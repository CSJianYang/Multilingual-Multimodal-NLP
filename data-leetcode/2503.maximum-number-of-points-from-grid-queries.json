[
    {
        "title": "Maximum Number of Points From Grid Queries",
        "question_content": "You are given an m x n integer matrix grid and an array queries of size k.\nFind an array answer of size k such that for each integer queries[i] you start in the top left cell of the matrix and repeat the following process:\n\n\tIf queries[i] is strictly greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any adjacent cell in all 4 directions: up, down, left, and right.\n\tOtherwise, you do not get any points, and you end this process.\n\nAfter the process, answer[i] is the maximum number of points you can get. Note that for each query you are allowed to visit the same cell multiple times.\nReturn the resulting array answer.\n&nbsp;\nExample 1:\n\nInput: grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2]\nOutput: [5,8,1]\nExplanation: The diagrams above show which cells we visit to get points for each query.\nExample 2:\n\nInput: grid = [[5,2,1],[1,1,2]], queries = [3]\nOutput: [0]\nExplanation: We can not get any points because the value of the top left cell is already greater than or equal to 3.\n\n&nbsp;\nConstraints:\n\n\tm == grid.length\n\tn == grid[i].length\n\t2 <= m, n <= 1000\n\t4 <= m * n <= 105\n\tk == queries.length\n\t1 <= k <= 104\n\t1 <= grid[i][j], queries[i] <= 106",
        "solutions": [
            {
                "id": 2899354,
                "title": "simple-solution-with-intuition-c-o-n-m-log-n-m-time-and-o-n-m-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Assume that there is just a single query, how would you solve this problem?\\n2. Thats easy, you would start a dfs/bfs from the top left cell and keep exploring the neighbours until the value is strictly lesser than the given query value.\\n3. The above task is achievable in linear time with respect to the number of cells because we visit each cell exactly once, how can you maintain this when we have multiple queries?\\n4. We sort the queries! If we visit a group of cells for a query value Q, we can visit the same set of cells perhaps more for any query value Q\\' which is greater than Q\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Process the queries from small to large. Add nodes to the graph such that their value is less than the current query.\\n2. Whenever a new node is added, add the corresponding edges in the graph.\\n*Note: each cell is represented in a 1-D format (Row major order)*\\n3. Rest of it must be clear if you know Union find.\\n# Complexity\\n- Time complexity: $$O(n*m*log(n*m))$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Similar problems\\n- https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/description/\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //UNION FIND\\n    vector<int> par,rank;\\n    int find(int a){\\n        if(par[a]==-1) return a;\\n        return par[a]=find(par[a]);\\n    }\\n    void uni(int a,int b){\\n        a=find(a),b=find(b);\\n        if(a==b) return;\\n        par[b]=a;\\n        rank[a]+=rank[b];\\n    }\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int n=grid.size(),m=grid[0].size();\\n        par=vector<int>(n*m+m,-1);\\n        rank=vector<int>(n*m+m,1);\\n        vector<vector<int>> nodes;\\n        //sort the nodes\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                nodes.push_back({grid[i][j],i,j});\\n            }\\n        }\\n        sort(nodes.begin(),nodes.end());\\n        //sort the queries\\n        vector<vector<int>> sortedQueries;\\n        for(int i=0;i<queries.size();i++){\\n            sortedQueries.push_back({queries[i],i});\\n        }\\n        sort(sortedQueries.begin(),sortedQueries.end());\\n        vector<int> ans(queries.size()), visited(n*m+m);\\n        int index = 0;\\n        vector<int> dx{0,1,0,-1}, dy{1,0,-1,0};\\n        for(auto &q:sortedQueries){\\n            //add nodes to graph\\n            while(index < n*m and nodes[index][0]<q[0]){\\n                int x = nodes[index][1], y = nodes[index][2];\\n                visited[x*m+y]=1;\\n                //add edges\\n                for(int z=0;z<4;z++){\\n                    int X = x+dx[z], Y = y+dy[z];\\n                    if(X>=0 and Y>=0 and X<n and Y<m and visited[X*m+Y]){\\n                        uni(X*m+Y, x*m+y);\\n                    }\\n                }\\n                index++;\\n            }\\n            if(visited[0])\\n                ans[q[1]]=rank[find(0)];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //UNION FIND\\n    vector<int> par,rank;\\n    int find(int a){\\n        if(par[a]==-1) return a;\\n        return par[a]=find(par[a]);\\n    }\\n    void uni(int a,int b){\\n        a=find(a),b=find(b);\\n        if(a==b) return;\\n        par[b]=a;\\n        rank[a]+=rank[b];\\n    }\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int n=grid.size(),m=grid[0].size();\\n        par=vector<int>(n*m+m,-1);\\n        rank=vector<int>(n*m+m,1);\\n        vector<vector<int>> nodes;\\n        //sort the nodes\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                nodes.push_back({grid[i][j],i,j});\\n            }\\n        }\\n        sort(nodes.begin(),nodes.end());\\n        //sort the queries\\n        vector<vector<int>> sortedQueries;\\n        for(int i=0;i<queries.size();i++){\\n            sortedQueries.push_back({queries[i],i});\\n        }\\n        sort(sortedQueries.begin(),sortedQueries.end());\\n        vector<int> ans(queries.size()), visited(n*m+m);\\n        int index = 0;\\n        vector<int> dx{0,1,0,-1}, dy{1,0,-1,0};\\n        for(auto &q:sortedQueries){\\n            //add nodes to graph\\n            while(index < n*m and nodes[index][0]<q[0]){\\n                int x = nodes[index][1], y = nodes[index][2];\\n                visited[x*m+y]=1;\\n                //add edges\\n                for(int z=0;z<4;z++){\\n                    int X = x+dx[z], Y = y+dy[z];\\n                    if(X>=0 and Y>=0 and X<n and Y<m and visited[X*m+Y]){\\n                        uni(X*m+Y, x*m+y);\\n                    }\\n                }\\n                index++;\\n            }\\n            if(visited[0])\\n                ans[q[1]]=rank[find(0)];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899355,
                "title": "bfs-prefix-sum",
                "content": "We do BFS search, exploring cells with minimum value first (we use min heap instead of queue for that).\\n\\nWe also track the maximum value so far (`cur`). A point collected at this cell requires a query larger than `cur`.\\n\\nWhen we process a query, we sum all points collected for values `[1...qs[i])`. A prefix sum is an efficient way to do this.\\n\\nWe can either use BIT, or do a line sweep in the end.\\n\\n## BIT\\n**C++**\\n```cpp\\nconstexpr int static n = 1000000;\\nint bt[n + 1] = {};\\nint prefix_sum(int i)\\n{\\n    int sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i))\\n        sum += bt[i];\\n    return sum;\\n}\\nvoid add(int i, int val)\\n{\\n    for (i = i + 1; i <= n; i += i & (-i))\\n        bt[i] += val;\\n}\\nint dirs[5] = { -1, 0, 1, 0, -1};\\nvector<int> maxPoints(vector<vector<int>>& g, vector<int>& qs) {\\n    int si = g.size(), sj = g[0].size(), cur = 1;\\n    priority_queue<array<int, 3>> pq;\\n    pq.push({-g[0][0], 0, 0});\\n    g[0][0] = 0;\\n    while(!pq.empty()) {\\n        auto [nval, i, j] = pq.top(); pq.pop();\\n        cur = max(cur, -nval);\\n        add(cur, 1);\\n        for (int d = 0; d < 4; ++d) {\\n            int x = i + dirs[d], y = j + dirs[d + 1];\\n            if (min(x, y) >= 0 && x < si && y < sj && g[x][y]) {\\n                pq.push({-g[x][y], x, y});\\n                g[x][y] = 0;\\n            }\\n        }\\n    }\\n    transform(begin(qs), end(qs), begin(qs), [&](int val){ return prefix_sum(val - 1); });\\n    return qs;\\n}\\n```\\n## Map\\n**C++**\\n```cpp\\nint dirs[5] = { -1, 0, 1, 0, -1};\\nvector<int> maxPoints(vector<vector<int>>& g, vector<int>& qs) {\\n    int si = g.size(), sj = g[0].size(), cur = 1;\\n    priority_queue<array<int, 3>> pq;\\n    map<int, int> psum;\\n    pq.push({-g[0][0], 0, 0});\\n    g[0][0] = 0;\\n    while(!pq.empty()) {\\n        auto [nval, i, j] = pq.top(); pq.pop();\\n        cur = max(cur, -nval);\\n        ++psum[cur];\\n        for (int d = 0; d < 4; ++d) {\\n            int x = i + dirs[d], y = j + dirs[d + 1];\\n            if (min(x, y) >= 0 && x < si && y < sj && g[x][y]) {\\n                pq.push({-g[x][y], x, y});\\n                g[x][y] = 0;\\n            }\\n        }\\n    }\\n    for (auto it = next(begin(psum)); it != end(psum); ++it) {\\n        it->second += prev(it)->second;\\n    }\\n    transform(begin(qs), end(qs), begin(qs), [&](int val){ \\n        auto it = psum.lower_bound(val);\\n        return it == begin(psum) ? 0 : prev(it)->second; \\n    });\\n    return qs;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nconstexpr int static n = 1000000;\\nint bt[n + 1] = {};\\nint prefix_sum(int i)\\n{\\n    int sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i))\\n        sum += bt[i];\\n    return sum;\\n}\\nvoid add(int i, int val)\\n{\\n    for (i = i + 1; i <= n; i += i & (-i))\\n        bt[i] += val;\\n}\\nint dirs[5] = { -1, 0, 1, 0, -1};\\nvector<int> maxPoints(vector<vector<int>>& g, vector<int>& qs) {\\n    int si = g.size(), sj = g[0].size(), cur = 1;\\n    priority_queue<array<int, 3>> pq;\\n    pq.push({-g[0][0], 0, 0});\\n    g[0][0] = 0;\\n    while(!pq.empty()) {\\n        auto [nval, i, j] = pq.top(); pq.pop();\\n        cur = max(cur, -nval);\\n        add(cur, 1);\\n        for (int d = 0; d < 4; ++d) {\\n            int x = i + dirs[d], y = j + dirs[d + 1];\\n            if (min(x, y) >= 0 && x < si && y < sj && g[x][y]) {\\n                pq.push({-g[x][y], x, y});\\n                g[x][y] = 0;\\n            }\\n        }\\n    }\\n    transform(begin(qs), end(qs), begin(qs), [&](int val){ return prefix_sum(val - 1); });\\n    return qs;\\n}\\n```\n```cpp\\nint dirs[5] = { -1, 0, 1, 0, -1};\\nvector<int> maxPoints(vector<vector<int>>& g, vector<int>& qs) {\\n    int si = g.size(), sj = g[0].size(), cur = 1;\\n    priority_queue<array<int, 3>> pq;\\n    map<int, int> psum;\\n    pq.push({-g[0][0], 0, 0});\\n    g[0][0] = 0;\\n    while(!pq.empty()) {\\n        auto [nval, i, j] = pq.top(); pq.pop();\\n        cur = max(cur, -nval);\\n        ++psum[cur];\\n        for (int d = 0; d < 4; ++d) {\\n            int x = i + dirs[d], y = j + dirs[d + 1];\\n            if (min(x, y) >= 0 && x < si && y < sj && g[x][y]) {\\n                pq.push({-g[x][y], x, y});\\n                g[x][y] = 0;\\n            }\\n        }\\n    }\\n    for (auto it = next(begin(psum)); it != end(psum); ++it) {\\n        it->second += prev(it)->second;\\n    }\\n    transform(begin(qs), end(qs), begin(qs), [&](int val){ \\n        auto it = psum.lower_bound(val);\\n        return it == begin(psum) ? 0 : prev(it)->second; \\n    });\\n    return qs;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2899594,
                "title": "python-3-solution-with-explanation-heap-binary-search-bfs",
                "content": "**Explanation**\\nIt is an graph based question we just have to get the full path from the top left (0,0).\\nAnd after that we have to just do a simple binary search (bisect_left or lower_bound) in the *order*\\nto get the result.\\n\\n\\n\\n\\n\\n\\n\\n\\tclass Solution:\\n\\t\\tdef maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n\\t\\t\\t#It is a simple questions based on the concept of graph\\n\\t\\t\\t#As we all know we can represent a matrix/grid into a graph\\n\\t\\t\\t#Then we can use the heap(min Heap) to get a perfect path.\\n\\t\\t\\t#Then we are using maxYet(means max till that index).\\n\\t\\t\\tm = len(grid)\\n\\t\\t\\tn = len(grid[0])\\n\\t\\t\\theap = [(grid[0][0], 0, 0)]\\n\\t\\t\\tv = {(0, 0)}\\n\\t\\t\\torder = []\\n\\t\\t\\twhile len(heap) > 0:\\n\\t\\t\\t\\tcurr, i, j = heapq.heappop(heap)\\n\\t\\t\\t\\torder.append(curr)\\n\\t\\t\\t\\tfor x, y in [(i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)]:\\n\\t\\t\\t\\t\\tif 0 <= x < m and 0 <= y < n and (x, y) not in v:\\n\\t\\t\\t\\t\\t\\tv.add((x, y))\\n\\t\\t\\t\\t\\t\\theapq.heappush(heap, (grid[x][y], x, y))\\n\\t\\t\\tmaxYet = -1\\n\\t\\t\\tfor i in range(len(order)):\\n\\t\\t\\t\\tmaxYet = max(maxYet, order[i])\\n\\t\\t\\t\\torder[i] = maxYet\\n\\t\\t\\tres = []\\n\\t\\t\\tfor q in queries:\\n\\t\\t\\t\\tres.append(bisect.bisect_left(order, q))\\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution:\\n\\t\\tdef maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n\\t\\t\\t#It is a simple questions based on the concept of graph\\n\\t\\t\\t#As we all know we can represent a matrix/grid into a graph\\n\\t\\t\\t#Then we can use the heap(min Heap) to get a perfect path.\\n\\t\\t\\t#Then we are using maxYet(means max till that index).\\n\\t\\t\\tm = len(grid)\\n\\t\\t\\tn = len(grid[0])\\n\\t\\t\\theap = [(grid[0][0], 0, 0)]\\n\\t\\t\\tv = {(0, 0)}",
                "codeTag": "Java"
            },
            {
                "id": 2899821,
                "title": "cleanest-implementation-min-priority-queue-c",
                "content": "# Approach \\n\\n1. manipulated query for my advantage i.e. put the query and index into a vector then sort it i.e. vector<pair<value,idx>>\\n2. after few hit and trial my observation lead me to explore smallest neighbour first from where I am right now which results creating a min priority queue of tuple<value, row, col>\\n3. now just pop element from min priority queue one by one till top element is smaller than current query\\n4. keep global count variable which will be increased every time when priority queue\\'s top element is smaller than query value\\n5. place that global count value into ans[idx], here idx is what I put into the vector in first point \\n\\n# Complexity\\n- Time complexity: KlogK + Klog(M*N)\\n- Space complexity: K + (M * N) + (M * N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        vector<pair<int,int>> vp;\\n        for(int i=0;i<queries.size();i++){\\n            vp.push_back({queries[i],i});\\n        }\\n        sort(vp.begin(),vp.end());\\n        \\n        vector<int> ans(queries.size());\\n        \\n        vector<vector<int>> vis(m , vector<int> (n,0));\\n        priority_queue<tuple<int,int,int>,vector<tuple<int,int,int>>,greater<tuple<int,int,int>>> pq;\\n        pq.push({grid[0][0],0,0}); vis[0][0] = 1;\\n        \\n        int cnt = 0;\\n        \\n        for(auto [val,idx] : vp){            \\n            while(pq.size()){\\n                auto [v,i,j] = pq.top();\\n                if(v >= val) break;\\n                else pq.pop(), cnt++;\\n                if(i-1 >= 0 and !vis[i-1][j]) pq.push({grid[i-1][j],i-1,j}), vis[i-1][j] = 1;\\n                if(j-1 >= 0 and !vis[i][j-1]) pq.push({grid[i][j-1],i,j-1}), vis[i][j-1] = 1;\\n                if(i+1 <  m and !vis[i+1][j]) pq.push({grid[i+1][j],i+1,j}), vis[i+1][j] = 1;\\n                if(j+1 <  n and !vis[i][j+1]) pq.push({grid[i][j+1],i,j+1}), vis[i][j+1] = 1;\\n            }   \\n            ans[idx] = cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        vector<pair<int,int>> vp;\\n        for(int i=0;i<queries.size();i++){\\n            vp.push_back({queries[i],i});\\n        }\\n        sort(vp.begin(),vp.end());\\n        \\n        vector<int> ans(queries.size());\\n        \\n        vector<vector<int>> vis(m , vector<int> (n,0));\\n        priority_queue<tuple<int,int,int>,vector<tuple<int,int,int>>,greater<tuple<int,int,int>>> pq;\\n        pq.push({grid[0][0],0,0}); vis[0][0] = 1;\\n        \\n        int cnt = 0;\\n        \\n        for(auto [val,idx] : vp){            \\n            while(pq.size()){\\n                auto [v,i,j] = pq.top();\\n                if(v >= val) break;\\n                else pq.pop(), cnt++;\\n                if(i-1 >= 0 and !vis[i-1][j]) pq.push({grid[i-1][j],i-1,j}), vis[i-1][j] = 1;\\n                if(j-1 >= 0 and !vis[i][j-1]) pq.push({grid[i][j-1],i,j-1}), vis[i][j-1] = 1;\\n                if(i+1 <  m and !vis[i+1][j]) pq.push({grid[i+1][j],i+1,j}), vis[i+1][j] = 1;\\n                if(j+1 <  n and !vis[i][j+1]) pq.push({grid[i][j+1],i,j+1}), vis[i][j+1] = 1;\\n            }   \\n            ans[idx] = cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899384,
                "title": "java-bfs-o-min-m-n-klogk",
                "content": "**Bruteforce solution**\\nFor each query find all points that are strictly less than the value of the current query, starting from the top-left of the grid.\\nThis can be done using BFS or DFS.\\n- Runtime complexity for a single query is O(m * n)\\n- Total runtime is O(m * n * k) => TLE (Time Limit Exceeded)\\n---\\n\\n\\n\\n**Key Observation**\\nQuery for some number consist of two types of points.\\n1. All points of a query with the lower number\\n2. Additional points that are connected to the lower value query\\n\\nIn other words: we have overlaping subproblems => while computing result for high value query we can reuse results from the low value queries.\\n\\n\\n&nbsp;\\nExample:\\n`queries = [3, 6]`\\nresult for `queries[0]` is all green points\\nresult for `queries[1]` is all green and blue points\\n![image.png](https://assets.leetcode.com/users/images/0e57e988-b307-4c91-8262-dcd596f3eedc_1670813840.8890803.png)\\n\\n---\\n\\n\\n\\n**Better solution**\\nBFS for each `query` and to avoid excessive computatoins reuse results from the previous BFS.\\n- We can reuse BFS results if we run BFSs from the smallest to the largest query. \\n    - For the very first BFS(for the smallest `query`) we get all the points connected to the top-left of the grid that are strictly less than `query`.\\n    - Also collect all the points we visit that are not striclty less that `query`. We will use them to start the next BFS for the second smallest query.\\n\\n&nbsp;\\nExample:\\n`queries = [3, 6]`\\nresult for `queries[0]` is all green and dark green points\\nresult for `queries[1]` is all green, dark green, blue and dark blue points\\n- Dark green point is the starting point for the first BFS (`nextBfs` in the code)\\n- Green points are the points that are discovered by the first BFS that are strictly less that the first `query`\\n- Dark blue points are the points that are discovered by the first BFS and that are not strictly less than the first `query`. It\\'s a starting points for the second BFS (`nextBfs` in the code)\\n- Blue points are points that are discovered by the second BFS that are strictly less than the first `query`\\n\\n![image.png](https://assets.leetcode.com/users/images/df4639bd-1894-4457-b054-70c1f9611d67_1670877983.4315987.png)\\n\\n**Algorithm**\\n```\\nfor \"small query\" to \"large query\":\\n    start new BFS using points from the previous BFS as a starting points\\n\\t\\tcount new points that are striclty less than current `query`\\n\\t\\tcollect new points in `nextBfs` that are not striclty less than current `query`, we will use those to start the next BFS\\n```\\n\\n\\n**Code**\\n```\\nint[][] DIRS = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };\\n\\npublic int[] maxPoints(int[][] g, int[] queries) {\\n    var M = g.length;\\n    var N = g[0].length;\\n    var queryToCount = new TreeMap<Integer, Integer>();\\n    for (var q : queries) {\\n        queryToCount.put(q, 0);\\n    }\\n\\n    var visited = new boolean[M][N];\\n    visited[0][0] = true;\\n    var nextBfs = new ArrayList<int[]>(List.of(new int[] { 0, 0 }));\\n\\n    var pre = 0;\\n    for (var query : queryToCount.keySet()) {\\n        if (g[0][0] >= query) {\\n            queryToCount.put(query, 0);\\n            continue;\\n        }\\n        // BFS\\n        var points = new ArrayList<int[]>(nextBfs);\\n        nextBfs = new ArrayList<>();\\n        int count = 0;\\n        while (points.size() > 0) {\\n            var nextPoints = new ArrayList<int[]>();\\n            for (var u : points) {\\n                if (g[u[0]][u[1]] >= query) {\\n                    nextBfs.add(u);\\n                    continue;\\n                }\\n                count++;\\n                for (var d : DIRS) {\\n                    int nr = u[0] + d[0];\\n                    int nc = u[1] + d[1];\\n                    if (nr >= 0 && nr < M && nc >= 0 && nc < N && !visited[nr][nc]) {\\n                        visited[nr][nc] = true;\\n                        if (g[nr][nc] < query) {\\n                            nextPoints.add(new int[] { nr, nc });\\n                        } else {\\n                            nextBfs.add(new int[] { nr, nc });\\n                        }\\n                    }\\n                }\\n            }\\n            points = nextPoints;\\n        }\\n        queryToCount.put(query, count + pre);\\n        pre += count;\\n    }\\n\\n    var res = new int[queries.length];\\n    for (int i = 0; i < res.length; i++) {\\n        res[i] = queryToCount.get(queries[i]);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nfor \"small query\" to \"large query\":\\n    start new BFS using points from the previous BFS as a starting points\\n\\t\\tcount new points that are striclty less than current `query`\\n\\t\\tcollect new points in `nextBfs` that are not striclty less than current `query`, we will use those to start the next BFS\\n```\n```\\nint[][] DIRS = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };\\n\\npublic int[] maxPoints(int[][] g, int[] queries) {\\n    var M = g.length;\\n    var N = g[0].length;\\n    var queryToCount = new TreeMap<Integer, Integer>();\\n    for (var q : queries) {\\n        queryToCount.put(q, 0);\\n    }\\n\\n    var visited = new boolean[M][N];\\n    visited[0][0] = true;\\n    var nextBfs = new ArrayList<int[]>(List.of(new int[] { 0, 0 }));\\n\\n    var pre = 0;\\n    for (var query : queryToCount.keySet()) {\\n        if (g[0][0] >= query) {\\n            queryToCount.put(query, 0);\\n            continue;\\n        }\\n        // BFS\\n        var points = new ArrayList<int[]>(nextBfs);\\n        nextBfs = new ArrayList<>();\\n        int count = 0;\\n        while (points.size() > 0) {\\n            var nextPoints = new ArrayList<int[]>();\\n            for (var u : points) {\\n                if (g[u[0]][u[1]] >= query) {\\n                    nextBfs.add(u);\\n                    continue;\\n                }\\n                count++;\\n                for (var d : DIRS) {\\n                    int nr = u[0] + d[0];\\n                    int nc = u[1] + d[1];\\n                    if (nr >= 0 && nr < M && nc >= 0 && nc < N && !visited[nr][nc]) {\\n                        visited[nr][nc] = true;\\n                        if (g[nr][nc] < query) {\\n                            nextPoints.add(new int[] { nr, nc });\\n                        } else {\\n                            nextBfs.add(new int[] { nr, nc });\\n                        }\\n                    }\\n                }\\n            }\\n            points = nextPoints;\\n        }\\n        queryToCount.put(query, count + pre);\\n        pre += count;\\n    }\\n\\n    var res = new int[queries.length];\\n    for (int i = 0; i < res.length; i++) {\\n        res[i] = queryToCount.get(queries[i]);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2901351,
                "title": "java-easy-to-understand-incremental-bfs-union-find-95-ms",
                "content": "IF YOU FIND THIS POST HELPFUL, PLEASE UPVOTE, THANKS!\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Direct BFS each query element will TLE, it\\'s not hard to notice, you can build result of larger query value on top of smaller ones.\\n- That gives us two intuitions, both require sort queries values ascending, we could then\\n    - Do BFS incrementally\\n    - Do Union Find and check set size of top left (2nd solution below)\\n    - No Duplicate processing in either case\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Save index and value of queries array before sort, in order to recover the correct order of results array to return\\n    - Then sort queries array by value\\n- Use PriorityQueue (MinHeap) for BFS, so that whenever we see a node with value greater than current query value, we know current query value is done and can move on to next\\n- Do prefix sum on result array, and recover it\\'s order\\n# Complexity\\n- Time complexity: O(mnlog(mn) + qlog(q))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    - Sort queries: qlog(q), let q be the length of queries array\\n    - BFS: mn * log(mn)\\n- Space complexity: o(mn+q)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    - queries related: O(q)\\n    - Q for bfs: mn\\n\\n# Code\\n```java\\nclass Solution {\\n    record Node(int i, int j, int v) {} // node coirdiantion in matrix\\n    record Cell(int i, int v) {} // node to store idx and value of queries array\\n\\n    private static int[] dr = new int[] {0,  0, 1, -1}; // delta row\\n    private static int[] dc = new int[] {1, -1, 0,  0}; // dleta col\\n\\n    public int[] maxPoints(int[][] grid, int[] QS) {\\n        // cause we need to sort queries array, we need to retain the original index for result\\n        Cell[] qs = new Cell[QS.length];\\n        for (int i = 0; i < qs.length; i++) qs[i] = new Cell(i, QS[i]);\\n        Arrays.sort(qs, (a, b) -> a.v - b.v); // sort to do bfs incrementally\\n\\n        // bfs with PriorityQueue, de-dup in place\\n        Queue<Node> q = new PriorityQueue<>((a, b) -> a.v - b.v);\\n        q.offer(new Node(0, 0, grid[0][0]));\\n        grid[0][0] = -1;\\n\\n         // incremental bfs\\n        int m = grid.length, n = grid[0].length, idx = 0;\\n        int[] res = new int[qs.length];\\n        for (int j = 0; j < qs.length; j++) { // iterate every query\\n            while (!q.isEmpty() && qs[j].v > q.peek().v) { // bfs all nodes smaller than query\\n                Node cur = q.poll();\\n                res[qs[j].i]++;\\n                for (int i = 0; i < 4; i++) { // expanding to neighbor nodes\\n                    int i2 = cur.i + dr[i], j2 = cur.j + dc[i];\\n                    if (i2 < 0 || j2 < 0 || i2 >= m || j2 >= n || grid[i2][j2] == -1) continue;\\n                    q.offer(new Node(i2, j2, grid[i2][j2]));\\n                    grid[i2][j2] = -1;\\n                }\\n            }\\n            if (j+1<qs.length) res[qs[j+1].i] = res[qs[j].i]; // build future result on top of current\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n\\n# Union Find\\nCredit of this solution goes to winner of this contest. Check this [video](https://www.youtube.com/watch?v=6rJYzfXIvdI) for detail.\\n[95ms](https://leetcode.com/problems/maximum-number-of-points-from-grid-queries/submissions/859166120/)\\n# Complexity\\n- Time complexity: O((mn+q) * log(mn+q))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    - Sort: (mn+q) * log(mn+q)\\n    - UF: m*n+q\\n- Space complexity: o(mn+q)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    - nodes and queries: mn+q => O(mn+q)\\n\\n```java\\nclass Solution {\\n    record Node(int i, int j, int v) {} // node coordination in matrix\\n    record Query(int i, int v) {} // nod\\n\\n    private static int[] dr = new int[] {0,  0, 1, -1}; // delta row\\n    private static int[] dc = new int[] {1, -1, 0,  0}; // dleta col\\n\\n    public int[] maxPoints(int[][] grid, int[] QS) {\\n        int m = grid.length, n = grid[0].length, SIZE = m * n;\\n        // cause we need to sort queries array, we need to retain the original index for result\\n        Query[] qs = new Query[QS.length];\\n        for (int i = 0; i < qs.length; i++) qs[i] = new Query(i, QS[i]);\\n        Arrays.sort(qs, (a, b) -> a.v - b.v); // sort to do bfs incrementally\\n\\n        // Generate all nodes, sort them by value\\n        Node[] nodes = new Node[SIZE];\\n        for (int i = 0; i < m; i++) for (int j = 0; j < n; j++)\\n            nodes[i*n+j] = new Node(i, j, grid[i][j]); // normal grid node\\n        Arrays.sort(nodes, (a, b) -> a.v - b.v);\\n\\n         // UF\\n         UF uf = new UF(SIZE);\\n        int[] res = new int[qs.length];\\n        for (int j = 0, i = 0; j < qs.length; j++) { // populate every query\\n            for (; i < SIZE && qs[j].v > nodes[i].v; i++) { // we only process nodes when it\\'s smaller than query value\\n                for (int k = 0; k < 4; k++) { // expanding to neighbor nodes\\n                    int i2 = nodes[i].i + dr[k], j2 = nodes[i].j + dc[k];\\n                    if (i2 >= 0 && j2 >= 0 && i2 < m && j2 < n && qs[j].v > grid[i2][j2])\\n                        uf.union(nodes[i].i*n+nodes[i].j, i2*n+j2);\\n                }\\n            }\\n            res[qs[j].i] = qs[j].v > grid[0][0] ? uf.size(0) : 0; // Get size of top left set, continue to next index\\n        }\\n\\n        return res;\\n    }\\n}\\n\\nclass UF {\\n    private int[] roots;\\n    UF (int n) {\\n        roots = new int[n];\\n        Arrays.fill(roots, -1); // negative means root is self, 1 means size 1\\n    }\\n\\n    public int find(int a) {\\n        if (roots[a] < 0) return a; // negative means root is self\\n        return roots[a] = find(roots[a]); // root not self, recursively find it\\n    }\\n\\n    public boolean union(int a, int b) {\\n        int ra = find(a), rb = find(b);\\n        if (ra == rb) return false;\\n    \\n        if (roots[ra] < roots[rb]) { // as size are negative, this means size ra > size rb, so ra will be parent\\n            roots[ra] += roots[rb];\\n            roots[rb] = ra;\\n        } else { // rb will be parent\\n            roots[rb] += roots[ra];\\n            roots[ra] = rb;\\n        }\\n        return true;\\n    }\\n\\n    public int size(int a) {\\n        return -roots[find(a)];\\n    }\\n}\\n```\\n# Brute Force, will TLE, for reference\\nTC: O(qmn)\\nSC: O(mn)\\n```java\\nclass Solution {\\n    private static int[][] dirs = new int[][] {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    int m, n;\\n    public int[] maxPoints(int[][] grid, int[] qs) {\\n        int len = qs.length;\\n        m = grid.length; n = grid[0].length;\\n        int[] res = new int[len];\\n\\n        for (int i = 0; i < len; i++) {\\n            boolean[][] visited = new boolean[m][n]; // restart dfs, so every round we need new visisted matrix\\n            res[i] = dfs(grid, qs[i], 0, 0, visited); // get ans for each query\\n        }\\n\\n        return res;\\n    }\\n\\n    private int dfs(int[][] grid, int x, int i, int j, boolean[][] visited) {\\n        if (x <= grid[i][j]) return 0; // able to go further no more\\n        \\n        int res = 1; // this grid is valid, so we get 1 point\\n        visited[i][j] = true;\\n        for (var dir : dirs) { // visit all neighbors, standard dfs\\n            int i2 = i + dir[0], j2 = j + dir[1];\\n            if (i2 < 0 || j2 < 0 || i2 >= m || j2 >= n || visited[i2][j2]) continue;\\n            res += dfs(grid, x, i2, j2, visited);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Union Find",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\nclass Solution {\\n    record Node(int i, int j, int v) {} // node coirdiantion in matrix\\n    record Cell(int i, int v) {} // node to store idx and value of queries array\\n\\n    private static int[] dr = new int[] {0,  0, 1, -1}; // delta row\\n    private static int[] dc = new int[] {1, -1, 0,  0}; // dleta col\\n\\n    public int[] maxPoints(int[][] grid, int[] QS) {\\n        // cause we need to sort queries array, we need to retain the original index for result\\n        Cell[] qs = new Cell[QS.length];\\n        for (int i = 0; i < qs.length; i++) qs[i] = new Cell(i, QS[i]);\\n        Arrays.sort(qs, (a, b) -> a.v - b.v); // sort to do bfs incrementally\\n\\n        // bfs with PriorityQueue, de-dup in place\\n        Queue<Node> q = new PriorityQueue<>((a, b) -> a.v - b.v);\\n        q.offer(new Node(0, 0, grid[0][0]));\\n        grid[0][0] = -1;\\n\\n         // incremental bfs\\n        int m = grid.length, n = grid[0].length, idx = 0;\\n        int[] res = new int[qs.length];\\n        for (int j = 0; j < qs.length; j++) { // iterate every query\\n            while (!q.isEmpty() && qs[j].v > q.peek().v) { // bfs all nodes smaller than query\\n                Node cur = q.poll();\\n                res[qs[j].i]++;\\n                for (int i = 0; i < 4; i++) { // expanding to neighbor nodes\\n                    int i2 = cur.i + dr[i], j2 = cur.j + dc[i];\\n                    if (i2 < 0 || j2 < 0 || i2 >= m || j2 >= n || grid[i2][j2] == -1) continue;\\n                    q.offer(new Node(i2, j2, grid[i2][j2]));\\n                    grid[i2][j2] = -1;\\n                }\\n            }\\n            if (j+1<qs.length) res[qs[j+1].i] = res[qs[j].i]; // build future result on top of current\\n        }\\n\\n        return res;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    record Node(int i, int j, int v) {} // node coordination in matrix\\n    record Query(int i, int v) {} // nod\\n\\n    private static int[] dr = new int[] {0,  0, 1, -1}; // delta row\\n    private static int[] dc = new int[] {1, -1, 0,  0}; // dleta col\\n\\n    public int[] maxPoints(int[][] grid, int[] QS) {\\n        int m = grid.length, n = grid[0].length, SIZE = m * n;\\n        // cause we need to sort queries array, we need to retain the original index for result\\n        Query[] qs = new Query[QS.length];\\n        for (int i = 0; i < qs.length; i++) qs[i] = new Query(i, QS[i]);\\n        Arrays.sort(qs, (a, b) -> a.v - b.v); // sort to do bfs incrementally\\n\\n        // Generate all nodes, sort them by value\\n        Node[] nodes = new Node[SIZE];\\n        for (int i = 0; i < m; i++) for (int j = 0; j < n; j++)\\n            nodes[i*n+j] = new Node(i, j, grid[i][j]); // normal grid node\\n        Arrays.sort(nodes, (a, b) -> a.v - b.v);\\n\\n         // UF\\n         UF uf = new UF(SIZE);\\n        int[] res = new int[qs.length];\\n        for (int j = 0, i = 0; j < qs.length; j++) { // populate every query\\n            for (; i < SIZE && qs[j].v > nodes[i].v; i++) { // we only process nodes when it\\'s smaller than query value\\n                for (int k = 0; k < 4; k++) { // expanding to neighbor nodes\\n                    int i2 = nodes[i].i + dr[k], j2 = nodes[i].j + dc[k];\\n                    if (i2 >= 0 && j2 >= 0 && i2 < m && j2 < n && qs[j].v > grid[i2][j2])\\n                        uf.union(nodes[i].i*n+nodes[i].j, i2*n+j2);\\n                }\\n            }\\n            res[qs[j].i] = qs[j].v > grid[0][0] ? uf.size(0) : 0; // Get size of top left set, continue to next index\\n        }\\n\\n        return res;\\n    }\\n}\\n\\nclass UF {\\n    private int[] roots;\\n    UF (int n) {\\n        roots = new int[n];\\n        Arrays.fill(roots, -1); // negative means root is self, 1 means size 1\\n    }\\n\\n    public int find(int a) {\\n        if (roots[a] < 0) return a; // negative means root is self\\n        return roots[a] = find(roots[a]); // root not self, recursively find it\\n    }\\n\\n    public boolean union(int a, int b) {\\n        int ra = find(a), rb = find(b);\\n        if (ra == rb) return false;\\n    \\n        if (roots[ra] < roots[rb]) { // as size are negative, this means size ra > size rb, so ra will be parent\\n            roots[ra] += roots[rb];\\n            roots[rb] = ra;\\n        } else { // rb will be parent\\n            roots[rb] += roots[ra];\\n            roots[ra] = rb;\\n        }\\n        return true;\\n    }\\n\\n    public int size(int a) {\\n        return -roots[find(a)];\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    private static int[][] dirs = new int[][] {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    int m, n;\\n    public int[] maxPoints(int[][] grid, int[] qs) {\\n        int len = qs.length;\\n        m = grid.length; n = grid[0].length;\\n        int[] res = new int[len];\\n\\n        for (int i = 0; i < len; i++) {\\n            boolean[][] visited = new boolean[m][n]; // restart dfs, so every round we need new visisted matrix\\n            res[i] = dfs(grid, qs[i], 0, 0, visited); // get ans for each query\\n        }\\n\\n        return res;\\n    }\\n\\n    private int dfs(int[][] grid, int x, int i, int j, boolean[][] visited) {\\n        if (x <= grid[i][j]) return 0; // able to go further no more\\n        \\n        int res = 1; // this grid is valid, so we get 1 point\\n        visited[i][j] = true;\\n        for (var dir : dirs) { // visit all neighbors, standard dfs\\n            int i2 = i + dir[0], j2 = j + dir[1];\\n            if (i2 < 0 || j2 < 0 || i2 >= m || j2 >= n || visited[i2][j2]) continue;\\n            res += dfs(grid, x, i2, j2, visited);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899424,
                "title": "c-python3-priority-queue-binary-search",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/8f409c5e220a4a1a1d7fdfbfcc1dcd24eeead232) for solutions of weekly 323. \\n\\n**Intuition**\\nHere I traverse the grid from the top-left cell. In the meantime, I use a priority queue to keep track of the largest value required to reach a cell. A separate counter is updated to indicate how many cells accessible prior to arriving at the current cell. This information is kept in an array via a value-count pair. \\nFor each queries, I binary search the array to find the number of cells whose corresponding value is strictly smaller than the given query. \\n**Implementation**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int m = grid.size(), n = grid[0].size(), dir[5] = {-1, 0, 1, 0, -1}, prefix = 0, prev = INT_MIN; \\n        vector<pair<int, int>> point; \\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq; \\n        pq.emplace(grid[0][0], 0, 0); \\n        grid[0][0] = 0; \\n        while (pq.size()) {\\n            auto [v, i, j] = pq.top(); pq.pop(); \\n            if (prev != v) point.emplace_back(prev, prefix); \\n            ++prefix; \\n            prev = v; \\n            for (int k = 0; k < 4; ++k) {\\n                int ii = i + dir[k], jj = j + dir[k+1]; \\n                if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj]) {\\n                    int vv = max(v, grid[ii][jj]); \\n                    pq.emplace(vv, ii, jj); \\n                    grid[ii][jj] = 0; \\n                }\\n            }\\n        }\\n        point.emplace_back(prev, prefix); \\n        vector<int> ans; \\n        for (auto& q : queries) {\\n            auto it = lower_bound(point.begin(), point.end(), make_pair(q, 0)); \\n            ans.push_back((--it)->second); \\n        }\\n        return ans; \\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        int m = grid.length, n = grid[0].length, prev = Integer.MIN_VALUE, prefix = 0; \\n        int[][] dir = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}}; \\n        Queue<int[]> pq = new PriorityQueue<>((a, b)->(a[0]-b[0])); \\n        pq.add(new int[]{grid[0][0], 0, 0}); \\n        grid[0][0] = 0; \\n        List<Integer> keys = new ArrayList(); \\n        List<Integer> vals = new ArrayList(); \\n        while (pq.size() > 0) {\\n            int[] elem = pq.remove(); \\n            int v = elem[0], i = elem[1], j = elem[2]; \\n            if (prev != v) {\\n                keys.add(prev); \\n                vals.add(prefix); \\n            }\\n            ++prefix; \\n            prev = v; \\n            for (var d : dir) {\\n                int ii = i + d[0], jj = j + d[1]; \\n                if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj] > 0) {\\n                    int vv = Math.max(v, grid[ii][jj]); \\n                    pq.add(new int[]{vv, ii, jj}); \\n                    grid[ii][jj] = 0; \\n                }\\n            }\\n        } \\n        keys.add(prev); \\n        vals.add(prefix); \\n        int sz = queries.length; \\n        int[] ans = new int[sz]; \\n        for (int i = 0; i < sz; ++i) {\\n            int k = Collections.binarySearch(keys, queries[i]);\\n            if (k < 0) k = -k-1; \\n            ans[i] = vals.get(k-1); \\n        }\\n        return ans; \\n    }\\n}\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        point = []\\n        prefix = 0 \\n        prev = -inf \\n        pq = [(grid[0][0], 0, 0)]\\n        grid[0][0] = 0 \\n        while pq: \\n            v, i, j = heappop(pq)\\n            if prev != v: point.append((prev, prefix))\\n            prefix += 1\\n            prev = v\\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj]: \\n                    vv = max(v, grid[ii][jj])\\n                    heappush(pq, (vv, ii, jj))\\n                    grid[ii][jj] = 0\\n        point.append((prev, prefix))\\n        ans = []\\n        for q in queries: \\n            i = bisect_left(point, q, key=lambda x: x[0]) - 1\\n            ans.append(point[i][1])\\n        return ans \\n```\\n**Complexity**\\nTime `O((MN+Q)logMN)`\\nSpace `O(MN+Q)`",
                "solutionTags": [
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int m = grid.size(), n = grid[0].size(), dir[5] = {-1, 0, 1, 0, -1}, prefix = 0, prev = INT_MIN; \\n        vector<pair<int, int>> point; \\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq; \\n        pq.emplace(grid[0][0], 0, 0); \\n        grid[0][0] = 0; \\n        while (pq.size()) {\\n            auto [v, i, j] = pq.top(); pq.pop(); \\n            if (prev != v) point.emplace_back(prev, prefix); \\n            ++prefix; \\n            prev = v; \\n            for (int k = 0; k < 4; ++k) {\\n                int ii = i + dir[k], jj = j + dir[k+1]; \\n                if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj]) {\\n                    int vv = max(v, grid[ii][jj]); \\n                    pq.emplace(vv, ii, jj); \\n                    grid[ii][jj] = 0; \\n                }\\n            }\\n        }\\n        point.emplace_back(prev, prefix); \\n        vector<int> ans; \\n        for (auto& q : queries) {\\n            auto it = lower_bound(point.begin(), point.end(), make_pair(q, 0)); \\n            ans.push_back((--it)->second); \\n        }\\n        return ans; \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        int m = grid.length, n = grid[0].length, prev = Integer.MIN_VALUE, prefix = 0; \\n        int[][] dir = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}}; \\n        Queue<int[]> pq = new PriorityQueue<>((a, b)->(a[0]-b[0])); \\n        pq.add(new int[]{grid[0][0], 0, 0}); \\n        grid[0][0] = 0; \\n        List<Integer> keys = new ArrayList(); \\n        List<Integer> vals = new ArrayList(); \\n        while (pq.size() > 0) {\\n            int[] elem = pq.remove(); \\n            int v = elem[0], i = elem[1], j = elem[2]; \\n            if (prev != v) {\\n                keys.add(prev); \\n                vals.add(prefix); \\n            }\\n            ++prefix; \\n            prev = v; \\n            for (var d : dir) {\\n                int ii = i + d[0], jj = j + d[1]; \\n                if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj] > 0) {\\n                    int vv = Math.max(v, grid[ii][jj]); \\n                    pq.add(new int[]{vv, ii, jj}); \\n                    grid[ii][jj] = 0; \\n                }\\n            }\\n        } \\n        keys.add(prev); \\n        vals.add(prefix); \\n        int sz = queries.length; \\n        int[] ans = new int[sz]; \\n        for (int i = 0; i < sz; ++i) {\\n            int k = Collections.binarySearch(keys, queries[i]);\\n            if (k < 0) k = -k-1; \\n            ans[i] = vals.get(k-1); \\n        }\\n        return ans; \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        point = []\\n        prefix = 0 \\n        prev = -inf \\n        pq = [(grid[0][0], 0, 0)]\\n        grid[0][0] = 0 \\n        while pq: \\n            v, i, j = heappop(pq)\\n            if prev != v: point.append((prev, prefix))\\n            prefix += 1\\n            prev = v\\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj]: \\n                    vv = max(v, grid[ii][jj])\\n                    heappush(pq, (vv, ii, jj))\\n                    grid[ii][jj] = 0\\n        point.append((prev, prefix))\\n        ans = []\\n        for q in queries: \\n            i = bisect_left(point, q, key=lambda x: x[0]) - 1\\n            ans.append(point[i][1])\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899763,
                "title": "easy-to-understand-dsu-offline-queries-c-code",
                "content": "# Intuition\\nWhenever I see queries which are somewhat related to some logical operation like >, >=, < and <=, the first thing that hits my mind is offline queries(manipulating arrangements of queires for our advantage).\\n\\n# Approach\\n$$Part 1:$$\\n\\nI treated the grid as a graph where every cell is a node and there is an edge between adjacent cells.\\n\\nI stored all the edges in a vector and sorted all the edges based on max(grid[u],grid[v]).\\n\\nHere I am treating the grid as a long array which is row wise arranged.\\n\\n$$Part 2:$$\\n\\nI created a Disjoint set union object.\\nBut why?\\nTo add edges.\\n\\nThe questions say:\\n\\u201CIf queries[i] is strictly greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any adjacent cell in all 4 directions: up, down, left, and right.\\u201D\\n\\nSo we will use this DSU object to add edges in ascending order of max(grid[u], grid[v]), where edge is between u and v.\\n\\n$$Part 3:$$\\n\\nNow I sorted the queries also to process them in ascending order.\\n\\n$$Part 4:$$\\n\\nAs all queries are sorted, Im moving forward with each query and adding edges to DSU in ascending order based on max(grid[u], grid[v]).\\n\\nFor the answer of the current query, I get the size of component whose parent is grid[0][0].\\n\\nWhy??\\nBecause we start our traversal from top left cell of the grid.\\n\\nAnd if grid[0][0] > query[i]\\nWe fill answer as 0.\\n\\n# Complexity\\n- Time complexity:\\nO(n* m * log(n*m) + k)\\n\\n- Space complexity:\\nO(n*m  + k)\\n\\nFor dry run and code explanation you check this video:\\n<iframe width=\"450\" height=\"260\" src=\"https://www.youtube.com/embed/4XFSx1j68gs\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tstruct edge {\\n\\t\\tint u;\\n\\t\\tint v;\\n\\t\\tint maxVal;\\n\\t\\tedge(int a, int b, int c) {\\n\\t\\t\\tu = a;\\n\\t\\t\\tv = b;\\n\\t\\t\\tmaxVal = c;\\n\\t\\t}\\n\\t};\\n\\n\\tclass DSU {\\n\\tprivate:\\n\\t\\tvector<int> parent;\\n\\t\\tvector<int> size;\\n\\tpublic:\\n\\t\\tDSU(int n) {\\n\\t\\t\\tparent.resize(n);\\n\\t\\t\\tsize.resize(n);\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tparent[i] = i;\\n\\t\\t\\t}\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsize[i] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint find(int x) {\\n\\t\\t\\tif (parent[x] == x)\\n\\t\\t\\t\\treturn x;\\n\\t\\t\\tparent[x] = find(parent[x]);\\n\\t\\t\\treturn parent[x];\\n\\n\\t\\t}\\n\\t\\tvoid unions(int x, int y) {\\n\\t\\t\\tint x_rep = find(x);\\n\\t\\t\\tint y_rep = find(y);\\n\\t\\t\\tif (x_rep == y_rep)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tparent[y_rep] = x_rep;\\n\\t\\t\\tsize[x_rep] += size[y_rep];\\n\\t\\t}\\n\\t\\tint getSize(int x) {\\n\\t\\t\\treturn size[find(x)];\\n\\t\\t}\\n\\t};\\n\\n\\tbool isWithinGrid(int x, int y, int& r, int& c)\\n\\t{\\n\\t\\tif (x < 0 || y < 0)\\n\\t\\t\\treturn false;\\n\\t\\tif (x >= r || y >= c)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}\\n\\n\\tvoid processEdges(vector<vector<int>>& grid, vector<edge>& allEdges)\\n\\t{\\n\\t\\tint n = grid.size();\\n\\t\\tint m = grid[0].size();\\n\\t\\tint u, v;\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tfor (int j = 0; j < m; ++j) {\\n\\t\\t\\t\\tu = i * m + j;\\n\\t\\t\\t\\tif (isWithinGrid(i, j + 1, n, m)) {\\n\\t\\t\\t\\t\\tv = i * m + j + 1;\\n\\t\\t\\t\\t\\tedge temp(u, v, max(grid[i][j], grid[i][j + 1]));\\n\\t\\t\\t\\t\\tallEdges.push_back(temp);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (isWithinGrid(i + 1, j, n, m)) {\\n\\t\\t\\t\\t\\tv = (i + 1) * m + j;\\n\\t\\t\\t\\t\\tedge temp(u, v, max(grid[i][j], grid[i + 1][j]));\\n\\t\\t\\t\\t\\tallEdges.push_back(temp);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n//Part 1:\\n\\t\\tvector<edge> allEdges;\\n\\t\\tint n = grid.size();\\n\\t\\tint m = grid[0].size();\\n\\t\\tprocessEdges(grid, allEdges);\\n\\t\\tsort(begin(allEdges), end(allEdges),\\n\\t\\t     [](edge a, edge b)\\n\\t\\t{\\n\\t\\t\\treturn a.maxVal < b.maxVal;\\n\\t\\t});\\n\\n//Part 2:\\n\\t\\tDSU ufobj(n * m);\\n\\n//Part 3:\\n\\t\\tvector<pair<int, int>> q;\\n\\t\\tfor (int i = 0; i < queries.size(); ++i)\\n\\t\\t\\tq.push_back({queries[i], i});\\n\\n\\t\\tsort(begin(q), end(q));\\n\\n//Part 4:\\n\\t\\tvector<int> ans(queries.size(), 0);\\n\\t\\tint edPointer = 0;\\n\\n\\t\\tfor (auto& currQ : q)\\n\\t\\t{\\n\\t\\t\\twhile (edPointer < allEdges.size() && allEdges[edPointer].maxVal < currQ.first)\\n\\t\\t\\t{\\n\\t\\t\\t\\tufobj.unions(allEdges[edPointer].u, allEdges[edPointer].v);\\n\\t\\t\\t\\tedPointer++;\\n\\t\\t\\t}\\n\\t\\t\\tif (grid[0][0] < currQ.first)\\n\\t\\t\\t\\tans[currQ.second] = ufobj.getSize(0);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n\\nUpvote if you found this helpful !",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tstruct edge {\\n\\t\\tint u;\\n\\t\\tint v;\\n\\t\\tint maxVal;\\n\\t\\tedge(int a, int b, int c) {\\n\\t\\t\\tu = a;\\n\\t\\t\\tv = b;\\n\\t\\t\\tmaxVal = c;\\n\\t\\t}\\n\\t};\\n\\n\\tclass DSU {\\n\\tprivate:\\n\\t\\tvector<int> parent;\\n\\t\\tvector<int> size;\\n\\tpublic:\\n\\t\\tDSU(int n) {\\n\\t\\t\\tparent.resize(n);\\n\\t\\t\\tsize.resize(n);\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tparent[i] = i;\\n\\t\\t\\t}\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsize[i] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint find(int x) {\\n\\t\\t\\tif (parent[x] == x)\\n\\t\\t\\t\\treturn x;\\n\\t\\t\\tparent[x] = find(parent[x]);\\n\\t\\t\\treturn parent[x];\\n\\n\\t\\t}\\n\\t\\tvoid unions(int x, int y) {\\n\\t\\t\\tint x_rep = find(x);\\n\\t\\t\\tint y_rep = find(y);\\n\\t\\t\\tif (x_rep == y_rep)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tparent[y_rep] = x_rep;\\n\\t\\t\\tsize[x_rep] += size[y_rep];\\n\\t\\t}\\n\\t\\tint getSize(int x) {\\n\\t\\t\\treturn size[find(x)];\\n\\t\\t}\\n\\t};\\n\\n\\tbool isWithinGrid(int x, int y, int& r, int& c)\\n\\t{\\n\\t\\tif (x < 0 || y < 0)\\n\\t\\t\\treturn false;\\n\\t\\tif (x >= r || y >= c)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}\\n\\n\\tvoid processEdges(vector<vector<int>>& grid, vector<edge>& allEdges)\\n\\t{\\n\\t\\tint n = grid.size();\\n\\t\\tint m = grid[0].size();\\n\\t\\tint u, v;\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tfor (int j = 0; j < m; ++j) {\\n\\t\\t\\t\\tu = i * m + j;\\n\\t\\t\\t\\tif (isWithinGrid(i, j + 1, n, m)) {\\n\\t\\t\\t\\t\\tv = i * m + j + 1;\\n\\t\\t\\t\\t\\tedge temp(u, v, max(grid[i][j], grid[i][j + 1]));\\n\\t\\t\\t\\t\\tallEdges.push_back(temp);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (isWithinGrid(i + 1, j, n, m)) {\\n\\t\\t\\t\\t\\tv = (i + 1) * m + j;\\n\\t\\t\\t\\t\\tedge temp(u, v, max(grid[i][j], grid[i + 1][j]));\\n\\t\\t\\t\\t\\tallEdges.push_back(temp);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n//Part 1:\\n\\t\\tvector<edge> allEdges;\\n\\t\\tint n = grid.size();\\n\\t\\tint m = grid[0].size();\\n\\t\\tprocessEdges(grid, allEdges);\\n\\t\\tsort(begin(allEdges), end(allEdges),\\n\\t\\t     [](edge a, edge b)\\n\\t\\t{\\n\\t\\t\\treturn a.maxVal < b.maxVal;\\n\\t\\t});\\n\\n//Part 2:\\n\\t\\tDSU ufobj(n * m);\\n\\n//Part 3:\\n\\t\\tvector<pair<int, int>> q;\\n\\t\\tfor (int i = 0; i < queries.size(); ++i)\\n\\t\\t\\tq.push_back({queries[i], i});\\n\\n\\t\\tsort(begin(q), end(q));\\n\\n//Part 4:\\n\\t\\tvector<int> ans(queries.size(), 0);\\n\\t\\tint edPointer = 0;\\n\\n\\t\\tfor (auto& currQ : q)\\n\\t\\t{\\n\\t\\t\\twhile (edPointer < allEdges.size() && allEdges[edPointer].maxVal < currQ.first)\\n\\t\\t\\t{\\n\\t\\t\\t\\tufobj.unions(allEdges[edPointer].u, allEdges[edPointer].v);\\n\\t\\t\\t\\tedPointer++;\\n\\t\\t\\t}\\n\\t\\t\\tif (grid[0][0] < currQ.first)\\n\\t\\t\\t\\tans[currQ.second] = ufobj.getSize(0);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899740,
                "title": "simple-greedy-bfs-c-priority-queue-o-m-n-log-m-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo we want to get the max score ,it would be helpful if we in some way choose smaller values when we have option . \\nLooking at the problems we know we have to do **traversal** using bfs or dfs and that too **greedily**.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will find the **best path greedily** prioritising the **smaller** values using min heap,we will use min heap for doing bfs traversal .\\nOnce we get out path we will get **copy** of queries and **sort** them in **increasing** order, we start from 1st value and check if we can go through our path and increment our count , if we can\\'t we go to next value of sorted query and so on.\\n![Screenshot (790).png](https://assets.leetcode.com/users/images/e0f3c876-0ec6-47e6-983c-34d6b865ec39_1670733595.2496676.png)\\n\\nWe use map to store the **score**(count) for each value\\n\\n# Complexity\\n- Time complexity: O((m*n)log(m*n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m*n) -- path and visited array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        //I start greedy bfs \\n        \\n        vector<int>temp = queries;\\n        sort(temp.begin(),temp.end());\\n        \\n        map<int,int>sol;\\n         \\n        int value = grid[0][0];\\n\\n       // we will priroitise smaller values\\n        priority_queue<pair<int,pair<int,int>>>bfs;\\n        bfs.push({value,{0,0}});\\n        int j = 0;\\n        \\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m));\\n        vis[0][0]++;\\n         \\n        vector<int>path;\\n        \\n        while(!bfs.empty()){\\n             int c = bfs.size();\\n              \\n                 pair<int,pair<int,int>>cur = bfs.top();\\n                 bfs.pop();\\n                 \\n                 int x = cur.second.first;\\n                 int y = cur.second.second;\\n                 int val = abs(cur.first);\\n                 \\n                 path.push_back(val);\\n                 \\n                 //move in all the four direction\\n                 if((x-1)>=0){\\n                     if(vis[x-1][y] == 0){\\n                         vis[x-1][y]++;\\n                         int cur_val = grid[x-1][y];\\n                         bfs.push({-cur_val,{x-1,y}});\\n                     }\\n                 }\\n                 \\n                 if((x+1)<n){\\n                     if(vis[x+1][y] == 0){\\n                         vis[x+1][y]++;\\n                         int cur_val = grid[x+1][y];\\n                         bfs.push({-cur_val,{x+1,y}});\\n                     }\\n                 }\\n                 \\n                 if((y-1)>=0){\\n                     if(vis[x][y-1] == 0){\\n                         vis[x][y-1]++;\\n                         int cur_val = grid[x][y-1];\\n                         bfs.push({-cur_val,{x,y-1}});\\n                     }\\n                 }\\n                 \\n                 if((y+1)<m){\\n                     if(vis[x][y+1] == 0){\\n                         vis[x][y+1]++;\\n                         int cur_val = grid[x][y+1];\\n                         bfs.push({-cur_val,{x,y+1}});\\n                     }\\n                 }\\n             \\n        }\\n         \\n        \\n        //we will travese along the path and check if there is any\\n        //query which allow us to continue through path\\n\\n        int count = 0;\\n        for(int i=0;i<path.size();){\\n            \\n            if(temp[j]>path[i]){\\n                count++;\\n                if(i == path.size()-1){\\n                    sol[temp[j]] =  count;\\n                }\\n                i++;\\n            }\\n            else{\\n                sol[temp[j]] = count;\\n                j++;\\n            }\\n            if(j == temp.size())break;\\n        }\\n        \\n       //case when we have already traversed through the path with many queries remaining\\n        while(j<temp.size()){\\n            sol[temp[j]] = count;\\n            j++;\\n        }\\n        \\n        vector<int>ans;\\n        for(auto&x:queries){\\n            ans.push_back(sol[x]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        //I start greedy bfs \\n        \\n        vector<int>temp = queries;\\n        sort(temp.begin(),temp.end());\\n        \\n        map<int,int>sol;\\n         \\n        int value = grid[0][0];\\n\\n       // we will priroitise smaller values\\n        priority_queue<pair<int,pair<int,int>>>bfs;\\n        bfs.push({value,{0,0}});\\n        int j = 0;\\n        \\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m));\\n        vis[0][0]++;\\n         \\n        vector<int>path;\\n        \\n        while(!bfs.empty()){\\n             int c = bfs.size();\\n              \\n                 pair<int,pair<int,int>>cur = bfs.top();\\n                 bfs.pop();\\n                 \\n                 int x = cur.second.first;\\n                 int y = cur.second.second;\\n                 int val = abs(cur.first);\\n                 \\n                 path.push_back(val);\\n                 \\n                 //move in all the four direction\\n                 if((x-1)>=0){\\n                     if(vis[x-1][y] == 0){\\n                         vis[x-1][y]++;\\n                         int cur_val = grid[x-1][y];\\n                         bfs.push({-cur_val,{x-1,y}});\\n                     }\\n                 }\\n                 \\n                 if((x+1)<n){\\n                     if(vis[x+1][y] == 0){\\n                         vis[x+1][y]++;\\n                         int cur_val = grid[x+1][y];\\n                         bfs.push({-cur_val,{x+1,y}});\\n                     }\\n                 }\\n                 \\n                 if((y-1)>=0){\\n                     if(vis[x][y-1] == 0){\\n                         vis[x][y-1]++;\\n                         int cur_val = grid[x][y-1];\\n                         bfs.push({-cur_val,{x,y-1}});\\n                     }\\n                 }\\n                 \\n                 if((y+1)<m){\\n                     if(vis[x][y+1] == 0){\\n                         vis[x][y+1]++;\\n                         int cur_val = grid[x][y+1];\\n                         bfs.push({-cur_val,{x,y+1}});\\n                     }\\n                 }\\n             \\n        }\\n         \\n        \\n        //we will travese along the path and check if there is any\\n        //query which allow us to continue through path\\n\\n        int count = 0;\\n        for(int i=0;i<path.size();){\\n            \\n            if(temp[j]>path[i]){\\n                count++;\\n                if(i == path.size()-1){\\n                    sol[temp[j]] =  count;\\n                }\\n                i++;\\n            }\\n            else{\\n                sol[temp[j]] = count;\\n                j++;\\n            }\\n            if(j == temp.size())break;\\n        }\\n        \\n       //case when we have already traversed through the path with many queries remaining\\n        while(j<temp.size()){\\n            sol[temp[j]] = count;\\n            j++;\\n        }\\n        \\n        vector<int>ans;\\n        for(auto&x:queries){\\n            ans.push_back(sol[x]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900203,
                "title": "simple-c-code-bfs-min-priority-queue",
                "content": "```\\nclass Solution{\\npublic:\\n    \\n\\t//to check if  current cell lie in the matrix or not\\n    bool valid(int i,int j,int n,int m){\\n        return i>=0 and j>=0 and i<n and j<m;\\n    }\\n    \\n    vector<int> maxPoints(vector<vector<int>>& nums,vector<int>& queries){\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        \\n\\t\\t// ans vector\\n        vector<int> ans(queries.size());\\n\\t\\t\\n\\t\\t//queries are stored with their index so that sorting can be done without loosing their initial position\\n        vector<pair<int,int>> q(queries.size());\\n\\t\\t\\n        for(int i=0;i<queries.size();i++){\\n            q[i] = { queries[i] , i };\\n        }\\n\\t\\tsort(q.begin(),q.end());\\n\\t\\t\\n\\t\\t//visited matrix\\n        vector<vector<int>> vis(n,vector<int>(m,-1));\\n        \\n\\t\\t//min priority queue storing {  value ,  row  ,  col  } \\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,\\n            greater<pair<int,pair<int,int>>>> pq;\\n        \\n\\t\\t//starting with ( 0 ,  0 ) cell \\n        pq.push({nums[0][0],{0,0}});\\n        vis[0][0] = 1;\\n        \\n\\t\\t//vector for traversal in four directions \\n        int dx[] = {0,0,1,-1};\\n        int dy[] = {1,-1,0,0};\\n        \\n\\t\\t//count to store ans for each query \\n        int count = 0;\\n        \\n\\t\\t//traversing for each query \\n        for(int i=0;i<queries.size();i++){\\n\\t\\t\\t\\n\\t\\t\\t// if top element if less than my query value then it can be count for curr query\\n            while(pq.size() and pq.top().first < q[i].first){\\n                count++;\\n                \\n                int x = pq.top().second.first;\\n                int y = pq.top().second.second;\\n                pq.pop();\\n                \\n\\t\\t\\t\\t//visiting all four directions \\n                for(int j=0;j<4;j++){\\n                    \\n                    int newx = dx[j] + x;\\n                    int newy = dy[j] + y;\\n                    \\n\\t\\t\\t\\t\\t//if new cell is valid and not visited earlier then push it into priority queue\\n                    if(valid(newx,newy,n,m) and vis[newx][newy]==-1){\\n                        vis[newx][newy] = 1;\\n                        pq.push({nums[newx][newy],{newx,newy}});\\n                    }\\n                }\\n            }\\n            \\n\\t\\t\\t//storing count in its original index \\n            ans[q[i].second] = count;\\n            \\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n****\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)",
                    "Matrix"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    \\n\\t//to check if  current cell lie in the matrix or not\\n    bool valid(int i,int j,int n,int m){\\n        return i>=0 and j>=0 and i<n and j<m;\\n    }\\n    \\n    vector<int> maxPoints(vector<vector<int>>& nums,vector<int>& queries){\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        \\n\\t\\t// ans vector\\n        vector<int> ans(queries.size());\\n\\t\\t\\n\\t\\t//queries are stored with their index so that sorting can be done without loosing their initial position\\n        vector<pair<int,int>> q(queries.size());\\n\\t\\t\\n        for(int i=0;i<queries.size();i++){\\n            q[i] = { queries[i] , i };\\n        }\\n\\t\\tsort(q.begin(),q.end());\\n\\t\\t\\n\\t\\t//visited matrix\\n        vector<vector<int>> vis(n,vector<int>(m,-1));\\n        \\n\\t\\t//min priority queue storing {  value ,  row  ,  col  } \\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,\\n            greater<pair<int,pair<int,int>>>> pq;\\n        \\n\\t\\t//starting with ( 0 ,  0 ) cell \\n        pq.push({nums[0][0],{0,0}});\\n        vis[0][0] = 1;\\n        \\n\\t\\t//vector for traversal in four directions \\n        int dx[] = {0,0,1,-1};\\n        int dy[] = {1,-1,0,0};\\n        \\n\\t\\t//count to store ans for each query \\n        int count = 0;\\n        \\n\\t\\t//traversing for each query \\n        for(int i=0;i<queries.size();i++){\\n\\t\\t\\t\\n\\t\\t\\t// if top element if less than my query value then it can be count for curr query\\n            while(pq.size() and pq.top().first < q[i].first){\\n                count++;\\n                \\n                int x = pq.top().second.first;\\n                int y = pq.top().second.second;\\n                pq.pop();\\n                \\n\\t\\t\\t\\t//visiting all four directions \\n                for(int j=0;j<4;j++){\\n                    \\n                    int newx = dx[j] + x;\\n                    int newy = dy[j] + y;\\n                    \\n\\t\\t\\t\\t\\t//if new cell is valid and not visited earlier then push it into priority queue\\n                    if(valid(newx,newy,n,m) and vis[newx][newy]==-1){\\n                        vis[newx][newy] = 1;\\n                        pq.push({nums[newx][newy],{newx,newy}});\\n                    }\\n                }\\n            }\\n            \\n\\t\\t\\t//storing count in its original index \\n            ans[q[i].second] = count;\\n            \\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n****\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899549,
                "title": "video-explanation-building-from-scratch-with-intuition",
                "content": "## Explanation\\n\\nhttps://www.youtube.com/watch?v=c_62SyDyyVo\\n\\n[Click here if the preview doesn\\'t work](https://www.youtube.com/watch?v=c_62SyDyyVo)\\n\\n## Code\\n```\\n#define pii pair<int, int>\\n#define F first\\n#define S second\\n\\nclass Solution {\\n    struct Node {\\n        int row, col;\\n        int val;\\n        \\n        Node (int _r, int _c, int _val) : row(_r), col(_c), val(_val) {}\\n        \\n        bool operator < (const Node& rhs) const {\\n            if (val != rhs.val) return val < rhs.val;\\n            if (row != rhs.row) return row < rhs.row;\\n            return col < rhs.col;\\n        }\\n    };\\n    \\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int q = queries.size();\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        \\n        vector<pii> queries_and_ind;\\n        for (int j = 0; j < q; j ++) {\\n            queries_and_ind.push_back({queries[j], j});\\n        }\\n        sort (queries_and_ind.begin(), queries_and_ind.end());\\n        \\n        vector<int> result(q);\\n        vector<vector<bool>> visited (rows, vector<bool>(cols, false));\\n        int total_visited = 0;\\n        \\n        set<Node> nodes;\\n        nodes.insert(Node(0, 0, grid[0][0]));\\n        visited[0][0] = true;\\n        \\n        for (int j = 0; j < q; j ++) {\\n            int mx_val = queries_and_ind[j].F;\\n            int ind = queries_and_ind[j].S;\\n            \\n            while (!nodes.empty() && nodes.begin() -> val < mx_val) {\\n                Node node = *nodes.begin();\\n                nodes.erase (nodes.begin());\\n                total_visited ++;\\n                \\n                vector<vector<int>> neighbors = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n                for (auto i : neighbors) {\\n                    int r = node.row + i[0];\\n                    int c = node.col + i[1];\\n                    \\n                    bool is_valid_cell = (r >= 0 && r < rows) && (c >= 0 && c < cols);\\n                    if (!is_valid_cell || visited[r][c]) continue;\\n                    \\n                    visited[r][c] = true;\\n                    nodes.insert(Node(r, c, grid[r][c]));\\n                }\\n            }\\n            \\n            result[ind] = total_visited;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define pii pair<int, int>\\n#define F first\\n#define S second\\n\\nclass Solution {\\n    struct Node {\\n        int row, col;\\n        int val;\\n        \\n        Node (int _r, int _c, int _val) : row(_r), col(_c), val(_val) {}\\n        \\n        bool operator < (const Node& rhs) const {\\n            if (val != rhs.val) return val < rhs.val;\\n            if (row != rhs.row) return row < rhs.row;\\n            return col < rhs.col;\\n        }\\n    };\\n    \\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int q = queries.size();\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        \\n        vector<pii> queries_and_ind;\\n        for (int j = 0; j < q; j ++) {\\n            queries_and_ind.push_back({queries[j], j});\\n        }\\n        sort (queries_and_ind.begin(), queries_and_ind.end());\\n        \\n        vector<int> result(q);\\n        vector<vector<bool>> visited (rows, vector<bool>(cols, false));\\n        int total_visited = 0;\\n        \\n        set<Node> nodes;\\n        nodes.insert(Node(0, 0, grid[0][0]));\\n        visited[0][0] = true;\\n        \\n        for (int j = 0; j < q; j ++) {\\n            int mx_val = queries_and_ind[j].F;\\n            int ind = queries_and_ind[j].S;\\n            \\n            while (!nodes.empty() && nodes.begin() -> val < mx_val) {\\n                Node node = *nodes.begin();\\n                nodes.erase (nodes.begin());\\n                total_visited ++;\\n                \\n                vector<vector<int>> neighbors = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n                for (auto i : neighbors) {\\n                    int r = node.row + i[0];\\n                    int c = node.col + i[1];\\n                    \\n                    bool is_valid_cell = (r >= 0 && r < rows) && (c >= 0 && c < cols);\\n                    if (!is_valid_cell || visited[r][c]) continue;\\n                    \\n                    visited[r][c] = true;\\n                    nodes.insert(Node(r, c, grid[r][c]));\\n                }\\n            }\\n            \\n            result[ind] = total_visited;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906042,
                "title": "using-disjoint-set-union-by-size",
                "content": "# Intuition\\n- We keep on connecting all the nodes whose value is less than the query value on that point.\\n- After we go to the next query value, we do not need to start from beginning since we already have couple of connected nodes because of the previous query value\\n- The total no. of nodes connected will be the answer for that query value\\n\\n\\nIf you do not know about Disjoint Set, then watch this video by Striver : [https://www.youtube.com/watch?v=aBxjDBC4M1U&ab_channel=takeUforward]()\\n \\n\\n\\nIf you like it, then do upvote !!!\\n\\n\\n\\n# Approach\\n**Step1** - Sort the nodes By value\\n**Step2** - Sort the Queries \\n**Step3** - Traverse through all the queries and keep on connecting the nodes (if value of the node is less than the query value). The total no. of nodes connected will be our answer for that query\\n\\n# Complexity\\n- Time complexity : *O(n * m * log(n * m))*\\n\\n- Space complexity : *O(n * m)*\\n\\n# Code\\n```\\nclass DisjointSet{\\n    public:\\n    vector<int> parent;\\n    vector<int> size;\\n\\n    DisjointSet(int n){\\n        parent.resize(n);\\n        size.resize(n, 1);  // Size is always 1 initially, since there is no node attached to it for now, except himself\\n\\n        for(int i=0 ; i<n ; i++)\\n        parent[i] = i;  // Initialize a node\\'s parent as himself\\n    }\\n\\n    // Find the Ultimate Parent or the base node\\n    int findUParent(int node){\\n        if(node == parent[node])\\n        return node;\\n\\n        return parent[node] = findUParent(parent[node]);\\n    }\\n\\n    void unionBySize(int u, int v){\\n        int uPu = findUParent(u);\\n        int uPv = findUParent(v);\\n\\n        // If both have same ultimate Parent, then it means they are attached\\n        if(uPu == uPv)\\n        return ;\\n\\n        // Node with lower size always gets atached to the node with larger size, Parent of node1(node with lower size) is updated to node2(Parent of node with larger size)\\n        if(size[uPu] < size[uPv]){\\n            size[uPv] += size[uPu];\\n            parent[uPu] = parent[uPv];\\n        }\\n        else{\\n            size[uPu] += size[uPv];\\n            parent[uPv] = parent[uPu];\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool isOutOfBound(int i, int j, int n, int m){\\n        return (i<0 || i==n || j<0 || j==m);\\n    }\\n\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int n = grid.size(), m = grid[0].size();\\n\\n        // Sorting the nodes according to the values\\n        vector<vector<int>> nodes;\\n        for(int i=0 ; i<n ; i++){\\n            for(int j=0 ; j<m ; j++)\\n            nodes.push_back({grid[i][j], i, j});\\n        }\\n        sort(nodes.begin(), nodes.end());\\n\\n        // Sorting the queries\\n        vector<vector<int>> updatedQueries;\\n        for(int i=0 ; i<queries.size() ; i++)\\n        updatedQueries.push_back({queries[i], i});\\n        sort(updatedQueries.begin(), updatedQueries.end());\\n\\n\\n        int size = updatedQueries.size();\\n        vector<int> ans(size);\\n\\n        int i = 0;\\n        vector<pair<int, int>> directions{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n\\n        DisjointSet ds(n*m+1);  // Creating an object of Disjoint Set\\n\\n        for(auto q:updatedQueries){\\n            // If the node value is less than the query value\\n            while(i < n*m && nodes[i][0]<q[0]){\\n                int x = nodes[i][1], y = nodes[i][2];\\n                visited[x][y] = true;\\n\\n                for(int d=0 ; d<4 ; d++){\\n                    int X = x+directions[d].first;\\n                    int Y = y+directions[d].second;\\n\\n                    // If the node is already visited, then and only then, we can move in its direction (As Given in the Question)\\n                    if(!isOutOfBound(X, Y, n, m) && visited[X][Y])\\n                    {\\n                        int u = x*m + y;\\n                        int v = X*m + Y;\\n                        ds.unionBySize(u, v);   // Connect the nodes\\n                    }\\n                }\\n                i++;\\n            }\\n            \\n            if(visited[0][0])   // Value of the node at cell [0][0] is less than the query value\\n            ans[q[1]] = ds.size[ds.findUParent(0)];     // No of nodes attached to it is the answer\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass DisjointSet{\\n    public:\\n    vector<int> parent;\\n    vector<int> size;\\n\\n    DisjointSet(int n){\\n        parent.resize(n);\\n        size.resize(n, 1);  // Size is always 1 initially, since there is no node attached to it for now, except himself\\n\\n        for(int i=0 ; i<n ; i++)\\n        parent[i] = i;  // Initialize a node\\'s parent as himself\\n    }\\n\\n    // Find the Ultimate Parent or the base node\\n    int findUParent(int node){\\n        if(node == parent[node])\\n        return node;\\n\\n        return parent[node] = findUParent(parent[node]);\\n    }\\n\\n    void unionBySize(int u, int v){\\n        int uPu = findUParent(u);\\n        int uPv = findUParent(v);\\n\\n        // If both have same ultimate Parent, then it means they are attached\\n        if(uPu == uPv)\\n        return ;\\n\\n        // Node with lower size always gets atached to the node with larger size, Parent of node1(node with lower size) is updated to node2(Parent of node with larger size)\\n        if(size[uPu] < size[uPv]){\\n            size[uPv] += size[uPu];\\n            parent[uPu] = parent[uPv];\\n        }\\n        else{\\n            size[uPu] += size[uPv];\\n            parent[uPv] = parent[uPu];\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool isOutOfBound(int i, int j, int n, int m){\\n        return (i<0 || i==n || j<0 || j==m);\\n    }\\n\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int n = grid.size(), m = grid[0].size();\\n\\n        // Sorting the nodes according to the values\\n        vector<vector<int>> nodes;\\n        for(int i=0 ; i<n ; i++){\\n            for(int j=0 ; j<m ; j++)\\n            nodes.push_back({grid[i][j], i, j});\\n        }\\n        sort(nodes.begin(), nodes.end());\\n\\n        // Sorting the queries\\n        vector<vector<int>> updatedQueries;\\n        for(int i=0 ; i<queries.size() ; i++)\\n        updatedQueries.push_back({queries[i], i});\\n        sort(updatedQueries.begin(), updatedQueries.end());\\n\\n\\n        int size = updatedQueries.size();\\n        vector<int> ans(size);\\n\\n        int i = 0;\\n        vector<pair<int, int>> directions{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n\\n        DisjointSet ds(n*m+1);  // Creating an object of Disjoint Set\\n\\n        for(auto q:updatedQueries){\\n            // If the node value is less than the query value\\n            while(i < n*m && nodes[i][0]<q[0]){\\n                int x = nodes[i][1], y = nodes[i][2];\\n                visited[x][y] = true;\\n\\n                for(int d=0 ; d<4 ; d++){\\n                    int X = x+directions[d].first;\\n                    int Y = y+directions[d].second;\\n\\n                    // If the node is already visited, then and only then, we can move in its direction (As Given in the Question)\\n                    if(!isOutOfBound(X, Y, n, m) && visited[X][Y])\\n                    {\\n                        int u = x*m + y;\\n                        int v = X*m + Y;\\n                        ds.unionBySize(u, v);   // Connect the nodes\\n                    }\\n                }\\n                i++;\\n            }\\n            \\n            if(visited[0][0])   // Value of the node at cell [0][0] is less than the query value\\n            ans[q[1]] = ds.size[ds.findUParent(0)];     // No of nodes attached to it is the answer\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899459,
                "title": "java-nlogn-easy-to-understand-same-as-dijkstra-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: (n*m) log(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: (n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxPoints(int[][] arr, int[] q) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->(a[0]-b[0]));\\n        pq.add(new int[]{arr[0][0],0,0});\\n        boolean[][] visited = new boolean[arr.length][arr[0].length];\\n        visited[0][0] = true; \\n        Map<Integer,List<Integer>> map = new HashMap<>();\\n        for(int i = 0;i<q.length;i++){\\n            if(map.get(q[i])==null){\\n                map.put(q[i],new ArrayList<>());\\n            }\\n            map.get(q[i]).add(i);\\n        }\\n        \\n        Arrays.sort(q);\\n        int ix = 0;\\n        int cur = 0;\\n        int[] res = new int[q.length];\\n        \\n        int[][] dir = {{0,1},{0,-1},{-1,0},{1,0}};\\n\\n        while(!pq.isEmpty()){\\n            int[] rem = pq.remove();\\n            \\n            while(ix<q.length && q[ix]<=rem[0]){\\n                res[ix] = cur;\\n                ix++;\\n            }\\n            if(ix>=q.length) break;\\n            cur++;\\n            \\n            for(int d[] : dir){\\n                int x = d[0] + rem[1];\\n                int y = d[1] + rem[2];\\n                \\n                if(x<0 || y<0 || x>=arr.length || y>=arr[0].length || visited[x][y]){\\n                    continue;\\n                }\\n                visited[x][y] = true;\\n                pq.add(new int[]{arr[x][y],x,y});\\n            }\\n        }\\n        while(ix<q.length){\\n            res[ix] = cur;\\n            ix++;\\n        }\\n        \\n        int[] ans = new int[q.length];\\n        int p = 0;\\n        for(int x : q){\\n            \\n            for(int i : map.get(x)){\\n                ans[i] = res[p];\\n            }\\n            p++;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxPoints(int[][] arr, int[] q) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->(a[0]-b[0]));\\n        pq.add(new int[]{arr[0][0],0,0});\\n        boolean[][] visited = new boolean[arr.length][arr[0].length];\\n        visited[0][0] = true; \\n        Map<Integer,List<Integer>> map = new HashMap<>();\\n        for(int i = 0;i<q.length;i++){\\n            if(map.get(q[i])==null){\\n                map.put(q[i],new ArrayList<>());\\n            }\\n            map.get(q[i]).add(i);\\n        }\\n        \\n        Arrays.sort(q);\\n        int ix = 0;\\n        int cur = 0;\\n        int[] res = new int[q.length];\\n        \\n        int[][] dir = {{0,1},{0,-1},{-1,0},{1,0}};\\n\\n        while(!pq.isEmpty()){\\n            int[] rem = pq.remove();\\n            \\n            while(ix<q.length && q[ix]<=rem[0]){\\n                res[ix] = cur;\\n                ix++;\\n            }\\n            if(ix>=q.length) break;\\n            cur++;\\n            \\n            for(int d[] : dir){\\n                int x = d[0] + rem[1];\\n                int y = d[1] + rem[2];\\n                \\n                if(x<0 || y<0 || x>=arr.length || y>=arr[0].length || visited[x][y]){\\n                    continue;\\n                }\\n                visited[x][y] = true;\\n                pq.add(new int[]{arr[x][y],x,y});\\n            }\\n        }\\n        while(ix<q.length){\\n            res[ix] = cur;\\n            ix++;\\n        }\\n        \\n        int[] ans = new int[q.length];\\n        int p = 0;\\n        for(int x : q){\\n            \\n            for(int i : map.get(x)){\\n                ans[i] = res[p];\\n            }\\n            p++;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899366,
                "title": "bfs-with-min-heap",
                "content": "1. We can sort `queries`.  Just remember to return the results in the original order.\\n2. Given a threshold `i`, we can form a reachable region from `(0,0)`, and we can record the boundary.  This can be done by BFS with min heap.\\n3. Given a larger threshold and a recorded boundary, we can enlarge the reachable region by the same method.\\nThe complexity is ~~O(m*n + klogk)~~ O(mnlogmn + klogk) because, despite all these queries, we have only one BFS across the whole grid effectively, and we have one `sort` on `queries`.\\n\\t* Also, since we use min heap in BFS, we have additional log(mn) in the complexity. (Thanks @xil899)\\n\\n```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m = len(grid)\\n        n = len(grid[0])\\n            \\n        sq = sorted(queries)\\n        h = {}\\n        vs = set()\\n        vs.add((0,0))\\n        pq = [(grid[0][0],0,0)]\\n        for i in sq:\\n            while pq:\\n                v, a, b = pq[0]\\n                if v >= i: break\\n                heappop(pq)\\n                for c, d in (a-1, b), (a+1, b), (a, b-1), (a, b+1):\\n                    if c < 0 or c >= m or d < 0 or d >= n: continue\\n                    if (c,d) in vs: continue\\n                    heappush(pq, (grid[c][d], c, d))\\n                    vs.add((c,d))\\n            h[i] = len(vs) - len(pq)\\n        \\n        return (h[i] for i in queries)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m = len(grid)\\n        n = len(grid[0])\\n            \\n        sq = sorted(queries)\\n        h = {}\\n        vs = set()\\n        vs.add((0,0))\\n        pq = [(grid[0][0],0,0)]\\n        for i in sq:\\n            while pq:\\n                v, a, b = pq[0]\\n                if v >= i: break\\n                heappop(pq)\\n                for c, d in (a-1, b), (a+1, b), (a, b-1), (a, b+1):\\n                    if c < 0 or c >= m or d < 0 or d >= n: continue\\n                    if (c,d) in vs: continue\\n                    heappush(pq, (grid[c][d], c, d))\\n                    vs.add((c,d))\\n            h[i] = len(vs) - len(pq)\\n        \\n        return (h[i] for i in queries)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912288,
                "title": "python-heap-binary-search-video-solution",
                "content": "I have explained the solution in this [video](https://youtu.be/zZWSZM7fboI).\\n\\n**Time**: `O( mn. log(mn) + k. log(mn))`\\n\\n**Space**: `O(mn)`\\n\\nIf this was helpful, please **Upvote**, like the video and subscribe to the channel.\\n\\n\\n```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        \\n        min_heap = [(grid[0][0], 0, 0)]\\n        visited = set()\\n        visited.add((0,0))\\n        \\n        threshold_order = []\\n        threshold = -1\\n        \\n        while min_heap:\\n            val, r, c = heapq.heappop(min_heap)\\n            threshold = max(threshold, val)\\n            threshold_order.append(threshold)\\n            \\n            for x,y in [(r+1, c), (r-1, c), (r, c+1), (r, c-1)]:\\n                if x < 0 or x >= m or y < 0 or y>=n or (x, y) in visited:\\n                    continue\\n                visited.add((x, y))\\n                heapq.heappush(min_heap, (grid[x][y], x, y))\\n                \\n        res = []\\n        for q in queries:\\n            res.append(bisect.bisect_left(threshold_order, q))\\n            \\n        return res",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "I have explained the solution in this [video](https://youtu.be/zZWSZM7fboI).\\n\\n**Time**: `O( mn. log(mn) + k. log(mn))`\\n\\n**Space**: `O(mn)`\\n\\nIf this was helpful, please **Upvote**, like the video and subscribe to the channel.\\n\\n\\n```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        \\n        min_heap = [(grid[0][0], 0, 0)]\\n        visited = set()\\n        visited.add((0,0))\\n        \\n        threshold_order = []\\n        threshold = -1\\n        \\n        while min_heap:\\n            val, r, c = heapq.heappop(min_heap)\\n            threshold = max(threshold, val)\\n            threshold_order.append(threshold)\\n            \\n            for x,y in [(r+1, c), (r-1, c), (r, c+1), (r, c-1)]:\\n                if x < 0 or x >= m or y < 0 or y>=n or (x, y) in visited:\\n                    continue\\n                visited.add((x, y))\\n                heapq.heappush(min_heap, (grid[x][y], x, y))\\n                \\n        res = []\\n        for q in queries:\\n            res.append(bisect.bisect_left(threshold_order, q))\\n            \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2900674,
                "title": "java-prioritized-bfs-explained",
                "content": "# Intuition\\nFirst of all, we want to smartly search the `queries` array, going in an ascending order. \\n\\nThe intuition for this, is that is if `queries[j] > queries[i]` then `queries[j]` must contain the solution set of `queries[i]` plus potentially more cells it can reach.\\n\\nNow we are going to do a BFS to find the reach, but we also want the cells in our bfs queue to be evaluated in an ascending order so we will prioritize that with a PriorityQueue. \\n\\nThe reason we want the cells evaluated in an ascending order is that we maximize the reach `queries[i]` can have, so we first check the smallest values.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        Queue<int[]> processQueue = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n        int k = queries.length;\\n        int[] answer = new int[k];\\n\\n        for (int i = 0; i < k; i++) {\\n            processQueue.offer(new int[]{queries[i], i});\\n        }\\n\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean[][] vis = new boolean[m][n];\\n        Queue<int[]> bfsQueue = new PriorityQueue<>((a,b) -> \\n                grid[a[0]][a[1]] - grid[b[0]][b[1]]\\n            );\\n        int reach = 0;\\n        \\n        bfsQueue.offer(new int[]{0, 0});\\n        vis[0][0] = true;\\n\\n        while (!processQueue.isEmpty()) {\\n            int[] nextElement = processQueue.poll();\\n            int elementValue = nextElement[0];\\n            int elementIndex = nextElement[1];\\n\\n            while (!bfsQueue.isEmpty() && elementValue > grid[bfsQueue.peek()[0]][bfsQueue.peek()[1]]) {\\n                reach++;\\n                int[] cell = bfsQueue.poll();\\n                int row = cell[0];\\n                int col = cell[1];\\n\\n                for (int[] d : new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}) {\\n                    int nextRow = row + d[0];\\n                    int nextCol = col + d[1];\\n                    if (nextRow >= 0 && nextRow < m && nextCol >= 0 && nextCol < n && !vis[nextRow][nextCol]) {\\n                        vis[nextRow][nextCol] = true;\\n                        bfsQueue.offer(new int[]{nextRow, nextCol});\\n                    }\\n                }\\n\\n            }\\n\\n            answer[elementIndex] = reach;\\n        }\\n\\n\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        Queue<int[]> processQueue = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n        int k = queries.length;\\n        int[] answer = new int[k];\\n\\n        for (int i = 0; i < k; i++) {\\n            processQueue.offer(new int[]{queries[i], i});\\n        }\\n\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean[][] vis = new boolean[m][n];\\n        Queue<int[]> bfsQueue = new PriorityQueue<>((a,b) -> \\n                grid[a[0]][a[1]] - grid[b[0]][b[1]]\\n            );\\n        int reach = 0;\\n        \\n        bfsQueue.offer(new int[]{0, 0});\\n        vis[0][0] = true;\\n\\n        while (!processQueue.isEmpty()) {\\n            int[] nextElement = processQueue.poll();\\n            int elementValue = nextElement[0];\\n            int elementIndex = nextElement[1];\\n\\n            while (!bfsQueue.isEmpty() && elementValue > grid[bfsQueue.peek()[0]][bfsQueue.peek()[1]]) {\\n                reach++;\\n                int[] cell = bfsQueue.poll();\\n                int row = cell[0];\\n                int col = cell[1];\\n\\n                for (int[] d : new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}) {\\n                    int nextRow = row + d[0];\\n                    int nextCol = col + d[1];\\n                    if (nextRow >= 0 && nextRow < m && nextCol >= 0 && nextCol < n && !vis[nextRow][nextCol]) {\\n                        vis[nextRow][nextCol] = true;\\n                        bfsQueue.offer(new int[]{nextRow, nextCol});\\n                    }\\n                }\\n\\n            }\\n\\n            answer[elementIndex] = reach;\\n        }\\n\\n\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899960,
                "title": "python-simplest-solution-detailed-explanation-bfs-heap-codeplug",
                "content": "# Intuition\\nWe need to traverse to the furthest possible distance from 0,0 for any given query. A BFS can help here, but normal BFS means we explore all possible neighbours, can we improve it by greedily selecting the smallest neighbour first?\\n\\nAnd as soon as we reach a neighbour thats >= query, we can stop the traversal as we know all other remaining neighbours will not satisfy the condition.\\n\\n# Approach\\n1. We can choose min-heap for greedily choosing the smallest cell to explore in every step of BFS. \\n2. We only care about unique query values, since for a given input the output will always be the same.\\n3. If we can sort the input queries, we are sure that the incoming query will be > than the previous query, so we start the BFS from where we left off, and increase the previous count during the traversal, so we skip starting from 0,0 again and again. Our heap already preserves the boundary of the previous query, we dont reset it for every new query. We also store the result for prev query in a variable.\\n4. We can store the res for a given query in a dicitonary/map so that, in the end form the result array using the query results.\\n\\n**Upvote if you understood the solution :)**\\n# Complexity\\n- Time complexity:\\n$$O(max(k, m*n*log(m*n)))$$\\n\\n- Space complexity:\\n$$O(max(k, m*n))$$\\n\\n# Code\\n```python []\\nclass Solution:\\n    def maxPoints(self, grid, qs: List[int]) -> List[int]:\\n        queries = sorted(set(qs))\\n        res = {}\\n        rows, cols = len(grid), len(grid[0])\\n        q = [(grid[0][0], 0, 0)] # heap\\n        prevCount = 0\\n\\n        for num in queries:\\n            count = prevCount\\n\\n            while q:\\n                val, r, c = q[0]\\n\\n                if val >= num: break # pop only when the condition satisfy else break\\n                else:\\n                    heappop(q)\\n                    grid[r][c] = None\\n                    count += 1\\n\\n                    for i, j in [(r + 1, c), (r, c + 1), (r - 1, c), (r, c - 1)]:\\n                        if 0 <= i < rows and 0 <= j < cols and grid[i][j] is not None:\\n                            heappush(q, (grid[i][j], i, j))\\n                            grid[i][j] = None\\n\\n            res[num] = prevCount = count\\n\\n        ans = [res[num] for num in qs]\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Sort",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```python []\\nclass Solution:\\n    def maxPoints(self, grid, qs: List[int]) -> List[int]:\\n        queries = sorted(set(qs))\\n        res = {}\\n        rows, cols = len(grid), len(grid[0])\\n        q = [(grid[0][0], 0, 0)] # heap\\n        prevCount = 0\\n\\n        for num in queries:\\n            count = prevCount\\n\\n            while q:\\n                val, r, c = q[0]\\n\\n                if val >= num: break # pop only when the condition satisfy else break\\n                else:\\n                    heappop(q)\\n                    grid[r][c] = None\\n                    count += 1\\n\\n                    for i, j in [(r + 1, c), (r, c + 1), (r - 1, c), (r, c - 1)]:\\n                        if 0 <= i < rows and 0 <= j < cols and grid[i][j] is not None:\\n                            heappush(q, (grid[i][j], i, j))\\n                            grid[i][j] = None\\n\\n            res[num] = prevCount = count\\n\\n        ans = [res[num] for num in qs]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899361,
                "title": "java-bfs-with-comments-heap-and-treemap",
                "content": "```\\nclass Solution {\\n    private static final int[][] DIRS = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    \\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        \\n        // map will store the number of points possible: query -> points\\n        TreeMap<Integer, Integer> pointsMap = new TreeMap<>();\\n        \\n        // use heap to visit reachable nodes in increasing order of cell value\\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        heap.offer(new int[] { 0, 0, grid[0][0] });  // row, col, cell value\\n        visited[0][0] = true;\\n        int points = 0;\\n        \\n        while (!heap.isEmpty()) {\\n            // the smallest query value needed to get to the next unvisited node,\\n            // we add 1 because queries[i] must be strictly greater than cell value\\n            int query = heap.peek()[2] + 1;\\n            \\n            // BFS - visit all nodes with cell value strictly less than query\\n            while (!heap.isEmpty() && heap.peek()[2] < query) {\\n                int[] entry = heap.poll();\\n                int row = entry[0];\\n                int col = entry[1];\\n                points++;\\n                \\n                for (int[] dir : DIRS) {\\n                    int r = row + dir[0];\\n                    int c = col + dir[1];\\n                    if (r >= 0 && r < m && c >= 0 && c < n && !visited[r][c]) {\\n                        heap.offer(new int[] { r, c, grid[r][c] });\\n                        visited[r][c] = true;\\n                    }\\n                }\\n            }\\n            \\n            // store points for query value\\n            pointsMap.put(query, points);\\n        }\\n        \\n        // handle each query\\n        int[] output = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            // use floorKey to key with maximum number of points for this query\\n            Integer key = pointsMap.floorKey(queries[i]);\\n            if (key != null) {\\n                output[i] = pointsMap.get(key);\\n            } else {\\n                output[i] = 0;\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final int[][] DIRS = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    \\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        \\n        // map will store the number of points possible: query -> points\\n        TreeMap<Integer, Integer> pointsMap = new TreeMap<>();\\n        \\n        // use heap to visit reachable nodes in increasing order of cell value\\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        heap.offer(new int[] { 0, 0, grid[0][0] });  // row, col, cell value\\n        visited[0][0] = true;\\n        int points = 0;\\n        \\n        while (!heap.isEmpty()) {\\n            // the smallest query value needed to get to the next unvisited node,\\n            // we add 1 because queries[i] must be strictly greater than cell value\\n            int query = heap.peek()[2] + 1;\\n            \\n            // BFS - visit all nodes with cell value strictly less than query\\n            while (!heap.isEmpty() && heap.peek()[2] < query) {\\n                int[] entry = heap.poll();\\n                int row = entry[0];\\n                int col = entry[1];\\n                points++;\\n                \\n                for (int[] dir : DIRS) {\\n                    int r = row + dir[0];\\n                    int c = col + dir[1];\\n                    if (r >= 0 && r < m && c >= 0 && c < n && !visited[r][c]) {\\n                        heap.offer(new int[] { r, c, grid[r][c] });\\n                        visited[r][c] = true;\\n                    }\\n                }\\n            }\\n            \\n            // store points for query value\\n            pointsMap.put(query, points);\\n        }\\n        \\n        // handle each query\\n        int[] output = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            // use floorKey to key with maximum number of points for this query\\n            Integer key = pointsMap.floorKey(queries[i]);\\n            if (key != null) {\\n                output[i] = pointsMap.get(key);\\n            } else {\\n                output[i] = 0;\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899357,
                "title": "javascript-union-find-sorting",
                "content": "**Solution: Union Find & Sorting**\\n\\n1. Sort queries in ascending order.\\n2. Collect each coordinate of the grid into an array \"coords\" and sort them in order of value.\\n3. For each query,\\n*   Use union find to connect cells in the grid (with `value <= query value`) with neighboring cells where `value <= query value`.\\n*   Count the number of cells connected to `grid[0][0]`.\\n*   **Note**: We keep track of the size of each group of connected nodes in the union find.\\n\\n`m = number of rows in grid`, `n = number of columns in grid`, `q = number of queries`\\nTime Complexity: `O(mn log(mn) + q)`\\nSpace Complexity: `O(mn + q)`\\n```\\nvar maxPoints = function(grid, queries) {\\n  let m = grid.length, n = grid[0].length;\\n  let coords = []; \\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      coords.push([i, j, grid[i][j]]); // [row, col, value]\\n    }\\n  }\\n  coords.sort((a, b) => a[2] - b[2]); // sort coordinates by value in asc order\\n  queries = queries.map((val, index) => [val, index]).sort((a, b) => a[0] - b[0]); // sort queries by value in asc order\\n  \\n  let k = coords.length, j = 0;\\n  let uf = new UnionFind(k), ans = Array(queries.length);\\n  for (let i = 0; i < queries.length; i++) {\\n    let [queryVal, index] = queries[i];\\n    while (j < k && coords[j][2] < queryVal) {\\n      let [row, col] = coords[j];\\n      connectWithNeighbors(row, col, queryVal);\\n      j++;\\n    }\\n    if (grid[0][0] >= queryVal) {\\n      ans[index] = 0;\\n    } else {\\n      let count = uf.size[uf.find(0)]; // count cells connected to grid[0][0]\\n      ans[index] = count;\\n    }\\n  }\\n  return ans;\\n  \\n  function connectWithNeighbors(row, col, queryVal) {\\n    const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];\\n    for (let [x, y] of directions) {\\n      let newRow = row + x, newCol = col + y;\\n      if (newRow < 0 || newRow >= m || newCol < 0 || newCol >= n) continue; // out of bounds\\n      if (grid[newRow][newCol] >= queryVal) continue; // cell value larger than or equal to query value\\n      uf.union(getIndex(row, col), getIndex(newRow, newCol));\\n    }\\n  }\\n  \\n  function getIndex(row, col) {\\n    return row * n + col;\\n  }\\n};\\n\\nclass UnionFind {\\n  constructor(size) {\\n    this.root = Array(size);\\n    this.rank = Array(size);\\n    this.size = Array(size); // size[i] = size of group i\\n    for (let i = 0; i < size; i++) {\\n      this.root[i] = i;\\n      this.rank[i] = 1;\\n      this.size[i] = 1;\\n    }\\n  }\\n  find(x) {\\n    if (this.root[x] === x) return x;\\n    return this.root[x] = this.find(this.root[x]);\\n  }\\n  union(x, y) {\\n    let rootX = this.find(x), rootY = this.find(y);\\n    if (rootX === rootY) return false;\\n    if (this.rank[rootX] < this.rank[rootY]) {\\n      this.root[rootX] = rootY;\\n      this.size[rootY] += this.size[rootX];\\n    } else if (this.rank[rootX] > this.rank[rootY]) {\\n      this.root[rootY] = rootX;\\n      this.size[rootX] += this.size[rootY];\\n    } else {\\n      this.root[rootY] = rootX;\\n      this.rank[rootX]++;\\n      this.size[rootX] += this.size[rootY];\\n    }\\n    return true;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxPoints = function(grid, queries) {\\n  let m = grid.length, n = grid[0].length;\\n  let coords = []; \\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      coords.push([i, j, grid[i][j]]); // [row, col, value]\\n    }\\n  }\\n  coords.sort((a, b) => a[2] - b[2]); // sort coordinates by value in asc order\\n  queries = queries.map((val, index) => [val, index]).sort((a, b) => a[0] - b[0]); // sort queries by value in asc order\\n  \\n  let k = coords.length, j = 0;\\n  let uf = new UnionFind(k), ans = Array(queries.length);\\n  for (let i = 0; i < queries.length; i++) {\\n    let [queryVal, index] = queries[i];\\n    while (j < k && coords[j][2] < queryVal) {\\n      let [row, col] = coords[j];\\n      connectWithNeighbors(row, col, queryVal);\\n      j++;\\n    }\\n    if (grid[0][0] >= queryVal) {\\n      ans[index] = 0;\\n    } else {\\n      let count = uf.size[uf.find(0)]; // count cells connected to grid[0][0]\\n      ans[index] = count;\\n    }\\n  }\\n  return ans;\\n  \\n  function connectWithNeighbors(row, col, queryVal) {\\n    const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];\\n    for (let [x, y] of directions) {\\n      let newRow = row + x, newCol = col + y;\\n      if (newRow < 0 || newRow >= m || newCol < 0 || newCol >= n) continue; // out of bounds\\n      if (grid[newRow][newCol] >= queryVal) continue; // cell value larger than or equal to query value\\n      uf.union(getIndex(row, col), getIndex(newRow, newCol));\\n    }\\n  }\\n  \\n  function getIndex(row, col) {\\n    return row * n + col;\\n  }\\n};\\n\\nclass UnionFind {\\n  constructor(size) {\\n    this.root = Array(size);\\n    this.rank = Array(size);\\n    this.size = Array(size); // size[i] = size of group i\\n    for (let i = 0; i < size; i++) {\\n      this.root[i] = i;\\n      this.rank[i] = 1;\\n      this.size[i] = 1;\\n    }\\n  }\\n  find(x) {\\n    if (this.root[x] === x) return x;\\n    return this.root[x] = this.find(this.root[x]);\\n  }\\n  union(x, y) {\\n    let rootX = this.find(x), rootY = this.find(y);\\n    if (rootX === rootY) return false;\\n    if (this.rank[rootX] < this.rank[rootY]) {\\n      this.root[rootX] = rootY;\\n      this.size[rootY] += this.size[rootX];\\n    } else if (this.rank[rootX] > this.rank[rootY]) {\\n      this.root[rootY] = rootX;\\n      this.size[rootX] += this.size[rootY];\\n    } else {\\n      this.root[rootY] = rootX;\\n      this.rank[rootX]++;\\n      this.size[rootX] += this.size[rootY];\\n    }\\n    return true;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899356,
                "title": "topological-sort-by-value",
                "content": "```\\nimport heapq\\nimport bisect\\n\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        heap = [(grid[0][0], 0, 0)]\\n        v = {(0, 0)}\\n        order = []\\n        while len(heap) > 0:\\n            curr, i, j = heapq.heappop(heap)\\n            order.append(curr)\\n            for x, y in [(i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)]:\\n                if 0 <= x < m and 0 <= y < n and (x, y) not in v:\\n                    v.add((x, y))\\n                    heapq.heappush(heap, (grid[x][y], x, y))\\n        myet = float(\\'-inf\\')\\n        for i in range(len(order)):\\n            myet = max(myet, order[i])\\n            order[i] = myet\\n        res = []\\n        for q in queries:\\n            res.append(bisect.bisect_left(order, q))\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport heapq\\nimport bisect\\n\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        heap = [(grid[0][0], 0, 0)]\\n        v = {(0, 0)}\\n        order = []\\n        while len(heap) > 0:\\n            curr, i, j = heapq.heappop(heap)\\n            order.append(curr)\\n            for x, y in [(i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)]:\\n                if 0 <= x < m and 0 <= y < n and (x, y) not in v:\\n                    v.add((x, y))\\n                    heapq.heappush(heap, (grid[x][y], x, y))\\n        myet = float(\\'-inf\\')\\n        for i in range(len(order)):\\n            myet = max(myet, order[i])\\n            order[i] = myet\\n        res = []\\n        for q in queries:\\n            res.append(bisect.bisect_left(order, q))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570872,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        Queue<int[]> processQueue = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n        int k = queries.length;\\n        int[] answer = new int[k];\\n\\n        for (int i = 0; i < k; i++) {\\n            processQueue.offer(new int[]{queries[i], i});\\n        }\\n\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean[][] vis = new boolean[m][n];\\n        Queue<int[]> bfsQueue = new PriorityQueue<>((a,b) -> \\n                grid[a[0]][a[1]] - grid[b[0]][b[1]]\\n            );\\n        int reach = 0;\\n        \\n        bfsQueue.offer(new int[]{0, 0});\\n        vis[0][0] = true;\\n\\n        while (!processQueue.isEmpty()) {\\n            int[] nextElement = processQueue.poll();\\n            int elementValue = nextElement[0];\\n            int elementIndex = nextElement[1];\\n\\n            while (!bfsQueue.isEmpty() && elementValue > grid[bfsQueue.peek()[0]][bfsQueue.peek()[1]]) {\\n                reach++;\\n                int[] cell = bfsQueue.poll();\\n                int row = cell[0];\\n                int col = cell[1];\\n\\n                for (int[] d : new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}) {\\n                    int nextRow = row + d[0];\\n                    int nextCol = col + d[1];\\n                    if (nextRow >= 0 && nextRow < m && nextCol >= 0 && nextCol < n && !vis[nextRow][nextCol]) {\\n                        vis[nextRow][nextCol] = true;\\n                        bfsQueue.offer(new int[]{nextRow, nextCol});\\n                    }\\n                }\\n\\n            }\\n\\n            answer[elementIndex] = reach;\\n        }\\n\\n\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        Queue<int[]> processQueue = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n        int k = queries.length;\\n        int[] answer = new int[k];\\n\\n        for (int i = 0; i < k; i++) {\\n            processQueue.offer(new int[]{queries[i], i});\\n        }\\n\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean[][] vis = new boolean[m][n];\\n        Queue<int[]> bfsQueue = new PriorityQueue<>((a,b) -> \\n                grid[a[0]][a[1]] - grid[b[0]][b[1]]\\n            );\\n        int reach = 0;\\n        \\n        bfsQueue.offer(new int[]{0, 0});\\n        vis[0][0] = true;\\n\\n        while (!processQueue.isEmpty()) {\\n            int[] nextElement = processQueue.poll();\\n            int elementValue = nextElement[0];\\n            int elementIndex = nextElement[1];\\n\\n            while (!bfsQueue.isEmpty() && elementValue > grid[bfsQueue.peek()[0]][bfsQueue.peek()[1]]) {\\n                reach++;\\n                int[] cell = bfsQueue.poll();\\n                int row = cell[0];\\n                int col = cell[1];\\n\\n                for (int[] d : new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}) {\\n                    int nextRow = row + d[0];\\n                    int nextCol = col + d[1];\\n                    if (nextRow >= 0 && nextRow < m && nextCol >= 0 && nextCol < n && !vis[nextRow][nextCol]) {\\n                        vis[nextRow][nextCol] = true;\\n                        bfsQueue.offer(new int[]{nextRow, nextCol});\\n                    }\\n                }\\n\\n            }\\n\\n            answer[elementIndex] = reach;\\n        }\\n\\n\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906749,
                "title": "approach-1-dfs-approach-2-bfs-video-editorial",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/T5vCtDYpA80\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/T5vCtDYpA80\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2899525,
                "title": "python-solution-priority-queue-and-then-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want to find the threshold to gain a point at each coordinate\\nThe answer is the maximum between grid[i][j] and the minimum of thresholds of its neighbours\\n\\nTherefore I figured I should not be doing BFS, but should use a priority queue instead.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe queries are simple: just sort all the thresholds and use binary search to find points gained\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        threshold = [[0 for j in range(n)] for i in range(m)]\\n        heap = []\\n        heapq.heappush(heap, [grid[0][0], 0, 0])\\n        while heap:\\n            while heap and threshold[heap[0][1]][heap[0][2]] > 0:\\n                heapq.heappop(heap)\\n            if heap:\\n                cost, x, y = heapq.heappop(heap)\\n                threshold[x][y] = cost\\n                for nx, ny in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\\n                    if 0 <= nx < m and 0 <= ny < n:\\n                        heapq.heappush(heap, [max(grid[nx][ny], cost), nx, ny])\\n        elements = []\\n        for i in range(m):\\n            for j in range(n):\\n                elements.append(threshold[i][j])\\n        elements.sort()\\n        \\n        result = []\\n        for query in queries:\\n            result.append(bisect.bisect_left(elements, query))\\n        return result\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        threshold = [[0 for j in range(n)] for i in range(m)]\\n        heap = []\\n        heapq.heappush(heap, [grid[0][0], 0, 0])\\n        while heap:\\n            while heap and threshold[heap[0][1]][heap[0][2]] > 0:\\n                heapq.heappop(heap)\\n            if heap:\\n                cost, x, y = heapq.heappop(heap)\\n                threshold[x][y] = cost\\n                for nx, ny in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\\n                    if 0 <= nx < m and 0 <= ny < n:\\n                        heapq.heappush(heap, [max(grid[nx][ny], cost), nx, ny])\\n        elements = []\\n        for i in range(m):\\n            for j in range(n):\\n                elements.append(threshold[i][j])\\n        elements.sort()\\n        \\n        result = []\\n        for query in queries:\\n            result.append(bisect.bisect_left(elements, query))\\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899369,
                "title": "dsu-offline-query-c",
                "content": "<h2>Approach</h2>\\nWe will solve the problem using <b>DSU with offline query processing</b>.\\n\\nAssume that each cell has four edges connecting it to its neighboring cells. Each edge has a weight equal to the maximum of its connecting cells. All of the edges will be kept in a list and sorted.\\nAdditionally, we\\'ll order the queries array.\\n\\nLet\\'s begin answering the queries now. At first, the response to all queries with value less than grid[0][0] will be 0. We will keep a pointer to point the current queries to be processed. \\n\\nWe now start processing the edges. For all the queries with a value less than the weight of current edge will have a response equal to the size of the set containing the (0,0) cell.\\nWe then join the two cells connected by that edge.\\nAfter all the edges have been processed the remaining queries will have answer equal to number of cells in the grid.\\n<h3>Code</h3>\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int>par,sz;\\n    vector<pair<int, pair< pair<int,int>, pair<int,int>>>> edges;\\n    \\n    //DSU Section\\n    int root(int u){\\n        return u==par[u]?u:par[u] = root(par[u]);\\n    }\\n    void join(int u,int v){\\n        u = root(u);\\n        v = root(v);\\n        if(u==v)return;\\n        par[u] = v;\\n        sz[v]+=sz[u];\\n    }\\n    \\n    \\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int q = queries.size();\\n        vector<int>qord(q);\\n        iota(qord.begin(),qord.end(),0);\\n        // Order the queries.\\n        sort(qord.begin(),qord.end(),[&queries](int x,int y){\\n            return queries[x]<queries[y];\\n        });\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        const int fx[4]={0,0,1,-1};\\n        const int fy[4]={1,-1,0,0};\\n        edges.clear();\\n        //Find all the edges.\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                for(int k=0;k<4;k++){\\n                    int di = i+fx[k];\\n                    int dj = j+fy[k];\\n                    if(di>=0 && di<n && dj>=0 && dj<m){\\n                        edges.push_back({max(grid[di][dj],grid[i][j]),{{i,j},{di,dj}}});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //Sort all the edges.\\n        sort(edges.begin(),edges.end());\\n        par.resize(m*n);\\n        iota(par.begin(),par.end(),0);\\n        sz.resize(m*n);\\n        for(int i=0;i<m*n;i++)sz[i] = 1;\\n        int ql = 0;\\n        vector<int>ans(q);\\n        //Queries with value less than grid[0][0] will have answer equal to 0.\\n        while(ql<q && queries[qord[ql]]<=grid[0][0]){\\n            ans[qord[ql]] = 0;\\n            ql++;\\n        }\\n        //Start processing the edges.\\n        for(auto&e:edges){\\n            int cost = e.first;\\n            int u = e.second.first.first*m+e.second.first.second;\\n            int v = e.second.second.first*m+e.second.second.second;\\n            while(ql<q && queries[qord[ql]]<=cost){\\n                ans[qord[ql]] = sz[root(0)];\\n                ql++;\\n            }\\n            join(u,v);\\n            \\n        }\\n        //Remaining Queries will have answer equal to grid size.\\n        while(ql<q){\\n            ans[qord[ql]] = sz[root(0)];\\n            ql++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>par,sz;\\n    vector<pair<int, pair< pair<int,int>, pair<int,int>>>> edges;\\n    \\n    //DSU Section\\n    int root(int u){\\n        return u==par[u]?u:par[u] = root(par[u]);\\n    }\\n    void join(int u,int v){\\n        u = root(u);\\n        v = root(v);\\n        if(u==v)return;\\n        par[u] = v;\\n        sz[v]+=sz[u];\\n    }\\n    \\n    \\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int q = queries.size();\\n        vector<int>qord(q);\\n        iota(qord.begin(),qord.end(),0);\\n        // Order the queries.\\n        sort(qord.begin(),qord.end(),[&queries](int x,int y){\\n            return queries[x]<queries[y];\\n        });\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        const int fx[4]={0,0,1,-1};\\n        const int fy[4]={1,-1,0,0};\\n        edges.clear();\\n        //Find all the edges.\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                for(int k=0;k<4;k++){\\n                    int di = i+fx[k];\\n                    int dj = j+fy[k];\\n                    if(di>=0 && di<n && dj>=0 && dj<m){\\n                        edges.push_back({max(grid[di][dj],grid[i][j]),{{i,j},{di,dj}}});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //Sort all the edges.\\n        sort(edges.begin(),edges.end());\\n        par.resize(m*n);\\n        iota(par.begin(),par.end(),0);\\n        sz.resize(m*n);\\n        for(int i=0;i<m*n;i++)sz[i] = 1;\\n        int ql = 0;\\n        vector<int>ans(q);\\n        //Queries with value less than grid[0][0] will have answer equal to 0.\\n        while(ql<q && queries[qord[ql]]<=grid[0][0]){\\n            ans[qord[ql]] = 0;\\n            ql++;\\n        }\\n        //Start processing the edges.\\n        for(auto&e:edges){\\n            int cost = e.first;\\n            int u = e.second.first.first*m+e.second.first.second;\\n            int v = e.second.second.first*m+e.second.second.second;\\n            while(ql<q && queries[qord[ql]]<=cost){\\n                ans[qord[ql]] = sz[root(0)];\\n                ql++;\\n            }\\n            join(u,v);\\n            \\n        }\\n        //Remaining Queries will have answer equal to grid size.\\n        while(ql<q){\\n            ans[qord[ql]] = sz[root(0)];\\n            ql++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3836651,
                "title": "heap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Define a struct to represent a point on the grid, with properties: value, x, and y.\\nstruct Node {\\n    int value, x, y;\\n    Node(int value, int x, int y) : value(value), x(x), y(y) {}\\n};\\n\\n// Define a custom comparator to compare Node* objects in the priority queue.\\nstruct CompareNode {\\n    bool operator()(const Node* a, const Node* b) const {\\n        // Compare based on value, then x, and finally y, in descending order.\\n        if (a->value == b->value) {\\n            if (a->x == b->x) {\\n                return a->y > b->y;\\n            }\\n            return a->x > b->x;\\n        }\\n        return a->value > b->value;\\n    }\\n};\\n\\n// Define the Solution class.\\nclass Solution {\\npublic:\\n    // Vector representing four directions: up, right, down, and left.\\n    vector<vector<int>> dir = { {-1, 0}, {0, 1}, {1, 0}, {0, -1} };\\n\\n    // Priority queue to store nodes in descending order of value using CompareNode.\\n    priority_queue<Node*, vector<Node*>, CompareNode> pq;\\n\\n    // DFS function to explore the grid for points with value < queryValue.\\n    void dfs(vector<vector<int>>& grid, int startX, int startY, int queryValue, vector<vector<bool>>& visited, int rows, int cols, int& count) {\\n        // Initialize variable to track the number of visited nodes.\\n        int v = 0;\\n\\n        // Continue until the priority queue is empty or the top element\\'s value is >= queryValue.\\n        while (pq.size() != v) {\\n            if (pq.top()->value >= queryValue)\\n                return; // Return if the top node\\'s value is greater or equal to queryValue.\\n\\n            // Pop the front node from the priority queue.\\n            auto fnode = pq.top();\\n            pq.pop();\\n\\n            // Get the x and y coordinates of the current node.\\n            int x = fnode->x, y = fnode->y;\\n\\n            // Get the value of the current node.\\n            int value = fnode->value;\\n\\n            // If the value is less than queryValue, increment count.\\n            if (value < queryValue)\\n                count++;\\n\\n            // Explore the four neighboring nodes.\\n            for (int i = 0; i < 4; i++) {\\n                // Calculate the new x and y coordinates for the neighboring node.\\n                int nx = x + dir[i][0];\\n                int ny = y + dir[i][1];\\n\\n                // Check if the neighboring node is within bounds and not visited.\\n                if (nx >= 0 && ny >= 0 && nx < rows && ny < cols && !visited[nx][ny]) {\\n                    // Create a new Node for the neighboring node with its value, x, and y.\\n                    Node* n = new Node(grid[nx][ny], nx, ny);\\n\\n                    // Get the value of the neighboring node.\\n                    int nodeValue = n->value;\\n\\n                    // If the neighboring node\\'s value is less than queryValue, add it to the priority queue and mark it as visited.\\n                    if (nodeValue < queryValue) {\\n                        pq.push(n);\\n                        visited[nx][ny] = true;\\n                    }\\n                    // Otherwise, add it to the priority queue and mark it as visited, but increment v to track the number of visited nodes.\\n                    else {\\n                        pq.push(n);\\n                        visited[nx][ny] = true;\\n                        v++;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    // Function to find the maximum points less than each query value in the grid.\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        // Get the number of rows and columns in the grid.\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n\\n        // Map to store the indices of queries that have the same value.\\n        unordered_map<int, list<int>> queryMap;\\n\\n        // Get the number of queries and create a vector to store the results.\\n        int k = queries.size();\\n        vector<int> ans(k, 0);\\n\\n        // Create a Node representing the starting point (0, 0) in the grid, and add it to the priority queue.\\n        Node node(grid[0][0], 0, 0);\\n        pq.push(&node);\\n\\n        // Populate the queryMap with indices of queries having the same value.\\n        for (int i = 0; i < queries.size(); i++)\\n            queryMap[queries[i]].push_back(i);\\n        \\n        // Sort the queries in ascending order.\\n        sort(queries.begin(), queries.end());\\n\\n        // Create a 2D boolean vector to keep track of visited nodes in the grid.\\n        vector<vector<bool>> visited(rows, vector<bool>(cols, false));\\n\\n        // Mark the starting point as visited.\\n        visited[0][0] = true;\\n\\n        // Initialize a variable to count points less than the current query value.\\n        int count = 0;\\n\\n        // Iterate through each query value.\\n        for (int i = 0; i < queries.size(); i++) {\\n            // If the value at the starting point is less than the current query value, perform DFS from the starting point.\\n            if (grid[0][0] < queries[i]) {\\n                dfs(grid, 0, 0, queries[i], visited, rows, cols, count);\\n\\n                // Update the results for all queries with the same value as the current query.\\n                bool flag = false;\\n                for (auto nbr : queryMap[queries[i]]) {\\n                    ans[nbr] = count;\\n                    flag = true;\\n                    i++;\\n                }\\n                if (flag) i--; // Decrement i to avoid skipping the next query.\\n            }\\n        }\\n\\n        // Return the results for all queries.\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Define a struct to represent a point on the grid, with properties: value, x, and y.\\nstruct Node {\\n    int value, x, y;\\n    Node(int value, int x, int y) : value(value), x(x), y(y) {}\\n};\\n\\n// Define a custom comparator to compare Node* objects in the priority queue.\\nstruct CompareNode {\\n    bool operator()(const Node* a, const Node* b) const {\\n        // Compare based on value, then x, and finally y, in descending order.\\n        if (a->value == b->value) {\\n            if (a->x == b->x) {\\n                return a->y > b->y;\\n            }\\n            return a->x > b->x;\\n        }\\n        return a->value > b->value;\\n    }\\n};\\n\\n// Define the Solution class.\\nclass Solution {\\npublic:\\n    // Vector representing four directions: up, right, down, and left.\\n    vector<vector<int>> dir = { {-1, 0}, {0, 1}, {1, 0}, {0, -1} };\\n\\n    // Priority queue to store nodes in descending order of value using CompareNode.\\n    priority_queue<Node*, vector<Node*>, CompareNode> pq;\\n\\n    // DFS function to explore the grid for points with value < queryValue.\\n    void dfs(vector<vector<int>>& grid, int startX, int startY, int queryValue, vector<vector<bool>>& visited, int rows, int cols, int& count) {\\n        // Initialize variable to track the number of visited nodes.\\n        int v = 0;\\n\\n        // Continue until the priority queue is empty or the top element\\'s value is >= queryValue.\\n        while (pq.size() != v) {\\n            if (pq.top()->value >= queryValue)\\n                return; // Return if the top node\\'s value is greater or equal to queryValue.\\n\\n            // Pop the front node from the priority queue.\\n            auto fnode = pq.top();\\n            pq.pop();\\n\\n            // Get the x and y coordinates of the current node.\\n            int x = fnode->x, y = fnode->y;\\n\\n            // Get the value of the current node.\\n            int value = fnode->value;\\n\\n            // If the value is less than queryValue, increment count.\\n            if (value < queryValue)\\n                count++;\\n\\n            // Explore the four neighboring nodes.\\n            for (int i = 0; i < 4; i++) {\\n                // Calculate the new x and y coordinates for the neighboring node.\\n                int nx = x + dir[i][0];\\n                int ny = y + dir[i][1];\\n\\n                // Check if the neighboring node is within bounds and not visited.\\n                if (nx >= 0 && ny >= 0 && nx < rows && ny < cols && !visited[nx][ny]) {\\n                    // Create a new Node for the neighboring node with its value, x, and y.\\n                    Node* n = new Node(grid[nx][ny], nx, ny);\\n\\n                    // Get the value of the neighboring node.\\n                    int nodeValue = n->value;\\n\\n                    // If the neighboring node\\'s value is less than queryValue, add it to the priority queue and mark it as visited.\\n                    if (nodeValue < queryValue) {\\n                        pq.push(n);\\n                        visited[nx][ny] = true;\\n                    }\\n                    // Otherwise, add it to the priority queue and mark it as visited, but increment v to track the number of visited nodes.\\n                    else {\\n                        pq.push(n);\\n                        visited[nx][ny] = true;\\n                        v++;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    // Function to find the maximum points less than each query value in the grid.\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        // Get the number of rows and columns in the grid.\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n\\n        // Map to store the indices of queries that have the same value.\\n        unordered_map<int, list<int>> queryMap;\\n\\n        // Get the number of queries and create a vector to store the results.\\n        int k = queries.size();\\n        vector<int> ans(k, 0);\\n\\n        // Create a Node representing the starting point (0, 0) in the grid, and add it to the priority queue.\\n        Node node(grid[0][0], 0, 0);\\n        pq.push(&node);\\n\\n        // Populate the queryMap with indices of queries having the same value.\\n        for (int i = 0; i < queries.size(); i++)\\n            queryMap[queries[i]].push_back(i);\\n        \\n        // Sort the queries in ascending order.\\n        sort(queries.begin(), queries.end());\\n\\n        // Create a 2D boolean vector to keep track of visited nodes in the grid.\\n        vector<vector<bool>> visited(rows, vector<bool>(cols, false));\\n\\n        // Mark the starting point as visited.\\n        visited[0][0] = true;\\n\\n        // Initialize a variable to count points less than the current query value.\\n        int count = 0;\\n\\n        // Iterate through each query value.\\n        for (int i = 0; i < queries.size(); i++) {\\n            // If the value at the starting point is less than the current query value, perform DFS from the starting point.\\n            if (grid[0][0] < queries[i]) {\\n                dfs(grid, 0, 0, queries[i], visited, rows, cols, count);\\n\\n                // Update the results for all queries with the same value as the current query.\\n                bool flag = false;\\n                for (auto nbr : queryMap[queries[i]]) {\\n                    ans[nbr] = count;\\n                    flag = true;\\n                    i++;\\n                }\\n                if (flag) i--; // Decrement i to avoid skipping the next query.\\n            }\\n        }\\n\\n        // Return the results for all queries.\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902292,
                "title": "python-every-detail-documented-short-elegant-heap-solution",
                "content": "# Raw Answer (Documented code below)\\n\\n```\\nclass Solution(object):\\n    def maxPoints(self, grid, queries):\\n        \"\"\"\\n        Original answer: https://leetcode.com/problems/maximum-number-of-points-from-grid-queries/solutions/2899594/python-3-solution-with-explanation-heap-binary-search/\\n        \"\"\"\\n        \\n        m,n = len(grid), len(grid[0])\\n        heap = [(grid[0][0],0,0)]\\n        heapq.heapify(heap)\\n        visited = {(0,0)}\\n        path = []\\n        \\n        while len(heap)>0:\\n            val, i, j = heappop(heap)\\n            path.append(val)\\n\\n            for a,b in [(i,j+1),(i,j-1),(i+1,j),(i-1,j)]:\\n                if 0<=a<m and 0<=b<n and (a,b) not in visited:\\n                    heapq.heappush(heap, (grid[a][b], a, b))\\n                    visited.add((a,b))\\n\\n        for i in range(1,len(path)):\\n            path[i] = max(path[i], path[i-1])\\n        \\n        return [bisect.bisect_left(path, q) for q in queries]\\n            \\n```\\n\\n# Explaination w. Documented Code\\n\\nThe intuition here is to find an \"optimized path\" through the graph by greedily go to the available block with the lowest score.\\n\\nThen we can simply count how far each query can go in the optimized path using binary search.\\n\\nWe use the following data structures / algorithms to speed up our answer:\\n\\n- Heap: quickly find the smallest element in all available blocks.\\n- Hash Map / Dictionary: quickly check if a block was visited before (so we count each block only once)\\n- Binary Search: quickly find how many elements in the path are smaller than the query number\\n\\n```\\nclass Solution(object):\\n    def maxPoints(self, grid, queries):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type queries: List[int]\\n        :rtype: List[int]\\n\\n        Original answer: https://leetcode.com/problems/maximum-number-of-points-from-grid-queries/solutions/2899594/python-3-solution-with-explanation-heap-binary-search/\\n        \"\"\"\\n\\n        m,n = len(grid), len(grid[0])\\n\\n        # The heap would be important since it allows us to quickly find the block with lowerst score\\n        # We use it to keep track of all the available blocks\\n        heap = [(grid[0][0],0,0)]\\n        heapq.heapify(heap)\\n\\n        # We use a hash table to quickly check if a block has been visited before\\n        # as we want to make sure each block only gives us score once\\n        visited = {(0,0)}\\n\\n        # This would be the optimized path\\n        path = []\\n        \\n        while len(heap)>0:\\n\\n            # The heappop function gives the element in the heap with the smallest value (and removes it)\\n            # We are using a tuple, it by default gives us the one with the smallest first value\\n            # (In this case the first value is the value of the block)\\n            val, i, j = heappop(heap)\\n\\n            # We add the smallest first value to the path\\n            path.append(val)\\n            \\n\\n            # For all valid blocks next to the visited block that has not been visited before,\\n            # we add them to the queue to mark them as available \\n            for a,b in [(i,j+1),(i,j-1),(i+1,j),(i-1,j)]:\\n                if 0<=a<m and 0<=b<n and (a,b) not in visited:\\n                    heapq.heappush(heap, (grid[a][b], a, b))\\n\\n                    # Make sure we don\\'t double count by making them visited\\n                    visited.add((a,b))\\n        \\n        # Note that in order to access the next block in the path we\\'ll have to visit the blocks before it\\n        # So the value of the query need to be larger than everything before it to access the block\\n        # e.g. the 1 in the bottom right corner of example 1 has a small value but can only be accessed\\n        #      after the query visits the 5 next to it. In the queue it would only be added after 5 has\\n        #      been visited, and therefore would only be appended to path after the 5\\n\\n        # Thus we make each element to be the max of itself and all elements before it in the path\\n        # Then if the value of query is larger than the n^th element it has access to the element\\n        for i in range(1,len(path)):\\n            path[i] = max(path[i], path[i-1])\\n        \\n        # Finally, we use binary search to find the number of elements the query is larger than\\n        # Do this for each q in query and find the answer\\n        # Note that by construction the path is a sorted list, which is pretty nice!\\n        return [bisect.bisect_left(path, q) for q in queries]\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Binary Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxPoints(self, grid, queries):\\n        \"\"\"\\n        Original answer: https://leetcode.com/problems/maximum-number-of-points-from-grid-queries/solutions/2899594/python-3-solution-with-explanation-heap-binary-search/\\n        \"\"\"\\n        \\n        m,n = len(grid), len(grid[0])\\n        heap = [(grid[0][0],0,0)]\\n        heapq.heapify(heap)\\n        visited = {(0,0)}\\n        path = []\\n        \\n        while len(heap)>0:\\n            val, i, j = heappop(heap)\\n            path.append(val)\\n\\n            for a,b in [(i,j+1),(i,j-1),(i+1,j),(i-1,j)]:\\n                if 0<=a<m and 0<=b<n and (a,b) not in visited:\\n                    heapq.heappush(heap, (grid[a][b], a, b))\\n                    visited.add((a,b))\\n\\n        for i in range(1,len(path)):\\n            path[i] = max(path[i], path[i-1])\\n        \\n        return [bisect.bisect_left(path, q) for q in queries]\\n            \\n```\n```\\nclass Solution(object):\\n    def maxPoints(self, grid, queries):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type queries: List[int]\\n        :rtype: List[int]\\n\\n        Original answer: https://leetcode.com/problems/maximum-number-of-points-from-grid-queries/solutions/2899594/python-3-solution-with-explanation-heap-binary-search/\\n        \"\"\"\\n\\n        m,n = len(grid), len(grid[0])\\n\\n        # The heap would be important since it allows us to quickly find the block with lowerst score\\n        # We use it to keep track of all the available blocks\\n        heap = [(grid[0][0],0,0)]\\n        heapq.heapify(heap)\\n\\n        # We use a hash table to quickly check if a block has been visited before\\n        # as we want to make sure each block only gives us score once\\n        visited = {(0,0)}\\n\\n        # This would be the optimized path\\n        path = []\\n        \\n        while len(heap)>0:\\n\\n            # The heappop function gives the element in the heap with the smallest value (and removes it)\\n            # We are using a tuple, it by default gives us the one with the smallest first value\\n            # (In this case the first value is the value of the block)\\n            val, i, j = heappop(heap)\\n\\n            # We add the smallest first value to the path\\n            path.append(val)\\n            \\n\\n            # For all valid blocks next to the visited block that has not been visited before,\\n            # we add them to the queue to mark them as available \\n            for a,b in [(i,j+1),(i,j-1),(i+1,j),(i-1,j)]:\\n                if 0<=a<m and 0<=b<n and (a,b) not in visited:\\n                    heapq.heappush(heap, (grid[a][b], a, b))\\n\\n                    # Make sure we don\\'t double count by making them visited\\n                    visited.add((a,b))\\n        \\n        # Note that in order to access the next block in the path we\\'ll have to visit the blocks before it\\n        # So the value of the query need to be larger than everything before it to access the block\\n        # e.g. the 1 in the bottom right corner of example 1 has a small value but can only be accessed\\n        #      after the query visits the 5 next to it. In the queue it would only be added after 5 has\\n        #      been visited, and therefore would only be appended to path after the 5\\n\\n        # Thus we make each element to be the max of itself and all elements before it in the path\\n        # Then if the value of query is larger than the n^th element it has access to the element\\n        for i in range(1,len(path)):\\n            path[i] = max(path[i], path[i-1])\\n        \\n        # Finally, we use binary search to find the number of elements the query is larger than\\n        # Do this for each q in query and find the answer\\n        # Note that by construction the path is a sorted list, which is pretty nice!\\n        return [bisect.bisect_left(path, q) for q in queries]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899788,
                "title": "simple-dsu-cpp-beats-100",
                "content": "```\\nclass DisjointUnionSet{\\nprivate :\\n    vector<int> leader, size;\\npublic :\\n    DisjointUnionSet(int mx) : leader(mx), size(mx, 1){\\n        iota(begin(leader), end(leader), 0);\\n    }\\n    int GetLeader(int a){\\n        return leader[a] == a ? a : leader[a] = GetLeader(leader[a]);\\n    }\\n    void MergeGroups(int a, int b){\\n        a = GetLeader(a); b = GetLeader(b);\\n        if(a != b){\\n            if(size[a] > size[b]) swap(a, b);\\n            size[b] += size[a];\\n            leader[a] = b;\\n        }\\n    }\\n    int GetGroupSize(int a){\\n        return size[GetLeader(a)];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> dir = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int k = size(queries);\\n        int nrows = grid.size();\\n        int ncols = grid[0].size();\\n        \\n        // Keep the value at position grid[0][0] handy\\n        int starting_value = grid[0][0];\\n        \\n        // Function to get the node_id of node at (row, col)\\n        auto id = [&](int row, int col){\\n            return (row * ncols + col);\\n        };\\n        \\n        // Storing values of \\'grid\\' along with their position into nodes.\\n        // Setting \\'grid\\' to 0. We will use \\'grid\\' now to know if a node has been visited or not.\\n        vector<array<int, 3>> nodes;\\n        for(int i = 0; i < nrows; ++i){\\n            for(int j = 0; j < ncols; ++j){\\n                nodes.push_back({grid[i][j], i, j});\\n                grid[i][j] = 0;\\n            }\\n        }\\n        \\n        // Sorting nodes in decreasing order based on values of node.\\n        sort(begin(nodes), end(nodes), greater<>());\\n        \\n        \\n        // Storing the values and indexes of queries for answering it as offline queries.\\n        vector<array<int, 2>> off_queries;\\n        for(int i = 0; i < k; ++i){\\n            off_queries.push_back({queries[i], i});\\n        }\\n        \\n        // Sorting \\'off_queries\\' in ascending order based on values.\\n        sort(begin(off_queries), end(off_queries));\\n        \\n        \\n        // Initializing DSU with size equal to number of nodes\\n        // No connections are made and each node have group size of 1.\\n        DisjointUnionSet dsu(nrows * ncols + 1);\\n        \\n        vector<int> answer(k);\\n        \\n        // Lets answer queries now\\n        for(int q = 0; q < k; ++q){\\n            // First we will activate all the nodes whose value is lesser than\\n            // the current query value. These nodes can now be traversed from now onwards.\\n            // Since we have sorted off_queries in asc order, these nodes will \\n            // remain activate for the subsequent upcoming queries as well.\\n            while(!nodes.empty() && nodes.back()[0] < off_queries[q][0]){\\n                // Get position of node\\n                int i = nodes.back()[1];\\n                int j = nodes.back()[2];\\n                \\n                // Activate current node\\n                grid[i][j] = 1;\\n                \\n                // Each node will have atmost 4 edges. If a node connected to current node is \\n                // already activated, then we can join it with the current node.\\n                for(int d = 0; d < 4; ++d){\\n                    int ni = dir[d][0] + i;\\n                    int nj = dir[d][1] + j;\\n                    if(ni >= 0 && nj >= 0 && ni < nrows && nj < ncols && grid[ni][nj]){\\n                        dsu.MergeGroups(id(ni, nj), id(i, j));\\n                    }\\n                }\\n                \\n                // Node is processed. We don\\'t need it anymore.\\n                nodes.pop_back();\\n            }\\n            \\n            // Now we have all the nodes activated such that their values is lesser than the current query value.\\n            // But we also need to make sure that current query value is greater than the starting cell value.\\n            // If it is then we can store the count of nodes connected to starting cell as answer for current query.\\n            answer[off_queries[q][1]] = (off_queries[q][0] > starting_value ? dsu.GetGroupSize(id(0, 0)) : 0);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass DisjointUnionSet{\\nprivate :\\n    vector<int> leader, size;\\npublic :\\n    DisjointUnionSet(int mx) : leader(mx), size(mx, 1){\\n        iota(begin(leader), end(leader), 0);\\n    }\\n    int GetLeader(int a){\\n        return leader[a] == a ? a : leader[a] = GetLeader(leader[a]);\\n    }\\n    void MergeGroups(int a, int b){\\n        a = GetLeader(a); b = GetLeader(b);\\n        if(a != b){\\n            if(size[a] > size[b]) swap(a, b);\\n            size[b] += size[a];\\n            leader[a] = b;\\n        }\\n    }\\n    int GetGroupSize(int a){\\n        return size[GetLeader(a)];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> dir = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int k = size(queries);\\n        int nrows = grid.size();\\n        int ncols = grid[0].size();\\n        \\n        // Keep the value at position grid[0][0] handy\\n        int starting_value = grid[0][0];\\n        \\n        // Function to get the node_id of node at (row, col)\\n        auto id = [&](int row, int col){\\n            return (row * ncols + col);\\n        };\\n        \\n        // Storing values of \\'grid\\' along with their position into nodes.\\n        // Setting \\'grid\\' to 0. We will use \\'grid\\' now to know if a node has been visited or not.\\n        vector<array<int, 3>> nodes;\\n        for(int i = 0; i < nrows; ++i){\\n            for(int j = 0; j < ncols; ++j){\\n                nodes.push_back({grid[i][j], i, j});\\n                grid[i][j] = 0;\\n            }\\n        }\\n        \\n        // Sorting nodes in decreasing order based on values of node.\\n        sort(begin(nodes), end(nodes), greater<>());\\n        \\n        \\n        // Storing the values and indexes of queries for answering it as offline queries.\\n        vector<array<int, 2>> off_queries;\\n        for(int i = 0; i < k; ++i){\\n            off_queries.push_back({queries[i], i});\\n        }\\n        \\n        // Sorting \\'off_queries\\' in ascending order based on values.\\n        sort(begin(off_queries), end(off_queries));\\n        \\n        \\n        // Initializing DSU with size equal to number of nodes\\n        // No connections are made and each node have group size of 1.\\n        DisjointUnionSet dsu(nrows * ncols + 1);\\n        \\n        vector<int> answer(k);\\n        \\n        // Lets answer queries now\\n        for(int q = 0; q < k; ++q){\\n            // First we will activate all the nodes whose value is lesser than\\n            // the current query value. These nodes can now be traversed from now onwards.\\n            // Since we have sorted off_queries in asc order, these nodes will \\n            // remain activate for the subsequent upcoming queries as well.\\n            while(!nodes.empty() && nodes.back()[0] < off_queries[q][0]){\\n                // Get position of node\\n                int i = nodes.back()[1];\\n                int j = nodes.back()[2];\\n                \\n                // Activate current node\\n                grid[i][j] = 1;\\n                \\n                // Each node will have atmost 4 edges. If a node connected to current node is \\n                // already activated, then we can join it with the current node.\\n                for(int d = 0; d < 4; ++d){\\n                    int ni = dir[d][0] + i;\\n                    int nj = dir[d][1] + j;\\n                    if(ni >= 0 && nj >= 0 && ni < nrows && nj < ncols && grid[ni][nj]){\\n                        dsu.MergeGroups(id(ni, nj), id(i, j));\\n                    }\\n                }\\n                \\n                // Node is processed. We don\\'t need it anymore.\\n                nodes.pop_back();\\n            }\\n            \\n            // Now we have all the nodes activated such that their values is lesser than the current query value.\\n            // But we also need to make sure that current query value is greater than the starting cell value.\\n            // If it is then we can store the count of nodes connected to starting cell as answer for current query.\\n            answer[off_queries[q][1]] = (off_queries[q][0] > starting_value ? dsu.GetGroupSize(id(0, 0)) : 0);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899556,
                "title": "java-priorityqueue-offline-query",
                "content": "# Intuition\\nUse the concept of offline query.\\n\\n# Approach\\nFirst sort the query and then use priorityqueue to get min value cell.\\nif value is less than query update count \\nelse cnt is ans for ith query.\\n\\n\\n# Complexity\\n- Time complexity: O(n*m*log(n*m))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxPoints(int[][] a, int[] q) {\\n        \\n        int n = a.length;\\n        int m = a[0].length;\\n        \\n        int l = q.length;\\n        int[][] p = new int[l][2];\\n        \\n        for(int i = 0 ; i < l ; i++) {\\n            \\n            p[i][0] = i;\\n            p[i][1] = q[i];\\n        }\\n        \\n        Arrays.sort(p, (o1,o2)-> {\\n            \\n            if(o1[1] == o2[1]) {\\n                \\n                Integer.compare(o1[0],o2[0]);\\n            }\\n            \\n            return Integer.compare(o1[1],o2[1]);\\n        });\\n        \\n        PriorityQueue<int[]> qu = new PriorityQueue<>((o1,o2)->{\\n            \\n            return Integer.compare(a[o1[0]][o1[1]],a[o2[0]][o2[1]]);\\n        });\\n        \\n        qu.add(new int[]{0,0});\\n        \\n        boolean[][] v = new boolean[n][m];\\n        int cnt = 0;\\n        int idx = 0;\\n        \\n        while(qu.size() > 0 && idx < l) {\\n            \\n            int[] f = qu.remove();\\n            int r = f[0] , c = f[1];\\n            \\n            if(v[r][c]) continue;\\n            \\n            v[r][c] = true;\\n            \\n            if(a[r][c] < p[idx][1]) {\\n                \\n                cnt++;\\n            }\\n            else{\\n                \\n                q[p[idx][0]] = cnt;\\n                idx++;\\n                qu.add(f);\\n                v[r][c] = false;\\n                continue;\\n            }\\n            \\n            if(c+1 < m && v[r][c+1] == false) qu.add(new int[]{r,c+1});\\n            if(r+1 < n && v[r+1][c] == false) qu.add(new int[]{r+1,c});\\n            if(r-1 >=0 && v[r-1][c] == false) qu.add(new int[]{r-1,c});\\n            if(c-1 >= 0 && v[r][c-1] == false) qu.add(new int[]{r,c-1});\\n        }\\n        \\n        while(idx < l) {\\n            \\n            q[p[idx][0]] = cnt;\\n            idx++;\\n        }\\n        \\n        return q;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxPoints(int[][] a, int[] q) {\\n        \\n        int n = a.length;\\n        int m = a[0].length;\\n        \\n        int l = q.length;\\n        int[][] p = new int[l][2];\\n        \\n        for(int i = 0 ; i < l ; i++) {\\n            \\n            p[i][0] = i;\\n            p[i][1] = q[i];\\n        }\\n        \\n        Arrays.sort(p, (o1,o2)-> {\\n            \\n            if(o1[1] == o2[1]) {\\n                \\n                Integer.compare(o1[0],o2[0]);\\n            }\\n            \\n            return Integer.compare(o1[1],o2[1]);\\n        });\\n        \\n        PriorityQueue<int[]> qu = new PriorityQueue<>((o1,o2)->{\\n            \\n            return Integer.compare(a[o1[0]][o1[1]],a[o2[0]][o2[1]]);\\n        });\\n        \\n        qu.add(new int[]{0,0});\\n        \\n        boolean[][] v = new boolean[n][m];\\n        int cnt = 0;\\n        int idx = 0;\\n        \\n        while(qu.size() > 0 && idx < l) {\\n            \\n            int[] f = qu.remove();\\n            int r = f[0] , c = f[1];\\n            \\n            if(v[r][c]) continue;\\n            \\n            v[r][c] = true;\\n            \\n            if(a[r][c] < p[idx][1]) {\\n                \\n                cnt++;\\n            }\\n            else{\\n                \\n                q[p[idx][0]] = cnt;\\n                idx++;\\n                qu.add(f);\\n                v[r][c] = false;\\n                continue;\\n            }\\n            \\n            if(c+1 < m && v[r][c+1] == false) qu.add(new int[]{r,c+1});\\n            if(r+1 < n && v[r+1][c] == false) qu.add(new int[]{r+1,c});\\n            if(r-1 >=0 && v[r-1][c] == false) qu.add(new int[]{r-1,c});\\n            if(c-1 >= 0 && v[r][c-1] == false) qu.add(new int[]{r,c-1});\\n        }\\n        \\n        while(idx < l) {\\n            \\n            q[p[idx][0]] = cnt;\\n            idx++;\\n        }\\n        \\n        return q;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914369,
                "title": "simple-solution-cleanest-code-commmented-o-n-m-easy-to-understand-fast-prriotised-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& g, vector<int>& queries) {\\n      \\n      // Initialising everything we require  \\n      vector<pair<int,int>>q;\\n      // Storing the value and index so that we can sort and yet access our index\\n      int tempans = 0;\\n      vector<int>ans(queries.size(),0);  \\n      vector<vector<bool>>vis(g.size(),vector<bool>(g[0].size(),false));\\n      // Visited array \\n      priority_queue<pair<int,pair<int,int>> , vector<pair<int,pair<int,int>>> , greater<pair<int,pair<int,int>>>> pq; \\n      // priority queue to store  i , j coordinates and grid value , priority sorted by increasing order of grid value at i and j ;\\n      pq.push({g[0][0],{0,0}});\\n      vis[0][0]=true;\\n     \\n          \\n        \\n      // Storing value with index to sort\\n      // We sort because if query[i] < query [i+1] then the cells which are included in query [i] will also be included in query [i+1] so we dont calc it again...\\n      for(int i=0 ;i<queries.size();i++)\\n      q.push_back({queries[i],i});\\n      sort(q.begin(),q.end());\\n        \\n      for(auto  query:q)\\n      {\\n          // prioritised BFS , basically breaking when our grid values start to be larger than query  \\n          while(!pq.empty() && pq.top().first<query.first )\\n          {\\n              int x=pq.top().second.first, y=pq.top().second.second;\\n              pq.pop();\\n              \\n              if(x>0 && !vis[x-1][y])\\n              pq.push({g[x-1][y],{x-1,y}}) ,  vis[x-1][y]=true;;\\n              if(y>0 && !vis[x][y-1])\\n              pq.push({g[x][y-1] ,{x,y-1}}) ,  vis[x][y-1]=true;;\\n              if(x+1<g.size() && !vis[x+1][y])\\n              pq.push({g[x+1][y],{x+1,y}}) ,  vis[x+1][y]=true;;\\n              if(y+1<g[0].size() && !vis[x][y+1])\\n              pq.push({g[x][y+1],{x,y+1}}) ,  vis[x][y+1]=true;;\\n              \\n              tempans++;\\n          }\\n          ans[query.second]=tempans;\\n      }\\n        \\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& g, vector<int>& queries) {\\n      \\n      // Initialising everything we require  \\n      vector<pair<int,int>>q;\\n      // Storing the value and index so that we can sort and yet access our index\\n      int tempans = 0;\\n      vector<int>ans(queries.size(),0);  \\n      vector<vector<bool>>vis(g.size(),vector<bool>(g[0].size(),false));\\n      // Visited array \\n      priority_queue<pair<int,pair<int,int>> , vector<pair<int,pair<int,int>>> , greater<pair<int,pair<int,int>>>> pq; \\n      // priority queue to store  i , j coordinates and grid value , priority sorted by increasing order of grid value at i and j ;\\n      pq.push({g[0][0],{0,0}});\\n      vis[0][0]=true;\\n     \\n          \\n        \\n      // Storing value with index to sort\\n      // We sort because if query[i] < query [i+1] then the cells which are included in query [i] will also be included in query [i+1] so we dont calc it again...\\n      for(int i=0 ;i<queries.size();i++)\\n      q.push_back({queries[i],i});\\n      sort(q.begin(),q.end());\\n        \\n      for(auto  query:q)\\n      {\\n          // prioritised BFS , basically breaking when our grid values start to be larger than query  \\n          while(!pq.empty() && pq.top().first<query.first )\\n          {\\n              int x=pq.top().second.first, y=pq.top().second.second;\\n              pq.pop();\\n              \\n              if(x>0 && !vis[x-1][y])\\n              pq.push({g[x-1][y],{x-1,y}}) ,  vis[x-1][y]=true;;\\n              if(y>0 && !vis[x][y-1])\\n              pq.push({g[x][y-1] ,{x,y-1}}) ,  vis[x][y-1]=true;;\\n              if(x+1<g.size() && !vis[x+1][y])\\n              pq.push({g[x+1][y],{x+1,y}}) ,  vis[x+1][y]=true;;\\n              if(y+1<g[0].size() && !vis[x][y+1])\\n              pq.push({g[x][y+1],{x,y+1}}) ,  vis[x][y+1]=true;;\\n              \\n              tempans++;\\n          }\\n          ans[query.second]=tempans;\\n      }\\n        \\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906261,
                "title": "bfs-minheap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        vector<pair<int,int>>v;\\n        int p=queries.size();\\n        for(int i=0;i<p;i++){\\n            v.push_back({queries[i],i});\\n\\n        }\\n        sort(begin(v),end(v));\\n        vector<int>ans(p,0);\\n        int row[4]={1,0,-1,0};\\n        int col[4]={0,1,0,-1};\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int vis[n][m];\\n        memset(vis,0,sizeof(vis));\\n        queue<pair<int,int>>q;\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>gre;\\n        int j;\\n        for(j=0;j<p;j++){\\n            if(v[j].first<=grid[0][0]){\\n                ans[v[j].second]=0;\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n        if(j==p)return ans;\\n        q.push({0,0});\\n        vis[0][0]=1;\\n        int cnt=0;\\n\\n        while(!q.empty() || !gre.empty()){\\n            \\n            pair<int,int>p1=q.front();\\n            q.pop();\\n            int i=p1.first;\\n            int j1=p1.second;\\n            cnt++;\\n            for(int k=0;k<=3;k++){\\n                int nx=i+row[k];\\n                int ny=j1+col[k];\\n                if(nx>=n || ny>=m || nx<0 || ny<0)continue;\\n                if(vis[nx][ny])continue;\\n                if(grid[nx][ny]<v[j].first){\\n                    vis[nx][ny]=1;\\n                    q.push({nx,ny});\\n                }else{\\n                    gre.push({grid[nx][ny],nx,ny});\\n                    vis[nx][ny]=1;\\n                }\\n            }\\n            \\n            if(q.size()==0){\\n                ans[v[j].second]=cnt;\\n                j++;\\n                while(j<p && !gre.empty() && (gre.top())[0]>=v[j].first){\\n                    ans[v[j].second]=cnt;\\n                    j++;\\n                }\\n                \\n                if(j==p)break;\\n                while(!gre.empty() && (gre.top())[0]<v[j].first){\\n                    q.push({(gre.top())[1],(gre.top())[2]});\\n                    gre.pop();\\n                } \\n            }\\n            \\n        }\\n        while(j<p)ans[v[j++].second]=cnt;\\n        \\n        return ans;\\n       \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        vector<pair<int,int>>v;\\n        int p=queries.size();\\n        for(int i=0;i<p;i++){\\n            v.push_back({queries[i],i});\\n\\n        }\\n        sort(begin(v),end(v));\\n        vector<int>ans(p,0);\\n        int row[4]={1,0,-1,0};\\n        int col[4]={0,1,0,-1};\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int vis[n][m];\\n        memset(vis,0,sizeof(vis));\\n        queue<pair<int,int>>q;\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>gre;\\n        int j;\\n        for(j=0;j<p;j++){\\n            if(v[j].first<=grid[0][0]){\\n                ans[v[j].second]=0;\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n        if(j==p)return ans;\\n        q.push({0,0});\\n        vis[0][0]=1;\\n        int cnt=0;\\n\\n        while(!q.empty() || !gre.empty()){\\n            \\n            pair<int,int>p1=q.front();\\n            q.pop();\\n            int i=p1.first;\\n            int j1=p1.second;\\n            cnt++;\\n            for(int k=0;k<=3;k++){\\n                int nx=i+row[k];\\n                int ny=j1+col[k];\\n                if(nx>=n || ny>=m || nx<0 || ny<0)continue;\\n                if(vis[nx][ny])continue;\\n                if(grid[nx][ny]<v[j].first){\\n                    vis[nx][ny]=1;\\n                    q.push({nx,ny});\\n                }else{\\n                    gre.push({grid[nx][ny],nx,ny});\\n                    vis[nx][ny]=1;\\n                }\\n            }\\n            \\n            if(q.size()==0){\\n                ans[v[j].second]=cnt;\\n                j++;\\n                while(j<p && !gre.empty() && (gre.top())[0]>=v[j].first){\\n                    ans[v[j].second]=cnt;\\n                    j++;\\n                }\\n                \\n                if(j==p)break;\\n                while(!gre.empty() && (gre.top())[0]<v[j].first){\\n                    q.push({(gre.top())[1],(gre.top())[2]});\\n                    gre.pop();\\n                } \\n            }\\n            \\n        }\\n        while(j<p)ans[v[j++].second]=cnt;\\n        \\n        return ans;\\n       \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902821,
                "title": "python-with-explanation-dynamic-programming-dfs-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe bigger query will cover all nodes traversed by the smaller queries.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. sort the query array and keep track of its original index to solve the problem with dynamic programming\\n2. traverse all possible nodes and mark them as visited\\n3. if a node is larger or equal to the query we keep track of it, and try to solve it in the next query\\n4. try to traverse from the nodes we can\\'t solve from the previous query\\n\\nUsing a heap or using binary search to maintain the order of the nodes to be solved next can save some time. (if not the result will be: TLE)\\n# Complexity\\n- Time complexity: $$O(Q*M*N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M*N+Q)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nPlease correct me if I\\'m wrong, thanks.\\n# Code\\n```python3\\nimport heapq\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        def dfs(q, r=0, c=0):\\n            dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n            count = 1\\n            for dr, dc in dirs:\\n                nr, nc = r+dr, c+dc\\n                if nr < 0 or nr >= m or nc < 0 or nc >= n or (nr, nc) in visited:\\n                    continue\\n                if (nr, nc) in edges_set:\\n                    continue\\n                if q <= grid[nr][nc]:\\n                    heapq.heappush(edges, (grid[nr][nc], nr, nc))\\n                    edges_set.add((nr, nc))\\n                    continue\\n                visited.add((nr, nc))\\n                count += dfs(q, nr, nc)\\n\\n            return count\\n        \\n        result = [0] * len(queries)\\n        pos = [(q, i) for i, q in enumerate(queries)]\\n        pos.sort()\\n        visited = set()\\n        edges = [(grid[0][0], 0, 0)]\\n        edges_set = set() # to avoid additional node being added to edges(heap)\\n        edges_set.add((0, 0))\\n        points = 0\\n        for q, i in pos:\\n            for _ in range(len(edges)):\\n                val, r, c = edges[0]\\n                if q > val and (r, c) not in visited:\\n                    heapq.heappop(edges)\\n                    edges_set.remove((r, c))\\n                    visited.add((r, c))\\n                    points += dfs(q, r, c)\\n                else:\\n                    break\\n            result[i] = points\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```python3\\nimport heapq\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        def dfs(q, r=0, c=0):\\n            dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n            count = 1\\n            for dr, dc in dirs:\\n                nr, nc = r+dr, c+dc\\n                if nr < 0 or nr >= m or nc < 0 or nc >= n or (nr, nc) in visited:\\n                    continue\\n                if (nr, nc) in edges_set:\\n                    continue\\n                if q <= grid[nr][nc]:\\n                    heapq.heappush(edges, (grid[nr][nc], nr, nc))\\n                    edges_set.add((nr, nc))\\n                    continue\\n                visited.add((nr, nc))\\n                count += dfs(q, nr, nc)\\n\\n            return count\\n        \\n        result = [0] * len(queries)\\n        pos = [(q, i) for i, q in enumerate(queries)]\\n        pos.sort()\\n        visited = set()\\n        edges = [(grid[0][0], 0, 0)]\\n        edges_set = set() # to avoid additional node being added to edges(heap)\\n        edges_set.add((0, 0))\\n        points = 0\\n        for q, i in pos:\\n            for _ in range(len(edges)):\\n                val, r, c = edges[0]\\n                if q > val and (r, c) not in visited:\\n                    heapq.heappop(edges)\\n                    edges_set.remove((r, c))\\n                    visited.add((r, c))\\n                    points += dfs(q, r, c)\\n                else:\\n                    break\\n            result[i] = points\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902485,
                "title": "intuitive-python-bfs-with-heap-explained-complexity",
                "content": "Inuition:\\n\\n* Iterate through the queries from smallest to largest.\\n* BFS, starting from top-left. Only visit cells that are smaller than the current query.\\n    * Once we visit a cell, then we will consider the neighbors.\\n    * Priority queue / min-heap helps us do this efficiently. Priority is based on value of the grid cell.\\n    * Increment n_visited when visiting a cell. When there are no more candidate nodes in the heap, then n_visited is the answer for the current query.\\n\\nComplexity, I believe, is *k\\\\*log(k) + m\\\\*n + m\\\\*n\\\\*log(m\\\\*n)*.\\n\\n* k\\\\*log(k) for sorting the queue (k = len(queries)).\\n* m\\\\*n for traversing the grid.\\n* m\\\\*n\\\\*log(m\\\\*n)) for the heap.\\n\\n```python\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        # Some setup\\n        dirs = [(0,1),(1,0),(-1,0),(0,-1)]\\n        nrows = len(grid)\\n        ncols = len(grid[0])\\n\\t\\t\\n        # Sort queries. Keep track of the original index.\\n        q_and_i = [[queries[i], i] for i in range(len(queries))]\\n        q_and_i.sort()  # Sort based on the value of the query\\n\\t\\n        # Prepare for BFS. Start with top-left cell.\\n        answer = [0 for _ in range(len(queries))]\\n        heap = [[grid[0][0], 0, 0]]\\n        seen = {(0,0)}  # Cells we have seen (but not necessarily visited)\\n        n_visited = 0\\n\\t\\t\\n        # BFS. Go through queries from smallest to largest.\\n        for q, i in q_and_i:\\n\\t\\t    # Only visit a cell if it is less than the current query\\n            while heap and heap[0][0] < q:\\n                n_visited += 1\\n                _, r, c = heapq.heappop(heap)\\n\\t\\t\\t\\t# Check all neighboring cells\\n                for h, v in dirs:\\n                    r2, c2 = r + v, c + h\\n\\t\\t\\t\\t\\t# Check that coordinates are valid\\n                    if r2 >= 0 and r2 < nrows and c2 >= 0 and c2 < ncols:\\n\\t\\t\\t\\t\\t    # Check that the cell has never been in the heap\\n                        if (r2, c2) not in seen:\\n\\t\\t\\t\\t\\t\\t    # Add cell to our options\\n                            seen.add((r2, c2))\\n                            heapq.heappush(heap, [grid[r2][c2], r2, c2])\\n\\t\\t\\t# Update the answer for the current query\\n            answer[i] = n_visited\\n        #\\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        # Some setup\\n        dirs = [(0,1),(1,0),(-1,0),(0,-1)]\\n        nrows = len(grid)\\n        ncols = len(grid[0])\\n\\t\\t\\n        # Sort queries. Keep track of the original index.\\n        q_and_i = [[queries[i], i] for i in range(len(queries))]\\n        q_and_i.sort()  # Sort based on the value of the query\\n\\t\\n        # Prepare for BFS. Start with top-left cell.\\n        answer = [0 for _ in range(len(queries))]\\n        heap = [[grid[0][0], 0, 0]]\\n        seen = {(0,0)}  # Cells we have seen (but not necessarily visited)\\n        n_visited = 0\\n\\t\\t\\n        # BFS. Go through queries from smallest to largest.\\n        for q, i in q_and_i:\\n\\t\\t    # Only visit a cell if it is less than the current query\\n            while heap and heap[0][0] < q:\\n                n_visited += 1\\n                _, r, c = heapq.heappop(heap)\\n\\t\\t\\t\\t# Check all neighboring cells\\n                for h, v in dirs:\\n                    r2, c2 = r + v, c + h\\n\\t\\t\\t\\t\\t# Check that coordinates are valid\\n                    if r2 >= 0 and r2 < nrows and c2 >= 0 and c2 < ncols:\\n\\t\\t\\t\\t\\t    # Check that the cell has never been in the heap\\n                        if (r2, c2) not in seen:\\n\\t\\t\\t\\t\\t\\t    # Add cell to our options\\n                            seen.add((r2, c2))\\n                            heapq.heappush(heap, [grid[r2][c2], r2, c2])\\n\\t\\t\\t# Update the answer for the current query\\n            answer[i] = n_visited\\n        #\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901215,
                "title": "rust-solution-using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1) Sort the quieries so that they are processed in incresing order\\n2) Perform DFS using a priority_queue starting from (0, 0) with only processing the grids that have values which are less than the current query value.   \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(M * N * (Log M + Log N))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(M * N)\\n# Code\\n```\\nuse std::cmp::Reverse;\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn max_points(grid: Vec<Vec<i32>>, queries: Vec<i32>) -> Vec<i32> {\\n        let mut data = vec![];\\n        for i in 0 .. queries.len() { data.push((queries[i], i)); }\\n        data.sort();\\n        \\n        let mut ret = vec![0; data.len()];\\n        let (m, n) = (grid.len(), grid[0].len());\\n        let mut flag = vec![vec![0; n]; m];\\n        let mut pq = BinaryHeap::from([Reverse((grid[0][0], 0, 0))]);\\n        let mut count = 0;\\n        let dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]];\\n        flag[0][0] = 1;\\n        \\n        for q in data {\\n            while let Some(Reverse((val, u, v))) = pq.peek() {\\n                if *val >= q.0 { break }\\n                let (u, v) = (*u as i32, *v as i32);\\n                count += 1;\\n                pq.pop();\\n                \\n                for d in dirs {\\n                    let (i, j) = (u + d[0], v + d[1]);\\n                    if i < 0 || i == m as i32 || j < 0 || j == n as i32 { continue }\\n                    \\n                    let (i, j) = (i as usize, j as usize);\\n                    if flag[i][j] == 1 { continue }\\n                    \\n                    flag[i][j] = 1;\\n                    pq.push(Reverse((grid[i][j], i, j)));\\n                }\\n            }\\n            \\n            ret[q.1] = count;\\n        }\\n        \\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::Reverse;\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn max_points(grid: Vec<Vec<i32>>, queries: Vec<i32>) -> Vec<i32> {\\n        let mut data = vec![];\\n        for i in 0 .. queries.len() { data.push((queries[i], i)); }\\n        data.sort();\\n        \\n        let mut ret = vec![0; data.len()];\\n        let (m, n) = (grid.len(), grid[0].len());\\n        let mut flag = vec![vec![0; n]; m];\\n        let mut pq = BinaryHeap::from([Reverse((grid[0][0], 0, 0))]);\\n        let mut count = 0;\\n        let dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]];\\n        flag[0][0] = 1;\\n        \\n        for q in data {\\n            while let Some(Reverse((val, u, v))) = pq.peek() {\\n                if *val >= q.0 { break }\\n                let (u, v) = (*u as i32, *v as i32);\\n                count += 1;\\n                pq.pop();\\n                \\n                for d in dirs {\\n                    let (i, j) = (u + d[0], v + d[1]);\\n                    if i < 0 || i == m as i32 || j < 0 || j == n as i32 { continue }\\n                    \\n                    let (i, j) = (i as usize, j as usize);\\n                    if flag[i][j] == 1 { continue }\\n                    \\n                    flag[i][j] = 1;\\n                    pq.push(Reverse((grid[i][j], i, j)));\\n                }\\n            }\\n            \\n            ret[q.1] = count;\\n        }\\n        \\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2900862,
                "title": "simple-extension-to-the-flood-fill-algorithm",
                "content": "# Approach\\nOn first approach this looks like a simple flood fill algorithm. But we have to process k queries. If we apply the flood fill starting from top left for each query our time complexity becomes O(m*n*k).\\nBut this is too large for given constraints.\\nWe observe that the checking condition asks us to move to cells which are strictly less than queries[i]. \\nSo cell < queries[i] and queries[j] > queries[i] => cell < queries[j].\\n**Thus we can process the queries in the increasing order and instead of starting all over again we can resume our flood fill from the leaf nodes of the last execution.**\\n\\n\\n# Complexity\\n- Time complexity: O(max(k, m*n))\\nFrom the code it might look like the complexity is greater than that but we are actually visiting any given cell atmost once. \\n\\n\\n- Space complexity: O(m*n)\\nWe use a 2-D vector to store visited nodes. We can also use a set.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int k = queries.size();\\n        if(m == 0 or n == 0 or k == 0){\\n            return {};\\n        }\\n        vector<pair<int,int>> sorted(k);\\n        for(int i=0 ; i<k ; i++){\\n            sorted[i] = {queries[i], i};\\n        }\\n        sort(sorted.begin(), sorted.end());\\n        // for(auto i:sorted){\\n        //     cout<<i.first<<\" \"<<i.second<<endl;\\n        // }\\n        vector<vector<bool>> visited(m , vector<bool> (n , false));\\n        queue<pair<int,int>> q;//queue which will store the terminal/leaf nodes from last bfs\\n        vector<int> answer(k,0);\\n        q.push({0,0});\\n        visited[0][0] = true;\\n        for(int i=0 ; i<k ; i++){\\n            if(i>0){\\n                answer[sorted[i].second] = answer[sorted[i-1].second];\\n                if(sorted[i].first == sorted[i-1].first){\\n                    continue;\\n                }\\n            }\\n            queue<pair<int,int>> currq;\\n            while(!q.empty()){\\n                pair<int,int> elem = q.front();\\n                currq.push(elem);\\n                q.pop();\\n            }\\n            //we will continue the bfs from last nodes instead of starting all over again from top left\\n           \\n            int added = 0;\\n            while(!currq.empty()){\\n                pair<int,int> curr = currq.front();\\n                currq.pop();\\n                int currx = curr.first;\\n                int curry = curr.second;\\n                if(grid[currx][curry] < sorted[i].first){\\n                    added+=1;\\n                    //go in all four directions\\n                    int dx[4] = {-1,1,0,0};\\n                    int dy[4] = {0,0,1,-1};\\n                    for(int j=0 ; j<4 ; j++){\\n                        int nxtx = currx + dx[j];\\n                        int nxty = curry + dy[j];\\n                        if(nxtx>=0 and nxty>=0 and nxtx<m and nxty<n and visited[nxtx][nxty] == false){\\n                            currq.push({nxtx, nxty});\\n                            visited[nxtx][nxty] = true;\\n                        }\\n                    }\\n                }else{\\n                    q.push(curr);\\n                }\\n            }\\n            answer[sorted[i].second]+=added;\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int k = queries.size();\\n        if(m == 0 or n == 0 or k == 0){\\n            return {};\\n        }\\n        vector<pair<int,int>> sorted(k);\\n        for(int i=0 ; i<k ; i++){\\n            sorted[i] = {queries[i], i};\\n        }\\n        sort(sorted.begin(), sorted.end());\\n        // for(auto i:sorted){\\n        //     cout<<i.first<<\" \"<<i.second<<endl;\\n        // }\\n        vector<vector<bool>> visited(m , vector<bool> (n , false));\\n        queue<pair<int,int>> q;//queue which will store the terminal/leaf nodes from last bfs\\n        vector<int> answer(k,0);\\n        q.push({0,0});\\n        visited[0][0] = true;\\n        for(int i=0 ; i<k ; i++){\\n            if(i>0){\\n                answer[sorted[i].second] = answer[sorted[i-1].second];\\n                if(sorted[i].first == sorted[i-1].first){\\n                    continue;\\n                }\\n            }\\n            queue<pair<int,int>> currq;\\n            while(!q.empty()){\\n                pair<int,int> elem = q.front();\\n                currq.push(elem);\\n                q.pop();\\n            }\\n            //we will continue the bfs from last nodes instead of starting all over again from top left\\n           \\n            int added = 0;\\n            while(!currq.empty()){\\n                pair<int,int> curr = currq.front();\\n                currq.pop();\\n                int currx = curr.first;\\n                int curry = curr.second;\\n                if(grid[currx][curry] < sorted[i].first){\\n                    added+=1;\\n                    //go in all four directions\\n                    int dx[4] = {-1,1,0,0};\\n                    int dy[4] = {0,0,1,-1};\\n                    for(int j=0 ; j<4 ; j++){\\n                        int nxtx = currx + dx[j];\\n                        int nxty = curry + dy[j];\\n                        if(nxtx>=0 and nxty>=0 and nxtx<m and nxty<n and visited[nxtx][nxty] == false){\\n                            currq.push({nxtx, nxty});\\n                            visited[nxtx][nxty] = true;\\n                        }\\n                    }\\n                }else{\\n                    q.push(curr);\\n                }\\n            }\\n            answer[sorted[i].second]+=added;\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2900060,
                "title": "python-bfs-min-heap-solution-faster-than-100",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can sort queries. Just remember to return the results in the original order. Given a threshold ```query```, we can form a reachable region from (0,0), and we can record the boundary. This can be done by BFS with min heap. Given a larger threshold and a recorded boundary, we can enlarge the reachable region by the same method.\\nThe complexity is O(m*n + klogk) because, despite all these queries, we have only one BFS across the whole grid effectively, and we have one sort on queries.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        numRows, numCols = len(grid), len(grid[0])\\n        queriesSorted, hashMap = sorted(queries), {}\\n        heap, visited = [(grid[0][0], 0, 0)], set()\\n        visited.add((0, 0))\\n        for query in queriesSorted:\\n            while heap:\\n                val, row, col = heap[0]\\n                if val >= query:\\n                    break\\n                heappop(heap)\\n                for newRow, newCol in (row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1):\\n                    if newRow < 0 or newRow >= numRows or newCol < 0 or newCol >= numCols: \\n                        continue\\n                    if (newRow, newCol) in visited: \\n                        continue\\n                    heappush(heap, (grid[newRow][newCol], newRow, newCol))\\n                    visited.add((newRow, newCol))\\n            hashMap[query] = len(visited) - len(heap)\\n        return [hashMap[query] for query in queries]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```query```\n```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        numRows, numCols = len(grid), len(grid[0])\\n        queriesSorted, hashMap = sorted(queries), {}\\n        heap, visited = [(grid[0][0], 0, 0)], set()\\n        visited.add((0, 0))\\n        for query in queriesSorted:\\n            while heap:\\n                val, row, col = heap[0]\\n                if val >= query:\\n                    break\\n                heappop(heap)\\n                for newRow, newCol in (row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1):\\n                    if newRow < 0 or newRow >= numRows or newCol < 0 or newCol >= numCols: \\n                        continue\\n                    if (newRow, newCol) in visited: \\n                        continue\\n                    heappush(heap, (grid[newRow][newCol], newRow, newCol))\\n                    visited.add((newRow, newCol))\\n            hashMap[query] = len(visited) - len(heap)\\n        return [hashMap[query] for query in queries]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899725,
                "title": "python-my-crappy-bfs-solution-100",
                "content": "sort queries, and start BFS layer upon layer...\\n```\\nclass Solution(object):\\n    def maxPoints(self, grid, queries):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type queries: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        q = []\\n        for i, v in enumerate(queries):\\n            q.append((v, i))\\n        q.sort()\\n        res = [0]*len(queries)\\n        \\n        def bfs(queue, limit):\\n            count = 0\\n            mn = float(\\'inf\\')\\n            nxtQueue = collections.deque([])\\n            while queue:\\n                for _ in range(len(queue)):\\n                    currR, currC = queue.popleft()\\n                    if grid[currR][currC] < limit:\\n                        count += 1\\n                        for dr, dc in ((1, 0), (0, 1), (-1, 0), (0, -1)):\\n                            nr = currR+dr\\n                            nc = currC+dc\\n                            if 0<=nr<len(grid) and 0<=nc<len(grid[0]) and (nr,nc) not in visited:\\n                                visited.add((nr, nc))\\n                                queue.append((nr, nc))\\n                    else:\\n                        mn = min(mn, grid[currR][currC])\\n                        nxtQueue.append((currR, currC))\\n            return count, nxtQueue, mn\\n        \\n        queue = collections.deque([(0, 0)])\\n        count = 0\\n        visited = set([(0, 0)])\\n        tot = 0\\n        mn = grid[0][0]\\n        \\n        for val, ind in q:\\n            if val <= mn:\\n                res[ind] = tot\\n                continue\\n            count, queue, mn = bfs(queue, val)\\n            res[ind] = tot+count\\n            tot += count\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxPoints(self, grid, queries):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type queries: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        q = []\\n        for i, v in enumerate(queries):\\n            q.append((v, i))\\n        q.sort()\\n        res = [0]*len(queries)\\n        \\n        def bfs(queue, limit):\\n            count = 0\\n            mn = float(\\'inf\\')\\n            nxtQueue = collections.deque([])\\n            while queue:\\n                for _ in range(len(queue)):\\n                    currR, currC = queue.popleft()\\n                    if grid[currR][currC] < limit:\\n                        count += 1\\n                        for dr, dc in ((1, 0), (0, 1), (-1, 0), (0, -1)):\\n                            nr = currR+dr\\n                            nc = currC+dc\\n                            if 0<=nr<len(grid) and 0<=nc<len(grid[0]) and (nr,nc) not in visited:\\n                                visited.add((nr, nc))\\n                                queue.append((nr, nc))\\n                    else:\\n                        mn = min(mn, grid[currR][currC])\\n                        nxtQueue.append((currR, currC))\\n            return count, nxtQueue, mn\\n        \\n        queue = collections.deque([(0, 0)])\\n        count = 0\\n        visited = set([(0, 0)])\\n        tot = 0\\n        mn = grid[0][0]\\n        \\n        for val, ind in q:\\n            if val <= mn:\\n                res[ind] = tot\\n                continue\\n            count, queue, mn = bfs(queue, val)\\n            res[ind] = tot+count\\n            tot += count\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899659,
                "title": "python3-bfs-heap-prefixsum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nKeep visiting smallest nodes as you see them. Keep running maximum and store that track that maximum number -> nodes seen. Take the keys and values out of the array and sort by key. Calculate prefix sum of the values. For each query, perform a binary search to find # of nodes below value `q`\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n\\\\log{n})$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        g = defaultdict(int)\\n        visited = []\\n        visited.append((grid[0][0], 0,0))\\n        vis = set()\\n        m = 0\\n        while visited:\\n            tv, tl, tr = heappop(visited)\\n            if (tl,tr) in vis:\\n                continue\\n            vis.add((tl, tr))\\n            m = max(tv, m)\\n            print(tv, tl, tr, m)\\n            \\n            g[m]+=1\\n            for x,y in [[-1, 0], [1, 0], [0, 1], [0, -1]]:\\n                a = tl+x\\n                b = tr +y\\n                if a >=0 and a < len(grid) and b >=0 and b < len(grid[0]):\\n                    if (a,b) not in vis:\\n                        heappush(visited, (grid[a][b], a, b))\\n        print(g)\\n        res = []\\n        gsort = [[k,v] for k,v in g.items()]\\n        gsort.sort()\\n        for i in range(1, len(gsort)):\\n            gsort[i][1] += gsort[i-1][1]\\n        print(gsort)\\n        for q in queries:\\n            dex = bisect_left(gsort, [q-1, float(\\'inf\\')])-1\\n            if q <= gsort[dex][0]:\\n                res.append(0)\\n                continue\\n            res.append(gsort[dex][1])\\n        return res\\n            \\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        g = defaultdict(int)\\n        visited = []\\n        visited.append((grid[0][0], 0,0))\\n        vis = set()\\n        m = 0\\n        while visited:\\n            tv, tl, tr = heappop(visited)\\n            if (tl,tr) in vis:\\n                continue\\n            vis.add((tl, tr))\\n            m = max(tv, m)\\n            print(tv, tl, tr, m)\\n            \\n            g[m]+=1\\n            for x,y in [[-1, 0], [1, 0], [0, 1], [0, -1]]:\\n                a = tl+x\\n                b = tr +y\\n                if a >=0 and a < len(grid) and b >=0 and b < len(grid[0]):\\n                    if (a,b) not in vis:\\n                        heappush(visited, (grid[a][b], a, b))\\n        print(g)\\n        res = []\\n        gsort = [[k,v] for k,v in g.items()]\\n        gsort.sort()\\n        for i in range(1, len(gsort)):\\n            gsort[i][1] += gsort[i-1][1]\\n        print(gsort)\\n        for q in queries:\\n            dex = bisect_left(gsort, [q-1, float(\\'inf\\')])-1\\n            if q <= gsort[dex][0]:\\n                res.append(0)\\n                continue\\n            res.append(gsort[dex][1])\\n        return res\\n            \\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899619,
                "title": "using-set-dfs-and-sorting",
                "content": "First of all we sort the queries array using a duplicate array, so that we can move in non-decreaing order and use previously calculated values efficiently.\\n\\n\\nSo, we want to store previous calculated reach in a previous variable and all those newly unveiled cell in a set so, that next time we are checking the reach of a bigger queries[i], we only check those cells that matter right.\\nUsing set prevents us from even duplicating our cells by mistake and is easy to delete, otherwise you can use map or priority_queue.\\n\\n```\\n#define ll long long\\n#define pi (3.141592653589)\\n#define mod 1000000007\\n#define float double\\n#define pb push_back\\n#define mp make_pair\\n#define ff first\\n#define ss second\\n#define all(c) c.begin(), c.end()\\n#define min3(a, b, c) min(c, min(a, b))\\n#define min4(a, b, c, d) min(d, min(c, min(a, b)))\\n#define rrep(i, n) for(int i=n-1;i>=0;i--)\\n#define rep(i,n) for(int i=0;i<n;i++)\\nclass Solution {\\npublic:\\n    vector<vector<bool>> vis;\\n    vector<vector<int>> d {{-1,0}, {1,0}, {0,-1}, {0,1}};\\n    set<pair<int,int>> s;\\n\\n    int dfs(int i, int j, vector<vector<int>>& grid, int query){\\n        int n=grid.size(), m=grid[0].size();\\n\\n        vis[i][j]=true;\\n\\n        ll cnt=1;\\n\\n        rep(k,4){\\n            int x= i+d[k][0];\\n            int y= j+d[k][1];\\n\\n            if(x>=0 && x<n && y>=0 && y<m){\\n                if(!vis[x][y] && grid[x][y] < query){\\n                   cnt+=  dfs(x,y, grid, query);\\n                }else if(!vis[x][y]){\\n                    s.insert({x,y});\\n                }\\n            }\\n        }\\n\\n        return cnt;\\n\\n    }\\n\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n\\n        ll mx= *(max_element(all(queries)));\\n        vector<ll> dp(mx+1, 0);\\n        int n=grid.size(), m=grid[0].size();\\n        vis.assign(n+1, vector<bool>(m+1, false));\\n\\n        ll prev=0;\\n        s.insert({0,0});\\n\\n        vector<int> p =queries;\\n        sort(all(p));\\n\\n        for(int i=0; i<p.size(); i++){\\n            dp[p[i]]=prev;\\n            for(auto it = s.begin(); it!=s.end(); it++){\\n                pair<int,int> now= *it;\\n                if(!vis[now.ff][now.ss] && grid[now.ff][now.ss]<p[i])\\n               dp[p[i]]+= dfs(now.ff, now.ss, grid, p[i]);\\n            }\\n\\n            for(auto it = s.begin(); it!=s.end(); it++){\\n                pair<int,int> now= *it;\\n                if(vis[now.ff][now.ss] )\\n                   s.erase(now);\\n            }\\n            prev=dp[p[i]];\\n        }\\n\\n        vector<int> ans;\\n        rep(i, queries.size()){\\n           ans.pb(dp[queries[i]]); \\n        }\\n\\n\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<bool>> vis;\\n    vector<vector<int>> d {{-1,0}",
                "codeTag": "Java"
            },
            {
                "id": 2899609,
                "title": "clean-code-dsu",
                "content": "# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass dsu {\\npublic:\\n    int n;\\n    vector<int> par;\\n    vector<int> siz;\\n    dsu(int n) {\\n        par.resize(n);\\n        siz.assign(n, 1);\\n        iota(par.begin(), par.end(), 0);\\n    }\\n    int root(int u) {\\n        return par[u] == u ? u : par[u] = root(par[u]);\\n    }\\n    bool merge(int u,int v) {\\n        u = root(u), v = root(v);\\n        if (u == v) return false;\\n        if (siz[u] < siz[v]) swap(u,v);\\n        par[v] = u;\\n        siz[u] += siz[v];\\n        return true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& a, vector<int>& queries) {\\n        vector <array<int, 2>> Q;\\n        for (int i = 0; i < queries.size(); ++i) {\\n            Q.push_back({queries[i], i});\\n        }\\n        sort(Q.begin(), Q.end());\\n        vector <int> res(queries.size());\\n        int n = a.size();\\n        int m = a[0].size();\\n        vector <array<int, 3>> vals;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                vals.push_back({a[i][j], i, j});\\n            }\\n        }\\n        sort(vals.begin(), vals.end());\\n        vector <vector<int>> done(n, vector<int>(m, 0));\\n\\n        dsu d(m * n);\\n\\n        auto okay = [&](int i, int j) {\\n            return i >= 0 and i < n and j >= 0 and j < m and done[i][j] == 1;\\n        };\\n\\n        auto get_idx = [&](int i, int j) {\\n            return i * m + j;\\n        };\\n\\n        auto merge = [&](int i, int j) {\\n            int idx = i * m + j;\\n            if (okay(i - 1, j)) {\\n                d.merge(idx, get_idx(i - 1, j));\\n            }\\n            if (okay(i + 1, j)) {\\n                d.merge(idx, get_idx(i + 1, j));\\n            }\\n            if (okay(i, j - 1)) {\\n                d.merge(idx, get_idx(i, j - 1));\\n            }\\n            if (okay(i, j + 1)) {\\n                d.merge(idx, get_idx(i, j + 1));\\n            }\\n        };\\n\\n        int j = 0;\\n        \\n        for (int i = 0; i < Q.size(); ++i) {\\n            vector <array<int, 2>> put;\\n            while (j < m * n and vals[j][0] < Q[i][0]) {\\n                done[vals[j][1]][vals[j][2]] = 1;\\n                //merge(i, j);\\n                put.push_back({vals[j][1], vals[j][2]});\\n                j++;\\n            }\\n            for (auto x : put) {\\n                merge(x[0], x[1]);\\n            }\\n            if (!done[0][0]) res[Q[i][1]] = 0;\\n            else res[Q[i][1]] = d.siz[d.root(0)];\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass dsu {\\npublic:\\n    int n;\\n    vector<int> par;\\n    vector<int> siz;\\n    dsu(int n) {\\n        par.resize(n);\\n        siz.assign(n, 1);\\n        iota(par.begin(), par.end(), 0);\\n    }\\n    int root(int u) {\\n        return par[u] == u ? u : par[u] = root(par[u]);\\n    }\\n    bool merge(int u,int v) {\\n        u = root(u), v = root(v);\\n        if (u == v) return false;\\n        if (siz[u] < siz[v]) swap(u,v);\\n        par[v] = u;\\n        siz[u] += siz[v];\\n        return true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& a, vector<int>& queries) {\\n        vector <array<int, 2>> Q;\\n        for (int i = 0; i < queries.size(); ++i) {\\n            Q.push_back({queries[i], i});\\n        }\\n        sort(Q.begin(), Q.end());\\n        vector <int> res(queries.size());\\n        int n = a.size();\\n        int m = a[0].size();\\n        vector <array<int, 3>> vals;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                vals.push_back({a[i][j], i, j});\\n            }\\n        }\\n        sort(vals.begin(), vals.end());\\n        vector <vector<int>> done(n, vector<int>(m, 0));\\n\\n        dsu d(m * n);\\n\\n        auto okay = [&](int i, int j) {\\n            return i >= 0 and i < n and j >= 0 and j < m and done[i][j] == 1;\\n        };\\n\\n        auto get_idx = [&](int i, int j) {\\n            return i * m + j;\\n        };\\n\\n        auto merge = [&](int i, int j) {\\n            int idx = i * m + j;\\n            if (okay(i - 1, j)) {\\n                d.merge(idx, get_idx(i - 1, j));\\n            }\\n            if (okay(i + 1, j)) {\\n                d.merge(idx, get_idx(i + 1, j));\\n            }\\n            if (okay(i, j - 1)) {\\n                d.merge(idx, get_idx(i, j - 1));\\n            }\\n            if (okay(i, j + 1)) {\\n                d.merge(idx, get_idx(i, j + 1));\\n            }\\n        };\\n\\n        int j = 0;\\n        \\n        for (int i = 0; i < Q.size(); ++i) {\\n            vector <array<int, 2>> put;\\n            while (j < m * n and vals[j][0] < Q[i][0]) {\\n                done[vals[j][1]][vals[j][2]] = 1;\\n                //merge(i, j);\\n                put.push_back({vals[j][1], vals[j][2]});\\n                j++;\\n            }\\n            for (auto x : put) {\\n                merge(x[0], x[1]);\\n            }\\n            if (!done[0][0]) res[Q[i][1]] = 0;\\n            else res[Q[i][1]] = d.siz[d.root(0)];\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899578,
                "title": "python3-djikstra-priority-queue",
                "content": "Run dijkstra through the matrix. Update the maximum number you\\'ve reached as you go along and keep your results in a dictionary. \\n-->Your dictionary should keep track of the maximum number of cells each number can reach\\nFor each query, find the maximum in your dictionary that you can reach. Could binary search this part if necessary.\\n\\n```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        mydict = defaultdict(int)\\n        dirs = ((0, 1), (0, -1), (1, 0), (-1, 0))\\n        height, width = len(grid) - 1, len(grid[0]) - 1\\n        \\n        # use a priority q to run djikstra\\n        q = [(grid[0][0], 0, 0)]\\n        visited = {(0, 0)}\\n        count, hi = 0, 0\\n        while q:\\n            value, row, col = heapq.heappop(q)\\n            # we get a point for every square\\n            count += 1\\n            # keep track of the max number we\\'ve gotten to\\n            hi = max(hi, value)\\n            # update the value of the maximum value in our dictionary to reflect how many squares it can take\\n            mydict[hi] = count\\n            for dir in dirs:\\n                new_row, new_col = row + dir[0], col + dir[1]\\n                if 0 <= new_row <= height and 0 <= new_col <= width and (new_row, new_col) not in visited:\\n                    visited.add((new_row, new_col))\\n                    heapq.heappush(q, (grid[new_row][new_col], new_row, new_col))\\n        \\n        answer = []\\n        # For each query check for the highest number we can reach from our dijkstra dictionary\\n        # Can probably binary search this part to make it faster, but wasn\\'t required to pass test cases \\n        for query in queries:\\n            hi = 0\\n            for key, value in mydict.items():\\n                if key < query:\\n                    hi = max(hi, value)\\n                else:\\n                    break\\n            answer.append(hi)\\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        mydict = defaultdict(int)\\n        dirs = ((0, 1), (0, -1), (1, 0), (-1, 0))\\n        height, width = len(grid) - 1, len(grid[0]) - 1\\n        \\n        # use a priority q to run djikstra\\n        q = [(grid[0][0], 0, 0)]\\n        visited = {(0, 0)}\\n        count, hi = 0, 0\\n        while q:\\n            value, row, col = heapq.heappop(q)\\n            # we get a point for every square\\n            count += 1\\n            # keep track of the max number we\\'ve gotten to\\n            hi = max(hi, value)\\n            # update the value of the maximum value in our dictionary to reflect how many squares it can take\\n            mydict[hi] = count\\n            for dir in dirs:\\n                new_row, new_col = row + dir[0], col + dir[1]\\n                if 0 <= new_row <= height and 0 <= new_col <= width and (new_row, new_col) not in visited:\\n                    visited.add((new_row, new_col))\\n                    heapq.heappush(q, (grid[new_row][new_col], new_row, new_col))\\n        \\n        answer = []\\n        # For each query check for the highest number we can reach from our dijkstra dictionary\\n        # Can probably binary search this part to make it faster, but wasn\\'t required to pass test cases \\n        for query in queries:\\n            hi = 0\\n            for key, value in mydict.items():\\n                if key < query:\\n                    hi = max(hi, value)\\n                else:\\n                    break\\n            answer.append(hi)\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899422,
                "title": "c-union-find-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>Parent;\\n    vector<int>Size;\\n\\n    int find(int x){\\n\\n        if(Parent[x]==x){\\n            return x;\\n        }\\n\\n        int temp=find(Parent[x]);\\n\\n        Parent[x]=temp;\\n\\n        return temp;\\n\\n    }\\n\\n\\n    void Union(int x,int y){\\n\\n        int lx=find(x);\\n        int ly=find(y);\\n\\n        if(lx!=ly){\\n\\n            if(Size[lx]>Size[ly]){\\n                Size[lx]+=Size[ly];\\n                Parent[ly]=lx;\\n            }\\n\\n            else{\\n                Size[ly]+=Size[lx];\\n                Parent[lx]=ly;\\n            }\\n\\n        }\\n\\n    }\\n    \\n   \\n    int r;\\n    \\n    int findCell(int i,int j){\\n        return ((i*r) + j);\\n    }\\n       \\n            \\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        r = max(m,n);\\n        \\n        Parent.resize(2000002);\\n        Size.resize(2000002);\\n        \\n        for(int i=0;i<2000002;i++){\\n            Parent[i] = i;\\n            Size[i] = 0;\\n        }\\n        \\n        vector<vector<pair<int,int>>>index(1000002);\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n               index[grid[i][j]].push_back({i,j});\\n            }\\n        }\\n    \\n\\n        vector<int>storage(1000002,0);\\n        \\n        int dx[4] = {0,0,1,-1};\\n        int dy[4] = {1,-1,0,0};\\n        \\n        for(int i=0;i<1000002;i++){\\n            for(int j=0;j<index[i].size();j++){\\n                int x = index[i][j].first;\\n                int y = index[i][j].second;\\n                int cellno = findCell(x,y);\\n                int p = find(cellno);\\n                Size[p]++;\\n                for(int dir=0;dir<4;dir++){\\n                    int nx = x + dx[dir];\\n                    int ny = y + dy[dir];\\n                    if(nx>=0 && ny>=0 && nx<m && ny<n && grid[nx][ny]<=i){\\n                            int nxt = findCell(nx,ny);\\n                            int par = find(nxt);\\n                            int nextcell = findCell(nx,ny);\\n                            Union(nextcell,cellno);\\n                    }\\n                }\\n            }\\n            int p = find(0);\\n            storage[i] = Size[p];\\n        }\\n        \\n        vector<int>ans;\\n        for(int i=0;i<queries.size();i++){\\n            int j = queries[i];\\n            ans.push_back(storage[j-1]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n/*\\n\\n1 2 3\\n2 5 7\\n3 5 1\\n\\n*/\\n  \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>Parent;\\n    vector<int>Size;\\n\\n    int find(int x){\\n\\n        if(Parent[x]==x){\\n            return x;\\n        }\\n\\n        int temp=find(Parent[x]);\\n\\n        Parent[x]=temp;\\n\\n        return temp;\\n\\n    }\\n\\n\\n    void Union(int x,int y){\\n\\n        int lx=find(x);\\n        int ly=find(y);\\n\\n        if(lx!=ly){\\n\\n            if(Size[lx]>Size[ly]){\\n                Size[lx]+=Size[ly];\\n                Parent[ly]=lx;\\n            }\\n\\n            else{\\n                Size[ly]+=Size[lx];\\n                Parent[lx]=ly;\\n            }\\n\\n        }\\n\\n    }\\n    \\n   \\n    int r;\\n    \\n    int findCell(int i,int j){\\n        return ((i*r) + j);\\n    }\\n       \\n            \\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        r = max(m,n);\\n        \\n        Parent.resize(2000002);\\n        Size.resize(2000002);\\n        \\n        for(int i=0;i<2000002;i++){\\n            Parent[i] = i;\\n            Size[i] = 0;\\n        }\\n        \\n        vector<vector<pair<int,int>>>index(1000002);\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n               index[grid[i][j]].push_back({i,j});\\n            }\\n        }\\n    \\n\\n        vector<int>storage(1000002,0);\\n        \\n        int dx[4] = {0,0,1,-1};\\n        int dy[4] = {1,-1,0,0};\\n        \\n        for(int i=0;i<1000002;i++){\\n            for(int j=0;j<index[i].size();j++){\\n                int x = index[i][j].first;\\n                int y = index[i][j].second;\\n                int cellno = findCell(x,y);\\n                int p = find(cellno);\\n                Size[p]++;\\n                for(int dir=0;dir<4;dir++){\\n                    int nx = x + dx[dir];\\n                    int ny = y + dy[dir];\\n                    if(nx>=0 && ny>=0 && nx<m && ny<n && grid[nx][ny]<=i){\\n                            int nxt = findCell(nx,ny);\\n                            int par = find(nxt);\\n                            int nextcell = findCell(nx,ny);\\n                            Union(nextcell,cellno);\\n                    }\\n                }\\n            }\\n            int p = find(0);\\n            storage[i] = Size[p];\\n        }\\n        \\n        vector<int>ans;\\n        for(int i=0;i<queries.size();i++){\\n            int j = queries[i];\\n            ans.push_back(storage[j-1]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n/*\\n\\n1 2 3\\n2 5 7\\n3 5 1\\n\\n*/\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899406,
                "title": "union-find-offline-queries",
                "content": "# Code\\n```\\n/*\\n * Created By: Rahul M <roboto7o32oo3@gmail.com>\\n *\\n * UnionFind provides near constant-time operations to add new sets, to merge existing sets and to check whether elements are in the same set.\\n * Mainly used for checking for connected components in graphs.\\n *\\n * Time Complexity: O(alpha(n)), where alpha(n) is the inverse Ackermann function. Since it is a very slowly growing function, the time complexity can be regareded as constant\\n *  \\n */\\n\\nclass UnionFind {\\n\\npublic:\\n\\n\\tvector<int> parent, rank, size;\\n    \\n    UnionFind(int n){\\n        parent = vector<int>(n);\\n        rank = vector<int>(n);\\n\\t\\tsize = vector<int>(n);\\n        \\n        for(int i=0; i<n; i++){\\n            parent[i] = i; // parent of each node will be itself initially\\n            rank[i] = 0; // rank will be 0 for all nodes initially\\n\\t\\t\\tsize[i] = 1; // size will be 1 for all nodes initially\\n        }\\n    }\\n    \\n    // finds the parent of given node u\\n    int find(int u) {\\n\\t\\t// if the node is the parent of itself, then it is the root of the set \\n        if(u == parent[u]){\\n            return u;\\n        }\\n\\t\\t// else, find the parent while also compressing the paths\\n        return u = find(parent[u]);\\n    }\\n    \\n    // merges two sets into one, u and v belong to the corresponding sets\\n\\t// performs union by rank\\n    void unionByRank(int u, int v) {\\n        // find the parents of u and v\\n        u = find(u);\\n        v = find(v);\\n        \\n        // if u and v does not belong to the same set\\n        if(u != v){\\n\\t\\t\\t// if tree has lower rank\\n            if(rank[u] < rank[v]){\\n                swap(u, v);\\n            }\\n            \\n            // attach lower rank tree to higher rank tree\\n            parent[v] = u;\\n            \\n\\t\\t\\t// if the ranks become equal, then increase the rank\\n            if(rank[u] == rank[v]){\\n                rank[u]++;\\n            }\\n        }\\n    }\\n\\n\\t// perform union by size\\n\\tvoid unionBySize(int u, int v) {\\n\\t\\t// find the parents of u and v\\n\\t\\tu = find(u);\\n\\t\\tv = find(v);\\n\\n\\t\\t// if u and v do not belong to the same set\\n\\t\\tif(u != v) {\\n\\t\\t\\t// if size of u is smaller\\n\\t\\t\\tif(size[u] < size[v]) {\\n\\t\\t\\t\\tswap(u, v);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// attach smaller size tree to larger size tree\\n\\t\\t\\tparent[v] = u;\\n\\n\\t\\t\\t// the tree u now contains all the elements of v as well\\n\\t\\t\\tsize[u] += size[v];\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int m=grid.size(), n=grid[0].size();\\n        \\n        // the queries are offline hence we can sort them\\n        vector<vector<int>> qs;\\n        \\n        for(int i=0; i<queries.size(); i++) {\\n            qs.push_back({queries[i], i});\\n        }\\n        \\n        // sort the queries\\n        sort(qs.begin(), qs.end());\\n        \\n        // find the position of each cell in given grid\\n        vector<vector<int>> cells;\\n        \\n        for(int i=0; i<grid.size(); i++) {\\n            for(int j=0; j<grid[0].size(); j++) {\\n                cells.push_back({grid[i][j], i, j});\\n            }\\n        }\\n        \\n        // sort the cells\\n        sort(cells.begin(), cells.end());\\n        \\n        vector<vector<bool>> yes(m, vector<bool>(n, false));\\n        \\n        vector<vector<int>> moves{{0,1},{0,-1},{1,0},{-1,0}};\\n        \\n        UnionFind UF(m*n);\\n        \\n        vector<int> result(queries.size(), 0);\\n        int i=0;\\n        \\n        for(vector<int>& q : qs) {\\n            while(i<cells.size() and cells[i][0]<q[0]) {                \\n                int a=cells[i][1], b=cells[i][2];\\n                yes[a][b] = true;\\n                \\n                for(vector<int>& move : moves) {\\n                    int na=a+move[0], nb=b+move[1];\\n                    \\n                    if(na>=0 and na<m and nb>=0 and nb<n and yes[na][nb]) {\\n                        UF.unionBySize(n*a+b, n*na+nb);\\n                    }\\n                }\\n                i++;\\n            }\\n            \\n            result[q[1]] = yes[0][0] ? UF.size[UF.find(0)] : 0;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Matrix"
                ],
                "code": "```\\n/*\\n * Created By: Rahul M <roboto7o32oo3@gmail.com>\\n *\\n * UnionFind provides near constant-time operations to add new sets, to merge existing sets and to check whether elements are in the same set.\\n * Mainly used for checking for connected components in graphs.\\n *\\n * Time Complexity: O(alpha(n)), where alpha(n) is the inverse Ackermann function. Since it is a very slowly growing function, the time complexity can be regareded as constant\\n *  \\n */\\n\\nclass UnionFind {\\n\\npublic:\\n\\n\\tvector<int> parent, rank, size;\\n    \\n    UnionFind(int n){\\n        parent = vector<int>(n);\\n        rank = vector<int>(n);\\n\\t\\tsize = vector<int>(n);\\n        \\n        for(int i=0; i<n; i++){\\n            parent[i] = i; // parent of each node will be itself initially\\n            rank[i] = 0; // rank will be 0 for all nodes initially\\n\\t\\t\\tsize[i] = 1; // size will be 1 for all nodes initially\\n        }\\n    }\\n    \\n    // finds the parent of given node u\\n    int find(int u) {\\n\\t\\t// if the node is the parent of itself, then it is the root of the set \\n        if(u == parent[u]){\\n            return u;\\n        }\\n\\t\\t// else, find the parent while also compressing the paths\\n        return u = find(parent[u]);\\n    }\\n    \\n    // merges two sets into one, u and v belong to the corresponding sets\\n\\t// performs union by rank\\n    void unionByRank(int u, int v) {\\n        // find the parents of u and v\\n        u = find(u);\\n        v = find(v);\\n        \\n        // if u and v does not belong to the same set\\n        if(u != v){\\n\\t\\t\\t// if tree has lower rank\\n            if(rank[u] < rank[v]){\\n                swap(u, v);\\n            }\\n            \\n            // attach lower rank tree to higher rank tree\\n            parent[v] = u;\\n            \\n\\t\\t\\t// if the ranks become equal, then increase the rank\\n            if(rank[u] == rank[v]){\\n                rank[u]++;\\n            }\\n        }\\n    }\\n\\n\\t// perform union by size\\n\\tvoid unionBySize(int u, int v) {\\n\\t\\t// find the parents of u and v\\n\\t\\tu = find(u);\\n\\t\\tv = find(v);\\n\\n\\t\\t// if u and v do not belong to the same set\\n\\t\\tif(u != v) {\\n\\t\\t\\t// if size of u is smaller\\n\\t\\t\\tif(size[u] < size[v]) {\\n\\t\\t\\t\\tswap(u, v);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// attach smaller size tree to larger size tree\\n\\t\\t\\tparent[v] = u;\\n\\n\\t\\t\\t// the tree u now contains all the elements of v as well\\n\\t\\t\\tsize[u] += size[v];\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int m=grid.size(), n=grid[0].size();\\n        \\n        // the queries are offline hence we can sort them\\n        vector<vector<int>> qs;\\n        \\n        for(int i=0; i<queries.size(); i++) {\\n            qs.push_back({queries[i], i});\\n        }\\n        \\n        // sort the queries\\n        sort(qs.begin(), qs.end());\\n        \\n        // find the position of each cell in given grid\\n        vector<vector<int>> cells;\\n        \\n        for(int i=0; i<grid.size(); i++) {\\n            for(int j=0; j<grid[0].size(); j++) {\\n                cells.push_back({grid[i][j], i, j});\\n            }\\n        }\\n        \\n        // sort the cells\\n        sort(cells.begin(), cells.end());\\n        \\n        vector<vector<bool>> yes(m, vector<bool>(n, false));\\n        \\n        vector<vector<int>> moves{{0,1},{0,-1},{1,0},{-1,0}};\\n        \\n        UnionFind UF(m*n);\\n        \\n        vector<int> result(queries.size(), 0);\\n        int i=0;\\n        \\n        for(vector<int>& q : qs) {\\n            while(i<cells.size() and cells[i][0]<q[0]) {                \\n                int a=cells[i][1], b=cells[i][2];\\n                yes[a][b] = true;\\n                \\n                for(vector<int>& move : moves) {\\n                    int na=a+move[0], nb=b+move[1];\\n                    \\n                    if(na>=0 and na<m and nb>=0 and nb<n and yes[na][nb]) {\\n                        UF.unionBySize(n*a+b, n*na+nb);\\n                    }\\n                }\\n                i++;\\n            }\\n            \\n            result[q[1]] = yes[0][0] ? UF.size[UF.find(0)] : 0;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983926,
                "title": "binary-search-priority-queue",
                "content": "\\n# \\uD83E\\uDDD0 Intuition\\n\\nImagine you\\'re exploring a mysterious grid of numbers \\uD83E\\uDDE9. For each query, your goal is to maximize your points \\u261D\\uFE0F while navigating through the grid.\\n\\nYour path can only go where the numbers are not too big \\uD83D\\uDE45\\u200D\\u2642\\uFE0F; otherwise, the adventure ends! The larger the query number, the more freedom you have \\uD83C\\uDF1F to explore.\\n\\n# \\uD83D\\uDE80 Approach\\n\\nWe\\'ll embark on this adventure step by step. Here\\'s our plan:\\n\\n1. Start at the top-left corner of the grid \\uD83C\\uDFDE\\uFE0F.\\n2. Use a priority queue to keep track of the next best places to go \\u2708\\uFE0F. We prioritize smaller numbers first.\\n3. As long as we find numbers less than or equal to our current bound, we\\'ll explore and mark our path \\uD83D\\uDDFA\\uFE0F.\\n4. We\\'ll count how many cells we\\'ve visited and record it, including the current bound.\\n5. We\\'ll also keep a record of how many cells we\\'ve visited for each bound, sorted in descending order, using a set and a map \\uD83D\\uDCCA.\\n6. For each query, we\\'ll find the bound that\\'s just greater than or equal to the query and retrieve the corresponding count from our records.\\n\\nThis way, we\\'ll know how many points we can gather for each query \\uD83C\\uDFAF.\\n\\n\\n# Complexity\\n## Time Complexity \\u23F0\\n\\n- The main loop that processes cells takes `O(n * m * log(n * m))` time due to the use of a priority queue.\\n- Processing queries takes `O(k * log(n * m))` time.\\n- Overall time complexity is `O((n * m + k) * log(n * m))`.\\n\\n## Space Complexity \\uD83E\\uDDEE\\n\\n- Additional space for the `vis` matrix: `O(n * m)`\\n- Space complexity for the priority queue: `O(n * m)`\\n- Space complexity for the set and map: `O(n * m)`\\n- Overall space complexity: `O(n * m)`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<int>dr={1,-1,0,0};\\n    vector<int>dc={0,0,1,-1};\\n    bool isvalid(int i,int j){\\n        return i>=0 and j>=0 and i<n and j<m;\\n    }\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>q;\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        set<pair<int,int>,greater<pair<int,int>>>s;\\n        map<int,int>mp;\\n        int cnt=0,bound=grid[0][0];\\n        q.push({grid[0][0],0,0});\\n        while(!q.empty()){\\n            vector<vector<int>>next;\\n            while(!q.empty() and q.top()[0]<=bound){\\n                vector<int>v=q.top();\\n                next.push_back(v);\\n                int i=v[1],j=v[2];\\n                vis[i][j]=1;\\n                q.pop();\\n                cnt++;\\n                for(int k=0;k<4;k++){\\n                    int ti=i+dr[k];\\n                    int tj=j+dc[k];\\n                    if(isvalid(ti,tj) and !vis[ti][tj] and grid[ti][tj]<=bound){\\n                        vis[ti][tj]=1;\\n                        q.push({grid[ti][tj],ti,tj});\\n                    }\\n                }\\n            }\\n            s.insert({bound,cnt});\\n            mp[bound]=cnt;\\n            for(auto v:next){\\n                int i=v[1],j=v[2];\\n                vis[i][j]=1;\\n                for(int k=0;k<4;k++){\\n                    int ti=i+dr[k];\\n                    int tj=j+dc[k];\\n                    if(isvalid(ti,tj) and !vis[ti][tj] and grid[ti][tj]>bound){\\n                        vis[ti][tj]=1;\\n                        q.push({grid[ti][tj],ti,tj});\\n                    }\\n                }\\n            }\\n            if(!q.empty())bound=q.top()[0];\\n        }\\n        vector<int>ans;\\n        for(int i:queries){\\n            if(s.lower_bound({i,0})!=s.end()){\\n                ans.push_back((s.lower_bound({i,0}))->second);\\n            }\\n            else ans.push_back(0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<int>dr={1,-1,0,0};\\n    vector<int>dc={0,0,1,-1};\\n    bool isvalid(int i,int j){\\n        return i>=0 and j>=0 and i<n and j<m;\\n    }\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>q;\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        set<pair<int,int>,greater<pair<int,int>>>s;\\n        map<int,int>mp;\\n        int cnt=0,bound=grid[0][0];\\n        q.push({grid[0][0],0,0});\\n        while(!q.empty()){\\n            vector<vector<int>>next;\\n            while(!q.empty() and q.top()[0]<=bound){\\n                vector<int>v=q.top();\\n                next.push_back(v);\\n                int i=v[1],j=v[2];\\n                vis[i][j]=1;\\n                q.pop();\\n                cnt++;\\n                for(int k=0;k<4;k++){\\n                    int ti=i+dr[k];\\n                    int tj=j+dc[k];\\n                    if(isvalid(ti,tj) and !vis[ti][tj] and grid[ti][tj]<=bound){\\n                        vis[ti][tj]=1;\\n                        q.push({grid[ti][tj],ti,tj});\\n                    }\\n                }\\n            }\\n            s.insert({bound,cnt});\\n            mp[bound]=cnt;\\n            for(auto v:next){\\n                int i=v[1],j=v[2];\\n                vis[i][j]=1;\\n                for(int k=0;k<4;k++){\\n                    int ti=i+dr[k];\\n                    int tj=j+dc[k];\\n                    if(isvalid(ti,tj) and !vis[ti][tj] and grid[ti][tj]>bound){\\n                        vis[ti][tj]=1;\\n                        q.push({grid[ti][tj],ti,tj});\\n                    }\\n                }\\n            }\\n            if(!q.empty())bound=q.top()[0];\\n        }\\n        vector<int>ans;\\n        for(int i:queries){\\n            if(s.lower_bound({i,0})!=s.end()){\\n                ans.push_back((s.lower_bound({i,0}))->second);\\n            }\\n            else ans.push_back(0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962252,
                "title": "python-binary-search-prioritise-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport heapq\\nfrom collections import defaultdict\\nfrom bisect import bisect_left\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        \\n        dirr=[(0,1),(1,0),(0,-1),(-1,0)]\\n\\n        row=len(grid)\\n        col=len(grid[0])\\n        visited=set()\\n        stc=[]\\n        stc.append((grid[0][0],0,0))\\n        heapq.heapify(stc)\\n        visited.add((0,0))\\n        result=defaultdict(int)\\n        count=0\\n        while stc:\\n            start=stc[0][0]\\n            result[start]=count\\n            while stc and stc[0][0]<=start:\\n                K=heapq.heappop(stc)\\n                val=K[0]\\n                r=K[1]\\n                c=K[2]\\n                for d in dirr:\\n                    if r+d[0] in range(row) and c+d[1] in range(col) and (r+d[0],c+d[1]) not in visited:\\n                        visited.add((r+d[0],c+d[1]))\\n                        heapq.heappush(stc,(grid[r+d[0]][c+d[1]],r+d[0],c+d[1]))\\n                count+=1\\n        ans=[]\\n        KEY=list(result.keys())\\n        KEY.sort()\\n        lk=len(KEY)\\n        for i in queries:\\n            K=bisect_left(KEY,i)\\n            if K<lk:\\n                ans.append(result[KEY[K]])\\n            else:\\n                ans.append(row*col)\\n        return ans\\n                \\n\\n\\n    \\n        \\n        \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nfrom collections import defaultdict\\nfrom bisect import bisect_left\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        \\n        dirr=[(0,1),(1,0),(0,-1),(-1,0)]\\n\\n        row=len(grid)\\n        col=len(grid[0])\\n        visited=set()\\n        stc=[]\\n        stc.append((grid[0][0],0,0))\\n        heapq.heapify(stc)\\n        visited.add((0,0))\\n        result=defaultdict(int)\\n        count=0\\n        while stc:\\n            start=stc[0][0]\\n            result[start]=count\\n            while stc and stc[0][0]<=start:\\n                K=heapq.heappop(stc)\\n                val=K[0]\\n                r=K[1]\\n                c=K[2]\\n                for d in dirr:\\n                    if r+d[0] in range(row) and c+d[1] in range(col) and (r+d[0],c+d[1]) not in visited:\\n                        visited.add((r+d[0],c+d[1]))\\n                        heapq.heappush(stc,(grid[r+d[0]][c+d[1]],r+d[0],c+d[1]))\\n                count+=1\\n        ans=[]\\n        KEY=list(result.keys())\\n        KEY.sort()\\n        lk=len(KEY)\\n        for i in queries:\\n            K=bisect_left(KEY,i)\\n            if K<lk:\\n                ans.append(result[KEY[K]])\\n            else:\\n                ans.append(row*col)\\n        return ans\\n                \\n\\n\\n    \\n        \\n        \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3934711,
                "title": "golang",
                "content": "\\n\\n# Code\\n```\\nfunc maxPoints(grid [][]int, queries []int) []int {\\n    m := len(grid)\\n    n := len(grid[0])\\n\\n    h :=  &minheap{\\n        grid: grid,\\n    }\\n    heap.Push(h, [2]int{0, 0})\\n\\n    visited := make([][]bool, m)\\n    for i := 0; i < m; i++ {\\n        visited[i] = make([]bool, n)\\n    }\\n\\n    visited[0][0] = true\\n\\n    q2 := make([]int, len(queries))\\n    for i := 0; i < len(q2); i++ {\\n        q2[i] = i\\n    }\\n    sort.Slice(q2, func(i int, j int) bool {\\n        return queries[q2[i]] < queries[q2[j]]\\n    })\\n\\n    cur := 0\\n    res := make([]int, len(queries))\\n    offset := [][]int{{0, -1}, {0, 1}, {1, 0}, {-1, 0}}\\n    for _, q := range q2 {\\n        for h.Len() > 0 && grid[h.Peek()[0]][h.Peek()[1]] < queries[q] {\\n            cur++\\n            cell := heap.Pop(h).([2]int)\\n            x, y := cell[0], cell[1]\\n            for _, dir := range offset {\\n                xx, yy := x + dir[0], y + dir[1]\\n                if xx >= 0 && yy >= 0 && xx < m && yy < n && !visited[xx][yy] {\\n                    visited[xx][yy] = true\\n                    heap.Push(h, [2]int{xx, yy})\\n                }\\n            }\\n        }\\n        res[q] = cur\\n    }\\n    return res\\n}\\n\\ntype minheap struct{\\n    list [][2]int\\n    grid [][]int\\n}\\n\\nfunc(h minheap) Len() int {\\n    return len(h.list)\\n}\\n\\nfunc(h minheap) Peek() [2]int {\\n    return h.list[0]\\n}\\n\\nfunc(h minheap) Swap(i int, j int) {\\n    h.list[i], h.list[j] = h.list[j], h.list[i]\\n}\\n\\nfunc(h minheap) Less(i int, j int) bool {\\n    return h.grid[h.list[i][0]][h.list[i][1]] < h.grid[h.list[j][0]][h.list[j][1]]\\n}\\n\\nfunc(h *minheap) Push(a interface{}) {\\n    (*h).list = append((*h).list, a.([2]int))\\n}\\n\\nfunc(h *minheap) Pop() interface{} {\\n    l := len((*h).list)\\n    res := (*h).list[l - 1]\\n    (*h).list = (*h).list[:l - 1]\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxPoints(grid [][]int, queries []int) []int {\\n    m := len(grid)\\n    n := len(grid[0])\\n\\n    h :=  &minheap{\\n        grid: grid,\\n    }\\n    heap.Push(h, [2]int{0, 0})\\n\\n    visited := make([][]bool, m)\\n    for i := 0; i < m; i++ {\\n        visited[i] = make([]bool, n)\\n    }\\n\\n    visited[0][0] = true\\n\\n    q2 := make([]int, len(queries))\\n    for i := 0; i < len(q2); i++ {\\n        q2[i] = i\\n    }\\n    sort.Slice(q2, func(i int, j int) bool {\\n        return queries[q2[i]] < queries[q2[j]]\\n    })\\n\\n    cur := 0\\n    res := make([]int, len(queries))\\n    offset := [][]int{{0, -1}, {0, 1}, {1, 0}, {-1, 0}}\\n    for _, q := range q2 {\\n        for h.Len() > 0 && grid[h.Peek()[0]][h.Peek()[1]] < queries[q] {\\n            cur++\\n            cell := heap.Pop(h).([2]int)\\n            x, y := cell[0], cell[1]\\n            for _, dir := range offset {\\n                xx, yy := x + dir[0], y + dir[1]\\n                if xx >= 0 && yy >= 0 && xx < m && yy < n && !visited[xx][yy] {\\n                    visited[xx][yy] = true\\n                    heap.Push(h, [2]int{xx, yy})\\n                }\\n            }\\n        }\\n        res[q] = cur\\n    }\\n    return res\\n}\\n\\ntype minheap struct{\\n    list [][2]int\\n    grid [][]int\\n}\\n\\nfunc(h minheap) Len() int {\\n    return len(h.list)\\n}\\n\\nfunc(h minheap) Peek() [2]int {\\n    return h.list[0]\\n}\\n\\nfunc(h minheap) Swap(i int, j int) {\\n    h.list[i], h.list[j] = h.list[j], h.list[i]\\n}\\n\\nfunc(h minheap) Less(i int, j int) bool {\\n    return h.grid[h.list[i][0]][h.list[i][1]] < h.grid[h.list[j][0]][h.list[j][1]]\\n}\\n\\nfunc(h *minheap) Push(a interface{}) {\\n    (*h).list = append((*h).list, a.([2]int))\\n}\\n\\nfunc(h *minheap) Pop() interface{} {\\n    l := len((*h).list)\\n    res := (*h).list[l - 1]\\n    (*h).list = (*h).list[:l - 1]\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3903821,
                "title": "java-o-mn-log-mn-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        final int m = grid.length;\\n        final int n = grid[0].length;\\n        int l=queries.length;\\n        int[][] arr=new int[l][2];\\n        for(int i=0;i<l;i++){\\n            arr[i][0]=queries[i];\\n            arr[i][1]=i;\\n        }\\n        Arrays.sort(arr,(a,b)->a[0]-b[0]);\\n        boolean[][] seen = new boolean[m][n];\\n        int[] ans=new int[l];\\n        int[] dirs = {0, 1, 0, -1, 0};\\n\\n    Queue<int[]> minHeap = new PriorityQueue<>((a, b) -> grid[a[0]][a[1]] - grid[b[0]][b[1]]);\\n        int count=0;\\n        minHeap.offer(new int[]{0,0});\\n        seen[0][0] = true;\\n        \\n        for(int[] a:arr){\\n            int query=a[0];\\n            int index=a[1];\\n            while(!minHeap.isEmpty()){\\n                int[] temp=minHeap.poll();\\n                int i=temp[0];\\n                int j=temp[1];\\n                if(grid[i][j]>=query){\\n                    minHeap.offer(new int[]{i,j});\\n                    break;\\n                }\\n                count++;\\n                for (int k = 0; k < 4; ++k) {\\n                 final int x = i + dirs[k];\\n                 final int y = j + dirs[k + 1];\\n                  if (x < 0 || x == m || y < 0 || y == n)\\n                    continue;\\n                  if (seen[x][y])\\n                   continue;\\n                  minHeap.offer(new int[]{x,y});\\n                    seen[x][y] = true;\\n               }\\n            }\\n            ans[index]=count;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        final int m = grid.length;\\n        final int n = grid[0].length;\\n        int l=queries.length;\\n        int[][] arr=new int[l][2];\\n        for(int i=0;i<l;i++){\\n            arr[i][0]=queries[i];\\n            arr[i][1]=i;\\n        }\\n        Arrays.sort(arr,(a,b)->a[0]-b[0]);\\n        boolean[][] seen = new boolean[m][n];\\n        int[] ans=new int[l];\\n        int[] dirs = {0, 1, 0, -1, 0};\\n\\n    Queue<int[]> minHeap = new PriorityQueue<>((a, b) -> grid[a[0]][a[1]] - grid[b[0]][b[1]]);\\n        int count=0;\\n        minHeap.offer(new int[]{0,0});\\n        seen[0][0] = true;\\n        \\n        for(int[] a:arr){\\n            int query=a[0];\\n            int index=a[1];\\n            while(!minHeap.isEmpty()){\\n                int[] temp=minHeap.poll();\\n                int i=temp[0];\\n                int j=temp[1];\\n                if(grid[i][j]>=query){\\n                    minHeap.offer(new int[]{i,j});\\n                    break;\\n                }\\n                count++;\\n                for (int k = 0; k < 4; ++k) {\\n                 final int x = i + dirs[k];\\n                 final int y = j + dirs[k + 1];\\n                  if (x < 0 || x == m || y < 0 || y == n)\\n                    continue;\\n                  if (seen[x][y])\\n                   continue;\\n                  minHeap.offer(new int[]{x,y});\\n                    seen[x][y] = true;\\n               }\\n            }\\n            ans[index]=count;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853863,
                "title": "c-online-query-solution",
                "content": "# Intuition\\nWe can solve the question without even sorting the queries. \\n\\n# Approach\\nI assume that we know how to calculate the answer using offline queries. Then the process to online queries is- Lets say that we have an query array which contains all the distinct elements of the matrix in sorted order. Then we will calculate the answers for these fake queries, after that we just have to know the first element which is just greater than or equal to current real query value. This will be the answer! \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& a, vector<int>& q) {\\n        int n = a.size();\\n        int m = a[0].size();\\n\\n        vector<int> qu;\\n        set<int> dif;\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                dif.insert(a[i][j]);\\n            }   \\n        }\\n\\n        for(auto it : dif)\\n        {\\n            qu.push_back(it);\\n        }\\n\\n        \\n        vector<vector<int>> vis(n , vector<int>(m , 0));\\n        set<array<int , 3>> s;\\n        s.insert({a[0][0] , 0 , 0});\\n\\n        vector<int> ans(qu.size());\\n        int cnt = 0;\\n        int dx[4] = {0 , 0 , 1 , -1};\\n        int dy[4] = {1 , -1 , 0 , 0};\\n        auto valid = [&](int i , int j)\\n        {\\n            if(((i >= 0 && i < n) && (j >= 0 && j < m)))\\n            {\\n                return 1;\\n            }\\n            return 0;\\n        };\\n        \\n        map<int , int> val;\\n        for(int i = 0; i < qu.size(); i++)\\n        {\\n            int x = qu[i];\\n            while(!s.empty())\\n            {\\n                array<int , 3> cur = *s.begin();\\n                if(cur[0] >= x)\\n                {\\n                    break;\\n                }\\n                s.erase(cur);\\n                vis[cur[1]][cur[2]] = 1;\\n                cnt++;\\n\\n                for(int j = 0; j < 4; j++)\\n                {\\n                    if(valid(cur[1] + dx[j] , cur[2] + dy[j]) && !vis[cur[1] + dx[j]][cur[2] + dy[j]])\\n                    {\\n                        s.insert({a[cur[1] + dx[j]][cur[2] + dy[j]] , cur[1] + dx[j] , cur[2] + dy[j]});\\n                    }\\n                }\\n\\n            }\\n            val[x] = cnt;\\n            ans[i] = x;\\n        }\\n\\n        vector<int> an(q.size());\\n        int j = 0;\\n        for(auto it : q)\\n        {\\n            if(it > ans[qu.size() - 1])\\n            {\\n                an[j] = n * m;\\n            }\\n            else\\n            {\\n                int ind = lower_bound(ans.begin() , ans.end() , it)  - ans.begin();\\n                an[j] = val[ans[ind]];\\n            }\\n            j++;\\n        }\\n        return an;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& a, vector<int>& q) {\\n        int n = a.size();\\n        int m = a[0].size();\\n\\n        vector<int> qu;\\n        set<int> dif;\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                dif.insert(a[i][j]);\\n            }   \\n        }\\n\\n        for(auto it : dif)\\n        {\\n            qu.push_back(it);\\n        }\\n\\n        \\n        vector<vector<int>> vis(n , vector<int>(m , 0));\\n        set<array<int , 3>> s;\\n        s.insert({a[0][0] , 0 , 0});\\n\\n        vector<int> ans(qu.size());\\n        int cnt = 0;\\n        int dx[4] = {0 , 0 , 1 , -1};\\n        int dy[4] = {1 , -1 , 0 , 0};\\n        auto valid = [&](int i , int j)\\n        {\\n            if(((i >= 0 && i < n) && (j >= 0 && j < m)))\\n            {\\n                return 1;\\n            }\\n            return 0;\\n        };\\n        \\n        map<int , int> val;\\n        for(int i = 0; i < qu.size(); i++)\\n        {\\n            int x = qu[i];\\n            while(!s.empty())\\n            {\\n                array<int , 3> cur = *s.begin();\\n                if(cur[0] >= x)\\n                {\\n                    break;\\n                }\\n                s.erase(cur);\\n                vis[cur[1]][cur[2]] = 1;\\n                cnt++;\\n\\n                for(int j = 0; j < 4; j++)\\n                {\\n                    if(valid(cur[1] + dx[j] , cur[2] + dy[j]) && !vis[cur[1] + dx[j]][cur[2] + dy[j]])\\n                    {\\n                        s.insert({a[cur[1] + dx[j]][cur[2] + dy[j]] , cur[1] + dx[j] , cur[2] + dy[j]});\\n                    }\\n                }\\n\\n            }\\n            val[x] = cnt;\\n            ans[i] = x;\\n        }\\n\\n        vector<int> an(q.size());\\n        int j = 0;\\n        for(auto it : q)\\n        {\\n            if(it > ans[qu.size() - 1])\\n            {\\n                an[j] = n * m;\\n            }\\n            else\\n            {\\n                int ind = lower_bound(ans.begin() , ans.end() , it)  - ans.begin();\\n                an[j] = val[ans[ind]];\\n            }\\n            j++;\\n        }\\n        return an;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788068,
                "title": "using-bfs-and-priorityqueue-detailed-explanation",
                "content": "# Intuition\\nAs the query values rise, more cells can be connected to covered blob of cells.\\nIf we address each query increasingly , then-->\\n1) we don\\'t have to start bfs from (0,0) for each query\\n2) we can just extend our coverage until we no adj. cell < query\\n# Approach\\n:) sum : counts cell coverage till current query after extension.\\n:) We use priorityQueue for bfs, as we want to be sure that we visit all adj. cell with value< query\\n:) we mark grid[r][c] as visited by putting its value as 0\\n# Complexity\\n- Time complexity:$$O(m*n*log(m*n))$$\\n- Space complexity:$$O(queries) + O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        int m =grid.length ,n = grid[0].length ; \\n        int[] dis = {-1,0,1,0,-1} ;\\n        PriorityQueue<Integer> pq_q = new PriorityQueue<>((a,b)->{\\n            return queries[a] - queries[b] ; \\n        }) ; \\n        PriorityQueue<int[]> pq_g = new PriorityQueue<>((a,b)->{  // [r,c, grid[r][c]]\\n            return a[2] - b[2] ; \\n        }) ;\\n\\n        for(int i=0 ;i< queries.length ; i++) pq_q.add(i) ; \\n\\n        pq_g.add(new int [] {0,0,grid[0][0]}) ; \\n        grid[0][0] = 0 ; \\n\\n        int sum = 0 ; \\n        int[] ans= new int[queries.length] ; \\n\\n        while(! pq_q.isEmpty()){\\n            int idx = pq_q.poll() ; \\n            int query = queries[idx] ; \\n            while(!pq_g.isEmpty() && pq_g.peek()[2]<query){\\n              \\n                int [] arr = pq_g.poll() ;\\n                int x = arr[0] , y = arr[1] ; \\n                sum ++ ; \\n\\n                // add non-visited neighbors\\n                for(int i =0 ; i<4 ; i++){\\n                    int x_ = x+dis[i] , y_ = y+dis[i+1] ; \\n                    if(dis[i]*dis[i+1]!=0 || x_<0 || y_<0 ||x_>=m || y_>=n || grid[x_][y_]==0){\\n                        continue ; \\n                    }\\n                    pq_g.add(new int[] {x_, y_, grid[x_][y_]}) ; \\n                    grid[x_][y_] = 0; \\n                } \\n                \\n            }\\n            ans[idx] = sum ; \\n\\n            \\n        }\\n\\n            \\n        return ans ; \\n\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        int m =grid.length ,n = grid[0].length ; \\n        int[] dis = {-1,0,1,0,-1} ;\\n        PriorityQueue<Integer> pq_q = new PriorityQueue<>((a,b)->{\\n            return queries[a] - queries[b] ; \\n        }) ; \\n        PriorityQueue<int[]> pq_g = new PriorityQueue<>((a,b)->{  // [r,c, grid[r][c]]\\n            return a[2] - b[2] ; \\n        }) ;\\n\\n        for(int i=0 ;i< queries.length ; i++) pq_q.add(i) ; \\n\\n        pq_g.add(new int [] {0,0,grid[0][0]}) ; \\n        grid[0][0] = 0 ; \\n\\n        int sum = 0 ; \\n        int[] ans= new int[queries.length] ; \\n\\n        while(! pq_q.isEmpty()){\\n            int idx = pq_q.poll() ; \\n            int query = queries[idx] ; \\n            while(!pq_g.isEmpty() && pq_g.peek()[2]<query){\\n              \\n                int [] arr = pq_g.poll() ;\\n                int x = arr[0] , y = arr[1] ; \\n                sum ++ ; \\n\\n                // add non-visited neighbors\\n                for(int i =0 ; i<4 ; i++){\\n                    int x_ = x+dis[i] , y_ = y+dis[i+1] ; \\n                    if(dis[i]*dis[i+1]!=0 || x_<0 || y_<0 ||x_>=m || y_>=n || grid[x_][y_]==0){\\n                        continue ; \\n                    }\\n                    pq_g.add(new int[] {x_, y_, grid[x_][y_]}) ; \\n                    grid[x_][y_] = 0; \\n                } \\n                \\n            }\\n            ans[idx] = sum ; \\n\\n            \\n        }\\n\\n            \\n        return ans ; \\n\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751352,
                "title": "c-min-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {0, 0, 1, -1};\\n    int dy[4] = {1, -1, 0, 0};\\n    vector<int> maxPoints(vector<vector<int>>& g, vector<int>& q) {\\n        vector<pair<int,int>> v;\\n        for (int i = 0; i < q.size(); ++i) v.push_back({q[i], i});\\n        sort(v.begin(), v.end());\\n        priority_queue<tuple<int,int,int>, vector<tuple<int,int,int>>, greater<tuple<int,int,int>>> bfs;\\n        int curSum = 0;\\n        vector<int> ans(q.size());\\n        bfs.push({g[0][0], 0, 0});\\n        g[0][0] = INT_MAX;\\n        for (int i = 0; i < v.size(); ++i){\\n            auto [f,s] = v[i];\\n            while (!bfs.empty() && get<0>(bfs.top()) < f){\\n                auto [val, x, y] = bfs.top();\\n                ++curSum;\\n                bfs.pop();\\n                for (int d = 0; d < 4; ++d){\\n                    int newX = x + dx[d], newY = y + dy[d];\\n                    if (newX < g.size() && newX > -1 && newY < g[0].size() &&\\n                        newY > -1 && g[newX][newY] != INT_MAX){\\n                        bfs.push({g[newX][newY], newX, newY});\\n                        g[newX][newY] = INT_MAX;\\n                    }\\n                }\\n            }\\n            ans[s] = curSum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {0, 0, 1, -1};\\n    int dy[4] = {1, -1, 0, 0};\\n    vector<int> maxPoints(vector<vector<int>>& g, vector<int>& q) {\\n        vector<pair<int,int>> v;\\n        for (int i = 0; i < q.size(); ++i) v.push_back({q[i], i});\\n        sort(v.begin(), v.end());\\n        priority_queue<tuple<int,int,int>, vector<tuple<int,int,int>>, greater<tuple<int,int,int>>> bfs;\\n        int curSum = 0;\\n        vector<int> ans(q.size());\\n        bfs.push({g[0][0], 0, 0});\\n        g[0][0] = INT_MAX;\\n        for (int i = 0; i < v.size(); ++i){\\n            auto [f,s] = v[i];\\n            while (!bfs.empty() && get<0>(bfs.top()) < f){\\n                auto [val, x, y] = bfs.top();\\n                ++curSum;\\n                bfs.pop();\\n                for (int d = 0; d < 4; ++d){\\n                    int newX = x + dx[d], newY = y + dy[d];\\n                    if (newX < g.size() && newX > -1 && newY < g[0].size() &&\\n                        newY > -1 && g[newX][newY] != INT_MAX){\\n                        bfs.push({g[newX][newY], newX, newY});\\n                        g[newX][newY] = INT_MAX;\\n                    }\\n                }\\n            }\\n            ans[s] = curSum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738665,
                "title": "simple-and-easy-approach-with-dijkstra-s-algorithm-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        vector<vector<bool>> vis(grid.size(),vector<bool>(grid[0].size(),false));\\n        vector<int> ans(queries.size(),0);\\n        map<int,vector<int>> mp;\\n        for(int i=0;i<queries.size();i++){\\n            mp[queries[i]].push_back(i);\\n        }\\n        sort(queries.begin(),queries.end());\\n        int dirI[4]={0,0,1,-1};\\n        int dirJ[4]={1,-1,0,0};\\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>> > pq;\\n        pq.push({grid[0][0],{0,0}}); vis[0][0]=true;\\n        int point=0;\\n        for(int xx = 0; xx < queries.size(); xx++){\\n            int target = queries[xx];\\n            int target_index = mp[target].back();\\n            mp[target].pop_back();\\n            while(!pq.empty() && pq.top().first < target){\\n                point++;\\n                auto temp = pq.top();\\n                pq.pop();\\n\\n                int i = temp.second.first;\\n                int j = temp.second.second;\\n                for(int index = 0; index < 4; index++){\\n                    int ni = i + dirI[index];\\n                    int nj = j + dirJ[index];\\n                    if(ni<0 || nj<0 || ni>=grid.size() || nj>=grid[0].size() || vis[ni][nj]==true)continue;\\n                    pq.push({grid[ni][nj],{ni,nj}});\\n                    vis[ni][nj]=true;\\n                }\\n            }\\n            ans[target_index]=point;\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        vector<vector<bool>> vis(grid.size(),vector<bool>(grid[0].size(),false));\\n        vector<int> ans(queries.size(),0);\\n        map<int,vector<int>> mp;\\n        for(int i=0;i<queries.size();i++){\\n            mp[queries[i]].push_back(i);\\n        }\\n        sort(queries.begin(),queries.end());\\n        int dirI[4]={0,0,1,-1};\\n        int dirJ[4]={1,-1,0,0};\\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>> > pq;\\n        pq.push({grid[0][0],{0,0}}); vis[0][0]=true;\\n        int point=0;\\n        for(int xx = 0; xx < queries.size(); xx++){\\n            int target = queries[xx];\\n            int target_index = mp[target].back();\\n            mp[target].pop_back();\\n            while(!pq.empty() && pq.top().first < target){\\n                point++;\\n                auto temp = pq.top();\\n                pq.pop();\\n\\n                int i = temp.second.first;\\n                int j = temp.second.second;\\n                for(int index = 0; index < 4; index++){\\n                    int ni = i + dirI[index];\\n                    int nj = j + dirJ[index];\\n                    if(ni<0 || nj<0 || ni>=grid.size() || nj>=grid[0].size() || vis[ni][nj]==true)continue;\\n                    pq.push({grid[ni][nj],{ni,nj}});\\n                    vis[ni][nj]=true;\\n                }\\n            }\\n            ans[target_index]=point;\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649800,
                "title": "optimised-bfs-solution-using-priority-queues",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we can re-use the Points obtained from the Smaller Queries, we can use a PQ to perform a BFS from top-left by pulling the smallest Query Point. \\n\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] directions = {{1,0},{0,1},{-1,0},{0,-1}};\\n\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a,b) -> a[0] - b[0]);\\n\\n        for(int idx = 0; idx < queries.length; idx++)\\n            pq.offer(new int[]{queries[idx], idx});\\n        \\n        int[] result = new int[queries.length];\\n        int runningSum = 0;\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean[][] visited = new boolean[rows][cols];\\n\\n        PriorityQueue<int[]> bfs = new PriorityQueue<int[]>((a,b) -> a[0] - b[0]);\\n        bfs.offer(new int[]{grid[0][0],0,0});\\n        visited[0][0] = true;\\n\\n        while(!pq.isEmpty())\\n        {\\n            int[] query = pq.poll();\\n            int point = query[0], idx = query[1];\\n\\n            while(!bfs.isEmpty())\\n            {\\n                int[] cell = bfs.peek();\\n                int currentValue = cell[0];\\n                int curX = cell[1], curY = cell[2];\\n\\n                if(currentValue >= point) break;\\n\\n                bfs.poll();\\n                runningSum++;\\n\\n                for(int k = 0; k < 4; k++)\\n                {\\n                    int nx = curX + directions[k][0];\\n                    int ny = curY + directions[k][1];\\n\\n                    if(nx < 0 || nx == rows) continue;\\n                    if(ny < 0 || ny == cols) continue;\\n                    if(visited[nx][ny]) continue;\\n\\n                    bfs.offer(new int[]{grid[nx][ny], nx, ny});\\n                    visited[nx][ny] = true;\\n                }\\n            }\\n\\n            result[idx] = runningSum;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    int[][] directions = {{1,0},{0,1},{-1,0},{0,-1}};\\n\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a,b) -> a[0] - b[0]);\\n\\n        for(int idx = 0; idx < queries.length; idx++)\\n            pq.offer(new int[]{queries[idx], idx});\\n        \\n        int[] result = new int[queries.length];\\n        int runningSum = 0;\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean[][] visited = new boolean[rows][cols];\\n\\n        PriorityQueue<int[]> bfs = new PriorityQueue<int[]>((a,b) -> a[0] - b[0]);\\n        bfs.offer(new int[]{grid[0][0],0,0});\\n        visited[0][0] = true;\\n\\n        while(!pq.isEmpty())\\n        {\\n            int[] query = pq.poll();\\n            int point = query[0], idx = query[1];\\n\\n            while(!bfs.isEmpty())\\n            {\\n                int[] cell = bfs.peek();\\n                int currentValue = cell[0];\\n                int curX = cell[1], curY = cell[2];\\n\\n                if(currentValue >= point) break;\\n\\n                bfs.poll();\\n                runningSum++;\\n\\n                for(int k = 0; k < 4; k++)\\n                {\\n                    int nx = curX + directions[k][0];\\n                    int ny = curY + directions[k][1];\\n\\n                    if(nx < 0 || nx == rows) continue;\\n                    if(ny < 0 || ny == cols) continue;\\n                    if(visited[nx][ny]) continue;\\n\\n                    bfs.offer(new int[]{grid[nx][ny], nx, ny});\\n                    visited[nx][ny] = true;\\n                }\\n            }\\n\\n            result[idx] = runningSum;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608874,
                "title": "c-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint bfs(vector<vector<int>> &vis,int k,priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>&q,int &np,vector<vector<int>>& grid)\\n{\\n    int n=grid.size(),m=grid[0].size();\\n    int dr[4]={-1,0,1,0},dc[4]={0,1,0,-1};\\n    while(!q.empty() ){\\n        auto i=q.top();\\n        q.pop();\\n        if(i.first>=k){\\n            q.push(i);\\n            break;\\n        }\\n        np++;\\n        int x=i.second.first,y=i.second.second;\\n        for(int i=0;i<4;i++){\\n            int nx=x+dr[i],ny=y+dc[i];\\n        if(nx>=0 and ny>=0 and nx<n and ny<m  and vis[nx][ny]==0){\\n                vis[nx][ny]=1;\\n                q.push({grid[nx][ny],{nx,ny}});\\n            }\\n        }\\n    }\\n    return np;\\n}\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n    int n=grid.size(),m=grid[0].size();\\n    vector<int> ans(queries.size());\\n    map<int,int>mp;\\n    vector<pair<int,int>> h;\\n    for(int i=0;i<queries.size();i++){\\n    h.push_back({queries[i],i});\\n    }\\n    sort(h.begin(),h.end());\\n    vector<vector<int>> vis(n,vector<int>(m,0));\\n    sort(queries.begin(),queries.end());\\npriority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>q;\\n\\nq.push({grid[0][0],{0,0}});\\n    vis[0][0]=1;\\n    int sum=0,k,np=0;\\n    for(auto it: h)\\n    {\\n        k=it.first;\\n        int indx=it.second;\\n        if(k<=grid[0][0]){\\n        ans[indx]=0;\\n        } else \\n        {\\n        ans[indx]=bfs(vis,k,q,np,grid);\\n        }\\n    }\\n    return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint bfs(vector<vector<int>> &vis,int k,priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>&q,int &np,vector<vector<int>>& grid)\\n{\\n    int n=grid.size(),m=grid[0].size();\\n    int dr[4]={-1,0,1,0},dc[4]={0,1,0,-1};\\n    while(!q.empty() ){\\n        auto i=q.top();\\n        q.pop();\\n        if(i.first>=k){\\n            q.push(i);\\n            break;\\n        }\\n        np++;\\n        int x=i.second.first,y=i.second.second;\\n        for(int i=0;i<4;i++){\\n            int nx=x+dr[i],ny=y+dc[i];\\n        if(nx>=0 and ny>=0 and nx<n and ny<m  and vis[nx][ny]==0){\\n                vis[nx][ny]=1;\\n                q.push({grid[nx][ny],{nx,ny}});\\n            }\\n        }\\n    }\\n    return np;\\n}\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n    int n=grid.size(),m=grid[0].size();\\n    vector<int> ans(queries.size());\\n    map<int,int>mp;\\n    vector<pair<int,int>> h;\\n    for(int i=0;i<queries.size();i++){\\n    h.push_back({queries[i],i});\\n    }\\n    sort(h.begin(),h.end());\\n    vector<vector<int>> vis(n,vector<int>(m,0));\\n    sort(queries.begin(),queries.end());\\npriority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>q;\\n\\nq.push({grid[0][0],{0,0}});\\n    vis[0][0]=1;\\n    int sum=0,k,np=0;\\n    for(auto it: h)\\n    {\\n        k=it.first;\\n        int indx=it.second;\\n        if(k<=grid[0][0]){\\n        ans[indx]=0;\\n        } else \\n        {\\n        ans[indx]=bfs(vis,k,q,np,grid);\\n        }\\n    }\\n    return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491248,
                "title": "c-just-one-bfs-with-multiple-stages",
                "content": "1. BFS propagating frontier until stopped at cell of `value >= query`\\n2. Resume BFS when given next larger `query value` \\n```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> indices(queries.size());\\n        iota(indices.begin(), indices.end(), 0);\\n        sort(indices.begin(), indices.end(), [&queries](int i, int j) { return queries[i] < queries[j]; });\\n        queue<pair<int,int>> next_frontier({{0,0}});\\n        unordered_map<int, unordered_set<int>> visited { {0, {0}} };\\n        int visits = 0;\\n        auto bfs = [&grid, &next_frontier, &visited, m, n, &visits] (int bound) {\\n            queue<pair<int,int>> frontier;\\n            frontier.swap(next_frontier);\\n            while(!frontier.empty())\\n                for(int sz = frontier.size(); sz; --sz) {\\n                    auto [r, c] = frontier.front();\\n                    frontier.pop();\\n                    if(grid[r][c] >= bound) \\n                        next_frontier.emplace(r,c);\\n                    else {\\n                        ++visits;\\n                        for(auto [incr, incc] : { pair(1,0), pair(-1,0), pair(0,1), pair(0,-1) }) {\\n                            if(int R = r + incr,  C = c + incc; R >= 0 && R < m && C >= 0 && C < n && visited[R].insert(C).second)\\n                                frontier.emplace(R,C);\\n                        }\\n                    }\\n                }\\n        };\\n        \\n        vector<int> ans(queries.size());\\n        int prevbound = 0;\\n        for(auto i : indices) {\\n            if(int bound = queries[i]; !next_frontier.empty() && bound > prevbound) {\\n                bfs(bound);\\n                prevbound = bound; \\n            }\\n            ans[i] = visits;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> indices(queries.size());\\n        iota(indices.begin(), indices.end(), 0);\\n        sort(indices.begin(), indices.end(), [&queries](int i, int j) { return queries[i] < queries[j]; });\\n        queue<pair<int,int>> next_frontier({{0,0}});\\n        unordered_map<int, unordered_set<int>> visited { {0, {0}} };\\n        int visits = 0;\\n        auto bfs = [&grid, &next_frontier, &visited, m, n, &visits] (int bound) {\\n            queue<pair<int,int>> frontier;\\n            frontier.swap(next_frontier);\\n            while(!frontier.empty())\\n                for(int sz = frontier.size(); sz; --sz) {\\n                    auto [r, c] = frontier.front();\\n                    frontier.pop();\\n                    if(grid[r][c] >= bound) \\n                        next_frontier.emplace(r,c);\\n                    else {\\n                        ++visits;\\n                        for(auto [incr, incc] : { pair(1,0), pair(-1,0), pair(0,1), pair(0,-1) }) {\\n                            if(int R = r + incr,  C = c + incc; R >= 0 && R < m && C >= 0 && C < n && visited[R].insert(C).second)\\n                                frontier.emplace(R,C);\\n                        }\\n                    }\\n                }\\n        };\\n        \\n        vector<int> ans(queries.size());\\n        int prevbound = 0;\\n        for(auto i : indices) {\\n            if(int bound = queries[i]; !next_frontier.empty() && bound > prevbound) {\\n                bfs(bound);\\n                prevbound = bound; \\n            }\\n            ans[i] = visits;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488712,
                "title": "c-easy-solution-bfs-priority-queue-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int r,int c,int n,int m){\\n        if(r>=0 && r<n && c>=0 && c<m){\\n            return true;\\n        }\\n        return false;\\n    }\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int n=grid.size(),m=grid[0].size();\\n        map<int,vector<int>> mp;\\n        for(int i=0;i<queries.size();i++){\\n            mp[queries[i]].push_back(i);\\n        }\\n        \\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        vector<int> ans(queries.size(),-1);\\n        sort(queries.begin(),queries.end());\\n       priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> q;\\n        q.push({grid[0][0],{0,0}});\\n        vis[0][0]=true;\\n        vector<int> dir{-1,0,1,0,-1};\\n        //up,right,down,left\\n        int count=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(!q.empty()){\\n                int dis=q.top().first;\\n                int r=q.top().second.first;\\n                int c=q.top().second.second;\\n                if(grid[r][c]>=queries[i]){\\n                    break;\\n                }\\n                q.pop();\\n                count++;\\n\\n               \\n                    for(int k=0;k<dir.size()-1;k++){\\n                        int curr_r=r+dir[k];\\n                        int curr_c=c+dir[k+1];\\n                        if(isValid(curr_r,curr_c,n,m) && !vis[curr_r][curr_c]){\\n                            vis[curr_r][curr_c]=true;\\n                            q.push({grid[curr_r][curr_c],{curr_r,curr_c}});\\n                        }\\n                    }\\n                \\n            }\\n            \\n            for(auto it:mp[queries[i]]){\\n                ans[it]=count;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# AUTHOR: JAYESH BADGUJAR\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int r,int c,int n,int m){\\n        if(r>=0 && r<n && c>=0 && c<m){\\n            return true;\\n        }\\n        return false;\\n    }\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int n=grid.size(),m=grid[0].size();\\n        map<int,vector<int>> mp;\\n        for(int i=0;i<queries.size();i++){\\n            mp[queries[i]].push_back(i);\\n        }\\n        \\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        vector<int> ans(queries.size(),-1);\\n        sort(queries.begin(),queries.end());\\n       priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> q;\\n        q.push({grid[0][0],{0,0}});\\n        vis[0][0]=true;\\n        vector<int> dir{-1,0,1,0,-1};\\n        //up,right,down,left\\n        int count=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(!q.empty()){\\n                int dis=q.top().first;\\n                int r=q.top().second.first;\\n                int c=q.top().second.second;\\n                if(grid[r][c]>=queries[i]){\\n                    break;\\n                }\\n                q.pop();\\n                count++;\\n\\n               \\n                    for(int k=0;k<dir.size()-1;k++){\\n                        int curr_r=r+dir[k];\\n                        int curr_c=c+dir[k+1];\\n                        if(isValid(curr_r,curr_c,n,m) && !vis[curr_r][curr_c]){\\n                            vis[curr_r][curr_c]=true;\\n                            q.push({grid[curr_r][curr_c],{curr_r,curr_c}});\\n                        }\\n                    }\\n                \\n            }\\n            \\n            for(auto it:mp[queries[i]]){\\n                ans[it]=count;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424829,
                "title": "python-sorting-binary-search-and-bfs-faster-than-99",
                "content": "First map the query number to its index in the query array. We\\'ll use this for constructing the anser later.\\nNext sort the UNIQUE queries into a keys list. Create another list of lists called next_up that is the same length as the unique queries.\\n\\nWe look at the first square in the grid, (0,0). We use binary search to find the smallest key that is greater than that square. Then we mark the first square as visited.\\n\\nNext we have a BFS nested inside a for loop that iterates on the keys list. For each key, we use its index to get the next_up to start of the deque for the BFS. This next_up was populated with the first square and is populated during the BFS when it finds a square that is greather than or equal to the current key. We do a BFS for each key and at the end use the index mappper we made at the start to set the answer array.\\n\\n### Python\\n```\\nDIRECTIONS = [(1,0), (0,1), (-1,0), (0,-1)]\\n\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        indexes = defaultdict(list)\\n        for i, v in enumerate(queries):\\n            indexes[v].append(i)\\n        ans = [0] * len(queries)\\n        keys = sorted(indexes.keys())\\n        next_up = [[] for _ in range(len(keys))]\\n        count = 0\\n        i = bisect_left(keys, grid[0][0]+1)\\n        if i < len(next_up): next_up[i].append((0,0))\\n        grid[0][0] = 0\\n        for i, k in enumerate(keys):\\n            dq = deque(next_up[i])\\n            while dq:\\n                count += 1\\n                row, col = dq.popleft()\\n                for r, c in DIRECTIONS:\\n                    new_row, new_col = row+r, col+c\\n                    if new_row >= 0 and new_row < len(grid) and new_col >= 0 and new_col < len(grid[0]) and grid[new_row][new_col] > 0:\\n                        if grid[new_row][new_col] < k: dq.append((new_row,new_col))\\n                        else:\\n                            next_i = bisect_left(keys, grid[new_row][new_col]+1)\\n                            if next_i < len(next_up): next_up[next_i].append((new_row,new_col))\\n                        grid[new_row][new_col] = 0\\n            for ans_i in indexes[k]:\\n                ans[ans_i] = count\\n        return ans\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nDIRECTIONS = [(1,0), (0,1), (-1,0), (0,-1)]\\n\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        indexes = defaultdict(list)\\n        for i, v in enumerate(queries):\\n            indexes[v].append(i)\\n        ans = [0] * len(queries)\\n        keys = sorted(indexes.keys())\\n        next_up = [[] for _ in range(len(keys))]\\n        count = 0\\n        i = bisect_left(keys, grid[0][0]+1)\\n        if i < len(next_up): next_up[i].append((0,0))\\n        grid[0][0] = 0\\n        for i, k in enumerate(keys):\\n            dq = deque(next_up[i])\\n            while dq:\\n                count += 1\\n                row, col = dq.popleft()\\n                for r, c in DIRECTIONS:\\n                    new_row, new_col = row+r, col+c\\n                    if new_row >= 0 and new_row < len(grid) and new_col >= 0 and new_col < len(grid[0]) and grid[new_row][new_col] > 0:\\n                        if grid[new_row][new_col] < k: dq.append((new_row,new_col))\\n                        else:\\n                            next_i = bisect_left(keys, grid[new_row][new_col]+1)\\n                            if next_i < len(next_up): next_up[next_i].append((new_row,new_col))\\n                        grid[new_row][new_col] = 0\\n            for ans_i in indexes[k]:\\n                ans[ans_i] = count\\n        return ans\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413305,
                "title": "dijkstra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nmlog(nm))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(10^6)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct P {\\n        int x, y, v;\\n        bool operator<(const P& an) const {\\n            return v > an.v;\\n        }\\n    };\\n    int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dist(n, vector<int>(m, -1));\\n        dist[0][0] = grid[0][0];\\n        priority_queue<P> pq;\\n        pq.push({0, 0, grid[0][0]});\\n        while (!pq.empty()) {\\n            P p = pq.top();\\n            pq.pop();\\n            int x = p.x, y = p.y;\\n            for (int i = 0; i < 4; i++) {\\n                int nx = x + dir[i][0], ny = y + dir[i][1];\\n                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {\\n                    if (dist[nx][ny] == -1 || max(p.v, grid[nx][ny]) < dist[nx][ny]) {\\n                        dist[nx][ny] = max(p.v, grid[nx][ny]);\\n                        pq.push({nx, ny, dist[nx][ny]});\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> v(1000004, 0);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (dist[i][j] != -1) {\\n                    v[dist[i][j]]++;\\n                }\\n            }\\n        }\\n        for (int i = 1; i < 1000004; i++) {\\n            v[i] += v[i-1];\\n        }\\n\\n        vector<int> r;\\n        for (int q : queries) {\\n            r.push_back(v[q-1]);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct P {\\n        int x, y, v;\\n        bool operator<(const P& an) const {\\n            return v > an.v;\\n        }\\n    };\\n    int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dist(n, vector<int>(m, -1));\\n        dist[0][0] = grid[0][0];\\n        priority_queue<P> pq;\\n        pq.push({0, 0, grid[0][0]});\\n        while (!pq.empty()) {\\n            P p = pq.top();\\n            pq.pop();\\n            int x = p.x, y = p.y;\\n            for (int i = 0; i < 4; i++) {\\n                int nx = x + dir[i][0], ny = y + dir[i][1];\\n                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {\\n                    if (dist[nx][ny] == -1 || max(p.v, grid[nx][ny]) < dist[nx][ny]) {\\n                        dist[nx][ny] = max(p.v, grid[nx][ny]);\\n                        pq.push({nx, ny, dist[nx][ny]});\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> v(1000004, 0);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (dist[i][j] != -1) {\\n                    v[dist[i][j]]++;\\n                }\\n            }\\n        }\\n        for (int i = 1; i < 1000004; i++) {\\n            v[i] += v[i-1];\\n        }\\n\\n        vector<int> r;\\n        for (int q : queries) {\\n            r.push_back(v[q-1]);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313707,
                "title": "c-priorityqueue-bfs",
                "content": "use the hints from problem\\n\\n```\\npublic class Solution {\\n    int[] dx =new int[4]{0,0,-1,1};\\n    int[] dy =new int[4]{1,-1,0,0};\\n        \\n    \\n    public int[] MaxPoints(int[][] grid, int[] queries) {\\n        int n2=queries.Length;\\n        int[] res=new int[n2];\\n        (int i,int v)[] queries2=Enumerable.Range(0,n2).Select(x=>(x,queries[x])).ToArray();\\n        Array.Sort(queries2,(x,y)=>x.v.CompareTo(y.v));\\n        \\n        int n=grid.Length;\\n        int m=grid[0].Length;\\n        \\n        bool[] v=new bool[n*m]; \\n        PriorityQueue<int,int> q=new PriorityQueue<int,int>();\\n        q.Enqueue(0,grid[0][0]);\\n        v[0]=true;\\n        int idx=0;\\n        int s=0;\\n            \\n        while(q.Count>0 && idx<n2)\\n        {\\n                int x=q.Dequeue();\\n                int r=x/m;int c=x%m;\\n                \\n                while(idx<n2 && grid[r][c]>=queries2[idx].v){\\n                    res[queries2[idx++].i]=s;    \\n                }\\n                \\n                if(idx>=n2)\\n                    continue;\\n                \\n                s++;\\n                for(int i=0;i<4;i++)\\n                {\\n                    int r2=r+dx[i];\\n                    int c2=c+dy[i];\\n                    int x2=r2*m+c2;\\n                    if(r2>=n ||r2<0 || c2>=m ||c2<0 || v[x2])\\n                        continue;\\n                    \\n                    v[x2]=true;\\n                    q.Enqueue(x2,grid[r2][c2]);\\n                }\\n        }\\n            \\n        while(idx<n2)\\n            res[queries2[idx++].i]=s;    \\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    int[] dx =new int[4]{0,0,-1,1};\\n    int[] dy =new int[4]{1,-1,0,0};\\n        \\n    \\n    public int[] MaxPoints(int[][] grid, int[] queries) {\\n        int n2=queries.Length;\\n        int[] res=new int[n2];\\n        (int i,int v)[] queries2=Enumerable.Range(0,n2).Select(x=>(x,queries[x])).ToArray();\\n        Array.Sort(queries2,(x,y)=>x.v.CompareTo(y.v));\\n        \\n        int n=grid.Length;\\n        int m=grid[0].Length;\\n        \\n        bool[] v=new bool[n*m]; \\n        PriorityQueue<int,int> q=new PriorityQueue<int,int>();\\n        q.Enqueue(0,grid[0][0]);\\n        v[0]=true;\\n        int idx=0;\\n        int s=0;\\n            \\n        while(q.Count>0 && idx<n2)\\n        {\\n                int x=q.Dequeue();\\n                int r=x/m;int c=x%m;\\n                \\n                while(idx<n2 && grid[r][c]>=queries2[idx].v){\\n                    res[queries2[idx++].i]=s;    \\n                }\\n                \\n                if(idx>=n2)\\n                    continue;\\n                \\n                s++;\\n                for(int i=0;i<4;i++)\\n                {\\n                    int r2=r+dx[i];\\n                    int c2=c+dy[i];\\n                    int x2=r2*m+c2;\\n                    if(r2>=n ||r2<0 || c2>=m ||c2<0 || v[x2])\\n                        continue;\\n                    \\n                    v[x2]=true;\\n                    q.Enqueue(x2,grid[r2][c2]);\\n                }\\n        }\\n            \\n        while(idx<n2)\\n            res[queries2[idx++].i]=s;    \\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252588,
                "title": "dsu-offlinequery",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- o((m*n)log(n*m))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- o(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int N,M;\\n    vector<int>parent,size;\\n    int maxi=1;\\n    int dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\\n    int actual(int i,int j){\\n        return (i*M+j);\\n    }\\n    int findP(int u){\\n        if(parent[u]==u)return u;\\n        return parent[u]=findP(parent[u]);\\n    }\\n    void uni(int u,int v){\\n        u=findP(u),v=findP(v);\\n        if(u==v)return;\\n        else{\\n            parent[v]=u;\\n            size[u]+=size[v];\\n            maxi=max(maxi,size[u]);\\n        }\\n        \\n    }\\n    void unihelper(int i,int j,vector<vector<int>>&active){\\n        int ac=actual(i,j);\\n        for(auto &a:dir){\\n            int xd=a[0]+i,yd=a[1]+j;\\n            if(xd>=0 && xd<N && yd>=0 && yd<M && active[xd][yd] && active[xd][yd]){\\n                int bc=actual(xd,yd);\\n                uni(ac,bc);\\n            }\\n        }\\n    }\\n    vector<int> maxPoints(vector<vector<int>>& g, vector<int>& q) {\\n        N=g.size();\\n        M=g[0].size();\\n        int qs=q.size();\\n        size.resize(M*N,1);\\n        for(int i=0;i<N*M;i++){\\n            parent.push_back(i);\\n        }\\n        vector<pair<int,int>>tq;\\n        for(int i=0;i<qs;i++){\\n            tq.push_back({q[i],i});\\n        }\\n        sort(tq.begin(),tq.end());\\n        vector<vector<int>>arr;\\n        for(int i=0;i<N;i++){\\n            for(int j=0;j<M;j++){\\n                arr.push_back({g[i][j],i,j});\\n            }\\n        }\\n        sort(arr.begin(),arr.end());\\n        vector<vector<int>>active(N,vector<int>(M,0));\\n        int i=0;\\n        int n=arr.size();\\n        vector<int>ans(qs);\\n        for(auto &a:tq){\\n            while(i<n && a.first>arr[i][0]){\\n                active[arr[i][1]][arr[i][2]]=1;\\n                unihelper(arr[i][1],arr[i][2],active);  \\n                i++;\\n            }\\n            int p=findP(0);\\n            if(a.first<=g[0][0])continue;\\n            ans[a.second]=size[p];\\n        }\\n        return ans;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int N,M;\\n    vector<int>parent,size;\\n    int maxi=1;\\n    int dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\\n    int actual(int i,int j){\\n        return (i*M+j);\\n    }\\n    int findP(int u){\\n        if(parent[u]==u)return u;\\n        return parent[u]=findP(parent[u]);\\n    }\\n    void uni(int u,int v){\\n        u=findP(u),v=findP(v);\\n        if(u==v)return;\\n        else{\\n            parent[v]=u;\\n            size[u]+=size[v];\\n            maxi=max(maxi,size[u]);\\n        }\\n        \\n    }\\n    void unihelper(int i,int j,vector<vector<int>>&active){\\n        int ac=actual(i,j);\\n        for(auto &a:dir){\\n            int xd=a[0]+i,yd=a[1]+j;\\n            if(xd>=0 && xd<N && yd>=0 && yd<M && active[xd][yd] && active[xd][yd]){\\n                int bc=actual(xd,yd);\\n                uni(ac,bc);\\n            }\\n        }\\n    }\\n    vector<int> maxPoints(vector<vector<int>>& g, vector<int>& q) {\\n        N=g.size();\\n        M=g[0].size();\\n        int qs=q.size();\\n        size.resize(M*N,1);\\n        for(int i=0;i<N*M;i++){\\n            parent.push_back(i);\\n        }\\n        vector<pair<int,int>>tq;\\n        for(int i=0;i<qs;i++){\\n            tq.push_back({q[i],i});\\n        }\\n        sort(tq.begin(),tq.end());\\n        vector<vector<int>>arr;\\n        for(int i=0;i<N;i++){\\n            for(int j=0;j<M;j++){\\n                arr.push_back({g[i][j],i,j});\\n            }\\n        }\\n        sort(arr.begin(),arr.end());\\n        vector<vector<int>>active(N,vector<int>(M,0));\\n        int i=0;\\n        int n=arr.size();\\n        vector<int>ans(qs);\\n        for(auto &a:tq){\\n            while(i<n && a.first>arr[i][0]){\\n                active[arr[i][1]][arr[i][2]]=1;\\n                unihelper(arr[i][1],arr[i][2],active);  \\n                i++;\\n            }\\n            int p=findP(0);\\n            if(a.first<=g[0][0])continue;\\n            ans[a.second]=size[p];\\n        }\\n        return ans;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138463,
                "title": "maximum-number-of-points",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        sorted_queries = [[queries[i], i] for i in range(len(queries))]\\n        sorted_queries.sort()\\n        print(sorted_queries)\\n        ans = [None] * len(queries)\\n        self.moves = 0\\n\\n        heap = []\\n        heapq.heappush(heap, (grid[0][0], 0, 0))\\n        visited = {(0, 0)}\\n\\n        def is_valid(i, j):\\n            return 0 <= i < m and 0 <= j < n\\n\\n        def get_neis(i, j):\\n            return [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n\\n        def bfs(heap, visited, val):\\n            while len(heap) and val > heap[0][0]:\\n                _, i, j = heapq.heappop(heap)\\n                self.moves+=1\\n                for nei in get_neis(i, j):\\n                    x, y = nei\\n                    if is_valid(x, y) and (x, y) not in visited:\\n                        visited.add((x, y))\\n                        heapq.heappush(heap, (grid[x][y], x, y))\\n            return heap, visited\\n\\n        for i, item in enumerate(sorted_queries):\\n            val, idx = item\\n            if i >= 1 and val == sorted_queries[i-1][0]:\\n                ans[idx] = self.moves\\n                continue\\n            heap, visited = bfs(heap, visited, val)\\n            ans[idx] = self.moves\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        sorted_queries = [[queries[i], i] for i in range(len(queries))]\\n        sorted_queries.sort()\\n        print(sorted_queries)\\n        ans = [None] * len(queries)\\n        self.moves = 0\\n\\n        heap = []\\n        heapq.heappush(heap, (grid[0][0], 0, 0))\\n        visited = {(0, 0)}\\n\\n        def is_valid(i, j):\\n            return 0 <= i < m and 0 <= j < n\\n\\n        def get_neis(i, j):\\n            return [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n\\n        def bfs(heap, visited, val):\\n            while len(heap) and val > heap[0][0]:\\n                _, i, j = heapq.heappop(heap)\\n                self.moves+=1\\n                for nei in get_neis(i, j):\\n                    x, y = nei\\n                    if is_valid(x, y) and (x, y) not in visited:\\n                        visited.add((x, y))\\n                        heapq.heappush(heap, (grid[x][y], x, y))\\n            return heap, visited\\n\\n        for i, item in enumerate(sorted_queries):\\n            val, idx = item\\n            if i >= 1 and val == sorted_queries[i-1][0]:\\n                ans[idx] = self.moves\\n                continue\\n            heap, visited = bfs(heap, visited, val)\\n            ans[idx] = self.moves\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085770,
                "title": "beats-57-heap-based-bfs",
                "content": "```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        sorted_queries = [[queries[i], i] for i in range(len(queries))]\\n        sorted_queries.sort()\\n        print(sorted_queries)\\n        ans = [None] * len(queries)\\n        self.moves = 0\\n\\n        heap = []\\n        heapq.heappush(heap, (grid[0][0], 0, 0))\\n        visited = {(0, 0)}\\n\\n        def is_valid(i, j):\\n            return 0 <= i < m and 0 <= j < n\\n\\n        def get_neis(i, j):\\n            return [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n\\n        def bfs(heap, visited, val):\\n            while len(heap) and val > heap[0][0]:\\n                _, i, j = heapq.heappop(heap)\\n                self.moves+=1\\n                for nei in get_neis(i, j):\\n                    x, y = nei\\n                    if is_valid(x, y) and (x, y) not in visited:\\n                        visited.add((x, y))\\n                        heapq.heappush(heap, (grid[x][y], x, y))\\n            return heap, visited\\n\\n        for i, item in enumerate(sorted_queries):\\n            val, idx = item\\n            if i >= 1 and val == sorted_queries[i-1][0]:\\n                ans[idx] = self.moves\\n                continue\\n            heap, visited = bfs(heap, visited, val)\\n            ans[idx] = self.moves\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        sorted_queries = [[queries[i], i] for i in range(len(queries))]\\n        sorted_queries.sort()\\n        print(sorted_queries)\\n        ans = [None] * len(queries)\\n        self.moves = 0\\n\\n        heap = []\\n        heapq.heappush(heap, (grid[0][0], 0, 0))\\n        visited = {(0, 0)}\\n\\n        def is_valid(i, j):\\n            return 0 <= i < m and 0 <= j < n\\n\\n        def get_neis(i, j):\\n            return [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n\\n        def bfs(heap, visited, val):\\n            while len(heap) and val > heap[0][0]:\\n                _, i, j = heapq.heappop(heap)\\n                self.moves+=1\\n                for nei in get_neis(i, j):\\n                    x, y = nei\\n                    if is_valid(x, y) and (x, y) not in visited:\\n                        visited.add((x, y))\\n                        heapq.heappush(heap, (grid[x][y], x, y))\\n            return heap, visited\\n\\n        for i, item in enumerate(sorted_queries):\\n            val, idx = item\\n            if i >= 1 and val == sorted_queries[i-1][0]:\\n                ans[idx] = self.moves\\n                continue\\n            heap, visited = bfs(heap, visited, val)\\n            ans[idx] = self.moves\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054829,
                "title": "simple-bfs-with-clear-explanation-bfs-heap-pq-c",
                "content": "# Intuition\\nThe very first approach coming to mind is to **run BFS/DFS on each query** and have the result with **TC = O(m.n.q) giving TLE** further.\\n\\nFor **optimization**, we can use an observation that:\\nif **node2 > node1**, then **node2 will consists all ans from node1**.\\ni.e. **ans(node2) = ans(node1) + additional nodes traversed**. \\nIt will consists of all nodes that helped in making score for node1.\\n\\nHence, instead of performing BFS/DFS over whole grid for each query again and again, we can just **continue BFS from where previous node left**.  \\n\\n# Approach\\n\\nqueue = []\\nfor q in qry:\\n    runBFS(queue)\\n\\nNow, problem comes When do we stop BFS?\\nThe answer is simple when our current node >= current query, we stop. But if we use simple queue here, all other nodes (that may be smaller than current node) will also not be counted in final answer, so as to **consider all smaller nodes**, we will use **Priority Queue** or **Min Heap**. And rest of the process remains as it is BFS.\\n\\n# Complexity\\n- Time complexity:\\nO(m.n + q)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m.n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int R, C;\\n    typedef priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> minHeap;\\n    int dr[4] = {0,0,-1,1};\\n    int dc[4] = {1,-1,0,0};\\n    \\n    bool valid(int r, int c){\\n        if(r < R and r >= 0 and c < C and c >= 0) return true;\\n        else return false;\\n    }\\n    \\n    int bfs(minHeap &q, vector<vector<int>>& grid, vector<vector<bool>> &seen, int max_ele){\\n        \\n        int ans = 0;\\n        while(!q.empty()){\\n            int cur_ele = q.top()[0];\\n            int row = q.top()[1];\\n            int col = q.top()[2];\\n            \\n            if(cur_ele >= max_ele) return ans;\\n            else {\\n                ans++;\\n                q.pop();        //if its included in ans, only then pop else leave for next query\\n            }\\n            \\n            //move to nbrs:\\n            for(int k=0;k<4;k++){\\n                int new_row = dr[k] + row; \\n                int new_col = dc[k] + col;\\n                \\n                if(valid(new_row, new_col) and !seen[new_row][new_col]){\\n                    q.push({grid[new_row][new_col], new_row, new_col});\\n                    seen[new_row][new_col] = true;\\n                }\\n            }            \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int Q = queries.size();\\n        R = grid.size(), C = grid[0].size();\\n        \\n        //sort:\\n        vector<pair<int,int>> qry_and_index;        // to return ans in input order\\n        for(int i=0;i<Q;i++){\\n            qry_and_index.push_back({queries[i], i});\\n        }\\n        \\n        sort(qry_and_index.begin(), qry_and_index.end());\\n        \\n        //BFS:\\n        minHeap q;\\n        q.push({grid[0][0], 0, 0});     //ele, row, col     \\n        vector<vector<bool>> seen(R+1, vector<bool> (C+1, false));\\n        seen[0][0] = true;\\n                \\n        vector<int> ans(Q, 0);\\n        int score_till_now = 0;         // to keep track of previous score for current as well\\n        for(auto [max_ele, idx]: qry_and_index){\\n            score_till_now += bfs(q, grid, seen, max_ele);\\n            ans[idx] = score_till_now;\\n        }       \\n                \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int R, C;\\n    typedef priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> minHeap;\\n    int dr[4] = {0,0,-1,1};\\n    int dc[4] = {1,-1,0,0};\\n    \\n    bool valid(int r, int c){\\n        if(r < R and r >= 0 and c < C and c >= 0) return true;\\n        else return false;\\n    }\\n    \\n    int bfs(minHeap &q, vector<vector<int>>& grid, vector<vector<bool>> &seen, int max_ele){\\n        \\n        int ans = 0;\\n        while(!q.empty()){\\n            int cur_ele = q.top()[0];\\n            int row = q.top()[1];\\n            int col = q.top()[2];\\n            \\n            if(cur_ele >= max_ele) return ans;\\n            else {\\n                ans++;\\n                q.pop();        //if its included in ans, only then pop else leave for next query\\n            }\\n            \\n            //move to nbrs:\\n            for(int k=0;k<4;k++){\\n                int new_row = dr[k] + row; \\n                int new_col = dc[k] + col;\\n                \\n                if(valid(new_row, new_col) and !seen[new_row][new_col]){\\n                    q.push({grid[new_row][new_col], new_row, new_col});\\n                    seen[new_row][new_col] = true;\\n                }\\n            }            \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int Q = queries.size();\\n        R = grid.size(), C = grid[0].size();\\n        \\n        //sort:\\n        vector<pair<int,int>> qry_and_index;        // to return ans in input order\\n        for(int i=0;i<Q;i++){\\n            qry_and_index.push_back({queries[i], i});\\n        }\\n        \\n        sort(qry_and_index.begin(), qry_and_index.end());\\n        \\n        //BFS:\\n        minHeap q;\\n        q.push({grid[0][0], 0, 0});     //ele, row, col     \\n        vector<vector<bool>> seen(R+1, vector<bool> (C+1, false));\\n        seen[0][0] = true;\\n                \\n        vector<int> ans(Q, 0);\\n        int score_till_now = 0;         // to keep track of previous score for current as well\\n        for(auto [max_ele, idx]: qry_and_index){\\n            score_till_now += bfs(q, grid, seen, max_ele);\\n            ans[idx] = score_till_now;\\n        }       \\n                \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017013,
                "title": "c-bfs-heap-with-binary-search",
                "content": "# Intuition\\nDefine $path\\\\_val$ as the max value point in a path. Find for each point(i, j), the path from point(0, 0) with smallest $path\\\\_val$. Use a priority_queue to implement process of finding $path\\\\_val$. Then put all $path\\\\_val$ into a array $vec$ and sort the array. answer[i] to queries[i] should be `lower_bound(vec.begin(), vec.end(), queries[i]) - vec.begin();`\\n\\n# Complexity\\n- Time complexity:\\n$$O(nm)*O(log(nm))$$\\n\\n- Space complexity:\\n$$O(nm)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dirs[4][2] = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n    \\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> ma = grid;\\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> que;\\n        vector<vector<bool>> vis(m, vector<bool>(n));\\n        que.push({grid[0][0], 0, 0});\\n        while (!que.empty()) {\\n            auto [v, i, j] = que.top();\\n            que.pop();\\n            if (vis[i][j]) {\\n                continue;\\n            }\\n            // cout << front[0] << \" \" << front[1] << endl;\\n            ma[i][j] = v;\\n            vis[i][j]= true;\\n            for (auto& dir : dirs) {\\n                int x = i + dir[0];\\n                int y = j + dir[1];\\n                if (x >= 0 && x < m && y >= 0 && y < n && !vis[x][y]) {\\n                    // cout << x << \" \" << y << endl;\\n                    que.push({max(grid[x][y], v), x, y});\\n                }\\n            }\\n        }\\n        vector<int> vec(m * n);\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                vec[i * n + j] = ma[i][j];\\n            }\\n        }\\n        sort(vec.begin(), vec.end());\\n        int size = queries.size();\\n        vector<int> answer(size);\\n        for (int i = 0; i < size; ++i) {\\n            answer[i] = lower_bound(vec.begin(), vec.end(), queries[i]) - vec.begin();\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dirs[4][2] = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n    \\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> ma = grid;\\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> que;\\n        vector<vector<bool>> vis(m, vector<bool>(n));\\n        que.push({grid[0][0], 0, 0});\\n        while (!que.empty()) {\\n            auto [v, i, j] = que.top();\\n            que.pop();\\n            if (vis[i][j]) {\\n                continue;\\n            }\\n            // cout << front[0] << \" \" << front[1] << endl;\\n            ma[i][j] = v;\\n            vis[i][j]= true;\\n            for (auto& dir : dirs) {\\n                int x = i + dir[0];\\n                int y = j + dir[1];\\n                if (x >= 0 && x < m && y >= 0 && y < n && !vis[x][y]) {\\n                    // cout << x << \" \" << y << endl;\\n                    que.push({max(grid[x][y], v), x, y});\\n                }\\n            }\\n        }\\n        vector<int> vec(m * n);\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                vec[i * n + j] = ma[i][j];\\n            }\\n        }\\n        sort(vec.begin(), vec.end());\\n        int size = queries.size();\\n        vector<int> answer(size);\\n        for (int i = 0; i < size; ++i) {\\n            answer[i] = lower_bound(vec.begin(), vec.end(), queries[i]) - vec.begin();\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3008538,
                "title": "python-3-maximum-number-of-points-from-grid-queries-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n    m = len(grid)\\n    n = len(grid[0])\\n    dirs = [0, 1, 0, -1, 0]\\n    ans = [0] * len(queries)\\n    queryAndIndexes = sorted([(query, i) for i, query in enumerate(queries)])\\n    minHeap = [(grid[0][0], 0, 0)]  # (grid[i][j], i, j)\\n    seen = {(0, 0)}\\n    accumulate = 0\\n\\n    for query, index in queryAndIndexes:\\n      while minHeap:\\n        val, i, j = heapq.heappop(minHeap)\\n        if val >= query:\\n          # The smallest neighbor is still larger than `query`, so no need to\\n          # keep exploring. Re-push (i, j, grid[i][j]) back to the `minHeap`.\\n          heapq.heappush(minHeap, (val, i, j))\\n          break\\n        accumulate += 1\\n        for k in range(4):\\n          x = i + dirs[k]\\n          y = j + dirs[k + 1]\\n          if x < 0 or x == m or y < 0 or y == n:\\n            continue\\n          if (x, y) in seen:\\n            continue\\n          heapq.heappush(minHeap, (grid[x][y], x, y))\\n          seen.add((x, y))\\n      ans[index] = accumulate\\n\\n    return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n    m = len(grid)\\n    n = len(grid[0])\\n    dirs = [0, 1, 0, -1, 0]\\n    ans = [0] * len(queries)\\n    queryAndIndexes = sorted([(query, i) for i, query in enumerate(queries)])\\n    minHeap = [(grid[0][0], 0, 0)]  # (grid[i][j], i, j)\\n    seen = {(0, 0)}\\n    accumulate = 0\\n\\n    for query, index in queryAndIndexes:\\n      while minHeap:\\n        val, i, j = heapq.heappop(minHeap)\\n        if val >= query:\\n          # The smallest neighbor is still larger than `query`, so no need to\\n          # keep exploring. Re-push (i, j, grid[i][j]) back to the `minHeap`.\\n          heapq.heappush(minHeap, (val, i, j))\\n          break\\n        accumulate += 1\\n        for k in range(4):\\n          x = i + dirs[k]\\n          y = j + dirs[k + 1]\\n          if x < 0 or x == m or y < 0 or y == n:\\n            continue\\n          if (x, y) in seen:\\n            continue\\n          heapq.heappush(minHeap, (grid[x][y], x, y))\\n          seen.add((x, y))\\n      ans[index] = accumulate\\n\\n    return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2987992,
                "title": "python-simple-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPoints(self, grid, queries):\\n        m, n = len(grid), len(grid[0])\\n\\n        visited = set()\\n\\n        visited.add((0,0))\\n\\n        stack, total = [(grid[0][0],0,0)], 0\\n\\n        nums, dict1 = sorted(queries), defaultdict(int)\\n\\n        for k in nums:\\n            while stack and stack[0][0] < k:\\n                total += 1\\n\\n                val, i, j = heapq.heappop(stack)\\n\\n                for ni,nj in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n                    if 0 <= ni < m and 0 <= nj < n and (ni,nj) not in visited:\\n                        heapq.heappush(stack,(grid[ni][nj],ni,nj))\\n                        visited.add((ni,nj))\\n\\n            dict1[k] = total\\n\\n        return [dict1[i] for i in queries]\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, grid, queries):\\n        m, n = len(grid), len(grid[0])\\n\\n        visited = set()\\n\\n        visited.add((0,0))\\n\\n        stack, total = [(grid[0][0],0,0)], 0\\n\\n        nums, dict1 = sorted(queries), defaultdict(int)\\n\\n        for k in nums:\\n            while stack and stack[0][0] < k:\\n                total += 1\\n\\n                val, i, j = heapq.heappop(stack)\\n\\n                for ni,nj in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n                    if 0 <= ni < m and 0 <= nj < n and (ni,nj) not in visited:\\n                        heapq.heappush(stack,(grid[ni][nj],ni,nj))\\n                        visited.add((ni,nj))\\n\\n            dict1[k] = total\\n\\n        return [dict1[i] for i in queries]\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2987900,
                "title": "python-simple-heap-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPoints(self, grid, queries):\\n        m, n = len(grid), len(grid[0])\\n\\n        result, max_val = [], -1\\n\\n        visited = set()\\n\\n        visited.add((0,0))\\n\\n        stack = [(grid[0][0],0,0)]\\n\\n        while stack:\\n            val, i, j = heapq.heappop(stack)\\n            max_val = max(max_val,val)\\n            result.append(max_val)\\n\\n            for ni,nj in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n                if 0 <= ni < m and 0 <= nj < n and (ni,nj) not in visited:\\n                    heapq.heappush(stack,(grid[ni][nj],ni,nj))\\n                    visited.add((ni,nj))\\n\\n        res = []\\n\\n        for i in queries:\\n            res += [bisect.bisect_left(result,i)]\\n\\n        return res\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, grid, queries):\\n        m, n = len(grid), len(grid[0])\\n\\n        result, max_val = [], -1\\n\\n        visited = set()\\n\\n        visited.add((0,0))\\n\\n        stack = [(grid[0][0],0,0)]\\n\\n        while stack:\\n            val, i, j = heapq.heappop(stack)\\n            max_val = max(max_val,val)\\n            result.append(max_val)\\n\\n            for ni,nj in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n                if 0 <= ni < m and 0 <= nj < n and (ni,nj) not in visited:\\n                    heapq.heappush(stack,(grid[ni][nj],ni,nj))\\n                    visited.add((ni,nj))\\n\\n        res = []\\n\\n        for i in queries:\\n            res += [bisect.bisect_left(result,i)]\\n\\n        return res\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981782,
                "title": "bfs-solution-clear-explanation",
                "content": "# Keypoint:\\n1. O(mnk) BFS solution is clear: For each query q, start with top left, BFS with all cells smaller than q.\\n2. **BFS-by-round**: This is the key optimization. **Sort query list**. Do BFS with smallest query q1. When it ends, start next round of BFS with second-smallest query q2. q2 contains all q1\\'s result, so we only do additional BFS without repeating q1\\'s work. \\n3. Time complexity is reduced to O(mn) since each cell is visited only once. \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPoints(self, g, queries):\\n        M, N = len(g), len(g[0])\\n        queryToCount = {}\\n        for q in queries:\\n            queryToCount[q] = 0\\n        \\n        visited = [[False] * N for _ in range(M)]\\n        visited[0][0] = True\\n        nextBfs = deque([(0, 0)])\\n\\n        pre = 0\\n        for query in sorted(queryToCount):\\n            if g[0][0] >= query:\\n                queryToCount[query] = 0\\n                continue\\n            # BFS\\n            points = nextBfs\\n            nextBfs = deque()\\n            count = 0\\n            while points:\\n                nextPoints = deque()\\n                for u in points:\\n                    if g[u[0]][u[1]] >= query:\\n                        nextBfs.append(u)\\n                        continue\\n                    count += 1\\n                    for d in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\\n                        nr, nc = u[0] + d[0], u[1] + d[1]\\n                        if nr >= 0 and nr < M and nc >= 0 and nc < N and not visited[nr][nc]:\\n                            visited[nr][nc] = True\\n                            if g[nr][nc] < query:\\n                                nextPoints.append((nr, nc))\\n                            else:\\n                                nextBfs.append((nr, nc))\\n                points = nextPoints\\n            queryToCount[query] = count + pre\\n            pre += count\\n\\n        res = [0] * len(queries)\\n        for i, q in enumerate(queries):\\n            res[i] = queryToCount[q]\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, g, queries):\\n        M, N = len(g), len(g[0])\\n        queryToCount = {}\\n        for q in queries:\\n            queryToCount[q] = 0\\n        \\n        visited = [[False] * N for _ in range(M)]\\n        visited[0][0] = True\\n        nextBfs = deque([(0, 0)])\\n\\n        pre = 0\\n        for query in sorted(queryToCount):\\n            if g[0][0] >= query:\\n                queryToCount[query] = 0\\n                continue\\n            # BFS\\n            points = nextBfs\\n            nextBfs = deque()\\n            count = 0\\n            while points:\\n                nextPoints = deque()\\n                for u in points:\\n                    if g[u[0]][u[1]] >= query:\\n                        nextBfs.append(u)\\n                        continue\\n                    count += 1\\n                    for d in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\\n                        nr, nc = u[0] + d[0], u[1] + d[1]\\n                        if nr >= 0 and nr < M and nc >= 0 and nc < N and not visited[nr][nc]:\\n                            visited[nr][nc] = True\\n                            if g[nr][nc] < query:\\n                                nextPoints.append((nr, nc))\\n                            else:\\n                                nextBfs.append((nr, nc))\\n                points = nextPoints\\n            queryToCount[query] = count + pre\\n            pre += count\\n\\n        res = [0] * len(queries)\\n        for i, q in enumerate(queries):\\n            res[i] = queryToCount[q]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976523,
                "title": "java-priority-queues-binary-search-faster-than-96",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    PriorityQueue<Pair> pq = new PriorityQueue<>();\\n    int numbersStrictlySmaller = 0;\\n    \\n    public class Pair implements Comparable<Pair> {\\n        int num;\\n        int row;\\n        int col;\\n        \\n        \\n        Pair(){};\\n        \\n        Pair(int num,int row,int col){\\n            this.num = num;\\n            this.row = row;\\n            this.col = col;\\n        }\\n        \\n        public int compareTo(Pair o){\\n            return this.num - o.num;\\n        }\\n\\n    }\\n\\n    class Query implements Comparable<Query>{\\n        int query;\\n        int qIdx;\\n\\n        Query(){};\\n        Query(int q,int idx){\\n            this.query = q;\\n            this.qIdx = idx;\\n        }\\n\\n        public int compareTo(Query o){\\n            return this.query - o.query;\\n        }\\n\\n\\n    }\\n    \\n\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n\\n        PriorityQueue<Query> qq = new PriorityQueue<>();\\n        int[] result = new int[queries.length];\\n\\n        Query[] queryArray = new Query[queries.length];\\n        \\n        for(int q=0;q<queries.length;q++)\\n            queryArray[q]  = new Query(queries[q],q);\\n\\n\\n        Arrays.sort(queryArray);\\n\\n        pq.add(new Pair(grid[0][0],0,0));\\n        \\n        grid[0][0] = - grid[0][0];\\n\\n\\n        \\n        int idx= 0;\\n\\n        while(idx<queryArray.length){\\n\\n            Query qp = queryArray[idx];\\n            int query = qp.query;\\n            int qIdx = qp.qIdx;\\n\\n            Pair pp = pq.peek();\\n\\n            calculatingStrictlySmallerNumbers(grid,query);\\n\\n            int i = idx;\\n            int j = queryArray.length-1;\\n\\n            while(pp!=null && i<=j){\\n                int mid = (i+j)/2;\\n\\n                if(queryArray[mid].query<=pp.num)\\n                    i = mid+1;\\n                else\\n                    j = mid-1;\\n\\n            }\\n\\n            \\n            for(int k=idx;k<=j;k++){\\n                qIdx = queryArray[k].qIdx;\\n                result[qIdx] = numbersStrictlySmaller;\\n                idx++;\\n            }\\n\\n            idx = j+1;\\n\\n    }\\n          \\n        return result;\\n  \\n        \\n    }\\n\\n\\n    public void calculatingStrictlySmallerNumbers(int[][] grid,int query){\\n\\n            int[][] dirs = {{-1,0},{1,0},{0,-1},{0,1}};\\n\\n            while (!pq.isEmpty() && query > pq.peek().num) {\\n                \\n                numbersStrictlySmaller++;\\n\\n                Pair rp = pq.poll();\\n                int row = rp.row;\\n                int col = rp.col;\\n\\n                for (int[] d : dirs) {\\n                    int nextRow = row + d[0];\\n                    int nextCol = col + d[1];\\n                    if (nextRow >= 0 && nextRow < grid.length && nextCol >= 0 && nextCol < grid[0].length && grid[nextRow][nextCol]>0) {                       \\n                        pq.add(new Pair(grid[nextRow][nextCol],nextRow,nextCol));\\n                        grid[nextRow][nextCol] = -grid[nextRow][nextCol];\\n                        \\n                    }\\n                }\\n\\n            }\\n\\n\\n    }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    PriorityQueue<Pair> pq = new PriorityQueue<>();\\n    int numbersStrictlySmaller = 0;\\n    \\n    public class Pair implements Comparable<Pair> {\\n        int num;\\n        int row;\\n        int col;\\n        \\n        \\n        Pair(){};\\n        \\n        Pair(int num,int row,int col){\\n            this.num = num;\\n            this.row = row;\\n            this.col = col;\\n        }\\n        \\n        public int compareTo(Pair o){\\n            return this.num - o.num;\\n        }\\n\\n    }\\n\\n    class Query implements Comparable<Query>{\\n        int query;\\n        int qIdx;\\n\\n        Query(){};\\n        Query(int q,int idx){\\n            this.query = q;\\n            this.qIdx = idx;\\n        }\\n\\n        public int compareTo(Query o){\\n            return this.query - o.query;\\n        }\\n\\n\\n    }\\n    \\n\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n\\n        PriorityQueue<Query> qq = new PriorityQueue<>();\\n        int[] result = new int[queries.length];\\n\\n        Query[] queryArray = new Query[queries.length];\\n        \\n        for(int q=0;q<queries.length;q++)\\n            queryArray[q]  = new Query(queries[q],q);\\n\\n\\n        Arrays.sort(queryArray);\\n\\n        pq.add(new Pair(grid[0][0],0,0));\\n        \\n        grid[0][0] = - grid[0][0];\\n\\n\\n        \\n        int idx= 0;\\n\\n        while(idx<queryArray.length){\\n\\n            Query qp = queryArray[idx];\\n            int query = qp.query;\\n            int qIdx = qp.qIdx;\\n\\n            Pair pp = pq.peek();\\n\\n            calculatingStrictlySmallerNumbers(grid,query);\\n\\n            int i = idx;\\n            int j = queryArray.length-1;\\n\\n            while(pp!=null && i<=j){\\n                int mid = (i+j)/2;\\n\\n                if(queryArray[mid].query<=pp.num)\\n                    i = mid+1;\\n                else\\n                    j = mid-1;\\n\\n            }\\n\\n            \\n            for(int k=idx;k<=j;k++){\\n                qIdx = queryArray[k].qIdx;\\n                result[qIdx] = numbersStrictlySmaller;\\n                idx++;\\n            }\\n\\n            idx = j+1;\\n\\n    }\\n          \\n        return result;\\n  \\n        \\n    }\\n\\n\\n    public void calculatingStrictlySmallerNumbers(int[][] grid,int query){\\n\\n            int[][] dirs = {{-1,0},{1,0},{0,-1},{0,1}};\\n\\n            while (!pq.isEmpty() && query > pq.peek().num) {\\n                \\n                numbersStrictlySmaller++;\\n\\n                Pair rp = pq.poll();\\n                int row = rp.row;\\n                int col = rp.col;\\n\\n                for (int[] d : dirs) {\\n                    int nextRow = row + d[0];\\n                    int nextCol = col + d[1];\\n                    if (nextRow >= 0 && nextRow < grid.length && nextCol >= 0 && nextCol < grid[0].length && grid[nextRow][nextCol]>0) {                       \\n                        pq.add(new Pair(grid[nextRow][nextCol],nextRow,nextCol));\\n                        grid[nextRow][nextCol] = -grid[nextRow][nextCol];\\n                        \\n                    }\\n                }\\n\\n            }\\n\\n\\n    }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976402,
                "title": "java-simple-code-easy-to-understand-priority-queue-graph",
                "content": "# Intricate Details:\\nWhy we need Priority Queue for Storing Queries?\\n--- Because after storing we need the original idxs.\\nSo we will add a Pair of (query,queryIdx).\\n\\nokay But\\n\\nwhy can\\'t we use HashMap for storing original Idxs ??\\n--- Because it can\\'t handle duplicates.\\n\\n**Duplicates Which duplicates**\\nIn question it is not mentioned that all queries are unique there could a chanche of duplication.\\n\\nSo if q= 888 present 3 times it will calculate answer for all three\\nbut in hashMap the there is only 1 idx present(the last one) so it will store value for only that qIdx. \\n\\n**Test Case 16 has duplicacy**\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n    PriorityQueue<Pair> pq = new PriorityQueue<>();\\n    int numbersStrictlySmaller = 0;\\n    \\n    public class Pair implements Comparable<Pair> {\\n        int num;\\n        int row;\\n        int col;\\n        \\n        \\n        Pair(){};\\n        \\n        Pair(int num,int row,int col){\\n            this.num = num;\\n            this.row = row;\\n            this.col = col;\\n        }\\n        \\n        public int compareTo(Pair o){\\n            return this.num - o.num;\\n        }\\n\\n    }\\n\\n    class Query implements Comparable<Query>{\\n        int query;\\n        int qIdx;\\n\\n        Query(){};\\n        Query(int q,int idx){\\n            this.query = q;\\n            this.qIdx = idx;\\n        }\\n\\n        public int compareTo(Query o){\\n            return this.query - o.query;\\n        }\\n\\n\\n    }\\n    \\n\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n\\n        PriorityQueue<Query> qq = new PriorityQueue<>();\\n        int[] result = new int[queries.length];\\n\\n        \\n        for(int q=0;q<queries.length;q++)\\n            qq.add(new Query(queries[q],q));\\n\\n        pq.add(new Pair(grid[0][0],0,0));\\n        \\n        grid[0][0] = - grid[0][0];\\n        \\n\\n        while (!qq.isEmpty()) {\\n\\n            Query qp = qq.poll();\\n            int query = qp.query;\\n            int qIdx = qp.qIdx;\\n            \\n            calculatingStrictlySmallerNumbers(grid,query);\\n\\n            result[qIdx] = numbersStrictlySmaller;\\n        }\\n          \\n        return result;\\n  \\n        \\n    }\\n\\n\\n    public void calculatingStrictlySmallerNumbers(int[][] grid,int query){\\n\\n            int[][] dirs = {{-1,0},{1,0},{0,-1},{0,1}};\\n\\n            while (!pq.isEmpty() && query > pq.peek().num) {\\n                \\n                numbersStrictlySmaller++;\\n\\n                Pair rp = pq.poll();\\n                int row = rp.row;\\n                int col = rp.col;\\n\\n                for (int[] d : dirs) {\\n                    int nextRow = row + d[0];\\n                    int nextCol = col + d[1];\\n                    if (nextRow >= 0 && nextRow < grid.length && nextCol >= 0 && nextCol < grid[0].length && grid[nextRow][nextCol]>0) {                       \\n                        pq.add(new Pair(grid[nextRow][nextCol],nextRow,nextCol));\\n                        grid[nextRow][nextCol] = -grid[nextRow][nextCol];\\n                        \\n                    }\\n                }\\n\\n            }\\n\\n\\n    }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    PriorityQueue<Pair> pq = new PriorityQueue<>();\\n    int numbersStrictlySmaller = 0;\\n    \\n    public class Pair implements Comparable<Pair> {\\n        int num;\\n        int row;\\n        int col;\\n        \\n        \\n        Pair(){};\\n        \\n        Pair(int num,int row,int col){\\n            this.num = num;\\n            this.row = row;\\n            this.col = col;\\n        }\\n        \\n        public int compareTo(Pair o){\\n            return this.num - o.num;\\n        }\\n\\n    }\\n\\n    class Query implements Comparable<Query>{\\n        int query;\\n        int qIdx;\\n\\n        Query(){};\\n        Query(int q,int idx){\\n            this.query = q;\\n            this.qIdx = idx;\\n        }\\n\\n        public int compareTo(Query o){\\n            return this.query - o.query;\\n        }\\n\\n\\n    }\\n    \\n\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n\\n        PriorityQueue<Query> qq = new PriorityQueue<>();\\n        int[] result = new int[queries.length];\\n\\n        \\n        for(int q=0;q<queries.length;q++)\\n            qq.add(new Query(queries[q],q));\\n\\n        pq.add(new Pair(grid[0][0],0,0));\\n        \\n        grid[0][0] = - grid[0][0];\\n        \\n\\n        while (!qq.isEmpty()) {\\n\\n            Query qp = qq.poll();\\n            int query = qp.query;\\n            int qIdx = qp.qIdx;\\n            \\n            calculatingStrictlySmallerNumbers(grid,query);\\n\\n            result[qIdx] = numbersStrictlySmaller;\\n        }\\n          \\n        return result;\\n  \\n        \\n    }\\n\\n\\n    public void calculatingStrictlySmallerNumbers(int[][] grid,int query){\\n\\n            int[][] dirs = {{-1,0},{1,0},{0,-1},{0,1}};\\n\\n            while (!pq.isEmpty() && query > pq.peek().num) {\\n                \\n                numbersStrictlySmaller++;\\n\\n                Pair rp = pq.poll();\\n                int row = rp.row;\\n                int col = rp.col;\\n\\n                for (int[] d : dirs) {\\n                    int nextRow = row + d[0];\\n                    int nextCol = col + d[1];\\n                    if (nextRow >= 0 && nextRow < grid.length && nextCol >= 0 && nextCol < grid[0].length && grid[nextRow][nextCol]>0) {                       \\n                        pq.add(new Pair(grid[nextRow][nextCol],nextRow,nextCol));\\n                        grid[nextRow][nextCol] = -grid[nextRow][nextCol];\\n                        \\n                    }\\n                }\\n\\n            }\\n\\n\\n    }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971681,
                "title": "c-easy-to-understand-bfs-using-priority-queue-min-heap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& qu) {\\n        // vector<int> preMaxh,preMaxv;\\n        // preMaxh=preMaxv=grid;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        vector<pair<int,int>> q;\\n        for(int i=0;i<qu.size();i++)\\n        {\\n            q.push_back({qu[i],i});\\n        }\\n        sort(q.begin(),q.end());\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>> > qq;\\n        \\n        int ans=0;\\n        qq.push({grid[0][0],0,0});\\n        vis[0][0]=true;\\n        vector<int> dx={0,0,1,-1};\\n        vector<int> dy={1,-1,0,0};\\n        vector<int> res(qu.size(),0);\\n        for(int k=0;k<q.size();k++)\\n        {\\n            // int val=q[k];\\n            while(!qq.empty()&&qq.top()[0]<q[k].first)\\n            {\\n               int x=qq.top()[1];\\n               int y=qq.top()[2];\\n               int val=qq.top()[0];\\n               ans++;\\n               qq.pop();\\n                for(int i=0;i<4;i++)\\n                {\\n                    if(x+dx[i]>=0&&x+dx[i]<n&&y+dy[i]>=0&&y+dy[i]<m&&!vis[x+dx[i]][y+dy[i]])\\n                    {\\n                        qq.push({grid[x+dx[i]][y+dy[i]],x+dx[i],y+dy[i]});\\n                        vis[x+dx[i]][y+dy[i]]=true;\\n                    }\\n                }\\n            }\\n            res[q[k].second]=ans;\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& qu) {\\n        // vector<int> preMaxh,preMaxv;\\n        // preMaxh=preMaxv=grid;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        vector<pair<int,int>> q;\\n        for(int i=0;i<qu.size();i++)\\n        {\\n            q.push_back({qu[i],i});\\n        }\\n        sort(q.begin(),q.end());\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>> > qq;\\n        \\n        int ans=0;\\n        qq.push({grid[0][0],0,0});\\n        vis[0][0]=true;\\n        vector<int> dx={0,0,1,-1};\\n        vector<int> dy={1,-1,0,0};\\n        vector<int> res(qu.size(),0);\\n        for(int k=0;k<q.size();k++)\\n        {\\n            // int val=q[k];\\n            while(!qq.empty()&&qq.top()[0]<q[k].first)\\n            {\\n               int x=qq.top()[1];\\n               int y=qq.top()[2];\\n               int val=qq.top()[0];\\n               ans++;\\n               qq.pop();\\n                for(int i=0;i<4;i++)\\n                {\\n                    if(x+dx[i]>=0&&x+dx[i]<n&&y+dy[i]>=0&&y+dy[i]<m&&!vis[x+dx[i]][y+dy[i]])\\n                    {\\n                        qq.push({grid[x+dx[i]][y+dy[i]],x+dx[i],y+dy[i]});\\n                        vis[x+dx[i]][y+dy[i]]=true;\\n                    }\\n                }\\n            }\\n            res[q[k].second]=ans;\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966627,
                "title": "easy-java-solution-intuition-explained-beats-96-using-bfs-with-priorityqueue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n * use BFS and sort queries because, if num2 > num1 then score(num2) > score(num1) , \\n * so idea is to starting calculating score for num2 where num1 has left\\n * (for this queue will store the points after which num1 was not satisfying the conditions)\\n * and cumulatively add score smaller(ie num1) number to larger number(i.e num2) \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(n*m log(n*m)) \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n# Code\\n```\\n\\nclass Solution {\\n    int dirs[][] = new int[][] { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } };\\n\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        int n = grid.length, m = grid[0].length;\\n        int[] cpy_query = Arrays.copyOf(queries, queries.length);\\n\\n        Arrays.sort(queries);\\n\\n        int ans[] = new int[queries.length];\\n        Map<Integer, Integer> map = new HashMap<>();\\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> grid[a.x][a.y] - grid[b.x][b.y]);\\n        boolean[][] seen = new boolean[n][m];\\n\\n        pq.add(new Pair(0, 0));\\n        seen[0][0] = true;\\n\\n        for (int i = 0; i < queries.length; i++) {\\n            int limit = queries[i];\\n            int score = 0;\\n            while (!pq.isEmpty()) {\\n                Pair pt = pq.peek();\\n                if (limit > grid[pt.x][pt.y]) {\\n                    pq.poll();\\n                    score++;\\n                } else\\n                    break;\\n                for (int dir[] : dirs) {\\n                    int x = dir[0] + pt.x;\\n                    int y = dir[1] + pt.y;\\n                    if (x >= 0 && x < n && y >= 0 && y < m && !seen[x][y]) {\\n                        pq.add(new Pair(x, y));\\n                        seen[x][y] = true;\\n                    }\\n                }\\n            }\\n            if (i > 0)\\n                map.put(limit, map.get(queries[i - 1]) + score);\\n            else\\n                map.put(limit, score);\\n        }\\n\\n        for (int i = 0; i < queries.length; i++)\\n            ans[i] = map.get(cpy_query[i]);\\n        return ans;\\n    }\\n}\\n\\nclass Pair {\\n    int x;\\n    int y;\\n\\n    Pair(int a, int b) {\\n        x = a;\\n        y = b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nclass Solution {\\n    int dirs[][] = new int[][] { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } };\\n\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        int n = grid.length, m = grid[0].length;\\n        int[] cpy_query = Arrays.copyOf(queries, queries.length);\\n\\n        Arrays.sort(queries);\\n\\n        int ans[] = new int[queries.length];\\n        Map<Integer, Integer> map = new HashMap<>();\\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> grid[a.x][a.y] - grid[b.x][b.y]);\\n        boolean[][] seen = new boolean[n][m];\\n\\n        pq.add(new Pair(0, 0));\\n        seen[0][0] = true;\\n\\n        for (int i = 0; i < queries.length; i++) {\\n            int limit = queries[i];\\n            int score = 0;\\n            while (!pq.isEmpty()) {\\n                Pair pt = pq.peek();\\n                if (limit > grid[pt.x][pt.y]) {\\n                    pq.poll();\\n                    score++;\\n                } else\\n                    break;\\n                for (int dir[] : dirs) {\\n                    int x = dir[0] + pt.x;\\n                    int y = dir[1] + pt.y;\\n                    if (x >= 0 && x < n && y >= 0 && y < m && !seen[x][y]) {\\n                        pq.add(new Pair(x, y));\\n                        seen[x][y] = true;\\n                    }\\n                }\\n            }\\n            if (i > 0)\\n                map.put(limit, map.get(queries[i - 1]) + score);\\n            else\\n                map.put(limit, score);\\n        }\\n\\n        for (int i = 0; i < queries.length; i++)\\n            ans[i] = map.get(cpy_query[i]);\\n        return ans;\\n    }\\n}\\n\\nclass Pair {\\n    int x;\\n    int y;\\n\\n    Pair(int a, int b) {\\n        x = a;\\n        y = b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960228,
                "title": "simple-java-solution-with-proper-classes-for-data",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create sorted queries (along with its index before sorting)\\n2. Add nodes (x, y, val) of first grid value in priority queue (sorted according to value)\\n3. Maintain a global counter\\n4. Add first node to visitedCells\\n5. For each query, see if the lowest value node has value less than query value\\n            - If yes, increment the counter\\n            - Add all non visited neighbors to priority queue and set them to visited\\n            - As long as the neighbors\\' values are smaller than current query value, they will be counted\\n              and their neighbors added to priority queue and visited set\\n            - If not, we loop to another query\\n6. At the end of each while loop (when it breaks), we add current count to result \\n\\n# Complexity\\n- Time complexity:O(nlogn). n being total size of grid. Because of use of priority queue\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(n). We don\\'t use more space than n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int[][] moves = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        \\n        List<Query> sortedQueries = new ArrayList<>();\\n        for (int i = 0; i < queries.length; i++) {\\n            sortedQueries.add(new Query(queries[i], i));\\n        }\\n        Collections.sort(sortedQueries, (x, y) -> x.val - y.val);\\n\\n        PriorityQueue<Node> cellQueue = new PriorityQueue<>((x, y) -> x.val - y.val);\\n        cellQueue.add(new Node(grid[0][0], 0, 0));\\n        \\n        int count = 0;\\n        int[] result = new int[queries.length];\\n        \\n        Set<Node> visitedCells = new HashSet<>();\\n        visitedCells.add(cellQueue.peek());  // Add cell {0, 0} with its value\\n        \\n        for (Query q : sortedQueries) {\\n            while (!cellQueue.isEmpty() && cellQueue.peek().val < q.val) {\\n                Node cell = cellQueue.poll();\\n                \\n                count++;\\n\\n                for (int[] move : moves) {\\n                    int x1 = cell.x + move[0];\\n                    int y1 = cell.y + move[1];\\n\\n                    if (x1 >= 0 && x1 < grid.length && y1 >= 0 && y1 < grid[0].length) {\\n                        Node newNode = new Node(grid[x1][y1], x1, y1);\\n                        \\n                        // Add all non visited neighbors, regardless of whether they are smaller or larger\\n                        // However, if the value in neighbor is less than current q.val, it will break the \\n                        // while loop and wait until value of q is greater than that neighbor or\\n                        // the for loop for query will end\\n                        if (!visitedCells.contains(newNode)) {\\n                            cellQueue.add(newNode);\\n                            visitedCells.add(newNode);\\n                        }\\n                        \\n                    }\\n                }\\n            }\\n\\n            result[q.pos] = count;\\n          }\\n\\n        return result;\\n    }\\n\\t\\n    static class Node {\\n        int val;\\n        int x, y;\\n\\n        public Node(int v, int x1, int y1) {\\n            val = v;\\n            x = x1;\\n            y = y1;\\n        }\\n\\n        public boolean equals(Object o2) {\\n            Node n2 = (Node) o2;\\n            return val == n2.val && x == n2.x && y == n2.y;\\n        }\\n\\n        public int hashCode() {\\n            return Objects.hash(val, x, y);\\n        }\\n\\n        public String toString() {\\n            return String.format(\"[%d, %d, %d]\", val, x, y);\\n        }\\n    }\\n\\n    static class Query {\\n        int val;\\n        int pos;\\n\\n        public Query(int v, int p) {\\n            val = v;\\n            pos = p;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    int[][] moves = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        \\n        List<Query> sortedQueries = new ArrayList<>();\\n        for (int i = 0; i < queries.length; i++) {\\n            sortedQueries.add(new Query(queries[i], i));\\n        }\\n        Collections.sort(sortedQueries, (x, y) -> x.val - y.val);\\n\\n        PriorityQueue<Node> cellQueue = new PriorityQueue<>((x, y) -> x.val - y.val);\\n        cellQueue.add(new Node(grid[0][0], 0, 0));\\n        \\n        int count = 0;\\n        int[] result = new int[queries.length];\\n        \\n        Set<Node> visitedCells = new HashSet<>();\\n        visitedCells.add(cellQueue.peek());  // Add cell {0, 0} with its value\\n        \\n        for (Query q : sortedQueries) {\\n            while (!cellQueue.isEmpty() && cellQueue.peek().val < q.val) {\\n                Node cell = cellQueue.poll();\\n                \\n                count++;\\n\\n                for (int[] move : moves) {\\n                    int x1 = cell.x + move[0];\\n                    int y1 = cell.y + move[1];\\n\\n                    if (x1 >= 0 && x1 < grid.length && y1 >= 0 && y1 < grid[0].length) {\\n                        Node newNode = new Node(grid[x1][y1], x1, y1);\\n                        \\n                        // Add all non visited neighbors, regardless of whether they are smaller or larger\\n                        // However, if the value in neighbor is less than current q.val, it will break the \\n                        // while loop and wait until value of q is greater than that neighbor or\\n                        // the for loop for query will end\\n                        if (!visitedCells.contains(newNode)) {\\n                            cellQueue.add(newNode);\\n                            visitedCells.add(newNode);\\n                        }\\n                        \\n                    }\\n                }\\n            }\\n\\n            result[q.pos] = count;\\n          }\\n\\n        return result;\\n    }\\n\\t\\n    static class Node {\\n        int val;\\n        int x, y;\\n\\n        public Node(int v, int x1, int y1) {\\n            val = v;\\n            x = x1;\\n            y = y1;\\n        }\\n\\n        public boolean equals(Object o2) {\\n            Node n2 = (Node) o2;\\n            return val == n2.val && x == n2.x && y == n2.y;\\n        }\\n\\n        public int hashCode() {\\n            return Objects.hash(val, x, y);\\n        }\\n\\n        public String toString() {\\n            return String.format(\"[%d, %d, %d]\", val, x, y);\\n        }\\n    }\\n\\n    static class Query {\\n        int val;\\n        int pos;\\n\\n        public Query(int v, int p) {\\n            val = v;\\n            pos = p;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948450,
                "title": "java-o-mnlog-m-n-48-ms-faster-than-99-91-less-than-52-53",
                "content": "# Intuition\\nEach query will take O(mn) time complexity and repeat the process. Try to generate a list which contains (threshold, count) and each query use binary search to find the result.\\n\\n**Example**\\n**Threshold 0 Count 0**\\n![step_0.png](https://assets.leetcode.com/users/images/3bb027f2-4532-484d-8309-992da5da855b_1671947278.001431.png)\\n**Threshold 1 Count 1**\\n![step_1.png](https://assets.leetcode.com/users/images/520aac8d-448b-40a6-b54a-a2d6fca00c82_1671947339.8171892.png)\\n**Threshold 2 Count 3**\\n![step_2.png](https://assets.leetcode.com/users/images/ee5165c7-5dff-4835-8373-8944d6a71447_1671947380.674309.png)\\n**Threshold 3 Count 5**\\n![step_3.png](https://assets.leetcode.com/users/images/f9a2cc4b-bb7c-4582-ab4c-a2e5519d702b_1671947401.3963497.png)\\n**Threshold 5 Count 8**\\n![step_4.png](https://assets.leetcode.com/users/images/504a9453-565c-4630-b2e9-e1dffe3bfa87_1671947429.960795.png)\\n**Threshold 7 Count 9**\\n![step_5.png](https://assets.leetcode.com/users/images/7d04eb5b-a8bd-4099-a846-bd359d087625_1671947461.5931692.png)\\n\\nPerform binary search with queries [5,6,2] to get [5,8,1]\\n\\n# Approach\\nPriorityQueue + DFS to build the list of thresholds.\\n1. Takse the value of first cell (top-left) as threshold\\n2. DFS with threshold\\n  a. If cell value <= threshold, increase count and continue\\n  b. If cell value > threshold, put into priority queue\\n3. When cannot continue with current threshold, add (threshold, count) and take new cell from priority queue and repeat from step 1 till queue is empty.\\n\\n\\n# Complexity\\n- Time complexity: O(mnlog(m+n))\\n  - DFS to visit all cells (m*n), Time complexity of dfs is limited to O(mn)\\n  - Max Size of Priority Queue is 2*(m+n-8), Time complexity of queue operations is limited to O(log(m+n))\\n  - Max Size of thresholds is m*n -> O(log(mn))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int threshold;\\n    int count;\\n    int[][] grid;\\n    boolean[][] visit;\\n    Queue<int[]> queue;\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        this.grid = grid;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        visit = new boolean[m][n];\\n        queue = new PriorityQueue<>((c1, c2) -> c1[2]-c2[2]);\\n        List<int[]> list = new ArrayList<>();\\n\\n        threshold = 0;\\n        count = 0;\\n        visit[0][0] = true;\\n        queue.offer(new int[] {0, 0, grid[0][0]});\\n        while (!queue.isEmpty()) {\\n            int[] cell = queue.poll();\\n            if (threshold < cell[2]) {\\n                list.add(new int[] {threshold, count});\\n                threshold = cell[2];\\n            }\\n            count++;\\n            dfs(cell);\\n        }\\n        list.add(new int[] {threshold, count});\\n\\n        for (int i = 0; i < queries.length; i++) queries[i] = search(list, queries[i]);\\n        return queries;\\n    }\\n\\n    private int search(List<int[]> list, int query) {\\n        int l = 0;\\n        int r = list.size();\\n        while (l < r) {\\n            int m = (l+r)/2;\\n            if (list.get(m)[0] >= query) r = m;\\n            else l = m+1;\\n        }\\n        return list.get(l-1)[1];\\n    }\\n\\n    private void dfs(int[] cell) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if (cell[0] > 0 && !visit[cell[0]-1][cell[1]]) process(new int[] {cell[0]-1, cell[1], grid[cell[0]-1][cell[1]]});\\n        if (cell[0] < m-1 && !visit[cell[0]+1][cell[1]]) process(new int[] {cell[0]+1, cell[1], grid[cell[0]+1][cell[1]]});\\n        if (cell[1] > 0 && !visit[cell[0]][cell[1]-1]) process(new int[] {cell[0], cell[1]-1, grid[cell[0]][cell[1]-1]});\\n        if (cell[1] < n-1 && !visit[cell[0]][cell[1]+1]) process(new int[] {cell[0], cell[1]+1, grid[cell[0]][cell[1]+1]});\\n    }\\n\\n    private void process(int[] cell) {\\n        visit[cell[0]][cell[1]] = true;\\n        if (cell[2] > threshold) queue.offer(cell);\\n        else {\\n            count++;\\n            dfs(cell);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int threshold;\\n    int count;\\n    int[][] grid;\\n    boolean[][] visit;\\n    Queue<int[]> queue;\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        this.grid = grid;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        visit = new boolean[m][n];\\n        queue = new PriorityQueue<>((c1, c2) -> c1[2]-c2[2]);\\n        List<int[]> list = new ArrayList<>();\\n\\n        threshold = 0;\\n        count = 0;\\n        visit[0][0] = true;\\n        queue.offer(new int[] {0, 0, grid[0][0]});\\n        while (!queue.isEmpty()) {\\n            int[] cell = queue.poll();\\n            if (threshold < cell[2]) {\\n                list.add(new int[] {threshold, count});\\n                threshold = cell[2];\\n            }\\n            count++;\\n            dfs(cell);\\n        }\\n        list.add(new int[] {threshold, count});\\n\\n        for (int i = 0; i < queries.length; i++) queries[i] = search(list, queries[i]);\\n        return queries;\\n    }\\n\\n    private int search(List<int[]> list, int query) {\\n        int l = 0;\\n        int r = list.size();\\n        while (l < r) {\\n            int m = (l+r)/2;\\n            if (list.get(m)[0] >= query) r = m;\\n            else l = m+1;\\n        }\\n        return list.get(l-1)[1];\\n    }\\n\\n    private void dfs(int[] cell) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if (cell[0] > 0 && !visit[cell[0]-1][cell[1]]) process(new int[] {cell[0]-1, cell[1], grid[cell[0]-1][cell[1]]});\\n        if (cell[0] < m-1 && !visit[cell[0]+1][cell[1]]) process(new int[] {cell[0]+1, cell[1], grid[cell[0]+1][cell[1]]});\\n        if (cell[1] > 0 && !visit[cell[0]][cell[1]-1]) process(new int[] {cell[0], cell[1]-1, grid[cell[0]][cell[1]-1]});\\n        if (cell[1] < n-1 && !visit[cell[0]][cell[1]+1]) process(new int[] {cell[0], cell[1]+1, grid[cell[0]][cell[1]+1]});\\n    }\\n\\n    private void process(int[] cell) {\\n        visit[cell[0]][cell[1]] = true;\\n        if (cell[2] > threshold) queue.offer(cell);\\n        else {\\n            count++;\\n            dfs(cell);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946701,
                "title": "python-solution-minheap-bfs",
                "content": "```\\ndef maxPoints(self, grid: List[List[int]], qs: List[int]) -> List[int]:\\n\\tm, n = len(grid), len(grid[0])\\n\\tgrid[0][0], q, cnt = 0, [(grid[0][0], 0, 0)], 0\\n\\tnums, res = sorted(set(qs)), {}\\n\\tfor k in nums:\\n\\t\\twhile q and q[0][0] < k:\\n\\t\\t\\tcnt += 1\\n\\t\\t\\t_, x, y = heappop(q)\\n\\t\\t\\tfor nx, ny in (x+1, y), (x-1, y), (x, y+1), (x, y-1):\\n\\t\\t\\t\\tif 0 <= nx < m and 0 <= ny < n and grid[nx][ny]:\\n\\t\\t\\t\\t\\theappush(q, (grid[nx][ny], nx, ny))\\n\\t\\t\\t\\t\\tgrid[nx][ny] = 0\\n\\t\\tres[k] = cnt\\n\\treturn [res[n] for n in qs]\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxPoints(self, grid: List[List[int]], qs: List[int]) -> List[int]:\\n\\tm, n = len(grid), len(grid[0])\\n\\tgrid[0][0], q, cnt = 0, [(grid[0][0], 0, 0)], 0\\n\\tnums, res = sorted(set(qs)), {}\\n\\tfor k in nums:\\n\\t\\twhile q and q[0][0] < k:\\n\\t\\t\\tcnt += 1\\n\\t\\t\\t_, x, y = heappop(q)\\n\\t\\t\\tfor nx, ny in (x+1, y), (x-1, y), (x, y+1), (x, y-1):\\n\\t\\t\\t\\tif 0 <= nx < m and 0 <= ny < n and grid[nx][ny]:\\n\\t\\t\\t\\t\\theappush(q, (grid[nx][ny], nx, ny))\\n\\t\\t\\t\\t\\tgrid[nx][ny] = 0\\n\\t\\tres[k] = cnt\\n\\treturn [res[n] for n in qs]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2945677,
                "title": "fast-and-easy-to-understand-dfs-priority-queue",
                "content": "# Approach\\nkeep track of neighbours which is greater than the value\\n# Complexity\\n- Time complexity:\\n- O(N*M*log(N*M))\\n- Space complexity:\\nO(N*M)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> vis;\\n    int dfs(vector<vector<int>> &grid,int &val,int i,int j,int n,int m,priority_queue<pair<int,pair<int,int>>>& que )\\n    {\\n        if(i<0||j<0||i>=n||j>=m)\\n            return(0);\\n    \\n    \\n        if(vis[i][j]==1)\\n            return(0);\\n\\n      // cout<<val<<\" \"<<grid[i][j]<<endl;\\n        if(val<=grid[i][j])\\n        {\\n            que.push({-grid[i][j],{i,j}});\\n            return(0);\\n        }\\n            \\n        vis[i][j]=1;\\n        return(1+dfs(grid,val,i+1,j,n,m,que)+dfs(grid,val,i,j+1,n,m,que)+dfs(grid,val,i-1,j,n,m,que)+dfs(grid,val,i,j-1,n,m,que));\\n    }\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& temp) {\\n        priority_queue<pair<int,pair<int,int>>> que; \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int> qu=temp;\\n        vis.resize(n,vector<int>(m,0));\\n        vector<int> v;\\n        int k=qu.size();\\n        int dp[k];\\n        memset(dp,0,sizeof(dp));\\n        sort(qu.begin(),qu.end());\\n        que.push({-1*grid[0][0],{0,0}});\\n        int in=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            \\n            int x=que.top().second.first;\\n            int y=que.top().second.second;\\n            //cout<<qu[i]<<\" \"<<grid[x][y]<<endl;\\n            while(!que.empty()&&qu[i]>grid[x][y])\\n            {\\n                \\n                int f=dfs(grid,qu[i],x,y,n,m,que);\\n                dp[in]+=f;\\n                //cout<<f<<endl;\\n                que.pop();\\n                if(!que.empty())\\n                {\\n                    x=que.top().second.first;\\n                    y=que.top().second.second;\\n                }\\n            }\\n            in++;\\n        }\\n        map<int,int> un_mp;\\n        un_mp[qu[0]]=dp[0];\\n        for(int i=1;i<k;i++)\\n        {\\n            dp[i]+=dp[i-1];\\n            un_mp[qu[i]]=dp[i];\\n        }\\n        for(auto i:temp)\\n        {\\n            v.push_back(un_mp[i]);\\n        }\\n        return(v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> vis;\\n    int dfs(vector<vector<int>> &grid,int &val,int i,int j,int n,int m,priority_queue<pair<int,pair<int,int>>>& que )\\n    {\\n        if(i<0||j<0||i>=n||j>=m)\\n            return(0);\\n    \\n    \\n        if(vis[i][j]==1)\\n            return(0);\\n\\n      // cout<<val<<\" \"<<grid[i][j]<<endl;\\n        if(val<=grid[i][j])\\n        {\\n            que.push({-grid[i][j],{i,j}});\\n            return(0);\\n        }\\n            \\n        vis[i][j]=1;\\n        return(1+dfs(grid,val,i+1,j,n,m,que)+dfs(grid,val,i,j+1,n,m,que)+dfs(grid,val,i-1,j,n,m,que)+dfs(grid,val,i,j-1,n,m,que));\\n    }\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& temp) {\\n        priority_queue<pair<int,pair<int,int>>> que; \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int> qu=temp;\\n        vis.resize(n,vector<int>(m,0));\\n        vector<int> v;\\n        int k=qu.size();\\n        int dp[k];\\n        memset(dp,0,sizeof(dp));\\n        sort(qu.begin(),qu.end());\\n        que.push({-1*grid[0][0],{0,0}});\\n        int in=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            \\n            int x=que.top().second.first;\\n            int y=que.top().second.second;\\n            //cout<<qu[i]<<\" \"<<grid[x][y]<<endl;\\n            while(!que.empty()&&qu[i]>grid[x][y])\\n            {\\n                \\n                int f=dfs(grid,qu[i],x,y,n,m,que);\\n                dp[in]+=f;\\n                //cout<<f<<endl;\\n                que.pop();\\n                if(!que.empty())\\n                {\\n                    x=que.top().second.first;\\n                    y=que.top().second.second;\\n                }\\n            }\\n            in++;\\n        }\\n        map<int,int> un_mp;\\n        un_mp[qu[0]]=dp[0];\\n        for(int i=1;i<k;i++)\\n        {\\n            dp[i]+=dp[i-1];\\n            un_mp[qu[i]]=dp[i];\\n        }\\n        for(auto i:temp)\\n        {\\n            v.push_back(un_mp[i]);\\n        }\\n        return(v);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2941437,
                "title": "java-javascript-priority-queue-bfs-picture-explanations",
                "content": "### Brute Force : Restart from [0, 0] every query, *TLE*\\n<img src=\"https://assets.leetcode.com/users/images/11f42a4f-4754-4e4a-9314-de94332458b9_1671780325.9356475.png\" width=\"300px\" height=\"auto\"/>\\n\\n<br>\\n<br>\\n\\n##### *Javascript - DFS*\\n```\\n/**\\n * @param {number[][]} grid\\n * @param {number[]} queries\\n * @return {number[]}\\n */\\nvar maxPoints = function(grid, queries) {\\n    const [row, col] = [grid.length, grid[0].length];\\n    \\n    const res = [];\\n    for(const query of queries){\\n        const newGrid = grid.map((arr) => arr.slice());\\n        res.push(dfs(query, 0, 0, newGrid));\\n    }\\n    return res;\\n    \\n    function dfs(query, r, c, newGrid){\\n        if(r < 0 || c < 0 || r === row || c === col || newGrid[r][c] >= query)\\n            return 0;\\n        newGrid[r][c] = Infinity;\\n        return 1 + dfs(query, r + 1, c, newGrid) \\n            + dfs(query, r - 1, c, newGrid)\\n            + dfs(query, r, c + 1, newGrid)\\n            + dfs(query, r, c - 1, newGrid);\\n    }\\n};\\n```\\n17 / 21\\xA0test cases passed.\\nTime : O(m* n * k)\\nSpace : O(m * n)\\n<br>\\n\\n---\\n\\n### Optimize Solution : Two PriorityQueue + BFS\\nWe can think about how to reduce duplicate tasks. \\nSince in each query, we need to start from grid[0][0] to count the points. Therefore, we can start with the minimum query, if the query\\'s value isn\\'t strictly greater than grid[0][0], We can first fill the current counting point into the result array.\\nOtherwise, we can start counting points from grid[0][0] to any adjacent cell in all 4 directions, and traverse with BFS.\\n\\nBUT \\uFF01Use Queue to implement BFS?\\nNotice, in the current query value, we need to include up to the number of points that can be counted. Therefore, we should use Min PriorityQueue to get the minimum grid\\'s value for counting.\\n\\nOk, based on our thinking, we need to prepare some variables.\\n\\nPrepare: \\n1. **Min PriorityQueue**, memorize the grid\\'s value and position index.\\n2. **Min PriorityQueue**, memorize the query\\'s value and index.\\n3. Use the boolean matrix to memorize that the grid is already visited.\\n    (or HashSet)\\n4. Empty result array\\n5. Global sum variable, memorize current counting.\\n\\n##### Init variable, and offer queries into queryPQ\\n<img src=\"https://assets.leetcode.com/users/images/9b330a25-f479-4f88-8ea9-18c36f1d3a34_1671780951.6424758.png\" width=\"600px\" height=\"auto\"/>\\n\\n<br>\\n<br>\\n\\n---\\n<br>\\n\\n#### First, offer grid[0][0] into gridPQ\\n<img src=\"https://assets.leetcode.com/users/images/bfe106bb-1d4c-47a6-ac57-1e560859177c_1671781041.159434.png\" width=\"600px\" height=\"auto\"/>\\n<br>\\n<br>\\n<br>\\n\\n#### 1, queryPQ top value compare with gridPQ top value\\n\\ttrue => \\n\\tsum += 1 \\n\\tpoll gridPQ\\n<img src=\"https://assets.leetcode.com/users/images/1cdc6007-12cc-41db-8723-01d7e3c776d4_1671781134.1258485.png\" width=\"600px\" height=\"auto\"/>\\n\\n<br>\\n<br>\\n<br>\\n\\n#### 2, poll\\'s cell visits 4 directions if it isn\\'t already visited and out of bound, offer cell into gridPQ\\n<img src=\"https://assets.leetcode.com/users/images/4f3f8007-1eac-4a61-8ed5-7ce2deadada6_1671781285.3170598.png\" width=\"600px\" height=\"auto\"/>\\n\\n<br>\\n<br>\\n<br>\\n\\n#### 3, keep compare\\nNow queryPQ top value is NOT strictly greater than gridPQ top value, poll queryPQ, and fill current sum into target index result array\\n<img src=\"https://assets.leetcode.com/users/images/1a97f651-eeed-4905-8ca1-c477f344bec7_1671781326.694682.png\" width=\"600px\" height=\"auto\"/>\\n\\n<br>\\n<br>\\n<br>\\n\\n\\n#### Keep Going...\\n<img src=\"https://assets.leetcode.com/users/images/c9368c8a-dc29-40df-9209-b7be06eaa5f4_1671781403.4702828.png\" width=\"400px\" height=\"auto\"/>\\n<img src=\"https://assets.leetcode.com/users/images/64432407-96db-49f3-8e68-8c1511ed5474_1671781499.5563977.png\" width=\"400px\" height=\"auto\"/>\\n<br>\\n<br>\\n<img src=\"https://assets.leetcode.com/users/images/cc860c36-3ad0-4230-b58f-394e922ab51e_1671781510.0710986.png\" width=\"400px\" height=\"auto\"/>\\n<img src=\"https://assets.leetcode.com/users/images/db607887-e81c-4ccc-9405-669a98822065_1671781525.9156504.png\" width=\"400px\" height=\"auto\"/>\\n<br>\\n<br>\\n<img src=\"https://assets.leetcode.com/users/images/e0d3ec40-375d-43ca-9b83-947fc3365713_1671781533.328053.png\" width=\"400px\" height=\"auto\"/>\\n<img src=\"https://assets.leetcode.com/users/images/7b6d2e5c-b574-433f-8ac2-14c867b05883_1671781544.0329726.png\" width=\"400px\" height=\"auto\"/>\\n<br>\\n<br>\\n\\n\\n#### Notice ! \\n#### Until finish the traversal grid, but maybe query\\'s PQ is not empty, we need to fill the rest of the query into the result array.\\n\\n<br>\\n\\n---\\n<br>\\n\\n##### *Java*\\n```\\nclass Solution {\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        int m = grid.length, n = grid[0].length, k = queries.length;\\n        int[] res = new int[k];\\n        \\n        // for queries: [val, index]\\n        PriorityQueue<int[]> queriesPQ = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n        // for grid: [val, row, col]\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n        boolean[][] visited = new boolean[m][n];\\n        pq.offer(new int[]{grid[0][0], 0, 0});\\n        visited[0][0] = true;\\n        \\n        // queries heap sort\\n        for(int i = 0; i < k; i++){\\n            queriesPQ.offer(new int[]{queries[i], i});\\n        }\\n        \\n        int sum = 0;\\n        int[] dr = new int[]{1, -1, 0, 0};\\n        int[] dc = new int[]{0, 0, 1, -1};\\n        while(!queriesPQ.isEmpty()){\\n            int[] curQuery = queriesPQ.poll();\\n            int val = curQuery[0], index = curQuery[1];\\n            \\n            while(!pq.isEmpty() && pq.peek()[0] < val){\\n                int[] curPos = pq.poll();\\n                int row = curPos[1], col = curPos[2];\\n                sum += 1;\\n                for(int i = 0; i < 4; i++){\\n                    int r = row + dr[i];\\n                    int c = col + dc[i];\\n                    if(r < 0 || c < 0 || r == m || c == n || visited[r][c])\\n                        continue;\\n                    visited[r][c] = true;\\n                    pq.offer(new int[]{grid[r][c], r, c});\\n                }\\n            }\\n            res[index] = sum;\\n        }\\n        \\n        while(!queriesPQ.isEmpty()){\\n            int[] cur = queriesPQ.poll();\\n            res[cur[1]] = sum;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n<br>\\n\\n---\\n<br>\\n\\n##### *Javascript*\\n```\\n/**\\n * @param {number[][]} grid\\n * @param {number[]} queries\\n * @return {number[]}\\n */\\nvar maxPoints = function(grid, queries) {\\n    const [m, n, k] = [grid.length, grid[0].length, queries.length];\\n    const res = new Array(k);\\n    \\n    // for grid: [val, row col]\\n    const pq = new PriorityQueue({compare: (a, b) => a[0] - b[0]});\\n    const visited = new Set();\\n    pq.enqueue([grid[0][0], 0, 0]);\\n    visited.add(`${0},${0}`);\\n    \\n    // for queries: [val, index]\\n    const newQueries = [];\\n    for(let i = 0; i < k; i++){\\n        newQueries.push([queries[i], i]);\\n    }\\n    \\n    // descending order by value, because we use pop() to get min value in JS, not use shift() to get it.\\n    newQueries.sort((a, b) => b[0] - a[0]);\\n    \\n    let sum = 0;\\n    const direct = [[1, 0], [-1, 0], [0, 1], [0, -1]];\\n    while(newQueries.length > 0){\\n        const [val, index] = newQueries.pop();\\n        while(pq.size() > 0 && pq.front()[0] < val){\\n            const [curVal, row, col] = pq.dequeue();\\n            sum += 1;\\n            for(const [dr, dc] of direct){\\n                const [r, c] = [row + dr, col + dc];\\n                if(r < 0 || c < 0 || r === m || c === n || visited.has(`${r},${c}`))\\n                    continue;\\n                visited.add(`${r},${c}`);\\n                pq.enqueue([grid[r][c], r, c]);\\n            }\\n        }\\n        res[index] = sum;\\n    }\\n    \\n    while(newQueries.length > 0){\\n        const [val, i] = newQueries.pop();\\n        res[i] = sum;\\n    }\\n    \\n    return res;\\n};\\n```\\n\\n#### Time : O( (mn)log(mn) + klogk )\\n#### Space : O(m * n)",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @param {number[]} queries\\n * @return {number[]}\\n */\\nvar maxPoints = function(grid, queries) {\\n    const [row, col] = [grid.length, grid[0].length];\\n    \\n    const res = [];\\n    for(const query of queries){\\n        const newGrid = grid.map((arr) => arr.slice());\\n        res.push(dfs(query, 0, 0, newGrid));\\n    }\\n    return res;\\n    \\n    function dfs(query, r, c, newGrid){\\n        if(r < 0 || c < 0 || r === row || c === col || newGrid[r][c] >= query)\\n            return 0;\\n        newGrid[r][c] = Infinity;\\n        return 1 + dfs(query, r + 1, c, newGrid) \\n            + dfs(query, r - 1, c, newGrid)\\n            + dfs(query, r, c + 1, newGrid)\\n            + dfs(query, r, c - 1, newGrid);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        int m = grid.length, n = grid[0].length, k = queries.length;\\n        int[] res = new int[k];\\n        \\n        // for queries: [val, index]\\n        PriorityQueue<int[]> queriesPQ = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n        // for grid: [val, row, col]\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n        boolean[][] visited = new boolean[m][n];\\n        pq.offer(new int[]{grid[0][0], 0, 0});\\n        visited[0][0] = true;\\n        \\n        // queries heap sort\\n        for(int i = 0; i < k; i++){\\n            queriesPQ.offer(new int[]{queries[i], i});\\n        }\\n        \\n        int sum = 0;\\n        int[] dr = new int[]{1, -1, 0, 0};\\n        int[] dc = new int[]{0, 0, 1, -1};\\n        while(!queriesPQ.isEmpty()){\\n            int[] curQuery = queriesPQ.poll();\\n            int val = curQuery[0], index = curQuery[1];\\n            \\n            while(!pq.isEmpty() && pq.peek()[0] < val){\\n                int[] curPos = pq.poll();\\n                int row = curPos[1], col = curPos[2];\\n                sum += 1;\\n                for(int i = 0; i < 4; i++){\\n                    int r = row + dr[i];\\n                    int c = col + dc[i];\\n                    if(r < 0 || c < 0 || r == m || c == n || visited[r][c])\\n                        continue;\\n                    visited[r][c] = true;\\n                    pq.offer(new int[]{grid[r][c], r, c});\\n                }\\n            }\\n            res[index] = sum;\\n        }\\n        \\n        while(!queriesPQ.isEmpty()){\\n            int[] cur = queriesPQ.poll();\\n            res[cur[1]] = sum;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\n/**\\n * @param {number[][]} grid\\n * @param {number[]} queries\\n * @return {number[]}\\n */\\nvar maxPoints = function(grid, queries) {\\n    const [m, n, k] = [grid.length, grid[0].length, queries.length];\\n    const res = new Array(k);\\n    \\n    // for grid: [val, row col]\\n    const pq = new PriorityQueue({compare: (a, b) => a[0] - b[0]});\\n    const visited = new Set();\\n    pq.enqueue([grid[0][0], 0, 0]);\\n    visited.add(`${0},${0}`);\\n    \\n    // for queries: [val, index]\\n    const newQueries = [];\\n    for(let i = 0; i < k; i++){\\n        newQueries.push([queries[i], i]);\\n    }\\n    \\n    // descending order by value, because we use pop() to get min value in JS, not use shift() to get it.\\n    newQueries.sort((a, b) => b[0] - a[0]);\\n    \\n    let sum = 0;\\n    const direct = [[1, 0], [-1, 0], [0, 1], [0, -1]];\\n    while(newQueries.length > 0){\\n        const [val, index] = newQueries.pop();\\n        while(pq.size() > 0 && pq.front()[0] < val){\\n            const [curVal, row, col] = pq.dequeue();\\n            sum += 1;\\n            for(const [dr, dc] of direct){\\n                const [r, c] = [row + dr, col + dc];\\n                if(r < 0 || c < 0 || r === m || c === n || visited.has(`${r},${c}`))\\n                    continue;\\n                visited.add(`${r},${c}`);\\n                pq.enqueue([grid[r][c], r, c]);\\n            }\\n        }\\n        res[index] = sum;\\n    }\\n    \\n    while(newQueries.length > 0){\\n        const [val, i] = newQueries.pop();\\n        res[i] = sum;\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2935864,
                "title": "kz-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Vertex struct {\\n\\tnnn             int\\n\\tcnt             int\\n\\tlst             []*Vertex\\n\\tisConnectedToZV bool\\n}\\n\\nfunc maxPoints(grid [][]int, queries []int) []int {\\n\\tret := make([]int, len(queries))\\n\\n\\tvar nnn int\\n\\tvar zeroVertex *Vertex\\n\\n\\tvar (\\n\\t\\ttopVertex *Vertex\\n\\t\\tlftVertex *Vertex\\n\\t\\twrkVertex *Vertex\\n\\t)\\n\\n\\tfor qi, q := range queries {\\n\\n\\t\\tif grid[0][0] >= q {\\n\\t\\t\\tret[qi] = 0\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tnnn = 0\\n\\t\\tzeroVertex = nil\\n\\n\\t\\tvisited := make([][]*Vertex, len(grid))\\n\\t\\tfor i := 0; i < len(grid); i++ {\\n\\t\\t\\tvisited[i] = make([]*Vertex, len(grid[i]))\\n\\t\\t\\tfor j := 0; j < len(grid[i]); j++ {\\n\\t\\t\\t\\tif grid[i][j] >= q {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttopVertex = nil\\n\\t\\t\\t\\tif i-1 >= 0 && visited[i-1][j] != nil {\\n\\t\\t\\t\\t\\ttopVertex = visited[i-1][j]\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tlftVertex = nil\\n\\t\\t\\t\\tif j-1 >= 0 && visited[i][j-1] != nil {\\n\\t\\t\\t\\t\\tlftVertex = visited[i][j-1]\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\twrkVertex = nil\\n\\t\\t\\t\\tif topVertex == nil && lftVertex == nil {\\n\\t\\t\\t\\t\\twrkVertex = &Vertex{\\n\\t\\t\\t\\t\\t\\tnnn:             nnn,\\n\\t\\t\\t\\t\\t\\tcnt:             0,\\n\\t\\t\\t\\t\\t\\tlst:             make([]*Vertex, 0),\\n\\t\\t\\t\\t\\t\\tisConnectedToZV: (i == 0 && j == 0),\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tnnn++\\n\\t\\t\\t\\t\\tif i == 0 && j == 0 {\\n\\t\\t\\t\\t\\t\\tzeroVertex = wrkVertex\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else if topVertex != nil && lftVertex != nil {\\n\\t\\t\\t\\t\\tif topVertex.isConnectedToZV && lftVertex.isConnectedToZV {\\n\\t\\t\\t\\t\\t\\twrkVertex = topVertex\\n\\t\\t\\t\\t\\t} else if topVertex.isConnectedToZV {\\n\\t\\t\\t\\t\\t\\twrkVertex = topVertex\\n\\t\\t\\t\\t\\t\\ttopVertex.lst = append(topVertex.lst, lftVertex)\\n\\t\\t\\t\\t\\t\\tlftVertex.isConnectedToZV = true\\n\\t\\t\\t\\t\\t} else if lftVertex.isConnectedToZV {\\n\\t\\t\\t\\t\\t\\twrkVertex = lftVertex\\n\\t\\t\\t\\t\\t\\tlftVertex.lst = append(lftVertex.lst, topVertex)\\n\\t\\t\\t\\t\\t\\ttopVertex.isConnectedToZV = true\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\twrkVertex = topVertex\\n\\t\\t\\t\\t\\t\\ttopVertex.lst = append(topVertex.lst, lftVertex)\\n\\t\\t\\t\\t\\t\\tlftVertex.lst = append(lftVertex.lst, topVertex)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else if topVertex != nil {\\n\\t\\t\\t\\t\\twrkVertex = topVertex\\n\\t\\t\\t\\t} else if lftVertex != nil {\\n\\t\\t\\t\\t\\twrkVertex = lftVertex\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvisited[i][j] = wrkVertex\\n\\t\\t\\t\\twrkVertex.cnt++\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t//printVisitedGrid(visited, aux)\\n\\n\\t\\tret[qi] = vertexSumDFS(zeroVertex, make([]bool, nnn))\\n\\t}\\n\\n\\treturn ret\\n}\\n\\nfunc vertexSumDFS(v *Vertex, visited []bool) int {\\n\\tif visited[v.nnn] {\\n\\t\\treturn 0\\n\\t}\\n\\tret := v.cnt\\n\\tfor _, vv := range v.lst {\\n\\t\\tvisited[v.nnn] = true\\n\\t\\tret += vertexSumDFS(vv, visited)\\n\\t}\\n\\n\\treturn ret\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Vertex struct {\\n\\tnnn             int\\n\\tcnt             int\\n\\tlst             []*Vertex\\n\\tisConnectedToZV bool\\n}\\n\\nfunc maxPoints(grid [][]int, queries []int) []int {\\n\\tret := make([]int, len(queries))\\n\\n\\tvar nnn int\\n\\tvar zeroVertex *Vertex\\n\\n\\tvar (\\n\\t\\ttopVertex *Vertex\\n\\t\\tlftVertex *Vertex\\n\\t\\twrkVertex *Vertex\\n\\t)\\n\\n\\tfor qi, q := range queries {\\n\\n\\t\\tif grid[0][0] >= q {\\n\\t\\t\\tret[qi] = 0\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tnnn = 0\\n\\t\\tzeroVertex = nil\\n\\n\\t\\tvisited := make([][]*Vertex, len(grid))\\n\\t\\tfor i := 0; i < len(grid); i++ {\\n\\t\\t\\tvisited[i] = make([]*Vertex, len(grid[i]))\\n\\t\\t\\tfor j := 0; j < len(grid[i]); j++ {\\n\\t\\t\\t\\tif grid[i][j] >= q {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttopVertex = nil\\n\\t\\t\\t\\tif i-1 >= 0 && visited[i-1][j] != nil {\\n\\t\\t\\t\\t\\ttopVertex = visited[i-1][j]\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tlftVertex = nil\\n\\t\\t\\t\\tif j-1 >= 0 && visited[i][j-1] != nil {\\n\\t\\t\\t\\t\\tlftVertex = visited[i][j-1]\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\twrkVertex = nil\\n\\t\\t\\t\\tif topVertex == nil && lftVertex == nil {\\n\\t\\t\\t\\t\\twrkVertex = &Vertex{\\n\\t\\t\\t\\t\\t\\tnnn:             nnn,\\n\\t\\t\\t\\t\\t\\tcnt:             0,\\n\\t\\t\\t\\t\\t\\tlst:             make([]*Vertex, 0),\\n\\t\\t\\t\\t\\t\\tisConnectedToZV: (i == 0 && j == 0),\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tnnn++\\n\\t\\t\\t\\t\\tif i == 0 && j == 0 {\\n\\t\\t\\t\\t\\t\\tzeroVertex = wrkVertex\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else if topVertex != nil && lftVertex != nil {\\n\\t\\t\\t\\t\\tif topVertex.isConnectedToZV && lftVertex.isConnectedToZV {\\n\\t\\t\\t\\t\\t\\twrkVertex = topVertex\\n\\t\\t\\t\\t\\t} else if topVertex.isConnectedToZV {\\n\\t\\t\\t\\t\\t\\twrkVertex = topVertex\\n\\t\\t\\t\\t\\t\\ttopVertex.lst = append(topVertex.lst, lftVertex)\\n\\t\\t\\t\\t\\t\\tlftVertex.isConnectedToZV = true\\n\\t\\t\\t\\t\\t} else if lftVertex.isConnectedToZV {\\n\\t\\t\\t\\t\\t\\twrkVertex = lftVertex\\n\\t\\t\\t\\t\\t\\tlftVertex.lst = append(lftVertex.lst, topVertex)\\n\\t\\t\\t\\t\\t\\ttopVertex.isConnectedToZV = true\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\twrkVertex = topVertex\\n\\t\\t\\t\\t\\t\\ttopVertex.lst = append(topVertex.lst, lftVertex)\\n\\t\\t\\t\\t\\t\\tlftVertex.lst = append(lftVertex.lst, topVertex)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else if topVertex != nil {\\n\\t\\t\\t\\t\\twrkVertex = topVertex\\n\\t\\t\\t\\t} else if lftVertex != nil {\\n\\t\\t\\t\\t\\twrkVertex = lftVertex\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvisited[i][j] = wrkVertex\\n\\t\\t\\t\\twrkVertex.cnt++\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t//printVisitedGrid(visited, aux)\\n\\n\\t\\tret[qi] = vertexSumDFS(zeroVertex, make([]bool, nnn))\\n\\t}\\n\\n\\treturn ret\\n}\\n\\nfunc vertexSumDFS(v *Vertex, visited []bool) int {\\n\\tif visited[v.nnn] {\\n\\t\\treturn 0\\n\\t}\\n\\tret := v.cnt\\n\\tfor _, vv := range v.lst {\\n\\t\\tvisited[v.nnn] = true\\n\\t\\tret += vertexSumDFS(vv, visited)\\n\\t}\\n\\n\\treturn ret\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2934456,
                "title": "set-c-simple",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    vector<pair<int,int>> dir = {{0,1}, {1,0}, {0,-1}, {-1,0}} ;\\n\\n    bool isvalid( int x , int y , int row , int col )\\n    {\\n        if (x >= 0 and y >= 0 and x < row and y < col )\\n            return true ;\\n        return false ;\\n    }\\n\\n    int solve(vector<vector<int>>&grid,int k,vector<int> &done, set<pair<int,pair<int,int>>> &adj, vector<vector<int>> &visited )\\n    {\\n        int row = grid.size(), col = grid[0].size() ;\\n        \\n        while( !adj.empty() and adj.begin()->first < k )\\n        { \\n            auto point = adj.begin() ;\\n            int data = point->first;\\n            int x = point->second.first;\\n            int y = point->second.second ;\\n            adj.erase(point) ;\\n            done.push_back(data) ;\\n\\n            for ( int i = 0 ; i < 4 ; i++ )\\n            {\\n                int nx = x + dir[i].first ;\\n                int ny = y + dir[i].second;\\n                if ( isvalid(nx,ny,row,col) and visited[nx][ny] == 0 )\\n                {\\n                    adj.insert({grid[nx][ny],{nx,ny}}) ;\\n                    visited[nx][ny] = 1 ;\\n                }\\n            }\\n        }\\n        return done.size() ;  \\n    }\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int qs = queries.size() ;\\n        int row = grid.size(), col = grid[0].size() ;\\n        vector<int> ans ( qs) ;\\n        vector<pair<int,int>> nquery ;\\n        for ( int i = 0 ; i <qs ; i++ )\\n            nquery.push_back({queries[i],i}) ;\\n        sort(nquery.begin(),nquery.end()) ;\\n        vector<int> done ;\\n        set<pair<int,pair<int,int>>> adj;\\n        vector<vector<int>> visited(row,vector<int>(col,0)) ;\\n\\n        adj.insert({grid[0][0],{0,0}}) ;\\n        visited[0][0] = 1 ;\\n        \\n        for ( int i = 0; i < qs; i++ )\\n        {\\n            int res = solve(grid, nquery[i].first, done, adj, visited ) ;\\n            ans[nquery[i].second] = res ;\\n        }\\n        return ans ;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n    vector<pair<int,int>> dir = {{0,1}, {1,0}, {0,-1}, {-1,0}} ;\\n\\n    bool isvalid( int x , int y , int row , int col )\\n    {\\n        if (x >= 0 and y >= 0 and x < row and y < col )\\n            return true ;\\n        return false ;\\n    }\\n\\n    int solve(vector<vector<int>>&grid,int k,vector<int> &done, set<pair<int,pair<int,int>>> &adj, vector<vector<int>> &visited )\\n    {\\n        int row = grid.size(), col = grid[0].size() ;\\n        \\n        while( !adj.empty() and adj.begin()->first < k )\\n        { \\n            auto point = adj.begin() ;\\n            int data = point->first;\\n            int x = point->second.first;\\n            int y = point->second.second ;\\n            adj.erase(point) ;\\n            done.push_back(data) ;\\n\\n            for ( int i = 0 ; i < 4 ; i++ )\\n            {\\n                int nx = x + dir[i].first ;\\n                int ny = y + dir[i].second;\\n                if ( isvalid(nx,ny,row,col) and visited[nx][ny] == 0 )\\n                {\\n                    adj.insert({grid[nx][ny],{nx,ny}}) ;\\n                    visited[nx][ny] = 1 ;\\n                }\\n            }\\n        }\\n        return done.size() ;  \\n    }\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int qs = queries.size() ;\\n        int row = grid.size(), col = grid[0].size() ;\\n        vector<int> ans ( qs) ;\\n        vector<pair<int,int>> nquery ;\\n        for ( int i = 0 ; i <qs ; i++ )\\n            nquery.push_back({queries[i],i}) ;\\n        sort(nquery.begin(),nquery.end()) ;\\n        vector<int> done ;\\n        set<pair<int,pair<int,int>>> adj;\\n        vector<vector<int>> visited(row,vector<int>(col,0)) ;\\n\\n        adj.insert({grid[0][0],{0,0}}) ;\\n        visited[0][0] = 1 ;\\n        \\n        for ( int i = 0; i < qs; i++ )\\n        {\\n            int res = solve(grid, nquery[i].first, done, adj, visited ) ;\\n            ans[nquery[i].second] = res ;\\n        }\\n        return ans ;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933990,
                "title": "python-priority-queue-one-pass-o-mnlog-mn-easy-to-understand",
                "content": "\\n# Code\\n```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        h = [(grid[0][0],0,0)]\\n        m,n = len(grid), len(grid[0])\\n        visited = set([(0,0)])\\n        curval = 0\\n        curcnt = 0\\n        sortedlist = []\\n        cntlist = []\\n        while h:\\n            d,i,j = heappop(h)\\n            if curval != d:\\n                sortedlist.append(curval)\\n                cntlist.append(curcnt)\\n                curval = d\\n                curcnt = 0\\n            curcnt += 1\\n            for di,dj in [[-1,0],[1,0],[0,-1],[0,1]]:\\n                if 0<=i+di<m and 0<=j+dj<n and (i+di,j+dj) not in visited:\\n                    heappush(h,(grid[i+di][j+dj],i+di,j+dj))\\n                    visited.add((i+di,j+dj))\\n        sortedlist.append(curval)\\n        cntlist.append(curcnt)\\n        res = [0]*len(queries)\\n        queries = list(sorted([(q,i) for i,q in enumerate(queries)]))\\n        j = 0\\n        k = len(sortedlist)\\n        cursum = 0\\n        for q, i in queries:\\n            while j < k and sortedlist[j] < q:\\n                cursum += cntlist[j]\\n                j += 1\\n            res[i] = cursum\\n        return res\\n\\n            \\n        \\n            \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        h = [(grid[0][0],0,0)]\\n        m,n = len(grid), len(grid[0])\\n        visited = set([(0,0)])\\n        curval = 0\\n        curcnt = 0\\n        sortedlist = []\\n        cntlist = []\\n        while h:\\n            d,i,j = heappop(h)\\n            if curval != d:\\n                sortedlist.append(curval)\\n                cntlist.append(curcnt)\\n                curval = d\\n                curcnt = 0\\n            curcnt += 1\\n            for di,dj in [[-1,0],[1,0],[0,-1],[0,1]]:\\n                if 0<=i+di<m and 0<=j+dj<n and (i+di,j+dj) not in visited:\\n                    heappush(h,(grid[i+di][j+dj],i+di,j+dj))\\n                    visited.add((i+di,j+dj))\\n        sortedlist.append(curval)\\n        cntlist.append(curcnt)\\n        res = [0]*len(queries)\\n        queries = list(sorted([(q,i) for i,q in enumerate(queries)]))\\n        j = 0\\n        k = len(sortedlist)\\n        cursum = 0\\n        for q, i in queries:\\n            while j < k and sortedlist[j] < q:\\n                cursum += cntlist[j]\\n                j += 1\\n            res[i] = cursum\\n        return res\\n\\n            \\n        \\n            \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928703,
                "title": "c-heap-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(int i, int j, int m, int n) {\\n        if(i >= m || i < 0 || j >=n || j < 0)return false;\\n        return true;\\n    }\\n    int dx[4] = {0,0,-1, 1};\\n    int dy[4] = {1, -1, 0, 0};\\n    \\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        bool visited[m][n];\\n        \\n        memset(visited, false, sizeof visited);\\n        \\n        priority_queue<vector<int>, vector<vector<int>>, greater<>> pq;\\n        \\n        pq.push({grid[0][0], 0, 0});\\n        visited[0][0] = true;\\n        \\n        map<int,int> maxPointMap;\\n        int visitedCount = 0;\\n        int currentMax = INT_MIN;\\n        \\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            \\n            auto xi = top[1];\\n            auto yi = top[2];\\n            auto val = top[0];\\n            \\n            for(int d=0; d<4; d++){\\n                auto xj = xi+dx[d];\\n                auto yj = yi+dy[d];\\n                if(isValid(xj, yj, m, n) && !visited[xj][yj]){\\n                    visited[xj][yj] = true;\\n                    pq.push({grid[xj][yj], xj, yj});\\n                }\\n            }\\n            currentMax = max(currentMax, val);\\n            maxPointMap[currentMax] = ++visitedCount;\\n            //cout<<currentMax<<\" \"<<visitedCount<<endl;\\n        }\\n        \\n        vector<int> ans;\\n        \\n        for(auto q:queries){\\n            auto itr = --maxPointMap.lower_bound(q);\\n            \\n            if(itr->first < q)\\n                ans.push_back(itr->second);\\n            else \\n                ans.push_back(0);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int i, int j, int m, int n) {\\n        if(i >= m || i < 0 || j >=n || j < 0)return false;\\n        return true;\\n    }\\n    int dx[4] = {0,0,-1, 1};\\n    int dy[4] = {1, -1, 0, 0};\\n    \\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        bool visited[m][n];\\n        \\n        memset(visited, false, sizeof visited);\\n        \\n        priority_queue<vector<int>, vector<vector<int>>, greater<>> pq;\\n        \\n        pq.push({grid[0][0], 0, 0});\\n        visited[0][0] = true;\\n        \\n        map<int,int> maxPointMap;\\n        int visitedCount = 0;\\n        int currentMax = INT_MIN;\\n        \\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            \\n            auto xi = top[1];\\n            auto yi = top[2];\\n            auto val = top[0];\\n            \\n            for(int d=0; d<4; d++){\\n                auto xj = xi+dx[d];\\n                auto yj = yi+dy[d];\\n                if(isValid(xj, yj, m, n) && !visited[xj][yj]){\\n                    visited[xj][yj] = true;\\n                    pq.push({grid[xj][yj], xj, yj});\\n                }\\n            }\\n            currentMax = max(currentMax, val);\\n            maxPointMap[currentMax] = ++visitedCount;\\n            //cout<<currentMax<<\" \"<<visitedCount<<endl;\\n        }\\n        \\n        vector<int> ans;\\n        \\n        for(auto q:queries){\\n            auto itr = --maxPointMap.lower_bound(q);\\n            \\n            if(itr->first < q)\\n                ans.push_back(itr->second);\\n            else \\n                ans.push_back(0);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2924676,
                "title": "java-priority-queue-bfs-using-first-hint",
                "content": "# Intuition\\nSort queries (inspired from first hint)\\n\\n# Approach\\nAdd points to the priority queue and stop when the top is more than or equal to the current query.\\n\\n# Complexity\\n- Time complexity:\\n$$O(m.n.log(m.n))$$\\n\\n- Space complexity:\\n$$O(m.n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    PriorityQueue<Pair<Integer, Pair<Integer, Integer>>> pq =\\n            new PriorityQueue<Pair<Integer, Pair<Integer, Integer>>>((a, b) -> a.getKey() - b.getKey());\\n    boolean[][] visited;\\n    int tot = 0;\\n\\n    int getAnswer(int query, int[][] grid) {\\n        int rows = grid.length, cols = grid[0].length;\\n        while (!pq.isEmpty() && pq.peek().getKey() < query) {\\n            tot++;\\n            Pair<Integer, Integer> point = pq.poll().getValue();\\n            int row = point.getKey(), col = point.getValue();\\n            if (row > 0 && !visited[row - 1][col]) {\\n                pq.offer(new Pair<>(grid[row - 1][col], new Pair<>(row - 1, col)));\\n                visited[row - 1][col] = true;\\n            }\\n            if (row < (rows - 1) && !visited[row + 1][col]) {\\n                pq.offer(new Pair<>(grid[row + 1][col], new Pair<>(row + 1, col)));\\n                visited[row + 1][col] = true;\\n            }\\n            if (col > 0 && !visited[row][col - 1]) {\\n                pq.offer(new Pair<>(grid[row][col - 1], new Pair<>(row, col - 1)));\\n                visited[row][col - 1] = true;\\n            }\\n            if (col < (cols - 1) && !visited[row][col + 1]) {\\n                pq.offer(new Pair<>(grid[row][col + 1], new Pair<>(row, col + 1)));\\n                visited[row][col + 1] = true;\\n            }\\n        }\\n        return tot;\\n    }\\n\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        visited = new boolean[grid.length][grid[0].length];\\n        int[] answer = new int[queries.length];\\n        ArrayList<Pair<Integer, Integer>> queryArr = new ArrayList<>();\\n        for (int i = 0; i < queries.length; ++i) {\\n            queryArr.add(new Pair<>(queries[i], i));\\n        }\\n        Collections.sort(queryArr, (a, b) -> a.getKey() - b.getKey());\\n        pq.offer(new Pair<>(grid[0][0], new Pair<>(0, 0)));\\n        visited[0][0] = true;\\n        for (Pair<Integer, Integer> query : queryArr) {\\n            int ans = getAnswer(query.getKey(), grid);\\n            answer[query.getValue()] = ans;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    PriorityQueue<Pair<Integer, Pair<Integer, Integer>>> pq =\\n            new PriorityQueue<Pair<Integer, Pair<Integer, Integer>>>((a, b) -> a.getKey() - b.getKey());\\n    boolean[][] visited;\\n    int tot = 0;\\n\\n    int getAnswer(int query, int[][] grid) {\\n        int rows = grid.length, cols = grid[0].length;\\n        while (!pq.isEmpty() && pq.peek().getKey() < query) {\\n            tot++;\\n            Pair<Integer, Integer> point = pq.poll().getValue();\\n            int row = point.getKey(), col = point.getValue();\\n            if (row > 0 && !visited[row - 1][col]) {\\n                pq.offer(new Pair<>(grid[row - 1][col], new Pair<>(row - 1, col)));\\n                visited[row - 1][col] = true;\\n            }\\n            if (row < (rows - 1) && !visited[row + 1][col]) {\\n                pq.offer(new Pair<>(grid[row + 1][col], new Pair<>(row + 1, col)));\\n                visited[row + 1][col] = true;\\n            }\\n            if (col > 0 && !visited[row][col - 1]) {\\n                pq.offer(new Pair<>(grid[row][col - 1], new Pair<>(row, col - 1)));\\n                visited[row][col - 1] = true;\\n            }\\n            if (col < (cols - 1) && !visited[row][col + 1]) {\\n                pq.offer(new Pair<>(grid[row][col + 1], new Pair<>(row, col + 1)));\\n                visited[row][col + 1] = true;\\n            }\\n        }\\n        return tot;\\n    }\\n\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        visited = new boolean[grid.length][grid[0].length];\\n        int[] answer = new int[queries.length];\\n        ArrayList<Pair<Integer, Integer>> queryArr = new ArrayList<>();\\n        for (int i = 0; i < queries.length; ++i) {\\n            queryArr.add(new Pair<>(queries[i], i));\\n        }\\n        Collections.sort(queryArr, (a, b) -> a.getKey() - b.getKey());\\n        pq.offer(new Pair<>(grid[0][0], new Pair<>(0, 0)));\\n        visited[0][0] = true;\\n        for (Pair<Integer, Integer> query : queryArr) {\\n            int ans = getAnswer(query.getKey(), grid);\\n            answer[query.getValue()] = ans;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924176,
                "title": "javascript-bfs-min-heap-pq-632ms",
                "content": "```\\nconst initialize2DArray = (n, m) => { let d = []; for (let i = 0; i < n; i++) { let t = Array(m).fill(false); d.push(t); } return d; };\\n\\nconst dx = [-1, 1, 0, 0], dy = [0, 0, -1, 1];\\nconst maxPoints = (g, queries) => {\\n    let n = g.length, m = g[0].length, cnt = 0, res = Array(queries.length), vis = initialize2DArray(n, m), pq = new MinPriorityQueue({\\n        compare: (x, y) => {\\n            if (x[0] != y[0]) return x[0] - y[0];\\n            if (x[1] != y[1]) return x[1] - y[1];\\n            return x[2] - y[2];\\n        }\\n    });\\n    queries = queries.map((x, i) => [x, i]).sort((x, y) => {\\n        if (x[0] != y[0]) return x[0] - y[0];\\n        return x[1] - y[1];\\n    });\\n    pq.enqueue([g[0][0], 0, 0]);\\n    vis[0][0] = true;\\n    for (const [q, i] of queries) {\\n        while (pq.size() && q > pq.front()[0]) {\\n            let [, x, y] = pq.dequeue();\\n            cnt++;\\n            for (let k = 0; k < 4; k++) {\\n                let nx = x + dx[k], ny = y + dy[k];\\n                if (nx < 0 || nx >= n || ny < 0 || ny >= m || vis[nx][ny]) continue;\\n                pq.enqueue([g[nx][ny], nx, ny]);\\n                vis[nx][ny] = true;\\n            }\\n        }\\n        res[i] = cnt;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst initialize2DArray = (n, m) => { let d = []; for (let i = 0; i < n; i++) { let t = Array(m).fill(false); d.push(t); } return d; };\\n\\nconst dx = [-1, 1, 0, 0], dy = [0, 0, -1, 1];\\nconst maxPoints = (g, queries) => {\\n    let n = g.length, m = g[0].length, cnt = 0, res = Array(queries.length), vis = initialize2DArray(n, m), pq = new MinPriorityQueue({\\n        compare: (x, y) => {\\n            if (x[0] != y[0]) return x[0] - y[0];\\n            if (x[1] != y[1]) return x[1] - y[1];\\n            return x[2] - y[2];\\n        }\\n    });\\n    queries = queries.map((x, i) => [x, i]).sort((x, y) => {\\n        if (x[0] != y[0]) return x[0] - y[0];\\n        return x[1] - y[1];\\n    });\\n    pq.enqueue([g[0][0], 0, 0]);\\n    vis[0][0] = true;\\n    for (const [q, i] of queries) {\\n        while (pq.size() && q > pq.front()[0]) {\\n            let [, x, y] = pq.dequeue();\\n            cnt++;\\n            for (let k = 0; k < 4; k++) {\\n                let nx = x + dx[k], ny = y + dy[k];\\n                if (nx < 0 || nx >= n || ny < 0 || ny >= m || vis[nx][ny]) continue;\\n                pq.enqueue([g[nx][ny], nx, ny]);\\n                vis[nx][ny] = true;\\n            }\\n        }\\n        res[i] = cnt;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2923719,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn max_points(grid: Vec<Vec<i32>>, queries: Vec<i32>) -> Vec<i32> {\\n        use std::cmp::Reverse;\\n        use std::collections::BinaryHeap;\\n\\n        let mut data = vec![];\\n        for (i, &item) in queries.iter().enumerate() {\\n            data.push((item, i));\\n        }\\n        data.sort();\\n\\n        let mut ret = vec![0; data.len()];\\n        let (m, n) = (grid.len(), grid[0].len());\\n        let mut flag = vec![vec![0; n]; m];\\n        let mut pq = BinaryHeap::from([Reverse((grid[0][0], 0, 0))]);\\n        let mut count = 0;\\n        let dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]];\\n        flag[0][0] = 1;\\n\\n        for q in data {\\n            while let Some(Reverse((val, u, v))) = pq.peek() {\\n                if *val >= q.0 {\\n                    break;\\n                }\\n                let (u, v) = (*u as i32, *v as i32);\\n                count += 1;\\n                pq.pop();\\n\\n                for d in dirs {\\n                    let (i, j) = (u + d[0], v + d[1]);\\n                    if i < 0 || i == m as i32 || j < 0 || j == n as i32 {\\n                        continue;\\n                    }\\n\\n                    let (i, j) = (i as usize, j as usize);\\n                    if flag[i][j] == 1 {\\n                        continue;\\n                    }\\n\\n                    flag[i][j] = 1;\\n                    pq.push(Reverse((grid[i][j], i, j)));\\n                }\\n            }\\n\\n            ret[q.1] = count;\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_points(grid: Vec<Vec<i32>>, queries: Vec<i32>) -> Vec<i32> {\\n        use std::cmp::Reverse;\\n        use std::collections::BinaryHeap;\\n\\n        let mut data = vec![];\\n        for (i, &item) in queries.iter().enumerate() {\\n            data.push((item, i));\\n        }\\n        data.sort();\\n\\n        let mut ret = vec![0; data.len()];\\n        let (m, n) = (grid.len(), grid[0].len());\\n        let mut flag = vec![vec![0; n]; m];\\n        let mut pq = BinaryHeap::from([Reverse((grid[0][0], 0, 0))]);\\n        let mut count = 0;\\n        let dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]];\\n        flag[0][0] = 1;\\n\\n        for q in data {\\n            while let Some(Reverse((val, u, v))) = pq.peek() {\\n                if *val >= q.0 {\\n                    break;\\n                }\\n                let (u, v) = (*u as i32, *v as i32);\\n                count += 1;\\n                pq.pop();\\n\\n                for d in dirs {\\n                    let (i, j) = (u + d[0], v + d[1]);\\n                    if i < 0 || i == m as i32 || j < 0 || j == n as i32 {\\n                        continue;\\n                    }\\n\\n                    let (i, j) = (i as usize, j as usize);\\n                    if flag[i][j] == 1 {\\n                        continue;\\n                    }\\n\\n                    flag[i][j] = 1;\\n                    pq.push(Reverse((grid[i][j], i, j)));\\n                }\\n            }\\n\\n            ret[q.1] = count;\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2923354,
                "title": "python-bfs",
                "content": "```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        q, i, n, cnt = [[grid[0][0], 0, 0]], 0, len(queries), 0\\n        rows, cols = len(grid), len(grid[0])\\n        queries, res = [[v, i] for i, v in enumerate(queries)], [0]*n\\n        dirs, cnt = [[1, 0], [-1, 0], [0, 1], [0, -1]], 0\\n        queries.sort()\\n        grid[0][0] = 0\\n        while q and i<n:\\n            if queries[i][0]<=q[0][0]:\\n                res[queries[i][1]] = cnt\\n                i+=1\\n                continue\\n            val, row, col = heapq.heappop(q)\\n            cnt+=1\\n            for dir_ in dirs:\\n                next_i, next_j = row+dir_[0], col+dir_[1]\\n                if 0<=next_i<rows and 0<=next_j<cols and grid[next_i][next_j]:\\n                    heapq.heappush(q, [grid[next_i][next_j], next_i, next_j])\\n                    grid[next_i][next_j] = 0\\n        while i<n:\\n            res[queries[i][1]] = cnt\\n            i+=1\\n        return res",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        q, i, n, cnt = [[grid[0][0], 0, 0]], 0, len(queries), 0\\n        rows, cols = len(grid), len(grid[0])\\n        queries, res = [[v, i] for i, v in enumerate(queries)], [0]*n\\n        dirs, cnt = [[1, 0], [-1, 0], [0, 1], [0, -1]], 0\\n        queries.sort()\\n        grid[0][0] = 0\\n        while q and i<n:\\n            if queries[i][0]<=q[0][0]:\\n                res[queries[i][1]] = cnt\\n                i+=1\\n                continue\\n            val, row, col = heapq.heappop(q)\\n            cnt+=1\\n            for dir_ in dirs:\\n                next_i, next_j = row+dir_[0], col+dir_[1]\\n                if 0<=next_i<rows and 0<=next_j<cols and grid[next_i][next_j]:\\n                    heapq.heappush(q, [grid[next_i][next_j], next_i, next_j])\\n                    grid[next_i][next_j] = 0\\n        while i<n:\\n            res[queries[i][1]] = cnt\\n            i+=1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2922552,
                "title": "simple-c-bfs-solution-using-priority-queue",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O((m*n)log(m*n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n# Code\\n```\\n#define pi pair<int,int>\\n#define ppi pair<int,pi>\\nclass Solution {\\npublic:\\n     \\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n//Approach=>Traverse the queries in sorted (ascending) order and apply Simple BFS using priority queue\\n        //first sort the queries with index\\n        int k=queries.size(),m=grid.size(),n=grid[0].size();\\n        vector<int>ans(k);//to store ans\\n        vector<vector<bool>>vis(m,vector<bool>(n,false));//visited matrix\\n        vector<pi>vp={{-1,0},{1,0},{0,-1},{0,1}};//for adjacent cells\\n        vector<pi>query;\\n        for(int i=0;i<k;i++){\\n            query.push_back({queries[i],i});\\n        }\\n        sort(begin(query),end(query));//sort the query in ascending order\\n        //create minHeap(priority_queue)=>This will ensure that elements will be visited in ascending order(in this way we will traverse the matrix only one time)\\n        priority_queue<ppi,vector<ppi>,greater<ppi>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        vis[0][0]=true;\\n        int val,idx,cnt=0,i,j,newi,newj;\\n        for(auto &p:query){\\n            val=p.first;\\n            idx=p.second;\\n         \\n            while(!pq.empty() && val>pq.top().first){\\n               cnt++;//store the points\\n               i=pq.top().second.first;\\n               j=pq.top().second.second;\\n               pq.pop();\\n               for(auto &pp:vp){\\n                  newi=i+pp.first;\\n                  newj=j+pp.second;\\n                  if(newi>=0 && newi<m && newj>=0 && newj<n && !vis[newi][newj]){\\n                      vis[newi][newj]=true;\\n                      pq.push({grid[newi][newj],{newi,newj}});\\n                  }\\n               }\\n            }\\n            ans[idx]=cnt;\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define pi pair<int,int>\\n#define ppi pair<int,pi>\\nclass Solution {\\npublic:\\n     \\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n//Approach=>Traverse the queries in sorted (ascending) order and apply Simple BFS using priority queue\\n        //first sort the queries with index\\n        int k=queries.size(),m=grid.size(),n=grid[0].size();\\n        vector<int>ans(k);//to store ans\\n        vector<vector<bool>>vis(m,vector<bool>(n,false));//visited matrix\\n        vector<pi>vp={{-1,0},{1,0},{0,-1},{0,1}};//for adjacent cells\\n        vector<pi>query;\\n        for(int i=0;i<k;i++){\\n            query.push_back({queries[i],i});\\n        }\\n        sort(begin(query),end(query));//sort the query in ascending order\\n        //create minHeap(priority_queue)=>This will ensure that elements will be visited in ascending order(in this way we will traverse the matrix only one time)\\n        priority_queue<ppi,vector<ppi>,greater<ppi>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        vis[0][0]=true;\\n        int val,idx,cnt=0,i,j,newi,newj;\\n        for(auto &p:query){\\n            val=p.first;\\n            idx=p.second;\\n         \\n            while(!pq.empty() && val>pq.top().first){\\n               cnt++;//store the points\\n               i=pq.top().second.first;\\n               j=pq.top().second.second;\\n               pq.pop();\\n               for(auto &pp:vp){\\n                  newi=i+pp.first;\\n                  newj=j+pp.second;\\n                  if(newi>=0 && newi<m && newj>=0 && newj<n && !vis[newi][newj]){\\n                      vis[newi][newj]=true;\\n                      pq.push({grid[newi][newj],{newi,newj}});\\n                  }\\n               }\\n            }\\n            ans[idx]=cnt;\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2922242,
                "title": "python-solution-using-priority-queue-and-bfs",
                "content": "\\n\\n# Code\\n```\\nfrom queue import PriorityQueue\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        obj=PriorityQueue()\\n        obj.put([grid[0][0],0,0])\\n        q=list(enumerate(queries))\\n        q.sort(key=lambda x:x[1])\\n        visited=[[False for _ in range(len(grid[0]))] for __ in range(len(grid))]\\n        count=0\\n        ans=[0 for __ in range(len(q))]\\n        visited[0][0]=True\\n        it=0\\n        for item in q:\\n            l=[]\\n            while(not obj.empty()):\\n                val,i,j=obj.get()\\n                if(val>=item[1]):\\n                    obj.put([val,i,j])\\n                    break\\n                else:\\n                    count+=1\\n                    if(i+1<len(grid) and not visited[i+1][j]):\\n                        visited[i+1][j]=True\\n                        obj.put([grid[i+1][j],i+1,j])\\n                    if(j+1<len(grid[0]) and not visited[i][j+1]):\\n                        visited[i][j+1]=True\\n                        obj.put([grid[i][j+1],i,j+1])\\n                    if(i-1>=0 and not visited[i-1][j]):\\n                        visited[i-1][j]=True\\n                        obj.put([grid[i-1][j],i-1,j])\\n                    if(j-1>=0 and not visited[i][j-1]):\\n                        visited[i][j-1]=True\\n                        obj.put([grid[i][j-1],i,j-1])\\n            ans[item[0]]=count\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom queue import PriorityQueue\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        obj=PriorityQueue()\\n        obj.put([grid[0][0],0,0])\\n        q=list(enumerate(queries))\\n        q.sort(key=lambda x:x[1])\\n        visited=[[False for _ in range(len(grid[0]))] for __ in range(len(grid))]\\n        count=0\\n        ans=[0 for __ in range(len(q))]\\n        visited[0][0]=True\\n        it=0\\n        for item in q:\\n            l=[]\\n            while(not obj.empty()):\\n                val,i,j=obj.get()\\n                if(val>=item[1]):\\n                    obj.put([val,i,j])\\n                    break\\n                else:\\n                    count+=1\\n                    if(i+1<len(grid) and not visited[i+1][j]):\\n                        visited[i+1][j]=True\\n                        obj.put([grid[i+1][j],i+1,j])\\n                    if(j+1<len(grid[0]) and not visited[i][j+1]):\\n                        visited[i][j+1]=True\\n                        obj.put([grid[i][j+1],i,j+1])\\n                    if(i-1>=0 and not visited[i-1][j]):\\n                        visited[i-1][j]=True\\n                        obj.put([grid[i-1][j],i-1,j])\\n                    if(j-1>=0 and not visited[i][j-1]):\\n                        visited[i][j-1]=True\\n                        obj.put([grid[i][j-1],i,j-1])\\n            ans[item[0]]=count\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920883,
                "title": "bfs-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe naive approach to solve this problem is really simple. We can just apply a BFS for each of the queries given. But the time complexity will be O(n*m*q){this will give TLE}. So what we are doing in the naive approach , we are caluclating the answer for each and every query , but any larger query will include the answer of it\\'s smaller query also (think about it). So instead of calculating for each query sepearately , we will use the answer of previous query.\\n\\n# Approach\\nIt\\'s very much a BFS. It\\'s just that we will be using a priority queue instead of a normal queue cuz we want want to minimize our time finding the smallest value.\\nFirst we sort our query vector.\\nWe will maintain a min heap which will store three values (grid cell value,row,col). And a visited grid.\\n\\n# Complexity\\n- Time complexity:\\n(n*m*(log(n*m)))\\n\\n\\n\\n# Code\\n```\\n#define pii pair<int,pair<int,int>>\\nclass Solution {\\npublic:\\n\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        vector<int>res(queries.size(),0);\\n        vector<pair<int,int>>new_query(queries.size());\\n        for(int i=0;i<queries.size();++i){\\n            new_query[i]={queries[i],i};\\n        }\\n        sort(new_query.begin(),new_query.end());\\n        priority_queue<pii,vector<pii>,greater<pii>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        vis[0][0]=1;\\n\\n        int dx[4]={0,0,1,-1};\\n        int dy[4]={1,-1,0,0};\\n        int point=0;\\n        for(int ind=0;ind<new_query.size();++ind){\\n            int maxi=new_query[ind].first;\\n            int index=new_query[ind].second;\\n            \\n            while(!pq.empty() && pq.top().first<maxi){\\n                point++;\\n                int i=pq.top().second.first;\\n                int j=pq.top().second.second;\\n                pq.pop();\\n                for(int k=0;k<4;++k){\\n                    int ni=i+dx[k];\\n                    int nj=j+dy[k];\\n                    if(ni>=0 && ni<n && nj>=0 && nj<m && vis[ni][nj]==0){\\n                        pq.push({grid[ni][nj],{ni,nj}});\\n                        vis[ni][nj]=1;\\n                    }\\n                }\\n            }\\n            res[index]=point;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define pii pair<int,pair<int,int>>\\nclass Solution {\\npublic:\\n\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        vector<int>res(queries.size(),0);\\n        vector<pair<int,int>>new_query(queries.size());\\n        for(int i=0;i<queries.size();++i){\\n            new_query[i]={queries[i],i};\\n        }\\n        sort(new_query.begin(),new_query.end());\\n        priority_queue<pii,vector<pii>,greater<pii>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        vis[0][0]=1;\\n\\n        int dx[4]={0,0,1,-1};\\n        int dy[4]={1,-1,0,0};\\n        int point=0;\\n        for(int ind=0;ind<new_query.size();++ind){\\n            int maxi=new_query[ind].first;\\n            int index=new_query[ind].second;\\n            \\n            while(!pq.empty() && pq.top().first<maxi){\\n                point++;\\n                int i=pq.top().second.first;\\n                int j=pq.top().second.second;\\n                pq.pop();\\n                for(int k=0;k<4;++k){\\n                    int ni=i+dx[k];\\n                    int nj=j+dy[k];\\n                    if(ni>=0 && ni<n && nj>=0 && nj<m && vis[ni][nj]==0){\\n                        pq.push({grid[ni][nj],{ni,nj}});\\n                        vis[ni][nj]=1;\\n                    }\\n                }\\n            }\\n            res[index]=point;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920157,
                "title": "golang-bfs-with-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Golang implementation of https://leetcode.com/problems/maximum-number-of-points-from-grid-queries/solutions/2899363/preprocessing-by-bfs-with-priority-queue/\\n\\n# Complexity\\n- Time complexity: $$O(K + MN log(MN))$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(K + MN)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Qstate struct {\\n    q, i int\\n}\\n\\ntype Gstate struct {\\n    r, c, g int\\n}\\n\\ntype PQ []Gstate\\nfunc (pq PQ) Len() int { return len(pq) }\\nfunc (pq PQ) Less(i, j int) bool { return pq[i].g < pq[j].g }\\nfunc (pq PQ) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] }\\nfunc (pq PQ) Peek() interface{} { return pq[0]}\\nfunc (pq *PQ) Push(x interface{}) { *pq = append(*pq, x.(Gstate)) }\\nfunc (pq *PQ) Pop() interface{} {\\n\\tgState := (*pq)[len(*pq)-1]\\n    *pq = (*pq)[:len(*pq)-1]\\n\\treturn gState\\n}\\n\\nfunc maxPoints(grid [][]int, queries []int) []int {\\n    m, n := len(grid), len(grid[0])\\n    qLen := len(queries)\\n    qStates := make([]Qstate, qLen)\\n    for i := range queries {\\n        qStates[i] = Qstate{queries[i], i}\\n    }\\n    sort.Slice(qStates, func(i, j int) bool {\\n        return qStates[i].q < qStates[j].q\\n    })\\n\\n    pq := PQ{{0, 0, grid[0][0]}}\\n    heap.Init(&pq)\\n\\n    answers := make([]int, qLen)\\n    visited := make(map[Gstate]struct{})\\n    count := 0\\n    for _, qState := range qStates {\\n        for pq.Len() > 0 && pq.Peek().(Gstate).g < qState.q {\\n            gState := heap.Pop(&pq).(Gstate)\\n            if _, ok := visited[Gstate{gState.r, gState.c, 0}]; ok {\\n                continue\\n            }\\n            visited[Gstate{gState.r, gState.c, 0}] = struct{}{}\\n            count++\\n            for _, d := range [][]int{{1, 0}, {-1, 0}, {0, 1}, {0, -1}} {\\n                rr, cc := gState.r + d[0], gState.c + d[1]\\n                if rr < 0 || rr >= m || cc < 0 || cc >= n {\\n                    continue \\n                }\\n\\n                if _, ok := visited[Gstate{rr, cc, 0}]; ok {\\n                    continue\\n                }\\n\\n                heap.Push(&pq, Gstate{rr , cc, grid[rr][cc]})\\n            }\\n        }\\n        answers[qState.i] = count\\n    }\\n\\n    return answers\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Qstate struct {\\n    q, i int\\n}\\n\\ntype Gstate struct {\\n    r, c, g int\\n}\\n\\ntype PQ []Gstate\\nfunc (pq PQ) Len() int { return len(pq) }\\nfunc (pq PQ) Less(i, j int) bool { return pq[i].g < pq[j].g }\\nfunc (pq PQ) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] }\\nfunc (pq PQ) Peek() interface{} { return pq[0]}\\nfunc (pq *PQ) Push(x interface{}) { *pq = append(*pq, x.(Gstate)) }\\nfunc (pq *PQ) Pop() interface{} {\\n\\tgState := (*pq)[len(*pq)-1]\\n    *pq = (*pq)[:len(*pq)-1]\\n\\treturn gState\\n}\\n\\nfunc maxPoints(grid [][]int, queries []int) []int {\\n    m, n := len(grid), len(grid[0])\\n    qLen := len(queries)\\n    qStates := make([]Qstate, qLen)\\n    for i := range queries {\\n        qStates[i] = Qstate{queries[i], i}\\n    }\\n    sort.Slice(qStates, func(i, j int) bool {\\n        return qStates[i].q < qStates[j].q\\n    })\\n\\n    pq := PQ{{0, 0, grid[0][0]}}\\n    heap.Init(&pq)\\n\\n    answers := make([]int, qLen)\\n    visited := make(map[Gstate]struct{})\\n    count := 0\\n    for _, qState := range qStates {\\n        for pq.Len() > 0 && pq.Peek().(Gstate).g < qState.q {\\n            gState := heap.Pop(&pq).(Gstate)\\n            if _, ok := visited[Gstate{gState.r, gState.c, 0}]; ok {\\n                continue\\n            }\\n            visited[Gstate{gState.r, gState.c, 0}] = struct{}{}\\n            count++\\n            for _, d := range [][]int{{1, 0}, {-1, 0}, {0, 1}, {0, -1}} {\\n                rr, cc := gState.r + d[0], gState.c + d[1]\\n                if rr < 0 || rr >= m || cc < 0 || cc >= n {\\n                    continue \\n                }\\n\\n                if _, ok := visited[Gstate{rr, cc, 0}]; ok {\\n                    continue\\n                }\\n\\n                heap.Push(&pq, Gstate{rr , cc, grid[rr][cc]})\\n            }\\n        }\\n        answers[qState.i] = count\\n    }\\n\\n    return answers\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2919419,
                "title": "java-bfs-prefix-sum-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. We don\\'t need to carry out BFS for each and every query, there comes some overlaps\\n2. If for query `l` we traverse and find the points, we dont need start from begining when we process a query `> l`. \\n3. We do a BFS traversal in the order of increasing query values and spread the boundry with every subsequent query.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the queries\\n2. Maintain a Min Heap instead of standard queue for poping the greyed nodes, and poll the nodes which have smaller `grid` value in the position. Because to ensure all the nodes with value less than query are processed before moving to next greater query.\\n3. Iterate over all the sorted query and in every step check the top element value of priority queue with the query value.\\n4. After BFS interation in every step count the number of nodes visited and store it in the `prefixSumMap`\\n5. Final calculate the exact number of value for every query.\\n\\nNote: remove duplicate queries before sortig out them, as it creates a inconsistent `prefixSumMap`\\n\\n# Complexity\\n- Time complexity: $$O(MNlog(MN) + K)$$ Because as a whole we are doing a single BFS traversal with a retrival of node from priority queue\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(MN + K)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n\\n        Map<Integer, Integer> prefixSumMap = new HashMap<>();\\n        PriorityQueue<Tuple> pq = new PriorityQueue<Tuple>((Tuple a, Tuple b) -> a.val - b.val);\\n        int[] x = {1, 0, -1, 0};\\n        int[] y = {0, 1, 0, -1};\\n        \\n        int m = grid.length, n = grid[0].length;\\n        \\n        int[] auxQ = Arrays.stream(queries)\\n                                .boxed()\\n                                .collect(Collectors.toSet())\\n                                .stream()\\n                                .mapToInt(Integer::intValue)\\n                                .toArray();\\n        Arrays.sort(auxQ);\\n        int[][] vis = new int[m][n];\\n\\n        // BFS with boundary spreading\\n        \\n        pq.add(new Tuple(0, 0, grid[0][0]));\\n        for(int query: auxQ) {\\n            int count = 0;\\n            while(!pq.isEmpty()) {\\n                Tuple top = pq.peek();\\n                if(top.val >= query) break;\\n                pq.poll();\\n                vis[top.p][top.q] = 2;\\n                count++;\\n                for(int i = 0;i< 4;i++) {\\n                    int np = top.p + x[i], nq = top.q + y[i];\\n                    \\n                    if(0 <= np && np < m && 0 <= nq && nq < n && vis[np][nq] == 0) {\\n                        vis[np][nq] = 1;\\n                        pq.add(new Tuple(np, nq, grid[np][nq]));\\n                    }\\n                }\\n            }\\n            prefixSumMap.putIfAbsent(query, count);\\n        }\\n        \\n        for(int i = 1;i<auxQ.length;i++) prefixSumMap.put(auxQ[i], ansMap.get(auxQ[i]) + ansMap.get(auxQ[i-1]));\\n        \\n        int[] ans = new int[queries.length];\\n        \\n        for(int i = 0;i<queries.length;i++) ans[i] = prefixSumMap.getOrDefault(queries[i], 0);\\n        \\n        return ans;\\n    }\\n    \\n    \\n    class Tuple {\\n        int p,q,val;\\n        \\n        Tuple(int p, int q, int val) {\\n            this.p = p;this.q = q;this.val = val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n\\n        Map<Integer, Integer> prefixSumMap = new HashMap<>();\\n        PriorityQueue<Tuple> pq = new PriorityQueue<Tuple>((Tuple a, Tuple b) -> a.val - b.val);\\n        int[] x = {1, 0, -1, 0};\\n        int[] y = {0, 1, 0, -1};\\n        \\n        int m = grid.length, n = grid[0].length;\\n        \\n        int[] auxQ = Arrays.stream(queries)\\n                                .boxed()\\n                                .collect(Collectors.toSet())\\n                                .stream()\\n                                .mapToInt(Integer::intValue)\\n                                .toArray();\\n        Arrays.sort(auxQ);\\n        int[][] vis = new int[m][n];\\n\\n        // BFS with boundary spreading\\n        \\n        pq.add(new Tuple(0, 0, grid[0][0]));\\n        for(int query: auxQ) {\\n            int count = 0;\\n            while(!pq.isEmpty()) {\\n                Tuple top = pq.peek();\\n                if(top.val >= query) break;\\n                pq.poll();\\n                vis[top.p][top.q] = 2;\\n                count++;\\n                for(int i = 0;i< 4;i++) {\\n                    int np = top.p + x[i], nq = top.q + y[i];\\n                    \\n                    if(0 <= np && np < m && 0 <= nq && nq < n && vis[np][nq] == 0) {\\n                        vis[np][nq] = 1;\\n                        pq.add(new Tuple(np, nq, grid[np][nq]));\\n                    }\\n                }\\n            }\\n            prefixSumMap.putIfAbsent(query, count);\\n        }\\n        \\n        for(int i = 1;i<auxQ.length;i++) prefixSumMap.put(auxQ[i], ansMap.get(auxQ[i]) + ansMap.get(auxQ[i-1]));\\n        \\n        int[] ans = new int[queries.length];\\n        \\n        for(int i = 0;i<queries.length;i++) ans[i] = prefixSumMap.getOrDefault(queries[i], 0);\\n        \\n        return ans;\\n    }\\n    \\n    \\n    class Tuple {\\n        int p,q,val;\\n        \\n        Tuple(int p, int q, int val) {\\n            this.p = p;this.q = q;this.val = val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918440,
                "title": "java-heap",
                "content": "# Intuition\\nMy first idea was to do a BFS starting from the top left index for each query, and just store the results for that and return it.\\nThis involves a lot of duplicate checks, so we can cut this down significantly with some sort of memoization or lookup table.\\nThe way I accomplished this is creating a sorted \"scores\" array, where scores[i] is a 2 length int array of [max, count]. Max corresponds to the highest value contained in this lookup, and count is the number of indexes in grid that we can reach starting from the top left with that as the max.\\n\\n# Approach\\nUsing a PriorityQueue/Min Heap, we can \"flood fill\" the array via the lowest value indexes first.\\nI initialzed a Min Heap of 3 length int arrays[i, j, val] where i and j are the coordinates of the index in question and val is the value of that index. The heap is then sorted by index 2 (value) ascending so the lower values are top of the heap.\\nWe maintain 2 ints, a \"cur\" and \"count\" which are the current max value, and the current count of indexes that are equal to or less then that value.\\nPut our starting index in the heap (0, 0, grid[0][0]), and create a visited array so we don\\'t keep rechecking the same indexes, and mark 0,0 as visited.\\nNow we start the pathing while loop, we first check if the lowest value index in the heap is greater then our current max. If it is, we store our current [max, count] to the scores array, and then\\nuse this index\\'s value as the new max.\\nIncrement the count for each index we pass through, then add adjacent, non visited, indexes to our heap.\\nRepeat this until we\\'ve processed the entire array, then make sure to add the final max/count to the scores array after the loop has finished.\\n\\nNow, we have a SORTED scores array where scores[i] is [max, count], where max = highest value seen, and count is # of indexes we can reach from the top left with that being the max.\\nWe can use this to fill out our queries now, for queries[i] we find the highest score that has a max less then our query, and store that in our output array at that index.\\nTo do this, you can binary search the scores with each query, or (what I did) is make a copy of the query array, sort it, then use 2 pointers to slide over the sorted query and a scores array, then add the best score into a hash map for that query, then just iterate over the input query again and build the output with the map.\\n\\n# Complexity\\n- Time complexity:\\nn = grid.length, m = grid[0].length, q = queries.length:\\nBuilding data structures: O(nm)\\nSearching with heap: O(nm * log(nm)) since we do n*m offers/polls and each has a potential worst case of log(nm), depending on the layout of the grid we could get a heap size that scales close to nm.\\nDuplicating and sorting queries: O(q log q)\\nMapping, and building output: O(q)\\nSummed = O(nm + nmlog(nm) + qlogq + q), simplified to O(nm log nm + q log q).\\n\\n\\n- Space complexity:\\nn = grid.length, m = grid[0].length, q = queries.length:\\nVisited Array: O(nm)\\nScores Array, Worst Case O(nm)\\nHeap Size: Worst Case ~O(nm)\\nSorted Input O(q)\\nSummed = O(nm*3 + q), so O(nm+q)\\n\\n# Code\\n```\\n    // comments to my self during implementation:\\n// heap \"flood fill\" sorta solution?\\n// start with top left index in the heap\\n// we build a \"scores\" 2d array where scores[i] is a 2 length int array\\n// that contains [max, count]\\n// max is the highest value used in this flood fill, and count is the\\n// number of indexes in grid that we can hit with this flood fill\\nclass Solution {\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        // Initialize all our data structures:\\n            // Scores array to contain best scores for each max value\\n            // Dirs to more easily find adjacent cells\\n            // PriorityQueue \"heap\" to find lowest value adjacent cell\\n            // Boolean \"visited\" array to avoid double counting cells\\n        ArrayList<int[]> scores = new ArrayList<>();\\n        int[][] dirs = new int[][]{{1,0}, {-1, 0}, {0,1}, {0,-1}};\\n\\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a,b) -> a[2] - b[2]);\\n        heap.offer(new int[]{0, 0, grid[0][0]});\\n\\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        vis[0][0] = true;\\n\\n            // Start with max = 0 and count = 0 as a base\\n        int cur = 0;\\n        int count = 0;\\n\\n        while(!heap.isEmpty()){\\n                // If the lowest value in our heap is bigger then the current max,\\n                // then we add the current max/count to our scores array\\n            if(heap.peek()[2] > cur){\\n                scores.add(new int[]{cur, count});\\n                cur = heap.peek()[2];\\n            }\\n\\n            int i = heap.peek()[0];\\n            int j = heap.poll()[1];\\n            count++;\\n\\n                // Increment count, and add unvisited adjacent nodes\\n                // to our heap.\\n            for(int[] dir : dirs){\\n                int di = i + dir[0];\\n                int dj = j + dir[1];\\n                if(di < 0 || di >= grid.length || dj < 0 || dj >= grid[0].length) continue;\\n                if(vis[di][dj]) continue;\\n                vis[di][dj] = true;\\n                heap.offer(new int[]{di, dj, grid[di][dj]});\\n            }\\n        }\\n            // Add the \"total array\" max/count to our scores.\\n        scores.add(new int[]{cur, count});\\n\\n            // Deep copy and sort the input query array.\\n        int[] sortedInput = new int[queries.length];\\n        for(int i = 0; i < queries.length; i++) sortedInput[i] = queries[i];\\n        Arrays.sort(sortedInput);\\n\\n            // Build our map with keys for each query, where map[i]\\n            // is the best score with a max < i.\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int j = 0;\\n        for(int q : sortedInput){\\n            while(j < scores.size() && scores.get(j)[0] < q) j++;\\n            map.put(q, scores.get(j-1)[1]);\\n        }\\n\\n            // Build output array by querying our map for each value in queries.\\n        int[] res = new int[queries.length];\\n        for(int i = 0; i < queries.length; i++) res[i] = map.get(queries[i]);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    // comments to my self during implementation:\\n// heap \"flood fill\" sorta solution?\\n// start with top left index in the heap\\n// we build a \"scores\" 2d array where scores[i] is a 2 length int array\\n// that contains [max, count]\\n// max is the highest value used in this flood fill, and count is the\\n// number of indexes in grid that we can hit with this flood fill\\nclass Solution {\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        // Initialize all our data structures:\\n            // Scores array to contain best scores for each max value\\n            // Dirs to more easily find adjacent cells\\n            // PriorityQueue \"heap\" to find lowest value adjacent cell\\n            // Boolean \"visited\" array to avoid double counting cells\\n        ArrayList<int[]> scores = new ArrayList<>();\\n        int[][] dirs = new int[][]{{1,0}, {-1, 0}, {0,1}, {0,-1}};\\n\\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a,b) -> a[2] - b[2]);\\n        heap.offer(new int[]{0, 0, grid[0][0]});\\n\\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        vis[0][0] = true;\\n\\n            // Start with max = 0 and count = 0 as a base\\n        int cur = 0;\\n        int count = 0;\\n\\n        while(!heap.isEmpty()){\\n                // If the lowest value in our heap is bigger then the current max,\\n                // then we add the current max/count to our scores array\\n            if(heap.peek()[2] > cur){\\n                scores.add(new int[]{cur, count});\\n                cur = heap.peek()[2];\\n            }\\n\\n            int i = heap.peek()[0];\\n            int j = heap.poll()[1];\\n            count++;\\n\\n                // Increment count, and add unvisited adjacent nodes\\n                // to our heap.\\n            for(int[] dir : dirs){\\n                int di = i + dir[0];\\n                int dj = j + dir[1];\\n                if(di < 0 || di >= grid.length || dj < 0 || dj >= grid[0].length) continue;\\n                if(vis[di][dj]) continue;\\n                vis[di][dj] = true;\\n                heap.offer(new int[]{di, dj, grid[di][dj]});\\n            }\\n        }\\n            // Add the \"total array\" max/count to our scores.\\n        scores.add(new int[]{cur, count});\\n\\n            // Deep copy and sort the input query array.\\n        int[] sortedInput = new int[queries.length];\\n        for(int i = 0; i < queries.length; i++) sortedInput[i] = queries[i];\\n        Arrays.sort(sortedInput);\\n\\n            // Build our map with keys for each query, where map[i]\\n            // is the best score with a max < i.\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int j = 0;\\n        for(int q : sortedInput){\\n            while(j < scores.size() && scores.get(j)[0] < q) j++;\\n            map.put(q, scores.get(j-1)[1]);\\n        }\\n\\n            // Build output array by querying our map for each value in queries.\\n        int[] res = new int[queries.length];\\n        for(int i = 0; i < queries.length; i++) res[i] = map.get(queries[i]);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2915315,
                "title": "bfs-with-priority-queue-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nDo BFS and try to reach smaller element if possible and store all the elements in array to answer the query.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nWhile ding BFS look for smaller element which are reachable and store all the elements traversed order.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n * m) + O(q * log(q) )$$\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        \\n        \\n        List<Integer> traversedList = new ArrayList<>();\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        bfs(grid, 0,0,traversedList);\\n        \\n        int [] ans = new int[traversedList.size()];\\n        \\n        int s = traversedList.get(0);\\n        ans[0] = s;\\n        for(int i = 1; i < traversedList.size(); i++){\\n            ans[i] = Math.max(ans[i-1],traversedList.get(i));\\n        }\\n        int [] res = new int[queries.length];\\n        for(int q = 0; q < queries.length; q++){\\n\\n            Integer v = lowerBound(ans, queries[q]);\\n            res[q] = v;\\n        }\\n        return res;\\n        \\n    }\\n\\n    int lowerBound(int a[], int x) {\\n        int l=-1,r=a.length;\\n        while(l+1<r) {\\n            int m=(l+r)>>>1;\\n            if(a[m]>=x) r=m;\\n            else l=m;\\n        }\\n        return r;\\n    }\\n    \\n    \\n    void bfs(int [][] grid, int i,int j, List<Integer> traversedList){\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        boolean [][] visited = new boolean[n][m];\\n        \\n        PriorityQueue<Pair> queue = new PriorityQueue<>((a, b) -> a.val - b.val);\\n        queue.add(new Pair(grid[i][j], i, j));\\n        visited[i][j] = true;\\n        \\n        int [][] dirs = {{1, 0}, {-1, 0}, {0,1}, {0,-1}};\\n        while(!queue.isEmpty()){\\n            \\n            Pair idx = queue.poll();\\n            traversedList.add(grid[idx.i][idx.j]);\\n            \\n            for(int [] d : dirs){\\n                \\n                int ni = d[0] + idx.i;\\n                int nj = d[1] + idx.j;\\n                \\n                if(ni < 0 || ni > n-1 || nj < 0 || nj > m-1 || visited[ni][nj]) continue;\\n                \\n                visited[ni][nj] = true;\\n                queue.add(new Pair(grid[ni][nj], ni, nj));\\n            }\\n        }\\n    }\\n}\\n\\nclass Pair{\\n    \\n    public int val;\\n    public int i;\\n    public int j;\\n    \\n    Pair(int val, int i, int j){\\n        this.val = val;\\n        this.i = i;\\n        this.j = j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        \\n        \\n        List<Integer> traversedList = new ArrayList<>();\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        bfs(grid, 0,0,traversedList);\\n        \\n        int [] ans = new int[traversedList.size()];\\n        \\n        int s = traversedList.get(0);\\n        ans[0] = s;\\n        for(int i = 1; i < traversedList.size(); i++){\\n            ans[i] = Math.max(ans[i-1],traversedList.get(i));\\n        }\\n        int [] res = new int[queries.length];\\n        for(int q = 0; q < queries.length; q++){\\n\\n            Integer v = lowerBound(ans, queries[q]);\\n            res[q] = v;\\n        }\\n        return res;\\n        \\n    }\\n\\n    int lowerBound(int a[], int x) {\\n        int l=-1,r=a.length;\\n        while(l+1<r) {\\n            int m=(l+r)>>>1;\\n            if(a[m]>=x) r=m;\\n            else l=m;\\n        }\\n        return r;\\n    }\\n    \\n    \\n    void bfs(int [][] grid, int i,int j, List<Integer> traversedList){\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        boolean [][] visited = new boolean[n][m];\\n        \\n        PriorityQueue<Pair> queue = new PriorityQueue<>((a, b) -> a.val - b.val);\\n        queue.add(new Pair(grid[i][j], i, j));\\n        visited[i][j] = true;\\n        \\n        int [][] dirs = {{1, 0}, {-1, 0}, {0,1}, {0,-1}};\\n        while(!queue.isEmpty()){\\n            \\n            Pair idx = queue.poll();\\n            traversedList.add(grid[idx.i][idx.j]);\\n            \\n            for(int [] d : dirs){\\n                \\n                int ni = d[0] + idx.i;\\n                int nj = d[1] + idx.j;\\n                \\n                if(ni < 0 || ni > n-1 || nj < 0 || nj > m-1 || visited[ni][nj]) continue;\\n                \\n                visited[ni][nj] = true;\\n                queue.add(new Pair(grid[ni][nj], ni, nj));\\n            }\\n        }\\n    }\\n}\\n\\nclass Pair{\\n    \\n    public int val;\\n    public int i;\\n    public int j;\\n    \\n    Pair(int val, int i, int j){\\n        this.val = val;\\n        this.i = i;\\n        this.j = j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914295,
                "title": "sort-and-count-very-detailed",
                "content": "***If you find it helpful, do upvote : )***\\n\\n# Intuition\\nJust think how would you do it if only 1 query was there.\\n\\n# Approach\\n1. Make a new queries array of pair of (query,index). We do this because we are going to sort it and we need it\\'s index when generating the result.\\n2. Now sort this new_queries array.\\n    **Why?** Consider an example where you had 2 queries = `[7,3]`. Now wouldn\\'t all the values that are smaller than 3 also be smaller than 7. So if we find the answer for 3 using BFS, for seven we just have to continue our BFS forward. We will use heap/priority queue instead of queue so that we get the least value first. I hope all this made sense.\\n3. Now start your BFS for the 1st query.\\n4. Now pop from heap/priority queue.\\n5. Check if this value is greater or equal than the current query. \\n    - If yes, then BFS for this query is done. Assign value of points to result, push the popped val back to the heap and move to the next query.\\n    - If not, then increase points by 1, and check all 4 directions of this cell and add them to the heap.\\n6. We repeat this till either the heap becomes empty or we are done with all the queries.\\n7. **EDGE CASE ALERT!!!** What if heap becomes empty we haven\\'t processed all the queries. \\n    > Eg. `grid = [[5,5,5],[5,5,5],[5,5,5]]` and `queries = [1,2,3,4]`\\n    **When the first query will be executed we will visit all the cells and BFS will end. Answer for the rest of the queries will be same what it was for first query since we have sorted them. So just run a while loop and assign them the current points.**\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(KlogK) + O((M*N)log(M*N))$$ *for sorting and BFS(because we use heap and push pop for heap is log(N))*\\n\\n- Space complexity:\\n$$O(K)+O(M*N)$$ *for new_queries array and heap*\\n\\n    *where,\\nK -> number of queries\\nM -> rows in grid\\nN -> columns in grid*\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m,n = len(grid),len(grid[0])\\n        directions = [(1,0),(0,1),(-1,0),(0,-1)]\\n        new_queries = [(query,i) for i,query in enumerate(queries)]\\n        new_queries.sort()\\n        heap = []\\n        visited = set()\\n        heappush(heap,(grid[0][0],0,0))\\n        visited.add((0,0))\\n        res = [0]*len(queries)\\n\\n        cur_query = 0\\n        cur_points = 0\\n\\n        while heap and cur_query<len(queries):\\n            val,x,y = heappop(heap)\\n            if val >= new_queries[cur_query][0]:\\n                res[new_queries[cur_query][1]] = cur_points\\n                cur_query += 1\\n                heappush(heap,(val,x,y))\\n\\n            else:\\n                cur_points += 1\\n                for dx,dy in directions:\\n                    newx,newy = x+dx,y+dy\\n                    if 0<=newx<m and 0<=newy<n and (newx,newy) not in visited:\\n                        heappush(heap,(grid[newx][newy],newx,newy))\\n                        visited.add((newx,newy))\\n\\n        while cur_query<len(queries):\\n            res[new_queries[cur_query][1]] = cur_points\\n            cur_query+=1\\n        \\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m,n = len(grid),len(grid[0])\\n        directions = [(1,0),(0,1),(-1,0),(0,-1)]\\n        new_queries = [(query,i) for i,query in enumerate(queries)]\\n        new_queries.sort()\\n        heap = []\\n        visited = set()\\n        heappush(heap,(grid[0][0],0,0))\\n        visited.add((0,0))\\n        res = [0]*len(queries)\\n\\n        cur_query = 0\\n        cur_points = 0\\n\\n        while heap and cur_query<len(queries):\\n            val,x,y = heappop(heap)\\n            if val >= new_queries[cur_query][0]:\\n                res[new_queries[cur_query][1]] = cur_points\\n                cur_query += 1\\n                heappush(heap,(val,x,y))\\n\\n            else:\\n                cur_points += 1\\n                for dx,dy in directions:\\n                    newx,newy = x+dx,y+dy\\n                    if 0<=newx<m and 0<=newy<n and (newx,newy) not in visited:\\n                        heappush(heap,(grid[newx][newy],newx,newy))\\n                        visited.add((newx,newy))\\n\\n        while cur_query<len(queries):\\n            res[new_queries[cur_query][1]] = cur_points\\n            cur_query+=1\\n        \\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912237,
                "title": "clean-fast-python3-faster-than-95",
                "content": "The idea is to sort the queries and maintain a heap of cells we need to visit next, `border`. By processing queries in nondecreasing order, we can be sure that if query `i` can visit some cell, query `i+1` can definitely also visit that cell.\\n\\nWe start with the border simply containing the start cell, `(0, 0)`. We keep track of the minimum border value in the heap at all times, and we can continue to explore and add points so long as the current query value `q` is greater than the minimum in the heap. When we reach a point where the min border value is >= q, we can no longer expand any further from this point, so we record the points in `ans`, and move on to the next query value.\\n\\nTime Complexity: `O(M\\\\*N + KlogK + Klog(M\\\\*N))\\n\\nPlease upvote if it helps!\\n```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n\\t    R, C, K = len(grid), len(grid[0]), len(queries)\\n        NEIS = [(-1, 0), (0, -1), (0, 1), (1, 0)]\\n        seen = [[False] * C for _ in range(R)]\\n\\t\\tborder = [(grid[0][0], 0, 0)]\\n\\t\\tseen[0][0] = True\\n        ans = [0] * K\\n        points = 0\\n        \\n        for q, i in sorted((x, i) for i, x in enumerate(queries)):\\n            while border and border[0][0] < q:\\n                val, row, col = heapq.heappop(border)\\n                for r, c in NEIS:\\n                    if 0 <= row+r < R and 0 <= col+c < C and not seen[row+r][col+c]:\\n                        heapq.heappush(border, (grid[row+r][col+c], row+r, col+c))\\n                        seen[row+r][col+c] = True\\n                points += 1\\n            ans[i] = points\\n                        \\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "The idea is to sort the queries and maintain a heap of cells we need to visit next, `border`. By processing queries in nondecreasing order, we can be sure that if query `i` can visit some cell, query `i+1` can definitely also visit that cell.\\n\\nWe start with the border simply containing the start cell, `(0, 0)`. We keep track of the minimum border value in the heap at all times, and we can continue to explore and add points so long as the current query value `q` is greater than the minimum in the heap. When we reach a point where the min border value is >= q, we can no longer expand any further from this point, so we record the points in `ans`, and move on to the next query value.\\n\\nTime Complexity: `O(M\\\\*N + KlogK + Klog(M\\\\*N))\\n\\nPlease upvote if it helps!\\n```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n\\t    R, C, K = len(grid), len(grid[0]), len(queries)\\n        NEIS = [(-1, 0), (0, -1), (0, 1), (1, 0)]\\n        seen = [[False] * C for _ in range(R)]\\n\\t\\tborder = [(grid[0][0], 0, 0)]\\n\\t\\tseen[0][0] = True\\n        ans = [0] * K\\n        points = 0\\n        \\n        for q, i in sorted((x, i) for i, x in enumerate(queries)):\\n            while border and border[0][0] < q:\\n                val, row, col = heapq.heappop(border)\\n                for r, c in NEIS:\\n                    if 0 <= row+r < R and 0 <= col+c < C and not seen[row+r][col+c]:\\n                        heapq.heappush(border, (grid[row+r][col+c], row+r, col+c))\\n                        seen[row+r][col+c] = True\\n                points += 1\\n            ans[i] = points\\n                        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2911845,
                "title": "swift-cfbinaryheap-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPlease refer this\\nhttps://leetcode.com/problems/maximum-number-of-points-from-grid-queries/solutions/2899594/python-3-solution-with-explanation-heap-binary-search/?orderBy=most_votes\\n\\n# Approach\\nIt\\'s not easy to pass by Swift\\nI tried union&find solution\\nhttps://leetcode.com/problems/maximum-number-of-points-from-grid-queries/solutions/2899354/simple-solution-with-intuition-c-o-n-m-time-and-space/?orderBy=most_votes\\n\\nBut always TLE\\ncustom heap also can\\'t pass\\n\\nGuys use Swift in LeetCode must keep a CFBinaryHeap template in your local notebook...\\n\\n\\n# Code\\n```\\n/*\\n    BFS find best path in ascending order\\n    prefix count is the result\\n    122335517\\n         ^  \\n    [5, 6, 2]\\n */\\nimport CoreFoundation\\ntypealias Node = (value: Int, coordinates: [Int])\\n\\nclass Heap {\\n    typealias Element = Node\\n    var pointer = UnsafeMutablePointer<Element>.allocate(capacity: 1)\\n    \\n    deinit {\\n        pointer.deinitialize(count: 1)\\n        pointer.deallocate()\\n    }\\n\\n    lazy var binaryHeap: CFBinaryHeap = {\\n        var callbacks = CFBinaryHeapCallBacks()\\n        callbacks.compare = { (a, b, _) in\\n            let x: Element = a!.load(as: Element.self), y: Element = b!.load(as: Element.self)\\n            return x.value < y.value ? CFComparisonResult.compareLessThan : CFComparisonResult.compareGreaterThan\\n        }\\n        var heap = CFBinaryHeapCreate(nil, 0, &callbacks, nil)\\n        return heap!\\n    }()\\n\\n    var count: Int {\\n        CFBinaryHeapGetCount(binaryHeap)\\n    }\\n\\n    func append(_ element: Element) {\\n        pointer = UnsafeMutablePointer<Element>.allocate(capacity: 1)\\n        pointer.initialize(to: (element))\\n        CFBinaryHeapAddValue(binaryHeap, pointer)\\n    }\\n\\n    func pop() -> Element {\\n        let popped: Element = CFBinaryHeapGetMinimum(binaryHeap).load(as: Element.self)\\n        CFBinaryHeapRemoveMinimumValue(binaryHeap)\\n        return popped\\n    }\\n}\\n\\nclass Solution {\\n    let minHeap = Heap()\\n    \\n    func maxPoints(_ grid: [[Int]], _ queries: [Int]) -> [Int] {\\n        let getNeighbors: (_ piont: [Int]) -> [[Int]] = { point -> [[Int]] in\\n            [\\n                [point[0], point[1]+1],\\n                [point[0], point[1]-1],\\n                [point[0]+1, point[1]],\\n                [point[0]-1, point[1]]\\n            ].filter { 0..<grid.count ~= $0[0] && 0..<grid[0].count ~= $0[1] }\\n        }\\n        minHeap.append((value: grid[0][0], coordinates: [0, 0]))\\n        var order = [Int]()\\n        var visitedSet = Set<[Int]>()\\n        while minHeap.count > 0 {\\n            let next = minHeap.pop()\\n            guard !visitedSet.contains(next.coordinates) else {\\n                continue\\n            }\\n            visitedSet.insert(next.coordinates)\\n            getNeighbors(next.coordinates)\\n                .map { (value: grid[$0[0]][$0[1]], coordinates: $0) }\\n                .forEach {\\n                    minHeap.append($0)\\n                }\\n            order.append(next.value)\\n        }\\n        \\n        var result = Array(repeating: 0, count: queries.count)\\n        \\n        let sortedQueries = queries.enumerated().sorted { $0.element < $1.element }\\n        var count = 0\\n        for i in 0..<sortedQueries.count {\\n            let query = sortedQueries[i].element\\n            let index = sortedQueries[i].offset\\n            while count < order.count, order[count] < query {\\n                count += 1\\n            }\\n            result[index] = count\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/*\\n    BFS find best path in ascending order\\n    prefix count is the result\\n    122335517\\n         ^  \\n    [5, 6, 2]\\n */\\nimport CoreFoundation\\ntypealias Node = (value: Int, coordinates: [Int])\\n\\nclass Heap {\\n    typealias Element = Node\\n    var pointer = UnsafeMutablePointer<Element>.allocate(capacity: 1)\\n    \\n    deinit {\\n        pointer.deinitialize(count: 1)\\n        pointer.deallocate()\\n    }\\n\\n    lazy var binaryHeap: CFBinaryHeap = {\\n        var callbacks = CFBinaryHeapCallBacks()\\n        callbacks.compare = { (a, b, _) in\\n            let x: Element = a!.load(as: Element.self), y: Element = b!.load(as: Element.self)\\n            return x.value < y.value ? CFComparisonResult.compareLessThan : CFComparisonResult.compareGreaterThan\\n        }\\n        var heap = CFBinaryHeapCreate(nil, 0, &callbacks, nil)\\n        return heap!\\n    }()\\n\\n    var count: Int {\\n        CFBinaryHeapGetCount(binaryHeap)\\n    }\\n\\n    func append(_ element: Element) {\\n        pointer = UnsafeMutablePointer<Element>.allocate(capacity: 1)\\n        pointer.initialize(to: (element))\\n        CFBinaryHeapAddValue(binaryHeap, pointer)\\n    }\\n\\n    func pop() -> Element {\\n        let popped: Element = CFBinaryHeapGetMinimum(binaryHeap).load(as: Element.self)\\n        CFBinaryHeapRemoveMinimumValue(binaryHeap)\\n        return popped\\n    }\\n}\\n\\nclass Solution {\\n    let minHeap = Heap()\\n    \\n    func maxPoints(_ grid: [[Int]], _ queries: [Int]) -> [Int] {\\n        let getNeighbors: (_ piont: [Int]) -> [[Int]] = { point -> [[Int]] in\\n            [\\n                [point[0], point[1]+1],\\n                [point[0], point[1]-1],\\n                [point[0]+1, point[1]],\\n                [point[0]-1, point[1]]\\n            ].filter { 0..<grid.count ~= $0[0] && 0..<grid[0].count ~= $0[1] }\\n        }\\n        minHeap.append((value: grid[0][0], coordinates: [0, 0]))\\n        var order = [Int]()\\n        var visitedSet = Set<[Int]>()\\n        while minHeap.count > 0 {\\n            let next = minHeap.pop()\\n            guard !visitedSet.contains(next.coordinates) else {\\n                continue\\n            }\\n            visitedSet.insert(next.coordinates)\\n            getNeighbors(next.coordinates)\\n                .map { (value: grid[$0[0]][$0[1]], coordinates: $0) }\\n                .forEach {\\n                    minHeap.append($0)\\n                }\\n            order.append(next.value)\\n        }\\n        \\n        var result = Array(repeating: 0, count: queries.count)\\n        \\n        let sortedQueries = queries.enumerated().sorted { $0.element < $1.element }\\n        var count = 0\\n        for i in 0..<sortedQueries.count {\\n            let query = sortedQueries[i].element\\n            let index = sortedQueries[i].offset\\n            while count < order.count, order[count] < query {\\n                count += 1\\n            }\\n            result[index] = count\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2910586,
                "title": "c-just-use-min-heap-instead-queue-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& g, vector<int>& qw) {\\n        int n = g.size();\\n        int m = g[0].size();\\n        int sz = qw.size();\\n        vector<int>ans(sz,0);\\n        vector<pair<int,int>>p;\\n        // cout<<m*n;\\n        for(int i=0;i<qw.size();i++){\\n            p.push_back({qw[i],i});\\n        }\\n        \\n        sort(p.begin(),p.end());\\n        \\n        int dx[4] = {1,-1,0,0};\\n        int dy[4] = {0,0,1,-1};\\n       \\n        \\n        vector<vector<bool>>vis(n,vector<bool>(m,false));\\n        priority_queue< pair<int,pair<int,int>> , vector<pair<int,pair<int,int>> > , \\n        greater<pair<int,pair<int,int>>> >pq ;\\n        \\n        pq.push({g[0][0] , {0,0}});\\n        \\n        vis[0][0] = true;\\n        \\n        int total = 0 ; \\n        int curr=0;\\n        \\n       \\n        while(!pq.empty() ){\\n            \\n            pair<int,pair<int,int>>temp = pq.top(); pq.pop();\\n            \\n            int value = temp.first ; \\n            int x = temp.second.first; \\n            int y = temp.second.second;\\n            \\n            while(curr < sz && p[curr].first <= value){\\n                ans[p[curr].second]=total;\\n                curr++;\\n            }\\n            total++; \\n          \\n            if(curr>=sz)return ans;\\n            \\n            for(int k=0;k<4;k++){\\n                int nx=dx[k]+x;\\n                int ny=dy[k]+y;\\n                if(nx<0||ny<0||nx>=n||ny>=m||vis[nx][ny]==true)continue; \\n                pq.push({g[nx][ny] , {nx,ny}});\\n                vis[nx][ny]=true; \\n            }\\n            \\n           \\n        }\\n        if(curr < sz) {\\n            for(int i = curr; i < sz ; i++)\\n                ans[p[i].second]  = m*n ; \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& g, vector<int>& qw) {\\n        int n = g.size();\\n        int m = g[0].size();\\n        int sz = qw.size();\\n        vector<int>ans(sz,0);\\n        vector<pair<int,int>>p;\\n        // cout<<m*n;\\n        for(int i=0;i<qw.size();i++){\\n            p.push_back({qw[i],i}",
                "codeTag": "C++"
            },
            {
                "id": 2910008,
                "title": "java-simple-logic-using-priorityqueue-and-comparator-beats-83-bfs-dfs-together",
                "content": "# Code\\n```\\nclass pair{\\n    int x,y,val;\\n    pair(int x,int y,int val)\\n    {\\n        this.x=x;\\n        this.y=y;\\n        this.val=val;\\n    }\\n}\\nclass Solution {\\n    public int dfs(int i,int j,int [][]arr, int k,PriorityQueue<pair> p)\\n    {\\n        if(i<0||i>arr.length-1||j<0||j>=arr[0].length||arr[i][j]==Integer.MAX_VALUE)\\n        return 0;\\n        if(arr[i][j]>=k)\\n        {\\n            p.offer(new pair(i,j,arr[i][j]));\\n            return 0;\\n        }\\n        int sum=1;\\n        arr[i][j]=Integer.MAX_VALUE;\\n        sum+=dfs(i+1,j,arr,k,p)+dfs(i,j+1,arr,k,p)+dfs(i-1,j,arr,k,p)+dfs(i,j-1,arr,k,p);\\n        return sum;\\n}\\n\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        PriorityQueue<pair> p=new PriorityQueue<>((a,b)->a.val-b.val);\\n        p.offer(new pair(0,0,grid[0][0]));\\n        int qr[]=new int[queries.length];\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            qr[i]=queries[i];\\n        }\\n        Arrays.sort(qr); \\n        int fans[]=new int [qr.length];\\n        for(int i=0;i<qr.length&&!p.isEmpty();i++)    \\n        {\\n            pair pe=p.peek();\\n            int sum=0;\\n            while(!p.isEmpty()&&pe.val<qr[i])\\n            {\\n            p.poll();\\n            sum+=dfs(pe.x,pe.y,grid,qr[i],p);\\n            pe=p.peek();\\n            }\\n            fans[i]=sum;\\n        }\\n        HashMap<Integer,Integer> h=new HashMap<>();\\n        h.put(qr[0],fans[0]);\\n        for(int i=1;i<fans.length;i++)\\n        {\\n            fans[i]+=fans[i-1];\\n            h.put(qr[i],fans[i]);\\n        }\\n        for(int i=0;i<fans.length;i++)\\n        {\\n            fans[i]=h.get(queries[i]);\\n        }\\n        return fans;\\n    }\\n}\\n```\\nUpvote if you like\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sort",
                    "Depth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass pair{\\n    int x,y,val;\\n    pair(int x,int y,int val)\\n    {\\n        this.x=x;\\n        this.y=y;\\n        this.val=val;\\n    }\\n}\\nclass Solution {\\n    public int dfs(int i,int j,int [][]arr, int k,PriorityQueue<pair> p)\\n    {\\n        if(i<0||i>arr.length-1||j<0||j>=arr[0].length||arr[i][j]==Integer.MAX_VALUE)\\n        return 0;\\n        if(arr[i][j]>=k)\\n        {\\n            p.offer(new pair(i,j,arr[i][j]));\\n            return 0;\\n        }\\n        int sum=1;\\n        arr[i][j]=Integer.MAX_VALUE;\\n        sum+=dfs(i+1,j,arr,k,p)+dfs(i,j+1,arr,k,p)+dfs(i-1,j,arr,k,p)+dfs(i,j-1,arr,k,p);\\n        return sum;\\n}\\n\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        PriorityQueue<pair> p=new PriorityQueue<>((a,b)->a.val-b.val);\\n        p.offer(new pair(0,0,grid[0][0]));\\n        int qr[]=new int[queries.length];\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            qr[i]=queries[i];\\n        }\\n        Arrays.sort(qr); \\n        int fans[]=new int [qr.length];\\n        for(int i=0;i<qr.length&&!p.isEmpty();i++)    \\n        {\\n            pair pe=p.peek();\\n            int sum=0;\\n            while(!p.isEmpty()&&pe.val<qr[i])\\n            {\\n            p.poll();\\n            sum+=dfs(pe.x,pe.y,grid,qr[i],p);\\n            pe=p.peek();\\n            }\\n            fans[i]=sum;\\n        }\\n        HashMap<Integer,Integer> h=new HashMap<>();\\n        h.put(qr[0],fans[0]);\\n        for(int i=1;i<fans.length;i++)\\n        {\\n            fans[i]+=fans[i-1];\\n            h.put(qr[i],fans[i]);\\n        }\\n        for(int i=0;i<fans.length;i++)\\n        {\\n            fans[i]=h.get(queries[i]);\\n        }\\n        return fans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908353,
                "title": "java-bfs-priorityqueue-sort-queries-from-small-to-big",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O((2qlogq) + q + (m * n * log(m*n)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(m * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        \\n        int idx=0;\\n        List<Query> arr=new ArrayList<>();\\n\\n        for(int q: queries)\\n        {\\n            arr.add(new Query(idx++, q, -1));\\n        }\\n        idx=0;\\n        Collections.sort(arr, new Comp1());\\n        q=new PriorityQueue<>();\\n        vis=new HashSet<>();\\n\\n        q.add(new IJ(0, 0, grid[0][0]));\\n        vis.add(\"0_0\");\\n        \\n        int lastAns = 0;\\n        while(idx<arr.size())\\n        {\\n            Query thisQuery = arr.get(idx);\\n            thisQuery.ans = lastAns + bfs(grid, thisQuery.q);\\n            lastAns = thisQuery.ans;\\n            idx++;\\n        }\\n        Collections.sort(arr, new Comp2());\\n        idx=0;\\n        int[] ansArr=new int[arr.size()];\\n        for(Query ele: arr)\\n        {\\n            ansArr[idx++]=ele.ans;\\n        }\\n        \\n        return ansArr;\\n    }\\n    static HashSet<String> vis;\\n    static Queue<IJ> q;\\n    public int bfs(int[][] grid, int query)\\n    {\\n        int ans=0;\\n        int m = grid.length, n=grid[0].length;\\n        \\n        while(!q.isEmpty())\\n        {\\n            int sz=q.size();\\n            boolean nowBreak = false;\\n            while(sz-->0)\\n            {\\n                IJ rem=q.remove();\\n                int i=rem.I, j=rem.J;\\n                if(rem.val >= query)\\n                {\\n                    nowBreak = true;\\n                    q.add(rem);\\n                    break;\\n                }\\n                ans++;\\n            \\n                String downString = \"\"+(i+1)+\"_\"+j;\\n                String upString = \"\"+(i-1)+\"_\"+j;\\n                String leftString = \"\"+i+\"_\"+(j-1);\\n                String rightString = \"\"+i+\"_\"+(j+1);\\n                \\n                if(i+1<m && !vis.contains(downString))\\n                {\\n                    IJ down = new IJ(i+1, j, grid[i+1][j]);\\n                    q.add(down);\\n                    vis.add(downString);\\n                }  \\n                if(j+1<n && !vis.contains(rightString))\\n                {\\n                    IJ right = new IJ(i, j+1, grid[i][j+1]);\\n                    q.add(right);\\n                    vis.add(rightString);\\n                }      \\n                if(j-1>=0 && !vis.contains(leftString))\\n                {\\n                    IJ left = new IJ(i, j-1, grid[i][j-1]);\\n                    q.add(left);\\n                    vis.add(leftString);\\n                }\\n                if(i-1>=0 && !vis.contains(upString))\\n                {\\n                    IJ up = new IJ(i-1, j, grid[i-1][j]);\\n                    q.add(up);\\n                    vis.add(upString);\\n                }\\n            }\\n            if(nowBreak)\\n                break;\\n        }\\n        // System.out.println(q);\\n        // System.out.println(vis);\\n        return ans;\\n    }\\n}\\nclass IJ implements Comparable<IJ>\\n{\\n    int I;\\n    int J;\\n    int val;\\n        \\n    IJ(int I, int J, int val)\\n    {\\n        this.I=I;\\n        this.J=J;\\n        this.val=val;\\n    }\\n    public int compareTo(IJ o)\\n    {\\n        return this.val-o.val;\\n    }\\n    public String toString()\\n    {\\n        return I+\":\"+J;\\n    }\\n    \\n}\\nclass Query\\n{\\n    int idx;\\n    int q;\\n    int ans;\\n    \\n    Query(int I, int Q, int A)\\n    {\\n        idx=I;\\n        q=Q;\\n        ans=A;\\n    }\\n    public String toString()\\n    {\\n        return idx+\":\"+q+\":\"+ans;\\n    }\\n}\\nclass Comp1 implements Comparator<Query>\\n{\\n    public int compare(Query p1, Query p2)\\n    {\\n        if(p1.q!=p2.q) return p1.q-p2.q;\\n        else return p1.idx - p2.idx;\\n    }\\n}\\nclass Comp2 implements Comparator<Query>\\n{\\n    public int compare(Query p1, Query p2)\\n    {\\n        return p1.idx-p2.idx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        \\n        int idx=0;\\n        List<Query> arr=new ArrayList<>();\\n\\n        for(int q: queries)\\n        {\\n            arr.add(new Query(idx++, q, -1));\\n        }\\n        idx=0;\\n        Collections.sort(arr, new Comp1());\\n        q=new PriorityQueue<>();\\n        vis=new HashSet<>();\\n\\n        q.add(new IJ(0, 0, grid[0][0]));\\n        vis.add(\"0_0\");\\n        \\n        int lastAns = 0;\\n        while(idx<arr.size())\\n        {\\n            Query thisQuery = arr.get(idx);\\n            thisQuery.ans = lastAns + bfs(grid, thisQuery.q);\\n            lastAns = thisQuery.ans;\\n            idx++;\\n        }\\n        Collections.sort(arr, new Comp2());\\n        idx=0;\\n        int[] ansArr=new int[arr.size()];\\n        for(Query ele: arr)\\n        {\\n            ansArr[idx++]=ele.ans;\\n        }\\n        \\n        return ansArr;\\n    }\\n    static HashSet<String> vis;\\n    static Queue<IJ> q;\\n    public int bfs(int[][] grid, int query)\\n    {\\n        int ans=0;\\n        int m = grid.length, n=grid[0].length;\\n        \\n        while(!q.isEmpty())\\n        {\\n            int sz=q.size();\\n            boolean nowBreak = false;\\n            while(sz-->0)\\n            {\\n                IJ rem=q.remove();\\n                int i=rem.I, j=rem.J;\\n                if(rem.val >= query)\\n                {\\n                    nowBreak = true;\\n                    q.add(rem);\\n                    break;\\n                }\\n                ans++;\\n            \\n                String downString = \"\"+(i+1)+\"_\"+j;\\n                String upString = \"\"+(i-1)+\"_\"+j;\\n                String leftString = \"\"+i+\"_\"+(j-1);\\n                String rightString = \"\"+i+\"_\"+(j+1);\\n                \\n                if(i+1<m && !vis.contains(downString))\\n                {\\n                    IJ down = new IJ(i+1, j, grid[i+1][j]);\\n                    q.add(down);\\n                    vis.add(downString);\\n                }  \\n                if(j+1<n && !vis.contains(rightString))\\n                {\\n                    IJ right = new IJ(i, j+1, grid[i][j+1]);\\n                    q.add(right);\\n                    vis.add(rightString);\\n                }      \\n                if(j-1>=0 && !vis.contains(leftString))\\n                {\\n                    IJ left = new IJ(i, j-1, grid[i][j-1]);\\n                    q.add(left);\\n                    vis.add(leftString);\\n                }\\n                if(i-1>=0 && !vis.contains(upString))\\n                {\\n                    IJ up = new IJ(i-1, j, grid[i-1][j]);\\n                    q.add(up);\\n                    vis.add(upString);\\n                }\\n            }\\n            if(nowBreak)\\n                break;\\n        }\\n        // System.out.println(q);\\n        // System.out.println(vis);\\n        return ans;\\n    }\\n}\\nclass IJ implements Comparable<IJ>\\n{\\n    int I;\\n    int J;\\n    int val;\\n        \\n    IJ(int I, int J, int val)\\n    {\\n        this.I=I;\\n        this.J=J;\\n        this.val=val;\\n    }\\n    public int compareTo(IJ o)\\n    {\\n        return this.val-o.val;\\n    }\\n    public String toString()\\n    {\\n        return I+\":\"+J;\\n    }\\n    \\n}\\nclass Query\\n{\\n    int idx;\\n    int q;\\n    int ans;\\n    \\n    Query(int I, int Q, int A)\\n    {\\n        idx=I;\\n        q=Q;\\n        ans=A;\\n    }\\n    public String toString()\\n    {\\n        return idx+\":\"+q+\":\"+ans;\\n    }\\n}\\nclass Comp1 implements Comparator<Query>\\n{\\n    public int compare(Query p1, Query p2)\\n    {\\n        if(p1.q!=p2.q) return p1.q-p2.q;\\n        else return p1.idx - p2.idx;\\n    }\\n}\\nclass Comp2 implements Comparator<Query>\\n{\\n    public int compare(Query p1, Query p2)\\n    {\\n        return p1.idx-p2.idx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907443,
                "title": "c-bfs-with-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod =1000000007;\\n    int dx[4] = {1,0,-1,0};\\n    int dy[4] = {0,1,0,-1};\\n   \\n     bool isvalid(int x, int y, vector<vector<int>>&grid){\\n        if(x<0 or x>=grid.size() or y<0 or y>=grid[0].size()) return false;\\n        return true;\\n    }\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n   int n = grid.size(), m = grid[0].size(), curAns = 0;\\n        \\n        vector<pair<int, int>> qries;\\n        vector<int> ans(queries.size(), 0);\\n        vector<vector<bool>> vis(n, vector<bool> (m, false));\\n\\n        priority_queue< vector<int>, vector<vector<int>>, greater<vector<int>> > pq;\\n\\n        for(int i = 0; i < queries.size(); ++i) \\n            qries.push_back({queries[i], i});\\n             sort(begin(qries), end(qries));\\n \\n        pq.push({grid[0][0], 0, 0});  // starting node value, i, j\\n        vis[0][0] = true;\\n\\n        for(auto &p : qries) {\\n            int val = p.first, indx = p.second;\\n\\n            while(!pq.empty()) {\\n                auto v = pq.top();\\n                pq.pop();\\n                int curVal = v[0], x = v[1], y = v[2];\\n\\n                if(curVal >= val) {\\n                    pq.push(v);\\n                    break;\\n                }\\n                curAns++;\\n\\n                for(int i = 0; i < 4; ++i) {\\n                    int nx = x + dx[i];\\n                    int ny = y + dy[i];\\n\\n                    if(isvalid(nx, ny ,grid)&& !vis[nx][ny]) {\\n                        vis[nx][ny] = 1;\\n                        pq.push({grid[nx][ny], nx, ny});\\n                    }\\n                }\\n            }\\n            ans[indx] = curAns;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod =1000000007;\\n    int dx[4] = {1,0,-1,0};\\n    int dy[4] = {0,1,0,-1};\\n   \\n     bool isvalid(int x, int y, vector<vector<int>>&grid){\\n        if(x<0 or x>=grid.size() or y<0 or y>=grid[0].size()) return false;\\n        return true;\\n    }\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n   int n = grid.size(), m = grid[0].size(), curAns = 0;\\n        \\n        vector<pair<int, int>> qries;\\n        vector<int> ans(queries.size(), 0);\\n        vector<vector<bool>> vis(n, vector<bool> (m, false));\\n\\n        priority_queue< vector<int>, vector<vector<int>>, greater<vector<int>> > pq;\\n\\n        for(int i = 0; i < queries.size(); ++i) \\n            qries.push_back({queries[i], i});\\n             sort(begin(qries), end(qries));\\n \\n        pq.push({grid[0][0], 0, 0});  // starting node value, i, j\\n        vis[0][0] = true;\\n\\n        for(auto &p : qries) {\\n            int val = p.first, indx = p.second;\\n\\n            while(!pq.empty()) {\\n                auto v = pq.top();\\n                pq.pop();\\n                int curVal = v[0], x = v[1], y = v[2];\\n\\n                if(curVal >= val) {\\n                    pq.push(v);\\n                    break;\\n                }\\n                curAns++;\\n\\n                for(int i = 0; i < 4; ++i) {\\n                    int nx = x + dx[i];\\n                    int ny = y + dy[i];\\n\\n                    if(isvalid(nx, ny ,grid)&& !vis[nx][ny]) {\\n                        vis[nx][ny] = 1;\\n                        pq.push({grid[nx][ny], nx, ny});\\n                    }\\n                }\\n            }\\n            ans[indx] = curAns;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906990,
                "title": "java-intuitive-solution-bfs-and-priorityqueue-comments-added",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsince brute force is going to give TLE O(k * m * n), the first intutition is to find ovelapping subproblems. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the queries in increasing order and then find the result for smaller query to bigger query. \\n2. Below I have separately calculated the number of smaller grid[i][j] for every query using BFS and then after that added res[i-1] to every res[i], since every grid[i][j] smaller then newQ[i] will also be smaller than newQ[i+1].\\n3. finally returned the answer in correct order.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSince we are using BFS only once, the TC comes out to be O(k*log(k) + m*nlog(mn)). correct me if I am wrong.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        int k = queries.length;\\n        int res[] = new int[k];\\n\\n        int newQ[] = new int[k];\\n        Map<Integer, Integer> map = new HashMap();\\n        for(int i = 0; i < k; i++){\\n            newQ[i] = queries[i];\\n        }\\n\\n        //sorted new queries\\n        Arrays.sort(newQ);\\n\\n        // pq for BFS, we have sorted on the least index in newQ basis. means the grid[i][j] with smaller values\\n        // will be evaluated first. this is important otherwise it will lead to wrong result.\\n        PriorityQueue<int[]> q = new PriorityQueue<>((a,b) -> Integer.compare(a[2],b[2]));\\n\\n        // int[] = {i, j, index of newQ}\\n        q.add(new int[]{0, 0, 0});\\n\\n        boolean vis[][] = new boolean[grid.length][grid[0].length];\\n\\n        // BFS\\n        while(!q.isEmpty()){\\n            int temp[] = q.remove();\\n\\n            int i = temp[0], j = temp[1], idx = temp[2];\\n\\n            //check if i, j is out of bounds or not and is not visited\\n            if(!outOfBounds(i, j, grid.length, grid[0].length) && !vis[i][j]){\\n                \\n                //here we are checking for current grid[i][j] which query is greater and saving the index top idx\\n                // example grid[i][j] = 8, newQ = [4,6,8,9,10]\\n                // hence idx = 3 in above case\\n                while(idx < newQ.length && newQ[idx] <= grid[i][j])\\n                    idx++;\\n\\n                // if we dont find grid[i][j] < any query we move forward\\n                if(idx != newQ.length){\\n\\n                    // updating the count for that query\\n                    // res[i] measures how many grid[i][j] are smaller than any query, excluding the smaller queries\\n                    // example grid[i][j] = [[1,2], [3,4]]. newQ = [3,4]\\n                    // then res[] = [2, 1]. \\n                    res[idx]++;\\n\\n                    vis[i][j] = true;\\n\\n                    q.add(new int[]{i, j+1, idx});\\n                    q.add(new int[]{i+1, j, idx});\\n                    q.add(new int[]{i, j-1, idx});\\n                    q.add(new int[]{i-1, j, idx});\\n                }\\n\\n            }\\n        }\\n\\n        // we need to udpate all res[i] and add res[i-1] to them. \\n        map.put(newQ[0], res[0]);\\n        for(int i = 0; i < res.length-1; i++){\\n            if(newQ[i] == newQ[i+1]){\\n                res[i+1] = res[i];\\n            } else{\\n                res[i+1] += res[i];\\n            }\\n\\n            // for remembering the values since we need to shuffle them later for final result\\n            map.put(newQ[i+1], res[i+1]);\\n\\n        }\\n\\n\\n        int finalRes[] = new int[k];\\n        for(int i = 0; i <k; i++){\\n            finalRes[i] = map.getOrDefault(queries[i], 0);\\n        }\\n\\n        return finalRes;\\n        \\n    }\\n\\n    private boolean outOfBounds(int i, int j, int r, int c){\\n        if(i < 0 || i >= r || j < 0 || j >= c)\\n            return true;\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        int k = queries.length;\\n        int res[] = new int[k];\\n\\n        int newQ[] = new int[k];\\n        Map<Integer, Integer> map = new HashMap();\\n        for(int i = 0; i < k; i++){\\n            newQ[i] = queries[i];\\n        }\\n\\n        //sorted new queries\\n        Arrays.sort(newQ);\\n\\n        // pq for BFS, we have sorted on the least index in newQ basis. means the grid[i][j] with smaller values\\n        // will be evaluated first. this is important otherwise it will lead to wrong result.\\n        PriorityQueue<int[]> q = new PriorityQueue<>((a,b) -> Integer.compare(a[2],b[2]));\\n\\n        // int[] = {i, j, index of newQ}\\n        q.add(new int[]{0, 0, 0});\\n\\n        boolean vis[][] = new boolean[grid.length][grid[0].length];\\n\\n        // BFS\\n        while(!q.isEmpty()){\\n            int temp[] = q.remove();\\n\\n            int i = temp[0], j = temp[1], idx = temp[2];\\n\\n            //check if i, j is out of bounds or not and is not visited\\n            if(!outOfBounds(i, j, grid.length, grid[0].length) && !vis[i][j]){\\n                \\n                //here we are checking for current grid[i][j] which query is greater and saving the index top idx\\n                // example grid[i][j] = 8, newQ = [4,6,8,9,10]\\n                // hence idx = 3 in above case\\n                while(idx < newQ.length && newQ[idx] <= grid[i][j])\\n                    idx++;\\n\\n                // if we dont find grid[i][j] < any query we move forward\\n                if(idx != newQ.length){\\n\\n                    // updating the count for that query\\n                    // res[i] measures how many grid[i][j] are smaller than any query, excluding the smaller queries\\n                    // example grid[i][j] = [[1,2], [3,4]]. newQ = [3,4]\\n                    // then res[] = [2, 1]. \\n                    res[idx]++;\\n\\n                    vis[i][j] = true;\\n\\n                    q.add(new int[]{i, j+1, idx});\\n                    q.add(new int[]{i+1, j, idx});\\n                    q.add(new int[]{i, j-1, idx});\\n                    q.add(new int[]{i-1, j, idx});\\n                }\\n\\n            }\\n        }\\n\\n        // we need to udpate all res[i] and add res[i-1] to them. \\n        map.put(newQ[0], res[0]);\\n        for(int i = 0; i < res.length-1; i++){\\n            if(newQ[i] == newQ[i+1]){\\n                res[i+1] = res[i];\\n            } else{\\n                res[i+1] += res[i];\\n            }\\n\\n            // for remembering the values since we need to shuffle them later for final result\\n            map.put(newQ[i+1], res[i+1]);\\n\\n        }\\n\\n\\n        int finalRes[] = new int[k];\\n        for(int i = 0; i <k; i++){\\n            finalRes[i] = map.getOrDefault(queries[i], 0);\\n        }\\n\\n        return finalRes;\\n        \\n    }\\n\\n    private boolean outOfBounds(int i, int j, int r, int c){\\n        if(i < 0 || i >= r || j < 0 || j >= c)\\n            return true;\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906971,
                "title": "python3-o-mnlog-mn-progressively-build-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAll the point we get in one query in the number of position we can reach from (0, 0), this can be solved with union set.\\n\\nObivious, if the query value is no more than grid[0][0], the answer is 0. We sort all all in grid and quries, we we meet v in quries, we merge all neibor nodes in the grid. The answer is the union set size at 0.\\n\\n# Code\\n```\\nfrom itertools import product\\n\\nclass Uniset:\\n    def __init__(self, n):\\n        self.rep = list(range(n))\\n        self.sz = [1] * n\\n    \\n    def find(self, x):\\n        if self.rep[x] != x: self.rep[x] = self.find(self.rep[x])\\n        return self.rep[x]\\n    \\n    def merge(self, x, y):\\n        x, y = self.find(x), self.find(y)\\n        if x != y:\\n            x, y = min(x, y), max(x, y)\\n            self.rep[y] = x\\n            self.sz[x] += self.sz[y]\\n\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        sorted_grid = sorted((grid[r][c], r, c) for r, c in product(range(m), range(n)))\\n        ans = [0] * len(queries)\\n        queries = sorted((v, i) for i, v in enumerate(queries))\\n        idx, uni = 0, Uniset(m * n)\\n        for v, i in queries:\\n            if v <= grid[0][0]: continue\\n            while idx < m * n and sorted_grid[idx][0] < v:\\n                _, r, c = sorted_grid[idx]\\n                for nr, nc in [(r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1)]:\\n                    if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] < v: uni.merge(r * n + c, nr * n + nc)\\n                idx += 1\\n            ans[i] = uni.sz[0]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nfrom itertools import product\\n\\nclass Uniset:\\n    def __init__(self, n):\\n        self.rep = list(range(n))\\n        self.sz = [1] * n\\n    \\n    def find(self, x):\\n        if self.rep[x] != x: self.rep[x] = self.find(self.rep[x])\\n        return self.rep[x]\\n    \\n    def merge(self, x, y):\\n        x, y = self.find(x), self.find(y)\\n        if x != y:\\n            x, y = min(x, y), max(x, y)\\n            self.rep[y] = x\\n            self.sz[x] += self.sz[y]\\n\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        sorted_grid = sorted((grid[r][c], r, c) for r, c in product(range(m), range(n)))\\n        ans = [0] * len(queries)\\n        queries = sorted((v, i) for i, v in enumerate(queries))\\n        idx, uni = 0, Uniset(m * n)\\n        for v, i in queries:\\n            if v <= grid[0][0]: continue\\n            while idx < m * n and sorted_grid[idx][0] < v:\\n                _, r, c = sorted_grid[idx]\\n                for nr, nc in [(r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1)]:\\n                    if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] < v: uni.merge(r * n + c, nr * n + nc)\\n                idx += 1\\n            ans[i] = uni.sz[0]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906789,
                "title": "priority-queue-c-easy-to-understand",
                "content": "# Intuition\\n- Instead of solving this problem using matrix, it would be easier if we have a 1D vector\\n- We know that if the value of queries are higher, then it will cover more elements of the matrix, so it will be easier to solve the problem if we have sorted query vector\\n\\n# Approach\\n- We will create a 1D vector named ```itea``` which will store the order in which elements of matrix would be visited if we have a very large number in the ```queries[i]```. Using priority queue, we are able to do this.\\n- We also made two maps to mark the original position of ```queries[i-1]``` and then sort the query vector. After that we find the count of each ```queries[i-1]``` and using maps we can place the value in the right position\\n- We made a itr which corresponds to the the number of elements which we have visited till now and increasing the itr using the condition given in the question. Since the queries vector is sorted, therefore, for any new ```queries[i-1]``` all the values we have visited till now must be smaller than the current value.\\n\\n# Complexity\\n- Time complexity:\\n $$O(n*m)$$ \\n\\n- Space complexity:\\n $$O(n*m)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int n= grid.size();\\n        int m  = grid[0].size();\\n        unordered_map<int,int>mp;\\n        \\n        for(int i=1;i<=queries.size();i++){\\n            mp[i-1]=queries[i-1];\\n        }\\n        \\n        sort(queries.begin(),queries.end());\\n        \\n        vector<int>itea;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n        while(pq.size()>0){\\n            auto top = pq.top();\\n            pq.pop();\\n            itea.push_back(top.first);\\n            vis[top.second.first][top.second.second]=1;\\n            if(top.second.first-1>=0 &&vis[top.second.first-1][top.second.second]==0){\\n                vis[top.second.first-1][top.second.second]=1;\\n                pq.push({grid[top.second.first-1][top.second.second],{top.second.first-1,top.second.second}});\\n            }\\n            if(top.second.second-1>=0 &&vis[top.second.first][top.second.second-1]==0){\\n                vis[top.second.first][top.second.second-1]=1;\\n                pq.push({grid[top.second.first][top.second.second-1],{top.second.first,top.second.second-1}});\\n            }\\n            if(top.second.first+1<n &&vis[top.second.first+1][top.second.second]==0){\\n                vis[top.second.first+1][top.second.second]=1;\\n                pq.push({grid[top.second.first+1][top.second.second],{top.second.first+1,top.second.second}});\\n            }\\n            if(top.second.second+1<m &&vis[top.second.first][top.second.second+1]==0){\\n                vis[top.second.first][top.second.second+1]=1;\\n                pq.push({grid[top.second.first][top.second.second+1],{top.second.first,top.second.second+1}});\\n            }\\n        }\\n        int itr=0;\\n\\n        unordered_map<int,int>answer;\\n        queue<pair<int,int>>q;\\n      \\n        int count=0;\\n        for(auto i:queries){\\n            int z = i;\\n            \\n            if(answer.find(z)==answer.end()){\\n                while(itea[itr]<z &&itr<itea.size()) itr++ ;\\n                answer[z]=itr;\\n            }\\n            \\n        }\\n        \\n        vector<int>ans(queries.size());\\n        for(auto i:mp) ans[i.first]=answer[i.second];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```itea```\n```queries[i]```\n```queries[i-1]```\n```queries[i-1]```\n```queries[i-1]```\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int n= grid.size();\\n        int m  = grid[0].size();\\n        unordered_map<int,int>mp;\\n        \\n        for(int i=1;i<=queries.size();i++){\\n            mp[i-1]=queries[i-1];\\n        }\\n        \\n        sort(queries.begin(),queries.end());\\n        \\n        vector<int>itea;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n        while(pq.size()>0){\\n            auto top = pq.top();\\n            pq.pop();\\n            itea.push_back(top.first);\\n            vis[top.second.first][top.second.second]=1;\\n            if(top.second.first-1>=0 &&vis[top.second.first-1][top.second.second]==0){\\n                vis[top.second.first-1][top.second.second]=1;\\n                pq.push({grid[top.second.first-1][top.second.second],{top.second.first-1,top.second.second}});\\n            }\\n            if(top.second.second-1>=0 &&vis[top.second.first][top.second.second-1]==0){\\n                vis[top.second.first][top.second.second-1]=1;\\n                pq.push({grid[top.second.first][top.second.second-1],{top.second.first,top.second.second-1}});\\n            }\\n            if(top.second.first+1<n &&vis[top.second.first+1][top.second.second]==0){\\n                vis[top.second.first+1][top.second.second]=1;\\n                pq.push({grid[top.second.first+1][top.second.second],{top.second.first+1,top.second.second}});\\n            }\\n            if(top.second.second+1<m &&vis[top.second.first][top.second.second+1]==0){\\n                vis[top.second.first][top.second.second+1]=1;\\n                pq.push({grid[top.second.first][top.second.second+1],{top.second.first,top.second.second+1}});\\n            }\\n        }\\n        int itr=0;\\n\\n        unordered_map<int,int>answer;\\n        queue<pair<int,int>>q;\\n      \\n        int count=0;\\n        for(auto i:queries){\\n            int z = i;\\n            \\n            if(answer.find(z)==answer.end()){\\n                while(itea[itr]<z &&itr<itea.size()) itr++ ;\\n                answer[z]=itr;\\n            }\\n            \\n        }\\n        \\n        vector<int>ans(queries.size());\\n        for(auto i:mp) ans[i.first]=answer[i.second];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905620,
                "title": "javascript-solution-based-on-the-idea-from-changeme",
                "content": "# Intuition\\n<!-- Based on the idea from changeme, refre below link for his idea -->\\nhttps://leetcode.com/problems/maximum-number-of-points-from-grid-queries/solutions/2899384/java-bfs-o-min-m-n-klogk/\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Based on the idea from below post:\\n * https://leetcode.com/problems/maximum-number-of-points-from-grid-queries/solutions/2899384/java-bfs-o-min-r-c-klogk/\\n *\\n * @param {number[][]} grid\\n * @param {number[]} queries\\n * @return {number[]}\\n */\\nvar maxPoints = function (grid, queries) {\\n  const m = grid.length;\\n  const n = grid[0].length;\\n  const DIRS = [\\n    [0, 1],\\n    [0, -1],\\n    [-1, 0],\\n    [1, 0],\\n  ];\\n\\n  let sorted = queries.slice();\\n  sorted.sort((a, b) => a - b);\\n\\n  let memo = [];\\n  for (let i = 0; i < m; i++) memo.push(Array(n).fill(false));\\n  let map = new Map();\\n  let nextQueue = [[0, 0]];\\n  let prev;\\n  for (let k of sorted) {\\n    if (grid[0][0] >= k) {\\n      map.set(k, 0);\\n      continue;\\n    } else if (map.has(k)) continue;\\n\\n    // start bfs for get result of k\\n    let queue = nextQueue.slice();\\n    nextQueue = [];\\n    memo[0][0] = true;\\n    let val = 0;\\n    let idx = 0;\\n    while (idx < queue.length) {\\n      let [i, j] = queue[idx++];\\n      if (grid[i][j] >= k) {\\n        nextQueue.push([i, j]);\\n        continue;\\n      }\\n      val++;\\n      for (let dir of DIRS) {\\n        let nx = i + dir[0];\\n        let ny = j + dir[1];\\n        if (nx < 0 || nx >= m || ny < 0 || ny >= n || memo[nx][ny] === true)\\n          continue;\\n\\n        memo[nx][ny] = true;\\n        queue.push([nx, ny]);\\n      }\\n    }\\n    if (prev !== undefined) val += map.get(prev);\\n    map.set(k, val);\\n    prev = k;\\n  }\\n\\n  let ans = [];\\n  for (let q of queries) ans.push(map.get(q));\\n  return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Based on the idea from below post:\\n * https://leetcode.com/problems/maximum-number-of-points-from-grid-queries/solutions/2899384/java-bfs-o-min-r-c-klogk/\\n *\\n * @param {number[][]} grid\\n * @param {number[]} queries\\n * @return {number[]}\\n */\\nvar maxPoints = function (grid, queries) {\\n  const m = grid.length;\\n  const n = grid[0].length;\\n  const DIRS = [\\n    [0, 1],\\n    [0, -1],\\n    [-1, 0],\\n    [1, 0],\\n  ];\\n\\n  let sorted = queries.slice();\\n  sorted.sort((a, b) => a - b);\\n\\n  let memo = [];\\n  for (let i = 0; i < m; i++) memo.push(Array(n).fill(false));\\n  let map = new Map();\\n  let nextQueue = [[0, 0]];\\n  let prev;\\n  for (let k of sorted) {\\n    if (grid[0][0] >= k) {\\n      map.set(k, 0);\\n      continue;\\n    } else if (map.has(k)) continue;\\n\\n    // start bfs for get result of k\\n    let queue = nextQueue.slice();\\n    nextQueue = [];\\n    memo[0][0] = true;\\n    let val = 0;\\n    let idx = 0;\\n    while (idx < queue.length) {\\n      let [i, j] = queue[idx++];\\n      if (grid[i][j] >= k) {\\n        nextQueue.push([i, j]);\\n        continue;\\n      }\\n      val++;\\n      for (let dir of DIRS) {\\n        let nx = i + dir[0];\\n        let ny = j + dir[1];\\n        if (nx < 0 || nx >= m || ny < 0 || ny >= n || memo[nx][ny] === true)\\n          continue;\\n\\n        memo[nx][ny] = true;\\n        queue.push([nx, ny]);\\n      }\\n    }\\n    if (prev !== undefined) val += map.get(prev);\\n    map.set(k, val);\\n    prev = k;\\n  }\\n\\n  let ans = [];\\n  for (let q of queries) ans.push(map.get(q));\\n  return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2905349,
                "title": "90-in-time-100-in-space-easy-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- as normal bfs giving TLE ,we need to modify the bfs somehow.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- for each query we were visiting single cell for ultiple times.so in this approach we are eliminating mutiple time visiting for same cell.\\n- we will sort the queries and checking for it in increasing order.\\n- use priority queue (min heap) to store the cell values .we will poping out element while it is less then current query value.and increamenting the count for it.\\n- once it is greater then query we will not further checking (because priority queue min heap stores min element at top and rest of all will be greater then it)hence our operations has been reduced.\\n- once we went outside from while loop we can store count for perticular query in our vector.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nm*log(nm))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(nm)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        vector<int>v(queries.size() , 0);\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int dr[] = {-1 , 0 , 1 , 0};\\n        int dc[] = {0 , 1 , 0 , -1};\\n\\n        vector<pair<int,int>>qua;\\n        \\n        for(int i=0;i<queries.size();i++){\\n            qua.push_back({queries[i] , i});\\n        }\\n\\n        sort(qua.begin() , qua.end());\\n\\n        priority_queue<pair<long long , pair<long long , long long>> , vector<pair<long long , pair<long long , long long>>> , greater<pair<long long , pair<long long , long long>>>>q;\\n            q.push({grid[0][0] , {0,0}});\\n            \\n            vector<vector<int>>vis(grid.size() , vector<int>(grid[0].size() , 0));\\n            vis[0][0] = 1;\\n            long long cnt = 0;\\n\\n        for(int it=0;it<qua.size();it++){\\n            long long qr = qua[it].first;\\n            long long ind = qua[it].second;\\n              \\n            while(!q.empty() && q.top().first < qr){\\n                long long val = q.top().first;\\n                long long r = q.top().second.first;\\n                long long c = q.top().second.second;\\n                q.pop();\\n                cnt++;\\n\\n                for(int i=0;i<4;i++){\\n                    long long nr = r + dr[i];\\n                    long long nc = c + dc[i];\\n                    \\n                    if(nr < n && nc < m && nr >=0 && nc>=0 && !vis[nr][nc]){\\n                        vis[nr][nc] = 1;\\n                        q.push({grid[nr][nc] , {nr , nc}});\\n                    }\\n                }      \\n            }\\n            v[ind] = cnt;         \\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Heap (Priority Queue)",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        vector<int>v(queries.size() , 0);\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int dr[] = {-1 , 0 , 1 , 0};\\n        int dc[] = {0 , 1 , 0 , -1};\\n\\n        vector<pair<int,int>>qua;\\n        \\n        for(int i=0;i<queries.size();i++){\\n            qua.push_back({queries[i] , i});\\n        }\\n\\n        sort(qua.begin() , qua.end());\\n\\n        priority_queue<pair<long long , pair<long long , long long>> , vector<pair<long long , pair<long long , long long>>> , greater<pair<long long , pair<long long , long long>>>>q;\\n            q.push({grid[0][0] , {0,0}});\\n            \\n            vector<vector<int>>vis(grid.size() , vector<int>(grid[0].size() , 0));\\n            vis[0][0] = 1;\\n            long long cnt = 0;\\n\\n        for(int it=0;it<qua.size();it++){\\n            long long qr = qua[it].first;\\n            long long ind = qua[it].second;\\n              \\n            while(!q.empty() && q.top().first < qr){\\n                long long val = q.top().first;\\n                long long r = q.top().second.first;\\n                long long c = q.top().second.second;\\n                q.pop();\\n                cnt++;\\n\\n                for(int i=0;i<4;i++){\\n                    long long nr = r + dr[i];\\n                    long long nc = c + dc[i];\\n                    \\n                    if(nr < n && nc < m && nr >=0 && nc>=0 && !vis[nr][nc]){\\n                        vis[nr][nc] = 1;\\n                        q.push({grid[nr][nc] , {nr , nc}});\\n                    }\\n                }      \\n            }\\n            v[ind] = cnt;         \\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904299,
                "title": "c-bfs-with-heap-visiting-only-necessary-cells-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    struct Node{\\n        int i, j, v;\\n        bool operator<(const Node& r) const {\\n            return v > r.v;\\n        }\\n    };\\n\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int k = queries.size();\\n        vector<int> answers(k);\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<pair<int, int>> q;\\n        for (int i = 0; i < k; ++i) {\\n            q.emplace_back(queries[i], i);\\n        }\\n        sort(q.begin(), q.end(), [](const pair<int, int>& l, const pair<int, int>& r){ return l.first < r.first;});\\n\\n        int cnt = 0;\\n        priority_queue<Node> p;\\n        p.push(Node{0, 0, grid[0][0]});\\n        grid[0][0] *= -1;  // mark as visited\\n        for (auto pii : q) {\\n            while (!p.empty() && p.top().v < pii.first) {\\n                Node base = p.top();\\n                p.pop();\\n                ++cnt;\\n                static const vector<pair<int,int>> steps{{0,1}, {0, -1}, {1, 0}, {-1, 0}};\\n                for (auto d : steps) {\\n                    int x = base.i + d.first;\\n                    int y = base.j + d.second;\\n                    if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] > 0) {\\n                        p.push(Node{x, y, grid[x][y]});\\n                        grid[x][y] *= -1;\\n                    }\\n                }\\n            }\\n            answers[pii.second] = cnt;\\n        }\\n        return answers;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    struct Node{\\n        int i, j, v;\\n        bool operator<(const Node& r) const {\\n            return v > r.v;\\n        }\\n    };\\n\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int k = queries.size();\\n        vector<int> answers(k);\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<pair<int, int>> q;\\n        for (int i = 0; i < k; ++i) {\\n            q.emplace_back(queries[i], i);\\n        }\\n        sort(q.begin(), q.end(), [](const pair<int, int>& l, const pair<int, int>& r){ return l.first < r.first;});\\n\\n        int cnt = 0;\\n        priority_queue<Node> p;\\n        p.push(Node{0, 0, grid[0][0]});\\n        grid[0][0] *= -1;  // mark as visited\\n        for (auto pii : q) {\\n            while (!p.empty() && p.top().v < pii.first) {\\n                Node base = p.top();\\n                p.pop();\\n                ++cnt;\\n                static const vector<pair<int,int>> steps{{0,1}, {0, -1}, {1, 0}, {-1, 0}};\\n                for (auto d : steps) {\\n                    int x = base.i + d.first;\\n                    int y = base.j + d.second;\\n                    if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] > 0) {\\n                        p.push(Node{x, y, grid[x][y]});\\n                        grid[x][y] *= -1;\\n                    }\\n                }\\n            }\\n            answers[pii.second] = cnt;\\n        }\\n        return answers;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904125,
                "title": "djikstra-kind-heap-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor a given query num, ans would be the no. of cells that can contribute this num.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake: Current cell: **A**(5) and Neighbouring ceil: **B**(8)\\nA thinks that it can contribute to the numbers >= 6 and says to B,\\nbut B knows that it can only contribute to the number >= 9, so we mark B\\'s contribution starts from 9......and traversal goes....\\n\\nTo optimise the traversal, at each step, take the cell which has minimum contribution....like we do in djikstra algo.\\n\\n\\nTo answer a query num, contribute[1..num] gives the ans...so take a prefix sum.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        rows,cols = len(grid),len(grid[0])\\n        highest = 10**6\\n        contribute = [[highest for c in range(cols)] for r in range(rows)]\\n        def safe(i,j):\\n            return 0<=i<rows and 0<=j<cols\\n        # def start(i,j,can_contribute): TLE\\n        #     if not safe(i,j):\\n        #         return\\n        #     can_contribute = max(can_contribute, grid[i][j]+1)\\n        #     if can_contribute >= contribute[i][j]:\\n        #         return\\n        #     contribute[i][j] = can_contribute\\n        #     start(i+1,j,can_contribute)\\n        #     start(i-1,j,can_contribute)\\n        #     start(i,j+1,can_contribute)\\n        #     start(i,j-1,can_contribute)\\n        # start(0,0,0)\\n        contribute[0][0] = grid[0][0]+1\\n        heap = [(contribute[0][0],(0,0))]\\n        while heap:\\n            c,(i,j) = heappop(heap)\\n            for dx,dy in [(0,1),(0,-1),(1,0),(-1,0)]:\\n                x,y = i+dx,j+dy\\n                if not safe(x,y):\\n                    continue\\n                can_contribute = max(c, grid[x][y]+1)\\n                if can_contribute >= contribute[x][y]:\\n                    continue\\n                contribute[x][y] = can_contribute\\n                heappush(heap, (can_contribute,(x,y)))\\n        prefix=[0]*(highest+1)\\n        for r in range(rows):\\n            for c in range(cols):\\n                prefix[contribute[r][c]]+=1\\n        for ind in range(1,highest+1):\\n            prefix[ind]+=prefix[ind-1]\\n        for c in contribute:\\n            print(c)\\n        ans = list(map(lambda q: prefix[q],queries))\\n        return ans\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        rows,cols = len(grid),len(grid[0])\\n        highest = 10**6\\n        contribute = [[highest for c in range(cols)] for r in range(rows)]\\n        def safe(i,j):\\n            return 0<=i<rows and 0<=j<cols\\n        # def start(i,j,can_contribute): TLE\\n        #     if not safe(i,j):\\n        #         return\\n        #     can_contribute = max(can_contribute, grid[i][j]+1)\\n        #     if can_contribute >= contribute[i][j]:\\n        #         return\\n        #     contribute[i][j] = can_contribute\\n        #     start(i+1,j,can_contribute)\\n        #     start(i-1,j,can_contribute)\\n        #     start(i,j+1,can_contribute)\\n        #     start(i,j-1,can_contribute)\\n        # start(0,0,0)\\n        contribute[0][0] = grid[0][0]+1\\n        heap = [(contribute[0][0],(0,0))]\\n        while heap:\\n            c,(i,j) = heappop(heap)\\n            for dx,dy in [(0,1),(0,-1),(1,0),(-1,0)]:\\n                x,y = i+dx,j+dy\\n                if not safe(x,y):\\n                    continue\\n                can_contribute = max(c, grid[x][y]+1)\\n                if can_contribute >= contribute[x][y]:\\n                    continue\\n                contribute[x][y] = can_contribute\\n                heappush(heap, (can_contribute,(x,y)))\\n        prefix=[0]*(highest+1)\\n        for r in range(rows):\\n            for c in range(cols):\\n                prefix[contribute[r][c]]+=1\\n        for ind in range(1,highest+1):\\n            prefix[ind]+=prefix[ind-1]\\n        for c in contribute:\\n            print(c)\\n        ans = list(map(lambda q: prefix[q],queries))\\n        return ans\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904017,
                "title": "java-one-of-the-easiest-solution-with-explanation-bruteforce-to-opt",
                "content": "**Brute Force**\\n```\\nstatic class Pair {\\n        int x;\\n        int y;\\n\\n        public Pair(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n\\n    public static int[] maxPoints(int[][] grid, int[] queries) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        boolean[][] vis = new boolean[n][m];\\n        int[] result = new int[queries.length];\\n        Queue<Pair> pq = new LinkedList<>();\\n        int index = 0;\\n        for (int i = 0; i < queries.length; i++) {\\n            int num = queries[i];\\n            pq.offer(new Pair(0, 0));\\n            vis[0][0] = true;\\n            int count = 0;\\n            while (!pq.isEmpty()) {\\n                Pair pair = pq.poll();\\n                int x = pair.x;\\n                int y = pair.y;\\n                if (grid[x][y] < num) {\\n                    count++;\\n                    int[] xcor = {1, -1, 0, 0};\\n                    int[] ycor = {0, 0, 1, -1};\\n                    for (int j = 0; j < 4; j++) {\\n                        int xtemp = xcor[j] + x;\\n                        int ytemp = ycor[j] + y;\\n                        if (xtemp >= 0 && xtemp < n && ytemp >= 0 && ytemp < m && grid[xtemp][ytemp] < num && !vis[xtemp][ytemp]) {\\n                            pq.offer(new Pair(xtemp, ytemp));\\n                            vis[xtemp][ytemp] = true;\\n                        }\\n                    }\\n                }\\n\\n            }\\n            result[index++] = count;\\n            vis = new boolean[n][m];\\n        }\\n        return result;\\n    }\\n```\\n\\nTC - (n*m*que.length) hence TLE\\n\\n**Optimised**\\n```\\nstatic class Node {\\n        int val;\\n        int x;\\n        int y;\\n\\n        public Node(int val, int x, int y) {\\n            this.val = val;\\n            this.x = x;\\n            this.y = y;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"Node{\" +\\n                    \"val=\" + val +\\n                    \", x=\" + x +\\n                    \", y=\" + y +\\n                    \\'}\\';\\n        }\\n    }\\n\\n    public static int[] maxPointsOpt(int[][] grid, int[] queries) {\\n        int len = queries.length;\\n        //0 is val, and 1 is index\\n        int[][] temp = new int[len][2];\\n        for (int i = 0; i < len; i++) {\\n            temp[i][0] = queries[i];\\n            temp[i][1] = i;\\n        }\\n        int[] result = new int[len];\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        Arrays.sort(temp, (a, b) -> a[0] - b[0]);\\n\\n        Queue<Node> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\\n        boolean[][] vis = new boolean[n][m];\\n        pq.offer(new Node(grid[0][0], 0, 0));\\n        vis[0][0] = true;\\n        int[] xcor = {1,-1,0,0};\\n        int[] ycor = {0,0,-1,1};\\n        int point = 0;\\n        for (int i = 0; i < len; i++) {\\n            int max_value = temp[i][0];\\n            int ind = temp[i][1];\\n            while (!pq.isEmpty() && pq.peek().val < max_value) {\\n                Node node = pq.poll();\\n                point++;\\n                for (int j = 0; j < 4; j++) {\\n                    int xtemp = xcor[j] + node.x;\\n                    int ytemp = ycor[j] + node.y;\\n                    boolean isValid = (xtemp >=0 && xtemp < n) && (ytemp >=0 && ytemp < m);\\n                    if(!isValid || vis[xtemp][ytemp]) continue;\\n                    vis[xtemp][ytemp] = true;\\n                    pq.offer(new Node(grid[xtemp][ytemp], xtemp, ytemp));\\n                }\\n            }\\n            result[ind] = point;\\n        }\\n        return result;\\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nstatic class Pair {\\n        int x;\\n        int y;\\n\\n        public Pair(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n\\n    public static int[] maxPoints(int[][] grid, int[] queries) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        boolean[][] vis = new boolean[n][m];\\n        int[] result = new int[queries.length];\\n        Queue<Pair> pq = new LinkedList<>();\\n        int index = 0;\\n        for (int i = 0; i < queries.length; i++) {\\n            int num = queries[i];\\n            pq.offer(new Pair(0, 0));\\n            vis[0][0] = true;\\n            int count = 0;\\n            while (!pq.isEmpty()) {\\n                Pair pair = pq.poll();\\n                int x = pair.x;\\n                int y = pair.y;\\n                if (grid[x][y] < num) {\\n                    count++;\\n                    int[] xcor = {1, -1, 0, 0};\\n                    int[] ycor = {0, 0, 1, -1};\\n                    for (int j = 0; j < 4; j++) {\\n                        int xtemp = xcor[j] + x;\\n                        int ytemp = ycor[j] + y;\\n                        if (xtemp >= 0 && xtemp < n && ytemp >= 0 && ytemp < m && grid[xtemp][ytemp] < num && !vis[xtemp][ytemp]) {\\n                            pq.offer(new Pair(xtemp, ytemp));\\n                            vis[xtemp][ytemp] = true;\\n                        }\\n                    }\\n                }\\n\\n            }\\n            result[index++] = count;\\n            vis = new boolean[n][m];\\n        }\\n        return result;\\n    }\\n```\n```\\nstatic class Node {\\n        int val;\\n        int x;\\n        int y;\\n\\n        public Node(int val, int x, int y) {\\n            this.val = val;\\n            this.x = x;\\n            this.y = y;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"Node{\" +\\n                    \"val=\" + val +\\n                    \", x=\" + x +\\n                    \", y=\" + y +\\n                    \\'}\\';\\n        }\\n    }\\n\\n    public static int[] maxPointsOpt(int[][] grid, int[] queries) {\\n        int len = queries.length;\\n        //0 is val, and 1 is index\\n        int[][] temp = new int[len][2];\\n        for (int i = 0; i < len; i++) {\\n            temp[i][0] = queries[i];\\n            temp[i][1] = i;\\n        }\\n        int[] result = new int[len];\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        Arrays.sort(temp, (a, b) -> a[0] - b[0]);\\n\\n        Queue<Node> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\\n        boolean[][] vis = new boolean[n][m];\\n        pq.offer(new Node(grid[0][0], 0, 0));\\n        vis[0][0] = true;\\n        int[] xcor = {1,-1,0,0};\\n        int[] ycor = {0,0,-1,1};\\n        int point = 0;\\n        for (int i = 0; i < len; i++) {\\n            int max_value = temp[i][0];\\n            int ind = temp[i][1];\\n            while (!pq.isEmpty() && pq.peek().val < max_value) {\\n                Node node = pq.poll();\\n                point++;\\n                for (int j = 0; j < 4; j++) {\\n                    int xtemp = xcor[j] + node.x;\\n                    int ytemp = ycor[j] + node.y;\\n                    boolean isValid = (xtemp >=0 && xtemp < n) && (ytemp >=0 && ytemp < m);\\n                    if(!isValid || vis[xtemp][ytemp]) continue;\\n                    vis[xtemp][ytemp] = true;\\n                    pq.offer(new Node(grid[xtemp][ytemp], xtemp, ytemp));\\n                }\\n            }\\n            result[ind] = point;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903957,
                "title": "java-solution-bfs-priorityqueue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(K+MNlog(MN))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(MN)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n    class Solution {\\n        class Node {\\n            int ij;\\n            int val;\\n\\n            Node(int i, int j, int val) {\\n                this.ij = i * 100000 + j;\\n                this.val = val;\\n            }\\n        }\\n\\n        public int[] maxPoints(int[][] grid, int[] queries) {\\n            Set<Integer> chk = new HashSet<>(); // points visited\\n            Map<Integer, Node> map = new HashMap<>();\\n            int max = 0;\\n            for (int i = 0; i < grid.length; i++) {\\n                for (int j = 0; j < grid[0].length; j++) {\\n                    map.put(i * 100000 + j, new Node(i, j, grid[i][j]));\\n                    max = Math.max(max, grid[i][j]);\\n                }\\n            }\\n            int[] cnts = new int[max];\\n            PriorityQueue<Node> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a.val));\\n            pq.offer(map.get(0));\\n            chk.add(0);\\n            for (int i = 1; i <= max; i++) {\\n                cnts[i] = cnts[i - 1];\\n                if (pq.isEmpty() || i > pq.peek().val) continue;\\n                while (!pq.isEmpty() && pq.peek().val <= i) {\\n                    Node node = pq.poll();\\n                    cnts[i]++;\\n                    if (map.containsKey(node.ij - 1) && !chk.contains(node.ij - 1)) { // left\\n                        pq.offer(map.get(node.ij - 1));\\n                        chk.add(node.ij - 1);\\n                    }\\n                    if (map.containsKey(node.ij + 1) && !chk.contains(node.ij + 1)) { // right\\n                        pq.offer(map.get(node.ij + 1));\\n                        chk.add(node.ij + 1);\\n                    }\\n                    if (map.containsKey(node.ij - 100000) && !chk.contains(node.ij - 100000)) { // top\\n                        pq.offer(map.get(node.ij - 100000));\\n                        chk.add(node.ij - 100000);\\n                    }\\n                    if (map.containsKey(node.ij + 100000) && !chk.contains(node.ij + 100000)) { // down\\n                        pq.offer(map.get(node.ij + 100000));\\n                        chk.add(node.ij + 100000);\\n                    }\\n                }\\n            }\\n            int[] rst = new int[queries.length];\\n            for (int i = 0; i < queries.length; i++) rst[i] = cnts[queries[i] - 1];\\n            return rst;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    class Solution {\\n        class Node {\\n            int ij;\\n            int val;\\n\\n            Node(int i, int j, int val) {\\n                this.ij = i * 100000 + j;\\n                this.val = val;\\n            }\\n        }\\n\\n        public int[] maxPoints(int[][] grid, int[] queries) {\\n            Set<Integer> chk = new HashSet<>(); // points visited\\n            Map<Integer, Node> map = new HashMap<>();\\n            int max = 0;\\n            for (int i = 0; i < grid.length; i++) {\\n                for (int j = 0; j < grid[0].length; j++) {\\n                    map.put(i * 100000 + j, new Node(i, j, grid[i][j]));\\n                    max = Math.max(max, grid[i][j]);\\n                }\\n            }\\n            int[] cnts = new int[max];\\n            PriorityQueue<Node> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a.val));\\n            pq.offer(map.get(0));\\n            chk.add(0);\\n            for (int i = 1; i <= max; i++) {\\n                cnts[i] = cnts[i - 1];\\n                if (pq.isEmpty() || i > pq.peek().val) continue;\\n                while (!pq.isEmpty() && pq.peek().val <= i) {\\n                    Node node = pq.poll();\\n                    cnts[i]++;\\n                    if (map.containsKey(node.ij - 1) && !chk.contains(node.ij - 1)) { // left\\n                        pq.offer(map.get(node.ij - 1));\\n                        chk.add(node.ij - 1);\\n                    }\\n                    if (map.containsKey(node.ij + 1) && !chk.contains(node.ij + 1)) { // right\\n                        pq.offer(map.get(node.ij + 1));\\n                        chk.add(node.ij + 1);\\n                    }\\n                    if (map.containsKey(node.ij - 100000) && !chk.contains(node.ij - 100000)) { // top\\n                        pq.offer(map.get(node.ij - 100000));\\n                        chk.add(node.ij - 100000);\\n                    }\\n                    if (map.containsKey(node.ij + 100000) && !chk.contains(node.ij + 100000)) { // down\\n                        pq.offer(map.get(node.ij + 100000));\\n                        chk.add(node.ij + 100000);\\n                    }\\n                }\\n            }\\n            int[] rst = new int[queries.length];\\n            for (int i = 0; i < queries.length; i++) rst[i] = cnts[queries[i] - 1];\\n            return rst;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903861,
                "title": "c-simple-bfs",
                "content": "# Intuition\\nWell it is very clear we can do bfs for each query. But then we would be doing a lot of repetitive work i.e all the visited blocks for query=5 will also be visited for query=6\\n# Approach\\nWe can process queries in increasing order.\\n1. We can continue our bfs from the point where our previous bfs could not penetrate due to large values\\n2. We will maintain a global queue, that stores all the values our previous bfs couldnot penetrate\\n3. Then we continue are bfs , using this queue\\n\\n# Complexity\\n- Time complexity:\\nO(k + (m*n))\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<bool>>visited;\\n    vector<vector<int> > grid;\\n    queue<pair<int,int> > q;\\n    int score=0;\\n    vector<int> ans;\\n    \\n    int dx[4] = {-1,0,+1,0};\\n    int dy[4] = {0,+1,0,-1};\\n    \\n    bool isValid(int x , int y){\\n        if(x>=0 and y>=0 and x<grid.size() and y<grid[0].size()) return true;\\n        return false;\\n    }\\n      \\n    void bfs(int val){\\n        queue<pair<int,int> > que;\\n        queue<pair<int,int> > temp;\\n\\n        //filter out blocks which can now start our bfs\\n        while(q.size()){\\n            auto e = q.front();q.pop();\\n            if(grid[e.first][e.second] < val){\\n                score++; \\n                que.push(e);\\n            }else{\\n                temp.push(e);\\n            }\\n        }\\n\\n        q=temp;\\n        \\n        while(que.size()){\\n            auto node = que.front();que.pop();\\n            int x = node.first , y=node.second;\\n            \\n            for(int k=0;k<4;k++){\\n                //find new coordinates\\n                int newX = x + dx[k] , newY = y+dy[k];\\n                \\n                if(isValid(newX,newY)){\\n                    if(visited[newX][newY]) continue;\\n                   \\n                    if(grid[newX][newY] >= val){\\n                        visited[newX][newY]=1;\\n                        q.push({newX,newY});\\n                    }else{\\n                        score++;\\n                        visited[newX][newY]=1;\\n                        que.push({newX,newY});\\n                    }\\n                }\\n            }\\n            \\n            \\n        }\\n        \\n    }\\n    \\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int k=queries.size() , n=grid.size() , m=grid[0].size();\\n        ans.resize(k); visited.resize(n);\\n        for(int i=0;i<n;i++) visited[i].resize(m);\\n        this->grid = grid;\\n        //for processing queries in sorted order\\n        vector<int> sorted(k);\\n        iota(sorted.begin(),sorted.end(),0);\\n        sort(sorted.begin(),sorted.end(),[&]( int a , int b){\\n            return queries[a]<queries[b];\\n        });\\n        \\n        q.push({0,0});\\n        visited[0][0]=1;\\n        //process queries\\n        for(int i=0;i<k;i++){\\n            bfs(queries[sorted[i]]);\\n            ans[sorted[i]]=score;\\n        }\\n        \\n        return  ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<bool>>visited;\\n    vector<vector<int> > grid;\\n    queue<pair<int,int> > q;\\n    int score=0;\\n    vector<int> ans;\\n    \\n    int dx[4] = {-1,0,+1,0};\\n    int dy[4] = {0,+1,0,-1};\\n    \\n    bool isValid(int x , int y){\\n        if(x>=0 and y>=0 and x<grid.size() and y<grid[0].size()) return true;\\n        return false;\\n    }\\n      \\n    void bfs(int val){\\n        queue<pair<int,int> > que;\\n        queue<pair<int,int> > temp;\\n\\n        //filter out blocks which can now start our bfs\\n        while(q.size()){\\n            auto e = q.front();q.pop();\\n            if(grid[e.first][e.second] < val){\\n                score++; \\n                que.push(e);\\n            }else{\\n                temp.push(e);\\n            }\\n        }\\n\\n        q=temp;\\n        \\n        while(que.size()){\\n            auto node = que.front();que.pop();\\n            int x = node.first , y=node.second;\\n            \\n            for(int k=0;k<4;k++){\\n                //find new coordinates\\n                int newX = x + dx[k] , newY = y+dy[k];\\n                \\n                if(isValid(newX,newY)){\\n                    if(visited[newX][newY]) continue;\\n                   \\n                    if(grid[newX][newY] >= val){\\n                        visited[newX][newY]=1;\\n                        q.push({newX,newY});\\n                    }else{\\n                        score++;\\n                        visited[newX][newY]=1;\\n                        que.push({newX,newY});\\n                    }\\n                }\\n            }\\n            \\n            \\n        }\\n        \\n    }\\n    \\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int k=queries.size() , n=grid.size() , m=grid[0].size();\\n        ans.resize(k); visited.resize(n);\\n        for(int i=0;i<n;i++) visited[i].resize(m);\\n        this->grid = grid;\\n        //for processing queries in sorted order\\n        vector<int> sorted(k);\\n        iota(sorted.begin(),sorted.end(),0);\\n        sort(sorted.begin(),sorted.end(),[&]( int a , int b){\\n            return queries[a]<queries[b];\\n        });\\n        \\n        q.push({0,0});\\n        visited[0][0]=1;\\n        //process queries\\n        for(int i=0;i<k;i++){\\n            bfs(queries[sorted[i]]);\\n            ans[sorted[i]]=score;\\n        }\\n        \\n        return  ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903280,
                "title": "c-using-priorityqueue",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int n = grid.size(), m = grid[0].size(), curAns = 0;\\n        \\n        vector<pair<int, int>> qries;\\n        vector<int> ans(queries.size(), 0), dirn = {-1, 0, 1, 0, -1};\\n        vector<vector<bool>> vis(n, vector<bool> (m, false));\\n\\n        priority_queue< vector<int>, vector<vector<int>>, greater<vector<int>> > minHeap;\\n\\n        for(int i = 0; i < queries.size(); ++i) \\n            qries.push_back({queries[i], i});\\n        sort(begin(qries), end(qries));\\n\\n        minHeap.push({grid[0][0], 0, 0});\\n        vis[0][0] = true;\\n\\n        for(auto &p : qries) {\\n            int val = p.first, indx = p.second;\\n\\n            while(!minHeap.empty()) {\\n                auto v = minHeap.top();\\n                minHeap.pop();\\n                int curVal = v[0], x = v[1], y = v[2];\\n\\n                if(curVal >= val) {\\n                    minHeap.push(v);\\n                    break;\\n                }\\n                curAns++;\\n\\n                for(int i = 0; i < 4; ++i) {\\n                    int nx = x + dirn[i];\\n                    int ny = y + dirn[i + 1];\\n\\n                    if(nx >= 0 && nx < n && ny >= 0 && ny < m && !vis[nx][ny]) {\\n                        vis[nx][ny] = 1;\\n                        minHeap.push({grid[nx][ny], nx, ny});\\n                    }\\n                }\\n            }\\n\\n            ans[indx] = curAns;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int n = grid.size(), m = grid[0].size(), curAns = 0;\\n        \\n        vector<pair<int, int>> qries;\\n        vector<int> ans(queries.size(), 0), dirn = {-1, 0, 1, 0, -1};\\n        vector<vector<bool>> vis(n, vector<bool> (m, false));\\n\\n        priority_queue< vector<int>, vector<vector<int>>, greater<vector<int>> > minHeap;\\n\\n        for(int i = 0; i < queries.size(); ++i) \\n            qries.push_back({queries[i], i});\\n        sort(begin(qries), end(qries));\\n\\n        minHeap.push({grid[0][0], 0, 0});\\n        vis[0][0] = true;\\n\\n        for(auto &p : qries) {\\n            int val = p.first, indx = p.second;\\n\\n            while(!minHeap.empty()) {\\n                auto v = minHeap.top();\\n                minHeap.pop();\\n                int curVal = v[0], x = v[1], y = v[2];\\n\\n                if(curVal >= val) {\\n                    minHeap.push(v);\\n                    break;\\n                }\\n                curAns++;\\n\\n                for(int i = 0; i < 4; ++i) {\\n                    int nx = x + dirn[i];\\n                    int ny = y + dirn[i + 1];\\n\\n                    if(nx >= 0 && nx < n && ny >= 0 && ny < m && !vis[nx][ny]) {\\n                        vis[nx][ny] = 1;\\n                        minHeap.push({grid[nx][ny], nx, ny});\\n                    }\\n                }\\n            }\\n\\n            ans[indx] = curAns;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903039,
                "title": "c-bfs-one-run",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] MaxPoints(int[][] grid, int[] q) {\\n        PriorityQueue<int,int> Q = new ();  //REMOVE REPEAT\\n        int n  = q.Length;\\n        int[] ans = new int[n];\\n        int res = 0;\\n        int[,] dirs = new int[4,2]{{-1,0},{1,0},{0,-1},{0,1}};\\n        \\n        int r = grid.Length;\\n        int c = grid[0].Length;\\n        int[][] V = new int[r][];\\n        for(int i=0;i<r;i++)\\n            V[i] = new int[c];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            Q.Enqueue(i,q[i]);\\n        }\\n        \\n        Queue<int> N1 = new(); //next \\n        Dictionary<int,int> B = new(); //boder point,v\\n        B[0] = grid[0][0];\\n        \\n        while(Q.Count>0)\\n        {\\n            int idx = Q.Dequeue();\\n            int v = q[idx];\\n            ResetQ(N1,B,v);\\n            while(N1.Count>0)\\n            {\\n                \\n                int m = N1.Dequeue();\\n                int r1 = m/c;\\n                int c1 = m%c;\\n                //Console.WriteLine($\"{res}\");\\n                if(V[r1][c1]==0)\\n                {\\n                    V[r1][c1]= 1;\\n                    res += 1;\\n                    \\n                    for(int i=0;i<4;i++)\\n                    {\\n                        int r2 = r1+dirs[i,0];\\n                        int c2 = c1+dirs[i,1];\\n                        \\n                        if(r2>=0 && r2<r && c2>=0 && c2<c)\\n                        {\\n                          //  Console.WriteLine($\"{r2},{c2},{grid[r2][c2]},{V[r2][c2]},{v}\");\\n                            if(V[r2][c2]==0)\\n                            {\\n                                if(grid[r2][c2]<v)\\n                                {\\n                                    //res += 1;\\n                                    //V[r2][c2] = 1;\\n                                    N1.Enqueue(r2*c+c2);\\n                                }\\n                                else\\n                                {\\n                                    if(!B.ContainsKey(r2*c+c2))\\n                                    {\\n                                        B[r2*c+c2] = grid[r2][c2];\\n                                    }\\n                                }\\n                                    \\n                            }\\n                        }\\n                    }\\n                }\\n                \\n              \\n                \\n                \\n            }\\n             ans[idx] = res;\\n           \\n            \\n        } \\n        return ans;\\n    }\\n    public void ResetQ(Queue<int> Q1, Dictionary<int,int>B,int t)\\n    {\\n         List<int> D = new();\\n         foreach(KeyValuePair<int,int> kv in B)\\n         {\\n             if(kv.Value<t)\\n             {\\n                 Q1.Enqueue(kv.Key);\\n                 D.Add(kv.Key);\\n             }\\n         }\\n        foreach(int key in D)\\n            B.Remove(key);\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] MaxPoints(int[][] grid, int[] q) {\\n        PriorityQueue<int,int> Q = new ();  //REMOVE REPEAT\\n        int n  = q.Length;\\n        int[] ans = new int[n];\\n        int res = 0;\\n        int[,] dirs = new int[4,2]{{-1,0},{1,0},{0,-1},{0,1}};\\n        \\n        int r = grid.Length;\\n        int c = grid[0].Length;\\n        int[][] V = new int[r][];\\n        for(int i=0;i<r;i++)\\n            V[i] = new int[c];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            Q.Enqueue(i,q[i]);\\n        }\\n        \\n        Queue<int> N1 = new(); //next \\n        Dictionary<int,int> B = new(); //boder point,v\\n        B[0] = grid[0][0];\\n        \\n        while(Q.Count>0)\\n        {\\n            int idx = Q.Dequeue();\\n            int v = q[idx];\\n            ResetQ(N1,B,v);\\n            while(N1.Count>0)\\n            {\\n                \\n                int m = N1.Dequeue();\\n                int r1 = m/c;\\n                int c1 = m%c;\\n                //Console.WriteLine($\"{res}\");\\n                if(V[r1][c1]==0)\\n                {\\n                    V[r1][c1]= 1;\\n                    res += 1;\\n                    \\n                    for(int i=0;i<4;i++)\\n                    {\\n                        int r2 = r1+dirs[i,0];\\n                        int c2 = c1+dirs[i,1];\\n                        \\n                        if(r2>=0 && r2<r && c2>=0 && c2<c)\\n                        {\\n                          //  Console.WriteLine($\"{r2},{c2},{grid[r2][c2]},{V[r2][c2]},{v}\");\\n                            if(V[r2][c2]==0)\\n                            {\\n                                if(grid[r2][c2]<v)\\n                                {\\n                                    //res += 1;\\n                                    //V[r2][c2] = 1;\\n                                    N1.Enqueue(r2*c+c2);\\n                                }\\n                                else\\n                                {\\n                                    if(!B.ContainsKey(r2*c+c2))\\n                                    {\\n                                        B[r2*c+c2] = grid[r2][c2];\\n                                    }\\n                                }\\n                                    \\n                            }\\n                        }\\n                    }\\n                }\\n                \\n              \\n                \\n                \\n            }\\n             ans[idx] = res;\\n           \\n            \\n        } \\n        return ans;\\n    }\\n    public void ResetQ(Queue<int> Q1, Dictionary<int,int>B,int t)\\n    {\\n         List<int> D = new();\\n         foreach(KeyValuePair<int,int> kv in B)\\n         {\\n             if(kv.Value<t)\\n             {\\n                 Q1.Enqueue(kv.Key);\\n                 D.Add(kv.Key);\\n             }\\n         }\\n        foreach(int key in D)\\n            B.Remove(key);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902872,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nstruct list{\\n    int val;\\n    int x;\\n    int y;\\n};\\n\\nstruct pp{\\n    int val;\\n    int place;\\n};\\n\\nint comp(const void* a, const void* b){\\n    return (*(struct pp*)a).val - (*(struct pp*)b).val;\\n}\\n\\nvoid input(int** grid, int gridSize, int gridColSize, int i, int j, struct list* helper, int* count, bool** used, int* nowpoint, int nowval){\\n    used[i][j] = true;\\n    if (nowval > grid[i][j]){\\n        *nowpoint += 1;\\n        if (i-1 >= 0 && !used[i-1][j]){\\n            input(grid, gridSize, gridColSize, i-1, j,  helper, count, used, nowpoint, nowval);\\n        }\\n        if (i+1 < gridSize && !used[i+1][j]){\\n            input(grid, gridSize, gridColSize, i+1, j,  helper, count, used, nowpoint, nowval);\\n        }\\n        if (j-1 >= 0 && !used[i][j-1]){\\n            input(grid, gridSize, gridColSize, i, j-1,  helper, count, used, nowpoint, nowval);\\n        }\\n        if (j+1 < gridColSize && !used[i][j+1]){\\n            input(grid, gridSize, gridColSize, i, j+1,  helper, count, used, nowpoint, nowval);\\n        }\\n    } else {\\n        helper[*count].val = grid[i][j];\\n        helper[*count].x = i;\\n        helper[*count].y = j;\\n        *count += 1;\\n    }\\n}\\n\\nint* maxPoints(int** grid, int gridSize, int* gridColSize, int* queries, int queriesSize, int* returnSize){\\n    int nowpoint = 0;\\n    struct list* helper1 =  malloc(sizeof(struct list)*(gridSize*(*gridColSize)));\\n    struct list* helper2 =  malloc(sizeof(struct list)*(gridSize*(*gridColSize)));\\n    int count1 = 0;\\n    int count2 = 0;\\n\\n    struct pp* remake = malloc(sizeof(struct pp)*queriesSize);\\n    for (int i = 0 ; i < queriesSize ; i++){\\n        remake[i].val = queries[i];\\n        remake[i].place = i;\\n    }\\n    qsort(remake, queriesSize, sizeof(struct pp), comp);\\n\\n    *returnSize = queriesSize;\\n    int* ans = malloc(sizeof(int)*queriesSize);\\n\\n    bool** used = malloc(sizeof(bool*)*gridSize);\\n    for (int i = 0 ; i < gridSize ; i++){\\n        used[i] = calloc(*gridColSize, sizeof(bool));\\n    }\\n    \\n    input(grid, gridSize, *gridColSize, 0, 0,  helper1, &count1, used, &nowpoint, remake[0].val);\\n    ans[remake[0].place] = nowpoint;\\n\\n    for (int i = 1 ; i < queriesSize ; i++){\\n        if ((i&1) == 1){\\n            count2 = 0;\\n            for (int m = 0 ; m < count1 ; m++){\\n                input(grid, gridSize, *gridColSize, helper1[m].x, helper1[m].y,  helper2, &count2, used, &nowpoint, remake[i].val);\\n            }\\n        } else {\\n            count1 = 0;\\n            for (int m = 0 ; m < count2 ; m++){\\n                input(grid, gridSize, *gridColSize, helper2[m].x, helper2[m].y,  helper1, &count1, used, &nowpoint, remake[i].val);\\n            }\\n        }\\n        ans[remake[i].place] = nowpoint;\\n    }\\n    free(remake);\\n    free(helper1);\\n    free(helper2);\\n    for (int i = 0 ; i < gridSize ; i++){\\n        free(used[i]);\\n    }\\n    free(used);\\n\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nstruct list{\\n    int val;\\n    int x;\\n    int y;\\n};\\n\\nstruct pp{\\n    int val;\\n    int place;\\n};\\n\\nint comp(const void* a, const void* b){\\n    return (*(struct pp*)a).val - (*(struct pp*)b).val;\\n}\\n\\nvoid input(int** grid, int gridSize, int gridColSize, int i, int j, struct list* helper, int* count, bool** used, int* nowpoint, int nowval){\\n    used[i][j] = true;\\n    if (nowval > grid[i][j]){\\n        *nowpoint += 1;\\n        if (i-1 >= 0 && !used[i-1][j]){\\n            input(grid, gridSize, gridColSize, i-1, j,  helper, count, used, nowpoint, nowval);\\n        }\\n        if (i+1 < gridSize && !used[i+1][j]){\\n            input(grid, gridSize, gridColSize, i+1, j,  helper, count, used, nowpoint, nowval);\\n        }\\n        if (j-1 >= 0 && !used[i][j-1]){\\n            input(grid, gridSize, gridColSize, i, j-1,  helper, count, used, nowpoint, nowval);\\n        }\\n        if (j+1 < gridColSize && !used[i][j+1]){\\n            input(grid, gridSize, gridColSize, i, j+1,  helper, count, used, nowpoint, nowval);\\n        }\\n    } else {\\n        helper[*count].val = grid[i][j];\\n        helper[*count].x = i;\\n        helper[*count].y = j;\\n        *count += 1;\\n    }\\n}\\n\\nint* maxPoints(int** grid, int gridSize, int* gridColSize, int* queries, int queriesSize, int* returnSize){\\n    int nowpoint = 0;\\n    struct list* helper1 =  malloc(sizeof(struct list)*(gridSize*(*gridColSize)));\\n    struct list* helper2 =  malloc(sizeof(struct list)*(gridSize*(*gridColSize)));\\n    int count1 = 0;\\n    int count2 = 0;\\n\\n    struct pp* remake = malloc(sizeof(struct pp)*queriesSize);\\n    for (int i = 0 ; i < queriesSize ; i++){\\n        remake[i].val = queries[i];\\n        remake[i].place = i;\\n    }\\n    qsort(remake, queriesSize, sizeof(struct pp), comp);\\n\\n    *returnSize = queriesSize;\\n    int* ans = malloc(sizeof(int)*queriesSize);\\n\\n    bool** used = malloc(sizeof(bool*)*gridSize);\\n    for (int i = 0 ; i < gridSize ; i++){\\n        used[i] = calloc(*gridColSize, sizeof(bool));\\n    }\\n    \\n    input(grid, gridSize, *gridColSize, 0, 0,  helper1, &count1, used, &nowpoint, remake[0].val);\\n    ans[remake[0].place] = nowpoint;\\n\\n    for (int i = 1 ; i < queriesSize ; i++){\\n        if ((i&1) == 1){\\n            count2 = 0;\\n            for (int m = 0 ; m < count1 ; m++){\\n                input(grid, gridSize, *gridColSize, helper1[m].x, helper1[m].y,  helper2, &count2, used, &nowpoint, remake[i].val);\\n            }\\n        } else {\\n            count1 = 0;\\n            for (int m = 0 ; m < count2 ; m++){\\n                input(grid, gridSize, *gridColSize, helper2[m].x, helper2[m].y,  helper1, &count1, used, &nowpoint, remake[i].val);\\n            }\\n        }\\n        ans[remake[i].place] = nowpoint;\\n    }\\n    free(remake);\\n    free(helper1);\\n    free(helper2);\\n    for (int i = 0 ; i < gridSize ; i++){\\n        free(used[i]);\\n    }\\n    free(used);\\n\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2902825,
                "title": "two-queue-intuitive-easy",
                "content": "```\\nclass Solution {\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        \\n        int n=queries.length;\\n        int [][]newQueries=new int[n][2];\\n        int [][]visited=new int[grid.length][grid[0].length];\\n        Queue<int []> queue=new LinkedList<>();\\n        Queue<int []> used=new LinkedList<>();\\n        queue.add(new int[]{0,0});\\n        int []res=new int[n];\\n        visited[0][0]=1;\\n        for(int i=0;i<n;i++){\\n            newQueries[i][0]=i;\\n            newQueries[i][1]=queries[i];\\n        }\\n        \\n        Arrays.sort(newQueries,(a,b)->a[1]-b[1]);\\n        \\n        int [][]dir=new int[][]{{-1,0},{1,0},{0,-1},{0,1}};\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            while(!used.isEmpty()){\\n                queue.add(used.poll());\\n            }\\n            int val=newQueries[i][1];\\n            int index=newQueries[i][0];\\n            // System.out.println();\\n            while(!queue.isEmpty()){\\n                int cur[]=queue.poll();\\n                if(grid[cur[0]][cur[1]]>=val){\\n                    used.offer(cur);\\n                    continue;\\n                }\\n                // System.out.println(cur[0]+\" \"+cur[1]);\\n                ans++;\\n\\n                for(int[] d:dir){\\n                    int x=cur[0]+d[0];\\n                    int y=cur[1]+d[1];\\n\\n                    if(x<0 || y<0 || x>=grid.length || y>=grid[0].length || visited[x][y]==1) continue;\\n\\n                    visited[x][y]=1;\\n                    queue.offer(new int[]{x,y});\\n                }\\n            }\\n            res[index]=ans;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Queue",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        \\n        int n=queries.length;\\n        int [][]newQueries=new int[n][2];\\n        int [][]visited=new int[grid.length][grid[0].length];\\n        Queue<int []> queue=new LinkedList<>();\\n        Queue<int []> used=new LinkedList<>();\\n        queue.add(new int[]{0,0});\\n        int []res=new int[n];\\n        visited[0][0]=1;\\n        for(int i=0;i<n;i++){\\n            newQueries[i][0]=i;\\n            newQueries[i][1]=queries[i];\\n        }\\n        \\n        Arrays.sort(newQueries,(a,b)->a[1]-b[1]);\\n        \\n        int [][]dir=new int[][]{{-1,0},{1,0},{0,-1},{0,1}};\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            while(!used.isEmpty()){\\n                queue.add(used.poll());\\n            }\\n            int val=newQueries[i][1];\\n            int index=newQueries[i][0];\\n            // System.out.println();\\n            while(!queue.isEmpty()){\\n                int cur[]=queue.poll();\\n                if(grid[cur[0]][cur[1]]>=val){\\n                    used.offer(cur);\\n                    continue;\\n                }\\n                // System.out.println(cur[0]+\" \"+cur[1]);\\n                ans++;\\n\\n                for(int[] d:dir){\\n                    int x=cur[0]+d[0];\\n                    int y=cur[1]+d[1];\\n\\n                    if(x<0 || y<0 || x>=grid.length || y>=grid[0].length || visited[x][y]==1) continue;\\n\\n                    visited[x][y]=1;\\n                    queue.offer(new int[]{x,y});\\n                }\\n            }\\n            res[index]=ans;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902783,
                "title": "fast-o-m-n-runtime-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPoints(self, g: List[List[int]], qu: List[int]) -> List[int]:\\n        m = len(g)\\n        n = len(g[0])\\n        cou = Counter()\\n        que = [(-1 , 0 , 0)]\\n\\n        while que:\\n            a , b , c = heappop(que)\\n            if g[b][c] == -1: continue\\n            can = max(a , g[b][c] + 1)\\n            cou[can] += 1\\n            g[b][c] = -1\\n            for i ,j in [(b+1 , c) , (b-1 , c) , (b , c+1) , (b , c-1)]:\\n                if 0 <= i < m and 0 <= j < n and g[i][j] != -1:\\n                    heappush(que , (can , i , j))\\n        \\n        cu = -1\\n        ar = []\\n        for kei in sorted(cou.keys()):\\n            ar.append(kei)\\n            if cu != -1:\\n                cou[kei] += cou[cu]\\n            cu = kei\\n        \\n        res = [0] * len(qu)\\n        for i , q in enumerate(qu):\\n            ca = bisect.bisect(ar , q) - 1\\n            if ca >= 0:\\n                res[i] = cou[ar[ca]]\\n        \\n        return res\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, g: List[List[int]], qu: List[int]) -> List[int]:\\n        m = len(g)\\n        n = len(g[0])\\n        cou = Counter()\\n        que = [(-1 , 0 , 0)]\\n\\n        while que:\\n            a , b , c = heappop(que)\\n            if g[b][c] == -1: continue\\n            can = max(a , g[b][c] + 1)\\n            cou[can] += 1\\n            g[b][c] = -1\\n            for i ,j in [(b+1 , c) , (b-1 , c) , (b , c+1) , (b , c-1)]:\\n                if 0 <= i < m and 0 <= j < n and g[i][j] != -1:\\n                    heappush(que , (can , i , j))\\n        \\n        cu = -1\\n        ar = []\\n        for kei in sorted(cou.keys()):\\n            ar.append(kei)\\n            if cu != -1:\\n                cou[kei] += cou[cu]\\n            cu = kei\\n        \\n        res = [0] * len(qu)\\n        for i , q in enumerate(qu):\\n            ca = bisect.bisect(ar , q) - 1\\n            if ca >= 0:\\n                res[i] = cou[ar[ca]]\\n        \\n        return res\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902706,
                "title": "heap-based-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to traverse this graph neither depth-first nor width-first (both take too much time), but in \"height\" order, where the height of a vertex is the maximum value along any path from the starting point to that vertex.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe keep track of the vertices with the lowest height seen so far, using a heap, and visit their neighbors first.\\n\\nIf we visit vertices in this order, we only need to visit each vertex once. \\n\\n# Complexity\\n- Time complexity: $O((mn+k) \\\\log mn)$, because each heap push and pop can take logarithmic time, then we sort the list of heights, and finally each query can also take logarithmic time.\\n\\nThis solution is faster than 88.9%.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m=len(grid)\\n        n=len(grid[0])\\n\\n        q=[(grid[0][0], 0, 0)]\\n        dct={(0, 0): grid[0][0]}\\n        while len(q):\\n            mx, x, y=heapq.heappop(q)\\n            tmp=[]\\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\\n                x1=x+dx\\n                y1=y+dy\\n                if (x1, y1) not in dct and x1>=0 and x1<m and y1>=0 and y1<n:\\n                    mx1=max(mx, grid[x1][y1])\\n                    heapq.heappush(q, (mx1, x1, y1))\\n                    dct[(x1, y1)]=mx1\\n\\n        lst=sorted(list(dct.values()))\\n        return [bisect.bisect_left(lst, qu) for qu in queries]\\n                        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m=len(grid)\\n        n=len(grid[0])\\n\\n        q=[(grid[0][0], 0, 0)]\\n        dct={(0, 0): grid[0][0]}\\n        while len(q):\\n            mx, x, y=heapq.heappop(q)\\n            tmp=[]\\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\\n                x1=x+dx\\n                y1=y+dy\\n                if (x1, y1) not in dct and x1>=0 and x1<m and y1>=0 and y1<n:\\n                    mx1=max(mx, grid[x1][y1])\\n                    heapq.heappush(q, (mx1, x1, y1))\\n                    dct[(x1, y1)]=mx1\\n\\n        lst=sorted(list(dct.values()))\\n        return [bisect.bisect_left(lst, qu) for qu in queries]\\n                        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902609,
                "title": "c-solution",
                "content": "This solution is a combination of different techniques such as bfs, heap, prefix sum and binary search. It was a good exercise to combine everything together.\\n```\\npublic class Solution {\\n    public int[] MaxPoints(int[][] grid, int[] queries) {\\n        int[] res = new int[queries.Length];\\n        SortedDictionary<int, int> sortedMap = Bfs(grid);\\n        List<int> prefix = new();\\n        List<int> sortedKeys = sortedMap.Keys.ToList();\\n        foreach(int key in sortedKeys){\\n            int prev = prefix.Count > 0 ? prefix[prefix.Count-1] : 0;\\n            prefix.Add(sortedMap[key]+prev);\\n        }        \\n        for(int i = 0; i < queries.Length; i++){\\n            int idx = BinarySearch(sortedKeys, queries[i]);\\n            res[i] = idx != -1 ? prefix[idx] : 0;\\n        }\\n        return res;\\n    }\\n    private int BinarySearch(List<int> sortedKeys, int query){\\n        int lo = 0, hi = sortedKeys.Count-1, ans = -1;\\n        while(lo <= hi){\\n            int mid = lo+(hi-lo)/2;\\n            if(sortedKeys[mid] < query) ans = mid;\\n            if(sortedKeys[mid] < query) lo = mid+1;\\n            else hi = mid-1;\\n        }\\n        return ans;\\n    }\\n    private SortedDictionary<int, int> Bfs(int[][] grid){\\n        int max = grid[0][0];\\n        int[] dx = new int[] { -1, 1, 0, 0 };\\n        int[] dy = new int[] { 0, 0, 1, -1 };\\n        SortedDictionary<int, int> sortedMap = new();\\n        PriorityQueue<int[], int> queue = new();\\n        bool[,] visited = new bool[grid.Length, grid[0].Length];\\n        queue.Enqueue(new int[] { 0, 0 }, grid[0][0]);\\n        visited[0,0] = true;\\n        while(queue.Count > 0){\\n            int size = queue.Count;\\n            for(int i = 0; i < size; i++){\\n                int[] curr = queue.Dequeue();\\n                if(max < grid[curr[0]][curr[1]])\\n                    max = grid[curr[0]][curr[1]];\\n                if(!sortedMap.ContainsKey(max))\\n                    sortedMap.Add(max, 0);\\n                sortedMap[max]++;\\n                for(int j = 0; j < 4; j++){\\n                    int x = curr[0]+dx[j], y = curr[1]+dy[j];\\n                    if(x < 0 || x >= grid.Length || y < 0 || y >= grid[0].Length || visited[x,y])\\n                        continue;\\n                    queue.Enqueue(new int[] { x, y }, grid[x][y]);\\n                    visited[x,y] = true;\\n                }\\n            }\\n        }\\n        return sortedMap;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Binary Search",
                    "Breadth-First Search",
                    "Prefix Sum"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] MaxPoints(int[][] grid, int[] queries) {\\n        int[] res = new int[queries.Length];\\n        SortedDictionary<int, int> sortedMap = Bfs(grid);\\n        List<int> prefix = new();\\n        List<int> sortedKeys = sortedMap.Keys.ToList();\\n        foreach(int key in sortedKeys){\\n            int prev = prefix.Count > 0 ? prefix[prefix.Count-1] : 0;\\n            prefix.Add(sortedMap[key]+prev);\\n        }        \\n        for(int i = 0; i < queries.Length; i++){\\n            int idx = BinarySearch(sortedKeys, queries[i]);\\n            res[i] = idx != -1 ? prefix[idx] : 0;\\n        }\\n        return res;\\n    }\\n    private int BinarySearch(List<int> sortedKeys, int query){\\n        int lo = 0, hi = sortedKeys.Count-1, ans = -1;\\n        while(lo <= hi){\\n            int mid = lo+(hi-lo)/2;\\n            if(sortedKeys[mid] < query) ans = mid;\\n            if(sortedKeys[mid] < query) lo = mid+1;\\n            else hi = mid-1;\\n        }\\n        return ans;\\n    }\\n    private SortedDictionary<int, int> Bfs(int[][] grid){\\n        int max = grid[0][0];\\n        int[] dx = new int[] { -1, 1, 0, 0 };\\n        int[] dy = new int[] { 0, 0, 1, -1 };\\n        SortedDictionary<int, int> sortedMap = new();\\n        PriorityQueue<int[], int> queue = new();\\n        bool[,] visited = new bool[grid.Length, grid[0].Length];\\n        queue.Enqueue(new int[] { 0, 0 }, grid[0][0]);\\n        visited[0,0] = true;\\n        while(queue.Count > 0){\\n            int size = queue.Count;\\n            for(int i = 0; i < size; i++){\\n                int[] curr = queue.Dequeue();\\n                if(max < grid[curr[0]][curr[1]])\\n                    max = grid[curr[0]][curr[1]];\\n                if(!sortedMap.ContainsKey(max))\\n                    sortedMap.Add(max, 0);\\n                sortedMap[max]++;\\n                for(int j = 0; j < 4; j++){\\n                    int x = curr[0]+dx[j], y = curr[1]+dy[j];\\n                    if(x < 0 || x >= grid.Length || y < 0 || y >= grid[0].Length || visited[x,y])\\n                        continue;\\n                    queue.Enqueue(new int[] { x, y }, grid[x][y]);\\n                    visited[x,y] = true;\\n                }\\n            }\\n        }\\n        return sortedMap;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902522,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n\\n\\n        public int[] MaxPoints(int[][] grid, int[] queries)\\n        {\\n            bool[][] dp = new bool[grid.Length][];\\n            for (int i = 0; i < grid.Length; i++)\\n            {\\n                dp[i] = new bool[grid[i].Length];\\n            }\\n\\n            int[] output = new int[queries.Length];\\n\\n            Dictionary<int, IList<int>> map = new Dictionary<int, IList<int>>();\\n            for (int i = 0; i < queries.Length; i++)\\n            {\\n                if (!map.ContainsKey(queries[i]))\\n                {\\n                    map.Add(queries[i], new List<int>());\\n                }\\n                map[queries[i]].Add(i);\\n            }\\n\\n\\n            Array.Sort(queries);\\n\\n            Queue<(int, int)> queue = new Queue<(int, int)>();\\n            HashSet<(int, int)> list = new HashSet<(int, int)>();\\n\\n            list.Add((0, 0));\\n            int[] result = new int[queries.Length];\\n            int counter = 0;\\n            for (int k = 0; k < queries.Length; k++)\\n            {\\n                queue = new Queue<(int, int)>(list);\\n\\n                list = new HashSet<(int, int)>();\\n                int num = queries[k];\\n                while (queue.Count > 0)\\n                {\\n                    (int i, int j) = queue.Dequeue();\\n                    if (i < 0 || j < 0 || i >= grid.Length || j >= grid[i].Length) continue;\\n\\n                    if (num > grid[i][j])\\n                    {\\n                        if (!dp[i][j])\\n                        {\\n                            counter++;\\n                            dp[i][j] = true;\\n                            //top i-1\\n                            queue.Enqueue((i - 1, j));\\n\\n                            //bottom i+1\\n                            queue.Enqueue((i + 1, j));\\n\\n                            //left j-1\\n                            queue.Enqueue((i, j - 1));\\n\\n                            //right j+1\\n                            queue.Enqueue((i, j + 1));\\n                        }\\n                    }\\n                    else\\n                    {\\n                        list.Add((i, j));\\n                    }\\n                }\\n\\n                result[k] = counter;\\n\\n                output[map[queries[k]][0]] = counter;\\n                map[queries[k]].RemoveAt(0);\\n            }\\n\\n            return output;\\n        }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\n\\n        public int[] MaxPoints(int[][] grid, int[] queries)\\n        {\\n            bool[][] dp = new bool[grid.Length][];\\n            for (int i = 0; i < grid.Length; i++)\\n            {\\n                dp[i] = new bool[grid[i].Length];\\n            }\\n\\n            int[] output = new int[queries.Length];\\n\\n            Dictionary<int, IList<int>> map = new Dictionary<int, IList<int>>();\\n            for (int i = 0; i < queries.Length; i++)\\n            {\\n                if (!map.ContainsKey(queries[i]))\\n                {\\n                    map.Add(queries[i], new List<int>());\\n                }\\n                map[queries[i]].Add(i);\\n            }\\n\\n\\n            Array.Sort(queries);\\n\\n            Queue<(int, int)> queue = new Queue<(int, int)>();\\n            HashSet<(int, int)> list = new HashSet<(int, int)>();\\n\\n            list.Add((0, 0));\\n            int[] result = new int[queries.Length];\\n            int counter = 0;\\n            for (int k = 0; k < queries.Length; k++)\\n            {\\n                queue = new Queue<(int, int)>(list);\\n\\n                list = new HashSet<(int, int)>();\\n                int num = queries[k];\\n                while (queue.Count > 0)\\n                {\\n                    (int i, int j) = queue.Dequeue();\\n                    if (i < 0 || j < 0 || i >= grid.Length || j >= grid[i].Length) continue;\\n\\n                    if (num > grid[i][j])\\n                    {\\n                        if (!dp[i][j])\\n                        {\\n                            counter++;\\n                            dp[i][j] = true;\\n                            //top i-1\\n                            queue.Enqueue((i - 1, j));\\n\\n                            //bottom i+1\\n                            queue.Enqueue((i + 1, j));\\n\\n                            //left j-1\\n                            queue.Enqueue((i, j - 1));\\n\\n                            //right j+1\\n                            queue.Enqueue((i, j + 1));\\n                        }\\n                    }\\n                    else\\n                    {\\n                        list.Add((i, j));\\n                    }\\n                }\\n\\n                result[k] = counter;\\n\\n                output[map[queries[k]][0]] = counter;\\n                map[queries[k]].RemoveAt(0);\\n            }\\n\\n            return output;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902502,
                "title": "c-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can perform Breadth First Search but with priority queue and precompute all critical pairs `(limit, count)` which we than use when answering `queries` \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBreadth First Search with Priority Queue; \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(m * n * log (m * n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(m * n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n\\n    public int[] MaxPoints(int[][] grid, int[] queries) {\\n      PriorityQueue<(int r, int c), int> agenda = new();\\n      HashSet<(int r, int c)> visited = new();\\n\\n      agenda.Enqueue((0, 0), grid[0][0]);\\n\\n      visited.Add((0, 0));\\n\\n      int limit = grid[0][0];\\n\\n      Dictionary<int, int> cache = new() {\\n        { limit, 0 },\\n      };\\n\\n      while (agenda.Count > 0) {\\n        var node = agenda.Dequeue();\\n\\n        var value = grid[node.r][node.c];\\n\\n        if (value <= limit)\\n          cache[limit] += 1;\\n        else {\\n          cache.Add(value, cache[limit] + 1);\\n\\n          limit = value;\\n        }\\n\\n        for (int d = 0; d < 4; ++d) {\\n          int dr = node.r + (d - 1) % 2;\\n          int dc = node.c + (d - 2) % 2;\\n\\n          if (dr < 0 || dc < 0 || dr >= grid.Length || dc >= grid[dr].Length)\\n            continue;\\n\\n          if (visited.Add((dr, dc)))\\n            agenda.Enqueue((dr, dc), grid[dr][dc]);\\n        }\\n      }\\n\\n      (int limit, int count)[] data = cache\\n        .OrderBy(pair => pair.Key)\\n        .Select(pair => (pair.Key, pair.Value))\\n        .ToArray();\\n\\n      int[] result = new int[queries.Length];\\n\\n      var comparer = Comparer<(int limit, int count)>.Create((a, b) => a.limit.CompareTo(b.limit));\\n\\n      for (int i = 0; i < queries.Length; ++i) {\\n        int q = queries[i] - 1;\\n\\n        int index = Array.BinarySearch(data, (q, 0), comparer);\\n\\n        if (index >= 0)\\n          result[i] = data[index].count;\\n        else {\\n          index = ~index - 1;\\n\\n          if (index >= 0)\\n            result[i] = data[index].count;\\n        }\\n      }\\n\\n      return result;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\n    public int[] MaxPoints(int[][] grid, int[] queries) {\\n      PriorityQueue<(int r, int c), int> agenda = new();\\n      HashSet<(int r, int c)> visited = new();\\n\\n      agenda.Enqueue((0, 0), grid[0][0]);\\n\\n      visited.Add((0, 0));\\n\\n      int limit = grid[0][0];\\n\\n      Dictionary<int, int> cache = new() {\\n        { limit, 0 },\\n      };\\n\\n      while (agenda.Count > 0) {\\n        var node = agenda.Dequeue();\\n\\n        var value = grid[node.r][node.c];\\n\\n        if (value <= limit)\\n          cache[limit] += 1;\\n        else {\\n          cache.Add(value, cache[limit] + 1);\\n\\n          limit = value;\\n        }\\n\\n        for (int d = 0; d < 4; ++d) {\\n          int dr = node.r + (d - 1) % 2;\\n          int dc = node.c + (d - 2) % 2;\\n\\n          if (dr < 0 || dc < 0 || dr >= grid.Length || dc >= grid[dr].Length)\\n            continue;\\n\\n          if (visited.Add((dr, dc)))\\n            agenda.Enqueue((dr, dc), grid[dr][dc]);\\n        }\\n      }\\n\\n      (int limit, int count)[] data = cache\\n        .OrderBy(pair => pair.Key)\\n        .Select(pair => (pair.Key, pair.Value))\\n        .ToArray();\\n\\n      int[] result = new int[queries.Length];\\n\\n      var comparer = Comparer<(int limit, int count)>.Create((a, b) => a.limit.CompareTo(b.limit));\\n\\n      for (int i = 0; i < queries.Length; ++i) {\\n        int q = queries[i] - 1;\\n\\n        int index = Array.BinarySearch(data, (q, 0), comparer);\\n\\n        if (index >= 0)\\n          result[i] = data[index].count;\\n        else {\\n          index = ~index - 1;\\n\\n          if (index >= 0)\\n            result[i] = data[index].count;\\n        }\\n      }\\n\\n      return result;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902494,
                "title": "bfs-with-priority-queue",
                "content": "# Intuition\\nBFS with Priority Queue \\n\\n# Approach\\nSort the quries and remeber the smallest query result and add it to the current query . with this approach , each element in the grid can be compared only once for all the queries . \\nProof : if 1 < 2 then 1 is always lesser than all the elements which are greater than 2 . \\n\\n# Complexity\\n- Time complexity:\\nsort queries : klogk ( k = length of the q)\\nBFS Algorithm : m * n ;\\nfor all queries : k \\ntotal complexity : k + (m * n)\\n\\n- Space complexity:\\nm * n ;\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        priority_queue<array<int, 3>, vector<array<int, 3>> , greater<array<int,3>>> pq;\\n        pq.push({grid[0][0], 0, 0});\\n        grid[0][0] = 0;\\n        int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        vector<int> newQuery = queries;\\n        sort(newQuery.begin(), newQuery.end());\\n        int res = 0, m = grid.size() , n = grid[0].size();\\n        map<int, int> mp;\\n        vector<int> result;\\n        for(auto q: newQuery) {\\n             while(!pq.empty()){\\n                auto [val, i, j]  = pq.top();\\n                if(val < q) {\\n                    res++;\\n                    pq.pop();\\n                } else {\\n                    break;\\n                }\\n                for(int d = 0;d < 4; d++) {\\n                    int x = i + dir[d][0];\\n                    int y = j + dir[d][1];\\n                    if(x >= 0 && y >= 0 && x < m && y < n && grid[x][y] != 0){\\n                        pq.push({grid[x][y], x, y});\\n                         grid[x][y] = 0;\\n                    }\\n                }\\n            }\\n            mp[q] = res;\\n        }\\n        for(auto q: queries) result.push_back(mp[q]);\\n        return result; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        priority_queue<array<int, 3>, vector<array<int, 3>> , greater<array<int,3>>> pq;\\n        pq.push({grid[0][0], 0, 0});\\n        grid[0][0] = 0;\\n        int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        vector<int> newQuery = queries;\\n        sort(newQuery.begin(), newQuery.end());\\n        int res = 0, m = grid.size() , n = grid[0].size();\\n        map<int, int> mp;\\n        vector<int> result;\\n        for(auto q: newQuery) {\\n             while(!pq.empty()){\\n                auto [val, i, j]  = pq.top();\\n                if(val < q) {\\n                    res++;\\n                    pq.pop();\\n                } else {\\n                    break;\\n                }\\n                for(int d = 0;d < 4; d++) {\\n                    int x = i + dir[d][0];\\n                    int y = j + dir[d][1];\\n                    if(x >= 0 && y >= 0 && x < m && y < n && grid[x][y] != 0){\\n                        pq.push({grid[x][y], x, y});\\n                         grid[x][y] = 0;\\n                    }\\n                }\\n            }\\n            mp[q] = res;\\n        }\\n        for(auto q: queries) result.push_back(mp[q]);\\n        return result; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902493,
                "title": "bfs-with-priority-queue",
                "content": "# Intuition\\nBFS with Priority Queue \\n\\n# Approach\\nSort the quries and remeber the smallest query result and add it to the current query . with this approach , each element in the grid can be compared only once for all the queries . \\nProof : if 1 < 2 then 1 is always lesser than all the elements which are greater than 2 . \\n\\n# Complexity\\n- Time complexity:\\nsort queries : klogk ( k = length of the q)\\nBFS Algorithm : m * n ;\\nfor all queries : k \\ntotal complexity : k + (m * n)\\n\\n- Space complexity:\\nm * n ;\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        priority_queue<array<int, 3>, vector<array<int, 3>> , greater<array<int,3>>> pq;\\n        pq.push({grid[0][0], 0, 0});\\n        grid[0][0] = 0;\\n        int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        vector<int> newQuery = queries;\\n        sort(newQuery.begin(), newQuery.end());\\n        int res = 0, m = grid.size() , n = grid[0].size();\\n        map<int, int> mp;\\n        vector<int> result;\\n        for(auto q: newQuery) {\\n             while(!pq.empty()){\\n                auto [val, i, j]  = pq.top();\\n                if(val < q) {\\n                    res++;\\n                    pq.pop();\\n                } else {\\n                    break;\\n                }\\n                for(int d = 0;d < 4; d++) {\\n                    int x = i + dir[d][0];\\n                    int y = j + dir[d][1];\\n                    if(x >= 0 && y >= 0 && x < m && y < n && grid[x][y] != 0){\\n                        pq.push({grid[x][y], x, y});\\n                         grid[x][y] = 0;\\n                    }\\n                }\\n            }\\n            mp[q] = res;\\n        }\\n        for(auto q: queries) result.push_back(mp[q]);\\n        return result; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        priority_queue<array<int, 3>, vector<array<int, 3>> , greater<array<int,3>>> pq;\\n        pq.push({grid[0][0], 0, 0});\\n        grid[0][0] = 0;\\n        int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        vector<int> newQuery = queries;\\n        sort(newQuery.begin(), newQuery.end());\\n        int res = 0, m = grid.size() , n = grid[0].size();\\n        map<int, int> mp;\\n        vector<int> result;\\n        for(auto q: newQuery) {\\n             while(!pq.empty()){\\n                auto [val, i, j]  = pq.top();\\n                if(val < q) {\\n                    res++;\\n                    pq.pop();\\n                } else {\\n                    break;\\n                }\\n                for(int d = 0;d < 4; d++) {\\n                    int x = i + dir[d][0];\\n                    int y = j + dir[d][1];\\n                    if(x >= 0 && y >= 0 && x < m && y < n && grid[x][y] != 0){\\n                        pq.push({grid[x][y], x, y});\\n                         grid[x][y] = 0;\\n                    }\\n                }\\n            }\\n            mp[q] = res;\\n        }\\n        for(auto q: queries) result.push_back(mp[q]);\\n        return result; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902446,
                "title": "explained-c-modified-bfs",
                "content": "# Intuition\\nBasically, you have to find for <b>each node</b> what is the <b>biggest element</b> in the best path from the left top corner, where <b>best</b> means that is a path that contains the smallest maximum value.\\n\\n# Approach\\nI used a BFS modified in such a way that it prioritizes the nodes that have the smallest values. So, I will always go on the <b>best</b> path, and the maximum element will always be the global maximum seen in all paths, because the previous paths have a maximum that is <= than the current one, for sure.\\n\\nAfter mapping each maximum with the number of nodes that can be reached from left top having exactly that value as the greatest value in the path, I created a prefix array to also know how many nodes are reachable by using maximums that are smaller than the current one.\\n\\n# Complexity\\n- Time complexity: ($V$ is the number of nodes, $n * m$ and $E$ is the number of edges, $4 * m * n$)\\n    - precomputing:\\n        - BFS: $$O(E + V + V * log(V))$$\\n            - $O(V * log(V))$ for the pq (each node is added and removed only once from the priority queue)\\n            - $O(E)$ because all edges are explored\\n            - $O(V)$ because while executes constant time operations for each node (vertex)\\n        - prefix array: $O(1)$ (always has 10^6 elements)\\n    - queries: $O(1)$ for each query\\n\\n- Space complexity:\\n    - $O(m * n)$, to keep the priority queue\\n    - $O(1)$ for the two additional arrays, which always have $10^6$ elements\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        // use a bfs and prioritiize smallest nodes\\n        // in order to associate each node with the smallest value\\n        // needed to be reached from the starting point\\n        \\n        // then, keep an array of 10^6 elements in order to know\\n        // how many nodes are reachable with some maximum value\\n        // allowed (the index will represent the query value)\\n        vector<int> stats((int)(1e6 + 1), 0);\\n        \\n        int maxValReached = grid[0][0];\\n        priority_queue<pair<int, pair<int, int>>> pq;\\n        pq.push({-grid[0][0], {0, 0}});\\n        grid[0][0] = -1;\\n        \\n        while (!pq.empty()) {\\n            auto current = pq.top();\\n            pq.pop();\\n            \\n            maxValReached = max(maxValReached, -current.first);\\n            stats[maxValReached] += 1;\\n            \\n            static int dx[] = {-1, 1, 0, 0};\\n            static int dy[] = {0, 0, -1, 1};\\n            \\n            for (int i = 0; i < 4; ++i) {\\n                int x = current.second.first + dx[i];\\n                int y = current.second.second + dy[i];\\n                \\n                if (x >= 0 && y >= 0 && x < grid.size() && y < grid[0].size()) {\\n                    if (grid[x][y] > 0) {\\n                        pq.push({-grid[x][y], {x, y}});\\n                        \\n                        grid[x][y] = -1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // create a prefix sum array for fast queries\\n        vector<int> pref(1, stats[0]);\\n        for (int i = 1; i < stats.size(); ++i) {\\n            pref.push_back(pref[i - 1] + stats[i]);\\n        }\\n        \\n        // now retrieve the results, based on queries\\n        vector<int> res;\\n        for (int it : queries) {\\n            res.push_back(pref[it - 1]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Heap (Priority Queue)",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        // use a bfs and prioritiize smallest nodes\\n        // in order to associate each node with the smallest value\\n        // needed to be reached from the starting point\\n        \\n        // then, keep an array of 10^6 elements in order to know\\n        // how many nodes are reachable with some maximum value\\n        // allowed (the index will represent the query value)\\n        vector<int> stats((int)(1e6 + 1), 0);\\n        \\n        int maxValReached = grid[0][0];\\n        priority_queue<pair<int, pair<int, int>>> pq;\\n        pq.push({-grid[0][0], {0, 0}});\\n        grid[0][0] = -1;\\n        \\n        while (!pq.empty()) {\\n            auto current = pq.top();\\n            pq.pop();\\n            \\n            maxValReached = max(maxValReached, -current.first);\\n            stats[maxValReached] += 1;\\n            \\n            static int dx[] = {-1, 1, 0, 0};\\n            static int dy[] = {0, 0, -1, 1};\\n            \\n            for (int i = 0; i < 4; ++i) {\\n                int x = current.second.first + dx[i];\\n                int y = current.second.second + dy[i];\\n                \\n                if (x >= 0 && y >= 0 && x < grid.size() && y < grid[0].size()) {\\n                    if (grid[x][y] > 0) {\\n                        pq.push({-grid[x][y], {x, y}});\\n                        \\n                        grid[x][y] = -1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // create a prefix sum array for fast queries\\n        vector<int> pref(1, stats[0]);\\n        for (int i = 1; i < stats.size(); ++i) {\\n            pref.push_back(pref[i - 1] + stats[i]);\\n        }\\n        \\n        // now retrieve the results, based on queries\\n        vector<int> res;\\n        for (int it : queries) {\\n            res.push_back(pref[it - 1]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902415,
                "title": "java-unionfind-solution",
                "content": "```\\nclass Solution {\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0 || queries == null || queries.length == 0) {\\n            return new int[1];\\n        }\\n\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] result = new int[queries.length];\\n\\n        int[][] q = new int[queries.length][2];\\n        for (int i = 0; i < queries.length; i++) {\\n            q[i] = new int[]{queries[i], i}; // val, index\\n        }\\n        Arrays.sort(q, Comparator.comparingInt(a -> a[0]));\\n\\n        int[][] g = new int[m * n][2];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int index = i * n + j;\\n                int value = grid[i][j];\\n                g[index] = new int[]{value, index}; // val, index\\n            }\\n        }\\n        Arrays.sort(g, Comparator.comparingInt(a -> a[0]));\\n\\n        UnionFind uf = new UnionFind(m * n);\\n        int j = 0;\\n        for (int[] query : q) {\\n            int value = query[0];\\n            int queryIndex = query[1];\\n            while (j < g.length && g[j][0] < value) {\\n                connectNeighbors(g[j][1], m, n, uf, value, grid);\\n                j++;\\n            }\\n            if (value > grid[0][0]) {\\n                result[queryIndex] = uf.size(0);\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private void connectNeighbors(int index, int m, int n, UnionFind uf, int value, int[][] grid) {\\n        int x = index / n;\\n        int y = index % n;\\n\\n        int[][] dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        for (int[] d : dir) {\\n            int newX = x + d[0];\\n            int newY = y + d[1];\\n            if (newX >= 0 && newX < m && newY >= 0 && newY < n && grid[newX][newY] < value) {\\n                uf.union(index, newX * n + newY);\\n            }\\n        }\\n    }\\n\\n    class UnionFind {\\n        private int[] root;\\n        private int[] size;\\n        public UnionFind(int n) {\\n            root = new int[n];\\n            size = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                root[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        public void union(int x, int y) {\\n            int rootX = find(x);\\n            int rootY = find(y);\\n\\n            if (rootX < rootY) {\\n                root[rootY] = rootX;\\n                size[rootX] += size[rootY];\\n            } else if (rootX > rootY){\\n                root[rootX] = rootY;\\n                size[rootY] += size[rootX];\\n            }\\n        }\\n        public int find(int x) {\\n            if (root[x] == x) {\\n                return x;\\n            }\\n            return find(root[x]);\\n        }\\n        public int size(int x) {\\n            return size[x];\\n        }\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0 || queries == null || queries.length == 0) {\\n            return new int[1];\\n        }\\n\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] result = new int[queries.length];\\n\\n        int[][] q = new int[queries.length][2];\\n        for (int i = 0; i < queries.length; i++) {\\n            q[i] = new int[]{queries[i], i}; // val, index\\n        }\\n        Arrays.sort(q, Comparator.comparingInt(a -> a[0]));\\n\\n        int[][] g = new int[m * n][2];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int index = i * n + j;\\n                int value = grid[i][j];\\n                g[index] = new int[]{value, index}; // val, index\\n            }\\n        }\\n        Arrays.sort(g, Comparator.comparingInt(a -> a[0]));\\n\\n        UnionFind uf = new UnionFind(m * n);\\n        int j = 0;\\n        for (int[] query : q) {\\n            int value = query[0];\\n            int queryIndex = query[1];\\n            while (j < g.length && g[j][0] < value) {\\n                connectNeighbors(g[j][1], m, n, uf, value, grid);\\n                j++;\\n            }\\n            if (value > grid[0][0]) {\\n                result[queryIndex] = uf.size(0);\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private void connectNeighbors(int index, int m, int n, UnionFind uf, int value, int[][] grid) {\\n        int x = index / n;\\n        int y = index % n;\\n\\n        int[][] dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        for (int[] d : dir) {\\n            int newX = x + d[0];\\n            int newY = y + d[1];\\n            if (newX >= 0 && newX < m && newY >= 0 && newY < n && grid[newX][newY] < value) {\\n                uf.union(index, newX * n + newY);\\n            }\\n        }\\n    }\\n\\n    class UnionFind {\\n        private int[] root;\\n        private int[] size;\\n        public UnionFind(int n) {\\n            root = new int[n];\\n            size = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                root[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        public void union(int x, int y) {\\n            int rootX = find(x);\\n            int rootY = find(y);\\n\\n            if (rootX < rootY) {\\n                root[rootY] = rootX;\\n                size[rootX] += size[rootY];\\n            } else if (rootX > rootY){\\n                root[rootX] = rootY;\\n                size[rootY] += size[rootX];\\n            }\\n        }\\n        public int find(int x) {\\n            if (root[x] == x) {\\n                return x;\\n            }\\n            return find(root[x]);\\n        }\\n        public int size(int x) {\\n            return size[x];\\n        }\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902405,
                "title": "python-solution-beats-100",
                "content": "\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m,n = len(grid), len(grid[0])\\n        q = sorted(queries)\\n        h = defaultdict(int)\\n        temp = [ [grid[0][0],0,0] ]\\n        heapq.heapify(temp)\\n        visited = set([(0,0)])\\n        res = 0\\n        i = 0\\n        while i < len(queries):\\n            while temp and temp[0][0] < q[i]:\\n                res += 1\\n                x,y,z = heapq.heappop(temp)\\n                for a,b in (1,0),(0,1),(-1,0),(0,-1):\\n                    aa = a+y\\n                    bb= b+z\\n                    if 0<=aa<m and 0<=bb<n and (aa,bb) not in visited:\\n                        heapq.heappush(temp, [grid[aa][bb],aa,bb])\\n                        visited.add((aa,bb))\\n            h[q[i]] = res\\n            i += 1\\n        print(h)\\n        arr = []\\n        for i in queries:\\n            arr.append(h[i])\\n        return arr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m,n = len(grid), len(grid[0])\\n        q = sorted(queries)\\n        h = defaultdict(int)\\n        temp = [ [grid[0][0],0,0] ]\\n        heapq.heapify(temp)\\n        visited = set([(0,0)])\\n        res = 0\\n        i = 0\\n        while i < len(queries):\\n            while temp and temp[0][0] < q[i]:\\n                res += 1\\n                x,y,z = heapq.heappop(temp)\\n                for a,b in (1,0),(0,1),(-1,0),(0,-1):\\n                    aa = a+y\\n                    bb= b+z\\n                    if 0<=aa<m and 0<=bb<n and (aa,bb) not in visited:\\n                        heapq.heappush(temp, [grid[aa][bb],aa,bb])\\n                        visited.add((aa,bb))\\n            h[q[i]] = res\\n            i += 1\\n        print(h)\\n        arr = []\\n        for i in queries:\\n            arr.append(h[i])\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902384,
                "title": "java-just-in-time-search-faster-than-100",
                "content": "# Intuition\\nScores will be weakly ascending with the query, because if a query q is blocked from reaching certain blocks, then certainly q - 1 will do no better.  Additionally, the key values where score actually increases are 1 more than the values in the grid (because the query must be strictly greater to add a point and explore further).  So, we can pre-compute scores for the transition points and use this to quickly determine a given score.\\n\\nBut, do we need to explore for **_every_** grid value when we could explore only the values we might actually encounter?  And do we need to explore beyond the highest query we have encountered so far?  The answer to both these questions is no.  We can do our exploration \"just in time\" and remember the results for future queries, exploring further in the grid only when we reach a query higher than any we have handled before.\\n\\nFor example, suppose my upper-left value in the grid is 7.  Until I reach a query of 8 or higher, there is no need to explore the grid any further.  Once I do, there is no need to explore values higher than 8 until we have a query which is higher yet.\\n\\n# Approach\\nWe store scores in a `TreeMap` called `scoreMap`, so we can use the floor for score lookups.  We initialize the score map to include the mapping `{0=0}`.  We track another `TreeMap` called `trailheads` which maps values to the points containing those values, which would be next for exploration (from least grid value to greatest).  Then, until we get a query large enough to score any points (must be higher than `grid[0][0]`), we **do not explore at all**.  In fact, we track the `lastLevel` (lowest value explored which is no less than the largest query so far) which starts at `0`.  When we exceed this `lastLevel`, if the `trailheads` map is not empty, we explore the next lowest value, stopping when our `lastLevel` explored is no longer less than the query.  Then we can reply to the query by looking in our `scoreMap`.  Thus cuts down on unnecessary exploration in cases where queries are insufficient to cover much of the grid.\\n\\nIn other words, while pre-processing would make sure we only explored each grid location exactly once, our just-in-time approach makes sure we only explore each grid location **at most once** (once _if we will use it for a query_ or zero times _if we will not_).\\n\\n# Complexity\\nLet p = mn.  Then in the worst cases, we have O(p log p) insertions in our score map, and we have O(k log p) from queries.  We also have p entries move through the trailheads map, which is also O(p log p).  And we have an O(p) search.  So, if q is the maximum of p and k (the maximum of the grid size mn and the number of queries k) then our **time complexity is O(q log p)**.  In the worst case, our **space complexity is O(p)** for p map entries in two tree maps.\\n\\nIt should be said, however, that this approach takes full advantage of non-worst-case data.  For example, if all queries are less than the upper-left grid value, our complexity is O(k).  Or, suppose `grid[0][0]` is the largest value.  Then we have O(mn) to explore the rest of the grid the first time the query exceeds `grid[0][0]`.  So, for non-worst-case data, this approach has a few opportunities to shine (based on non-worst-case query data and/or non-worst-case grid data).\\n\\n# Java Code\\n```\\nclass Solution {\\n\\n    static final int[][] DIRS = new int[][] { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\\n\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        final int m = grid.length;\\n        final int n = grid[0].length;\\n        final int k = queries.length;\\n        final TreeMap<Integer, Integer> scoreMap = new TreeMap<>();\\n        final boolean[][] visited = new boolean[m][n];\\n        scoreMap.put(0, 0);\\n        final TreeMap<Integer, Set<List<Integer>>> trailheads = new TreeMap<>();\\n        int score = 0;\\n        trailheads.computeIfAbsent(grid[0][0], (key) -> new LinkedHashSet<>()).add(List.of(0, 0));\\n        int lastLevel = 0;\\n        final int[] replies = new int[k];\\n        for (int i = 0; i < k; ++i) {\\n            final int query = queries[i];\\n            // Just-in-time search:\\n            while (query > lastLevel && !trailheads.isEmpty()) {\\n                final Map.Entry<Integer, Set<List<Integer>>> entry = trailheads.pollFirstEntry();\\n                final int level = entry.getKey() + 1;\\n                for (List<Integer> point : entry.getValue()) {\\n                    score += explore(level, grid, visited, point.get(0), point.get(1), trailheads);\\n                }\\n                scoreMap.put(level, score);\\n                lastLevel = level;\\n            }\\n            // Now we\\'ve searched all values or all values less than or\\n            // equal to the query, so we can look up the score.\\n            replies[i] = scoreMap.floorEntry(queries[i]).getValue();\\n        }\\n        return replies;\\n    }\\n\\n    private int explore(int level, int[][] grid, boolean[][] visited, int r, int c, Map<Integer, Set<List<Integer>>> trailheads) {\\n        int score = 0;\\n        if (r < 0 || c < 0 || r >= grid.length || c >= grid[r].length || visited[r][c]) {\\n            return score;\\n        }\\n        if (grid[r][c] < level) {\\n            score++;\\n            visited[r][c] = true;\\n            for (int[] dir : DIRS) {\\n                score += explore(level, grid, visited, r + dir[0], c + dir[1], trailheads);\\n            }\\n        } else {\\n            trailheads.computeIfAbsent(grid[r][c], (key) -> new LinkedHashSet<>()).add(List.of(r, c));\\n        }\\n        return score;\\n    }\\n\\n}\\n\\n```\\n# Runtime\\n105 ms as of Dec 11, 2022 (faster than 100%).\\n\\n# Standard Plea\\nIf you found this solution helpful, interesting, or at least not a waste of your time, **I would appreciate your upvote.**  If you have constructive criticism, **I would appreciate you posting it in the comments** so I can write better solutions.\\n\\nThanks for reading, and happy coding!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n    static final int[][] DIRS = new int[][] { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\\n\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        final int m = grid.length;\\n        final int n = grid[0].length;\\n        final int k = queries.length;\\n        final TreeMap<Integer, Integer> scoreMap = new TreeMap<>();\\n        final boolean[][] visited = new boolean[m][n];\\n        scoreMap.put(0, 0);\\n        final TreeMap<Integer, Set<List<Integer>>> trailheads = new TreeMap<>();\\n        int score = 0;\\n        trailheads.computeIfAbsent(grid[0][0], (key) -> new LinkedHashSet<>()).add(List.of(0, 0));\\n        int lastLevel = 0;\\n        final int[] replies = new int[k];\\n        for (int i = 0; i < k; ++i) {\\n            final int query = queries[i];\\n            // Just-in-time search:\\n            while (query > lastLevel && !trailheads.isEmpty()) {\\n                final Map.Entry<Integer, Set<List<Integer>>> entry = trailheads.pollFirstEntry();\\n                final int level = entry.getKey() + 1;\\n                for (List<Integer> point : entry.getValue()) {\\n                    score += explore(level, grid, visited, point.get(0), point.get(1), trailheads);\\n                }\\n                scoreMap.put(level, score);\\n                lastLevel = level;\\n            }\\n            // Now we\\'ve searched all values or all values less than or\\n            // equal to the query, so we can look up the score.\\n            replies[i] = scoreMap.floorEntry(queries[i]).getValue();\\n        }\\n        return replies;\\n    }\\n\\n    private int explore(int level, int[][] grid, boolean[][] visited, int r, int c, Map<Integer, Set<List<Integer>>> trailheads) {\\n        int score = 0;\\n        if (r < 0 || c < 0 || r >= grid.length || c >= grid[r].length || visited[r][c]) {\\n            return score;\\n        }\\n        if (grid[r][c] < level) {\\n            score++;\\n            visited[r][c] = true;\\n            for (int[] dir : DIRS) {\\n                score += explore(level, grid, visited, r + dir[0], c + dir[1], trailheads);\\n            }\\n        } else {\\n            trailheads.computeIfAbsent(grid[r][c], (key) -> new LinkedHashSet<>()).add(List.of(r, c));\\n        }\\n        return score;\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902276,
                "title": "short-python-solution-tc-o-mnlog-mn-len-queries",
                "content": "For 1 query, we do BFS to find the result for 1 query. The time complexity is O(mn), where m, n are the dimentions of the matrix.\\nFor k queries, if we repeat that, the complexity would be m*n*k, which is too big.\\nObservation:\\n- If we start the queries from the smallest to the larger one, then we don\\'t have to start the BFS from the beginning but we can continue where we left off. Then even if we do k queries, the complexity would be O(mn+k). But how can we continue where we left off? We have to loop through all the elements left in the queue (the queue is the one you usually use for BFS) and see which cells you can continue, right? But then the queue could be very large too. Imagine the matrix is structured in such a way that the values are smaller at the boundaries and get larger and larger when going towards the center, then the queue would look like a square inside the matrix. A more efficient way is to be able to start from the smallest element in the queue. Then we should use a min heap instead of a normal queue. That way, when we continue where we left off, we immediately know which cell we want to start expanding. \\nCode:\\n```\\nfrom heapq import *\\n\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        k = len(queries)\\n        ans = [0]*k\\n        result = [0]*(10**6+1)\\n        m, n = len(grid), len(grid[0])\\n        h = [(grid[0][0], 0, 0)]\\n        dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]\\n        visited = set([(0, 0)])\\n        for i in range(1, 10**6+1):\\n            result[i] = result[i-1]\\n            while h and h[0][0] < i:\\n                v, x, y = heappop(h)\\n                result[i] += 1\\n                for dx, dy in dirs:\\n                    nx, ny = x + dx, y + dy\\n                    if nx >= 0 and nx < m and ny >= 0 and ny < n and (nx, ny) not in visited:\\n                        visited.add((nx, ny))\\n                        heappush(h, (grid[nx][ny], nx, ny))\\n        for i in range(k):\\n            ans[i] = result[queries[i]]\\n        return ans\\n```\\nTC: O(mnlog(mn)+k)\\nSC: O(mn+k), mn for the heap, k = len(queries)",
                "solutionTags": [],
                "code": "```\\nfrom heapq import *\\n\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        k = len(queries)\\n        ans = [0]*k\\n        result = [0]*(10**6+1)\\n        m, n = len(grid), len(grid[0])\\n        h = [(grid[0][0], 0, 0)]\\n        dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]\\n        visited = set([(0, 0)])\\n        for i in range(1, 10**6+1):\\n            result[i] = result[i-1]\\n            while h and h[0][0] < i:\\n                v, x, y = heappop(h)\\n                result[i] += 1\\n                for dx, dy in dirs:\\n                    nx, ny = x + dx, y + dy\\n                    if nx >= 0 and nx < m and ny >= 0 and ny < n and (nx, ny) not in visited:\\n                        visited.add((nx, ny))\\n                        heappush(h, (grid[nx][ny], nx, ny))\\n        for i in range(k):\\n            ans[i] = result[queries[i]]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902233,
                "title": "sort-stop-and-go-dfs",
                "content": "# Intuition\\nSort the queries and values of the grid and count the number of cells we can visit by \"stop-and-go\" DFS.\\n\\n# Approach\\n1. Sort the queries but keep track of the original indices in order to construct the answer\\n2. Sort the values of the grid but keep track of the indices\\n3. As we go through the queries in ascending order, add the newly available cells of the grid back to `avail`.\\n4. \"stop-and-go\" DFS: As we make more cells available, new paths may open up for DFS. Such paths must start somewhere though: From a visited cell. So, we only need restart DFS from a newly available cell that is adjacent to a visited one, or the  top left cell.\\n\\n# Complexity\\n- Time complexity:\\n$$O(m \\\\cdot n  \\\\cdot \\\\log(m \\\\cdot n))$$\\n\\n- Space complexity:\\n$$O(m \\\\cdot n )$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        ans = [None] * len(queries)\\n        x_i = sorted((x, i) for i, x in enumerate(queries))\\n        m, n = len(grid), len(grid[0])\\n        x_i_j = sorted((grid[i][j], i, j) for i in range(m) for j in range(n))\\n        self.count = 0\\n        visited = [[False] * n for _ in range(m)]\\n        avail = [[False] * n for _ in range(m)]\\n        index = 0\\n        def dfs(i, j):\\n            neighbors = [(x, y) for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)] if 0 <= x < m and 0 <= y < n]\\n            if avail[i][j] and not visited[i][j] and ((i, j) == (0, 0) or any(visited[x][y] for x, y in neighbors)):\\n                self.count += 1\\n                visited[i][j] = True\\n                for x, y in neighbors:\\n                    dfs(x, y)\\n\\n        for x, k in x_i:\\n            while index < m * n and x_i_j[index][0] < x:\\n                _, i, j = x_i_j[index]\\n                index += 1\\n                avail[i][j] = True\\n                dfs(i, j)\\n            ans[k] = self.count\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        ans = [None] * len(queries)\\n        x_i = sorted((x, i) for i, x in enumerate(queries))\\n        m, n = len(grid), len(grid[0])\\n        x_i_j = sorted((grid[i][j], i, j) for i in range(m) for j in range(n))\\n        self.count = 0\\n        visited = [[False] * n for _ in range(m)]\\n        avail = [[False] * n for _ in range(m)]\\n        index = 0\\n        def dfs(i, j):\\n            neighbors = [(x, y) for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)] if 0 <= x < m and 0 <= y < n]\\n            if avail[i][j] and not visited[i][j] and ((i, j) == (0, 0) or any(visited[x][y] for x, y in neighbors)):\\n                self.count += 1\\n                visited[i][j] = True\\n                for x, y in neighbors:\\n                    dfs(x, y)\\n\\n        for x, k in x_i:\\n            while index < m * n and x_i_j[index][0] < x:\\n                _, i, j = x_i_j[index]\\n                index += 1\\n                avail[i][j] = True\\n                dfs(i, j)\\n            ans[k] = self.count\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902218,
                "title": "modified-bfs-using-heap-beats-100-runtime-and-memory-c",
                "content": "# Intuition\\nModifying BFS and accessing each query in ascending order. The main idea is, the number of nodes covered by a larger number in query will cover all the nodes accessed under a smaller number plus some extra nodes. Secondly, you can not cover all nodes, if have to start traversal from top left and see what is the max ans.\\n\\n# Approach\\nI have modified the normal BFS approach by using a priority queue in place of a normal queue. First sort all the queries so that they are accessed in ascending order. Start from the top left node and store the adjacent nodes in the priority queue. Access only those nodes which are smaller than the current query value otherwise increment for getting a higher value. At the end, just add the values covered by a smaller query number in the larger number.\\n\\n# Complexity\\n- Time complexity:O(m*n*log(m*n))\\n\\n- Space complexity: O(m*n)\\n\\n# Code\\n```\\ntypedef pair<int, pair<int, int>> node;\\nclass Solution {\\npublic:\\n    int dx[4]={-1, 0, 1, 0};\\n    int dy[4]={0, 1, 0, -1};\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int k=queries.size();\\n        vector<vector<int>>arr;\\n        for(int i=0;i<k;i++){\\n            arr.push_back({queries[i], i, 0});\\n        }\\n        sort(arr.begin(), arr.end());\\n        \\n        priority_queue<node, vector<node>, greater<node>>pq;\\n        pq.push({grid[0][0], {0, 0}});\\n        grid[0][0]=-1;\\n        \\n        int i=0;\\n        vector<int>ans(k);\\n        while(!pq.empty() and i<k){\\n            auto f=pq.top();\\n            pq.pop();\\n            int val=f.first;\\n            int x=f.second.first;\\n            int y=f.second.second;\\n            \\n            while(i<k and arr[i][0]<=val){\\n                i++;\\n            }\\n            if(i==k)break;\\n            \\n            arr[i][2]++;\\n            for(int dir=0;dir<4;dir++){\\n                int ii=x+dx[dir], jj=y+dy[dir];\\n                if(ii>=0 and jj>=0 and ii<grid.size() and jj<grid[0].size() and grid[ii][jj]!=-1){\\n                    pq.push({grid[ii][jj], {ii, jj}});\\n                    grid[ii][jj]=-1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<k;i++){\\n            arr[i][2]+=arr[i-1][2];\\n        }\\n        for(int i=0;i<k;i++){\\n            ans[arr[i][1]]=arr[i][2];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntypedef pair<int, pair<int, int>> node;\\nclass Solution {\\npublic:\\n    int dx[4]={-1, 0, 1, 0};\\n    int dy[4]={0, 1, 0, -1};\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int k=queries.size();\\n        vector<vector<int>>arr;\\n        for(int i=0;i<k;i++){\\n            arr.push_back({queries[i], i, 0});\\n        }\\n        sort(arr.begin(), arr.end());\\n        \\n        priority_queue<node, vector<node>, greater<node>>pq;\\n        pq.push({grid[0][0], {0, 0}});\\n        grid[0][0]=-1;\\n        \\n        int i=0;\\n        vector<int>ans(k);\\n        while(!pq.empty() and i<k){\\n            auto f=pq.top();\\n            pq.pop();\\n            int val=f.first;\\n            int x=f.second.first;\\n            int y=f.second.second;\\n            \\n            while(i<k and arr[i][0]<=val){\\n                i++;\\n            }\\n            if(i==k)break;\\n            \\n            arr[i][2]++;\\n            for(int dir=0;dir<4;dir++){\\n                int ii=x+dx[dir], jj=y+dy[dir];\\n                if(ii>=0 and jj>=0 and ii<grid.size() and jj<grid[0].size() and grid[ii][jj]!=-1){\\n                    pq.push({grid[ii][jj], {ii, jj}});\\n                    grid[ii][jj]=-1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<k;i++){\\n            arr[i][2]+=arr[i-1][2];\\n        }\\n        for(int i=0;i<k;i++){\\n            ans[arr[i][1]]=arr[i][2];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901899,
                "title": "c-normal-bfs-sorted-border-using-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBFS from small values to large values.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a heap to store the border of the BFS, and when it\\'s time to explore the next bigger value, pop the heap to populate the queue which will then be used to do normal BFS.\\n\\nDuring the process of normal BFS, we also need to add cells into the border if its value is not smaller than the current value we are considering.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(m*n*log(m + n))$$ as the number of elements in heap will not exceed $$m + n$$, however, there are at most $$m * n$$ heap operations.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int m = grid.size(), n = grid[0].size(), k = queries.size();\\n        vector<int> vec(k);\\n        for (int i = 0; i < k; i++) vec[i] = i;\\n        sort(vec.begin(), vec.end(), [&](int left, int right) -> bool { return queries[left] < queries[right]; });\\n        sort(queries.begin(), queries.end());\\n        vector<int> ans(k, 0);\\n        queue<pair<int, int>> q;\\n        bool visit[m][n];\\n        memset(visit, 0, sizeof(visit));\\n        bool in_border[m][n];\\n        memset(in_border, 0, sizeof(in_border));\\n        auto cmp = [&](const pair<int, int>& left, const pair<int, int>& right) -> bool {\\n            return grid[left.first][left.second] > grid[right.first][right.second];\\n        };\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> border(cmp);\\n        border.push(make_pair(0, 0));\\n        int cnt = 0;\\n        vector<pair<int, int>> moves{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        for (int i = 0; i < k; i++) {\\n            int val = queries[i];\\n            int j = vec[i];\\n            \\n            while (!border.empty()) {\\n                auto [x, y] = border.top();\\n                if (grid[x][y] < val) {\\n                    border.pop();\\n                    q.push(make_pair(x, y));\\n                    visit[x][y] = true;\\n                    cnt += 1;\\n                } else {\\n                    break;\\n                }\\n            }\\n        \\n            while (!q.empty()) {\\n                auto [x, y] = q.front();\\n                q.pop();\\n                for (const auto& [dx, dy] : moves) {\\n                    int r = x + dx;\\n                    int c = y + dy;\\n                    if (r >= 0 && r < m && c >= 0 && c < n && !visit[r][c]) {\\n                        if (grid[r][c] < val) {\\n                            q.push(make_pair(r, c));\\n                            visit[r][c] = true;\\n                            cnt += 1;\\n                        } else if (!in_border[r][c]) {\\n                            border.push(make_pair(r, c));\\n                            in_border[r][c] = true;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            ans[j] = cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int m = grid.size(), n = grid[0].size(), k = queries.size();\\n        vector<int> vec(k);\\n        for (int i = 0; i < k; i++) vec[i] = i;\\n        sort(vec.begin(), vec.end(), [&](int left, int right) -> bool { return queries[left] < queries[right]; });\\n        sort(queries.begin(), queries.end());\\n        vector<int> ans(k, 0);\\n        queue<pair<int, int>> q;\\n        bool visit[m][n];\\n        memset(visit, 0, sizeof(visit));\\n        bool in_border[m][n];\\n        memset(in_border, 0, sizeof(in_border));\\n        auto cmp = [&](const pair<int, int>& left, const pair<int, int>& right) -> bool {\\n            return grid[left.first][left.second] > grid[right.first][right.second];\\n        };\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> border(cmp);\\n        border.push(make_pair(0, 0));\\n        int cnt = 0;\\n        vector<pair<int, int>> moves{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        for (int i = 0; i < k; i++) {\\n            int val = queries[i];\\n            int j = vec[i];\\n            \\n            while (!border.empty()) {\\n                auto [x, y] = border.top();\\n                if (grid[x][y] < val) {\\n                    border.pop();\\n                    q.push(make_pair(x, y));\\n                    visit[x][y] = true;\\n                    cnt += 1;\\n                } else {\\n                    break;\\n                }\\n            }\\n        \\n            while (!q.empty()) {\\n                auto [x, y] = q.front();\\n                q.pop();\\n                for (const auto& [dx, dy] : moves) {\\n                    int r = x + dx;\\n                    int c = y + dy;\\n                    if (r >= 0 && r < m && c >= 0 && c < n && !visit[r][c]) {\\n                        if (grid[r][c] < val) {\\n                            q.push(make_pair(r, c));\\n                            visit[r][c] = true;\\n                            cnt += 1;\\n                        } else if (!in_border[r][c]) {\\n                            border.push(make_pair(r, c));\\n                            in_border[r][c] = true;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            ans[j] = cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901886,
                "title": "using-priority-queue-easy-approach-short-code-beginner-friendly",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n->manipulate query  i.e. put the query and index into a vector then sort it \\n->create a min priority queue \\n-> pop element from min priority queue one by one until top element is smaller than current query\\n->create global count variable which will be increased every time when priority queue\\'s top element is smaller than query value\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int m=grid.size(), n= grid[0].size();\\n        vector<pair<int,int>>vp;\\n        for(int i =0;i<queries.size();i++){\\n            vp.push_back({queries[i],i});\\n        }\\n\\n        //sort queries\\n        sort(vp.begin(),vp.end());\\n        vector<int>ans(queries.size());\\n        vector<vector<int>>vis(m,vector<int>(n,0));\\n        //priority queue of tuple grid, i , j\\n    \\n    priority_queue<tuple<int,int,int>, vector<tuple<int,int,int>>,\\n     greater<tuple<int,int,int>>>pq;\\n    pq.push({grid[0][0],0,0});\\n    vis[0][0]=1;\\n        int cnt=0;\\n        int dr[]= {0,1,0,-1};\\n        int dc[]={-1,0,1,0};\\n        for(auto [val,idx]: vp){\\n           while(pq.size()){\\n             auto [v,i,j] = pq.top();\\n                   if(v>= val) break;\\n                   else pq.pop(), cnt++;\\n                    if(i-1 >= 0 and !vis[i-1][j]) \\n                    pq.push({grid[i-1][j],i-1,j}), vis[i-1][j] = 1;\\n                if(j-1 >= 0 and !vis[i][j-1]) \\n                pq.push({grid[i][j-1],i,j-1}), vis[i][j-1] = 1;\\n                if(i+1 <  m and !vis[i+1][j]) \\n                pq.push({grid[i+1][j],i+1,j}), vis[i+1][j] = 1;\\n                if(j+1 <  n and !vis[i][j+1]) \\n                pq.push({grid[i][j+1],i,j+1}), vis[i][j+1] = 1;\\n               \\n           }\\n           ans[idx]=cnt;\\n\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int m=grid.size(), n= grid[0].size();\\n        vector<pair<int,int>>vp;\\n        for(int i =0;i<queries.size();i++){\\n            vp.push_back({queries[i],i});\\n        }\\n\\n        //sort queries\\n        sort(vp.begin(),vp.end());\\n        vector<int>ans(queries.size());\\n        vector<vector<int>>vis(m,vector<int>(n,0));\\n        //priority queue of tuple grid, i , j\\n    \\n    priority_queue<tuple<int,int,int>, vector<tuple<int,int,int>>,\\n     greater<tuple<int,int,int>>>pq;\\n    pq.push({grid[0][0],0,0});\\n    vis[0][0]=1;\\n        int cnt=0;\\n        int dr[]= {0,1,0,-1};\\n        int dc[]={-1,0,1,0};\\n        for(auto [val,idx]: vp){\\n           while(pq.size()){\\n             auto [v,i,j] = pq.top();\\n                   if(v>= val) break;\\n                   else pq.pop(), cnt++;\\n                    if(i-1 >= 0 and !vis[i-1][j]) \\n                    pq.push({grid[i-1][j],i-1,j}), vis[i-1][j] = 1;\\n                if(j-1 >= 0 and !vis[i][j-1]) \\n                pq.push({grid[i][j-1],i,j-1}), vis[i][j-1] = 1;\\n                if(i+1 <  m and !vis[i+1][j]) \\n                pq.push({grid[i+1][j],i+1,j}), vis[i+1][j] = 1;\\n                if(j+1 <  n and !vis[i][j+1]) \\n                pq.push({grid[i][j+1],i,j+1}), vis[i][j+1] = 1;\\n               \\n           }\\n           ans[idx]=cnt;\\n\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901878,
                "title": "python-sorting-bfs-with-pause-and-priority-queue",
                "content": "# Intuition\\nMy intuition is mess like problem it self, this problem has a lot of issues, from problem statement to python runnning time.\\nLets say that problem expects that input will be extremely optimistic :) and you write code in specific way that rely on that.\\n\\n# Approach\\nSort queries, used later to push step by step BFS, hold values in minimum priority qu and pick them up till they satisfy condition of being smaller then current query value.\\n\\n# Complexity\\n- Time complexity:\\nO(q log q) + O(n log n) ~ O( n log n + q log q), where q is number of queries and n is number of grid cells (rows x cols)\\n\\n- Space complexity:\\nO(n), n is number of grid cells (rows x cols)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPoints(self, g: List[List[int]], queries: List[int]) -> List[int]:\\n        qs = sorted([(v, i) for i, v in enumerate(queries)])\\n        R, C, Q, index = len(g), len(g[0]), len(qs), defaultdict(int)\\n        seen, curr = set(), 0\\n        pq = [(g[0][0], 0, 0)]        \\n        seen.add((0, 0))\\n        for val, i in qs:            \\n            while pq and pq[0][0] < val:\\n                _, r, c = heappop(pq)\\n                curr += 1\\n                for row, col in [(r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1)]:\\n                    if 0 <= row < R and 0 <= col < C and (row, col) not in seen:           \\n                        heappush(pq, (g[row][col], row, col))     \\n                        seen.add((row, col))\\n            index[i] = curr\\n        return [index[i] for i in range(Q)]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, g: List[List[int]], queries: List[int]) -> List[int]:\\n        qs = sorted([(v, i) for i, v in enumerate(queries)])\\n        R, C, Q, index = len(g), len(g[0]), len(qs), defaultdict(int)\\n        seen, curr = set(), 0\\n        pq = [(g[0][0], 0, 0)]        \\n        seen.add((0, 0))\\n        for val, i in qs:            \\n            while pq and pq[0][0] < val:\\n                _, r, c = heappop(pq)\\n                curr += 1\\n                for row, col in [(r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1)]:\\n                    if 0 <= row < R and 0 <= col < C and (row, col) not in seen:           \\n                        heappush(pq, (g[row][col], row, col))     \\n                        seen.add((row, col))\\n            index[i] = curr\\n        return [index[i] for i in range(Q)]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901729,
                "title": "java-100-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:N*M\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:N+M\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class Element{\\n        int row;\\n        int column;\\n        int value;\\n        public Element(int row, int column, int value)\\n        {\\n            this.row = row;\\n            this.column = column;\\n            this.value = value;\\n        }\\n    }\\n    class Pair{\\n        int value;\\n        int index;\\n        public Pair(int value, int index)\\n        {\\n            this.value = value;\\n            this.index=index;\\n        }\\n    }\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n\\n        Queue<Element> qu = new PriorityQueue<>((a,b)->a.value-b.value);\\n        ArrayList<Pair> querieList = new ArrayList<>();\\n        for(int i = 0;i<queries.length;i++)\\n        {\\n            querieList.add(new Pair(queries[i],i));\\n        }\\n        Collections.sort(querieList,(a,b)->a.value-b.value);\\n        qu.add(new Element(0,0,grid[0][0]));\\n        int[] dir = {-1,1,0,0};\\n        int[] dir1 = {0,0,-1,1};\\n        int points = 0;\\n        boolean [][] visited =new boolean[grid.length][grid[0].length];\\n        visited[0][0] = true;\\n        int[] result = new int[queries.length];\\n        for(int i = 0;i<querieList.size();i++)\\n        {\\n            while(!qu.isEmpty() && qu.peek().value<querieList.get(i).value)\\n            {\\n                points++;\\n                Element element = qu.poll();\\n               \\n                for(int j = 0;j<dir.length;j++)\\n                {\\n                    int nR = element.row+dir[j];\\n                    int nC = element.column+dir1[j];\\n                    if(nR>=0 && nR<grid.length &&  nC>=0&& nC<grid[0].length && visited[nR][nC]==false)\\n                    {\\n                        visited[nR][nC]= true;\\n                        qu.add(new Element(nR, nC, grid[nR][nC]));\\n                    }\\n                }\\n            }\\n            result[querieList.get(i).index] = points;\\n\\n        }\\n        return result;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Element{\\n        int row;\\n        int column;\\n        int value;\\n        public Element(int row, int column, int value)\\n        {\\n            this.row = row;\\n            this.column = column;\\n            this.value = value;\\n        }\\n    }\\n    class Pair{\\n        int value;\\n        int index;\\n        public Pair(int value, int index)\\n        {\\n            this.value = value;\\n            this.index=index;\\n        }\\n    }\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n\\n        Queue<Element> qu = new PriorityQueue<>((a,b)->a.value-b.value);\\n        ArrayList<Pair> querieList = new ArrayList<>();\\n        for(int i = 0;i<queries.length;i++)\\n        {\\n            querieList.add(new Pair(queries[i],i));\\n        }\\n        Collections.sort(querieList,(a,b)->a.value-b.value);\\n        qu.add(new Element(0,0,grid[0][0]));\\n        int[] dir = {-1,1,0,0};\\n        int[] dir1 = {0,0,-1,1};\\n        int points = 0;\\n        boolean [][] visited =new boolean[grid.length][grid[0].length];\\n        visited[0][0] = true;\\n        int[] result = new int[queries.length];\\n        for(int i = 0;i<querieList.size();i++)\\n        {\\n            while(!qu.isEmpty() && qu.peek().value<querieList.get(i).value)\\n            {\\n                points++;\\n                Element element = qu.poll();\\n               \\n                for(int j = 0;j<dir.length;j++)\\n                {\\n                    int nR = element.row+dir[j];\\n                    int nC = element.column+dir1[j];\\n                    if(nR>=0 && nR<grid.length &&  nC>=0&& nC<grid[0].length && visited[nR][nC]==false)\\n                    {\\n                        visited[nR][nC]= true;\\n                        qu.add(new Element(nR, nC, grid[nR][nC]));\\n                    }\\n                }\\n            }\\n            result[querieList.get(i).index] = points;\\n\\n        }\\n        return result;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901653,
                "title": "javascript-heap",
                "content": "# Intuition\\n\\nThe naive approach would be to initiate a search starting at (0, 0) for each query. However, this will surely lead to TLE. This suggests that we should sort the queries and perform a search within the grid that visits each cell at most once.  For each query in `sortedQueries` we visit cells in the grid that are less than that query. We push adjacent cells to a min heap that is designed to place the cell with the smallest value at the top of the heap.\\n\\n# Code\\n```\\nvar maxPoints = function (grid, queries) {\\n  const heap = new MinPriorityQueue({\\n    compare: ({ value: valueA }, { value: valueB }) => valueA - valueB,\\n  });\\n\\n  const enqueue = (r, c) => {\\n    if (\\n      0 <= r &&\\n      r < grid.length &&\\n      0 <= c &&\\n      c < grid[0].length &&\\n      grid[r][c] !== null\\n    ) {\\n      heap.enqueue({ row: r, col: c, value: grid[r][c] });\\n      grid[r][c] = null;\\n    }\\n  };\\n\\n  enqueue(0, 0);\\n\\n  let count = 0;\\n\\n  const map = {};\\n\\n  const sortedQueries = [...queries].sort((x, y) => x - y);\\n\\n  for (const query of sortedQueries) {\\n    while (!heap.isEmpty()) {\\n      const {row, col, value} = heap.front();\\n\\n      if (query <= value)\\n        break;\\n\\n      heap.dequeue();\\n\\n      ++count;\\n\\n      enqueue(row + 1, col);\\n      enqueue(row - 1, col);\\n      enqueue(row, col + 1);\\n      enqueue(row, col - 1);\\n    }\\n\\n    map[query] = count;\\n  }\\n\\n  return queries.map((query) => map[query]);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxPoints = function (grid, queries) {\\n  const heap = new MinPriorityQueue({\\n    compare: ({ value: valueA }, { value: valueB }) => valueA - valueB,\\n  });\\n\\n  const enqueue = (r, c) => {\\n    if (\\n      0 <= r &&\\n      r < grid.length &&\\n      0 <= c &&\\n      c < grid[0].length &&\\n      grid[r][c] !== null\\n    ) {\\n      heap.enqueue({ row: r, col: c, value: grid[r][c] });\\n      grid[r][c] = null;\\n    }\\n  };\\n\\n  enqueue(0, 0);\\n\\n  let count = 0;\\n\\n  const map = {};\\n\\n  const sortedQueries = [...queries].sort((x, y) => x - y);\\n\\n  for (const query of sortedQueries) {\\n    while (!heap.isEmpty()) {\\n      const {row, col, value} = heap.front();\\n\\n      if (query <= value)\\n        break;\\n\\n      heap.dequeue();\\n\\n      ++count;\\n\\n      enqueue(row + 1, col);\\n      enqueue(row - 1, col);\\n      enqueue(row, col + 1);\\n      enqueue(row, col - 1);\\n    }\\n\\n    map[query] = count;\\n  }\\n\\n  return queries.map((query) => map[query]);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2901632,
                "title": "bfs-binary-search-using-priority-queue-c-solution",
                "content": "# Approach\\n*Do ****bfs with least value**** first and then hash the max_till_now value with its size(number of nodes taken till now) to a map.\\ni have used ****priority queue**** of pair<int,pair<int,int>> with ****minimum heap****.\\nfor unique visiting i am replacing the ****grid[i][j] with -1**** after pushing and at time of pushing the values to priority queue we have to check if it is -1;\\nand **finally , doing Binary search** for getting final values from hashmap.\\nsaying it all let\\'s move to *time complexity.**\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n + k*log(size-of-map))$$ *which is nearly m*n\\n\\n- Space complexity:\\n$$in worst case - O(m*n)$$ *for map*\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef pair<int,pair<int,int>> P;\\n    int dir[5]={0,1,0,-1,0};\\n\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int m=grid.size(),n=grid[0].size();\\n        priority_queue<P, vector<P>, greater<P>> pq;\\n        map<int,int> mp;\\n        \\n        int total=0,mx_till_now=0;\\n        pq.push({grid[0][0],{0,0}});\\n        grid[0][0]=-1;\\n        while(!pq.empty()){\\n            auto f=pq.top();\\n            pq.pop();\\n\\n            total++;\\n            mx_till_now=max(mx_till_now,f.first);\\n            mp[mx_till_now]=total;\\n            cout<<mx_till_now<<\" \"<<total<<endl;\\n\\n            int i=f.second.first,j=f.second.second;\\n            for(int k=0;k<4;k++){\\n                int nx=i+dir[k];\\n                int ny=j+dir[k+1];\\n                if(nx>=0 && nx<m && ny>=0 && ny<n && grid[nx][ny]!=-1){\\n                    pq.push({grid[nx][ny],{nx,ny}});\\n                    grid[nx][ny]=-1;\\n                }\\n            }\\n        }\\n\\n        int k=queries.size();\\n        vector<int> ans(k);\\n        for(int i=0;i<k;i++){\\n            auto it=mp.lower_bound(queries[i]);\\n            if(it==mp.begin()) ans[i]=0;\\n            else{\\n                auto itr=prev(it);\\n                ans[i]=itr->second;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef pair<int,pair<int,int>> P;\\n    int dir[5]={0,1,0,-1,0};\\n\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int m=grid.size(),n=grid[0].size();\\n        priority_queue<P, vector<P>, greater<P>> pq;\\n        map<int,int> mp;\\n        \\n        int total=0,mx_till_now=0;\\n        pq.push({grid[0][0],{0,0}});\\n        grid[0][0]=-1;\\n        while(!pq.empty()){\\n            auto f=pq.top();\\n            pq.pop();\\n\\n            total++;\\n            mx_till_now=max(mx_till_now,f.first);\\n            mp[mx_till_now]=total;\\n            cout<<mx_till_now<<\" \"<<total<<endl;\\n\\n            int i=f.second.first,j=f.second.second;\\n            for(int k=0;k<4;k++){\\n                int nx=i+dir[k];\\n                int ny=j+dir[k+1];\\n                if(nx>=0 && nx<m && ny>=0 && ny<n && grid[nx][ny]!=-1){\\n                    pq.push({grid[nx][ny],{nx,ny}});\\n                    grid[nx][ny]=-1;\\n                }\\n            }\\n        }\\n\\n        int k=queries.size();\\n        vector<int> ans(k);\\n        for(int i=0;i<k;i++){\\n            auto it=mp.lower_bound(queries[i]);\\n            if(it==mp.begin()) ans[i]=0;\\n            else{\\n                auto itr=prev(it);\\n                ans[i]=itr->second;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2901595,
                "title": "python-3-bfs-heap",
                "content": "- Store coordinates wait to be visited in a minheap\\n- Sort the queries\\n  - Pop from heap into a queue if the top stricly smaller than the current query value\\n  - BFS starting from the queue and push into the heap for any cells can\\'t be visited at current step\\n  - Counts are just the current length of visited cells\\n\\n```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        \\n        cands = [(x, i) for i, x in enumerate(queries) if x > grid[0][0]]\\n        \\n        cands.sort()\\n        n = len(queries)\\n        ans = [0] * n\\n                \\n        def neighbor(x, y):\\n            for dx, dy in [(0, 1), (0, -1), (-1, 0), (1, 0)]:\\n                nx, ny = x+ dx, y +dy\\n                if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]):\\n                    yield nx, ny\\n        \\n        def bfs(q):\\n            while q:\\n                new_q = []\\n                for x, y in q:\\n                    for nx, ny in neighbor(x, y):\\n                        if (nx, ny) in vis: continue\\n                        if grid[nx][ny] >= uplimit: \\n                            heappush(border, (grid[nx][ny], nx, ny))\\n                            continue\\n                        vis.add((nx, ny))\\n                        new_q.append((nx, ny))\\n                q = new_q\\n        \\n        vis = set()\\n        border = [(grid[0][0], 0, 0)]\\n        for uplimit, i in cands:\\n            q = []\\n            while border and border[0][0] < uplimit:\\n                v, x, y = heappop(border)\\n                q.append((x, y))\\n                vis.add((x, y))            \\n            bfs(q)\\n            ans[i] = len(vis)\\n        \\n        return ans\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        \\n        cands = [(x, i) for i, x in enumerate(queries) if x > grid[0][0]]\\n        \\n        cands.sort()\\n        n = len(queries)\\n        ans = [0] * n\\n                \\n        def neighbor(x, y):\\n            for dx, dy in [(0, 1), (0, -1), (-1, 0), (1, 0)]:\\n                nx, ny = x+ dx, y +dy\\n                if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]):\\n                    yield nx, ny\\n        \\n        def bfs(q):\\n            while q:\\n                new_q = []\\n                for x, y in q:\\n                    for nx, ny in neighbor(x, y):\\n                        if (nx, ny) in vis: continue\\n                        if grid[nx][ny] >= uplimit: \\n                            heappush(border, (grid[nx][ny], nx, ny))\\n                            continue\\n                        vis.add((nx, ny))\\n                        new_q.append((nx, ny))\\n                q = new_q\\n        \\n        vis = set()\\n        border = [(grid[0][0], 0, 0)]\\n        for uplimit, i in cands:\\n            q = []\\n            while border and border[0][0] < uplimit:\\n                v, x, y = heappop(border)\\n                q.append((x, y))\\n                vis.add((x, y))            \\n            bfs(q)\\n            ans[i] = len(vis)\\n        \\n        return ans\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2901571,
                "title": "priority-queue-bfs-faster-than-100",
                "content": "\\n\\n\\n\\n```\\nclass Solution {\\n\\t// check if the indices are valid\\n    boolean isValid(int i, int j, int r, int c)\\n    {\\n        if (i >= 0 && i <= r - 1 && j <= c - 1 && j >= 0)\\n            return true;\\n        return false;\\n    }\\n\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        int[] x = {-1, 1, 0, 0};\\n        int[] y = {0, 0, 1, -1};\\n\\n        int[][] nqueries = new int[queries.length][2];\\n\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        int q = queries.length;\\n        for (int i = 0; i <= q - 1; i++) {\\n            nqueries[i][0] = queries[i];\\n            nqueries[i][1] = i;\\n        }\\n\\n        Arrays.sort(nqueries, (int[] a, int[] b) -> a[0] - b[0]);\\n\\n        int idx = 0;\\n        int count = 0;\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((int[] a, int [] b) -> a[2] - b[2]);\\n        pq.offer(new int[]{0, 0, grid[0][0]});\\n\\n        int[] ans = new int[q];\\n\\t\\t// since all the cell values are positive, using the same grid to mark visited as true\\n\\t\\t// by making the cell negative\\n        grid[0][0] *= -1;\\n\\n        while (idx <= q - 1) {\\n            if (pq.isEmpty()) {\\n                ans[nqueries[idx++][1]] = count;\\n                continue;\\n            }\\n\\n            int[] cell = pq.poll();\\n            while (idx <= q - 1 && cell[2] >= nqueries[idx][0]) {\\n                ans[nqueries[idx][1]] = count;\\n                idx++;\\n            }\\n\\n            if (idx >= q)\\n                break;\\n\\n            count++;\\n            for (int i = 0; i < 4; i++) {\\n                int nx = cell[0] + x[i];\\n                int ny = cell[1] + y[i];\\n\\n\\t\\t\\t\\t// check if the new index is not Valid, in that case continue\\n                if (!isValid(nx, ny, r, c) || grid[nx][ny] <= 0) {\\n                    continue;\\n                }\\n\\n                pq.offer(new int[]{nx, ny, grid[nx][ny]});\\n                grid[nx][ny] *= -1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t// check if the indices are valid\\n    boolean isValid(int i, int j, int r, int c)\\n    {\\n        if (i >= 0 && i <= r - 1 && j <= c - 1 && j >= 0)\\n            return true;\\n        return false;\\n    }\\n\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        int[] x = {-1, 1, 0, 0};\\n        int[] y = {0, 0, 1, -1};\\n\\n        int[][] nqueries = new int[queries.length][2];\\n\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        int q = queries.length;\\n        for (int i = 0; i <= q - 1; i++) {\\n            nqueries[i][0] = queries[i];\\n            nqueries[i][1] = i;\\n        }\\n\\n        Arrays.sort(nqueries, (int[] a, int[] b) -> a[0] - b[0]);\\n\\n        int idx = 0;\\n        int count = 0;\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((int[] a, int [] b) -> a[2] - b[2]);\\n        pq.offer(new int[]{0, 0, grid[0][0]});\\n\\n        int[] ans = new int[q];\\n\\t\\t// since all the cell values are positive, using the same grid to mark visited as true\\n\\t\\t// by making the cell negative\\n        grid[0][0] *= -1;\\n\\n        while (idx <= q - 1) {\\n            if (pq.isEmpty()) {\\n                ans[nqueries[idx++][1]] = count;\\n                continue;\\n            }\\n\\n            int[] cell = pq.poll();\\n            while (idx <= q - 1 && cell[2] >= nqueries[idx][0]) {\\n                ans[nqueries[idx][1]] = count;\\n                idx++;\\n            }\\n\\n            if (idx >= q)\\n                break;\\n\\n            count++;\\n            for (int i = 0; i < 4; i++) {\\n                int nx = cell[0] + x[i];\\n                int ny = cell[1] + y[i];\\n\\n\\t\\t\\t\\t// check if the new index is not Valid, in that case continue\\n                if (!isValid(nx, ny, r, c) || grid[nx][ny] <= 0) {\\n                    continue;\\n                }\\n\\n                pq.offer(new int[]{nx, ny, grid[nx][ny]});\\n                grid[nx][ny] *= -1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901555,
                "title": "java-dfs-optimised",
                "content": "```public int[] maxPoints(int[][] grid, int[] q) {\\n        int n=q.length;\\n        int k=grid.length;\\n        int m=grid[0].length;\\n        int[] ans= new int[n];\\n\\n        for(int i=0;i<n;i++){\\n            int val=q[i];\\n            boolean[][] vis= new boolean[k][m];\\n            int[] delrow={-1,0,+1,0};\\n            int[] delcol={0,1,0,-1};\\n            int[] count=new int[1];\\n            if(grid[0][0]<val)dfs(0,0,count,vis,delrow,delcol,k,m,val,grid);\\n            ans[i]=count[0];\\n        }\\n        return ans;\\n    }\\n    void dfs(int i, int j, int[] count, boolean[][] vis, int[] delrow, int[] delcol,int n, int m,int val,int[][] grid){\\n        vis[i][j]=true;\\n         count[0]++;\\n        for(int k=0;k<4;k++){\\n            int nrow=delrow[k]+i;\\n            int ncol=delcol[k]+j;\\n            if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && vis[nrow][ncol]==false && grid[nrow][ncol]<val ){\\n\\n                dfs(nrow,ncol,count,vis,delrow,delcol,n,m,val,grid);\\n            }\\n        }\\n    }\\n}``",
                "solutionTags": [],
                "code": "```public int[] maxPoints(int[][] grid, int[] q) {\\n        int n=q.length;\\n        int k=grid.length;\\n        int m=grid[0].length;\\n        int[] ans= new int[n];\\n\\n        for(int i=0;i<n;i++){\\n            int val=q[i];\\n            boolean[][] vis= new boolean[k][m];\\n            int[] delrow={-1,0,+1,0};\\n            int[] delcol={0,1,0,-1};\\n            int[] count=new int[1];\\n            if(grid[0][0]<val)dfs(0,0,count,vis,delrow,delcol,k,m,val,grid);\\n            ans[i]=count[0];\\n        }\\n        return ans;\\n    }\\n    void dfs(int i, int j, int[] count, boolean[][] vis, int[] delrow, int[] delcol,int n, int m,int val,int[][] grid){\\n        vis[i][j]=true;\\n         count[0]++;\\n        for(int k=0;k<4;k++){\\n            int nrow=delrow[k]+i;\\n            int ncol=delcol[k]+j;\\n            if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && vis[nrow][ncol]==false && grid[nrow][ncol]<val ){\\n\\n                dfs(nrow,ncol,count,vis,delrow,delcol,n,m,val,grid);\\n            }\\n        }\\n    }\\n}``",
                "codeTag": "Unknown"
            },
            {
                "id": 2901311,
                "title": "bfs-with-iterating-level-in-increasing-order-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDo BFS on Grid, using priority queue so that we can maintain the level of tree in increasing order.\\nNow whenever a `num` greater or equal number occurs put the `nodeTravelled` till now count as `num` : `nodesTravelled` key: value pair in an ArrayList `arr`\\n\\nIterate over the query and return lower_bound of `queries[i]` in `arr` calculation. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- `O(nLogn)`\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- `O(N + q.length)`\\n# Code\\n```\\nclass Solution {\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> grid[a[0]][a[1]] - grid[b[0]][b[1]]);\\n        ArrayList<int[]>list = new ArrayList<>();\\n        int maxNum = 1000001;\\n        int lastSmaller = grid[0][0];\\n        pq.add(new int[]{0, 0});\\n        int nodesTravelled = 0;\\n        while (!pq.isEmpty()) {\\n            int[] node = pq.poll();\\n            int r = node[0], c = node[1];\\n            int num = grid[r][c]% maxNum;\\n            if (num >= lastSmaller) {\\n                list.add(new int[]{lastSmaller, nodesTravelled});\\n                System.out.println(lastSmaller + \"  \" + nodesTravelled);\\n                lastSmaller = num+1;\\n            }\\n            nodesTravelled++;\\n            grid[r][c] += maxNum;\\n\\n            if (r < (grid.length - 1) && (grid[r + 1][c] < maxNum)) {\\n                grid[r + 1][c]+= maxNum;\\n                pq.add(new int[] {r + 1, c});\\n            }\\n\\n            if (r > 0 && (grid[r - 1][c] < maxNum)) {\\n                grid[r - 1][c] += maxNum;\\n                pq.add(new int[] {r - 1, c});\\n            }\\n\\n            if ( c < (grid[0].length - 1) && (grid[r][c + 1] < maxNum)) {\\n                grid[r][c + 1] += maxNum;\\n                pq.add(new int[] {r, c + 1});\\n            }\\n\\n            if (c > 0 && (grid[r][c - 1] < maxNum)) {\\n                grid[r][c - 1] += maxNum;\\n                pq.add(new int[] {r, c - 1});\\n            }\\n        }\\n        list.add(new int[]{lastSmaller, nodesTravelled});\\n        int[] ans = new int[queries.length];\\n\\n        for (int i = 0; i < queries.length; ++i) {\\n            ans[i] = lower_bound(list, queries[i]);\\n        }\\n        return ans;\\n    }\\n\\n    public int lower_bound(ArrayList<int[]> list, int target) {\\n        int l = 0, h = list.size()-1;\\n        int ans = -1;\\n        while (l <= h) {\\n            int m = (l + h)/2;\\n            if (list.get(m)[0] == target) {\\n                return list.get(m)[1];\\n            }\\n            if (list.get(m)[0] < target) {\\n                ans = m;\\n                l = m + 1;\\n            } else {\\n                h = m - 1;\\n            }\\n        }\\n        return ans == -1 ? 0 : list.get(ans)[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> grid[a[0]][a[1]] - grid[b[0]][b[1]]);\\n        ArrayList<int[]>list = new ArrayList<>();\\n        int maxNum = 1000001;\\n        int lastSmaller = grid[0][0];\\n        pq.add(new int[]{0, 0});\\n        int nodesTravelled = 0;\\n        while (!pq.isEmpty()) {\\n            int[] node = pq.poll();\\n            int r = node[0], c = node[1];\\n            int num = grid[r][c]% maxNum;\\n            if (num >= lastSmaller) {\\n                list.add(new int[]{lastSmaller, nodesTravelled});\\n                System.out.println(lastSmaller + \"  \" + nodesTravelled);\\n                lastSmaller = num+1;\\n            }\\n            nodesTravelled++;\\n            grid[r][c] += maxNum;\\n\\n            if (r < (grid.length - 1) && (grid[r + 1][c] < maxNum)) {\\n                grid[r + 1][c]+= maxNum;\\n                pq.add(new int[] {r + 1, c});\\n            }\\n\\n            if (r > 0 && (grid[r - 1][c] < maxNum)) {\\n                grid[r - 1][c] += maxNum;\\n                pq.add(new int[] {r - 1, c});\\n            }\\n\\n            if ( c < (grid[0].length - 1) && (grid[r][c + 1] < maxNum)) {\\n                grid[r][c + 1] += maxNum;\\n                pq.add(new int[] {r, c + 1});\\n            }\\n\\n            if (c > 0 && (grid[r][c - 1] < maxNum)) {\\n                grid[r][c - 1] += maxNum;\\n                pq.add(new int[] {r, c - 1});\\n            }\\n        }\\n        list.add(new int[]{lastSmaller, nodesTravelled});\\n        int[] ans = new int[queries.length];\\n\\n        for (int i = 0; i < queries.length; ++i) {\\n            ans[i] = lower_bound(list, queries[i]);\\n        }\\n        return ans;\\n    }\\n\\n    public int lower_bound(ArrayList<int[]> list, int target) {\\n        int l = 0, h = list.size()-1;\\n        int ans = -1;\\n        while (l <= h) {\\n            int m = (l + h)/2;\\n            if (list.get(m)[0] == target) {\\n                return list.get(m)[1];\\n            }\\n            if (list.get(m)[0] < target) {\\n                ans = m;\\n                l = m + 1;\\n            } else {\\n                h = m - 1;\\n            }\\n        }\\n        return ans == -1 ? 0 : list.get(ans)[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901213,
                "title": "bfs-with-priorityqueue-query-to-treemap",
                "content": "# Intuition\\nI1)\\nGiven the constraints\\n```\\n4 <= m * n <= 10^5\\nk == queries.length\\n1 <= k <= 10^4\\n```\\nit is expected get TLE, if\\neach query takes 10^5 (10^5 * 10^4 is over 10^8).\\n\\nWe natually noticed that we does duplicate process \\nacross each query.\\nWe want to make each query process as fast as possible.\\n\\nI2) imagine grid[][] is mountain range, and we pour\\nwater to queries[] height.\\n\\n# Approach\\n\\n\\nThe value of grid[i][j] is discreate and there\\'s up to\\n`m*n` patterns.\\nIf we visit each cell of grid with BFS (imagine grid[][] is mountain range, and  water\\nis poured up to each queries[] height from top left corner ),\\nwe gain up to `m*n` patterns of point for each grid[i][j].\\nIf we use grid[i][j] as the key of TreeMap, then\\neach query can be performed with log(`m*n`).\\n\\n## The key point\\nThe key point is that key of TreeMap can be only the grid[][] at which water has climed with BFS.\\ngrid[][] filled with downstream flow can be ignored except the point.\\n\\n# Complexity\\n- Time complexity:\\n` O((k + m*n) * log(m*n)) `\\n\\n- Space complexity:\\n` O(m*n)`\\n\\n\\n# Code\\n\\n```\\n\\nclass Solution {\\n  int[] dir = {-1, 0, 1, 0, -1};\\n\\n  public int[] maxPoints(int[][] grid, int[] queries) {\\n    int R = grid.length, C = grid[0].length;\\n    // <val, cnt>\\n    var m = new TreeMap<Integer, Integer>();\\n    var cur = grid[0][0]; // cur is the current lowest \\'water\\' height.\\n    // [val, row, col]\\n    var q = new PriorityQueue<int[]>(Comparator.comparingInt(a -> a[0]));\\n    q.add(new int[]{cur, 0, 0});\\n    var isUsed = new boolean[R][C];\\n    isUsed[0][0] = true;\\n    while (!q.isEmpty()) {\\n      var p = q.poll();\\n      cur = Math.max(cur, p[0]); // See the \\'The key point\\' in \\'Approach\\' section.\\n      var e = m.floorEntry(cur);\\n      if (e == null) {\\n        m.put(cur, 1);\\n      } else {\\n        m.put(cur, e.getValue() + 1);\\n      }\\n      for (int i = 0; i < 4; i++) {\\n        int nr = p[1] + dir[i], nc = p[2] + dir[i + 1];\\n        if (nr < 0 || R <= nr || nc < 0 || C <= nc || isUsed[nr][nc]) continue;\\n        isUsed[nr][nc] = true;\\n        q.add(new int[]{grid[nr][nc], nr, nc});\\n      }\\n    }\\n\\n    var res = new int[queries.length];\\n    for (int i = 0; i < queries.length; i++) {\\n      var query = queries[i];\\n      var e = m.lowerEntry(query);\\n      if (e == null) continue;\\n      res[i] = e.getValue();\\n    }\\n    return res;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n4 <= m * n <= 10^5\\nk == queries.length\\n1 <= k <= 10^4\\n```\n```\\n\\nclass Solution {\\n  int[] dir = {-1, 0, 1, 0, -1};\\n\\n  public int[] maxPoints(int[][] grid, int[] queries) {\\n    int R = grid.length, C = grid[0].length;\\n    // <val, cnt>\\n    var m = new TreeMap<Integer, Integer>();\\n    var cur = grid[0][0]; // cur is the current lowest \\'water\\' height.\\n    // [val, row, col]\\n    var q = new PriorityQueue<int[]>(Comparator.comparingInt(a -> a[0]));\\n    q.add(new int[]{cur, 0, 0});\\n    var isUsed = new boolean[R][C];\\n    isUsed[0][0] = true;\\n    while (!q.isEmpty()) {\\n      var p = q.poll();\\n      cur = Math.max(cur, p[0]); // See the \\'The key point\\' in \\'Approach\\' section.\\n      var e = m.floorEntry(cur);\\n      if (e == null) {\\n        m.put(cur, 1);\\n      } else {\\n        m.put(cur, e.getValue() + 1);\\n      }\\n      for (int i = 0; i < 4; i++) {\\n        int nr = p[1] + dir[i], nc = p[2] + dir[i + 1];\\n        if (nr < 0 || R <= nr || nc < 0 || C <= nc || isUsed[nr][nc]) continue;\\n        isUsed[nr][nc] = true;\\n        q.add(new int[]{grid[nr][nc], nr, nc});\\n      }\\n    }\\n\\n    var res = new int[queries.length];\\n    for (int i = 0; i < queries.length; i++) {\\n      var query = queries[i];\\n      var e = m.lowerEntry(query);\\n      if (e == null) continue;\\n      res[i] = e.getValue();\\n    }\\n    return res;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901179,
                "title": "python-20-lines-solution-with-intuitive-explanation-no-binary-search-or-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI have read a few approaches using `heap` and binary search, but failed to understand. Guess I am not familiar with the approach in graph. Here is a solution that is intuitive for me.\\n\\nClearly, for this problem we can only iterate the graph once, otherwise would be `TLE`. But we have `k` queries to go through, how can we make that possible?\\n\\nNotice that, the bigger the query value, the bigger the result! So the way to do it is to make one query relays on the other, i.e. **we do BFS, starting from the smallest query, and build our later query on top of the previous search.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt is basically a BFS. But here we use heap, which **stores the nodes to be visited**. The reason we use a min heap here is to make sure we always consider the smaller node value first, for example, suppose the current `query = 5` and you are at the following position with neigbors `[3, 10]`\\n\\n```\\npos| 3\\n-------\\n10 |\\n```\\n\\nSince `5 > 3`, we should make sure that the node `3` is added into count. Conversely, if `10` is added first, then node `3` is missed.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`O(klogK + MNlogMN)`\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`O(MN)`\\n\\n# Code\\n```\\nimport heapq as hq\\n\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m, n = map(len, (grid, grid[0]))\\n        qs = sorted([(q, i) for i, q in enumerate(queries)])\\n        c, ans = 0, [-1] * len(qs) # c is the current count\\n        heap = [(grid[0][0], 0, 0)] # stores nodes to be visited\\n        vis = [[0 for _ in range(n)] for _ in range(m)]\\n        for q, i in qs:\\n            while heap and heap[0][0] < q:  # the smallest node suffices the condition\\n                v, x, y = hq.heappop(heap)\\n                vis[x][y] = 1\\n                c += 1  # the current node satisfy the condition, so +1\\n                for x_new, y_new in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:\\n                    if 0<=x_new<m and 0<=y_new<n and not vis[x_new][y_new]:\\n                        hq.heappush(heap, (grid[x_new][y_new], x_new, y_new))\\n                        vis[x_new][y_new] = 1\\n            ans[i] = c # store the current result of the query\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\npos| 3\\n-------\\n10 |\\n```\n```\\nimport heapq as hq\\n\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m, n = map(len, (grid, grid[0]))\\n        qs = sorted([(q, i) for i, q in enumerate(queries)])\\n        c, ans = 0, [-1] * len(qs) # c is the current count\\n        heap = [(grid[0][0], 0, 0)] # stores nodes to be visited\\n        vis = [[0 for _ in range(n)] for _ in range(m)]\\n        for q, i in qs:\\n            while heap and heap[0][0] < q:  # the smallest node suffices the condition\\n                v, x, y = hq.heappop(heap)\\n                vis[x][y] = 1\\n                c += 1  # the current node satisfy the condition, so +1\\n                for x_new, y_new in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:\\n                    if 0<=x_new<m and 0<=y_new<n and not vis[x_new][y_new]:\\n                        hq.heappush(heap, (grid[x_new][y_new], x_new, y_new))\\n                        vis[x_new][y_new] = 1\\n            ans[i] = c # store the current result of the query\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901134,
                "title": "bfs-with-preprocessing-by-sorting-c",
                "content": "# Intuition\\nhere we have to find something like sum of all the connected node with some constrains and we have to so bfs because here we are intrested in branches to get expanded,\\njust like making smallest spanning tree.\\n\\n# Approach\\n-step1: take a map to store the count of nodes visted by each queres\\n-step 2:make a copy of queries and sort orginal one\\n-step 3:do bfs till u wont reach the end of qurie array \\n-steo 4 :after compition of bfs just with help of map push the answer as per mentioned form \\n\\n# Complexity\\n- Time complexity:\\nO(n*m + q)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) \\n    {\\n        unordered_map<int,int>mp;\\n        vector<int>tqueries=queries;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            mp[queries[i]]=i;\\n            \\n        }\\n        int previous=0;\\n        unordered_map<int,int>mq;\\n        sort(queries.begin(),queries.end());\\n        priority_queue <pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        grid[0][0]=-1;\\n        int qi=0;\\n        int count=0;\\n        while(qi!=queries.size())\\n        {   \\n                if (pq.size()==0 || pq.top().first>=queries[qi] )\\n                {\\n                    mq[queries[qi]]=previous+count;\\n                    previous=count+previous;\\n                    qi++;\\n                    count=0;\\n                    \\n                }\\n                else\\n                {\\n                    auto temp=pq.top();\\n                    pq.pop();\\n                    int i=temp.second.first;\\n                    int j=temp.second.second;\\n                    if (i-1>=0 && grid[i-1][j]!=-1)\\n                    {\\n                        pq.push({grid[i-1][j],{i-1,j}});\\n                        grid[i-1][j]=-1;\\n                    }\\n                    if (j-1>=0 && grid[i][j-1]!=-1)\\n                    {\\n                        pq.push({grid[i][j-1],{i,j-1}});\\n                        grid[i][j-1]=-1;\\n                    }\\n                    if (i+1<grid.size() && grid[i+1][j]!=-1)\\n                    {\\n                        pq.push({grid[i+1][j],{i+1,j}});\\n                        grid[i+1][j]=-1;\\n                    }\\n                    if (j+1<grid[0].size() && grid[i][j+1]!=-1)\\n                    {\\n                        pq.push({grid[i][j+1],{i,j+1}});\\n                        grid[i][j+1]=-1;\\n                    }\\n                    count++;\\n                    \\n                }\\n        }\\n        vector<int>ans;\\n        for(auto &it:tqueries)\\n        {\\n            ans.push_back(mq[it]);\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) \\n    {\\n        unordered_map<int,int>mp;\\n        vector<int>tqueries=queries;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            mp[queries[i]]=i;\\n            \\n        }\\n        int previous=0;\\n        unordered_map<int,int>mq;\\n        sort(queries.begin(),queries.end());\\n        priority_queue <pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        grid[0][0]=-1;\\n        int qi=0;\\n        int count=0;\\n        while(qi!=queries.size())\\n        {   \\n                if (pq.size()==0 || pq.top().first>=queries[qi] )\\n                {\\n                    mq[queries[qi]]=previous+count;\\n                    previous=count+previous;\\n                    qi++;\\n                    count=0;\\n                    \\n                }\\n                else\\n                {\\n                    auto temp=pq.top();\\n                    pq.pop();\\n                    int i=temp.second.first;\\n                    int j=temp.second.second;\\n                    if (i-1>=0 && grid[i-1][j]!=-1)\\n                    {\\n                        pq.push({grid[i-1][j],{i-1,j}});\\n                        grid[i-1][j]=-1;\\n                    }\\n                    if (j-1>=0 && grid[i][j-1]!=-1)\\n                    {\\n                        pq.push({grid[i][j-1],{i,j-1}});\\n                        grid[i][j-1]=-1;\\n                    }\\n                    if (i+1<grid.size() && grid[i+1][j]!=-1)\\n                    {\\n                        pq.push({grid[i+1][j],{i+1,j}});\\n                        grid[i+1][j]=-1;\\n                    }\\n                    if (j+1<grid[0].size() && grid[i][j+1]!=-1)\\n                    {\\n                        pq.push({grid[i][j+1],{i,j+1}});\\n                        grid[i][j+1]=-1;\\n                    }\\n                    count++;\\n                    \\n                }\\n        }\\n        vector<int>ans;\\n        for(auto &it:tqueries)\\n        {\\n            ans.push_back(mq[it]);\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901066,
                "title": "priority-queue-bfs-binary-search-python3",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        q = [(grid[0][0], 0, 0)]\\n        visited = {(0, 0)}\\n        cm = grid[0][0]\\n        cnt = 0\\n        arr = [0]\\n        arrI = [0]\\n        while len(q) != 0:\\n            h, i, j = heappop(q)\\n            if h > cm:\\n                arr.append(cnt)\\n                arrI.append(cm)\\n                cm = h\\n            cnt += 1\\n            if i + 1 < m and (i+1, j) not in visited:\\n                heapq.heappush(q, (grid[i+1][j], i+1, j))\\n                visited.add((i+1, j))\\n            if i - 1 > -1 and (i-1, j) not in visited:\\n                heapq.heappush(q, (grid[i-1][j], i-1, j))\\n                visited.add((i-1, j))\\n            if j + 1 < n and (i, j+1) not in visited:\\n                heapq.heappush(q, (grid[i][j+1], i, j+1))\\n                visited.add((i, j+1))\\n            if j - 1 > -1 and (i, j-1) not in visited:\\n                heapq.heappush(q, (grid[i][j-1], i, j-1))\\n                visited.add((i, j-1))\\n        arrI.append(cm)\\n        arr.append(cnt)\\n        ans = []\\n        for q in queries:\\n            q -= 1\\n            l, h = 0, len(arr) - 1\\n            ptr = 0\\n            while l <= h:\\n                m = (l + h) // 2\\n                if arrI[m] == q:\\n                    ptr = m\\n                    break\\n                if arrI[m] > q:\\n                    h = m - 1\\n                else:\\n                    ptr = m\\n                    l = m + 1\\n            ans.append(arr[ptr])\\n        return ans\\n                    \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        q = [(grid[0][0], 0, 0)]\\n        visited = {(0, 0)}\\n        cm = grid[0][0]\\n        cnt = 0\\n        arr = [0]\\n        arrI = [0]\\n        while len(q) != 0:\\n            h, i, j = heappop(q)\\n            if h > cm:\\n                arr.append(cnt)\\n                arrI.append(cm)\\n                cm = h\\n            cnt += 1\\n            if i + 1 < m and (i+1, j) not in visited:\\n                heapq.heappush(q, (grid[i+1][j], i+1, j))\\n                visited.add((i+1, j))\\n            if i - 1 > -1 and (i-1, j) not in visited:\\n                heapq.heappush(q, (grid[i-1][j], i-1, j))\\n                visited.add((i-1, j))\\n            if j + 1 < n and (i, j+1) not in visited:\\n                heapq.heappush(q, (grid[i][j+1], i, j+1))\\n                visited.add((i, j+1))\\n            if j - 1 > -1 and (i, j-1) not in visited:\\n                heapq.heappush(q, (grid[i][j-1], i, j-1))\\n                visited.add((i, j-1))\\n        arrI.append(cm)\\n        arr.append(cnt)\\n        ans = []\\n        for q in queries:\\n            q -= 1\\n            l, h = 0, len(arr) - 1\\n            ptr = 0\\n            while l <= h:\\n                m = (l + h) // 2\\n                if arrI[m] == q:\\n                    ptr = m\\n                    break\\n                if arrI[m] > q:\\n                    h = m - 1\\n                else:\\n                    ptr = m\\n                    l = m + 1\\n            ans.append(arr[ptr])\\n        return ans\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901006,
                "title": "k-queue-bfs-binary-search-with-time-o-mnlogk-and-space-o-mn",
                "content": "**Algorithm**\\nThe main idea is BFS with 4 directions. Instead of a single queue for BFS, we maintain at most K queue according to the limit of each queries. (queries may be the same.)\\n\\n*Part 1*: we reorder the queries so that the limits is non-decreasing.\\n\\n*Part 2:* from low to high, we start BFS with position [0,0].\\nInstead of pushing the newly explored position at the back of current queue, we do binary search (a.k.a upper_bound) to see which queue is suitable. (**NOTE**: although not included in the code, the binary search can be skipped as long as current limit is higher than the value of newly explored position. The performance is similar, about 136ms ~ 200ms)\\n\\nSince MxN<=1e5 but k<=1e4, some kind of benefit is expected. Further optimization is possible.\\n\\n**Complexity**\\n```\\nTime: O(MNlogK+KlogK)\\nSpace: O(MN) (Hint: ZigZag path)\\n```\\n**Performance**\\n```\\nRuntime: 169 ms, faster than 100.00% of C++ online submissions for Maximum Number of Points From Grid Queries.\\nMemory Usage: 59.5 MB, less than 50.00% of C++ online submissions for Maximum Number of Points From Grid Queries.\\n```\\n\\n**Code**\\n```\\nint dir [] = {-1, 0, 1, 0, -1};\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        int m=grid.size(), n=grid[0].size(), k=queries.size();\\n        map<int, int> dic;\\n        vector<int> ans (k);\\n        vector<queue<pair<int,int>>> buf (k);\\n        for(int i=k-1; i>=0; --i) {\\n            dic[queries[i]]=i;   \\n        }\\n        auto cur=dic.begin(), done=dic.end(), it=dic.upper_bound(grid[0][0]);\\n        if(it!=done) {\\n            buf[it->second].push({0,0});\\n            grid[0][0]=0;\\n        }\\n        for(int i, j, r, c, r1, c1, cnt=0; cur!=done; ++cur) {\\n            for(i=cur->second; buf[i].size(); buf[i].pop()) {\\n                ++cnt;\\n                r=buf[i].front().first;\\n                c=buf[i].front().second;\\n                for(j=0; j<4; ++j) {\\n                    r1=r+dir[j];\\n                    c1=c+dir[j+1];\\n                    if(r1>=0 && c1>=0 && r1<m && c1<n && grid[r1][c1]) {\\n                        it=dic.upper_bound(grid[r1][c1]);\\n                        if(it!=done) {\\n                            it->first>cur->first?\\n                                buf[it->second].push({r1,c1}) : \\n                                buf[cur->second].push({r1,c1});\\n                        }\\n                        grid[r1][c1]=0;\\n                    }\\n                }\\n            }\\n            ans[i]=cnt;\\n        }\\n        for(int i=k-1; i>=0; --i) {\\n            ans[i]=ans[dic[queries[i]]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nTime: O(MNlogK+KlogK)\\nSpace: O(MN) (Hint: ZigZag path)\\n```\n```\\nRuntime: 169 ms, faster than 100.00% of C++ online submissions for Maximum Number of Points From Grid Queries.\\nMemory Usage: 59.5 MB, less than 50.00% of C++ online submissions for Maximum Number of Points From Grid Queries.\\n```\n```\\nint dir [] = {-1, 0, 1, 0, -1};\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        int m=grid.size(), n=grid[0].size(), k=queries.size();\\n        map<int, int> dic;\\n        vector<int> ans (k);\\n        vector<queue<pair<int,int>>> buf (k);\\n        for(int i=k-1; i>=0; --i) {\\n            dic[queries[i]]=i;   \\n        }\\n        auto cur=dic.begin(), done=dic.end(), it=dic.upper_bound(grid[0][0]);\\n        if(it!=done) {\\n            buf[it->second].push({0,0});\\n            grid[0][0]=0;\\n        }\\n        for(int i, j, r, c, r1, c1, cnt=0; cur!=done; ++cur) {\\n            for(i=cur->second; buf[i].size(); buf[i].pop()) {\\n                ++cnt;\\n                r=buf[i].front().first;\\n                c=buf[i].front().second;\\n                for(j=0; j<4; ++j) {\\n                    r1=r+dir[j];\\n                    c1=c+dir[j+1];\\n                    if(r1>=0 && c1>=0 && r1<m && c1<n && grid[r1][c1]) {\\n                        it=dic.upper_bound(grid[r1][c1]);\\n                        if(it!=done) {\\n                            it->first>cur->first?\\n                                buf[it->second].push({r1,c1}) : \\n                                buf[cur->second].push({r1,c1});\\n                        }\\n                        grid[r1][c1]=0;\\n                    }\\n                }\\n            }\\n            ans[i]=cnt;\\n        }\\n        for(int i=k-1; i>=0; --i) {\\n            ans[i]=ans[dic[queries[i]]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900957,
                "title": "bfs-code-with-comments-why-priority-queue-instead-of-normal-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly, we can see naive solution(visiting matrix), will lwad to tle, so we have to think, where we can optimize. Can take help of queries array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, we sort the queries array in increasing order, to use the previous results in form of prefix array. After sorting, we have to use a priority queue instead of a normal queue, because if a cell is visited by a higher value first, then a smaller value will not get its count, also if use visited matrix to solve this problem, it will lead to duplicacy. Min priority queue will ensure that a cell is visited by a smaller value first, which is a potential candidate and not a higher value first.\\nThen, using the indexes(meaning not the original of queries array) in prefix array, we add sum of lower values to higher values, and finally put values in answer array in their original indexes.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(k log k) + O(m*n) - Sorting + Visiting all values in worst case\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2*k) + O(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct node{\\n        int cur;\\n        int i;\\n        int j;\\n        int val;\\n    };\\n\\n    struct compare{\\n        bool operator()(node a, node b){\\n            return a.val > b.val;\\n        }\\n    };\\n    int m, n, k;\\n    \\n    vector<int> maxPoints(vector<vector<int>>& g, vector<int>& qu) {\\n        \\n        m = g.size();\\n        n = g[0].size();\\n        k = qu.size();\\n\\n        vector<pair<int, pair<int, int>>>ans(k);\\n        // vector<int>extra(k, 0);\\n        vector<pair<int, int>>qq(k);\\n\\n        for(int i=0; i<k; i++){\\n            qq[i].first = qu[i]; // for sorting values\\n            qq[i].second = i;  // original index\\n        }\\n        \\n        \\n        sort(qq.begin(), qq.end());\\n        \\n        vector<vector<int>>vis(m, vector<int>(n, INT_MAX));\\n        \\n        // queue<node>q;\\n        priority_queue<node, vector<node>, compare>q;\\n        \\n        for(int cur=0; cur<k; cur++){\\n            ans[cur].first = cur;\\n            // ans[qq[cur].second].first = cur;  // index after sorting\\n            // ans[qq[cur].second].second.second = qq[cur].second; // original index\\n            ans[cur].second.second = qq[cur].second;\\n        }\\n\\n        q.push({0, 0, 0, g[0][0]});\\n        vis[0][0] = 0;\\n        \\n\\n        // have to push cells which have lower value first, otherwise some cells may get visite dby higher values first, and lower values count will not be taken\\n        // if we take use of vis matrix, then it will lead to duplicacy\\n        while(!q.empty()){\\n            int s = q.size();\\n            for(int i=0; i<s; i++){\\n                int ii = q.top().i;\\n                int jj = q.top().j;\\n                // vis[ii][jj] = 1;\\n                int cur = q.top().cur;\\n                q.pop();\\n\\n                while(cur<k && qq[cur].first <= g[ii][jj]){\\n                    cur++;\\n                }\\n                \\n                if(cur>=k)\\n                    continue;\\n                \\n                ans[cur].second.first++;\\n                // ans[qq[cur].second].second.first++;\\n\\n                if((ii-1)>=0 && vis[ii-1][jj]>cur){\\n                    // if(vis[ii-1][jj] != INT_MAX)\\n                    //     extra[cur]--;\\n                    vis[ii-1][jj] = cur;\\n                    q.push({cur, ii-1, jj, g[ii-1][jj]});\\n                }\\n                \\n                if((ii+1)<m && vis[ii+1][jj]>cur){\\n                    // if(vis[ii+1][jj] != INT_MAX)\\n                    //     extra[cur]--;\\n                    vis[ii+1][jj] = cur;\\n                    q.push({cur, ii+1, jj, g[ii+1][jj]});\\n                }\\n                \\n                if((jj+1)<n && vis[ii][jj+1]>cur){\\n                    // if(vis[ii][jj+1] != INT_MAX)\\n                    //     extra[cur]--;\\n                    vis[ii][jj+1] = cur;\\n                    q.push({cur, ii, jj+1, g[ii][jj+1]});\\n                }\\n                \\n                if((jj-1)>=0 && vis[ii][jj-1]>cur){\\n                    // if(vis[ii][jj-1] != INT_MAX)\\n                    //     extra[cur]--;\\n                    vis[ii][jj-1] = cur;\\n                    q.push({cur, ii, jj-1, g[ii][jj-1]});\\n                }\\n\\n            }\\n        }\\n        vector<int>a(k);\\n        \\n        sort(ans.begin(), ans.end());\\n        // for(int i=0; i<k; i++){\\n            // cout<<ans[i].second.second<<\" \"<<ans[i].second.first<<endl;\\n        // }\\n        \\n        for(int i=1; i<k; i++){\\n            // cout<<ans[i].second.first<<\" \";\\n            ans[i].second.first += ans[i-1].second.first;\\n            // ans[i].second.first += extra[i-1];\\n        }\\n        \\n        for(int i=0; i<k; i++)\\n            a[ans[i].second.second] = ans[i].second.first;\\n        return a;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Heap (Priority Queue)",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct node{\\n        int cur;\\n        int i;\\n        int j;\\n        int val;\\n    };\\n\\n    struct compare{\\n        bool operator()(node a, node b){\\n            return a.val > b.val;\\n        }\\n    };\\n    int m, n, k;\\n    \\n    vector<int> maxPoints(vector<vector<int>>& g, vector<int>& qu) {\\n        \\n        m = g.size();\\n        n = g[0].size();\\n        k = qu.size();\\n\\n        vector<pair<int, pair<int, int>>>ans(k);\\n        // vector<int>extra(k, 0);\\n        vector<pair<int, int>>qq(k);\\n\\n        for(int i=0; i<k; i++){\\n            qq[i].first = qu[i]; // for sorting values\\n            qq[i].second = i;  // original index\\n        }\\n        \\n        \\n        sort(qq.begin(), qq.end());\\n        \\n        vector<vector<int>>vis(m, vector<int>(n, INT_MAX));\\n        \\n        // queue<node>q;\\n        priority_queue<node, vector<node>, compare>q;\\n        \\n        for(int cur=0; cur<k; cur++){\\n            ans[cur].first = cur;\\n            // ans[qq[cur].second].first = cur;  // index after sorting\\n            // ans[qq[cur].second].second.second = qq[cur].second; // original index\\n            ans[cur].second.second = qq[cur].second;\\n        }\\n\\n        q.push({0, 0, 0, g[0][0]});\\n        vis[0][0] = 0;\\n        \\n\\n        // have to push cells which have lower value first, otherwise some cells may get visite dby higher values first, and lower values count will not be taken\\n        // if we take use of vis matrix, then it will lead to duplicacy\\n        while(!q.empty()){\\n            int s = q.size();\\n            for(int i=0; i<s; i++){\\n                int ii = q.top().i;\\n                int jj = q.top().j;\\n                // vis[ii][jj] = 1;\\n                int cur = q.top().cur;\\n                q.pop();\\n\\n                while(cur<k && qq[cur].first <= g[ii][jj]){\\n                    cur++;\\n                }\\n                \\n                if(cur>=k)\\n                    continue;\\n                \\n                ans[cur].second.first++;\\n                // ans[qq[cur].second].second.first++;\\n\\n                if((ii-1)>=0 && vis[ii-1][jj]>cur){\\n                    // if(vis[ii-1][jj] != INT_MAX)\\n                    //     extra[cur]--;\\n                    vis[ii-1][jj] = cur;\\n                    q.push({cur, ii-1, jj, g[ii-1][jj]});\\n                }\\n                \\n                if((ii+1)<m && vis[ii+1][jj]>cur){\\n                    // if(vis[ii+1][jj] != INT_MAX)\\n                    //     extra[cur]--;\\n                    vis[ii+1][jj] = cur;\\n                    q.push({cur, ii+1, jj, g[ii+1][jj]});\\n                }\\n                \\n                if((jj+1)<n && vis[ii][jj+1]>cur){\\n                    // if(vis[ii][jj+1] != INT_MAX)\\n                    //     extra[cur]--;\\n                    vis[ii][jj+1] = cur;\\n                    q.push({cur, ii, jj+1, g[ii][jj+1]});\\n                }\\n                \\n                if((jj-1)>=0 && vis[ii][jj-1]>cur){\\n                    // if(vis[ii][jj-1] != INT_MAX)\\n                    //     extra[cur]--;\\n                    vis[ii][jj-1] = cur;\\n                    q.push({cur, ii, jj-1, g[ii][jj-1]});\\n                }\\n\\n            }\\n        }\\n        vector<int>a(k);\\n        \\n        sort(ans.begin(), ans.end());\\n        // for(int i=0; i<k; i++){\\n            // cout<<ans[i].second.second<<\" \"<<ans[i].second.first<<endl;\\n        // }\\n        \\n        for(int i=1; i<k; i++){\\n            // cout<<ans[i].second.first<<\" \";\\n            ans[i].second.first += ans[i-1].second.first;\\n            // ans[i].second.first += extra[i-1];\\n        }\\n        \\n        for(int i=0; i<k; i++)\\n            a[ans[i].second.second] = ans[i].second.first;\\n        return a;\\n    }\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2900945,
                "title": "c-bfs-sorting-tc-o-n-m-log-n-m",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* First sort the queries in accending order with their indices\\n* Push {0,0} into queue and start BFS \\n* for every querry there is precomputed values are there which we use so that we does not recomputed same querry again & again\\n* when queue is empty then update current querry and then start next querry\\n\\n# Complexity\\n- Time complexity: O(N\\\\*M*log(N\\\\*M))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N\\\\*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int row[4] = {0,0,1,-1};\\n    int col[4] = {1,-1,0,0};\\n    bool is_pos(int i,int j,vector<vector<int>>&st,int n,int m){\\n        if(i==-1 || j==-1 || i==n || j==m || st[i][j]<=0) return false;\\n        return true;\\n    }\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& q) {\\n        vector<vector<int>> v;\\n        vector<int> ans(q.size(),0);\\n        for(int i=0;i<q.size();i++){\\n            v.push_back({q[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        queue<pair<int,int>> *p1,*p2;\\n        p1 = new queue<pair<int,int>>();\\n        p2 = new queue<pair<int,int>>();\\n        int cur = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        grid[0][0]*=-1;\\n        p1->push({0,0});\\n        for(int i=0;i<q.size();i++){\\n            while(p1->size()){\\n                int k = p1->size();\\n                while(k--){\\n                    int o = p1->front().first;\\n                    int p = p1->front().second;\\n                    p1->pop();\\n                    if(abs(grid[o][p])>=v[i][0]) {\\n                        p2->push({o,p});\\n                        continue;\\n                    }\\n                    for(int z=0;z<4;z++){\\n                        if(is_pos(o+row[z],p+col[z],grid, n, m)){\\n                            grid[o+row[z]][p+col[z]]*=-1;\\n                            p1->push({o+row[z],p+col[z]});\\n                        }\\n                    }\\n                    cur++;\\n                }\\n            }\\n            queue<pair<int,int>> *ptr = p1;\\n            p1 = p2;\\n            p2 =  ptr;\\n            ans[v[i][1]] = cur;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIf You Like Solution Please Upvote :)\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int row[4] = {0,0,1,-1};\\n    int col[4] = {1,-1,0,0};\\n    bool is_pos(int i,int j,vector<vector<int>>&st,int n,int m){\\n        if(i==-1 || j==-1 || i==n || j==m || st[i][j]<=0) return false;\\n        return true;\\n    }\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& q) {\\n        vector<vector<int>> v;\\n        vector<int> ans(q.size(),0);\\n        for(int i=0;i<q.size();i++){\\n            v.push_back({q[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        queue<pair<int,int>> *p1,*p2;\\n        p1 = new queue<pair<int,int>>();\\n        p2 = new queue<pair<int,int>>();\\n        int cur = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        grid[0][0]*=-1;\\n        p1->push({0,0});\\n        for(int i=0;i<q.size();i++){\\n            while(p1->size()){\\n                int k = p1->size();\\n                while(k--){\\n                    int o = p1->front().first;\\n                    int p = p1->front().second;\\n                    p1->pop();\\n                    if(abs(grid[o][p])>=v[i][0]) {\\n                        p2->push({o,p});\\n                        continue;\\n                    }\\n                    for(int z=0;z<4;z++){\\n                        if(is_pos(o+row[z],p+col[z],grid, n, m)){\\n                            grid[o+row[z]][p+col[z]]*=-1;\\n                            p1->push({o+row[z],p+col[z]});\\n                        }\\n                    }\\n                    cur++;\\n                }\\n            }\\n            queue<pair<int,int>> *ptr = p1;\\n            p1 = p2;\\n            p2 =  ptr;\\n            ans[v[i][1]] = cur;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900854,
                "title": "python3-heapq-sol-for-reference",
                "content": "```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        st = [(grid[0][0], (0,0))]\\n        visited = defaultdict(bool)\\n        R = len(grid)\\n        C = len(grid[0])\\n        \\n        seq = []\\n        visited[(0,0)] = True\\n        \\n        while st:\\n            value, point = heapq.heappop(st)\\n            x,y = point \\n            seq.append(value)\\n                        \\n            for dx,dy in [(1,0),(0,1),(-1,0),(0,-1)]: \\n                nx = dx + x \\n                ny = dy + y \\n                \\n                if nx >= 0 and nx < R and ny >=0 and ny < C and visited[(nx,ny)] == False:\\n                    visited[(nx, ny)] = True \\n\\n                    heapq.heappush(st, (grid[nx][ny], (nx, ny)))\\n        \\n        for i in range(1, len(seq)): \\n            if seq[i-1] > seq[i]:\\n                seq[i] = seq[i-1]\\n                            \\n        return [bisect_left(seq, i) for i in queries]\\n",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        st = [(grid[0][0], (0,0))]\\n        visited = defaultdict(bool)\\n        R = len(grid)\\n        C = len(grid[0])\\n        \\n        seq = []\\n        visited[(0,0)] = True\\n        \\n        while st:\\n            value, point = heapq.heappop(st)\\n            x,y = point \\n            seq.append(value)\\n                        \\n            for dx,dy in [(1,0),(0,1),(-1,0),(0,-1)]: \\n                nx = dx + x \\n                ny = dy + y \\n                \\n                if nx >= 0 and nx < R and ny >=0 and ny < C and visited[(nx,ny)] == False:\\n                    visited[(nx, ny)] = True \\n\\n                    heapq.heappush(st, (grid[nx][ny], (nx, ny)))\\n        \\n        for i in range(1, len(seq)): \\n            if seq[i-1] > seq[i]:\\n                seq[i] = seq[i-1]\\n                            \\n        return [bisect_left(seq, i) for i in queries]\\n",
                "codeTag": "Java"
            },
            {
                "id": 2900847,
                "title": "100-faster-using-priorityqueue",
                "content": "```\\nclass Solution {\\n    \\n    int dirs[][] = new int[][]{{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\\n    \\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        /**\\n        Thought Process -> \\n        * for each queries[i], We need to find count of values which are connected 4-directionally starting from top-left corner\\n        * suppose we have to find count of values for query q then ans till q-1 should be added and we need to continue where we left\\n        * Hence, we need to sort the queries and maintain indices where we left already\\n        */\\n        \\n        int qLength = queries.length;\\n        int queriesIndices[][] = new int[qLength][2]; // query, index\\n        \\n        for(int i = 0; i < qLength; i++) {\\n            queriesIndices[i] = new int[]{queries[i], i};\\n        }\\n        Arrays.sort(queriesIndices, (q1, q2) -> q1[0] - q2[0]);\\n        \\n        int[] ans = new int[qLength];\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue(new Comp()); // (row, col, value) sorted by value in ascending order\\n        pq.add(new int[]{0,0,grid[0][0]});\\n        \\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        vis[0][0] = true;\\n        \\n        int count = 0;\\n        \\n        for(int[] q : queriesIndices) {\\n            int val = q[0];\\n            while(pq.size() > 0 && pq.peek()[2] < val) {\\n                int[] top = pq.remove();\\n                int r = top[0];\\n                int c = top[1];\\n                \\n                for(int[] dir : dirs) {\\n                    int newR = r + dir[0], newC = c + dir[1];\\n                    if(newR >= 0 && newR < grid.length && newC >= 0 && newC < grid[0].length && !vis[newR][newC]) {\\n                        vis[newR][newC] = true;\\n                        pq.add(new int[]{newR, newC, grid[newR][newC]});\\n                    }\\n                }\\n                \\n                count++;\\n            }\\n            ans[q[1]] = count;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\nclass Comp implements Comparator<int[]> {\\n    public int compare(int[] a, int b[]) {\\n        return a[2] - b[2];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int dirs[][] = new int[][]{{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\\n    \\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        /**\\n        Thought Process -> \\n        * for each queries[i], We need to find count of values which are connected 4-directionally starting from top-left corner\\n        * suppose we have to find count of values for query q then ans till q-1 should be added and we need to continue where we left\\n        * Hence, we need to sort the queries and maintain indices where we left already\\n        */\\n        \\n        int qLength = queries.length;\\n        int queriesIndices[][] = new int[qLength][2]; // query, index\\n        \\n        for(int i = 0; i < qLength; i++) {\\n            queriesIndices[i] = new int[]{queries[i], i};\\n        }\\n        Arrays.sort(queriesIndices, (q1, q2) -> q1[0] - q2[0]);\\n        \\n        int[] ans = new int[qLength];\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue(new Comp()); // (row, col, value) sorted by value in ascending order\\n        pq.add(new int[]{0,0,grid[0][0]});\\n        \\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        vis[0][0] = true;\\n        \\n        int count = 0;\\n        \\n        for(int[] q : queriesIndices) {\\n            int val = q[0];\\n            while(pq.size() > 0 && pq.peek()[2] < val) {\\n                int[] top = pq.remove();\\n                int r = top[0];\\n                int c = top[1];\\n                \\n                for(int[] dir : dirs) {\\n                    int newR = r + dir[0], newC = c + dir[1];\\n                    if(newR >= 0 && newR < grid.length && newC >= 0 && newC < grid[0].length && !vis[newR][newC]) {\\n                        vis[newR][newC] = true;\\n                        pq.add(new int[]{newR, newC, grid[newR][newC]});\\n                    }\\n                }\\n                \\n                count++;\\n            }\\n            ans[q[1]] = count;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\nclass Comp implements Comparator<int[]> {\\n    public int compare(int[] a, int b[]) {\\n        return a[2] - b[2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900683,
                "title": "priority-queue-based-simple-approach-with-intuition",
                "content": "# Intuition\\nThe essential thing to see is to stop processing questions in the order they appear and instead look for an order in which we can build on the previously processed query. We can see that if we have an answer for a smaller query, all we need to do is expand the prior island to accommodate the new inquiry.\\n# Complexity\\n- Time complexity:\\nO(n * m * log(n * m))\\n\\n- Space complexity:\\nO(n * m)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        query_idx = [(queries[idx], idx) for idx in range(len(queries))]\\n        query_idx.sort(reverse = True)\\n\\n        result = [None for _ in range(len(queries))]\\n        \\n        visited = {(0, 0)}\\n        seen = 0\\n        heap = [(grid[0][0], 0, 0)]\\n\\n        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n        ROWS, COLS = len(grid), len(grid[0])\\n        \\n        while query_idx:\\n            val, idx = query_idx.pop()\\n\\n            while heap and heap[0][0] < val:\\n                _, i, j = heappop(heap)\\n                seen += 1\\n\\n                for (ni, nj) in map(lambda dir: (i + dir[0], j + dir[1]), dirs):\\n                    if 0 <= ni < ROWS and 0 <= nj < COLS and (ni, nj) not in visited:\\n                        visited.add((ni, nj))\\n                        heappush(heap, (grid[ni][nj], ni, nj))\\n            \\n            result[idx] = seen\\n        \\n        return result\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        query_idx = [(queries[idx], idx) for idx in range(len(queries))]\\n        query_idx.sort(reverse = True)\\n\\n        result = [None for _ in range(len(queries))]\\n        \\n        visited = {(0, 0)}\\n        seen = 0\\n        heap = [(grid[0][0], 0, 0)]\\n\\n        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n        ROWS, COLS = len(grid), len(grid[0])\\n        \\n        while query_idx:\\n            val, idx = query_idx.pop()\\n\\n            while heap and heap[0][0] < val:\\n                _, i, j = heappop(heap)\\n                seen += 1\\n\\n                for (ni, nj) in map(lambda dir: (i + dir[0], j + dir[1]), dirs):\\n                    if 0 <= ni < ROWS and 0 <= nj < COLS and (ni, nj) not in visited:\\n                        visited.add((ni, nj))\\n                        heappush(heap, (grid[ni][nj], ni, nj))\\n            \\n            result[idx] = seen\\n        \\n        return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900633,
                "title": "dijkstra-prefix-sum-offline-queries",
                "content": "# Approach\\n- dijkstra for finding out the minimum query value(cost) required to reach each cell.\\n- we store the counts of these costs to then efficiently answer offline queries.\\n- prepare prefix array and provide answer for each query.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& g, vector<int>& queries) {\\n        int N = g.size(), M = g[0].size();\\n        vector<vector<int>> cost(N, vector<int> (M, INT_MAX));\\n        // cost[i][j] is the cost to reach cell {i, j} with minimum possible query value.\\n\\n        vector<int> prefix(1000000 + 2, 0); // v[i] is number of cell which requires i as query value to reach cell.\\n\\n        vector<vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        // priority_queue for dijkstra\\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;\\n\\n        int maxQueryValueRequired = g[0][0] + 1; // initial cost to start at top left ?!\\n        cost[0][0] = maxQueryValueRequired;\\n        pq.push({cost[0][0], 0, 0}); \\n\\n        while (!pq.empty()) {\\n            tuple<int, int, int> t = pq.top();\\n            pq.pop();\\n            maxQueryValueRequired = max(maxQueryValueRequired, get<0>(t));\\n            // maxQueryValueRequired will be the max cell value (+1 for strictly greater) we have encounter till here.\\n\\n            // we increament the node count which will require maxQueryValueRequired as to reach that cell.\\n            prefix[maxQueryValueRequired]++;\\n            int x = get<1> (t), y = get<2> (t);\\n            for (auto &d: dir) {\\n                int X = x + d[0];\\n                int Y = y + d[1];\\n                if (X >= N || X < 0 || Y < 0 || Y >= M) continue;\\n\\n                // if cost of the the neighbour cell will be less when we travel from cur cell ?!\\n                if (cost[X][Y] > max(cost[x][y], g[X][Y] + 1)) {\\n                    cost[X][Y] = max(cost[x][y], g[X][Y] + 1); // g[X][Y] + 1 for strictly higher value required to visit cell.\\n                    pq.push({cost[X][Y], X, Y});\\n                }\\n            }\\n        }\\n\\n        // prefix sum for offline queries\\n        for (int i = 1; i < 1000002; ++i) prefix[i] += prefix[i - 1];\\n        transform(begin(queries), end(queries), begin(queries), [&](int val){ return prefix[val]; });\\n        return queries;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& g, vector<int>& queries) {\\n        int N = g.size(), M = g[0].size();\\n        vector<vector<int>> cost(N, vector<int> (M, INT_MAX));\\n        // cost[i][j] is the cost to reach cell {i, j} with minimum possible query value.\\n\\n        vector<int> prefix(1000000 + 2, 0); // v[i] is number of cell which requires i as query value to reach cell.\\n\\n        vector<vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        // priority_queue for dijkstra\\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;\\n\\n        int maxQueryValueRequired = g[0][0] + 1; // initial cost to start at top left ?!\\n        cost[0][0] = maxQueryValueRequired;\\n        pq.push({cost[0][0], 0, 0}); \\n\\n        while (!pq.empty()) {\\n            tuple<int, int, int> t = pq.top();\\n            pq.pop();\\n            maxQueryValueRequired = max(maxQueryValueRequired, get<0>(t));\\n            // maxQueryValueRequired will be the max cell value (+1 for strictly greater) we have encounter till here.\\n\\n            // we increament the node count which will require maxQueryValueRequired as to reach that cell.\\n            prefix[maxQueryValueRequired]++;\\n            int x = get<1> (t), y = get<2> (t);\\n            for (auto &d: dir) {\\n                int X = x + d[0];\\n                int Y = y + d[1];\\n                if (X >= N || X < 0 || Y < 0 || Y >= M) continue;\\n\\n                // if cost of the the neighbour cell will be less when we travel from cur cell ?!\\n                if (cost[X][Y] > max(cost[x][y], g[X][Y] + 1)) {\\n                    cost[X][Y] = max(cost[x][y], g[X][Y] + 1); // g[X][Y] + 1 for strictly higher value required to visit cell.\\n                    pq.push({cost[X][Y], X, Y});\\n                }\\n            }\\n        }\\n\\n        // prefix sum for offline queries\\n        for (int i = 1; i < 1000002; ++i) prefix[i] += prefix[i - 1];\\n        transform(begin(queries), end(queries), begin(queries), [&](int val){ return prefix[val]; });\\n        return queries;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900632,
                "title": "c-dijkstra-s-intuition-with-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInuition to use Dijkstra\\'s for calculating the minimum weight you can get\\nfor visting any node r, c where wt will be defined by maximum edge wt in the path instead of usual weight of the path in dijkstra\\'s\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct cmp {\\n        bool operator()(const pair<pair<int, int>, int>& p1, const pair<pair<int, int>, int>& p2) {\\n            return p1.second > p2.second;\\n        }\\n    };\\n    \\n    int dir[4][2] = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n    \\n    bool isValid(int r, int c, vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        return r >= 0 && r < n && c >= 0 && c < m;\\n    }\\n    \\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        priority_queue<pair<pair<int, int>, int>, vector<pair<pair<int, int>, int>>, cmp> q;\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int> > dis(n, vector<int>(m, INT_MAX));\\n        vector<vector<bool> > f(n, vector<bool>(m, false));\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                dis[i][j] = INT_MAX;\\n            }\\n        }\\n        \\n        q.push({{0, 0}, grid[0][0]});\\n        dis[0][0] = grid[0][0];\\n        \\n        while (!q.empty()) {\\n            pair<pair<int, int>, int> nodePair = q.top();\\n            q.pop();\\n            \\n            int r = nodePair.first.first;\\n            int c = nodePair.first.second;\\n            \\n            if (f[r][c]) continue;\\n            \\n            int wt = nodePair.second;\\n            //cout<<r<<\" \"<<c<<\" \"<<wt<<endl;\\n            for (int d = 0; d < 4; d++) {\\n                int n_r = r + dir[d][0];\\n                int n_c = c + dir[d][1];\\n                \\n                if (isValid(n_r, n_c, grid) && !f[n_r][n_c] && dis[n_r][n_c] > max(wt, grid[n_r][n_c])) {\\n                    dis[n_r][n_c] = max(wt, grid[n_r][n_c]);\\n                    q.push({{n_r, n_c}, dis[n_r][n_c]});\\n                }\\n            }\\n            f[r][c] = true;\\n        }\\n        \\n        vector<int> values;\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                //cout<<dis[i][j]<<\" \";\\n                values.push_back(dis[i][j]);\\n            }\\n            //cout<<endl;\\n        }\\n        \\n        sort(values.begin(), values.end());\\n        \\n        int k = queries.size();\\n        \\n        vector<int> ans(k, 0);\\n        \\n        for (int i = 0; i < k; i++) {\\n            int idx = (int)(lower_bound(values.begin(), values.end(), queries[i]) - values.begin());\\n            idx--;\\n            ans[i] = idx + 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct cmp {\\n        bool operator()(const pair<pair<int, int>, int>& p1, const pair<pair<int, int>, int>& p2) {\\n            return p1.second > p2.second;\\n        }\\n    };\\n    \\n    int dir[4][2] = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n    \\n    bool isValid(int r, int c, vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        return r >= 0 && r < n && c >= 0 && c < m;\\n    }\\n    \\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        priority_queue<pair<pair<int, int>, int>, vector<pair<pair<int, int>, int>>, cmp> q;\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int> > dis(n, vector<int>(m, INT_MAX));\\n        vector<vector<bool> > f(n, vector<bool>(m, false));\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                dis[i][j] = INT_MAX;\\n            }\\n        }\\n        \\n        q.push({{0, 0}, grid[0][0]});\\n        dis[0][0] = grid[0][0];\\n        \\n        while (!q.empty()) {\\n            pair<pair<int, int>, int> nodePair = q.top();\\n            q.pop();\\n            \\n            int r = nodePair.first.first;\\n            int c = nodePair.first.second;\\n            \\n            if (f[r][c]) continue;\\n            \\n            int wt = nodePair.second;\\n            //cout<<r<<\" \"<<c<<\" \"<<wt<<endl;\\n            for (int d = 0; d < 4; d++) {\\n                int n_r = r + dir[d][0];\\n                int n_c = c + dir[d][1];\\n                \\n                if (isValid(n_r, n_c, grid) && !f[n_r][n_c] && dis[n_r][n_c] > max(wt, grid[n_r][n_c])) {\\n                    dis[n_r][n_c] = max(wt, grid[n_r][n_c]);\\n                    q.push({{n_r, n_c}, dis[n_r][n_c]});\\n                }\\n            }\\n            f[r][c] = true;\\n        }\\n        \\n        vector<int> values;\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                //cout<<dis[i][j]<<\" \";\\n                values.push_back(dis[i][j]);\\n            }\\n            //cout<<endl;\\n        }\\n        \\n        sort(values.begin(), values.end());\\n        \\n        int k = queries.size();\\n        \\n        vector<int> ans(k, 0);\\n        \\n        for (int i = 0; i < k; i++) {\\n            int idx = (int)(lower_bound(values.begin(), values.end(), queries[i]) - values.begin());\\n            idx--;\\n            ans[i] = idx + 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2900566,
                "title": "sorting-queries",
                "content": "As the queries are offline, we can sort the queries and find answers incremently\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int n = grid.size(), m = grid[0].size(), curAns = 0;\\n        vector<pair<int, int>> vec;\\n        vector<int> ans(queries.size(), 0), chng = {-1, 0, 1, 0, -1};\\n        vector<vector<int>> vis(n, vector<int> (m, 0));\\n        priority_queue<vector<int>, vector<vector<int>>,greater<vector<int>> > pq;\\n        \\n        for(int i = 0;i < queries.size();i++) vec.push_back({queries[i], i});\\n        sort(begin(vec), end(vec));\\n        pq.push({grid[0][0], 0, 0});\\n        vis[0][0] = 1;\\n        \\n        for(auto& p: vec) {\\n            int val = p.first, index = p.second;\\n            \\n            while(pq.size()) {\\n                auto v = pq.top(); pq.pop();\\n                int curVal = v[0], x = v[1], y = v[2];\\n                \\n                if(curVal >= val) {pq.push(v); break;} \\n                curAns++;\\n\\n                for(int i = 0;i < 4;i++){\\n                    int nx = x + chng[i];\\n                    int ny = y + chng[i + 1];\\n\\n                    if(nx >= 0 && nx < n && ny >= 0&& ny < m && !vis[nx][ny]) {\\n                        vis[nx][ny] = 1;\\n                        pq.push({grid[nx][ny], nx, ny});\\n                    }\\n                }\\n            }\\n            \\n            ans[index] = curAns;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int n = grid.size(), m = grid[0].size(), curAns = 0;\\n        vector<pair<int, int>> vec;\\n        vector<int> ans(queries.size(), 0), chng = {-1, 0, 1, 0, -1};\\n        vector<vector<int>> vis(n, vector<int> (m, 0));\\n        priority_queue<vector<int>, vector<vector<int>>,greater<vector<int>> > pq;\\n        \\n        for(int i = 0;i < queries.size();i++) vec.push_back({queries[i], i});\\n        sort(begin(vec), end(vec));\\n        pq.push({grid[0][0], 0, 0});\\n        vis[0][0] = 1;\\n        \\n        for(auto& p: vec) {\\n            int val = p.first, index = p.second;\\n            \\n            while(pq.size()) {\\n                auto v = pq.top(); pq.pop();\\n                int curVal = v[0], x = v[1], y = v[2];\\n                \\n                if(curVal >= val) {pq.push(v); break;} \\n                curAns++;\\n\\n                for(int i = 0;i < 4;i++){\\n                    int nx = x + chng[i];\\n                    int ny = y + chng[i + 1];\\n\\n                    if(nx >= 0 && nx < n && ny >= 0&& ny < m && !vis[nx][ny]) {\\n                        vis[nx][ny] = 1;\\n                        pq.push({grid[nx][ny], nx, ny});\\n                    }\\n                }\\n            }\\n            \\n            ans[index] = curAns;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900565,
                "title": "java-two-solutions-bfs-sort-treemap",
                "content": "\\n3.BFS + Sort\\n```\\n    //3.BFS + Sort\\n    //Runtime: 188 ms, 100%; Memory: 57.8 MB, 100%\\n    //Time: O(L + L * log(L) + M * N * log(M * N)); Space: O(L + log(L) + M * N)\\n    //let L be the length of the queries\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        int[] res = new int[queries.length];\\n\\n        //Time: O(L + L * log(L)); Space: O(L + log(L)\\n        List<int[]> querylist = new ArrayList<>();\\n        for (int i = 0; i < queries.length; i++) querylist.add(new int[]{queries[i],i});\\n        Collections.sort(querylist, Comparator.comparingInt(a -> a[0]));\\n\\n        //Space: O(M * N);\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        PriorityQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(a -> a[2]));\\n        queue.add(new int[]{0, 0, grid[0][0]});\\n        visited[0][0] = true;\\n\\n        //Time: O(M * N * log(M * N));\\n        int idx = 0, sum = 0;\\n        while (!queue.isEmpty()) {\\n            int[] cell = queue.poll();\\n            int val = cell[2];\\n\\n            while (idx < querylist.size() && val >= querylist.get(idx)[0])\\n                res[querylist.get(idx++)[1]] = sum;\\n\\n            if (idx == querylist.size()) break;\\n            sum++;\\n\\n            for (int[] offset : offsets) {\\n                int x = cell[0] + offset[0];\\n                int y = cell[1] + offset[1];\\n                if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length) continue;\\n                if (visited[x][y] == true) continue;\\n                visited[x][y] = true;\\n                queue.offer(new int[]{x, y, grid[x][y]});\\n            }\\n        }\\n\\n        while (idx < querylist.size()) res[querylist.get(idx++)[1]] = sum;\\n        return res;\\n    }\\n\\n```\\n# 2.BFS + TreeMap\\n```\\n    //2.BFS + TreeMap\\n    //Runtime: 149 ms, 100%; Memory: 59.6 MB, 100%\\n    //Time: O(M * N * log(M * N) + L * log(M * N)); Space: O(M * N)\\n    //let L be the length of the queries\\n    public int[] maxPoints_2(int[][] grid, int[] queries) {\\n        int max = 0, sum = 0;\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        PriorityQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(a -> a[2]));\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n\\n        queue.offer(new int[]{0, 0, grid[0][0]});\\n        visited[0][0] = true;\\n\\n        while (!queue.isEmpty()) {\\n            int[] cell = queue.poll();\\n            max = Math.max(cell[2], max);\\n            map.put(max, ++sum);\\n\\n            for (int[] offset : offsets) {\\n                int x = offset[0] + cell[0];\\n                int y = offset[1] + cell[1];\\n                if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length) continue;\\n                if (visited[x][y]) continue;\\n                visited[x][y] = true;\\n                queue.offer(new int[]{x, y, grid[x][y]});\\n            }\\n        }\\n\\n        int[] res = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            Integer cur = map.lowerKey(queries[i]);\\n            if (cur != null) res[i] = map.get(cur);\\n        }\\n        return res;\\n    }\\n```\\n# 1.Brute force + BFS\\n```\\n\\n    //1.Brute force + BFS\\n    //TLE\\n    //Time: O(L * M * N); Space: O(M * N + L)\\n    //let L be the length of the queries\\n    int[][] offsets = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n    public int[] maxPoints_1(int[][] grid, int[] queries) {\\n        int[] res = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++)\\n            res[i] = help_bfs(grid, queries[i]);\\n        return res;\\n    }\\n\\n    private int help_bfs(int[][] grid, int query){\\n        int res = 0;\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        Queue<int[]> queue = new ArrayDeque<>();\\n\\n        if (query > grid[0][0]) {\\n            visited[0][0] = true;\\n            queue.add(new int[]{0, 0});\\n            res++;\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int[] cell = queue.poll();\\n\\n            for (int[] offset : offsets) {\\n                int x = cell[0] + offset[0];\\n                int y = cell[1] + offset[1];\\n                if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length) continue;\\n                if (visited[x][y]) continue;\\n                visited[x][y] = true;\\n                if (query > grid[x][y]) {\\n                    queue.add(new int[]{x, y});\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sort",
                    "Breadth-First Search"
                ],
                "code": "```\\n    //3.BFS + Sort\\n    //Runtime: 188 ms, 100%; Memory: 57.8 MB, 100%\\n    //Time: O(L + L * log(L) + M * N * log(M * N)); Space: O(L + log(L) + M * N)\\n    //let L be the length of the queries\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        int[] res = new int[queries.length];\\n\\n        //Time: O(L + L * log(L)); Space: O(L + log(L)\\n        List<int[]> querylist = new ArrayList<>();\\n        for (int i = 0; i < queries.length; i++) querylist.add(new int[]{queries[i],i});\\n        Collections.sort(querylist, Comparator.comparingInt(a -> a[0]));\\n\\n        //Space: O(M * N);\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        PriorityQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(a -> a[2]));\\n        queue.add(new int[]{0, 0, grid[0][0]});\\n        visited[0][0] = true;\\n\\n        //Time: O(M * N * log(M * N));\\n        int idx = 0, sum = 0;\\n        while (!queue.isEmpty()) {\\n            int[] cell = queue.poll();\\n            int val = cell[2];\\n\\n            while (idx < querylist.size() && val >= querylist.get(idx)[0])\\n                res[querylist.get(idx++)[1]] = sum;\\n\\n            if (idx == querylist.size()) break;\\n            sum++;\\n\\n            for (int[] offset : offsets) {\\n                int x = cell[0] + offset[0];\\n                int y = cell[1] + offset[1];\\n                if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length) continue;\\n                if (visited[x][y] == true) continue;\\n                visited[x][y] = true;\\n                queue.offer(new int[]{x, y, grid[x][y]});\\n            }\\n        }\\n\\n        while (idx < querylist.size()) res[querylist.get(idx++)[1]] = sum;\\n        return res;\\n    }\\n\\n```\n```\\n    //2.BFS + TreeMap\\n    //Runtime: 149 ms, 100%; Memory: 59.6 MB, 100%\\n    //Time: O(M * N * log(M * N) + L * log(M * N)); Space: O(M * N)\\n    //let L be the length of the queries\\n    public int[] maxPoints_2(int[][] grid, int[] queries) {\\n        int max = 0, sum = 0;\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        PriorityQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(a -> a[2]));\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n\\n        queue.offer(new int[]{0, 0, grid[0][0]});\\n        visited[0][0] = true;\\n\\n        while (!queue.isEmpty()) {\\n            int[] cell = queue.poll();\\n            max = Math.max(cell[2], max);\\n            map.put(max, ++sum);\\n\\n            for (int[] offset : offsets) {\\n                int x = offset[0] + cell[0];\\n                int y = offset[1] + cell[1];\\n                if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length) continue;\\n                if (visited[x][y]) continue;\\n                visited[x][y] = true;\\n                queue.offer(new int[]{x, y, grid[x][y]});\\n            }\\n        }\\n\\n        int[] res = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            Integer cur = map.lowerKey(queries[i]);\\n            if (cur != null) res[i] = map.get(cur);\\n        }\\n        return res;\\n    }\\n```\n```\\n\\n    //1.Brute force + BFS\\n    //TLE\\n    //Time: O(L * M * N); Space: O(M * N + L)\\n    //let L be the length of the queries\\n    int[][] offsets = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n    public int[] maxPoints_1(int[][] grid, int[] queries) {\\n        int[] res = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++)\\n            res[i] = help_bfs(grid, queries[i]);\\n        return res;\\n    }\\n\\n    private int help_bfs(int[][] grid, int query){\\n        int res = 0;\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        Queue<int[]> queue = new ArrayDeque<>();\\n\\n        if (query > grid[0][0]) {\\n            visited[0][0] = true;\\n            queue.add(new int[]{0, 0});\\n            res++;\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int[] cell = queue.poll();\\n\\n            for (int[] offset : offsets) {\\n                int x = cell[0] + offset[0];\\n                int y = cell[1] + offset[1];\\n                if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length) continue;\\n                if (visited[x][y]) continue;\\n                visited[x][y] = true;\\n                if (query > grid[x][y]) {\\n                    queue.add(new int[]{x, y});\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2900547,
                "title": "c-topological-sorting-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int dir[4][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}};\\n\\n    bool valid(int i, int j, int m, int n) {\\n        return (i >= 0 && i < m && j >= 0 && j < n);\\n    }\\n\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        //{val, x, y}\\n        set<pair<int, pair<int, int>>> minh;\\n        vector<vector<bool>> used(m, vector<bool>(n));\\n        minh.insert({grid[0][0], {0, 0}});\\n\\n        vector<int> order;\\n        while(minh.size() > 0) {\\n            auto it = minh.begin();\\n            int i = it->second.first, j = it->second.second;\\n            order.push_back(it->first);\\n            used[i][j] = true;\\n            minh.erase(it);\\n            for(int k = 0; k < 4; k++) {\\n                int x = dir[k][0] + i;\\n                int y = dir[k][1] + j;\\n                if(valid(x, y, m, n) && !used[x][y] && !minh.count({grid[x][y], {x, y}})) \\n                    minh.insert({grid[x][y], {x, y}});\\n            }\\n        }\\n\\n        assert(order.size() == m*n);\\n\\n        for(int i = 1; i < order.size(); i++) {\\n            if(order[i] < order[i-1])\\n                order[i] = order[i-1];\\n        }\\n\\n        vector<int> ans;\\n        for(int val: queries) {\\n            int pos = lower_bound(order.begin(), order.end(), val) - order.begin();\\n            ans.push_back(pos);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Topological Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    int dir[4][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}};\\n\\n    bool valid(int i, int j, int m, int n) {\\n        return (i >= 0 && i < m && j >= 0 && j < n);\\n    }\\n\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        //{val, x, y}\\n        set<pair<int, pair<int, int>>> minh;\\n        vector<vector<bool>> used(m, vector<bool>(n));\\n        minh.insert({grid[0][0], {0, 0}});\\n\\n        vector<int> order;\\n        while(minh.size() > 0) {\\n            auto it = minh.begin();\\n            int i = it->second.first, j = it->second.second;\\n            order.push_back(it->first);\\n            used[i][j] = true;\\n            minh.erase(it);\\n            for(int k = 0; k < 4; k++) {\\n                int x = dir[k][0] + i;\\n                int y = dir[k][1] + j;\\n                if(valid(x, y, m, n) && !used[x][y] && !minh.count({grid[x][y], {x, y}})) \\n                    minh.insert({grid[x][y], {x, y}});\\n            }\\n        }\\n\\n        assert(order.size() == m*n);\\n\\n        for(int i = 1; i < order.size(); i++) {\\n            if(order[i] < order[i-1])\\n                order[i] = order[i-1];\\n        }\\n\\n        vector<int> ans;\\n        for(int val: queries) {\\n            int pos = lower_bound(order.begin(), order.end(), val) - order.begin();\\n            ans.push_back(pos);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1712810,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "There are better color combinations in world than light gray and white combination. :|"
                    },
                    {
                        "username": "vigneshr1603",
                        "content": "Am I color blind? All 3 diagrams of sol1 are same "
                    },
                    {
                        "username": "WitcherG",
                        "content": "the blurred cells are the visited ones, i got confused too."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "For people who are having trouble with the colors of the matrices.\\n\\n![image.png](https://assets.leetcode.com/users/images/1e2e29d1-be89-4c26-a2a6-8e4fe5ad11dc_1671030245.3139484.png)"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent 20 mins trying to understand what the matrices are, while others completed this question under 15mins. :\\\\"
                    },
                    {
                        "username": "Martician",
                        "content": "This is the coolest problem I have encountered."
                    },
                    {
                        "username": "dev-madhurendra",
                        "content": "Why this solution is not working for test case\\nMy Solution : \\n `\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &a,vector<int> &q,vector<vector<bool>> &vis,int n,int m,int row,int col,int target){\\n        if(row>=n || col >= m || row < 0 || col < 0 || vis[row][col] || a[row][col]>=target){\\n            return;\\n        }\\n        vis[row][col] = true;\\n        dfs(a,q,vis,n,m,row-1,col,target);\\n        dfs(a,q,vis,n,m,row+1,col,target);\\n        dfs(a,q,vis,n,m,row,col+1,target);\\n        dfs(a,q,vis,n,m,row+1,col-1,target);\\n    }\\n    vector<int> maxPoints(vector<vector<int>> &a,vector<int> &q){\\n        int n = a.size();\\n        int m = a[0].size();\\n        \\n\\n        vector<int> res;\\n        for(int i=0;i<q.size();++i){\\n            vector<vector<bool>> vis(n,vector<bool>(m,false));\\n            dfs(a,q,vis,n,m,0,0,q[i]);\\n            int ans = 0;\\n            for(int i=0;i<n;++i){\\n                for(int j=0;j<m;++j){\\n                    if(vis[i][j]){\\n                        ans++;\\n                    }\\n                }\\n            }\\n\\n            res.push_back(ans);\\n        }\\n\\n        return res;\\n    }\\n};\\n`\\n\\n\\n\\n\\nGrid : \\n[[249472,735471,144880,992181,760916,920551,898524,37043,422852,194509,714395,325171],[295872,922051,900801,634980,644237,912433,857189,98466,725226,984534,370121,399006],[618420,573065,587011,298153,694872,12760,880413,593508,474772,291113,852444,77998],[67650,426517,146447,190319,379151,184754,479219,106819,138473,865661,799297,228827],[390392,789371,772048,730506,7144,862164,650590,21524,879440,396198,408897,851020],[932044,662093,436861,246956,128943,167432,267483,148325,458128,418348,900594,831373],[742255,795191,598857,441846,243888,777685,313717,560586,257220,488025,846817,554722],[252507,621902,87704,599753,651175,305330,620166,631193,385405,183376,432598,706692],[984416,996917,586571,324595,784565,300514,101313,685863,703194,729430,732044,349877],[155629,290992,539879,173659,989930,373725,701670,992137,893024,455455,454886,559081],[252809,641084,632837,764260,68790,732601,349257,208701,613650,429049,983008,76324],[918085,126894,909148,194638,915416,225708,184408,462852,40392,964501,436864,785076],[875475,442333,111818,494972,486734,901577,46210,326422,603800,176902,315208,225178],[171174,458473,744971,872087,680060,95371,806370,322605,349331,736473,306720,556064],[207705,587869,129465,543368,840821,977451,399877,486877,327390,8865,605705,481076]]\\n\\nQueries : \\n[690474,796832,913701,939418,46696,266869,150594,948153,718874] \\n\\n"
                    },
                    {
                        "username": "yashsangwan2611",
                        "content": "can anybody tell me why it is giving wrong answer and only passes 7 cases as my approach is correct\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& q) {\\n        int m=grid.size(),n=grid[0].size(),k=q.size();\\n        vector<int>ans(k);\\n        vector<pair<int,int>>queries(k);\\n        for(int i=0;i<k;i++){\\n            queries[i]={q[i],i};\\n        }\\n        sort(queries.begin(),queries.end());\\n        set<pair<int,int>>s;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        s.insert({0,0});\\n        int cnt=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(!pq.empty()&&pq.top().first<queries[i].first){\\n                cnt++;\\n                int x=pq.top().second.first;\\n                int y=pq.top().second.second;\\n                pq.pop();\\n                if(x+1<m){\\n                    if(s.find({x+1,y})==s.end()){\\n                        pq.push({grid[x+1][y],{x+1,y}});\\n                        s.insert({x+1,y});\\n                    }\\n                }\\n                if(y+1<n){\\n                    if(s.find({x,y+1})==s.end()){\\n                        pq.push({grid[x][y+1],{x,y+1}});\\n                        s.insert({x,y+1});\\n                    }\\n                }   \\n            }\\n             ans[i]=cnt;\\n        }\\n        vector<int>res(k);\\n        for(int i=0;i<queries.size();i++){\\n            res[queries[i].second]=ans[i];\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Test cases are weak My brute force code got accepted."
                    },
                    {
                        "username": "15o1",
                        "content": "not anymore :("
                    },
                    {
                        "username": "ajay36",
                        "content": "why wouldn\\'t DFS work here? "
                    },
                    {
                        "username": "saam_neu",
                        "content": "Can anyone tell the mistake in my dfs. Its throwing error for the following test case\\n\\n```\\ndir=[0,1,0,-1,0]\\n        \\n        def dfs(q,nums,visit):\\n            val1,x,y=q[0]\\n            #visit.add((x,y))\\n            if val1>=nums:\\n                return\\n            heappop(q)    \\n            self.prevCount+=1\\n            grid[x][y]=\\'#\\'\\n            for i in range(len(dir)-1):\\n                a,b=x+dir[i],y+dir[i+1]\\n                if 0 <= a < rows and 0 <= b < cols and grid[a][b] !=\\'#\\':\\n                    if (a,b) not in visit:\\n                        visit.add((a,b))\\n                        heappush(q, (grid[a][b], a, b))              \\n                    dfs(q,nums,visit)\\n\\n        query = sorted(set(queries))\\n        r = {}\\n        rows, cols = len(grid), len(grid[0])\\n        q = [(grid[0][0], 0, 0)]\\n        self.prevCount = 0\\n        visit=set()\\n        \\n        for num in query:\\n            dfs(q,num,visit)\\n            r[num]=self.prevCount\\n            \\n        \\n        final = [r[num] for num in queries]\\n        return final\\n\\ngrid:\\n[[444424,409221,703419,11307,578382,330430,522887,38831,267101,315541,148425,360873],[353160,3217,718922,509568,494803,327636,715882,456279,374061,701863,711832,644822],[459535,264294,246310,405317,275802,948618,449015,176733,921040,56692,632708,556696],[167402,594284,8377,766746,728202,329140,399028,907843,68783,149661,244321,861358],[727577,582470,946680,222674,152875,128658,389710,581164,512061,367464,883657,78004],[463513,473823,328325,888670,267782,435621,153221,877511,900231,72761,825121,532939],[992835,33883,587426,680675,674055,682929,750368,241142,241026,369751,462134,785672],[915635,918034,398025,400424,695630,594801,748962,278900,705889,570212,42410,823342],[644602,961002,489119,606936,327139,664880,455045,231423,114466,315707,25092,961268],[962857,647428,139005,221262,469484,669734,66022,473118,258066,67408,545435,316643],[977028,938186,277400,756609,491213,704014,292941,392893,280499,650462,270100,477276],[393574,562825,637562,639836,8932,540799,758836,403682,79851,17885,851550,499020],[403665,119906,305796,88211,759076,441097,164887,709599,194,468995,922288,359913],[696749,265394,517399,161062,512967,205098,814158,627951,286474,763625,370987,798077],[166098,940946,871758,690278,903705,368584,576209,94794,25522,255261,209835,540769],[8088,89612,457088,492467,511285,900536,734726,683046,515695,14749,988608,977041],[76149,112648,515127,257871,912674,880020,32805,688253,722582,931114,734057,939655],[395351,377494,543729,368629,913310,69242,737795,849175,870860,278493,575561,111787]]\\n\\nqueries:\\n[483649,690923,317026,408761,985459,619592,287085,302896,241756,557463,914140,994632,511904,377570,272415,840485,578955,797418,609746,388421,517504,170621,188489,169881,466574]"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "You have your frontier of places to visit in a heap, which means you don\\'t have to do a recursive call to dfs().  Just iterate while the lead element in the heap has low enough value.  Maybe you are not exploring sufficiently because. of this?  Another thought is that you seem to be putting \\'#\\' in the grid and also using a visit set;  you don\\'t need to do both!"
                    }
                ]
            },
            {
                "id": 1712933,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "There are better color combinations in world than light gray and white combination. :|"
                    },
                    {
                        "username": "vigneshr1603",
                        "content": "Am I color blind? All 3 diagrams of sol1 are same "
                    },
                    {
                        "username": "WitcherG",
                        "content": "the blurred cells are the visited ones, i got confused too."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "For people who are having trouble with the colors of the matrices.\\n\\n![image.png](https://assets.leetcode.com/users/images/1e2e29d1-be89-4c26-a2a6-8e4fe5ad11dc_1671030245.3139484.png)"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent 20 mins trying to understand what the matrices are, while others completed this question under 15mins. :\\\\"
                    },
                    {
                        "username": "Martician",
                        "content": "This is the coolest problem I have encountered."
                    },
                    {
                        "username": "dev-madhurendra",
                        "content": "Why this solution is not working for test case\\nMy Solution : \\n `\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &a,vector<int> &q,vector<vector<bool>> &vis,int n,int m,int row,int col,int target){\\n        if(row>=n || col >= m || row < 0 || col < 0 || vis[row][col] || a[row][col]>=target){\\n            return;\\n        }\\n        vis[row][col] = true;\\n        dfs(a,q,vis,n,m,row-1,col,target);\\n        dfs(a,q,vis,n,m,row+1,col,target);\\n        dfs(a,q,vis,n,m,row,col+1,target);\\n        dfs(a,q,vis,n,m,row+1,col-1,target);\\n    }\\n    vector<int> maxPoints(vector<vector<int>> &a,vector<int> &q){\\n        int n = a.size();\\n        int m = a[0].size();\\n        \\n\\n        vector<int> res;\\n        for(int i=0;i<q.size();++i){\\n            vector<vector<bool>> vis(n,vector<bool>(m,false));\\n            dfs(a,q,vis,n,m,0,0,q[i]);\\n            int ans = 0;\\n            for(int i=0;i<n;++i){\\n                for(int j=0;j<m;++j){\\n                    if(vis[i][j]){\\n                        ans++;\\n                    }\\n                }\\n            }\\n\\n            res.push_back(ans);\\n        }\\n\\n        return res;\\n    }\\n};\\n`\\n\\n\\n\\n\\nGrid : \\n[[249472,735471,144880,992181,760916,920551,898524,37043,422852,194509,714395,325171],[295872,922051,900801,634980,644237,912433,857189,98466,725226,984534,370121,399006],[618420,573065,587011,298153,694872,12760,880413,593508,474772,291113,852444,77998],[67650,426517,146447,190319,379151,184754,479219,106819,138473,865661,799297,228827],[390392,789371,772048,730506,7144,862164,650590,21524,879440,396198,408897,851020],[932044,662093,436861,246956,128943,167432,267483,148325,458128,418348,900594,831373],[742255,795191,598857,441846,243888,777685,313717,560586,257220,488025,846817,554722],[252507,621902,87704,599753,651175,305330,620166,631193,385405,183376,432598,706692],[984416,996917,586571,324595,784565,300514,101313,685863,703194,729430,732044,349877],[155629,290992,539879,173659,989930,373725,701670,992137,893024,455455,454886,559081],[252809,641084,632837,764260,68790,732601,349257,208701,613650,429049,983008,76324],[918085,126894,909148,194638,915416,225708,184408,462852,40392,964501,436864,785076],[875475,442333,111818,494972,486734,901577,46210,326422,603800,176902,315208,225178],[171174,458473,744971,872087,680060,95371,806370,322605,349331,736473,306720,556064],[207705,587869,129465,543368,840821,977451,399877,486877,327390,8865,605705,481076]]\\n\\nQueries : \\n[690474,796832,913701,939418,46696,266869,150594,948153,718874] \\n\\n"
                    },
                    {
                        "username": "yashsangwan2611",
                        "content": "can anybody tell me why it is giving wrong answer and only passes 7 cases as my approach is correct\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& q) {\\n        int m=grid.size(),n=grid[0].size(),k=q.size();\\n        vector<int>ans(k);\\n        vector<pair<int,int>>queries(k);\\n        for(int i=0;i<k;i++){\\n            queries[i]={q[i],i};\\n        }\\n        sort(queries.begin(),queries.end());\\n        set<pair<int,int>>s;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        s.insert({0,0});\\n        int cnt=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(!pq.empty()&&pq.top().first<queries[i].first){\\n                cnt++;\\n                int x=pq.top().second.first;\\n                int y=pq.top().second.second;\\n                pq.pop();\\n                if(x+1<m){\\n                    if(s.find({x+1,y})==s.end()){\\n                        pq.push({grid[x+1][y],{x+1,y}});\\n                        s.insert({x+1,y});\\n                    }\\n                }\\n                if(y+1<n){\\n                    if(s.find({x,y+1})==s.end()){\\n                        pq.push({grid[x][y+1],{x,y+1}});\\n                        s.insert({x,y+1});\\n                    }\\n                }   \\n            }\\n             ans[i]=cnt;\\n        }\\n        vector<int>res(k);\\n        for(int i=0;i<queries.size();i++){\\n            res[queries[i].second]=ans[i];\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Test cases are weak My brute force code got accepted."
                    },
                    {
                        "username": "15o1",
                        "content": "not anymore :("
                    },
                    {
                        "username": "ajay36",
                        "content": "why wouldn\\'t DFS work here? "
                    },
                    {
                        "username": "saam_neu",
                        "content": "Can anyone tell the mistake in my dfs. Its throwing error for the following test case\\n\\n```\\ndir=[0,1,0,-1,0]\\n        \\n        def dfs(q,nums,visit):\\n            val1,x,y=q[0]\\n            #visit.add((x,y))\\n            if val1>=nums:\\n                return\\n            heappop(q)    \\n            self.prevCount+=1\\n            grid[x][y]=\\'#\\'\\n            for i in range(len(dir)-1):\\n                a,b=x+dir[i],y+dir[i+1]\\n                if 0 <= a < rows and 0 <= b < cols and grid[a][b] !=\\'#\\':\\n                    if (a,b) not in visit:\\n                        visit.add((a,b))\\n                        heappush(q, (grid[a][b], a, b))              \\n                    dfs(q,nums,visit)\\n\\n        query = sorted(set(queries))\\n        r = {}\\n        rows, cols = len(grid), len(grid[0])\\n        q = [(grid[0][0], 0, 0)]\\n        self.prevCount = 0\\n        visit=set()\\n        \\n        for num in query:\\n            dfs(q,num,visit)\\n            r[num]=self.prevCount\\n            \\n        \\n        final = [r[num] for num in queries]\\n        return final\\n\\ngrid:\\n[[444424,409221,703419,11307,578382,330430,522887,38831,267101,315541,148425,360873],[353160,3217,718922,509568,494803,327636,715882,456279,374061,701863,711832,644822],[459535,264294,246310,405317,275802,948618,449015,176733,921040,56692,632708,556696],[167402,594284,8377,766746,728202,329140,399028,907843,68783,149661,244321,861358],[727577,582470,946680,222674,152875,128658,389710,581164,512061,367464,883657,78004],[463513,473823,328325,888670,267782,435621,153221,877511,900231,72761,825121,532939],[992835,33883,587426,680675,674055,682929,750368,241142,241026,369751,462134,785672],[915635,918034,398025,400424,695630,594801,748962,278900,705889,570212,42410,823342],[644602,961002,489119,606936,327139,664880,455045,231423,114466,315707,25092,961268],[962857,647428,139005,221262,469484,669734,66022,473118,258066,67408,545435,316643],[977028,938186,277400,756609,491213,704014,292941,392893,280499,650462,270100,477276],[393574,562825,637562,639836,8932,540799,758836,403682,79851,17885,851550,499020],[403665,119906,305796,88211,759076,441097,164887,709599,194,468995,922288,359913],[696749,265394,517399,161062,512967,205098,814158,627951,286474,763625,370987,798077],[166098,940946,871758,690278,903705,368584,576209,94794,25522,255261,209835,540769],[8088,89612,457088,492467,511285,900536,734726,683046,515695,14749,988608,977041],[76149,112648,515127,257871,912674,880020,32805,688253,722582,931114,734057,939655],[395351,377494,543729,368629,913310,69242,737795,849175,870860,278493,575561,111787]]\\n\\nqueries:\\n[483649,690923,317026,408761,985459,619592,287085,302896,241756,557463,914140,994632,511904,377570,272415,840485,578955,797418,609746,388421,517504,170621,188489,169881,466574]"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "You have your frontier of places to visit in a heap, which means you don\\'t have to do a recursive call to dfs().  Just iterate while the lead element in the heap has low enough value.  Maybe you are not exploring sufficiently because. of this?  Another thought is that you seem to be putting \\'#\\' in the grid and also using a visit set;  you don\\'t need to do both!"
                    }
                ]
            },
            {
                "id": 1716413,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "There are better color combinations in world than light gray and white combination. :|"
                    },
                    {
                        "username": "vigneshr1603",
                        "content": "Am I color blind? All 3 diagrams of sol1 are same "
                    },
                    {
                        "username": "WitcherG",
                        "content": "the blurred cells are the visited ones, i got confused too."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "For people who are having trouble with the colors of the matrices.\\n\\n![image.png](https://assets.leetcode.com/users/images/1e2e29d1-be89-4c26-a2a6-8e4fe5ad11dc_1671030245.3139484.png)"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent 20 mins trying to understand what the matrices are, while others completed this question under 15mins. :\\\\"
                    },
                    {
                        "username": "Martician",
                        "content": "This is the coolest problem I have encountered."
                    },
                    {
                        "username": "dev-madhurendra",
                        "content": "Why this solution is not working for test case\\nMy Solution : \\n `\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &a,vector<int> &q,vector<vector<bool>> &vis,int n,int m,int row,int col,int target){\\n        if(row>=n || col >= m || row < 0 || col < 0 || vis[row][col] || a[row][col]>=target){\\n            return;\\n        }\\n        vis[row][col] = true;\\n        dfs(a,q,vis,n,m,row-1,col,target);\\n        dfs(a,q,vis,n,m,row+1,col,target);\\n        dfs(a,q,vis,n,m,row,col+1,target);\\n        dfs(a,q,vis,n,m,row+1,col-1,target);\\n    }\\n    vector<int> maxPoints(vector<vector<int>> &a,vector<int> &q){\\n        int n = a.size();\\n        int m = a[0].size();\\n        \\n\\n        vector<int> res;\\n        for(int i=0;i<q.size();++i){\\n            vector<vector<bool>> vis(n,vector<bool>(m,false));\\n            dfs(a,q,vis,n,m,0,0,q[i]);\\n            int ans = 0;\\n            for(int i=0;i<n;++i){\\n                for(int j=0;j<m;++j){\\n                    if(vis[i][j]){\\n                        ans++;\\n                    }\\n                }\\n            }\\n\\n            res.push_back(ans);\\n        }\\n\\n        return res;\\n    }\\n};\\n`\\n\\n\\n\\n\\nGrid : \\n[[249472,735471,144880,992181,760916,920551,898524,37043,422852,194509,714395,325171],[295872,922051,900801,634980,644237,912433,857189,98466,725226,984534,370121,399006],[618420,573065,587011,298153,694872,12760,880413,593508,474772,291113,852444,77998],[67650,426517,146447,190319,379151,184754,479219,106819,138473,865661,799297,228827],[390392,789371,772048,730506,7144,862164,650590,21524,879440,396198,408897,851020],[932044,662093,436861,246956,128943,167432,267483,148325,458128,418348,900594,831373],[742255,795191,598857,441846,243888,777685,313717,560586,257220,488025,846817,554722],[252507,621902,87704,599753,651175,305330,620166,631193,385405,183376,432598,706692],[984416,996917,586571,324595,784565,300514,101313,685863,703194,729430,732044,349877],[155629,290992,539879,173659,989930,373725,701670,992137,893024,455455,454886,559081],[252809,641084,632837,764260,68790,732601,349257,208701,613650,429049,983008,76324],[918085,126894,909148,194638,915416,225708,184408,462852,40392,964501,436864,785076],[875475,442333,111818,494972,486734,901577,46210,326422,603800,176902,315208,225178],[171174,458473,744971,872087,680060,95371,806370,322605,349331,736473,306720,556064],[207705,587869,129465,543368,840821,977451,399877,486877,327390,8865,605705,481076]]\\n\\nQueries : \\n[690474,796832,913701,939418,46696,266869,150594,948153,718874] \\n\\n"
                    },
                    {
                        "username": "yashsangwan2611",
                        "content": "can anybody tell me why it is giving wrong answer and only passes 7 cases as my approach is correct\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& q) {\\n        int m=grid.size(),n=grid[0].size(),k=q.size();\\n        vector<int>ans(k);\\n        vector<pair<int,int>>queries(k);\\n        for(int i=0;i<k;i++){\\n            queries[i]={q[i],i};\\n        }\\n        sort(queries.begin(),queries.end());\\n        set<pair<int,int>>s;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        s.insert({0,0});\\n        int cnt=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(!pq.empty()&&pq.top().first<queries[i].first){\\n                cnt++;\\n                int x=pq.top().second.first;\\n                int y=pq.top().second.second;\\n                pq.pop();\\n                if(x+1<m){\\n                    if(s.find({x+1,y})==s.end()){\\n                        pq.push({grid[x+1][y],{x+1,y}});\\n                        s.insert({x+1,y});\\n                    }\\n                }\\n                if(y+1<n){\\n                    if(s.find({x,y+1})==s.end()){\\n                        pq.push({grid[x][y+1],{x,y+1}});\\n                        s.insert({x,y+1});\\n                    }\\n                }   \\n            }\\n             ans[i]=cnt;\\n        }\\n        vector<int>res(k);\\n        for(int i=0;i<queries.size();i++){\\n            res[queries[i].second]=ans[i];\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Test cases are weak My brute force code got accepted."
                    },
                    {
                        "username": "15o1",
                        "content": "not anymore :("
                    },
                    {
                        "username": "ajay36",
                        "content": "why wouldn\\'t DFS work here? "
                    },
                    {
                        "username": "saam_neu",
                        "content": "Can anyone tell the mistake in my dfs. Its throwing error for the following test case\\n\\n```\\ndir=[0,1,0,-1,0]\\n        \\n        def dfs(q,nums,visit):\\n            val1,x,y=q[0]\\n            #visit.add((x,y))\\n            if val1>=nums:\\n                return\\n            heappop(q)    \\n            self.prevCount+=1\\n            grid[x][y]=\\'#\\'\\n            for i in range(len(dir)-1):\\n                a,b=x+dir[i],y+dir[i+1]\\n                if 0 <= a < rows and 0 <= b < cols and grid[a][b] !=\\'#\\':\\n                    if (a,b) not in visit:\\n                        visit.add((a,b))\\n                        heappush(q, (grid[a][b], a, b))              \\n                    dfs(q,nums,visit)\\n\\n        query = sorted(set(queries))\\n        r = {}\\n        rows, cols = len(grid), len(grid[0])\\n        q = [(grid[0][0], 0, 0)]\\n        self.prevCount = 0\\n        visit=set()\\n        \\n        for num in query:\\n            dfs(q,num,visit)\\n            r[num]=self.prevCount\\n            \\n        \\n        final = [r[num] for num in queries]\\n        return final\\n\\ngrid:\\n[[444424,409221,703419,11307,578382,330430,522887,38831,267101,315541,148425,360873],[353160,3217,718922,509568,494803,327636,715882,456279,374061,701863,711832,644822],[459535,264294,246310,405317,275802,948618,449015,176733,921040,56692,632708,556696],[167402,594284,8377,766746,728202,329140,399028,907843,68783,149661,244321,861358],[727577,582470,946680,222674,152875,128658,389710,581164,512061,367464,883657,78004],[463513,473823,328325,888670,267782,435621,153221,877511,900231,72761,825121,532939],[992835,33883,587426,680675,674055,682929,750368,241142,241026,369751,462134,785672],[915635,918034,398025,400424,695630,594801,748962,278900,705889,570212,42410,823342],[644602,961002,489119,606936,327139,664880,455045,231423,114466,315707,25092,961268],[962857,647428,139005,221262,469484,669734,66022,473118,258066,67408,545435,316643],[977028,938186,277400,756609,491213,704014,292941,392893,280499,650462,270100,477276],[393574,562825,637562,639836,8932,540799,758836,403682,79851,17885,851550,499020],[403665,119906,305796,88211,759076,441097,164887,709599,194,468995,922288,359913],[696749,265394,517399,161062,512967,205098,814158,627951,286474,763625,370987,798077],[166098,940946,871758,690278,903705,368584,576209,94794,25522,255261,209835,540769],[8088,89612,457088,492467,511285,900536,734726,683046,515695,14749,988608,977041],[76149,112648,515127,257871,912674,880020,32805,688253,722582,931114,734057,939655],[395351,377494,543729,368629,913310,69242,737795,849175,870860,278493,575561,111787]]\\n\\nqueries:\\n[483649,690923,317026,408761,985459,619592,287085,302896,241756,557463,914140,994632,511904,377570,272415,840485,578955,797418,609746,388421,517504,170621,188489,169881,466574]"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "You have your frontier of places to visit in a heap, which means you don\\'t have to do a recursive call to dfs().  Just iterate while the lead element in the heap has low enough value.  Maybe you are not exploring sufficiently because. of this?  Another thought is that you seem to be putting \\'#\\' in the grid and also using a visit set;  you don\\'t need to do both!"
                    }
                ]
            },
            {
                "id": 1713620,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "There are better color combinations in world than light gray and white combination. :|"
                    },
                    {
                        "username": "vigneshr1603",
                        "content": "Am I color blind? All 3 diagrams of sol1 are same "
                    },
                    {
                        "username": "WitcherG",
                        "content": "the blurred cells are the visited ones, i got confused too."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "For people who are having trouble with the colors of the matrices.\\n\\n![image.png](https://assets.leetcode.com/users/images/1e2e29d1-be89-4c26-a2a6-8e4fe5ad11dc_1671030245.3139484.png)"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent 20 mins trying to understand what the matrices are, while others completed this question under 15mins. :\\\\"
                    },
                    {
                        "username": "Martician",
                        "content": "This is the coolest problem I have encountered."
                    },
                    {
                        "username": "dev-madhurendra",
                        "content": "Why this solution is not working for test case\\nMy Solution : \\n `\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &a,vector<int> &q,vector<vector<bool>> &vis,int n,int m,int row,int col,int target){\\n        if(row>=n || col >= m || row < 0 || col < 0 || vis[row][col] || a[row][col]>=target){\\n            return;\\n        }\\n        vis[row][col] = true;\\n        dfs(a,q,vis,n,m,row-1,col,target);\\n        dfs(a,q,vis,n,m,row+1,col,target);\\n        dfs(a,q,vis,n,m,row,col+1,target);\\n        dfs(a,q,vis,n,m,row+1,col-1,target);\\n    }\\n    vector<int> maxPoints(vector<vector<int>> &a,vector<int> &q){\\n        int n = a.size();\\n        int m = a[0].size();\\n        \\n\\n        vector<int> res;\\n        for(int i=0;i<q.size();++i){\\n            vector<vector<bool>> vis(n,vector<bool>(m,false));\\n            dfs(a,q,vis,n,m,0,0,q[i]);\\n            int ans = 0;\\n            for(int i=0;i<n;++i){\\n                for(int j=0;j<m;++j){\\n                    if(vis[i][j]){\\n                        ans++;\\n                    }\\n                }\\n            }\\n\\n            res.push_back(ans);\\n        }\\n\\n        return res;\\n    }\\n};\\n`\\n\\n\\n\\n\\nGrid : \\n[[249472,735471,144880,992181,760916,920551,898524,37043,422852,194509,714395,325171],[295872,922051,900801,634980,644237,912433,857189,98466,725226,984534,370121,399006],[618420,573065,587011,298153,694872,12760,880413,593508,474772,291113,852444,77998],[67650,426517,146447,190319,379151,184754,479219,106819,138473,865661,799297,228827],[390392,789371,772048,730506,7144,862164,650590,21524,879440,396198,408897,851020],[932044,662093,436861,246956,128943,167432,267483,148325,458128,418348,900594,831373],[742255,795191,598857,441846,243888,777685,313717,560586,257220,488025,846817,554722],[252507,621902,87704,599753,651175,305330,620166,631193,385405,183376,432598,706692],[984416,996917,586571,324595,784565,300514,101313,685863,703194,729430,732044,349877],[155629,290992,539879,173659,989930,373725,701670,992137,893024,455455,454886,559081],[252809,641084,632837,764260,68790,732601,349257,208701,613650,429049,983008,76324],[918085,126894,909148,194638,915416,225708,184408,462852,40392,964501,436864,785076],[875475,442333,111818,494972,486734,901577,46210,326422,603800,176902,315208,225178],[171174,458473,744971,872087,680060,95371,806370,322605,349331,736473,306720,556064],[207705,587869,129465,543368,840821,977451,399877,486877,327390,8865,605705,481076]]\\n\\nQueries : \\n[690474,796832,913701,939418,46696,266869,150594,948153,718874] \\n\\n"
                    },
                    {
                        "username": "yashsangwan2611",
                        "content": "can anybody tell me why it is giving wrong answer and only passes 7 cases as my approach is correct\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& q) {\\n        int m=grid.size(),n=grid[0].size(),k=q.size();\\n        vector<int>ans(k);\\n        vector<pair<int,int>>queries(k);\\n        for(int i=0;i<k;i++){\\n            queries[i]={q[i],i};\\n        }\\n        sort(queries.begin(),queries.end());\\n        set<pair<int,int>>s;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        s.insert({0,0});\\n        int cnt=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(!pq.empty()&&pq.top().first<queries[i].first){\\n                cnt++;\\n                int x=pq.top().second.first;\\n                int y=pq.top().second.second;\\n                pq.pop();\\n                if(x+1<m){\\n                    if(s.find({x+1,y})==s.end()){\\n                        pq.push({grid[x+1][y],{x+1,y}});\\n                        s.insert({x+1,y});\\n                    }\\n                }\\n                if(y+1<n){\\n                    if(s.find({x,y+1})==s.end()){\\n                        pq.push({grid[x][y+1],{x,y+1}});\\n                        s.insert({x,y+1});\\n                    }\\n                }   \\n            }\\n             ans[i]=cnt;\\n        }\\n        vector<int>res(k);\\n        for(int i=0;i<queries.size();i++){\\n            res[queries[i].second]=ans[i];\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Test cases are weak My brute force code got accepted."
                    },
                    {
                        "username": "15o1",
                        "content": "not anymore :("
                    },
                    {
                        "username": "ajay36",
                        "content": "why wouldn\\'t DFS work here? "
                    },
                    {
                        "username": "saam_neu",
                        "content": "Can anyone tell the mistake in my dfs. Its throwing error for the following test case\\n\\n```\\ndir=[0,1,0,-1,0]\\n        \\n        def dfs(q,nums,visit):\\n            val1,x,y=q[0]\\n            #visit.add((x,y))\\n            if val1>=nums:\\n                return\\n            heappop(q)    \\n            self.prevCount+=1\\n            grid[x][y]=\\'#\\'\\n            for i in range(len(dir)-1):\\n                a,b=x+dir[i],y+dir[i+1]\\n                if 0 <= a < rows and 0 <= b < cols and grid[a][b] !=\\'#\\':\\n                    if (a,b) not in visit:\\n                        visit.add((a,b))\\n                        heappush(q, (grid[a][b], a, b))              \\n                    dfs(q,nums,visit)\\n\\n        query = sorted(set(queries))\\n        r = {}\\n        rows, cols = len(grid), len(grid[0])\\n        q = [(grid[0][0], 0, 0)]\\n        self.prevCount = 0\\n        visit=set()\\n        \\n        for num in query:\\n            dfs(q,num,visit)\\n            r[num]=self.prevCount\\n            \\n        \\n        final = [r[num] for num in queries]\\n        return final\\n\\ngrid:\\n[[444424,409221,703419,11307,578382,330430,522887,38831,267101,315541,148425,360873],[353160,3217,718922,509568,494803,327636,715882,456279,374061,701863,711832,644822],[459535,264294,246310,405317,275802,948618,449015,176733,921040,56692,632708,556696],[167402,594284,8377,766746,728202,329140,399028,907843,68783,149661,244321,861358],[727577,582470,946680,222674,152875,128658,389710,581164,512061,367464,883657,78004],[463513,473823,328325,888670,267782,435621,153221,877511,900231,72761,825121,532939],[992835,33883,587426,680675,674055,682929,750368,241142,241026,369751,462134,785672],[915635,918034,398025,400424,695630,594801,748962,278900,705889,570212,42410,823342],[644602,961002,489119,606936,327139,664880,455045,231423,114466,315707,25092,961268],[962857,647428,139005,221262,469484,669734,66022,473118,258066,67408,545435,316643],[977028,938186,277400,756609,491213,704014,292941,392893,280499,650462,270100,477276],[393574,562825,637562,639836,8932,540799,758836,403682,79851,17885,851550,499020],[403665,119906,305796,88211,759076,441097,164887,709599,194,468995,922288,359913],[696749,265394,517399,161062,512967,205098,814158,627951,286474,763625,370987,798077],[166098,940946,871758,690278,903705,368584,576209,94794,25522,255261,209835,540769],[8088,89612,457088,492467,511285,900536,734726,683046,515695,14749,988608,977041],[76149,112648,515127,257871,912674,880020,32805,688253,722582,931114,734057,939655],[395351,377494,543729,368629,913310,69242,737795,849175,870860,278493,575561,111787]]\\n\\nqueries:\\n[483649,690923,317026,408761,985459,619592,287085,302896,241756,557463,914140,994632,511904,377570,272415,840485,578955,797418,609746,388421,517504,170621,188489,169881,466574]"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "You have your frontier of places to visit in a heap, which means you don\\'t have to do a recursive call to dfs().  Just iterate while the lead element in the heap has low enough value.  Maybe you are not exploring sufficiently because. of this?  Another thought is that you seem to be putting \\'#\\' in the grid and also using a visit set;  you don\\'t need to do both!"
                    }
                ]
            },
            {
                "id": 2075568,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "There are better color combinations in world than light gray and white combination. :|"
                    },
                    {
                        "username": "vigneshr1603",
                        "content": "Am I color blind? All 3 diagrams of sol1 are same "
                    },
                    {
                        "username": "WitcherG",
                        "content": "the blurred cells are the visited ones, i got confused too."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "For people who are having trouble with the colors of the matrices.\\n\\n![image.png](https://assets.leetcode.com/users/images/1e2e29d1-be89-4c26-a2a6-8e4fe5ad11dc_1671030245.3139484.png)"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent 20 mins trying to understand what the matrices are, while others completed this question under 15mins. :\\\\"
                    },
                    {
                        "username": "Martician",
                        "content": "This is the coolest problem I have encountered."
                    },
                    {
                        "username": "dev-madhurendra",
                        "content": "Why this solution is not working for test case\\nMy Solution : \\n `\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &a,vector<int> &q,vector<vector<bool>> &vis,int n,int m,int row,int col,int target){\\n        if(row>=n || col >= m || row < 0 || col < 0 || vis[row][col] || a[row][col]>=target){\\n            return;\\n        }\\n        vis[row][col] = true;\\n        dfs(a,q,vis,n,m,row-1,col,target);\\n        dfs(a,q,vis,n,m,row+1,col,target);\\n        dfs(a,q,vis,n,m,row,col+1,target);\\n        dfs(a,q,vis,n,m,row+1,col-1,target);\\n    }\\n    vector<int> maxPoints(vector<vector<int>> &a,vector<int> &q){\\n        int n = a.size();\\n        int m = a[0].size();\\n        \\n\\n        vector<int> res;\\n        for(int i=0;i<q.size();++i){\\n            vector<vector<bool>> vis(n,vector<bool>(m,false));\\n            dfs(a,q,vis,n,m,0,0,q[i]);\\n            int ans = 0;\\n            for(int i=0;i<n;++i){\\n                for(int j=0;j<m;++j){\\n                    if(vis[i][j]){\\n                        ans++;\\n                    }\\n                }\\n            }\\n\\n            res.push_back(ans);\\n        }\\n\\n        return res;\\n    }\\n};\\n`\\n\\n\\n\\n\\nGrid : \\n[[249472,735471,144880,992181,760916,920551,898524,37043,422852,194509,714395,325171],[295872,922051,900801,634980,644237,912433,857189,98466,725226,984534,370121,399006],[618420,573065,587011,298153,694872,12760,880413,593508,474772,291113,852444,77998],[67650,426517,146447,190319,379151,184754,479219,106819,138473,865661,799297,228827],[390392,789371,772048,730506,7144,862164,650590,21524,879440,396198,408897,851020],[932044,662093,436861,246956,128943,167432,267483,148325,458128,418348,900594,831373],[742255,795191,598857,441846,243888,777685,313717,560586,257220,488025,846817,554722],[252507,621902,87704,599753,651175,305330,620166,631193,385405,183376,432598,706692],[984416,996917,586571,324595,784565,300514,101313,685863,703194,729430,732044,349877],[155629,290992,539879,173659,989930,373725,701670,992137,893024,455455,454886,559081],[252809,641084,632837,764260,68790,732601,349257,208701,613650,429049,983008,76324],[918085,126894,909148,194638,915416,225708,184408,462852,40392,964501,436864,785076],[875475,442333,111818,494972,486734,901577,46210,326422,603800,176902,315208,225178],[171174,458473,744971,872087,680060,95371,806370,322605,349331,736473,306720,556064],[207705,587869,129465,543368,840821,977451,399877,486877,327390,8865,605705,481076]]\\n\\nQueries : \\n[690474,796832,913701,939418,46696,266869,150594,948153,718874] \\n\\n"
                    },
                    {
                        "username": "yashsangwan2611",
                        "content": "can anybody tell me why it is giving wrong answer and only passes 7 cases as my approach is correct\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& q) {\\n        int m=grid.size(),n=grid[0].size(),k=q.size();\\n        vector<int>ans(k);\\n        vector<pair<int,int>>queries(k);\\n        for(int i=0;i<k;i++){\\n            queries[i]={q[i],i};\\n        }\\n        sort(queries.begin(),queries.end());\\n        set<pair<int,int>>s;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        s.insert({0,0});\\n        int cnt=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(!pq.empty()&&pq.top().first<queries[i].first){\\n                cnt++;\\n                int x=pq.top().second.first;\\n                int y=pq.top().second.second;\\n                pq.pop();\\n                if(x+1<m){\\n                    if(s.find({x+1,y})==s.end()){\\n                        pq.push({grid[x+1][y],{x+1,y}});\\n                        s.insert({x+1,y});\\n                    }\\n                }\\n                if(y+1<n){\\n                    if(s.find({x,y+1})==s.end()){\\n                        pq.push({grid[x][y+1],{x,y+1}});\\n                        s.insert({x,y+1});\\n                    }\\n                }   \\n            }\\n             ans[i]=cnt;\\n        }\\n        vector<int>res(k);\\n        for(int i=0;i<queries.size();i++){\\n            res[queries[i].second]=ans[i];\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Test cases are weak My brute force code got accepted."
                    },
                    {
                        "username": "15o1",
                        "content": "not anymore :("
                    },
                    {
                        "username": "ajay36",
                        "content": "why wouldn\\'t DFS work here? "
                    },
                    {
                        "username": "saam_neu",
                        "content": "Can anyone tell the mistake in my dfs. Its throwing error for the following test case\\n\\n```\\ndir=[0,1,0,-1,0]\\n        \\n        def dfs(q,nums,visit):\\n            val1,x,y=q[0]\\n            #visit.add((x,y))\\n            if val1>=nums:\\n                return\\n            heappop(q)    \\n            self.prevCount+=1\\n            grid[x][y]=\\'#\\'\\n            for i in range(len(dir)-1):\\n                a,b=x+dir[i],y+dir[i+1]\\n                if 0 <= a < rows and 0 <= b < cols and grid[a][b] !=\\'#\\':\\n                    if (a,b) not in visit:\\n                        visit.add((a,b))\\n                        heappush(q, (grid[a][b], a, b))              \\n                    dfs(q,nums,visit)\\n\\n        query = sorted(set(queries))\\n        r = {}\\n        rows, cols = len(grid), len(grid[0])\\n        q = [(grid[0][0], 0, 0)]\\n        self.prevCount = 0\\n        visit=set()\\n        \\n        for num in query:\\n            dfs(q,num,visit)\\n            r[num]=self.prevCount\\n            \\n        \\n        final = [r[num] for num in queries]\\n        return final\\n\\ngrid:\\n[[444424,409221,703419,11307,578382,330430,522887,38831,267101,315541,148425,360873],[353160,3217,718922,509568,494803,327636,715882,456279,374061,701863,711832,644822],[459535,264294,246310,405317,275802,948618,449015,176733,921040,56692,632708,556696],[167402,594284,8377,766746,728202,329140,399028,907843,68783,149661,244321,861358],[727577,582470,946680,222674,152875,128658,389710,581164,512061,367464,883657,78004],[463513,473823,328325,888670,267782,435621,153221,877511,900231,72761,825121,532939],[992835,33883,587426,680675,674055,682929,750368,241142,241026,369751,462134,785672],[915635,918034,398025,400424,695630,594801,748962,278900,705889,570212,42410,823342],[644602,961002,489119,606936,327139,664880,455045,231423,114466,315707,25092,961268],[962857,647428,139005,221262,469484,669734,66022,473118,258066,67408,545435,316643],[977028,938186,277400,756609,491213,704014,292941,392893,280499,650462,270100,477276],[393574,562825,637562,639836,8932,540799,758836,403682,79851,17885,851550,499020],[403665,119906,305796,88211,759076,441097,164887,709599,194,468995,922288,359913],[696749,265394,517399,161062,512967,205098,814158,627951,286474,763625,370987,798077],[166098,940946,871758,690278,903705,368584,576209,94794,25522,255261,209835,540769],[8088,89612,457088,492467,511285,900536,734726,683046,515695,14749,988608,977041],[76149,112648,515127,257871,912674,880020,32805,688253,722582,931114,734057,939655],[395351,377494,543729,368629,913310,69242,737795,849175,870860,278493,575561,111787]]\\n\\nqueries:\\n[483649,690923,317026,408761,985459,619592,287085,302896,241756,557463,914140,994632,511904,377570,272415,840485,578955,797418,609746,388421,517504,170621,188489,169881,466574]"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "You have your frontier of places to visit in a heap, which means you don\\'t have to do a recursive call to dfs().  Just iterate while the lead element in the heap has low enough value.  Maybe you are not exploring sufficiently because. of this?  Another thought is that you seem to be putting \\'#\\' in the grid and also using a visit set;  you don\\'t need to do both!"
                    }
                ]
            },
            {
                "id": 1720773,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "There are better color combinations in world than light gray and white combination. :|"
                    },
                    {
                        "username": "vigneshr1603",
                        "content": "Am I color blind? All 3 diagrams of sol1 are same "
                    },
                    {
                        "username": "WitcherG",
                        "content": "the blurred cells are the visited ones, i got confused too."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "For people who are having trouble with the colors of the matrices.\\n\\n![image.png](https://assets.leetcode.com/users/images/1e2e29d1-be89-4c26-a2a6-8e4fe5ad11dc_1671030245.3139484.png)"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent 20 mins trying to understand what the matrices are, while others completed this question under 15mins. :\\\\"
                    },
                    {
                        "username": "Martician",
                        "content": "This is the coolest problem I have encountered."
                    },
                    {
                        "username": "dev-madhurendra",
                        "content": "Why this solution is not working for test case\\nMy Solution : \\n `\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &a,vector<int> &q,vector<vector<bool>> &vis,int n,int m,int row,int col,int target){\\n        if(row>=n || col >= m || row < 0 || col < 0 || vis[row][col] || a[row][col]>=target){\\n            return;\\n        }\\n        vis[row][col] = true;\\n        dfs(a,q,vis,n,m,row-1,col,target);\\n        dfs(a,q,vis,n,m,row+1,col,target);\\n        dfs(a,q,vis,n,m,row,col+1,target);\\n        dfs(a,q,vis,n,m,row+1,col-1,target);\\n    }\\n    vector<int> maxPoints(vector<vector<int>> &a,vector<int> &q){\\n        int n = a.size();\\n        int m = a[0].size();\\n        \\n\\n        vector<int> res;\\n        for(int i=0;i<q.size();++i){\\n            vector<vector<bool>> vis(n,vector<bool>(m,false));\\n            dfs(a,q,vis,n,m,0,0,q[i]);\\n            int ans = 0;\\n            for(int i=0;i<n;++i){\\n                for(int j=0;j<m;++j){\\n                    if(vis[i][j]){\\n                        ans++;\\n                    }\\n                }\\n            }\\n\\n            res.push_back(ans);\\n        }\\n\\n        return res;\\n    }\\n};\\n`\\n\\n\\n\\n\\nGrid : \\n[[249472,735471,144880,992181,760916,920551,898524,37043,422852,194509,714395,325171],[295872,922051,900801,634980,644237,912433,857189,98466,725226,984534,370121,399006],[618420,573065,587011,298153,694872,12760,880413,593508,474772,291113,852444,77998],[67650,426517,146447,190319,379151,184754,479219,106819,138473,865661,799297,228827],[390392,789371,772048,730506,7144,862164,650590,21524,879440,396198,408897,851020],[932044,662093,436861,246956,128943,167432,267483,148325,458128,418348,900594,831373],[742255,795191,598857,441846,243888,777685,313717,560586,257220,488025,846817,554722],[252507,621902,87704,599753,651175,305330,620166,631193,385405,183376,432598,706692],[984416,996917,586571,324595,784565,300514,101313,685863,703194,729430,732044,349877],[155629,290992,539879,173659,989930,373725,701670,992137,893024,455455,454886,559081],[252809,641084,632837,764260,68790,732601,349257,208701,613650,429049,983008,76324],[918085,126894,909148,194638,915416,225708,184408,462852,40392,964501,436864,785076],[875475,442333,111818,494972,486734,901577,46210,326422,603800,176902,315208,225178],[171174,458473,744971,872087,680060,95371,806370,322605,349331,736473,306720,556064],[207705,587869,129465,543368,840821,977451,399877,486877,327390,8865,605705,481076]]\\n\\nQueries : \\n[690474,796832,913701,939418,46696,266869,150594,948153,718874] \\n\\n"
                    },
                    {
                        "username": "yashsangwan2611",
                        "content": "can anybody tell me why it is giving wrong answer and only passes 7 cases as my approach is correct\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& q) {\\n        int m=grid.size(),n=grid[0].size(),k=q.size();\\n        vector<int>ans(k);\\n        vector<pair<int,int>>queries(k);\\n        for(int i=0;i<k;i++){\\n            queries[i]={q[i],i};\\n        }\\n        sort(queries.begin(),queries.end());\\n        set<pair<int,int>>s;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        s.insert({0,0});\\n        int cnt=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(!pq.empty()&&pq.top().first<queries[i].first){\\n                cnt++;\\n                int x=pq.top().second.first;\\n                int y=pq.top().second.second;\\n                pq.pop();\\n                if(x+1<m){\\n                    if(s.find({x+1,y})==s.end()){\\n                        pq.push({grid[x+1][y],{x+1,y}});\\n                        s.insert({x+1,y});\\n                    }\\n                }\\n                if(y+1<n){\\n                    if(s.find({x,y+1})==s.end()){\\n                        pq.push({grid[x][y+1],{x,y+1}});\\n                        s.insert({x,y+1});\\n                    }\\n                }   \\n            }\\n             ans[i]=cnt;\\n        }\\n        vector<int>res(k);\\n        for(int i=0;i<queries.size();i++){\\n            res[queries[i].second]=ans[i];\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Test cases are weak My brute force code got accepted."
                    },
                    {
                        "username": "15o1",
                        "content": "not anymore :("
                    },
                    {
                        "username": "ajay36",
                        "content": "why wouldn\\'t DFS work here? "
                    },
                    {
                        "username": "saam_neu",
                        "content": "Can anyone tell the mistake in my dfs. Its throwing error for the following test case\\n\\n```\\ndir=[0,1,0,-1,0]\\n        \\n        def dfs(q,nums,visit):\\n            val1,x,y=q[0]\\n            #visit.add((x,y))\\n            if val1>=nums:\\n                return\\n            heappop(q)    \\n            self.prevCount+=1\\n            grid[x][y]=\\'#\\'\\n            for i in range(len(dir)-1):\\n                a,b=x+dir[i],y+dir[i+1]\\n                if 0 <= a < rows and 0 <= b < cols and grid[a][b] !=\\'#\\':\\n                    if (a,b) not in visit:\\n                        visit.add((a,b))\\n                        heappush(q, (grid[a][b], a, b))              \\n                    dfs(q,nums,visit)\\n\\n        query = sorted(set(queries))\\n        r = {}\\n        rows, cols = len(grid), len(grid[0])\\n        q = [(grid[0][0], 0, 0)]\\n        self.prevCount = 0\\n        visit=set()\\n        \\n        for num in query:\\n            dfs(q,num,visit)\\n            r[num]=self.prevCount\\n            \\n        \\n        final = [r[num] for num in queries]\\n        return final\\n\\ngrid:\\n[[444424,409221,703419,11307,578382,330430,522887,38831,267101,315541,148425,360873],[353160,3217,718922,509568,494803,327636,715882,456279,374061,701863,711832,644822],[459535,264294,246310,405317,275802,948618,449015,176733,921040,56692,632708,556696],[167402,594284,8377,766746,728202,329140,399028,907843,68783,149661,244321,861358],[727577,582470,946680,222674,152875,128658,389710,581164,512061,367464,883657,78004],[463513,473823,328325,888670,267782,435621,153221,877511,900231,72761,825121,532939],[992835,33883,587426,680675,674055,682929,750368,241142,241026,369751,462134,785672],[915635,918034,398025,400424,695630,594801,748962,278900,705889,570212,42410,823342],[644602,961002,489119,606936,327139,664880,455045,231423,114466,315707,25092,961268],[962857,647428,139005,221262,469484,669734,66022,473118,258066,67408,545435,316643],[977028,938186,277400,756609,491213,704014,292941,392893,280499,650462,270100,477276],[393574,562825,637562,639836,8932,540799,758836,403682,79851,17885,851550,499020],[403665,119906,305796,88211,759076,441097,164887,709599,194,468995,922288,359913],[696749,265394,517399,161062,512967,205098,814158,627951,286474,763625,370987,798077],[166098,940946,871758,690278,903705,368584,576209,94794,25522,255261,209835,540769],[8088,89612,457088,492467,511285,900536,734726,683046,515695,14749,988608,977041],[76149,112648,515127,257871,912674,880020,32805,688253,722582,931114,734057,939655],[395351,377494,543729,368629,913310,69242,737795,849175,870860,278493,575561,111787]]\\n\\nqueries:\\n[483649,690923,317026,408761,985459,619592,287085,302896,241756,557463,914140,994632,511904,377570,272415,840485,578955,797418,609746,388421,517504,170621,188489,169881,466574]"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "You have your frontier of places to visit in a heap, which means you don\\'t have to do a recursive call to dfs().  Just iterate while the lead element in the heap has low enough value.  Maybe you are not exploring sufficiently because. of this?  Another thought is that you seem to be putting \\'#\\' in the grid and also using a visit set;  you don\\'t need to do both!"
                    }
                ]
            },
            {
                "id": 1720591,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "There are better color combinations in world than light gray and white combination. :|"
                    },
                    {
                        "username": "vigneshr1603",
                        "content": "Am I color blind? All 3 diagrams of sol1 are same "
                    },
                    {
                        "username": "WitcherG",
                        "content": "the blurred cells are the visited ones, i got confused too."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "For people who are having trouble with the colors of the matrices.\\n\\n![image.png](https://assets.leetcode.com/users/images/1e2e29d1-be89-4c26-a2a6-8e4fe5ad11dc_1671030245.3139484.png)"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent 20 mins trying to understand what the matrices are, while others completed this question under 15mins. :\\\\"
                    },
                    {
                        "username": "Martician",
                        "content": "This is the coolest problem I have encountered."
                    },
                    {
                        "username": "dev-madhurendra",
                        "content": "Why this solution is not working for test case\\nMy Solution : \\n `\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &a,vector<int> &q,vector<vector<bool>> &vis,int n,int m,int row,int col,int target){\\n        if(row>=n || col >= m || row < 0 || col < 0 || vis[row][col] || a[row][col]>=target){\\n            return;\\n        }\\n        vis[row][col] = true;\\n        dfs(a,q,vis,n,m,row-1,col,target);\\n        dfs(a,q,vis,n,m,row+1,col,target);\\n        dfs(a,q,vis,n,m,row,col+1,target);\\n        dfs(a,q,vis,n,m,row+1,col-1,target);\\n    }\\n    vector<int> maxPoints(vector<vector<int>> &a,vector<int> &q){\\n        int n = a.size();\\n        int m = a[0].size();\\n        \\n\\n        vector<int> res;\\n        for(int i=0;i<q.size();++i){\\n            vector<vector<bool>> vis(n,vector<bool>(m,false));\\n            dfs(a,q,vis,n,m,0,0,q[i]);\\n            int ans = 0;\\n            for(int i=0;i<n;++i){\\n                for(int j=0;j<m;++j){\\n                    if(vis[i][j]){\\n                        ans++;\\n                    }\\n                }\\n            }\\n\\n            res.push_back(ans);\\n        }\\n\\n        return res;\\n    }\\n};\\n`\\n\\n\\n\\n\\nGrid : \\n[[249472,735471,144880,992181,760916,920551,898524,37043,422852,194509,714395,325171],[295872,922051,900801,634980,644237,912433,857189,98466,725226,984534,370121,399006],[618420,573065,587011,298153,694872,12760,880413,593508,474772,291113,852444,77998],[67650,426517,146447,190319,379151,184754,479219,106819,138473,865661,799297,228827],[390392,789371,772048,730506,7144,862164,650590,21524,879440,396198,408897,851020],[932044,662093,436861,246956,128943,167432,267483,148325,458128,418348,900594,831373],[742255,795191,598857,441846,243888,777685,313717,560586,257220,488025,846817,554722],[252507,621902,87704,599753,651175,305330,620166,631193,385405,183376,432598,706692],[984416,996917,586571,324595,784565,300514,101313,685863,703194,729430,732044,349877],[155629,290992,539879,173659,989930,373725,701670,992137,893024,455455,454886,559081],[252809,641084,632837,764260,68790,732601,349257,208701,613650,429049,983008,76324],[918085,126894,909148,194638,915416,225708,184408,462852,40392,964501,436864,785076],[875475,442333,111818,494972,486734,901577,46210,326422,603800,176902,315208,225178],[171174,458473,744971,872087,680060,95371,806370,322605,349331,736473,306720,556064],[207705,587869,129465,543368,840821,977451,399877,486877,327390,8865,605705,481076]]\\n\\nQueries : \\n[690474,796832,913701,939418,46696,266869,150594,948153,718874] \\n\\n"
                    },
                    {
                        "username": "yashsangwan2611",
                        "content": "can anybody tell me why it is giving wrong answer and only passes 7 cases as my approach is correct\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& q) {\\n        int m=grid.size(),n=grid[0].size(),k=q.size();\\n        vector<int>ans(k);\\n        vector<pair<int,int>>queries(k);\\n        for(int i=0;i<k;i++){\\n            queries[i]={q[i],i};\\n        }\\n        sort(queries.begin(),queries.end());\\n        set<pair<int,int>>s;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        s.insert({0,0});\\n        int cnt=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(!pq.empty()&&pq.top().first<queries[i].first){\\n                cnt++;\\n                int x=pq.top().second.first;\\n                int y=pq.top().second.second;\\n                pq.pop();\\n                if(x+1<m){\\n                    if(s.find({x+1,y})==s.end()){\\n                        pq.push({grid[x+1][y],{x+1,y}});\\n                        s.insert({x+1,y});\\n                    }\\n                }\\n                if(y+1<n){\\n                    if(s.find({x,y+1})==s.end()){\\n                        pq.push({grid[x][y+1],{x,y+1}});\\n                        s.insert({x,y+1});\\n                    }\\n                }   \\n            }\\n             ans[i]=cnt;\\n        }\\n        vector<int>res(k);\\n        for(int i=0;i<queries.size();i++){\\n            res[queries[i].second]=ans[i];\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Test cases are weak My brute force code got accepted."
                    },
                    {
                        "username": "15o1",
                        "content": "not anymore :("
                    },
                    {
                        "username": "ajay36",
                        "content": "why wouldn\\'t DFS work here? "
                    },
                    {
                        "username": "saam_neu",
                        "content": "Can anyone tell the mistake in my dfs. Its throwing error for the following test case\\n\\n```\\ndir=[0,1,0,-1,0]\\n        \\n        def dfs(q,nums,visit):\\n            val1,x,y=q[0]\\n            #visit.add((x,y))\\n            if val1>=nums:\\n                return\\n            heappop(q)    \\n            self.prevCount+=1\\n            grid[x][y]=\\'#\\'\\n            for i in range(len(dir)-1):\\n                a,b=x+dir[i],y+dir[i+1]\\n                if 0 <= a < rows and 0 <= b < cols and grid[a][b] !=\\'#\\':\\n                    if (a,b) not in visit:\\n                        visit.add((a,b))\\n                        heappush(q, (grid[a][b], a, b))              \\n                    dfs(q,nums,visit)\\n\\n        query = sorted(set(queries))\\n        r = {}\\n        rows, cols = len(grid), len(grid[0])\\n        q = [(grid[0][0], 0, 0)]\\n        self.prevCount = 0\\n        visit=set()\\n        \\n        for num in query:\\n            dfs(q,num,visit)\\n            r[num]=self.prevCount\\n            \\n        \\n        final = [r[num] for num in queries]\\n        return final\\n\\ngrid:\\n[[444424,409221,703419,11307,578382,330430,522887,38831,267101,315541,148425,360873],[353160,3217,718922,509568,494803,327636,715882,456279,374061,701863,711832,644822],[459535,264294,246310,405317,275802,948618,449015,176733,921040,56692,632708,556696],[167402,594284,8377,766746,728202,329140,399028,907843,68783,149661,244321,861358],[727577,582470,946680,222674,152875,128658,389710,581164,512061,367464,883657,78004],[463513,473823,328325,888670,267782,435621,153221,877511,900231,72761,825121,532939],[992835,33883,587426,680675,674055,682929,750368,241142,241026,369751,462134,785672],[915635,918034,398025,400424,695630,594801,748962,278900,705889,570212,42410,823342],[644602,961002,489119,606936,327139,664880,455045,231423,114466,315707,25092,961268],[962857,647428,139005,221262,469484,669734,66022,473118,258066,67408,545435,316643],[977028,938186,277400,756609,491213,704014,292941,392893,280499,650462,270100,477276],[393574,562825,637562,639836,8932,540799,758836,403682,79851,17885,851550,499020],[403665,119906,305796,88211,759076,441097,164887,709599,194,468995,922288,359913],[696749,265394,517399,161062,512967,205098,814158,627951,286474,763625,370987,798077],[166098,940946,871758,690278,903705,368584,576209,94794,25522,255261,209835,540769],[8088,89612,457088,492467,511285,900536,734726,683046,515695,14749,988608,977041],[76149,112648,515127,257871,912674,880020,32805,688253,722582,931114,734057,939655],[395351,377494,543729,368629,913310,69242,737795,849175,870860,278493,575561,111787]]\\n\\nqueries:\\n[483649,690923,317026,408761,985459,619592,287085,302896,241756,557463,914140,994632,511904,377570,272415,840485,578955,797418,609746,388421,517504,170621,188489,169881,466574]"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "You have your frontier of places to visit in a heap, which means you don\\'t have to do a recursive call to dfs().  Just iterate while the lead element in the heap has low enough value.  Maybe you are not exploring sufficiently because. of this?  Another thought is that you seem to be putting \\'#\\' in the grid and also using a visit set;  you don\\'t need to do both!"
                    }
                ]
            },
            {
                "id": 1717373,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "There are better color combinations in world than light gray and white combination. :|"
                    },
                    {
                        "username": "vigneshr1603",
                        "content": "Am I color blind? All 3 diagrams of sol1 are same "
                    },
                    {
                        "username": "WitcherG",
                        "content": "the blurred cells are the visited ones, i got confused too."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "For people who are having trouble with the colors of the matrices.\\n\\n![image.png](https://assets.leetcode.com/users/images/1e2e29d1-be89-4c26-a2a6-8e4fe5ad11dc_1671030245.3139484.png)"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent 20 mins trying to understand what the matrices are, while others completed this question under 15mins. :\\\\"
                    },
                    {
                        "username": "Martician",
                        "content": "This is the coolest problem I have encountered."
                    },
                    {
                        "username": "dev-madhurendra",
                        "content": "Why this solution is not working for test case\\nMy Solution : \\n `\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &a,vector<int> &q,vector<vector<bool>> &vis,int n,int m,int row,int col,int target){\\n        if(row>=n || col >= m || row < 0 || col < 0 || vis[row][col] || a[row][col]>=target){\\n            return;\\n        }\\n        vis[row][col] = true;\\n        dfs(a,q,vis,n,m,row-1,col,target);\\n        dfs(a,q,vis,n,m,row+1,col,target);\\n        dfs(a,q,vis,n,m,row,col+1,target);\\n        dfs(a,q,vis,n,m,row+1,col-1,target);\\n    }\\n    vector<int> maxPoints(vector<vector<int>> &a,vector<int> &q){\\n        int n = a.size();\\n        int m = a[0].size();\\n        \\n\\n        vector<int> res;\\n        for(int i=0;i<q.size();++i){\\n            vector<vector<bool>> vis(n,vector<bool>(m,false));\\n            dfs(a,q,vis,n,m,0,0,q[i]);\\n            int ans = 0;\\n            for(int i=0;i<n;++i){\\n                for(int j=0;j<m;++j){\\n                    if(vis[i][j]){\\n                        ans++;\\n                    }\\n                }\\n            }\\n\\n            res.push_back(ans);\\n        }\\n\\n        return res;\\n    }\\n};\\n`\\n\\n\\n\\n\\nGrid : \\n[[249472,735471,144880,992181,760916,920551,898524,37043,422852,194509,714395,325171],[295872,922051,900801,634980,644237,912433,857189,98466,725226,984534,370121,399006],[618420,573065,587011,298153,694872,12760,880413,593508,474772,291113,852444,77998],[67650,426517,146447,190319,379151,184754,479219,106819,138473,865661,799297,228827],[390392,789371,772048,730506,7144,862164,650590,21524,879440,396198,408897,851020],[932044,662093,436861,246956,128943,167432,267483,148325,458128,418348,900594,831373],[742255,795191,598857,441846,243888,777685,313717,560586,257220,488025,846817,554722],[252507,621902,87704,599753,651175,305330,620166,631193,385405,183376,432598,706692],[984416,996917,586571,324595,784565,300514,101313,685863,703194,729430,732044,349877],[155629,290992,539879,173659,989930,373725,701670,992137,893024,455455,454886,559081],[252809,641084,632837,764260,68790,732601,349257,208701,613650,429049,983008,76324],[918085,126894,909148,194638,915416,225708,184408,462852,40392,964501,436864,785076],[875475,442333,111818,494972,486734,901577,46210,326422,603800,176902,315208,225178],[171174,458473,744971,872087,680060,95371,806370,322605,349331,736473,306720,556064],[207705,587869,129465,543368,840821,977451,399877,486877,327390,8865,605705,481076]]\\n\\nQueries : \\n[690474,796832,913701,939418,46696,266869,150594,948153,718874] \\n\\n"
                    },
                    {
                        "username": "yashsangwan2611",
                        "content": "can anybody tell me why it is giving wrong answer and only passes 7 cases as my approach is correct\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& q) {\\n        int m=grid.size(),n=grid[0].size(),k=q.size();\\n        vector<int>ans(k);\\n        vector<pair<int,int>>queries(k);\\n        for(int i=0;i<k;i++){\\n            queries[i]={q[i],i};\\n        }\\n        sort(queries.begin(),queries.end());\\n        set<pair<int,int>>s;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        s.insert({0,0});\\n        int cnt=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(!pq.empty()&&pq.top().first<queries[i].first){\\n                cnt++;\\n                int x=pq.top().second.first;\\n                int y=pq.top().second.second;\\n                pq.pop();\\n                if(x+1<m){\\n                    if(s.find({x+1,y})==s.end()){\\n                        pq.push({grid[x+1][y],{x+1,y}});\\n                        s.insert({x+1,y});\\n                    }\\n                }\\n                if(y+1<n){\\n                    if(s.find({x,y+1})==s.end()){\\n                        pq.push({grid[x][y+1],{x,y+1}});\\n                        s.insert({x,y+1});\\n                    }\\n                }   \\n            }\\n             ans[i]=cnt;\\n        }\\n        vector<int>res(k);\\n        for(int i=0;i<queries.size();i++){\\n            res[queries[i].second]=ans[i];\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Test cases are weak My brute force code got accepted."
                    },
                    {
                        "username": "15o1",
                        "content": "not anymore :("
                    },
                    {
                        "username": "ajay36",
                        "content": "why wouldn\\'t DFS work here? "
                    },
                    {
                        "username": "saam_neu",
                        "content": "Can anyone tell the mistake in my dfs. Its throwing error for the following test case\\n\\n```\\ndir=[0,1,0,-1,0]\\n        \\n        def dfs(q,nums,visit):\\n            val1,x,y=q[0]\\n            #visit.add((x,y))\\n            if val1>=nums:\\n                return\\n            heappop(q)    \\n            self.prevCount+=1\\n            grid[x][y]=\\'#\\'\\n            for i in range(len(dir)-1):\\n                a,b=x+dir[i],y+dir[i+1]\\n                if 0 <= a < rows and 0 <= b < cols and grid[a][b] !=\\'#\\':\\n                    if (a,b) not in visit:\\n                        visit.add((a,b))\\n                        heappush(q, (grid[a][b], a, b))              \\n                    dfs(q,nums,visit)\\n\\n        query = sorted(set(queries))\\n        r = {}\\n        rows, cols = len(grid), len(grid[0])\\n        q = [(grid[0][0], 0, 0)]\\n        self.prevCount = 0\\n        visit=set()\\n        \\n        for num in query:\\n            dfs(q,num,visit)\\n            r[num]=self.prevCount\\n            \\n        \\n        final = [r[num] for num in queries]\\n        return final\\n\\ngrid:\\n[[444424,409221,703419,11307,578382,330430,522887,38831,267101,315541,148425,360873],[353160,3217,718922,509568,494803,327636,715882,456279,374061,701863,711832,644822],[459535,264294,246310,405317,275802,948618,449015,176733,921040,56692,632708,556696],[167402,594284,8377,766746,728202,329140,399028,907843,68783,149661,244321,861358],[727577,582470,946680,222674,152875,128658,389710,581164,512061,367464,883657,78004],[463513,473823,328325,888670,267782,435621,153221,877511,900231,72761,825121,532939],[992835,33883,587426,680675,674055,682929,750368,241142,241026,369751,462134,785672],[915635,918034,398025,400424,695630,594801,748962,278900,705889,570212,42410,823342],[644602,961002,489119,606936,327139,664880,455045,231423,114466,315707,25092,961268],[962857,647428,139005,221262,469484,669734,66022,473118,258066,67408,545435,316643],[977028,938186,277400,756609,491213,704014,292941,392893,280499,650462,270100,477276],[393574,562825,637562,639836,8932,540799,758836,403682,79851,17885,851550,499020],[403665,119906,305796,88211,759076,441097,164887,709599,194,468995,922288,359913],[696749,265394,517399,161062,512967,205098,814158,627951,286474,763625,370987,798077],[166098,940946,871758,690278,903705,368584,576209,94794,25522,255261,209835,540769],[8088,89612,457088,492467,511285,900536,734726,683046,515695,14749,988608,977041],[76149,112648,515127,257871,912674,880020,32805,688253,722582,931114,734057,939655],[395351,377494,543729,368629,913310,69242,737795,849175,870860,278493,575561,111787]]\\n\\nqueries:\\n[483649,690923,317026,408761,985459,619592,287085,302896,241756,557463,914140,994632,511904,377570,272415,840485,578955,797418,609746,388421,517504,170621,188489,169881,466574]"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "You have your frontier of places to visit in a heap, which means you don\\'t have to do a recursive call to dfs().  Just iterate while the lead element in the heap has low enough value.  Maybe you are not exploring sufficiently because. of this?  Another thought is that you seem to be putting \\'#\\' in the grid and also using a visit set;  you don\\'t need to do both!"
                    }
                ]
            },
            {
                "id": 1716835,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "There are better color combinations in world than light gray and white combination. :|"
                    },
                    {
                        "username": "vigneshr1603",
                        "content": "Am I color blind? All 3 diagrams of sol1 are same "
                    },
                    {
                        "username": "WitcherG",
                        "content": "the blurred cells are the visited ones, i got confused too."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "For people who are having trouble with the colors of the matrices.\\n\\n![image.png](https://assets.leetcode.com/users/images/1e2e29d1-be89-4c26-a2a6-8e4fe5ad11dc_1671030245.3139484.png)"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent 20 mins trying to understand what the matrices are, while others completed this question under 15mins. :\\\\"
                    },
                    {
                        "username": "Martician",
                        "content": "This is the coolest problem I have encountered."
                    },
                    {
                        "username": "dev-madhurendra",
                        "content": "Why this solution is not working for test case\\nMy Solution : \\n `\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &a,vector<int> &q,vector<vector<bool>> &vis,int n,int m,int row,int col,int target){\\n        if(row>=n || col >= m || row < 0 || col < 0 || vis[row][col] || a[row][col]>=target){\\n            return;\\n        }\\n        vis[row][col] = true;\\n        dfs(a,q,vis,n,m,row-1,col,target);\\n        dfs(a,q,vis,n,m,row+1,col,target);\\n        dfs(a,q,vis,n,m,row,col+1,target);\\n        dfs(a,q,vis,n,m,row+1,col-1,target);\\n    }\\n    vector<int> maxPoints(vector<vector<int>> &a,vector<int> &q){\\n        int n = a.size();\\n        int m = a[0].size();\\n        \\n\\n        vector<int> res;\\n        for(int i=0;i<q.size();++i){\\n            vector<vector<bool>> vis(n,vector<bool>(m,false));\\n            dfs(a,q,vis,n,m,0,0,q[i]);\\n            int ans = 0;\\n            for(int i=0;i<n;++i){\\n                for(int j=0;j<m;++j){\\n                    if(vis[i][j]){\\n                        ans++;\\n                    }\\n                }\\n            }\\n\\n            res.push_back(ans);\\n        }\\n\\n        return res;\\n    }\\n};\\n`\\n\\n\\n\\n\\nGrid : \\n[[249472,735471,144880,992181,760916,920551,898524,37043,422852,194509,714395,325171],[295872,922051,900801,634980,644237,912433,857189,98466,725226,984534,370121,399006],[618420,573065,587011,298153,694872,12760,880413,593508,474772,291113,852444,77998],[67650,426517,146447,190319,379151,184754,479219,106819,138473,865661,799297,228827],[390392,789371,772048,730506,7144,862164,650590,21524,879440,396198,408897,851020],[932044,662093,436861,246956,128943,167432,267483,148325,458128,418348,900594,831373],[742255,795191,598857,441846,243888,777685,313717,560586,257220,488025,846817,554722],[252507,621902,87704,599753,651175,305330,620166,631193,385405,183376,432598,706692],[984416,996917,586571,324595,784565,300514,101313,685863,703194,729430,732044,349877],[155629,290992,539879,173659,989930,373725,701670,992137,893024,455455,454886,559081],[252809,641084,632837,764260,68790,732601,349257,208701,613650,429049,983008,76324],[918085,126894,909148,194638,915416,225708,184408,462852,40392,964501,436864,785076],[875475,442333,111818,494972,486734,901577,46210,326422,603800,176902,315208,225178],[171174,458473,744971,872087,680060,95371,806370,322605,349331,736473,306720,556064],[207705,587869,129465,543368,840821,977451,399877,486877,327390,8865,605705,481076]]\\n\\nQueries : \\n[690474,796832,913701,939418,46696,266869,150594,948153,718874] \\n\\n"
                    },
                    {
                        "username": "yashsangwan2611",
                        "content": "can anybody tell me why it is giving wrong answer and only passes 7 cases as my approach is correct\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& q) {\\n        int m=grid.size(),n=grid[0].size(),k=q.size();\\n        vector<int>ans(k);\\n        vector<pair<int,int>>queries(k);\\n        for(int i=0;i<k;i++){\\n            queries[i]={q[i],i};\\n        }\\n        sort(queries.begin(),queries.end());\\n        set<pair<int,int>>s;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        s.insert({0,0});\\n        int cnt=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(!pq.empty()&&pq.top().first<queries[i].first){\\n                cnt++;\\n                int x=pq.top().second.first;\\n                int y=pq.top().second.second;\\n                pq.pop();\\n                if(x+1<m){\\n                    if(s.find({x+1,y})==s.end()){\\n                        pq.push({grid[x+1][y],{x+1,y}});\\n                        s.insert({x+1,y});\\n                    }\\n                }\\n                if(y+1<n){\\n                    if(s.find({x,y+1})==s.end()){\\n                        pq.push({grid[x][y+1],{x,y+1}});\\n                        s.insert({x,y+1});\\n                    }\\n                }   \\n            }\\n             ans[i]=cnt;\\n        }\\n        vector<int>res(k);\\n        for(int i=0;i<queries.size();i++){\\n            res[queries[i].second]=ans[i];\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Test cases are weak My brute force code got accepted."
                    },
                    {
                        "username": "15o1",
                        "content": "not anymore :("
                    },
                    {
                        "username": "ajay36",
                        "content": "why wouldn\\'t DFS work here? "
                    },
                    {
                        "username": "saam_neu",
                        "content": "Can anyone tell the mistake in my dfs. Its throwing error for the following test case\\n\\n```\\ndir=[0,1,0,-1,0]\\n        \\n        def dfs(q,nums,visit):\\n            val1,x,y=q[0]\\n            #visit.add((x,y))\\n            if val1>=nums:\\n                return\\n            heappop(q)    \\n            self.prevCount+=1\\n            grid[x][y]=\\'#\\'\\n            for i in range(len(dir)-1):\\n                a,b=x+dir[i],y+dir[i+1]\\n                if 0 <= a < rows and 0 <= b < cols and grid[a][b] !=\\'#\\':\\n                    if (a,b) not in visit:\\n                        visit.add((a,b))\\n                        heappush(q, (grid[a][b], a, b))              \\n                    dfs(q,nums,visit)\\n\\n        query = sorted(set(queries))\\n        r = {}\\n        rows, cols = len(grid), len(grid[0])\\n        q = [(grid[0][0], 0, 0)]\\n        self.prevCount = 0\\n        visit=set()\\n        \\n        for num in query:\\n            dfs(q,num,visit)\\n            r[num]=self.prevCount\\n            \\n        \\n        final = [r[num] for num in queries]\\n        return final\\n\\ngrid:\\n[[444424,409221,703419,11307,578382,330430,522887,38831,267101,315541,148425,360873],[353160,3217,718922,509568,494803,327636,715882,456279,374061,701863,711832,644822],[459535,264294,246310,405317,275802,948618,449015,176733,921040,56692,632708,556696],[167402,594284,8377,766746,728202,329140,399028,907843,68783,149661,244321,861358],[727577,582470,946680,222674,152875,128658,389710,581164,512061,367464,883657,78004],[463513,473823,328325,888670,267782,435621,153221,877511,900231,72761,825121,532939],[992835,33883,587426,680675,674055,682929,750368,241142,241026,369751,462134,785672],[915635,918034,398025,400424,695630,594801,748962,278900,705889,570212,42410,823342],[644602,961002,489119,606936,327139,664880,455045,231423,114466,315707,25092,961268],[962857,647428,139005,221262,469484,669734,66022,473118,258066,67408,545435,316643],[977028,938186,277400,756609,491213,704014,292941,392893,280499,650462,270100,477276],[393574,562825,637562,639836,8932,540799,758836,403682,79851,17885,851550,499020],[403665,119906,305796,88211,759076,441097,164887,709599,194,468995,922288,359913],[696749,265394,517399,161062,512967,205098,814158,627951,286474,763625,370987,798077],[166098,940946,871758,690278,903705,368584,576209,94794,25522,255261,209835,540769],[8088,89612,457088,492467,511285,900536,734726,683046,515695,14749,988608,977041],[76149,112648,515127,257871,912674,880020,32805,688253,722582,931114,734057,939655],[395351,377494,543729,368629,913310,69242,737795,849175,870860,278493,575561,111787]]\\n\\nqueries:\\n[483649,690923,317026,408761,985459,619592,287085,302896,241756,557463,914140,994632,511904,377570,272415,840485,578955,797418,609746,388421,517504,170621,188489,169881,466574]"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "You have your frontier of places to visit in a heap, which means you don\\'t have to do a recursive call to dfs().  Just iterate while the lead element in the heap has low enough value.  Maybe you are not exploring sufficiently because. of this?  Another thought is that you seem to be putting \\'#\\' in the grid and also using a visit set;  you don\\'t need to do both!"
                    }
                ]
            },
            {
                "id": 1716612,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "There are better color combinations in world than light gray and white combination. :|"
                    },
                    {
                        "username": "vigneshr1603",
                        "content": "Am I color blind? All 3 diagrams of sol1 are same "
                    },
                    {
                        "username": "WitcherG",
                        "content": "the blurred cells are the visited ones, i got confused too."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "For people who are having trouble with the colors of the matrices.\\n\\n![image.png](https://assets.leetcode.com/users/images/1e2e29d1-be89-4c26-a2a6-8e4fe5ad11dc_1671030245.3139484.png)"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent 20 mins trying to understand what the matrices are, while others completed this question under 15mins. :\\\\"
                    },
                    {
                        "username": "Martician",
                        "content": "This is the coolest problem I have encountered."
                    },
                    {
                        "username": "dev-madhurendra",
                        "content": "Why this solution is not working for test case\\nMy Solution : \\n `\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &a,vector<int> &q,vector<vector<bool>> &vis,int n,int m,int row,int col,int target){\\n        if(row>=n || col >= m || row < 0 || col < 0 || vis[row][col] || a[row][col]>=target){\\n            return;\\n        }\\n        vis[row][col] = true;\\n        dfs(a,q,vis,n,m,row-1,col,target);\\n        dfs(a,q,vis,n,m,row+1,col,target);\\n        dfs(a,q,vis,n,m,row,col+1,target);\\n        dfs(a,q,vis,n,m,row+1,col-1,target);\\n    }\\n    vector<int> maxPoints(vector<vector<int>> &a,vector<int> &q){\\n        int n = a.size();\\n        int m = a[0].size();\\n        \\n\\n        vector<int> res;\\n        for(int i=0;i<q.size();++i){\\n            vector<vector<bool>> vis(n,vector<bool>(m,false));\\n            dfs(a,q,vis,n,m,0,0,q[i]);\\n            int ans = 0;\\n            for(int i=0;i<n;++i){\\n                for(int j=0;j<m;++j){\\n                    if(vis[i][j]){\\n                        ans++;\\n                    }\\n                }\\n            }\\n\\n            res.push_back(ans);\\n        }\\n\\n        return res;\\n    }\\n};\\n`\\n\\n\\n\\n\\nGrid : \\n[[249472,735471,144880,992181,760916,920551,898524,37043,422852,194509,714395,325171],[295872,922051,900801,634980,644237,912433,857189,98466,725226,984534,370121,399006],[618420,573065,587011,298153,694872,12760,880413,593508,474772,291113,852444,77998],[67650,426517,146447,190319,379151,184754,479219,106819,138473,865661,799297,228827],[390392,789371,772048,730506,7144,862164,650590,21524,879440,396198,408897,851020],[932044,662093,436861,246956,128943,167432,267483,148325,458128,418348,900594,831373],[742255,795191,598857,441846,243888,777685,313717,560586,257220,488025,846817,554722],[252507,621902,87704,599753,651175,305330,620166,631193,385405,183376,432598,706692],[984416,996917,586571,324595,784565,300514,101313,685863,703194,729430,732044,349877],[155629,290992,539879,173659,989930,373725,701670,992137,893024,455455,454886,559081],[252809,641084,632837,764260,68790,732601,349257,208701,613650,429049,983008,76324],[918085,126894,909148,194638,915416,225708,184408,462852,40392,964501,436864,785076],[875475,442333,111818,494972,486734,901577,46210,326422,603800,176902,315208,225178],[171174,458473,744971,872087,680060,95371,806370,322605,349331,736473,306720,556064],[207705,587869,129465,543368,840821,977451,399877,486877,327390,8865,605705,481076]]\\n\\nQueries : \\n[690474,796832,913701,939418,46696,266869,150594,948153,718874] \\n\\n"
                    },
                    {
                        "username": "yashsangwan2611",
                        "content": "can anybody tell me why it is giving wrong answer and only passes 7 cases as my approach is correct\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& q) {\\n        int m=grid.size(),n=grid[0].size(),k=q.size();\\n        vector<int>ans(k);\\n        vector<pair<int,int>>queries(k);\\n        for(int i=0;i<k;i++){\\n            queries[i]={q[i],i};\\n        }\\n        sort(queries.begin(),queries.end());\\n        set<pair<int,int>>s;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        s.insert({0,0});\\n        int cnt=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(!pq.empty()&&pq.top().first<queries[i].first){\\n                cnt++;\\n                int x=pq.top().second.first;\\n                int y=pq.top().second.second;\\n                pq.pop();\\n                if(x+1<m){\\n                    if(s.find({x+1,y})==s.end()){\\n                        pq.push({grid[x+1][y],{x+1,y}});\\n                        s.insert({x+1,y});\\n                    }\\n                }\\n                if(y+1<n){\\n                    if(s.find({x,y+1})==s.end()){\\n                        pq.push({grid[x][y+1],{x,y+1}});\\n                        s.insert({x,y+1});\\n                    }\\n                }   \\n            }\\n             ans[i]=cnt;\\n        }\\n        vector<int>res(k);\\n        for(int i=0;i<queries.size();i++){\\n            res[queries[i].second]=ans[i];\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Test cases are weak My brute force code got accepted."
                    },
                    {
                        "username": "15o1",
                        "content": "not anymore :("
                    },
                    {
                        "username": "ajay36",
                        "content": "why wouldn\\'t DFS work here? "
                    },
                    {
                        "username": "saam_neu",
                        "content": "Can anyone tell the mistake in my dfs. Its throwing error for the following test case\\n\\n```\\ndir=[0,1,0,-1,0]\\n        \\n        def dfs(q,nums,visit):\\n            val1,x,y=q[0]\\n            #visit.add((x,y))\\n            if val1>=nums:\\n                return\\n            heappop(q)    \\n            self.prevCount+=1\\n            grid[x][y]=\\'#\\'\\n            for i in range(len(dir)-1):\\n                a,b=x+dir[i],y+dir[i+1]\\n                if 0 <= a < rows and 0 <= b < cols and grid[a][b] !=\\'#\\':\\n                    if (a,b) not in visit:\\n                        visit.add((a,b))\\n                        heappush(q, (grid[a][b], a, b))              \\n                    dfs(q,nums,visit)\\n\\n        query = sorted(set(queries))\\n        r = {}\\n        rows, cols = len(grid), len(grid[0])\\n        q = [(grid[0][0], 0, 0)]\\n        self.prevCount = 0\\n        visit=set()\\n        \\n        for num in query:\\n            dfs(q,num,visit)\\n            r[num]=self.prevCount\\n            \\n        \\n        final = [r[num] for num in queries]\\n        return final\\n\\ngrid:\\n[[444424,409221,703419,11307,578382,330430,522887,38831,267101,315541,148425,360873],[353160,3217,718922,509568,494803,327636,715882,456279,374061,701863,711832,644822],[459535,264294,246310,405317,275802,948618,449015,176733,921040,56692,632708,556696],[167402,594284,8377,766746,728202,329140,399028,907843,68783,149661,244321,861358],[727577,582470,946680,222674,152875,128658,389710,581164,512061,367464,883657,78004],[463513,473823,328325,888670,267782,435621,153221,877511,900231,72761,825121,532939],[992835,33883,587426,680675,674055,682929,750368,241142,241026,369751,462134,785672],[915635,918034,398025,400424,695630,594801,748962,278900,705889,570212,42410,823342],[644602,961002,489119,606936,327139,664880,455045,231423,114466,315707,25092,961268],[962857,647428,139005,221262,469484,669734,66022,473118,258066,67408,545435,316643],[977028,938186,277400,756609,491213,704014,292941,392893,280499,650462,270100,477276],[393574,562825,637562,639836,8932,540799,758836,403682,79851,17885,851550,499020],[403665,119906,305796,88211,759076,441097,164887,709599,194,468995,922288,359913],[696749,265394,517399,161062,512967,205098,814158,627951,286474,763625,370987,798077],[166098,940946,871758,690278,903705,368584,576209,94794,25522,255261,209835,540769],[8088,89612,457088,492467,511285,900536,734726,683046,515695,14749,988608,977041],[76149,112648,515127,257871,912674,880020,32805,688253,722582,931114,734057,939655],[395351,377494,543729,368629,913310,69242,737795,849175,870860,278493,575561,111787]]\\n\\nqueries:\\n[483649,690923,317026,408761,985459,619592,287085,302896,241756,557463,914140,994632,511904,377570,272415,840485,578955,797418,609746,388421,517504,170621,188489,169881,466574]"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "You have your frontier of places to visit in a heap, which means you don\\'t have to do a recursive call to dfs().  Just iterate while the lead element in the heap has low enough value.  Maybe you are not exploring sufficiently because. of this?  Another thought is that you seem to be putting \\'#\\' in the grid and also using a visit set;  you don\\'t need to do both!"
                    }
                ]
            },
            {
                "id": 1712810,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "There are better color combinations in world than light gray and white combination. :|"
                    },
                    {
                        "username": "vigneshr1603",
                        "content": "Am I color blind? All 3 diagrams of sol1 are same "
                    },
                    {
                        "username": "WitcherG",
                        "content": "the blurred cells are the visited ones, i got confused too."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "For people who are having trouble with the colors of the matrices.\\n\\n![image.png](https://assets.leetcode.com/users/images/1e2e29d1-be89-4c26-a2a6-8e4fe5ad11dc_1671030245.3139484.png)"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent 20 mins trying to understand what the matrices are, while others completed this question under 15mins. :\\\\"
                    },
                    {
                        "username": "Martician",
                        "content": "This is the coolest problem I have encountered."
                    },
                    {
                        "username": "dev-madhurendra",
                        "content": "Why this solution is not working for test case\\nMy Solution : \\n `\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &a,vector<int> &q,vector<vector<bool>> &vis,int n,int m,int row,int col,int target){\\n        if(row>=n || col >= m || row < 0 || col < 0 || vis[row][col] || a[row][col]>=target){\\n            return;\\n        }\\n        vis[row][col] = true;\\n        dfs(a,q,vis,n,m,row-1,col,target);\\n        dfs(a,q,vis,n,m,row+1,col,target);\\n        dfs(a,q,vis,n,m,row,col+1,target);\\n        dfs(a,q,vis,n,m,row+1,col-1,target);\\n    }\\n    vector<int> maxPoints(vector<vector<int>> &a,vector<int> &q){\\n        int n = a.size();\\n        int m = a[0].size();\\n        \\n\\n        vector<int> res;\\n        for(int i=0;i<q.size();++i){\\n            vector<vector<bool>> vis(n,vector<bool>(m,false));\\n            dfs(a,q,vis,n,m,0,0,q[i]);\\n            int ans = 0;\\n            for(int i=0;i<n;++i){\\n                for(int j=0;j<m;++j){\\n                    if(vis[i][j]){\\n                        ans++;\\n                    }\\n                }\\n            }\\n\\n            res.push_back(ans);\\n        }\\n\\n        return res;\\n    }\\n};\\n`\\n\\n\\n\\n\\nGrid : \\n[[249472,735471,144880,992181,760916,920551,898524,37043,422852,194509,714395,325171],[295872,922051,900801,634980,644237,912433,857189,98466,725226,984534,370121,399006],[618420,573065,587011,298153,694872,12760,880413,593508,474772,291113,852444,77998],[67650,426517,146447,190319,379151,184754,479219,106819,138473,865661,799297,228827],[390392,789371,772048,730506,7144,862164,650590,21524,879440,396198,408897,851020],[932044,662093,436861,246956,128943,167432,267483,148325,458128,418348,900594,831373],[742255,795191,598857,441846,243888,777685,313717,560586,257220,488025,846817,554722],[252507,621902,87704,599753,651175,305330,620166,631193,385405,183376,432598,706692],[984416,996917,586571,324595,784565,300514,101313,685863,703194,729430,732044,349877],[155629,290992,539879,173659,989930,373725,701670,992137,893024,455455,454886,559081],[252809,641084,632837,764260,68790,732601,349257,208701,613650,429049,983008,76324],[918085,126894,909148,194638,915416,225708,184408,462852,40392,964501,436864,785076],[875475,442333,111818,494972,486734,901577,46210,326422,603800,176902,315208,225178],[171174,458473,744971,872087,680060,95371,806370,322605,349331,736473,306720,556064],[207705,587869,129465,543368,840821,977451,399877,486877,327390,8865,605705,481076]]\\n\\nQueries : \\n[690474,796832,913701,939418,46696,266869,150594,948153,718874] \\n\\n"
                    },
                    {
                        "username": "yashsangwan2611",
                        "content": "can anybody tell me why it is giving wrong answer and only passes 7 cases as my approach is correct\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& q) {\\n        int m=grid.size(),n=grid[0].size(),k=q.size();\\n        vector<int>ans(k);\\n        vector<pair<int,int>>queries(k);\\n        for(int i=0;i<k;i++){\\n            queries[i]={q[i],i};\\n        }\\n        sort(queries.begin(),queries.end());\\n        set<pair<int,int>>s;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        s.insert({0,0});\\n        int cnt=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(!pq.empty()&&pq.top().first<queries[i].first){\\n                cnt++;\\n                int x=pq.top().second.first;\\n                int y=pq.top().second.second;\\n                pq.pop();\\n                if(x+1<m){\\n                    if(s.find({x+1,y})==s.end()){\\n                        pq.push({grid[x+1][y],{x+1,y}});\\n                        s.insert({x+1,y});\\n                    }\\n                }\\n                if(y+1<n){\\n                    if(s.find({x,y+1})==s.end()){\\n                        pq.push({grid[x][y+1],{x,y+1}});\\n                        s.insert({x,y+1});\\n                    }\\n                }   \\n            }\\n             ans[i]=cnt;\\n        }\\n        vector<int>res(k);\\n        for(int i=0;i<queries.size();i++){\\n            res[queries[i].second]=ans[i];\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Test cases are weak My brute force code got accepted."
                    },
                    {
                        "username": "15o1",
                        "content": "not anymore :("
                    },
                    {
                        "username": "ajay36",
                        "content": "why wouldn\\'t DFS work here? "
                    },
                    {
                        "username": "saam_neu",
                        "content": "Can anyone tell the mistake in my dfs. Its throwing error for the following test case\\n\\n```\\ndir=[0,1,0,-1,0]\\n        \\n        def dfs(q,nums,visit):\\n            val1,x,y=q[0]\\n            #visit.add((x,y))\\n            if val1>=nums:\\n                return\\n            heappop(q)    \\n            self.prevCount+=1\\n            grid[x][y]=\\'#\\'\\n            for i in range(len(dir)-1):\\n                a,b=x+dir[i],y+dir[i+1]\\n                if 0 <= a < rows and 0 <= b < cols and grid[a][b] !=\\'#\\':\\n                    if (a,b) not in visit:\\n                        visit.add((a,b))\\n                        heappush(q, (grid[a][b], a, b))              \\n                    dfs(q,nums,visit)\\n\\n        query = sorted(set(queries))\\n        r = {}\\n        rows, cols = len(grid), len(grid[0])\\n        q = [(grid[0][0], 0, 0)]\\n        self.prevCount = 0\\n        visit=set()\\n        \\n        for num in query:\\n            dfs(q,num,visit)\\n            r[num]=self.prevCount\\n            \\n        \\n        final = [r[num] for num in queries]\\n        return final\\n\\ngrid:\\n[[444424,409221,703419,11307,578382,330430,522887,38831,267101,315541,148425,360873],[353160,3217,718922,509568,494803,327636,715882,456279,374061,701863,711832,644822],[459535,264294,246310,405317,275802,948618,449015,176733,921040,56692,632708,556696],[167402,594284,8377,766746,728202,329140,399028,907843,68783,149661,244321,861358],[727577,582470,946680,222674,152875,128658,389710,581164,512061,367464,883657,78004],[463513,473823,328325,888670,267782,435621,153221,877511,900231,72761,825121,532939],[992835,33883,587426,680675,674055,682929,750368,241142,241026,369751,462134,785672],[915635,918034,398025,400424,695630,594801,748962,278900,705889,570212,42410,823342],[644602,961002,489119,606936,327139,664880,455045,231423,114466,315707,25092,961268],[962857,647428,139005,221262,469484,669734,66022,473118,258066,67408,545435,316643],[977028,938186,277400,756609,491213,704014,292941,392893,280499,650462,270100,477276],[393574,562825,637562,639836,8932,540799,758836,403682,79851,17885,851550,499020],[403665,119906,305796,88211,759076,441097,164887,709599,194,468995,922288,359913],[696749,265394,517399,161062,512967,205098,814158,627951,286474,763625,370987,798077],[166098,940946,871758,690278,903705,368584,576209,94794,25522,255261,209835,540769],[8088,89612,457088,492467,511285,900536,734726,683046,515695,14749,988608,977041],[76149,112648,515127,257871,912674,880020,32805,688253,722582,931114,734057,939655],[395351,377494,543729,368629,913310,69242,737795,849175,870860,278493,575561,111787]]\\n\\nqueries:\\n[483649,690923,317026,408761,985459,619592,287085,302896,241756,557463,914140,994632,511904,377570,272415,840485,578955,797418,609746,388421,517504,170621,188489,169881,466574]"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "You have your frontier of places to visit in a heap, which means you don\\'t have to do a recursive call to dfs().  Just iterate while the lead element in the heap has low enough value.  Maybe you are not exploring sufficiently because. of this?  Another thought is that you seem to be putting \\'#\\' in the grid and also using a visit set;  you don\\'t need to do both!"
                    }
                ]
            },
            {
                "id": 1712933,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "There are better color combinations in world than light gray and white combination. :|"
                    },
                    {
                        "username": "vigneshr1603",
                        "content": "Am I color blind? All 3 diagrams of sol1 are same "
                    },
                    {
                        "username": "WitcherG",
                        "content": "the blurred cells are the visited ones, i got confused too."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "For people who are having trouble with the colors of the matrices.\\n\\n![image.png](https://assets.leetcode.com/users/images/1e2e29d1-be89-4c26-a2a6-8e4fe5ad11dc_1671030245.3139484.png)"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent 20 mins trying to understand what the matrices are, while others completed this question under 15mins. :\\\\"
                    },
                    {
                        "username": "Martician",
                        "content": "This is the coolest problem I have encountered."
                    },
                    {
                        "username": "dev-madhurendra",
                        "content": "Why this solution is not working for test case\\nMy Solution : \\n `\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &a,vector<int> &q,vector<vector<bool>> &vis,int n,int m,int row,int col,int target){\\n        if(row>=n || col >= m || row < 0 || col < 0 || vis[row][col] || a[row][col]>=target){\\n            return;\\n        }\\n        vis[row][col] = true;\\n        dfs(a,q,vis,n,m,row-1,col,target);\\n        dfs(a,q,vis,n,m,row+1,col,target);\\n        dfs(a,q,vis,n,m,row,col+1,target);\\n        dfs(a,q,vis,n,m,row+1,col-1,target);\\n    }\\n    vector<int> maxPoints(vector<vector<int>> &a,vector<int> &q){\\n        int n = a.size();\\n        int m = a[0].size();\\n        \\n\\n        vector<int> res;\\n        for(int i=0;i<q.size();++i){\\n            vector<vector<bool>> vis(n,vector<bool>(m,false));\\n            dfs(a,q,vis,n,m,0,0,q[i]);\\n            int ans = 0;\\n            for(int i=0;i<n;++i){\\n                for(int j=0;j<m;++j){\\n                    if(vis[i][j]){\\n                        ans++;\\n                    }\\n                }\\n            }\\n\\n            res.push_back(ans);\\n        }\\n\\n        return res;\\n    }\\n};\\n`\\n\\n\\n\\n\\nGrid : \\n[[249472,735471,144880,992181,760916,920551,898524,37043,422852,194509,714395,325171],[295872,922051,900801,634980,644237,912433,857189,98466,725226,984534,370121,399006],[618420,573065,587011,298153,694872,12760,880413,593508,474772,291113,852444,77998],[67650,426517,146447,190319,379151,184754,479219,106819,138473,865661,799297,228827],[390392,789371,772048,730506,7144,862164,650590,21524,879440,396198,408897,851020],[932044,662093,436861,246956,128943,167432,267483,148325,458128,418348,900594,831373],[742255,795191,598857,441846,243888,777685,313717,560586,257220,488025,846817,554722],[252507,621902,87704,599753,651175,305330,620166,631193,385405,183376,432598,706692],[984416,996917,586571,324595,784565,300514,101313,685863,703194,729430,732044,349877],[155629,290992,539879,173659,989930,373725,701670,992137,893024,455455,454886,559081],[252809,641084,632837,764260,68790,732601,349257,208701,613650,429049,983008,76324],[918085,126894,909148,194638,915416,225708,184408,462852,40392,964501,436864,785076],[875475,442333,111818,494972,486734,901577,46210,326422,603800,176902,315208,225178],[171174,458473,744971,872087,680060,95371,806370,322605,349331,736473,306720,556064],[207705,587869,129465,543368,840821,977451,399877,486877,327390,8865,605705,481076]]\\n\\nQueries : \\n[690474,796832,913701,939418,46696,266869,150594,948153,718874] \\n\\n"
                    },
                    {
                        "username": "yashsangwan2611",
                        "content": "can anybody tell me why it is giving wrong answer and only passes 7 cases as my approach is correct\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& q) {\\n        int m=grid.size(),n=grid[0].size(),k=q.size();\\n        vector<int>ans(k);\\n        vector<pair<int,int>>queries(k);\\n        for(int i=0;i<k;i++){\\n            queries[i]={q[i],i};\\n        }\\n        sort(queries.begin(),queries.end());\\n        set<pair<int,int>>s;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        s.insert({0,0});\\n        int cnt=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(!pq.empty()&&pq.top().first<queries[i].first){\\n                cnt++;\\n                int x=pq.top().second.first;\\n                int y=pq.top().second.second;\\n                pq.pop();\\n                if(x+1<m){\\n                    if(s.find({x+1,y})==s.end()){\\n                        pq.push({grid[x+1][y],{x+1,y}});\\n                        s.insert({x+1,y});\\n                    }\\n                }\\n                if(y+1<n){\\n                    if(s.find({x,y+1})==s.end()){\\n                        pq.push({grid[x][y+1],{x,y+1}});\\n                        s.insert({x,y+1});\\n                    }\\n                }   \\n            }\\n             ans[i]=cnt;\\n        }\\n        vector<int>res(k);\\n        for(int i=0;i<queries.size();i++){\\n            res[queries[i].second]=ans[i];\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Test cases are weak My brute force code got accepted."
                    },
                    {
                        "username": "15o1",
                        "content": "not anymore :("
                    },
                    {
                        "username": "ajay36",
                        "content": "why wouldn\\'t DFS work here? "
                    },
                    {
                        "username": "saam_neu",
                        "content": "Can anyone tell the mistake in my dfs. Its throwing error for the following test case\\n\\n```\\ndir=[0,1,0,-1,0]\\n        \\n        def dfs(q,nums,visit):\\n            val1,x,y=q[0]\\n            #visit.add((x,y))\\n            if val1>=nums:\\n                return\\n            heappop(q)    \\n            self.prevCount+=1\\n            grid[x][y]=\\'#\\'\\n            for i in range(len(dir)-1):\\n                a,b=x+dir[i],y+dir[i+1]\\n                if 0 <= a < rows and 0 <= b < cols and grid[a][b] !=\\'#\\':\\n                    if (a,b) not in visit:\\n                        visit.add((a,b))\\n                        heappush(q, (grid[a][b], a, b))              \\n                    dfs(q,nums,visit)\\n\\n        query = sorted(set(queries))\\n        r = {}\\n        rows, cols = len(grid), len(grid[0])\\n        q = [(grid[0][0], 0, 0)]\\n        self.prevCount = 0\\n        visit=set()\\n        \\n        for num in query:\\n            dfs(q,num,visit)\\n            r[num]=self.prevCount\\n            \\n        \\n        final = [r[num] for num in queries]\\n        return final\\n\\ngrid:\\n[[444424,409221,703419,11307,578382,330430,522887,38831,267101,315541,148425,360873],[353160,3217,718922,509568,494803,327636,715882,456279,374061,701863,711832,644822],[459535,264294,246310,405317,275802,948618,449015,176733,921040,56692,632708,556696],[167402,594284,8377,766746,728202,329140,399028,907843,68783,149661,244321,861358],[727577,582470,946680,222674,152875,128658,389710,581164,512061,367464,883657,78004],[463513,473823,328325,888670,267782,435621,153221,877511,900231,72761,825121,532939],[992835,33883,587426,680675,674055,682929,750368,241142,241026,369751,462134,785672],[915635,918034,398025,400424,695630,594801,748962,278900,705889,570212,42410,823342],[644602,961002,489119,606936,327139,664880,455045,231423,114466,315707,25092,961268],[962857,647428,139005,221262,469484,669734,66022,473118,258066,67408,545435,316643],[977028,938186,277400,756609,491213,704014,292941,392893,280499,650462,270100,477276],[393574,562825,637562,639836,8932,540799,758836,403682,79851,17885,851550,499020],[403665,119906,305796,88211,759076,441097,164887,709599,194,468995,922288,359913],[696749,265394,517399,161062,512967,205098,814158,627951,286474,763625,370987,798077],[166098,940946,871758,690278,903705,368584,576209,94794,25522,255261,209835,540769],[8088,89612,457088,492467,511285,900536,734726,683046,515695,14749,988608,977041],[76149,112648,515127,257871,912674,880020,32805,688253,722582,931114,734057,939655],[395351,377494,543729,368629,913310,69242,737795,849175,870860,278493,575561,111787]]\\n\\nqueries:\\n[483649,690923,317026,408761,985459,619592,287085,302896,241756,557463,914140,994632,511904,377570,272415,840485,578955,797418,609746,388421,517504,170621,188489,169881,466574]"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "You have your frontier of places to visit in a heap, which means you don\\'t have to do a recursive call to dfs().  Just iterate while the lead element in the heap has low enough value.  Maybe you are not exploring sufficiently because. of this?  Another thought is that you seem to be putting \\'#\\' in the grid and also using a visit set;  you don\\'t need to do both!"
                    }
                ]
            },
            {
                "id": 1716413,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "There are better color combinations in world than light gray and white combination. :|"
                    },
                    {
                        "username": "vigneshr1603",
                        "content": "Am I color blind? All 3 diagrams of sol1 are same "
                    },
                    {
                        "username": "WitcherG",
                        "content": "the blurred cells are the visited ones, i got confused too."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "For people who are having trouble with the colors of the matrices.\\n\\n![image.png](https://assets.leetcode.com/users/images/1e2e29d1-be89-4c26-a2a6-8e4fe5ad11dc_1671030245.3139484.png)"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent 20 mins trying to understand what the matrices are, while others completed this question under 15mins. :\\\\"
                    },
                    {
                        "username": "Martician",
                        "content": "This is the coolest problem I have encountered."
                    },
                    {
                        "username": "dev-madhurendra",
                        "content": "Why this solution is not working for test case\\nMy Solution : \\n `\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &a,vector<int> &q,vector<vector<bool>> &vis,int n,int m,int row,int col,int target){\\n        if(row>=n || col >= m || row < 0 || col < 0 || vis[row][col] || a[row][col]>=target){\\n            return;\\n        }\\n        vis[row][col] = true;\\n        dfs(a,q,vis,n,m,row-1,col,target);\\n        dfs(a,q,vis,n,m,row+1,col,target);\\n        dfs(a,q,vis,n,m,row,col+1,target);\\n        dfs(a,q,vis,n,m,row+1,col-1,target);\\n    }\\n    vector<int> maxPoints(vector<vector<int>> &a,vector<int> &q){\\n        int n = a.size();\\n        int m = a[0].size();\\n        \\n\\n        vector<int> res;\\n        for(int i=0;i<q.size();++i){\\n            vector<vector<bool>> vis(n,vector<bool>(m,false));\\n            dfs(a,q,vis,n,m,0,0,q[i]);\\n            int ans = 0;\\n            for(int i=0;i<n;++i){\\n                for(int j=0;j<m;++j){\\n                    if(vis[i][j]){\\n                        ans++;\\n                    }\\n                }\\n            }\\n\\n            res.push_back(ans);\\n        }\\n\\n        return res;\\n    }\\n};\\n`\\n\\n\\n\\n\\nGrid : \\n[[249472,735471,144880,992181,760916,920551,898524,37043,422852,194509,714395,325171],[295872,922051,900801,634980,644237,912433,857189,98466,725226,984534,370121,399006],[618420,573065,587011,298153,694872,12760,880413,593508,474772,291113,852444,77998],[67650,426517,146447,190319,379151,184754,479219,106819,138473,865661,799297,228827],[390392,789371,772048,730506,7144,862164,650590,21524,879440,396198,408897,851020],[932044,662093,436861,246956,128943,167432,267483,148325,458128,418348,900594,831373],[742255,795191,598857,441846,243888,777685,313717,560586,257220,488025,846817,554722],[252507,621902,87704,599753,651175,305330,620166,631193,385405,183376,432598,706692],[984416,996917,586571,324595,784565,300514,101313,685863,703194,729430,732044,349877],[155629,290992,539879,173659,989930,373725,701670,992137,893024,455455,454886,559081],[252809,641084,632837,764260,68790,732601,349257,208701,613650,429049,983008,76324],[918085,126894,909148,194638,915416,225708,184408,462852,40392,964501,436864,785076],[875475,442333,111818,494972,486734,901577,46210,326422,603800,176902,315208,225178],[171174,458473,744971,872087,680060,95371,806370,322605,349331,736473,306720,556064],[207705,587869,129465,543368,840821,977451,399877,486877,327390,8865,605705,481076]]\\n\\nQueries : \\n[690474,796832,913701,939418,46696,266869,150594,948153,718874] \\n\\n"
                    },
                    {
                        "username": "yashsangwan2611",
                        "content": "can anybody tell me why it is giving wrong answer and only passes 7 cases as my approach is correct\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& q) {\\n        int m=grid.size(),n=grid[0].size(),k=q.size();\\n        vector<int>ans(k);\\n        vector<pair<int,int>>queries(k);\\n        for(int i=0;i<k;i++){\\n            queries[i]={q[i],i};\\n        }\\n        sort(queries.begin(),queries.end());\\n        set<pair<int,int>>s;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        s.insert({0,0});\\n        int cnt=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(!pq.empty()&&pq.top().first<queries[i].first){\\n                cnt++;\\n                int x=pq.top().second.first;\\n                int y=pq.top().second.second;\\n                pq.pop();\\n                if(x+1<m){\\n                    if(s.find({x+1,y})==s.end()){\\n                        pq.push({grid[x+1][y],{x+1,y}});\\n                        s.insert({x+1,y});\\n                    }\\n                }\\n                if(y+1<n){\\n                    if(s.find({x,y+1})==s.end()){\\n                        pq.push({grid[x][y+1],{x,y+1}});\\n                        s.insert({x,y+1});\\n                    }\\n                }   \\n            }\\n             ans[i]=cnt;\\n        }\\n        vector<int>res(k);\\n        for(int i=0;i<queries.size();i++){\\n            res[queries[i].second]=ans[i];\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Test cases are weak My brute force code got accepted."
                    },
                    {
                        "username": "15o1",
                        "content": "not anymore :("
                    },
                    {
                        "username": "ajay36",
                        "content": "why wouldn\\'t DFS work here? "
                    },
                    {
                        "username": "saam_neu",
                        "content": "Can anyone tell the mistake in my dfs. Its throwing error for the following test case\\n\\n```\\ndir=[0,1,0,-1,0]\\n        \\n        def dfs(q,nums,visit):\\n            val1,x,y=q[0]\\n            #visit.add((x,y))\\n            if val1>=nums:\\n                return\\n            heappop(q)    \\n            self.prevCount+=1\\n            grid[x][y]=\\'#\\'\\n            for i in range(len(dir)-1):\\n                a,b=x+dir[i],y+dir[i+1]\\n                if 0 <= a < rows and 0 <= b < cols and grid[a][b] !=\\'#\\':\\n                    if (a,b) not in visit:\\n                        visit.add((a,b))\\n                        heappush(q, (grid[a][b], a, b))              \\n                    dfs(q,nums,visit)\\n\\n        query = sorted(set(queries))\\n        r = {}\\n        rows, cols = len(grid), len(grid[0])\\n        q = [(grid[0][0], 0, 0)]\\n        self.prevCount = 0\\n        visit=set()\\n        \\n        for num in query:\\n            dfs(q,num,visit)\\n            r[num]=self.prevCount\\n            \\n        \\n        final = [r[num] for num in queries]\\n        return final\\n\\ngrid:\\n[[444424,409221,703419,11307,578382,330430,522887,38831,267101,315541,148425,360873],[353160,3217,718922,509568,494803,327636,715882,456279,374061,701863,711832,644822],[459535,264294,246310,405317,275802,948618,449015,176733,921040,56692,632708,556696],[167402,594284,8377,766746,728202,329140,399028,907843,68783,149661,244321,861358],[727577,582470,946680,222674,152875,128658,389710,581164,512061,367464,883657,78004],[463513,473823,328325,888670,267782,435621,153221,877511,900231,72761,825121,532939],[992835,33883,587426,680675,674055,682929,750368,241142,241026,369751,462134,785672],[915635,918034,398025,400424,695630,594801,748962,278900,705889,570212,42410,823342],[644602,961002,489119,606936,327139,664880,455045,231423,114466,315707,25092,961268],[962857,647428,139005,221262,469484,669734,66022,473118,258066,67408,545435,316643],[977028,938186,277400,756609,491213,704014,292941,392893,280499,650462,270100,477276],[393574,562825,637562,639836,8932,540799,758836,403682,79851,17885,851550,499020],[403665,119906,305796,88211,759076,441097,164887,709599,194,468995,922288,359913],[696749,265394,517399,161062,512967,205098,814158,627951,286474,763625,370987,798077],[166098,940946,871758,690278,903705,368584,576209,94794,25522,255261,209835,540769],[8088,89612,457088,492467,511285,900536,734726,683046,515695,14749,988608,977041],[76149,112648,515127,257871,912674,880020,32805,688253,722582,931114,734057,939655],[395351,377494,543729,368629,913310,69242,737795,849175,870860,278493,575561,111787]]\\n\\nqueries:\\n[483649,690923,317026,408761,985459,619592,287085,302896,241756,557463,914140,994632,511904,377570,272415,840485,578955,797418,609746,388421,517504,170621,188489,169881,466574]"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "You have your frontier of places to visit in a heap, which means you don\\'t have to do a recursive call to dfs().  Just iterate while the lead element in the heap has low enough value.  Maybe you are not exploring sufficiently because. of this?  Another thought is that you seem to be putting \\'#\\' in the grid and also using a visit set;  you don\\'t need to do both!"
                    }
                ]
            },
            {
                "id": 1713620,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "There are better color combinations in world than light gray and white combination. :|"
                    },
                    {
                        "username": "vigneshr1603",
                        "content": "Am I color blind? All 3 diagrams of sol1 are same "
                    },
                    {
                        "username": "WitcherG",
                        "content": "the blurred cells are the visited ones, i got confused too."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "For people who are having trouble with the colors of the matrices.\\n\\n![image.png](https://assets.leetcode.com/users/images/1e2e29d1-be89-4c26-a2a6-8e4fe5ad11dc_1671030245.3139484.png)"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent 20 mins trying to understand what the matrices are, while others completed this question under 15mins. :\\\\"
                    },
                    {
                        "username": "Martician",
                        "content": "This is the coolest problem I have encountered."
                    },
                    {
                        "username": "dev-madhurendra",
                        "content": "Why this solution is not working for test case\\nMy Solution : \\n `\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &a,vector<int> &q,vector<vector<bool>> &vis,int n,int m,int row,int col,int target){\\n        if(row>=n || col >= m || row < 0 || col < 0 || vis[row][col] || a[row][col]>=target){\\n            return;\\n        }\\n        vis[row][col] = true;\\n        dfs(a,q,vis,n,m,row-1,col,target);\\n        dfs(a,q,vis,n,m,row+1,col,target);\\n        dfs(a,q,vis,n,m,row,col+1,target);\\n        dfs(a,q,vis,n,m,row+1,col-1,target);\\n    }\\n    vector<int> maxPoints(vector<vector<int>> &a,vector<int> &q){\\n        int n = a.size();\\n        int m = a[0].size();\\n        \\n\\n        vector<int> res;\\n        for(int i=0;i<q.size();++i){\\n            vector<vector<bool>> vis(n,vector<bool>(m,false));\\n            dfs(a,q,vis,n,m,0,0,q[i]);\\n            int ans = 0;\\n            for(int i=0;i<n;++i){\\n                for(int j=0;j<m;++j){\\n                    if(vis[i][j]){\\n                        ans++;\\n                    }\\n                }\\n            }\\n\\n            res.push_back(ans);\\n        }\\n\\n        return res;\\n    }\\n};\\n`\\n\\n\\n\\n\\nGrid : \\n[[249472,735471,144880,992181,760916,920551,898524,37043,422852,194509,714395,325171],[295872,922051,900801,634980,644237,912433,857189,98466,725226,984534,370121,399006],[618420,573065,587011,298153,694872,12760,880413,593508,474772,291113,852444,77998],[67650,426517,146447,190319,379151,184754,479219,106819,138473,865661,799297,228827],[390392,789371,772048,730506,7144,862164,650590,21524,879440,396198,408897,851020],[932044,662093,436861,246956,128943,167432,267483,148325,458128,418348,900594,831373],[742255,795191,598857,441846,243888,777685,313717,560586,257220,488025,846817,554722],[252507,621902,87704,599753,651175,305330,620166,631193,385405,183376,432598,706692],[984416,996917,586571,324595,784565,300514,101313,685863,703194,729430,732044,349877],[155629,290992,539879,173659,989930,373725,701670,992137,893024,455455,454886,559081],[252809,641084,632837,764260,68790,732601,349257,208701,613650,429049,983008,76324],[918085,126894,909148,194638,915416,225708,184408,462852,40392,964501,436864,785076],[875475,442333,111818,494972,486734,901577,46210,326422,603800,176902,315208,225178],[171174,458473,744971,872087,680060,95371,806370,322605,349331,736473,306720,556064],[207705,587869,129465,543368,840821,977451,399877,486877,327390,8865,605705,481076]]\\n\\nQueries : \\n[690474,796832,913701,939418,46696,266869,150594,948153,718874] \\n\\n"
                    },
                    {
                        "username": "yashsangwan2611",
                        "content": "can anybody tell me why it is giving wrong answer and only passes 7 cases as my approach is correct\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& q) {\\n        int m=grid.size(),n=grid[0].size(),k=q.size();\\n        vector<int>ans(k);\\n        vector<pair<int,int>>queries(k);\\n        for(int i=0;i<k;i++){\\n            queries[i]={q[i],i};\\n        }\\n        sort(queries.begin(),queries.end());\\n        set<pair<int,int>>s;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        s.insert({0,0});\\n        int cnt=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(!pq.empty()&&pq.top().first<queries[i].first){\\n                cnt++;\\n                int x=pq.top().second.first;\\n                int y=pq.top().second.second;\\n                pq.pop();\\n                if(x+1<m){\\n                    if(s.find({x+1,y})==s.end()){\\n                        pq.push({grid[x+1][y],{x+1,y}});\\n                        s.insert({x+1,y});\\n                    }\\n                }\\n                if(y+1<n){\\n                    if(s.find({x,y+1})==s.end()){\\n                        pq.push({grid[x][y+1],{x,y+1}});\\n                        s.insert({x,y+1});\\n                    }\\n                }   \\n            }\\n             ans[i]=cnt;\\n        }\\n        vector<int>res(k);\\n        for(int i=0;i<queries.size();i++){\\n            res[queries[i].second]=ans[i];\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Test cases are weak My brute force code got accepted."
                    },
                    {
                        "username": "15o1",
                        "content": "not anymore :("
                    },
                    {
                        "username": "ajay36",
                        "content": "why wouldn\\'t DFS work here? "
                    },
                    {
                        "username": "saam_neu",
                        "content": "Can anyone tell the mistake in my dfs. Its throwing error for the following test case\\n\\n```\\ndir=[0,1,0,-1,0]\\n        \\n        def dfs(q,nums,visit):\\n            val1,x,y=q[0]\\n            #visit.add((x,y))\\n            if val1>=nums:\\n                return\\n            heappop(q)    \\n            self.prevCount+=1\\n            grid[x][y]=\\'#\\'\\n            for i in range(len(dir)-1):\\n                a,b=x+dir[i],y+dir[i+1]\\n                if 0 <= a < rows and 0 <= b < cols and grid[a][b] !=\\'#\\':\\n                    if (a,b) not in visit:\\n                        visit.add((a,b))\\n                        heappush(q, (grid[a][b], a, b))              \\n                    dfs(q,nums,visit)\\n\\n        query = sorted(set(queries))\\n        r = {}\\n        rows, cols = len(grid), len(grid[0])\\n        q = [(grid[0][0], 0, 0)]\\n        self.prevCount = 0\\n        visit=set()\\n        \\n        for num in query:\\n            dfs(q,num,visit)\\n            r[num]=self.prevCount\\n            \\n        \\n        final = [r[num] for num in queries]\\n        return final\\n\\ngrid:\\n[[444424,409221,703419,11307,578382,330430,522887,38831,267101,315541,148425,360873],[353160,3217,718922,509568,494803,327636,715882,456279,374061,701863,711832,644822],[459535,264294,246310,405317,275802,948618,449015,176733,921040,56692,632708,556696],[167402,594284,8377,766746,728202,329140,399028,907843,68783,149661,244321,861358],[727577,582470,946680,222674,152875,128658,389710,581164,512061,367464,883657,78004],[463513,473823,328325,888670,267782,435621,153221,877511,900231,72761,825121,532939],[992835,33883,587426,680675,674055,682929,750368,241142,241026,369751,462134,785672],[915635,918034,398025,400424,695630,594801,748962,278900,705889,570212,42410,823342],[644602,961002,489119,606936,327139,664880,455045,231423,114466,315707,25092,961268],[962857,647428,139005,221262,469484,669734,66022,473118,258066,67408,545435,316643],[977028,938186,277400,756609,491213,704014,292941,392893,280499,650462,270100,477276],[393574,562825,637562,639836,8932,540799,758836,403682,79851,17885,851550,499020],[403665,119906,305796,88211,759076,441097,164887,709599,194,468995,922288,359913],[696749,265394,517399,161062,512967,205098,814158,627951,286474,763625,370987,798077],[166098,940946,871758,690278,903705,368584,576209,94794,25522,255261,209835,540769],[8088,89612,457088,492467,511285,900536,734726,683046,515695,14749,988608,977041],[76149,112648,515127,257871,912674,880020,32805,688253,722582,931114,734057,939655],[395351,377494,543729,368629,913310,69242,737795,849175,870860,278493,575561,111787]]\\n\\nqueries:\\n[483649,690923,317026,408761,985459,619592,287085,302896,241756,557463,914140,994632,511904,377570,272415,840485,578955,797418,609746,388421,517504,170621,188489,169881,466574]"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "You have your frontier of places to visit in a heap, which means you don\\'t have to do a recursive call to dfs().  Just iterate while the lead element in the heap has low enough value.  Maybe you are not exploring sufficiently because. of this?  Another thought is that you seem to be putting \\'#\\' in the grid and also using a visit set;  you don\\'t need to do both!"
                    }
                ]
            },
            {
                "id": 2075568,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "There are better color combinations in world than light gray and white combination. :|"
                    },
                    {
                        "username": "vigneshr1603",
                        "content": "Am I color blind? All 3 diagrams of sol1 are same "
                    },
                    {
                        "username": "WitcherG",
                        "content": "the blurred cells are the visited ones, i got confused too."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "For people who are having trouble with the colors of the matrices.\\n\\n![image.png](https://assets.leetcode.com/users/images/1e2e29d1-be89-4c26-a2a6-8e4fe5ad11dc_1671030245.3139484.png)"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent 20 mins trying to understand what the matrices are, while others completed this question under 15mins. :\\\\"
                    },
                    {
                        "username": "Martician",
                        "content": "This is the coolest problem I have encountered."
                    },
                    {
                        "username": "dev-madhurendra",
                        "content": "Why this solution is not working for test case\\nMy Solution : \\n `\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &a,vector<int> &q,vector<vector<bool>> &vis,int n,int m,int row,int col,int target){\\n        if(row>=n || col >= m || row < 0 || col < 0 || vis[row][col] || a[row][col]>=target){\\n            return;\\n        }\\n        vis[row][col] = true;\\n        dfs(a,q,vis,n,m,row-1,col,target);\\n        dfs(a,q,vis,n,m,row+1,col,target);\\n        dfs(a,q,vis,n,m,row,col+1,target);\\n        dfs(a,q,vis,n,m,row+1,col-1,target);\\n    }\\n    vector<int> maxPoints(vector<vector<int>> &a,vector<int> &q){\\n        int n = a.size();\\n        int m = a[0].size();\\n        \\n\\n        vector<int> res;\\n        for(int i=0;i<q.size();++i){\\n            vector<vector<bool>> vis(n,vector<bool>(m,false));\\n            dfs(a,q,vis,n,m,0,0,q[i]);\\n            int ans = 0;\\n            for(int i=0;i<n;++i){\\n                for(int j=0;j<m;++j){\\n                    if(vis[i][j]){\\n                        ans++;\\n                    }\\n                }\\n            }\\n\\n            res.push_back(ans);\\n        }\\n\\n        return res;\\n    }\\n};\\n`\\n\\n\\n\\n\\nGrid : \\n[[249472,735471,144880,992181,760916,920551,898524,37043,422852,194509,714395,325171],[295872,922051,900801,634980,644237,912433,857189,98466,725226,984534,370121,399006],[618420,573065,587011,298153,694872,12760,880413,593508,474772,291113,852444,77998],[67650,426517,146447,190319,379151,184754,479219,106819,138473,865661,799297,228827],[390392,789371,772048,730506,7144,862164,650590,21524,879440,396198,408897,851020],[932044,662093,436861,246956,128943,167432,267483,148325,458128,418348,900594,831373],[742255,795191,598857,441846,243888,777685,313717,560586,257220,488025,846817,554722],[252507,621902,87704,599753,651175,305330,620166,631193,385405,183376,432598,706692],[984416,996917,586571,324595,784565,300514,101313,685863,703194,729430,732044,349877],[155629,290992,539879,173659,989930,373725,701670,992137,893024,455455,454886,559081],[252809,641084,632837,764260,68790,732601,349257,208701,613650,429049,983008,76324],[918085,126894,909148,194638,915416,225708,184408,462852,40392,964501,436864,785076],[875475,442333,111818,494972,486734,901577,46210,326422,603800,176902,315208,225178],[171174,458473,744971,872087,680060,95371,806370,322605,349331,736473,306720,556064],[207705,587869,129465,543368,840821,977451,399877,486877,327390,8865,605705,481076]]\\n\\nQueries : \\n[690474,796832,913701,939418,46696,266869,150594,948153,718874] \\n\\n"
                    },
                    {
                        "username": "yashsangwan2611",
                        "content": "can anybody tell me why it is giving wrong answer and only passes 7 cases as my approach is correct\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& q) {\\n        int m=grid.size(),n=grid[0].size(),k=q.size();\\n        vector<int>ans(k);\\n        vector<pair<int,int>>queries(k);\\n        for(int i=0;i<k;i++){\\n            queries[i]={q[i],i};\\n        }\\n        sort(queries.begin(),queries.end());\\n        set<pair<int,int>>s;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        s.insert({0,0});\\n        int cnt=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(!pq.empty()&&pq.top().first<queries[i].first){\\n                cnt++;\\n                int x=pq.top().second.first;\\n                int y=pq.top().second.second;\\n                pq.pop();\\n                if(x+1<m){\\n                    if(s.find({x+1,y})==s.end()){\\n                        pq.push({grid[x+1][y],{x+1,y}});\\n                        s.insert({x+1,y});\\n                    }\\n                }\\n                if(y+1<n){\\n                    if(s.find({x,y+1})==s.end()){\\n                        pq.push({grid[x][y+1],{x,y+1}});\\n                        s.insert({x,y+1});\\n                    }\\n                }   \\n            }\\n             ans[i]=cnt;\\n        }\\n        vector<int>res(k);\\n        for(int i=0;i<queries.size();i++){\\n            res[queries[i].second]=ans[i];\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Test cases are weak My brute force code got accepted."
                    },
                    {
                        "username": "15o1",
                        "content": "not anymore :("
                    },
                    {
                        "username": "ajay36",
                        "content": "why wouldn\\'t DFS work here? "
                    },
                    {
                        "username": "saam_neu",
                        "content": "Can anyone tell the mistake in my dfs. Its throwing error for the following test case\\n\\n```\\ndir=[0,1,0,-1,0]\\n        \\n        def dfs(q,nums,visit):\\n            val1,x,y=q[0]\\n            #visit.add((x,y))\\n            if val1>=nums:\\n                return\\n            heappop(q)    \\n            self.prevCount+=1\\n            grid[x][y]=\\'#\\'\\n            for i in range(len(dir)-1):\\n                a,b=x+dir[i],y+dir[i+1]\\n                if 0 <= a < rows and 0 <= b < cols and grid[a][b] !=\\'#\\':\\n                    if (a,b) not in visit:\\n                        visit.add((a,b))\\n                        heappush(q, (grid[a][b], a, b))              \\n                    dfs(q,nums,visit)\\n\\n        query = sorted(set(queries))\\n        r = {}\\n        rows, cols = len(grid), len(grid[0])\\n        q = [(grid[0][0], 0, 0)]\\n        self.prevCount = 0\\n        visit=set()\\n        \\n        for num in query:\\n            dfs(q,num,visit)\\n            r[num]=self.prevCount\\n            \\n        \\n        final = [r[num] for num in queries]\\n        return final\\n\\ngrid:\\n[[444424,409221,703419,11307,578382,330430,522887,38831,267101,315541,148425,360873],[353160,3217,718922,509568,494803,327636,715882,456279,374061,701863,711832,644822],[459535,264294,246310,405317,275802,948618,449015,176733,921040,56692,632708,556696],[167402,594284,8377,766746,728202,329140,399028,907843,68783,149661,244321,861358],[727577,582470,946680,222674,152875,128658,389710,581164,512061,367464,883657,78004],[463513,473823,328325,888670,267782,435621,153221,877511,900231,72761,825121,532939],[992835,33883,587426,680675,674055,682929,750368,241142,241026,369751,462134,785672],[915635,918034,398025,400424,695630,594801,748962,278900,705889,570212,42410,823342],[644602,961002,489119,606936,327139,664880,455045,231423,114466,315707,25092,961268],[962857,647428,139005,221262,469484,669734,66022,473118,258066,67408,545435,316643],[977028,938186,277400,756609,491213,704014,292941,392893,280499,650462,270100,477276],[393574,562825,637562,639836,8932,540799,758836,403682,79851,17885,851550,499020],[403665,119906,305796,88211,759076,441097,164887,709599,194,468995,922288,359913],[696749,265394,517399,161062,512967,205098,814158,627951,286474,763625,370987,798077],[166098,940946,871758,690278,903705,368584,576209,94794,25522,255261,209835,540769],[8088,89612,457088,492467,511285,900536,734726,683046,515695,14749,988608,977041],[76149,112648,515127,257871,912674,880020,32805,688253,722582,931114,734057,939655],[395351,377494,543729,368629,913310,69242,737795,849175,870860,278493,575561,111787]]\\n\\nqueries:\\n[483649,690923,317026,408761,985459,619592,287085,302896,241756,557463,914140,994632,511904,377570,272415,840485,578955,797418,609746,388421,517504,170621,188489,169881,466574]"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "You have your frontier of places to visit in a heap, which means you don\\'t have to do a recursive call to dfs().  Just iterate while the lead element in the heap has low enough value.  Maybe you are not exploring sufficiently because. of this?  Another thought is that you seem to be putting \\'#\\' in the grid and also using a visit set;  you don\\'t need to do both!"
                    }
                ]
            },
            {
                "id": 1720773,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "There are better color combinations in world than light gray and white combination. :|"
                    },
                    {
                        "username": "vigneshr1603",
                        "content": "Am I color blind? All 3 diagrams of sol1 are same "
                    },
                    {
                        "username": "WitcherG",
                        "content": "the blurred cells are the visited ones, i got confused too."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "For people who are having trouble with the colors of the matrices.\\n\\n![image.png](https://assets.leetcode.com/users/images/1e2e29d1-be89-4c26-a2a6-8e4fe5ad11dc_1671030245.3139484.png)"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent 20 mins trying to understand what the matrices are, while others completed this question under 15mins. :\\\\"
                    },
                    {
                        "username": "Martician",
                        "content": "This is the coolest problem I have encountered."
                    },
                    {
                        "username": "dev-madhurendra",
                        "content": "Why this solution is not working for test case\\nMy Solution : \\n `\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &a,vector<int> &q,vector<vector<bool>> &vis,int n,int m,int row,int col,int target){\\n        if(row>=n || col >= m || row < 0 || col < 0 || vis[row][col] || a[row][col]>=target){\\n            return;\\n        }\\n        vis[row][col] = true;\\n        dfs(a,q,vis,n,m,row-1,col,target);\\n        dfs(a,q,vis,n,m,row+1,col,target);\\n        dfs(a,q,vis,n,m,row,col+1,target);\\n        dfs(a,q,vis,n,m,row+1,col-1,target);\\n    }\\n    vector<int> maxPoints(vector<vector<int>> &a,vector<int> &q){\\n        int n = a.size();\\n        int m = a[0].size();\\n        \\n\\n        vector<int> res;\\n        for(int i=0;i<q.size();++i){\\n            vector<vector<bool>> vis(n,vector<bool>(m,false));\\n            dfs(a,q,vis,n,m,0,0,q[i]);\\n            int ans = 0;\\n            for(int i=0;i<n;++i){\\n                for(int j=0;j<m;++j){\\n                    if(vis[i][j]){\\n                        ans++;\\n                    }\\n                }\\n            }\\n\\n            res.push_back(ans);\\n        }\\n\\n        return res;\\n    }\\n};\\n`\\n\\n\\n\\n\\nGrid : \\n[[249472,735471,144880,992181,760916,920551,898524,37043,422852,194509,714395,325171],[295872,922051,900801,634980,644237,912433,857189,98466,725226,984534,370121,399006],[618420,573065,587011,298153,694872,12760,880413,593508,474772,291113,852444,77998],[67650,426517,146447,190319,379151,184754,479219,106819,138473,865661,799297,228827],[390392,789371,772048,730506,7144,862164,650590,21524,879440,396198,408897,851020],[932044,662093,436861,246956,128943,167432,267483,148325,458128,418348,900594,831373],[742255,795191,598857,441846,243888,777685,313717,560586,257220,488025,846817,554722],[252507,621902,87704,599753,651175,305330,620166,631193,385405,183376,432598,706692],[984416,996917,586571,324595,784565,300514,101313,685863,703194,729430,732044,349877],[155629,290992,539879,173659,989930,373725,701670,992137,893024,455455,454886,559081],[252809,641084,632837,764260,68790,732601,349257,208701,613650,429049,983008,76324],[918085,126894,909148,194638,915416,225708,184408,462852,40392,964501,436864,785076],[875475,442333,111818,494972,486734,901577,46210,326422,603800,176902,315208,225178],[171174,458473,744971,872087,680060,95371,806370,322605,349331,736473,306720,556064],[207705,587869,129465,543368,840821,977451,399877,486877,327390,8865,605705,481076]]\\n\\nQueries : \\n[690474,796832,913701,939418,46696,266869,150594,948153,718874] \\n\\n"
                    },
                    {
                        "username": "yashsangwan2611",
                        "content": "can anybody tell me why it is giving wrong answer and only passes 7 cases as my approach is correct\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& q) {\\n        int m=grid.size(),n=grid[0].size(),k=q.size();\\n        vector<int>ans(k);\\n        vector<pair<int,int>>queries(k);\\n        for(int i=0;i<k;i++){\\n            queries[i]={q[i],i};\\n        }\\n        sort(queries.begin(),queries.end());\\n        set<pair<int,int>>s;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        s.insert({0,0});\\n        int cnt=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(!pq.empty()&&pq.top().first<queries[i].first){\\n                cnt++;\\n                int x=pq.top().second.first;\\n                int y=pq.top().second.second;\\n                pq.pop();\\n                if(x+1<m){\\n                    if(s.find({x+1,y})==s.end()){\\n                        pq.push({grid[x+1][y],{x+1,y}});\\n                        s.insert({x+1,y});\\n                    }\\n                }\\n                if(y+1<n){\\n                    if(s.find({x,y+1})==s.end()){\\n                        pq.push({grid[x][y+1],{x,y+1}});\\n                        s.insert({x,y+1});\\n                    }\\n                }   \\n            }\\n             ans[i]=cnt;\\n        }\\n        vector<int>res(k);\\n        for(int i=0;i<queries.size();i++){\\n            res[queries[i].second]=ans[i];\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Test cases are weak My brute force code got accepted."
                    },
                    {
                        "username": "15o1",
                        "content": "not anymore :("
                    },
                    {
                        "username": "ajay36",
                        "content": "why wouldn\\'t DFS work here? "
                    },
                    {
                        "username": "saam_neu",
                        "content": "Can anyone tell the mistake in my dfs. Its throwing error for the following test case\\n\\n```\\ndir=[0,1,0,-1,0]\\n        \\n        def dfs(q,nums,visit):\\n            val1,x,y=q[0]\\n            #visit.add((x,y))\\n            if val1>=nums:\\n                return\\n            heappop(q)    \\n            self.prevCount+=1\\n            grid[x][y]=\\'#\\'\\n            for i in range(len(dir)-1):\\n                a,b=x+dir[i],y+dir[i+1]\\n                if 0 <= a < rows and 0 <= b < cols and grid[a][b] !=\\'#\\':\\n                    if (a,b) not in visit:\\n                        visit.add((a,b))\\n                        heappush(q, (grid[a][b], a, b))              \\n                    dfs(q,nums,visit)\\n\\n        query = sorted(set(queries))\\n        r = {}\\n        rows, cols = len(grid), len(grid[0])\\n        q = [(grid[0][0], 0, 0)]\\n        self.prevCount = 0\\n        visit=set()\\n        \\n        for num in query:\\n            dfs(q,num,visit)\\n            r[num]=self.prevCount\\n            \\n        \\n        final = [r[num] for num in queries]\\n        return final\\n\\ngrid:\\n[[444424,409221,703419,11307,578382,330430,522887,38831,267101,315541,148425,360873],[353160,3217,718922,509568,494803,327636,715882,456279,374061,701863,711832,644822],[459535,264294,246310,405317,275802,948618,449015,176733,921040,56692,632708,556696],[167402,594284,8377,766746,728202,329140,399028,907843,68783,149661,244321,861358],[727577,582470,946680,222674,152875,128658,389710,581164,512061,367464,883657,78004],[463513,473823,328325,888670,267782,435621,153221,877511,900231,72761,825121,532939],[992835,33883,587426,680675,674055,682929,750368,241142,241026,369751,462134,785672],[915635,918034,398025,400424,695630,594801,748962,278900,705889,570212,42410,823342],[644602,961002,489119,606936,327139,664880,455045,231423,114466,315707,25092,961268],[962857,647428,139005,221262,469484,669734,66022,473118,258066,67408,545435,316643],[977028,938186,277400,756609,491213,704014,292941,392893,280499,650462,270100,477276],[393574,562825,637562,639836,8932,540799,758836,403682,79851,17885,851550,499020],[403665,119906,305796,88211,759076,441097,164887,709599,194,468995,922288,359913],[696749,265394,517399,161062,512967,205098,814158,627951,286474,763625,370987,798077],[166098,940946,871758,690278,903705,368584,576209,94794,25522,255261,209835,540769],[8088,89612,457088,492467,511285,900536,734726,683046,515695,14749,988608,977041],[76149,112648,515127,257871,912674,880020,32805,688253,722582,931114,734057,939655],[395351,377494,543729,368629,913310,69242,737795,849175,870860,278493,575561,111787]]\\n\\nqueries:\\n[483649,690923,317026,408761,985459,619592,287085,302896,241756,557463,914140,994632,511904,377570,272415,840485,578955,797418,609746,388421,517504,170621,188489,169881,466574]"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "You have your frontier of places to visit in a heap, which means you don\\'t have to do a recursive call to dfs().  Just iterate while the lead element in the heap has low enough value.  Maybe you are not exploring sufficiently because. of this?  Another thought is that you seem to be putting \\'#\\' in the grid and also using a visit set;  you don\\'t need to do both!"
                    }
                ]
            },
            {
                "id": 1720591,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "There are better color combinations in world than light gray and white combination. :|"
                    },
                    {
                        "username": "vigneshr1603",
                        "content": "Am I color blind? All 3 diagrams of sol1 are same "
                    },
                    {
                        "username": "WitcherG",
                        "content": "the blurred cells are the visited ones, i got confused too."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "For people who are having trouble with the colors of the matrices.\\n\\n![image.png](https://assets.leetcode.com/users/images/1e2e29d1-be89-4c26-a2a6-8e4fe5ad11dc_1671030245.3139484.png)"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent 20 mins trying to understand what the matrices are, while others completed this question under 15mins. :\\\\"
                    },
                    {
                        "username": "Martician",
                        "content": "This is the coolest problem I have encountered."
                    },
                    {
                        "username": "dev-madhurendra",
                        "content": "Why this solution is not working for test case\\nMy Solution : \\n `\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &a,vector<int> &q,vector<vector<bool>> &vis,int n,int m,int row,int col,int target){\\n        if(row>=n || col >= m || row < 0 || col < 0 || vis[row][col] || a[row][col]>=target){\\n            return;\\n        }\\n        vis[row][col] = true;\\n        dfs(a,q,vis,n,m,row-1,col,target);\\n        dfs(a,q,vis,n,m,row+1,col,target);\\n        dfs(a,q,vis,n,m,row,col+1,target);\\n        dfs(a,q,vis,n,m,row+1,col-1,target);\\n    }\\n    vector<int> maxPoints(vector<vector<int>> &a,vector<int> &q){\\n        int n = a.size();\\n        int m = a[0].size();\\n        \\n\\n        vector<int> res;\\n        for(int i=0;i<q.size();++i){\\n            vector<vector<bool>> vis(n,vector<bool>(m,false));\\n            dfs(a,q,vis,n,m,0,0,q[i]);\\n            int ans = 0;\\n            for(int i=0;i<n;++i){\\n                for(int j=0;j<m;++j){\\n                    if(vis[i][j]){\\n                        ans++;\\n                    }\\n                }\\n            }\\n\\n            res.push_back(ans);\\n        }\\n\\n        return res;\\n    }\\n};\\n`\\n\\n\\n\\n\\nGrid : \\n[[249472,735471,144880,992181,760916,920551,898524,37043,422852,194509,714395,325171],[295872,922051,900801,634980,644237,912433,857189,98466,725226,984534,370121,399006],[618420,573065,587011,298153,694872,12760,880413,593508,474772,291113,852444,77998],[67650,426517,146447,190319,379151,184754,479219,106819,138473,865661,799297,228827],[390392,789371,772048,730506,7144,862164,650590,21524,879440,396198,408897,851020],[932044,662093,436861,246956,128943,167432,267483,148325,458128,418348,900594,831373],[742255,795191,598857,441846,243888,777685,313717,560586,257220,488025,846817,554722],[252507,621902,87704,599753,651175,305330,620166,631193,385405,183376,432598,706692],[984416,996917,586571,324595,784565,300514,101313,685863,703194,729430,732044,349877],[155629,290992,539879,173659,989930,373725,701670,992137,893024,455455,454886,559081],[252809,641084,632837,764260,68790,732601,349257,208701,613650,429049,983008,76324],[918085,126894,909148,194638,915416,225708,184408,462852,40392,964501,436864,785076],[875475,442333,111818,494972,486734,901577,46210,326422,603800,176902,315208,225178],[171174,458473,744971,872087,680060,95371,806370,322605,349331,736473,306720,556064],[207705,587869,129465,543368,840821,977451,399877,486877,327390,8865,605705,481076]]\\n\\nQueries : \\n[690474,796832,913701,939418,46696,266869,150594,948153,718874] \\n\\n"
                    },
                    {
                        "username": "yashsangwan2611",
                        "content": "can anybody tell me why it is giving wrong answer and only passes 7 cases as my approach is correct\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& q) {\\n        int m=grid.size(),n=grid[0].size(),k=q.size();\\n        vector<int>ans(k);\\n        vector<pair<int,int>>queries(k);\\n        for(int i=0;i<k;i++){\\n            queries[i]={q[i],i};\\n        }\\n        sort(queries.begin(),queries.end());\\n        set<pair<int,int>>s;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        s.insert({0,0});\\n        int cnt=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(!pq.empty()&&pq.top().first<queries[i].first){\\n                cnt++;\\n                int x=pq.top().second.first;\\n                int y=pq.top().second.second;\\n                pq.pop();\\n                if(x+1<m){\\n                    if(s.find({x+1,y})==s.end()){\\n                        pq.push({grid[x+1][y],{x+1,y}});\\n                        s.insert({x+1,y});\\n                    }\\n                }\\n                if(y+1<n){\\n                    if(s.find({x,y+1})==s.end()){\\n                        pq.push({grid[x][y+1],{x,y+1}});\\n                        s.insert({x,y+1});\\n                    }\\n                }   \\n            }\\n             ans[i]=cnt;\\n        }\\n        vector<int>res(k);\\n        for(int i=0;i<queries.size();i++){\\n            res[queries[i].second]=ans[i];\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Test cases are weak My brute force code got accepted."
                    },
                    {
                        "username": "15o1",
                        "content": "not anymore :("
                    },
                    {
                        "username": "ajay36",
                        "content": "why wouldn\\'t DFS work here? "
                    },
                    {
                        "username": "saam_neu",
                        "content": "Can anyone tell the mistake in my dfs. Its throwing error for the following test case\\n\\n```\\ndir=[0,1,0,-1,0]\\n        \\n        def dfs(q,nums,visit):\\n            val1,x,y=q[0]\\n            #visit.add((x,y))\\n            if val1>=nums:\\n                return\\n            heappop(q)    \\n            self.prevCount+=1\\n            grid[x][y]=\\'#\\'\\n            for i in range(len(dir)-1):\\n                a,b=x+dir[i],y+dir[i+1]\\n                if 0 <= a < rows and 0 <= b < cols and grid[a][b] !=\\'#\\':\\n                    if (a,b) not in visit:\\n                        visit.add((a,b))\\n                        heappush(q, (grid[a][b], a, b))              \\n                    dfs(q,nums,visit)\\n\\n        query = sorted(set(queries))\\n        r = {}\\n        rows, cols = len(grid), len(grid[0])\\n        q = [(grid[0][0], 0, 0)]\\n        self.prevCount = 0\\n        visit=set()\\n        \\n        for num in query:\\n            dfs(q,num,visit)\\n            r[num]=self.prevCount\\n            \\n        \\n        final = [r[num] for num in queries]\\n        return final\\n\\ngrid:\\n[[444424,409221,703419,11307,578382,330430,522887,38831,267101,315541,148425,360873],[353160,3217,718922,509568,494803,327636,715882,456279,374061,701863,711832,644822],[459535,264294,246310,405317,275802,948618,449015,176733,921040,56692,632708,556696],[167402,594284,8377,766746,728202,329140,399028,907843,68783,149661,244321,861358],[727577,582470,946680,222674,152875,128658,389710,581164,512061,367464,883657,78004],[463513,473823,328325,888670,267782,435621,153221,877511,900231,72761,825121,532939],[992835,33883,587426,680675,674055,682929,750368,241142,241026,369751,462134,785672],[915635,918034,398025,400424,695630,594801,748962,278900,705889,570212,42410,823342],[644602,961002,489119,606936,327139,664880,455045,231423,114466,315707,25092,961268],[962857,647428,139005,221262,469484,669734,66022,473118,258066,67408,545435,316643],[977028,938186,277400,756609,491213,704014,292941,392893,280499,650462,270100,477276],[393574,562825,637562,639836,8932,540799,758836,403682,79851,17885,851550,499020],[403665,119906,305796,88211,759076,441097,164887,709599,194,468995,922288,359913],[696749,265394,517399,161062,512967,205098,814158,627951,286474,763625,370987,798077],[166098,940946,871758,690278,903705,368584,576209,94794,25522,255261,209835,540769],[8088,89612,457088,492467,511285,900536,734726,683046,515695,14749,988608,977041],[76149,112648,515127,257871,912674,880020,32805,688253,722582,931114,734057,939655],[395351,377494,543729,368629,913310,69242,737795,849175,870860,278493,575561,111787]]\\n\\nqueries:\\n[483649,690923,317026,408761,985459,619592,287085,302896,241756,557463,914140,994632,511904,377570,272415,840485,578955,797418,609746,388421,517504,170621,188489,169881,466574]"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "You have your frontier of places to visit in a heap, which means you don\\'t have to do a recursive call to dfs().  Just iterate while the lead element in the heap has low enough value.  Maybe you are not exploring sufficiently because. of this?  Another thought is that you seem to be putting \\'#\\' in the grid and also using a visit set;  you don\\'t need to do both!"
                    }
                ]
            },
            {
                "id": 1717373,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "There are better color combinations in world than light gray and white combination. :|"
                    },
                    {
                        "username": "vigneshr1603",
                        "content": "Am I color blind? All 3 diagrams of sol1 are same "
                    },
                    {
                        "username": "WitcherG",
                        "content": "the blurred cells are the visited ones, i got confused too."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "For people who are having trouble with the colors of the matrices.\\n\\n![image.png](https://assets.leetcode.com/users/images/1e2e29d1-be89-4c26-a2a6-8e4fe5ad11dc_1671030245.3139484.png)"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent 20 mins trying to understand what the matrices are, while others completed this question under 15mins. :\\\\"
                    },
                    {
                        "username": "Martician",
                        "content": "This is the coolest problem I have encountered."
                    },
                    {
                        "username": "dev-madhurendra",
                        "content": "Why this solution is not working for test case\\nMy Solution : \\n `\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &a,vector<int> &q,vector<vector<bool>> &vis,int n,int m,int row,int col,int target){\\n        if(row>=n || col >= m || row < 0 || col < 0 || vis[row][col] || a[row][col]>=target){\\n            return;\\n        }\\n        vis[row][col] = true;\\n        dfs(a,q,vis,n,m,row-1,col,target);\\n        dfs(a,q,vis,n,m,row+1,col,target);\\n        dfs(a,q,vis,n,m,row,col+1,target);\\n        dfs(a,q,vis,n,m,row+1,col-1,target);\\n    }\\n    vector<int> maxPoints(vector<vector<int>> &a,vector<int> &q){\\n        int n = a.size();\\n        int m = a[0].size();\\n        \\n\\n        vector<int> res;\\n        for(int i=0;i<q.size();++i){\\n            vector<vector<bool>> vis(n,vector<bool>(m,false));\\n            dfs(a,q,vis,n,m,0,0,q[i]);\\n            int ans = 0;\\n            for(int i=0;i<n;++i){\\n                for(int j=0;j<m;++j){\\n                    if(vis[i][j]){\\n                        ans++;\\n                    }\\n                }\\n            }\\n\\n            res.push_back(ans);\\n        }\\n\\n        return res;\\n    }\\n};\\n`\\n\\n\\n\\n\\nGrid : \\n[[249472,735471,144880,992181,760916,920551,898524,37043,422852,194509,714395,325171],[295872,922051,900801,634980,644237,912433,857189,98466,725226,984534,370121,399006],[618420,573065,587011,298153,694872,12760,880413,593508,474772,291113,852444,77998],[67650,426517,146447,190319,379151,184754,479219,106819,138473,865661,799297,228827],[390392,789371,772048,730506,7144,862164,650590,21524,879440,396198,408897,851020],[932044,662093,436861,246956,128943,167432,267483,148325,458128,418348,900594,831373],[742255,795191,598857,441846,243888,777685,313717,560586,257220,488025,846817,554722],[252507,621902,87704,599753,651175,305330,620166,631193,385405,183376,432598,706692],[984416,996917,586571,324595,784565,300514,101313,685863,703194,729430,732044,349877],[155629,290992,539879,173659,989930,373725,701670,992137,893024,455455,454886,559081],[252809,641084,632837,764260,68790,732601,349257,208701,613650,429049,983008,76324],[918085,126894,909148,194638,915416,225708,184408,462852,40392,964501,436864,785076],[875475,442333,111818,494972,486734,901577,46210,326422,603800,176902,315208,225178],[171174,458473,744971,872087,680060,95371,806370,322605,349331,736473,306720,556064],[207705,587869,129465,543368,840821,977451,399877,486877,327390,8865,605705,481076]]\\n\\nQueries : \\n[690474,796832,913701,939418,46696,266869,150594,948153,718874] \\n\\n"
                    },
                    {
                        "username": "yashsangwan2611",
                        "content": "can anybody tell me why it is giving wrong answer and only passes 7 cases as my approach is correct\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& q) {\\n        int m=grid.size(),n=grid[0].size(),k=q.size();\\n        vector<int>ans(k);\\n        vector<pair<int,int>>queries(k);\\n        for(int i=0;i<k;i++){\\n            queries[i]={q[i],i};\\n        }\\n        sort(queries.begin(),queries.end());\\n        set<pair<int,int>>s;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        s.insert({0,0});\\n        int cnt=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(!pq.empty()&&pq.top().first<queries[i].first){\\n                cnt++;\\n                int x=pq.top().second.first;\\n                int y=pq.top().second.second;\\n                pq.pop();\\n                if(x+1<m){\\n                    if(s.find({x+1,y})==s.end()){\\n                        pq.push({grid[x+1][y],{x+1,y}});\\n                        s.insert({x+1,y});\\n                    }\\n                }\\n                if(y+1<n){\\n                    if(s.find({x,y+1})==s.end()){\\n                        pq.push({grid[x][y+1],{x,y+1}});\\n                        s.insert({x,y+1});\\n                    }\\n                }   \\n            }\\n             ans[i]=cnt;\\n        }\\n        vector<int>res(k);\\n        for(int i=0;i<queries.size();i++){\\n            res[queries[i].second]=ans[i];\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Test cases are weak My brute force code got accepted."
                    },
                    {
                        "username": "15o1",
                        "content": "not anymore :("
                    },
                    {
                        "username": "ajay36",
                        "content": "why wouldn\\'t DFS work here? "
                    },
                    {
                        "username": "saam_neu",
                        "content": "Can anyone tell the mistake in my dfs. Its throwing error for the following test case\\n\\n```\\ndir=[0,1,0,-1,0]\\n        \\n        def dfs(q,nums,visit):\\n            val1,x,y=q[0]\\n            #visit.add((x,y))\\n            if val1>=nums:\\n                return\\n            heappop(q)    \\n            self.prevCount+=1\\n            grid[x][y]=\\'#\\'\\n            for i in range(len(dir)-1):\\n                a,b=x+dir[i],y+dir[i+1]\\n                if 0 <= a < rows and 0 <= b < cols and grid[a][b] !=\\'#\\':\\n                    if (a,b) not in visit:\\n                        visit.add((a,b))\\n                        heappush(q, (grid[a][b], a, b))              \\n                    dfs(q,nums,visit)\\n\\n        query = sorted(set(queries))\\n        r = {}\\n        rows, cols = len(grid), len(grid[0])\\n        q = [(grid[0][0], 0, 0)]\\n        self.prevCount = 0\\n        visit=set()\\n        \\n        for num in query:\\n            dfs(q,num,visit)\\n            r[num]=self.prevCount\\n            \\n        \\n        final = [r[num] for num in queries]\\n        return final\\n\\ngrid:\\n[[444424,409221,703419,11307,578382,330430,522887,38831,267101,315541,148425,360873],[353160,3217,718922,509568,494803,327636,715882,456279,374061,701863,711832,644822],[459535,264294,246310,405317,275802,948618,449015,176733,921040,56692,632708,556696],[167402,594284,8377,766746,728202,329140,399028,907843,68783,149661,244321,861358],[727577,582470,946680,222674,152875,128658,389710,581164,512061,367464,883657,78004],[463513,473823,328325,888670,267782,435621,153221,877511,900231,72761,825121,532939],[992835,33883,587426,680675,674055,682929,750368,241142,241026,369751,462134,785672],[915635,918034,398025,400424,695630,594801,748962,278900,705889,570212,42410,823342],[644602,961002,489119,606936,327139,664880,455045,231423,114466,315707,25092,961268],[962857,647428,139005,221262,469484,669734,66022,473118,258066,67408,545435,316643],[977028,938186,277400,756609,491213,704014,292941,392893,280499,650462,270100,477276],[393574,562825,637562,639836,8932,540799,758836,403682,79851,17885,851550,499020],[403665,119906,305796,88211,759076,441097,164887,709599,194,468995,922288,359913],[696749,265394,517399,161062,512967,205098,814158,627951,286474,763625,370987,798077],[166098,940946,871758,690278,903705,368584,576209,94794,25522,255261,209835,540769],[8088,89612,457088,492467,511285,900536,734726,683046,515695,14749,988608,977041],[76149,112648,515127,257871,912674,880020,32805,688253,722582,931114,734057,939655],[395351,377494,543729,368629,913310,69242,737795,849175,870860,278493,575561,111787]]\\n\\nqueries:\\n[483649,690923,317026,408761,985459,619592,287085,302896,241756,557463,914140,994632,511904,377570,272415,840485,578955,797418,609746,388421,517504,170621,188489,169881,466574]"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "You have your frontier of places to visit in a heap, which means you don\\'t have to do a recursive call to dfs().  Just iterate while the lead element in the heap has low enough value.  Maybe you are not exploring sufficiently because. of this?  Another thought is that you seem to be putting \\'#\\' in the grid and also using a visit set;  you don\\'t need to do both!"
                    }
                ]
            },
            {
                "id": 1716835,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "There are better color combinations in world than light gray and white combination. :|"
                    },
                    {
                        "username": "vigneshr1603",
                        "content": "Am I color blind? All 3 diagrams of sol1 are same "
                    },
                    {
                        "username": "WitcherG",
                        "content": "the blurred cells are the visited ones, i got confused too."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "For people who are having trouble with the colors of the matrices.\\n\\n![image.png](https://assets.leetcode.com/users/images/1e2e29d1-be89-4c26-a2a6-8e4fe5ad11dc_1671030245.3139484.png)"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent 20 mins trying to understand what the matrices are, while others completed this question under 15mins. :\\\\"
                    },
                    {
                        "username": "Martician",
                        "content": "This is the coolest problem I have encountered."
                    },
                    {
                        "username": "dev-madhurendra",
                        "content": "Why this solution is not working for test case\\nMy Solution : \\n `\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &a,vector<int> &q,vector<vector<bool>> &vis,int n,int m,int row,int col,int target){\\n        if(row>=n || col >= m || row < 0 || col < 0 || vis[row][col] || a[row][col]>=target){\\n            return;\\n        }\\n        vis[row][col] = true;\\n        dfs(a,q,vis,n,m,row-1,col,target);\\n        dfs(a,q,vis,n,m,row+1,col,target);\\n        dfs(a,q,vis,n,m,row,col+1,target);\\n        dfs(a,q,vis,n,m,row+1,col-1,target);\\n    }\\n    vector<int> maxPoints(vector<vector<int>> &a,vector<int> &q){\\n        int n = a.size();\\n        int m = a[0].size();\\n        \\n\\n        vector<int> res;\\n        for(int i=0;i<q.size();++i){\\n            vector<vector<bool>> vis(n,vector<bool>(m,false));\\n            dfs(a,q,vis,n,m,0,0,q[i]);\\n            int ans = 0;\\n            for(int i=0;i<n;++i){\\n                for(int j=0;j<m;++j){\\n                    if(vis[i][j]){\\n                        ans++;\\n                    }\\n                }\\n            }\\n\\n            res.push_back(ans);\\n        }\\n\\n        return res;\\n    }\\n};\\n`\\n\\n\\n\\n\\nGrid : \\n[[249472,735471,144880,992181,760916,920551,898524,37043,422852,194509,714395,325171],[295872,922051,900801,634980,644237,912433,857189,98466,725226,984534,370121,399006],[618420,573065,587011,298153,694872,12760,880413,593508,474772,291113,852444,77998],[67650,426517,146447,190319,379151,184754,479219,106819,138473,865661,799297,228827],[390392,789371,772048,730506,7144,862164,650590,21524,879440,396198,408897,851020],[932044,662093,436861,246956,128943,167432,267483,148325,458128,418348,900594,831373],[742255,795191,598857,441846,243888,777685,313717,560586,257220,488025,846817,554722],[252507,621902,87704,599753,651175,305330,620166,631193,385405,183376,432598,706692],[984416,996917,586571,324595,784565,300514,101313,685863,703194,729430,732044,349877],[155629,290992,539879,173659,989930,373725,701670,992137,893024,455455,454886,559081],[252809,641084,632837,764260,68790,732601,349257,208701,613650,429049,983008,76324],[918085,126894,909148,194638,915416,225708,184408,462852,40392,964501,436864,785076],[875475,442333,111818,494972,486734,901577,46210,326422,603800,176902,315208,225178],[171174,458473,744971,872087,680060,95371,806370,322605,349331,736473,306720,556064],[207705,587869,129465,543368,840821,977451,399877,486877,327390,8865,605705,481076]]\\n\\nQueries : \\n[690474,796832,913701,939418,46696,266869,150594,948153,718874] \\n\\n"
                    },
                    {
                        "username": "yashsangwan2611",
                        "content": "can anybody tell me why it is giving wrong answer and only passes 7 cases as my approach is correct\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& q) {\\n        int m=grid.size(),n=grid[0].size(),k=q.size();\\n        vector<int>ans(k);\\n        vector<pair<int,int>>queries(k);\\n        for(int i=0;i<k;i++){\\n            queries[i]={q[i],i};\\n        }\\n        sort(queries.begin(),queries.end());\\n        set<pair<int,int>>s;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        s.insert({0,0});\\n        int cnt=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(!pq.empty()&&pq.top().first<queries[i].first){\\n                cnt++;\\n                int x=pq.top().second.first;\\n                int y=pq.top().second.second;\\n                pq.pop();\\n                if(x+1<m){\\n                    if(s.find({x+1,y})==s.end()){\\n                        pq.push({grid[x+1][y],{x+1,y}});\\n                        s.insert({x+1,y});\\n                    }\\n                }\\n                if(y+1<n){\\n                    if(s.find({x,y+1})==s.end()){\\n                        pq.push({grid[x][y+1],{x,y+1}});\\n                        s.insert({x,y+1});\\n                    }\\n                }   \\n            }\\n             ans[i]=cnt;\\n        }\\n        vector<int>res(k);\\n        for(int i=0;i<queries.size();i++){\\n            res[queries[i].second]=ans[i];\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Test cases are weak My brute force code got accepted."
                    },
                    {
                        "username": "15o1",
                        "content": "not anymore :("
                    },
                    {
                        "username": "ajay36",
                        "content": "why wouldn\\'t DFS work here? "
                    },
                    {
                        "username": "saam_neu",
                        "content": "Can anyone tell the mistake in my dfs. Its throwing error for the following test case\\n\\n```\\ndir=[0,1,0,-1,0]\\n        \\n        def dfs(q,nums,visit):\\n            val1,x,y=q[0]\\n            #visit.add((x,y))\\n            if val1>=nums:\\n                return\\n            heappop(q)    \\n            self.prevCount+=1\\n            grid[x][y]=\\'#\\'\\n            for i in range(len(dir)-1):\\n                a,b=x+dir[i],y+dir[i+1]\\n                if 0 <= a < rows and 0 <= b < cols and grid[a][b] !=\\'#\\':\\n                    if (a,b) not in visit:\\n                        visit.add((a,b))\\n                        heappush(q, (grid[a][b], a, b))              \\n                    dfs(q,nums,visit)\\n\\n        query = sorted(set(queries))\\n        r = {}\\n        rows, cols = len(grid), len(grid[0])\\n        q = [(grid[0][0], 0, 0)]\\n        self.prevCount = 0\\n        visit=set()\\n        \\n        for num in query:\\n            dfs(q,num,visit)\\n            r[num]=self.prevCount\\n            \\n        \\n        final = [r[num] for num in queries]\\n        return final\\n\\ngrid:\\n[[444424,409221,703419,11307,578382,330430,522887,38831,267101,315541,148425,360873],[353160,3217,718922,509568,494803,327636,715882,456279,374061,701863,711832,644822],[459535,264294,246310,405317,275802,948618,449015,176733,921040,56692,632708,556696],[167402,594284,8377,766746,728202,329140,399028,907843,68783,149661,244321,861358],[727577,582470,946680,222674,152875,128658,389710,581164,512061,367464,883657,78004],[463513,473823,328325,888670,267782,435621,153221,877511,900231,72761,825121,532939],[992835,33883,587426,680675,674055,682929,750368,241142,241026,369751,462134,785672],[915635,918034,398025,400424,695630,594801,748962,278900,705889,570212,42410,823342],[644602,961002,489119,606936,327139,664880,455045,231423,114466,315707,25092,961268],[962857,647428,139005,221262,469484,669734,66022,473118,258066,67408,545435,316643],[977028,938186,277400,756609,491213,704014,292941,392893,280499,650462,270100,477276],[393574,562825,637562,639836,8932,540799,758836,403682,79851,17885,851550,499020],[403665,119906,305796,88211,759076,441097,164887,709599,194,468995,922288,359913],[696749,265394,517399,161062,512967,205098,814158,627951,286474,763625,370987,798077],[166098,940946,871758,690278,903705,368584,576209,94794,25522,255261,209835,540769],[8088,89612,457088,492467,511285,900536,734726,683046,515695,14749,988608,977041],[76149,112648,515127,257871,912674,880020,32805,688253,722582,931114,734057,939655],[395351,377494,543729,368629,913310,69242,737795,849175,870860,278493,575561,111787]]\\n\\nqueries:\\n[483649,690923,317026,408761,985459,619592,287085,302896,241756,557463,914140,994632,511904,377570,272415,840485,578955,797418,609746,388421,517504,170621,188489,169881,466574]"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "You have your frontier of places to visit in a heap, which means you don\\'t have to do a recursive call to dfs().  Just iterate while the lead element in the heap has low enough value.  Maybe you are not exploring sufficiently because. of this?  Another thought is that you seem to be putting \\'#\\' in the grid and also using a visit set;  you don\\'t need to do both!"
                    }
                ]
            },
            {
                "id": 1716612,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "There are better color combinations in world than light gray and white combination. :|"
                    },
                    {
                        "username": "vigneshr1603",
                        "content": "Am I color blind? All 3 diagrams of sol1 are same "
                    },
                    {
                        "username": "WitcherG",
                        "content": "the blurred cells are the visited ones, i got confused too."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "For people who are having trouble with the colors of the matrices.\\n\\n![image.png](https://assets.leetcode.com/users/images/1e2e29d1-be89-4c26-a2a6-8e4fe5ad11dc_1671030245.3139484.png)"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent 20 mins trying to understand what the matrices are, while others completed this question under 15mins. :\\\\"
                    },
                    {
                        "username": "Martician",
                        "content": "This is the coolest problem I have encountered."
                    },
                    {
                        "username": "dev-madhurendra",
                        "content": "Why this solution is not working for test case\\nMy Solution : \\n `\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &a,vector<int> &q,vector<vector<bool>> &vis,int n,int m,int row,int col,int target){\\n        if(row>=n || col >= m || row < 0 || col < 0 || vis[row][col] || a[row][col]>=target){\\n            return;\\n        }\\n        vis[row][col] = true;\\n        dfs(a,q,vis,n,m,row-1,col,target);\\n        dfs(a,q,vis,n,m,row+1,col,target);\\n        dfs(a,q,vis,n,m,row,col+1,target);\\n        dfs(a,q,vis,n,m,row+1,col-1,target);\\n    }\\n    vector<int> maxPoints(vector<vector<int>> &a,vector<int> &q){\\n        int n = a.size();\\n        int m = a[0].size();\\n        \\n\\n        vector<int> res;\\n        for(int i=0;i<q.size();++i){\\n            vector<vector<bool>> vis(n,vector<bool>(m,false));\\n            dfs(a,q,vis,n,m,0,0,q[i]);\\n            int ans = 0;\\n            for(int i=0;i<n;++i){\\n                for(int j=0;j<m;++j){\\n                    if(vis[i][j]){\\n                        ans++;\\n                    }\\n                }\\n            }\\n\\n            res.push_back(ans);\\n        }\\n\\n        return res;\\n    }\\n};\\n`\\n\\n\\n\\n\\nGrid : \\n[[249472,735471,144880,992181,760916,920551,898524,37043,422852,194509,714395,325171],[295872,922051,900801,634980,644237,912433,857189,98466,725226,984534,370121,399006],[618420,573065,587011,298153,694872,12760,880413,593508,474772,291113,852444,77998],[67650,426517,146447,190319,379151,184754,479219,106819,138473,865661,799297,228827],[390392,789371,772048,730506,7144,862164,650590,21524,879440,396198,408897,851020],[932044,662093,436861,246956,128943,167432,267483,148325,458128,418348,900594,831373],[742255,795191,598857,441846,243888,777685,313717,560586,257220,488025,846817,554722],[252507,621902,87704,599753,651175,305330,620166,631193,385405,183376,432598,706692],[984416,996917,586571,324595,784565,300514,101313,685863,703194,729430,732044,349877],[155629,290992,539879,173659,989930,373725,701670,992137,893024,455455,454886,559081],[252809,641084,632837,764260,68790,732601,349257,208701,613650,429049,983008,76324],[918085,126894,909148,194638,915416,225708,184408,462852,40392,964501,436864,785076],[875475,442333,111818,494972,486734,901577,46210,326422,603800,176902,315208,225178],[171174,458473,744971,872087,680060,95371,806370,322605,349331,736473,306720,556064],[207705,587869,129465,543368,840821,977451,399877,486877,327390,8865,605705,481076]]\\n\\nQueries : \\n[690474,796832,913701,939418,46696,266869,150594,948153,718874] \\n\\n"
                    },
                    {
                        "username": "yashsangwan2611",
                        "content": "can anybody tell me why it is giving wrong answer and only passes 7 cases as my approach is correct\\nclass Solution {\\npublic:\\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& q) {\\n        int m=grid.size(),n=grid[0].size(),k=q.size();\\n        vector<int>ans(k);\\n        vector<pair<int,int>>queries(k);\\n        for(int i=0;i<k;i++){\\n            queries[i]={q[i],i};\\n        }\\n        sort(queries.begin(),queries.end());\\n        set<pair<int,int>>s;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        s.insert({0,0});\\n        int cnt=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(!pq.empty()&&pq.top().first<queries[i].first){\\n                cnt++;\\n                int x=pq.top().second.first;\\n                int y=pq.top().second.second;\\n                pq.pop();\\n                if(x+1<m){\\n                    if(s.find({x+1,y})==s.end()){\\n                        pq.push({grid[x+1][y],{x+1,y}});\\n                        s.insert({x+1,y});\\n                    }\\n                }\\n                if(y+1<n){\\n                    if(s.find({x,y+1})==s.end()){\\n                        pq.push({grid[x][y+1],{x,y+1}});\\n                        s.insert({x,y+1});\\n                    }\\n                }   \\n            }\\n             ans[i]=cnt;\\n        }\\n        vector<int>res(k);\\n        for(int i=0;i<queries.size();i++){\\n            res[queries[i].second]=ans[i];\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Test cases are weak My brute force code got accepted."
                    },
                    {
                        "username": "15o1",
                        "content": "not anymore :("
                    },
                    {
                        "username": "ajay36",
                        "content": "why wouldn\\'t DFS work here? "
                    },
                    {
                        "username": "saam_neu",
                        "content": "Can anyone tell the mistake in my dfs. Its throwing error for the following test case\\n\\n```\\ndir=[0,1,0,-1,0]\\n        \\n        def dfs(q,nums,visit):\\n            val1,x,y=q[0]\\n            #visit.add((x,y))\\n            if val1>=nums:\\n                return\\n            heappop(q)    \\n            self.prevCount+=1\\n            grid[x][y]=\\'#\\'\\n            for i in range(len(dir)-1):\\n                a,b=x+dir[i],y+dir[i+1]\\n                if 0 <= a < rows and 0 <= b < cols and grid[a][b] !=\\'#\\':\\n                    if (a,b) not in visit:\\n                        visit.add((a,b))\\n                        heappush(q, (grid[a][b], a, b))              \\n                    dfs(q,nums,visit)\\n\\n        query = sorted(set(queries))\\n        r = {}\\n        rows, cols = len(grid), len(grid[0])\\n        q = [(grid[0][0], 0, 0)]\\n        self.prevCount = 0\\n        visit=set()\\n        \\n        for num in query:\\n            dfs(q,num,visit)\\n            r[num]=self.prevCount\\n            \\n        \\n        final = [r[num] for num in queries]\\n        return final\\n\\ngrid:\\n[[444424,409221,703419,11307,578382,330430,522887,38831,267101,315541,148425,360873],[353160,3217,718922,509568,494803,327636,715882,456279,374061,701863,711832,644822],[459535,264294,246310,405317,275802,948618,449015,176733,921040,56692,632708,556696],[167402,594284,8377,766746,728202,329140,399028,907843,68783,149661,244321,861358],[727577,582470,946680,222674,152875,128658,389710,581164,512061,367464,883657,78004],[463513,473823,328325,888670,267782,435621,153221,877511,900231,72761,825121,532939],[992835,33883,587426,680675,674055,682929,750368,241142,241026,369751,462134,785672],[915635,918034,398025,400424,695630,594801,748962,278900,705889,570212,42410,823342],[644602,961002,489119,606936,327139,664880,455045,231423,114466,315707,25092,961268],[962857,647428,139005,221262,469484,669734,66022,473118,258066,67408,545435,316643],[977028,938186,277400,756609,491213,704014,292941,392893,280499,650462,270100,477276],[393574,562825,637562,639836,8932,540799,758836,403682,79851,17885,851550,499020],[403665,119906,305796,88211,759076,441097,164887,709599,194,468995,922288,359913],[696749,265394,517399,161062,512967,205098,814158,627951,286474,763625,370987,798077],[166098,940946,871758,690278,903705,368584,576209,94794,25522,255261,209835,540769],[8088,89612,457088,492467,511285,900536,734726,683046,515695,14749,988608,977041],[76149,112648,515127,257871,912674,880020,32805,688253,722582,931114,734057,939655],[395351,377494,543729,368629,913310,69242,737795,849175,870860,278493,575561,111787]]\\n\\nqueries:\\n[483649,690923,317026,408761,985459,619592,287085,302896,241756,557463,914140,994632,511904,377570,272415,840485,578955,797418,609746,388421,517504,170621,188489,169881,466574]"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "You have your frontier of places to visit in a heap, which means you don\\'t have to do a recursive call to dfs().  Just iterate while the lead element in the heap has low enough value.  Maybe you are not exploring sufficiently because. of this?  Another thought is that you seem to be putting \\'#\\' in the grid and also using a visit set;  you don\\'t need to do both!"
                    }
                ]
            }
        ]
    }
]