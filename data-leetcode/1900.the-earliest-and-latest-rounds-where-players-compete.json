[
    {
        "title": "Number of Submatrices That Sum to Target",
        "question_content": "Given a matrix&nbsp;and a target, return the number of non-empty submatrices that sum to target.\nA submatrix x1, y1, x2, y2 is the set of all cells matrix[x][y] with x1 <= x <= x2 and y1 <= y <= y2.\nTwo submatrices (x1, y1, x2, y2) and (x1', y1', x2', y2') are different if they have some coordinate&nbsp;that is different: for example, if x1 != x1'.\n&nbsp;\nExample 1:\n\nInput: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0\nOutput: 4\nExplanation: The four 1x1 submatrices that only contain 0.\n\nExample 2:\n\nInput: matrix = [[1,-1],[-1,1]], target = 0\nOutput: 5\nExplanation: The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.\n\nExample 3:\n\nInput: matrix = [[904]], target = 0\nOutput: 0\n\n&nbsp;\nConstraints:\n\n\t1 <= matrix.length <= 100\n\t1 <= matrix[0].length <= 100\n\t-1000 <= matrix[i] <= 1000\n\t-10^8 <= target <= 10^8",
        "solutions": [
            {
                "id": 303750,
                "title": "java-c-python-find-the-subarray-with-target-sum",
                "content": "# Intuition\\nPreaquis: [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/description/)\\nFind the Subarray with Target Sum in linear time.\\n<br>\\n\\n# Explanation\\nFor each row, calculate the prefix sum.\\nFor each pair of columns,\\ncalculate the accumulated sum of rows.\\nNow this problem is same to, \"Find the Subarray with Target Sum\".\\n<br>\\n\\n# Complexity\\nTime `O(mnn)`\\nSpace `O(m)`\\n<br>\\n\\n**Java**\\n```java\\n    public int numSubmatrixSumTarget(int[][] A, int target) {\\n        int res = 0, m = A.length, n = A[0].length;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                A[i][j] += A[i][j - 1];\\n        Map<Integer, Integer> counter = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                counter.clear();\\n                counter.put(0, 1);\\n                int cur = 0;\\n                for (int k = 0; k < m; k++) {\\n                    cur += A[k][j] - (i > 0 ? A[k][i - 1] : 0);\\n                    res += counter.getOrDefault(cur - target, 0);\\n                    counter.put(cur, counter.getOrDefault(cur, 0) + 1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n        int res = 0, m = A.size(), n = A[0].size();\\n        for (int i = 0; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                A[i][j] += A[i][j - 1];\\n\\n        unordered_map<int, int> counter;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                counter = {{0,1}};\\n                int cur = 0;\\n                for (int k = 0; k < m; k++) {\\n                    cur += A[k][j] - (i > 0 ? A[k][i - 1] : 0);\\n                    res += counter.find(cur - target) != counter.end() ? counter[cur - target] : 0;\\n                    counter[cur]++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def numSubmatrixSumTarget(self, A, target):\\n        m, n = len(A), len(A[0])\\n        for row in A:\\n            for i in xrange(n - 1):\\n                row[i + 1] += row[i]\\n        res = 0\\n        for i in xrange(n):\\n            for j in xrange(i, n):\\n                c = collections.defaultdict(int)\\n                cur, c[0] = 0, 1\\n                for k in xrange(m):\\n                    cur += A[k][j] - (A[k][i - 1] if i > 0 else 0)\\n                    res += c[cur - target]\\n                    c[cur] += 1\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int numSubmatrixSumTarget(int[][] A, int target) {\\n        int res = 0, m = A.length, n = A[0].length;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                A[i][j] += A[i][j - 1];\\n        Map<Integer, Integer> counter = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                counter.clear();\\n                counter.put(0, 1);\\n                int cur = 0;\\n                for (int k = 0; k < m; k++) {\\n                    cur += A[k][j] - (i > 0 ? A[k][i - 1] : 0);\\n                    res += counter.getOrDefault(cur - target, 0);\\n                    counter.put(cur, counter.getOrDefault(cur, 0) + 1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n        int res = 0, m = A.size(), n = A[0].size();\\n        for (int i = 0; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                A[i][j] += A[i][j - 1];\\n\\n        unordered_map<int, int> counter;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                counter = {{0,1}};\\n                int cur = 0;\\n                for (int k = 0; k < m; k++) {\\n                    cur += A[k][j] - (i > 0 ? A[k][i - 1] : 0);\\n                    res += counter.find(cur - target) != counter.end() ? counter[cur - target] : 0;\\n                    counter[cur]++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def numSubmatrixSumTarget(self, A, target):\\n        m, n = len(A), len(A[0])\\n        for row in A:\\n            for i in xrange(n - 1):\\n                row[i + 1] += row[i]\\n        res = 0\\n        for i in xrange(n):\\n            for j in xrange(i, n):\\n                c = collections.defaultdict(int)\\n                cur, c[0] = 0, 1\\n                for k in xrange(m):\\n                    cur += A[k][j] - (A[k][i - 1] if i > 0 else 0)\\n                    res += c[cur - target]\\n                    c[cur] += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 303773,
                "title": "c-o-n-3-simple-1d-subarray-target-sum-applied-to-2d-array",
                "content": "**Explaination:**\\nCheck out how to solve for 1D array `560. Subarray Sum Equals K` in O(n) time.\\n\\nThe solution for 1D array uses running prefix sum.\\n* We know that to get sum of a subarray `[j,i]` we can calculate using `SUM[0,i] - SUM [0,j-1]`.\\n* If this calculation = target then we have a subarray who\\'s sum equals target and ends at `i`.\\n* Hence at any point `i` we need to find number of occurence of `runningSum - target` since `x + target = runningSum`.\\n* We start moving from 1st element to the last and keep adding the value to running sum.\\n* We also keep a hash map maintaining number of such sums occured.\\n* Thus at any point `i` we have sums from [0,i) stored in hashmap where `i` ranges from `0` to `i` excluding `i`. eg: at `i=3`, we have `SUM[0,0`] , `SUM[0,1]` and `SUM[0,2]`.\\n* At each index `i` we can then query the hashmap to find out number of occurences of `runningSum-target` to get number of subarrays ending at `i`.\\n\\nNow since we know how to find number of subarrays who\\'s sum equals target for 1D array.\\nWe can convert a 2D matrix of values to 1D matrix whose values equal to that of 2D. Such that they have combination of all rows and apply the same technique.\\neg: [[1,2,3,4,5],[2,6,7,8,9]]\\n\\nWe can break this down to 1 2x5 matrix and 2 1x5 matrix\\nThus the 1D value matrices are:\\n* We start row wise\\n* 1st 1x5 matrix is matrix[0] itself [1,2,3,4,5].\\n* We then add second row to previous 1D matrix and get [3,8,10,12,14].\\n* We then move on to make matrices with 2nd row of the original matrix as their first row.\\n* Since 2nd row is the last we end up with last 1D matrix of [2,6,7,8,9].\\n\\nWe use the same technique for each 1D matrix created in above steps and keep adding the result for these individual 1D arrays and return that as the result in the end.\\n\\nIf you notice in the case of 1D array you get results for subarrays of all lengths starting from any point.\\nso you are checking rectangles of 1x1, 1x2, 1x3 ..... upto length.\\nWhen you apply this to a 2D->1D array at each `i` you are checking rectangles of all sizes starting from `i`.\\nwhich looks like ( (1x1, 1x2 ...upto length of row then 2x1, 2x2 ...upto length of a row) .... upto length of columns) for each row in original matrix as their 1st row, hence the result includes all combinations of submatrices.\\n\\n**Note:** You can make this a little bit faster by sacrificing space and precalculating all prefix sums in the 2D matrix and storing them as in `304. Range Sum Query 2D - Immutable` so that we have a constant lookup for calculating sums, this way we avoid recalculating sums of overlapping rows.\\n\\n**Solution:**\\n```c++\\nclass Solution {\\npublic:\\n    int result=0,target;\\n    unordered_map<int,int> map;\\n    void get_result(vector<int>& nums)                          //Get number of subarrays that sum to target.\\n    {\\n        int sum=0;\\n        map.clear();\\n        map[0]++;\\n        for(int &i:nums)\\n        {\\n            sum+=i;\\n            result+=map[sum-target];       //get number of subarrays who\\'s sum equals target and end at i and add result to global result.\\n            map[sum]++;                    //Add the occurence of running sum to map.\\n        }\\n    }\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) \\n    {\\n        this->target=target;\\n        vector<int> row(matrix[0].size());\\n        for(int i=0;i<matrix.size();i++)                    //Convert 2D array to 1D by row.\\n        {\\n            fill(row.begin(),row.end(),0);                  //Clear vector to start the row with i as starting row.\\n            for(int j=i;j<matrix.size();j++)\\n            {\\n                for(int x=0;x<matrix[0].size();x++)         //Add next row\\n                    row[x]+=matrix[j][x];\\n                get_result(row);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int result=0,target;\\n    unordered_map<int,int> map;\\n    void get_result(vector<int>& nums)                          //Get number of subarrays that sum to target.\\n    {\\n        int sum=0;\\n        map.clear();\\n        map[0]++;\\n        for(int &i:nums)\\n        {\\n            sum+=i;\\n            result+=map[sum-target];       //get number of subarrays who\\'s sum equals target and end at i and add result to global result.\\n            map[sum]++;                    //Add the occurence of running sum to map.\\n        }\\n    }\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) \\n    {\\n        this->target=target;\\n        vector<int> row(matrix[0].size());\\n        for(int i=0;i<matrix.size();i++)                    //Convert 2D array to 1D by row.\\n        {\\n            fill(row.begin(),row.end(),0);                  //Clear vector to start the row with i as starting row.\\n            for(int j=i;j<matrix.size();j++)\\n            {\\n                for(int x=0;x<matrix[0].size();x++)         //Add next row\\n                    row[x]+=matrix[j][x];\\n                get_result(row);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 803353,
                "title": "java-solution-with-detailed-explanation",
                "content": "## Before this problem\\n>https://leetcode.com/problems/subarray-sum-equals-k/\\n>https://leetcode.com/problems/subarray-sum-equals-k/discuss/803317/Java-Solution-with-Detailed-Explanation\\n## Thinkings\\n\\n1.  For a matrix, what is the prefix sum ?\\n\\n\\t   sum[x] [y] is the sum of submatrix \\n\\n\\t   (The upper left corner is matrix[0] [0], the lower right corner is matrix[x] [y])\\n\\n\\t  ![image](https://assets.leetcode.com/users/images/da24efb3-690d-487a-b40f-8afb366907b8_1597987444.885463.png)\\n\\n\\n2. How to calculate the sum of all submatrices ***whose upper left corners are matrix[0] [0]*** \\uFF1F\\n\\n   Step 1. Calculate the prefix sum of each line.\\n\\n\\t  ![image](https://assets.leetcode.com/users/images/04f9a388-d83a-499c-b7bf-2423a0e4833e_1597987466.6122327.png)\\n\\n\\n   ```java\\n   // Like the one-dimensional prefix sum, \\n   // in order to prevent index out of range and facilitate calculations,\\n   // we add an extra column with all 0s at the forefront.\\n   int line = matrix.length;\\n   int column = matrix[0].length + 1;\\n   int[][] sum = new int[line][column]; // Initialization default is all 0\\n           \\n   for (int l = 0; l < sum.length; l++){\\n     // start from the second column\\n     for (int c = 1; c < sum[0].length; c++){\\n       sum[l][c] = sum[l][c - 1] + matrix[l][c - 1]; // \"c - 1\",because of an extra column.\\n     }\\n   }\\n   ```\\n\\n\\t  ![image](https://assets.leetcode.com/users/images/36d2c68a-1682-4e79-9eb2-84f12b4d0677_1597987495.016029.png)\\n\\n\\n   Step 2. Using the prefix sum of each line to calculate the sum of submatrix.\\n\\n   ![image](https://assets.leetcode.com/users/images/bdd7351c-95df-4c5d-be1a-eed32d7c9057_1597987518.405201.png)\\n\\n\\n   ```java\\xA0\\n   sum[1][2] = sum[1][2] + sum[0][2]; // green + orange\\n   ```\\n\\n   ```java\\n   sum[2][2] = sum[2][2] + sum[1][2] + sum[0][2]; // blue + green + orange\\n   ```\\n\\n   So, to caculate any sum of submatrices ***whose upper left corner are matrix[0] [0].***\\n\\n   ```java\\n   int sumOfSubMatrix = 0;\\n   \\n   for(int l = 0; l < line; l++){\\n   \\tsumOfSubMatrix += sum[l][column]; // one of submatrices\\n   }\\n   ```\\n\\n\\n\\n3. How to find all submatrices ?\\n\\n   1. Any submatrix needs any two rows and any two columns to form, that is to say, four variables and four nested loops are required.\\n\\n      ```java\\n      // Use double nested \"for\" loop to select any two columns\\n      for (int start = 0; start < column; start++){\\n                  for (int end = start + 1; end < column; end++ ){\\n                    \\t// ...\\n                    \\t// Then Use double nested \"for\" loop to select any two lines\\n                  \\t}\\n                  }\\n      ```\\n\\n   2. Convert 2D to 1D\\n\\n      Step 1 : Use the ***prefix sum of each row*** to calculate the matrix sum between the \"start\" column and \"end\" column.\\n\\n      ![image](https://assets.leetcode.com/users/images/14f2cef5-3e35-4d80-abfa-184c6c58b3a0_1597986571.6869073.png)\\n\\n\\n      Step 2 : Rotate it 90 degrees to the left, ***it can be regarded as a one-dimensional array.***\\n\\n\\t\\t ![image](https://assets.leetcode.com/users/images/5c6c40f3-55ab-4af5-b090-f0b32c018c9e_1597986584.019118.png)\\n\\n\\n      Then the problem is transformed into how many sub-arrays whose sum == target ?\\n\\n      ***It\\'s the same with >https://leetcode.com/problems/subarray-sum-equals-k/***\\n\\n      Step 3 : In the same way, we can use hashmap to optimize the double nested loop for any two lines, and only need one loop\\n\\n      ```java\\n      int sumOfSubMatrix = 0;\\n      Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n      map.put(0, 1);\\n      \\n      for(int l = 0; l < line; l++){\\n        // prefix sum\\n      \\tsumOfSubMatrix += sum[l][end] - sum[l][start];\\n        \\n      \\tif (map.containsKey(sumOfSubMatrix - target))\\n      \\t\\tcount += map.get(sumOfSubMatrix - target);\\n        \\n      \\tmap.put(sumOfSubMatrix, map.getOrDefault(sumOfSubMatrix, 0) + 1);\\n      ```\\n\\n      \\n\\n      \\n\\n## Code\\n\\n```java\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int count = 0;\\n        int line = matrix.length;\\n        int column = matrix[0].length + 1;\\n        int[][] sum = new int[line][column];\\n        \\n        for (int i = 0; i < sum.length; i++){\\n            for (int j = 1; j < sum[0].length; j++){\\n                sum[i][j] = sum[i][j - 1] + matrix[i][j - 1];\\n            }\\n        }\\n        \\n        \\n        for (int start = 0; start < column; start++){\\n            for (int end = start + 1; end < column; end++ ){\\n                \\n                int sumOfSubMatrix = 0;\\n                Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n                map.put(0, 1);\\n                for(int l = 0; l < line; l++){\\n                    sumOfSubMatrix += sum[l][end] - sum[l][start];\\n                    if (map.containsKey(sumOfSubMatrix - target))\\n                        count += map.get(sumOfSubMatrix - target);\\n                    map.put(sumOfSubMatrix, map.getOrDefault(sumOfSubMatrix, 0) + 1);\\n                    \\n                }\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```\\n\\n\\n\\n## Update\\nFor the commet from jun.\\n1. What\\'s the meaning of this sentence ?\\n+ \"Any submatrix needs any two rows and any two columns to form, that is to say, four variables and four nested loops are required.\" \\n\\n\\teg. |0| is the submatrix I want to find, whose index is [0][0]\\n\\tIn the \"sum\", the column 1 corresponds to column 0 in \"matrix\".  SO we bound the area like this\\n![image](https://assets.leetcode.com/users/images/3637adc2-9111-4232-8ce2-0195bf164e03_1618829866.7781012.png)\\n\\nSince we have done prefix sum for every line, we need to do sum[line][end_column] - sum[line][start_column], and in this case elements in start_column is all 0, when we subtract sum[line][0], It actually did nothing.\\n\\nAlso, since \"end_cloumn\" starts from \"end_cloumn = start_column + 1\", it is impossible to treat the first column of \"sum\" as part of our result.\\n![image](https://assets.leetcode.com/users/images/bef01364-0496-400b-867e-c664f40b084d_1618830124.2679777.png)\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```java\\n   // Like the one-dimensional prefix sum, \\n   // in order to prevent index out of range and facilitate calculations,\\n   // we add an extra column with all 0s at the forefront.\\n   int line = matrix.length;\\n   int column = matrix[0].length + 1;\\n   int[][] sum = new int[line][column]; // Initialization default is all 0\\n           \\n   for (int l = 0; l < sum.length; l++){\\n     // start from the second column\\n     for (int c = 1; c < sum[0].length; c++){\\n       sum[l][c] = sum[l][c - 1] + matrix[l][c - 1]; // \"c - 1\",because of an extra column.\\n     }\\n   }\\n   ```\n```java\\xA0\\n   sum[1][2] = sum[1][2] + sum[0][2]; // green + orange\\n   ```\n```java\\n   sum[2][2] = sum[2][2] + sum[1][2] + sum[0][2]; // blue + green + orange\\n   ```\n```java\\n   int sumOfSubMatrix = 0;\\n   \\n   for(int l = 0; l < line; l++){\\n   \\tsumOfSubMatrix += sum[l][column]; // one of submatrices\\n   }\\n   ```\n```java\\n      // Use double nested \"for\" loop to select any two columns\\n      for (int start = 0; start < column; start++){\\n                  for (int end = start + 1; end < column; end++ ){\\n                    \\t// ...\\n                    \\t// Then Use double nested \"for\" loop to select any two lines\\n                  \\t}\\n                  }\\n      ```\n```java\\n      int sumOfSubMatrix = 0;\\n      Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n      map.put(0, 1);\\n      \\n      for(int l = 0; l < line; l++){\\n        // prefix sum\\n      \\tsumOfSubMatrix += sum[l][end] - sum[l][start];\\n        \\n      \\tif (map.containsKey(sumOfSubMatrix - target))\\n      \\t\\tcount += map.get(sumOfSubMatrix - target);\\n        \\n      \\tmap.put(sumOfSubMatrix, map.getOrDefault(sumOfSubMatrix, 0) + 1);\\n      ```\n```java\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int count = 0;\\n        int line = matrix.length;\\n        int column = matrix[0].length + 1;\\n        int[][] sum = new int[line][column];\\n        \\n        for (int i = 0; i < sum.length; i++){\\n            for (int j = 1; j < sum[0].length; j++){\\n                sum[i][j] = sum[i][j - 1] + matrix[i][j - 1];\\n            }\\n        }\\n        \\n        \\n        for (int start = 0; start < column; start++){\\n            for (int end = start + 1; end < column; end++ ){\\n                \\n                int sumOfSubMatrix = 0;\\n                Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n                map.put(0, 1);\\n                for(int l = 0; l < line; l++){\\n                    sumOfSubMatrix += sum[l][end] - sum[l][start];\\n                    if (map.containsKey(sumOfSubMatrix - target))\\n                        count += map.get(sumOfSubMatrix - target);\\n                    map.put(sumOfSubMatrix, map.getOrDefault(sumOfSubMatrix, 0) + 1);\\n                    \\n                }\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162927,
                "title": "optimization-from-brute-force-to-optimized-solution-w-easy-explanation",
                "content": "There are a few solution mentioned by others but most have directly given the most optimal solution. Here, I will try to start from the brute-force approach and try to explain the various optimizations that can be done to finally arrive at the optimal solution.\\n\\n---\\n\\n\\u274C ***Solution - I (Brute-Force Approach) [Rejected]***\\n\\nLet\\'s start with the most basic approach to this problem. Take all the submatrices possible for the given matrix and check if their sum is equal to `target`.\\n\\n```\\nint numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n\\tint res = 0, m = size(A), n = size(A[0]);\\n\\t// calculate sum of each submatrix and check if it is equal to target\\n\\tfor(int rowStart = 0; rowStart < m; rowStart++)\\n\\t\\tfor(int rowSize = 1; rowStart + rowSize <= m; rowSize++)\\n\\t\\t\\tfor(int colStart = 0; colStart < n; colStart++)\\n\\t\\t\\t\\tfor(int colSize = 1; colStart + colSize <= n; colSize++)\\n\\t\\t\\t\\t\\tif(SUM(A, rowStart, rowSize, colStart, colSize) == target)\\n\\t\\t\\t\\t\\t\\tres++;\\n\\treturn res;    \\n}\\n// Calculates the sum of a submatrix with given bounds\\nint SUM(vector<vector<int> > &A, int rStart, int rSize, int cStart, int cSize){\\n\\tint subMatrixSum = 0;\\n\\tfor(int i = rStart; i < rStart + rSize; i++)\\n\\t\\tfor(int j = cStart; j < cStart + cSize; j++)\\n\\t\\t\\tsubMatrixSum += A[i][j];\\n\\treturn subMatrixSum;\\n}\\n```\\n\\n***Time Complexity :*** **`O((M*N)^3)`**, where `M` is the number of rows and `N` is the number of columns  in the given matrix.\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Compute prefix sum for each Row or Column)***\\n\\nWe can optimize the above approach by reducing the time complexity of the `SUM` function in the above solution. We know that in a given array, the sum of range [i,j] can be calculated by `prefixSum[j] - prefixSum[i - 1]`. We can use this to optimize the solution.\\n\\nAfter computing prefix sum for each row of matrix (*you can do it for column as well*), we can get the sum of a given range in O(1) time. Thus, for any submatrix of the main matrix, we just need to iterate over all its rows and we can get sum of given range (`[colStart, colEnd]`) in O(1) time.\\n\\n1. We just start from row 0, calculate the sum for that row for the range `[colStart, colEnd]`.\\n2. Extend the sum by perform step-1 for row 1, row 2, ... and so on till last row.\\n3. Repeat this process for every `[colStart, colEnd]` combination.\\n\\n\\n```\\nint numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n\\tint res = 0, m = size(A), n = size(A[0]);\\n\\t// calculating prefix sum for each row of matrix\\n\\tfor (int row = 0; row < m; row++)\\n\\t\\tfor (int col = 1; col < n; col++)\\n\\t\\t\\tA[row][col] += A[row][col - 1];\\n\\t// calculate sum of each submatrix and check if it is equal to target\\n\\tfor (int colStart = 0; colStart < n; colStart++) {\\n\\t\\tfor (int colEnd = colStart; colEnd < n; colEnd++) {\\n\\t\\t\\tfor(int rowStart = 0; rowStart < m; rowStart++){\\n\\t\\t\\t\\tint sum = 0;\\n\\t\\t\\t\\tfor(int rowEnd = rowStart; rowEnd < m; rowEnd++){\\n\\t\\t\\t\\t\\tsum += A[rowEnd][colEnd] - (colStart ? A[rowEnd][colStart - 1] : 0);\\n\\t\\t\\t\\t\\tif(sum == target) res++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;    \\n}\\n```\\n***Time Complexity :*** **`O((M*N)^2)`**, where `M` is the number of rows and `N` is the number of columns  in the given matrix.\\n***Space Complexity :*** **`O(1)`**, since we are modifying the given matrix itself. If we use a new prefix sum matrix, the space complexity would be `O(M*N)`.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Further Optimization in Solution - II)***\\n\\nWe can further optimize the solution by using hashmap. The optimization done here is similar to the one in solution of [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/solution/).\\n\\nBasically, we will be maintaining a running submatrix sum starting from row 0 till m, for a given `[colStart, colEnd]` range. Each sum value and number of its occurence will be stored in hashmap. If there\\'s a submatrix which was found such that `cursum` at that time was equal to present sum (`cursum`) - target, then we are sure that there were occurences of submatrices which had sum equal to `target` and the count is given by `mp[cursum - target]`.\\n\\nIf the explanation didn\\'t make the approach clear, I really suggest you to try the *560. Subarray Sum Equals K* problem and read the hashmap solution. It took me some time reading that before I was able to clearly understand this solution.\\n\\n```\\nint numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n\\tint res = 0, m = size(A), n = size(A[0]);\\n\\tfor (int row = 0; row < m; row++)\\n\\t\\tfor (int col = 1; col < n; col++)\\n\\t\\t\\tA[row][col] += A[row][col - 1];\\n\\t//         cursum, occurences\\n\\tunordered_map<int, int> mp;\\n\\tfor (int colStart = 0; colStart < n; colStart++) {\\n\\t\\tfor (int colEnd = colStart; colEnd < n; colEnd++) {\\n\\t\\t\\tint cursum = 0;\\n\\t\\t\\tmp = {{0, 1}};\\n\\t\\t\\tfor(int row = 0; row < m; row++){\\n\\t\\t\\t\\tcursum += A[row][colEnd] - (colStart ? A[row][colStart - 1] : 0);    \\n\\t\\t\\t\\t// mp[sum-target] will give number of submatrices found having sum as \\'sum - target\\'\\n\\t\\t\\t\\tres += mp[cursum - target];\\n\\t\\t\\t\\tmp[cursum]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;    \\n}\\n```\\n***Time Complexity :*** **`O(N*N*M)`**, where `M` is the number of rows and `N` is the number of columns  in the given matrix.\\n***Space Complexity :*** **`O(N)`**\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any questions or mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```\\nint numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n\\tint res = 0, m = size(A), n = size(A[0]);\\n\\t// calculate sum of each submatrix and check if it is equal to target\\n\\tfor(int rowStart = 0; rowStart < m; rowStart++)\\n\\t\\tfor(int rowSize = 1; rowStart + rowSize <= m; rowSize++)\\n\\t\\t\\tfor(int colStart = 0; colStart < n; colStart++)\\n\\t\\t\\t\\tfor(int colSize = 1; colStart + colSize <= n; colSize++)\\n\\t\\t\\t\\t\\tif(SUM(A, rowStart, rowSize, colStart, colSize) == target)\\n\\t\\t\\t\\t\\t\\tres++;\\n\\treturn res;    \\n}\\n// Calculates the sum of a submatrix with given bounds\\nint SUM(vector<vector<int> > &A, int rStart, int rSize, int cStart, int cSize){\\n\\tint subMatrixSum = 0;\\n\\tfor(int i = rStart; i < rStart + rSize; i++)\\n\\t\\tfor(int j = cStart; j < cStart + cSize; j++)\\n\\t\\t\\tsubMatrixSum += A[i][j];\\n\\treturn subMatrixSum;\\n}\\n```\n```\\nint numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n\\tint res = 0, m = size(A), n = size(A[0]);\\n\\t// calculating prefix sum for each row of matrix\\n\\tfor (int row = 0; row < m; row++)\\n\\t\\tfor (int col = 1; col < n; col++)\\n\\t\\t\\tA[row][col] += A[row][col - 1];\\n\\t// calculate sum of each submatrix and check if it is equal to target\\n\\tfor (int colStart = 0; colStart < n; colStart++) {\\n\\t\\tfor (int colEnd = colStart; colEnd < n; colEnd++) {\\n\\t\\t\\tfor(int rowStart = 0; rowStart < m; rowStart++){\\n\\t\\t\\t\\tint sum = 0;\\n\\t\\t\\t\\tfor(int rowEnd = rowStart; rowEnd < m; rowEnd++){\\n\\t\\t\\t\\t\\tsum += A[rowEnd][colEnd] - (colStart ? A[rowEnd][colStart - 1] : 0);\\n\\t\\t\\t\\t\\tif(sum == target) res++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;    \\n}\\n```\n```\\nint numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n\\tint res = 0, m = size(A), n = size(A[0]);\\n\\tfor (int row = 0; row < m; row++)\\n\\t\\tfor (int col = 1; col < n; col++)\\n\\t\\t\\tA[row][col] += A[row][col - 1];\\n\\t//         cursum, occurences\\n\\tunordered_map<int, int> mp;\\n\\tfor (int colStart = 0; colStart < n; colStart++) {\\n\\t\\tfor (int colEnd = colStart; colEnd < n; colEnd++) {\\n\\t\\t\\tint cursum = 0;\\n\\t\\t\\tmp = {{0, 1}};\\n\\t\\t\\tfor(int row = 0; row < m; row++){\\n\\t\\t\\t\\tcursum += A[row][colEnd] - (colStart ? A[row][colStart - 1] : 0);    \\n\\t\\t\\t\\t// mp[sum-target] will give number of submatrices found having sum as \\'sum - target\\'\\n\\t\\t\\t\\tres += mp[cursum - target];\\n\\t\\t\\t\\tmp[cursum]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2298642,
                "title": "fully-explained-intuition-4-solutions-must-read-with-image",
                "content": "Note: that\\'s a long read, but I explained the whole thinking process. It\\'s going to be worth it if you want to learn and not to memorize solutions :)\\n\\nIf you found it helpful, please upvote <3\\n\\n<hr />\\n\\n\\nLet\\'s start with the basics\\n\\nFirst, how do we generate the coordinates for all the submatrices? we need all distinct (x1,y1), (x2,y2) pairs\\n\\nSo it will be something like this:\\n\\n```\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        # Generate all submatrices\\n        for y1 in range(m):\\n            for x1 in range(n):\\n                for y2 in range(y1, m):\\n                    for x2 in range(x1, n):\\n                        print(f\"({x1}, {y1}), ({x2, y2})\")\\n```\\n\\n\\nAnd a brute force would be to count the sum between all pairs of coordinates\\n\\n```\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        ans = 0\\n        \\n        # Generate all submatrices\\n        for y1 in range(m):\\n            for x1 in range(n):\\n                for y2 in range(y1, m):\\n                    for x2 in range(x1, n):\\n                        # We could sum the distance between the coordinates\\n                        total = 0\\n                        for r in range(y1, y2+1):\\n                            for c in range(x1, x2+1):\\n                                total += matrix[r][c]\\n                \\n                        if total == target:\\n                            ans += 1\\n        return ans\\n```\\n\\n\\nObviously that\\'s too bad of a solution with `n^3*m^3`\\n\\n# Improvement\\n\\nIn the last example, we had to iterate from (x1,y1) to (x2,y2) to find the sum.\\n\\nWe can reduce the time complexity for finding the sum to `O(1)` instead of `O(m*n)`, but how?\\n\\nBy using `prefix sums` (or prefix matrices one may say), extending the idea of a prefix sum array\\n\\nLet\\'s look at the image below:\\n\\n\\n**UPDATE**: **the value 8 is calculated as `7+6+(-3)-2`. The image has a mistake in it.. Sorry \\nAll other calculations are fine**\\n**Also the usage of DP in the image is for convenience, it\\'s not a dynamic programming question.**\\n\\n![image](https://assets.leetcode.com/users/images/5de8eaf9-89e4-4dd9-afde-6317934c0aeb_1658129118.454311.png)\\n\\nEvery coordinate (x,y) is the matrix sum between origin `(0,0) and (x,y)`\\n\\nWe can calculate the sum by taking the sum of the matrix above `matrix_sum[row-1][col]`, adding the sum of the matrix behind `matrix_sum[row][col-1]` and removing the intersection, because there is a part that is added twice `matrix_sum[row-1][col-1]`\\n\\nThen to calculate the sum of some `submatrix (x1,y1), (x2,y2)` we need to add the sum of the matrix that ends at the bottom coordinates, and remove the parts which are unused (again there is an intersection, hence we need to add the intersection because it\\'s removed twice)\\n\\n![image](https://assets.leetcode.com/users/images/4dbde7d6-b63f-428c-a8bd-467c5f97b330_1658129404.9013832.png)\\n\\n\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        matrix_sums = [[0 for _ in range(n)] for _ in range(m)]\\n        \\n        # Calculate all the submatrices sum with the transition formula we found\\n        for row in range(m):\\n            for col in range(n):\\n                # first cell\\n                if row == 0 and col == 0:\\n                    matrix_sums[row][col] = matrix[row][col]\\n                # Rows and columns are like prefix sums, without intersection\\n                elif row == 0:\\n                    matrix_sums[row][col] = matrix[row][col] + matrix_sums[row][col-1]\\n                elif col == 0:\\n                    matrix_sums[row][col] = matrix[row][col] + matrix_sums[row-1][col]\\n                \\n                # current sum is the sum of the matrix above, to the left and subtract the intersection\\n                else:\\n                    matrix_sums[row][col] = matrix[row][col] \\\\\\n                    + (matrix_sums[row][col-1]) \\\\\\n                    + (matrix_sums[row-1][col]) \\\\\\n                    - (matrix_sums[row-1][col-1])\\n\\n                \\n        ans = 0\\n        # Generate all submatrices\\n        for y1 in range(m):\\n            for x1 in range(n):\\n                for y2 in range(y1, m):\\n                    for x2 in range(x1, n):\\n                        # calculate sum in O(1)\\n                        submatrix_total = matrix_sums[y2][x2] \\\\\\n                        - (matrix_sums[y2][x1-1] if x1-1 >= 0 else 0) \\\\\\n                        - (matrix_sums[y1-1][x2] if y1-1 >= 0 else 0) \\\\\\n                        + (matrix_sums[y1-1][x1-1] if y1-1 >= 0 and x1-1 >= 0 else 0)\\n                        \\n                        if submatrix_total == target:\\n                            ans += 1\\n        return ans\\n```\\n\\n# Do we really need 2 separate iterations?\\nWe can inverse the order of iterations, to build the prefix matrix and calculate in one go\\n\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        matrix_sums = [[0 for _ in range(n)] for _ in range(m)]\\n        \\n        ans = 0\\n        # Generate all submatrices\\n        for y1 in range(m):\\n            for x1 in range(n):\\n                # Calculate matrix_sums\\n                # first cell\\n                if y1 == 0 and x1 == 0:\\n                    matrix_sums[y1][x1] = matrix[y1][x1]\\n                # Rows and columns are like prefix sums, without intersection\\n                elif y1 == 0:\\n                    matrix_sums[y1][x1] = matrix[y1][x1] + matrix_sums[y1][x1-1]\\n                elif x1 == 0:\\n                    matrix_sums[y1][x1] = matrix[y1][x1] + matrix_sums[y1-1][x1]\\n                \\n                # current sum is the sum of the matrix above, to the left and subtract the intersection\\n                else:\\n                    matrix_sums[y1][x1] = matrix[y1][x1] \\\\\\n                    + (matrix_sums[y1][x1-1]) \\\\\\n                    + (matrix_sums[y1-1][x1]) \\\\\\n                    - (matrix_sums[y1-1][x1-1])\\n                \\n                for y2 in range(y1 + 1):\\n                    for x2 in range(x1 + 1):\\n                        submatrix_total = matrix_sums[y1][x1] \\\\\\n                        - (matrix_sums[y1][x2-1] if x2-1 >= 0 else 0) \\\\\\n                        - (matrix_sums[y2-1][x1] if y2-1 >= 0 else 0) \\\\\\n                        + (matrix_sums[y2-1][x2-1] if y2-1 >= 0 and x2-1 >= 0 else 0)\\n                        \\n                        if submatrix_total == target:\\n                            ans += 1\\n        return ans\\n```\\n\\n\\n# But wait...\\nWe can optimize even more!\\n\\nWe have time complexity of `m^2*n^2` but do we really need the `n^2` ?\\n\\nInstead, it\\'s enough to simply \"fix\" the vertical coordinates y1, y2 and let x iterate\\n\\nThis way, we can reduce the problem into **subarray sum equal to target** (1D problem)\\n\\nFinal complexity: `O(m^2*n)`\\n\\n# Code\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        matrix_sums = [[0 for _ in range(n)] for _ in range(m)]\\n        \\n        # Calculate all the submatrices sum with the transition formula we found\\n        for row in range(m):\\n            for col in range(n):\\n                # first cell\\n                if row == 0 and col == 0:\\n                    matrix_sums[row][col] = matrix[row][col]\\n                # Rows and columns are like prefix sums, without intersection\\n                elif row == 0:\\n                    matrix_sums[row][col] = matrix[row][col] + matrix_sums[row][col-1]\\n                elif col == 0:\\n                    matrix_sums[row][col] = matrix[row][col] + matrix_sums[row-1][col]\\n                \\n                # current sum is the sum of the matrix above, to the left and subtract the intersection\\n                else:\\n                    matrix_sums[row][col] = matrix[row][col] \\\\\\n                    + (matrix_sums[row][col-1]) \\\\\\n                    + (matrix_sums[row-1][col]) \\\\\\n                    - (matrix_sums[row-1][col-1])\\n\\n                \\n        ans = 0\\n        for y1 in range(m):\\n            for y2 in range(y1, m):\\n                # Reduce the problem to subarray sum of target\\n                subarray_sums = defaultdict(int)\\n                subarray_sums[0] = 1\\n                \\n                for x in range(n):\\n                    matrix_sum = matrix_sums[y2][x]\\n                    \\n                    # Remove to matrix sum above y1\\n                    if y1 > 0:\\n                        matrix_sum -= matrix_sums[y1-1][x]\\n                        \\n                    if matrix_sum - target in subarray_sums:\\n                        ans += subarray_sums[matrix_sum - target]\\n                    \\n                    subarray_sums[matrix_sum] += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        # Generate all submatrices\\n        for y1 in range(m):\\n            for x1 in range(n):\\n                for y2 in range(y1, m):\\n                    for x2 in range(x1, n):\\n                        print(f\"({x1}, {y1}), ({x2, y2})\")\\n```\n```\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        ans = 0\\n        \\n        # Generate all submatrices\\n        for y1 in range(m):\\n            for x1 in range(n):\\n                for y2 in range(y1, m):\\n                    for x2 in range(x1, n):\\n                        # We could sum the distance between the coordinates\\n                        total = 0\\n                        for r in range(y1, y2+1):\\n                            for c in range(x1, x2+1):\\n                                total += matrix[r][c]\\n                \\n                        if total == target:\\n                            ans += 1\\n        return ans\\n```\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        matrix_sums = [[0 for _ in range(n)] for _ in range(m)]\\n        \\n        # Calculate all the submatrices sum with the transition formula we found\\n        for row in range(m):\\n            for col in range(n):\\n                # first cell\\n                if row == 0 and col == 0:\\n                    matrix_sums[row][col] = matrix[row][col]\\n                # Rows and columns are like prefix sums, without intersection\\n                elif row == 0:\\n                    matrix_sums[row][col] = matrix[row][col] + matrix_sums[row][col-1]\\n                elif col == 0:\\n                    matrix_sums[row][col] = matrix[row][col] + matrix_sums[row-1][col]\\n                \\n                # current sum is the sum of the matrix above, to the left and subtract the intersection\\n                else:\\n                    matrix_sums[row][col] = matrix[row][col] \\\\\\n                    + (matrix_sums[row][col-1]) \\\\\\n                    + (matrix_sums[row-1][col]) \\\\\\n                    - (matrix_sums[row-1][col-1])\\n\\n                \\n        ans = 0\\n        # Generate all submatrices\\n        for y1 in range(m):\\n            for x1 in range(n):\\n                for y2 in range(y1, m):\\n                    for x2 in range(x1, n):\\n                        # calculate sum in O(1)\\n                        submatrix_total = matrix_sums[y2][x2] \\\\\\n                        - (matrix_sums[y2][x1-1] if x1-1 >= 0 else 0) \\\\\\n                        - (matrix_sums[y1-1][x2] if y1-1 >= 0 else 0) \\\\\\n                        + (matrix_sums[y1-1][x1-1] if y1-1 >= 0 and x1-1 >= 0 else 0)\\n                        \\n                        if submatrix_total == target:\\n                            ans += 1\\n        return ans\\n```\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        matrix_sums = [[0 for _ in range(n)] for _ in range(m)]\\n        \\n        ans = 0\\n        # Generate all submatrices\\n        for y1 in range(m):\\n            for x1 in range(n):\\n                # Calculate matrix_sums\\n                # first cell\\n                if y1 == 0 and x1 == 0:\\n                    matrix_sums[y1][x1] = matrix[y1][x1]\\n                # Rows and columns are like prefix sums, without intersection\\n                elif y1 == 0:\\n                    matrix_sums[y1][x1] = matrix[y1][x1] + matrix_sums[y1][x1-1]\\n                elif x1 == 0:\\n                    matrix_sums[y1][x1] = matrix[y1][x1] + matrix_sums[y1-1][x1]\\n                \\n                # current sum is the sum of the matrix above, to the left and subtract the intersection\\n                else:\\n                    matrix_sums[y1][x1] = matrix[y1][x1] \\\\\\n                    + (matrix_sums[y1][x1-1]) \\\\\\n                    + (matrix_sums[y1-1][x1]) \\\\\\n                    - (matrix_sums[y1-1][x1-1])\\n                \\n                for y2 in range(y1 + 1):\\n                    for x2 in range(x1 + 1):\\n                        submatrix_total = matrix_sums[y1][x1] \\\\\\n                        - (matrix_sums[y1][x2-1] if x2-1 >= 0 else 0) \\\\\\n                        - (matrix_sums[y2-1][x1] if y2-1 >= 0 else 0) \\\\\\n                        + (matrix_sums[y2-1][x2-1] if y2-1 >= 0 and x2-1 >= 0 else 0)\\n                        \\n                        if submatrix_total == target:\\n                            ans += 1\\n        return ans\\n```\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        matrix_sums = [[0 for _ in range(n)] for _ in range(m)]\\n        \\n        # Calculate all the submatrices sum with the transition formula we found\\n        for row in range(m):\\n            for col in range(n):\\n                # first cell\\n                if row == 0 and col == 0:\\n                    matrix_sums[row][col] = matrix[row][col]\\n                # Rows and columns are like prefix sums, without intersection\\n                elif row == 0:\\n                    matrix_sums[row][col] = matrix[row][col] + matrix_sums[row][col-1]\\n                elif col == 0:\\n                    matrix_sums[row][col] = matrix[row][col] + matrix_sums[row-1][col]\\n                \\n                # current sum is the sum of the matrix above, to the left and subtract the intersection\\n                else:\\n                    matrix_sums[row][col] = matrix[row][col] \\\\\\n                    + (matrix_sums[row][col-1]) \\\\\\n                    + (matrix_sums[row-1][col]) \\\\\\n                    - (matrix_sums[row-1][col-1])\\n\\n                \\n        ans = 0\\n        for y1 in range(m):\\n            for y2 in range(y1, m):\\n                # Reduce the problem to subarray sum of target\\n                subarray_sums = defaultdict(int)\\n                subarray_sums[0] = 1\\n                \\n                for x in range(n):\\n                    matrix_sum = matrix_sums[y2][x]\\n                    \\n                    # Remove to matrix sum above y1\\n                    if y1 > 0:\\n                        matrix_sum -= matrix_sums[y1-1][x]\\n                        \\n                    if matrix_sum - target in subarray_sums:\\n                        ans += subarray_sums[matrix_sum - target]\\n                    \\n                    subarray_sums[matrix_sum] += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 344440,
                "title": "simple-python-dp-solution",
                "content": "Please see and vote for my solution for these similar problems.\\n[560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/discuss/344431/Simple-Python-DP-solution)\\n[974. Subarray Sums Divisible by K](https://leetcode.com/problems/subarray-sums-divisible-by-k/discuss/344436/Simple-Python-DP-solution)\\n[325. Maximum Size Subarray Sum Equals k](https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/discuss/344432/Simple-Python-DP-solution)\\n[1074. Number of Submatrices That Sum to Target](https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/discuss/344440/Simple-Python-DP-solution)\\n[363. Max Sum of Rectangle No Larger Than K](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/discuss/445540/Python-bisect-solution-(960ms-beat-71.25))\\n\\nFor each row, calculate the prefix sum. For each pair of columns, calculate the sum of rows. \\nNow this problem is changed to problem 560 Subarray Sum Equals K.\\n```\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        for x in range(m):\\n            for y in range(n - 1):\\n                matrix[x][y+1] += matrix[x][y]\\n        res = 0\\n        for y1 in range(n):\\n            for y2 in range(y1, n):\\n                preSums = {0: 1}\\n                s = 0\\n                for x in range(m):\\n                    s += matrix[x][y2] - (matrix[x][y1-1] if y1 > 0 else 0)\\n                    res += preSums.get(s - target, 0)\\n                    preSums[s] = preSums.get(s, 0) + 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        for x in range(m):\\n            for y in range(n - 1):\\n                matrix[x][y+1] += matrix[x][y]\\n        res = 0\\n        for y1 in range(n):\\n            for y2 in range(y1, n):\\n                preSums = {0: 1}\\n                s = 0\\n                for x in range(m):\\n                    s += matrix[x][y2] - (matrix[x][y1-1] if y1 > 0 else 0)\\n                    res += preSums.get(s - target, 0)\\n                    preSums[s] = preSums.get(s, 0) + 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 303767,
                "title": "java-reduce-to-1d-array",
                "content": "Similar to [\"Max Sum of Rectangle No Larger Than K\"](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/), reduce 2D array to 1D, and find the sub-array sum targeting k.\\n\\n```\\npublic int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[] array = new int[m];\\n        int result = 0;\\n        for(int i = 0; i < n; i++) { //i is the starting column\\n            Arrays.fill(array, 0);\\n            for(int j = i; j < n; j++) { //j is the ending column\\n                for(int k = 0; k < m; k++) {\\n                    array[k] += matrix[k][j];\\n                }\\n                result += subarraySum(array, target);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public int subarraySum(int[] nums, int k) {\\n        int sum = 0, result = 0;\\n        Map<Integer, Integer> preSum = new HashMap<>();\\n        preSum.put(0, 1);\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            if (preSum.containsKey(sum - k)) {\\n                result += preSum.get(sum - k);\\n            }\\n            preSum.put(sum, preSum.getOrDefault(sum, 0) + 1);\\n        }\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[] array = new int[m];\\n        int result = 0;\\n        for(int i = 0; i < n; i++) { //i is the starting column\\n            Arrays.fill(array, 0);\\n            for(int j = i; j < n; j++) { //j is the ending column\\n                for(int k = 0; k < m; k++) {\\n                    array[k] += matrix[k][j];\\n                }\\n                result += subarraySum(array, target);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public int subarraySum(int[] nums, int k) {\\n        int sum = 0, result = 0;\\n        Map<Integer, Integer> preSum = new HashMap<>();\\n        preSum.put(0, 1);\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            if (preSum.containsKey(sum - k)) {\\n                result += preSum.get(sum - k);\\n            }\\n            preSum.put(sum, preSum.getOrDefault(sum, 0) + 1);\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1162748,
                "title": "c-easy-solution-with-explanation",
                "content": "**Intution :**\\n* We need to apply same logic which we used in : **[Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)**. If you have not done this pls check it out first .\\n* Calculate prefix sum for each row.\\n* Calculate  sum for each column and check if **sum - target** is there in the DS or not .If it is there then add the count. (DS is data structure , in this question we will use **`unordered_map<int,int> counter`**)\\n\\t\\t** Why sum - target ? Because if sum - target is there in the DS it means that there is a subset whose sum == target.\\n\\t\\tExample :   target = 4 \\n\\t\\t***1***  *1  1*  1 \\n\\t\\t***1***  *1  1*  1 \\n\\t\\tsum of bold = 2 , sum of bold + Italic = 6 ,,, 6 - 4 = **2** , it means the italic sub matrix sum = target.\\n\\n\\n**Example** : 4 * 4 matrix , target = 4,\\n```\\n1 1 1 1\\n1 1 1 1\\n1 1 1 1\\n1 1 1 1\\n```\\n**1. Calculate prefix sum for each row ;**\\n\\n```\\n1 2 3 4\\n1 2 3 4\\n1 2 3 4\\n1 2 3 4\\n```\\n\\n**2. For every possible range between two columns, accumulate the prefix sum of submartrixes that can be formed between these two columns by adding up the sum of values between these two columns for every row.**\\n\\nFor first column  :\\n![image](https://assets.leetcode.com/users/images/01ff2db8-d070-445b-b67a-d074f1d454ab_1618661347.535767.png)\\n\\n\\n```\\nSum = 1 + 1 + 1 + 1 =4\\nsum - target =  0 , which is there in map so count will be increased by 1.\\n```\\n\\nFor second column  :\\n![image](https://assets.leetcode.com/users/images/c4b0a598-85e5-40cd-8c32-7eeb643bec5b_1618661383.5533128.png)\\n\\n\\nHere   when row = 1 ,  2 - target is not there in the DS so we will add  2 into DS with count 1,  **sum = 2**     `DS : {{0 , 1 } , {2 , 1}`\\nwhen row = 2  , **sum = 4** 4 - target is there so increase count. `DS : {{0 , 1 } , {2 , 1} , { 4 ,1}`\\nwhen row = 3  , **sum = 6** 6 - target = 2, which is there in DS so increase count.`DS : {{0 , 1 } , {2 , 1} , { 4 ,1} ,{6,1}`\\nwhen row = 4 , **sum = 8** 8 - target = 4 , which is there in DS so increase count. `DS : {{0 , 1 } , {2 , 1} , { 4 ,1} ,{6,1}, {8,1}`\\n\\n**In this way for each column we will get number of sub matrixes whose sum is equals to target. Like wise we will do this for all the columns . Now the problem is in this way we are missing some  sub matrixes**\\n![image](https://assets.leetcode.com/users/images/bc2d358c-f1ad-463d-9f10-87e0e0c1fb9c_1618662144.7394516.png)\\n\\nAs you can see in the image for column 2 we have considered 3 sub matrixes :\\n1. Yellow 1\\'s\\n2. boxes with color inside it.\\n3. Red border color boxes. so **what we missed ?????**\\n![image](https://assets.leetcode.com/users/images/a010166e-ffcd-4ad9-95b4-77240850a0f4_1618662409.24798.png)\\n**We missed the 1\\'s in green box. So to count those sub matrixes  we need to subtract  previous column sum. For this third loop is there which checks if column start is greater than 0  then subtract the sum of previous column and sum.**\\n\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size() , cols = matrix[0].size();\\n        \\n        if(rows < 1){\\n            return 0;\\n        }\\n        \\n        // calculate prefix sum for rows\\n        for(int row = 0 ; row < rows ; row++){\\n            for(int col = 1 ; col < cols ;col++){\\n                matrix[row][col] =  matrix[row][col] + matrix[row][col -1];\\n            }\\n        }\\n      \\n        int count = 0 , sum ;\\n        unordered_map<int , int> counter;\\n        for(int colstart = 0 ; colstart < cols ;colstart++){\\n            for(int col = colstart ; col < cols; col++){\\n                counter.clear();\\n                counter[0] = 1;\\n                sum =0;\\n                for(int row = 0 ; row < rows ;row++){\\n                    sum += matrix[row][col] - (colstart > 0 ? matrix[row][colstart - 1] : 0 );\\n                    count += (counter.find(sum- target) != counter.end() ? counter[sum-target] : 0);\\n                    counter[sum]++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n***Time Complexity   :  O(row * column^2)\\nSpace Complexity :O(N)***\\n\\n**Update 18/04/2021 :**\\n\\nIncase anyone else is having same doubt : \\n![image](https://assets.leetcode.com/users/images/11c39b8e-da66-438b-8d50-bb8ac7f23b00_1618745215.816512.png)\\n\\n**Hello,\\n\\tFeel free to comment for doubts . I will love to clear them . If something is wrong please let me know in comment section.\\nThanks !! Happy Coding.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n1 1 1 1\\n1 1 1 1\\n1 1 1 1\\n1 1 1 1\\n```\n```\\n1 2 3 4\\n1 2 3 4\\n1 2 3 4\\n1 2 3 4\\n```\n```\\nSum = 1 + 1 + 1 + 1 =4\\nsum - target =  0 , which is there in map so count will be increased by 1.\\n```\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size() , cols = matrix[0].size();\\n        \\n        if(rows < 1){\\n            return 0;\\n        }\\n        \\n        // calculate prefix sum for rows\\n        for(int row = 0 ; row < rows ; row++){\\n            for(int col = 1 ; col < cols ;col++){\\n                matrix[row][col] =  matrix[row][col] + matrix[row][col -1];\\n            }\\n        }\\n      \\n        int count = 0 , sum ;\\n        unordered_map<int , int> counter;\\n        for(int colstart = 0 ; colstart < cols ;colstart++){\\n            for(int col = colstart ; col < cols; col++){\\n                counter.clear();\\n                counter[0] = 1;\\n                sum =0;\\n                for(int row = 0 ; row < rows ;row++){\\n                    sum += matrix[row][col] - (colstart > 0 ? matrix[row][colstart - 1] : 0 );\\n                    count += (counter.find(sum- target) != counter.end() ? counter[sum-target] : 0);\\n                    counter[sum]++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162767,
                "title": "js-python-java-c-short-prefix-sum-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThis problem is essentially a **2-dimensional** version of [**#560. Subarray Sum Equals K (S.S.E.K)**](https://leetcode.com/problems/subarray-sum-equals-k/description/). By using a **prefix sum** on each row or each column, we can compress this problem down to either **N^2** iterations of the **O(M)** SSEK, or **M^2** iterations of the **O(N)** SSEK.\\n\\nIn the SSEK solution, we can find the number of subarrays with the target sum by utilizing a **result map** (**res**) to store the different values found as we iterate through the array while keeping a running sum (**csum**). Just as in the case with a prefix sum array, the sum of a subarray between **i** and **j** is equal to the sum of the subarray from **0** to **j** minus the sum of the subarray from **0** to **i-1**.\\n\\nRather than iteratively checking if **sum[0,j] - sum[0,i-1] = T** for every pair of **i, j** values, we can flip it around to **sum[0,j] - T = sum[0,i-1]** and since every earlier sum value has been stored in **res**, we can simply perform a lookup on **sum[0,j] - T** to see if there are any matches.\\n\\nWhen extrapolating this solution to our **2-dimensional** matrix (**M**), we will need to first prefix sum the rows or columns, (which we can do **in-place** to avoid extra space, as we will not need the original values again). Then we should iterate through **M** again in the opposite order of rows/columns where the prefix sums will allow us to treat a group of columns or rows as if it were a **1-dimensional** array and apply the SSEK algorithm.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython, oddly, has _much_ better performance with the use of a simple **dict** instead of a **defaultdict** for **res** (Thanks, [@slcheungcasado](https://leetcode.com/slcheungcasado)!)\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **232ms / 44.8MB** (beats 100% / 81%).\\n```javascript\\nvar numSubmatrixSumTarget = function(M, T) {\\n    let xlen = M[0].length, ylen = M.length,\\n        ans = 0, res = new Map(), csum\\n    for (let i = 0, r = M[0]; i < ylen; r = M[++i]) \\n        for (let j = 1; j < xlen; j++)\\n            r[j] += r[j-1]\\n    for (let j = 0; j < xlen; j++)\\n        for (let k = j; k < xlen; k++) {\\n            res.clear(), res.set(0,1), csum = 0\\n            for (let i = 0; i < ylen; i++) {\\n                csum += M[i][k] - (j ? M[i][j-1] : 0)\\n                ans += (res.get(csum - T) || 0)\\n                res.set(csum, (res.get(csum) || 0) + 1)\\n            }\\n        }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **552ms / 15.0MB** (beats 100% / 85%).\\n```python\\nclass Solution:\\n    def numSubmatrixSumTarget(self, M: List[List[int]], T: int) -> int:\\n        xlen, ylen, ans = len(M[0]), len(M), 0\\n        for r in M:\\n            for j in range(1, xlen):\\n                r[j] += r[j-1]\\n        for j in range(xlen):\\n            for k in range(j, xlen):\\n                res, csum = {0: 1}, 0\\n                for r in M:\\n                    csum += r[k] - (r[j-1] if j else 0)\\n                    if csum - T in res: ans += res[csum-T]\\n                    res[csum] = res[csum] + 1 if csum in res else 1  \\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **81ms / 39.3MB** (beats 96% / 95%).\\n```java\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] M, int T) {\\n        int xlen = M[0].length, ylen = M.length, ans = 0;\\n        Map<Integer, Integer> res = new HashMap<>();\\n        for (int[] r : M)\\n            for (int j = 1; j < xlen; j++)\\n                r[j] += r[j-1];\\n        for (int j = 0; j < xlen; j++)\\n            for (int k = j; k < xlen; k++) {\\n                res.clear();\\n                res.put(0,1);\\n                int csum = 0;\\n                for (int i = 0; i < ylen; i++) {\\n                    csum += M[i][k] - (j > 0 ? M[i][j-1] : 0);\\n                    ans += res.getOrDefault(csum - T, 0);\\n                    res.put(csum, res.getOrDefault(csum, 0) + 1);\\n                }\\n            }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **484ms / 95.3MB** (beats 96% / 76%).\\n```c++\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& M, int T) {\\n        int xlen = M[0].size(), ylen = M.size(), ans = 0;\\n        unordered_map<int, int> res;\\n        for (int i = 0; i < ylen; i++)\\n            for (int j = 1; j < xlen; j++)\\n                M[i][j] += M[i][j-1];\\n        for (int j = 0; j < xlen; j++)\\n            for (int k = j; k < xlen; k++) {\\n                res.clear();\\n                res[0] = 1;\\n                int csum = 0;\\n                for (int i = 0; i < ylen; i++) {\\n                    csum += M[i][k] - (j ? M[i][j-1] : 0);\\n                    ans += res.find(csum - T) != res.end() ? res[csum - T] : 0;\\n                    res[csum]++;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar numSubmatrixSumTarget = function(M, T) {\\n    let xlen = M[0].length, ylen = M.length,\\n        ans = 0, res = new Map(), csum\\n    for (let i = 0, r = M[0]; i < ylen; r = M[++i]) \\n        for (let j = 1; j < xlen; j++)\\n            r[j] += r[j-1]\\n    for (let j = 0; j < xlen; j++)\\n        for (let k = j; k < xlen; k++) {\\n            res.clear(), res.set(0,1), csum = 0\\n            for (let i = 0; i < ylen; i++) {\\n                csum += M[i][k] - (j ? M[i][j-1] : 0)\\n                ans += (res.get(csum - T) || 0)\\n                res.set(csum, (res.get(csum) || 0) + 1)\\n            }\\n        }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def numSubmatrixSumTarget(self, M: List[List[int]], T: int) -> int:\\n        xlen, ylen, ans = len(M[0]), len(M), 0\\n        for r in M:\\n            for j in range(1, xlen):\\n                r[j] += r[j-1]\\n        for j in range(xlen):\\n            for k in range(j, xlen):\\n                res, csum = {0: 1}, 0\\n                for r in M:\\n                    csum += r[k] - (r[j-1] if j else 0)\\n                    if csum - T in res: ans += res[csum-T]\\n                    res[csum] = res[csum] + 1 if csum in res else 1  \\n        return ans\\n```\n```java\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] M, int T) {\\n        int xlen = M[0].length, ylen = M.length, ans = 0;\\n        Map<Integer, Integer> res = new HashMap<>();\\n        for (int[] r : M)\\n            for (int j = 1; j < xlen; j++)\\n                r[j] += r[j-1];\\n        for (int j = 0; j < xlen; j++)\\n            for (int k = j; k < xlen; k++) {\\n                res.clear();\\n                res.put(0,1);\\n                int csum = 0;\\n                for (int i = 0; i < ylen; i++) {\\n                    csum += M[i][k] - (j > 0 ? M[i][j-1] : 0);\\n                    ans += res.getOrDefault(csum - T, 0);\\n                    res.put(csum, res.getOrDefault(csum, 0) + 1);\\n                }\\n            }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& M, int T) {\\n        int xlen = M[0].size(), ylen = M.size(), ans = 0;\\n        unordered_map<int, int> res;\\n        for (int i = 0; i < ylen; i++)\\n            for (int j = 1; j < xlen; j++)\\n                M[i][j] += M[i][j-1];\\n        for (int j = 0; j < xlen; j++)\\n            for (int k = j; k < xlen; k++) {\\n                res.clear();\\n                res[0] = 1;\\n                int csum = 0;\\n                for (int i = 0; i < ylen; i++) {\\n                    csum += M[i][k] - (j ? M[i][j-1] : 0);\\n                    ans += res.find(csum - T) != res.end() ? res[csum - T] : 0;\\n                    res[csum]++;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162611,
                "title": "python-cumulative-sum-dp-explained",
                "content": "Let us define by `dp[i, j, k]` sum of numbers in the rectangle `i <= x < j` and `0 <= y < m`. Why it is enough to evaluate only values on these matrices? Because then we can use **2Sum** problem: any sum of elements in submatrix with coordinates `a <= x < b` and `c <= y < d` can be evaluated as difference between sum of `a <= x < b, 0 <= y < d` and sum of `a <= x < b, 0 <= y < c`. So, let us fix `a` and `b`, and say we have sums `S1, S2, ... Sm`.  Then we want to find how many differences between these values give us our `target`. The idea is to calculate cumulative sums and keep counter of values, and then check how many we have (we can not use sliding window, because we can have negative values), see problem **560**. Subarray Sum Equals K for more details.\\n\\nSo, we have in total two stages of our algorithm:\\n1. Precompute all sums in rectangles of the type `i <= x < j` and `0 <= y < m`.\\n2. For each `n*(n-1)/2` problems with fixed `i` and `j`, solve sumproblem in `O(m)` time.\\n\\n#### Complexity\\nTime complexity is `O(n^2m)`, we need it for both stages. Space complexity is the same.\\n\\n#### Code\\n\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix, target):\\n        m, n = len(matrix), len(matrix[0])\\n        dp, ans = {}, 0\\n        for k in range(m):\\n            t = [0] + list(accumulate(matrix[k]))\\n            for i, j in combinations(range(n+1), 2):\\n                dp[i, j, k] = dp.get((i,j,k-1), 0) + t[j] - t[i]\\n        \\n        for i, j in combinations(range(n+1), 2):\\n            T = Counter([0])\\n            for k in range(m):\\n                ans += T[dp[i, j, k] - target]\\n                T[dp[i, j, k]] += 1\\n                \\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix, target):\\n        m, n = len(matrix), len(matrix[0])\\n        dp, ans = {}, 0\\n        for k in range(m):\\n            t = [0] + list(accumulate(matrix[k]))\\n            for i, j in combinations(range(n+1), 2):\\n                dp[i, j, k] = dp.get((i,j,k-1), 0) + t[j] - t[i]\\n        \\n        for i, j in combinations(range(n+1), 2):\\n            T = Counter([0])\\n            for k in range(m):\\n                ans += T[dp[i, j, k] - target]\\n                T[dp[i, j, k]] += 1\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297590,
                "title": "java-easy-to-understand-heavily-commented-detailed-explanation-with-pictures",
                "content": "Region(Answer)\\n![image](https://assets.leetcode.com/users/images/d00849a5-cb20-4edc-aead-5a6a459a9d13_1658113975.539614.png)\\nSo we first need the sum from each of the following regions:\\n1. Region(A)\\n\\t![image](https://assets.leetcode.com/users/images/ec4d1b9e-b2fb-414f-a710-6edab00ee3b7_1658113980.4055543.png)\\n2. Region(B)\\n\\t![image](https://assets.leetcode.com/users/images/e9c0952f-4c70-4d2c-b051-3ce1ada0d650_1658113989.4605181.png)\\n3. Region(C)\\n   ![image](https://assets.leetcode.com/users/images/add5a19c-d4df-494a-8f1a-003700980546_1658113998.129529.png)\\n4. Region(D)\\n   ![image](https://assets.leetcode.com/users/images/3ce884fc-fb99-4907-a1aa-3a341394a064_1658114008.1346068.png)\\nRegion(Answer) = Region(A) - Region(B) - Region(C) + Region(D)\\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        \\n\\t\\t// aux[i][j] is the sum of sub-matrix which start at [0][0] and end in [i][j]\\n        int[][] aux = new int[m + 1][n + 1]; // padding on top and left\\n        for (int i = 1; i < m + 1; i++) {\\n            for (int j = 1; j < n + 1; j++) {\\n\\t\\t\\t\\t// draw a picture, you will understand it easily~\\n                aux[i][j] = matrix[i - 1][j - 1] + aux[i - 1][j] + aux[i][j - 1] - aux[i - 1][j - 1]; \\n            }\\n        }\\n        \\n        int res = 0;\\n\\t\\t// try each sub-matrix\\n        for (int x1 = 1; x1 < m + 1; x1++) {\\n            for (int y1 = 1; y1 < n + 1; y1++) {\\n                for (int x2 = x1; x2 < m + 1; x2++) {\\n                    for (int y2 = y1; y2 < n + 1; y2++) {\\n                        if (target == aux[x2][y2] - aux[x2][y1 - 1] - aux[x1 - 1][y2] + aux[x1 - 1][y1 - 1])\\n                            res++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\nPlease vote if it helps\\uD83D\\uDE06~",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        \\n\\t\\t// aux[i][j] is the sum of sub-matrix which start at [0][0] and end in [i][j]\\n        int[][] aux = new int[m + 1][n + 1]; // padding on top and left\\n        for (int i = 1; i < m + 1; i++) {\\n            for (int j = 1; j < n + 1; j++) {\\n\\t\\t\\t\\t// draw a picture, you will understand it easily~\\n                aux[i][j] = matrix[i - 1][j - 1] + aux[i - 1][j] + aux[i][j - 1] - aux[i - 1][j - 1]; \\n            }\\n        }\\n        \\n        int res = 0;\\n\\t\\t// try each sub-matrix\\n        for (int x1 = 1; x1 < m + 1; x1++) {\\n            for (int y1 = 1; y1 < n + 1; y1++) {\\n                for (int x2 = x1; x2 < m + 1; x2++) {\\n                    for (int y2 = y1; y2 < n + 1; y2++) {\\n                        if (target == aux[x2][y2] - aux[x2][y1 - 1] - aux[x1 - 1][y2] + aux[x1 - 1][y1 - 1])\\n                            res++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521463,
                "title": "java-n-4-and-n-3-solutions",
                "content": "**Solution 1: N^4 ~ 4500ms**\\n```java\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length, n = matrix[0].length;\\n        int[][] sum = new int[m + 1][n + 1];\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + matrix[i - 1][j - 1];\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                for (int u = i + 1; u <= m; u++) {\\n                    for (int v = j + 1; v <= n; v++) {\\n                        int _sum = sum[u][v] - sum[i][v] - sum[u][j] + sum[i][j];\\n                        if (_sum == target) {\\n                            ans++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O((m*n)^2)`\\n- Space: `O(m*n)`\\n\\n**Solution 2 - N^3 ~ 1000ms**\\n```java\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length, n = matrix[0].length;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                matrix[i][j] += matrix[i][j - 1];\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                HashMap<Integer, Integer> map = new HashMap<>();\\n                map.put(0, 1);\\n                int right = 0;\\n                for (int k = 0; k < m; k++) {\\n                    right += matrix[k][j] - (i == 0 ? 0 : matrix[k][i - 1]);\\n                    int left = right - target;\\n                    ans += map.getOrDefault(left, 0);\\n                    map.put(right, map.getOrDefault(right, 0) + 1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(n*n*m)`\\n- Space: `O(m)` for map",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length, n = matrix[0].length;\\n        int[][] sum = new int[m + 1][n + 1];\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + matrix[i - 1][j - 1];\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                for (int u = i + 1; u <= m; u++) {\\n                    for (int v = j + 1; v <= n; v++) {\\n                        int _sum = sum[u][v] - sum[i][v] - sum[u][j] + sum[i][j];\\n                        if (_sum == target) {\\n                            ans++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length, n = matrix[0].length;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                matrix[i][j] += matrix[i][j - 1];\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                HashMap<Integer, Integer> map = new HashMap<>();\\n                map.put(0, 1);\\n                int right = 0;\\n                for (int k = 0; k < m; k++) {\\n                    right += matrix[k][j] - (i == 0 ? 0 : matrix[k][i - 1]);\\n                    int left = right - target;\\n                    ans += map.getOrDefault(left, 0);\\n                    map.put(right, map.getOrDefault(right, 0) + 1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162768,
                "title": "number-of-submatrices-that-sum-to-target-js-python-java-c-short-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThis problem is essentially a **2-dimensional** version of [**#560. Subarray Sum Equals K (S.S.E.K)**](https://leetcode.com/problems/subarray-sum-equals-k/description/). By using a **prefix sum** on each row or each column, we can compress this problem down to either **N^2** iterations of the **O(M)** SSEK, or **M^2** iterations of the **O(N)** SSEK.\\n\\nIn the SSEK solution, we can find the number of subarrays with the target sum by utilizing a **result map** (**res**) to store the different values found as we iterate through the array while keeping a running sum (**csum**). Just as in the case with a prefix sum array, the sum of a subarray between **i** and **j** is equal to the sum of the subarray from **0** to **j** minus the sum of the subarray from **0** to **i-1**.\\n\\nRather than iteratively checking if **sum[0,j] - sum[0,i-1] = T** for every pair of **i, j** values, we can flip it around to **sum[0,j] - T = sum[0,i-1]** and since every earlier sum value has been stored in **res**, we can simply perform a lookup on **sum[0,j] - T** to see if there are any matches.\\n\\nWhen extrapolating this solution to our **2-dimensional** matrix (**M**), we will need to first prefix sum the rows or columns, (which we can do **in-place** to avoid extra space, as we will not need the original values again). Then we should iterate through **M** again in the opposite order of rows/columns where the prefix sums will allow us to treat a group of columns or rows as if it were a **1-dimensional** array and apply the SSEK algorithm.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython, oddly, has _much_ better performance with the use of a simple **dict** instead of a **defaultdict** for **res** (Thanks, [@slcheungcasado](https://leetcode.com/slcheungcasado)!)\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **232ms / 44.8MB** (beats 100% / 81%).\\n```javascript\\nvar numSubmatrixSumTarget = function(M, T) {\\n    let xlen = M[0].length, ylen = M.length,\\n        ans = 0, res = new Map(), csum\\n    for (let i = 0, r = M[0]; i < ylen; r = M[++i]) \\n        for (let j = 1; j < xlen; j++)\\n            r[j] += r[j-1]\\n    for (let j = 0; j < xlen; j++)\\n        for (let k = j; k < xlen; k++) {\\n            res.clear(), res.set(0,1), csum = 0\\n            for (let i = 0; i < ylen; i++) {\\n                csum += M[i][k] - (j ? M[i][j-1] : 0)\\n                ans += (res.get(csum - T) || 0)\\n                res.set(csum, (res.get(csum) || 0) + 1)\\n            }\\n        }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **552ms / 15.0MB** (beats 100% / 85%).\\n```python\\nclass Solution:\\n    def numSubmatrixSumTarget(self, M: List[List[int]], T: int) -> int:\\n        xlen, ylen, ans = len(M[0]), len(M), 0\\n        for r in M:\\n            for j in range(1, xlen):\\n                r[j] += r[j-1]\\n        for j in range(xlen):\\n            for k in range(j, xlen):\\n                res, csum = {0: 1}, 0\\n                for r in M:\\n                    csum += r[k] - (r[j-1] if j else 0)\\n                    if csum - T in res: ans += res[csum-T]\\n                    res[csum] = res[csum] + 1 if csum in res else 1  \\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **81ms / 39.3MB** (beats 96% / 95%).\\n```java\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] M, int T) {\\n        int xlen = M[0].length, ylen = M.length, ans = 0;\\n        Map<Integer, Integer> res = new HashMap<>();\\n        for (int[] r : M)\\n            for (int j = 1; j < xlen; j++)\\n                r[j] += r[j-1];\\n        for (int j = 0; j < xlen; j++)\\n            for (int k = j; k < xlen; k++) {\\n                res.clear();\\n                res.put(0,1);\\n                int csum = 0;\\n                for (int i = 0; i < ylen; i++) {\\n                    csum += M[i][k] - (j > 0 ? M[i][j-1] : 0);\\n                    ans += res.getOrDefault(csum - T, 0);\\n                    res.put(csum, res.getOrDefault(csum, 0) + 1);\\n                }\\n            }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **484ms / 95.3MB** (beats 96% / 76%).\\n```c++\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& M, int T) {\\n        int xlen = M[0].size(), ylen = M.size(), ans = 0;\\n        unordered_map<int, int> res;\\n        for (int i = 0; i < ylen; i++)\\n            for (int j = 1; j < xlen; j++)\\n                M[i][j] += M[i][j-1];\\n        for (int j = 0; j < xlen; j++)\\n            for (int k = j; k < xlen; k++) {\\n                res.clear();\\n                res[0] = 1;\\n                int csum = 0;\\n                for (int i = 0; i < ylen; i++) {\\n                    csum += M[i][k] - (j ? M[i][j-1] : 0);\\n                    ans += res.find(csum - T) != res.end() ? res[csum - T] : 0;\\n                    res[csum]++;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar numSubmatrixSumTarget = function(M, T) {\\n    let xlen = M[0].length, ylen = M.length,\\n        ans = 0, res = new Map(), csum\\n    for (let i = 0, r = M[0]; i < ylen; r = M[++i]) \\n        for (let j = 1; j < xlen; j++)\\n            r[j] += r[j-1]\\n    for (let j = 0; j < xlen; j++)\\n        for (let k = j; k < xlen; k++) {\\n            res.clear(), res.set(0,1), csum = 0\\n            for (let i = 0; i < ylen; i++) {\\n                csum += M[i][k] - (j ? M[i][j-1] : 0)\\n                ans += (res.get(csum - T) || 0)\\n                res.set(csum, (res.get(csum) || 0) + 1)\\n            }\\n        }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def numSubmatrixSumTarget(self, M: List[List[int]], T: int) -> int:\\n        xlen, ylen, ans = len(M[0]), len(M), 0\\n        for r in M:\\n            for j in range(1, xlen):\\n                r[j] += r[j-1]\\n        for j in range(xlen):\\n            for k in range(j, xlen):\\n                res, csum = {0: 1}, 0\\n                for r in M:\\n                    csum += r[k] - (r[j-1] if j else 0)\\n                    if csum - T in res: ans += res[csum-T]\\n                    res[csum] = res[csum] + 1 if csum in res else 1  \\n        return ans\\n```\n```java\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] M, int T) {\\n        int xlen = M[0].length, ylen = M.length, ans = 0;\\n        Map<Integer, Integer> res = new HashMap<>();\\n        for (int[] r : M)\\n            for (int j = 1; j < xlen; j++)\\n                r[j] += r[j-1];\\n        for (int j = 0; j < xlen; j++)\\n            for (int k = j; k < xlen; k++) {\\n                res.clear();\\n                res.put(0,1);\\n                int csum = 0;\\n                for (int i = 0; i < ylen; i++) {\\n                    csum += M[i][k] - (j > 0 ? M[i][j-1] : 0);\\n                    ans += res.getOrDefault(csum - T, 0);\\n                    res.put(csum, res.getOrDefault(csum, 0) + 1);\\n                }\\n            }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& M, int T) {\\n        int xlen = M[0].size(), ylen = M.size(), ans = 0;\\n        unordered_map<int, int> res;\\n        for (int i = 0; i < ylen; i++)\\n            for (int j = 1; j < xlen; j++)\\n                M[i][j] += M[i][j-1];\\n        for (int j = 0; j < xlen; j++)\\n            for (int k = j; k < xlen; k++) {\\n                res.clear();\\n                res[0] = 1;\\n                int csum = 0;\\n                for (int i = 0; i < ylen; i++) {\\n                    csum += M[i][k] - (j ? M[i][j-1] : 0);\\n                    ans += res.find(csum - T) != res.end() ? res[csum - T] : 0;\\n                    res[csum]++;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297511,
                "title": "java-easy-solution-with-explanation-hashmap",
                "content": "Explanation\\n\\n* For each row, calculate the prefix sum.\\n* For each pair of columns,\\n* calculate the accumulated sum of rows.\\n* Now this problem is same to, \"Find the Subarray with Target Sum\".\\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int res = 0;\\n        //int[][] sum = new int[row][col];\\n        \\n        for(int i = 0; i < row; i++){\\n            for(int j = 1; j < col; j++){\\n                //sum[i][j] =sum[i][j-1] + matrix[i][j-1];\\n                matrix[i][j] += matrix[i][j-1];\\n            }\\n        }\\n        \\n        for(int start = 0; start < col; start++){\\n            for(int end = start; end < col; end++){\\n                int subMatrixSum = 0;\\n                \\n                Map<Integer, Integer> countElm = new HashMap<Integer, Integer>();\\n                countElm.put(0,1);\\n                \\n                for(int k = 0; k < row; k++){\\n                    //subMatrixSum += sum[k][end] - sum[k][start];\\n                    int prefixSum = start == 0 ? 0:matrix[k][start-1];\\n                    subMatrixSum += matrix[k][end] - prefixSum;\\n                    \\n                    if(countElm.containsKey(subMatrixSum - target))\\n                        res += countElm.get(subMatrixSum - target);\\n                    \\n                    int r = countElm.getOrDefault(subMatrixSum, 0);\\n                    countElm.put(subMatrixSum, r+1);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int res = 0;\\n        //int[][] sum = new int[row][col];\\n        \\n        for(int i = 0; i < row; i++){\\n            for(int j = 1; j < col; j++){\\n                //sum[i][j] =sum[i][j-1] + matrix[i][j-1];\\n                matrix[i][j] += matrix[i][j-1];\\n            }\\n        }\\n        \\n        for(int start = 0; start < col; start++){\\n            for(int end = start; end < col; end++){\\n                int subMatrixSum = 0;\\n                \\n                Map<Integer, Integer> countElm = new HashMap<Integer, Integer>();\\n                countElm.put(0,1);\\n                \\n                for(int k = 0; k < row; k++){\\n                    //subMatrixSum += sum[k][end] - sum[k][start];\\n                    int prefixSum = start == 0 ? 0:matrix[k][start-1];\\n                    subMatrixSum += matrix[k][end] - prefixSum;\\n                    \\n                    if(countElm.containsKey(subMatrixSum - target))\\n                        res += countElm.get(subMatrixSum - target);\\n                    \\n                    int r = countElm.getOrDefault(subMatrixSum, 0);\\n                    countElm.put(subMatrixSum, r+1);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162925,
                "title": "number-of-submatrices-that-sum-to-target-optimization-from-brute-force-explained",
                "content": "There are a few solution mentioned by others but most have directly given the most optimal solution. Here, I will try to start from the brute-force approach and try to explain the various optimizations that can be done to finally arrive at the optimal solution.\\n\\n---\\n\\n\\u274C ***Solution - I (Brute-Force Approach) [Rejected]***\\n\\nLet\\'s start with the most basic approach to this problem. Take all the submatrices possible for the given matrix and check if their sum is equal to `target`.\\n\\n```\\nint numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n\\tint res = 0, m = size(A), n = size(A[0]);\\n\\t// calculate sum of each submatrix and check if it is equal to target\\n\\tfor(int rowStart = 0; rowStart < m; rowStart++)\\n\\t\\tfor(int rowSize = 1; rowStart + rowSize <= m; rowSize++)\\n\\t\\t\\tfor(int colStart = 0; colStart < n; colStart++)\\n\\t\\t\\t\\tfor(int colSize = 1; colStart + colSize <= n; colSize++)\\n\\t\\t\\t\\t\\tif(SUM(A, rowStart, rowSize, colStart, colSize) == target)\\n\\t\\t\\t\\t\\t\\tres++;\\n\\treturn res;    \\n}\\n// Calculates the sum of a submatrix with given bounds\\nint SUM(vector<vector<int> > &A, int rStart, int rSize, int cStart, int cSize){\\n\\tint subMatrixSum = 0;\\n\\tfor(int i = rStart; i < rStart + rSize; i++)\\n\\t\\tfor(int j = cStart; j < cStart + cSize; j++)\\n\\t\\t\\tsubMatrixSum += A[i][j];\\n\\treturn subMatrixSum;\\n}\\n```\\n\\n***Time Complexity :*** **`O((M*N)^3)`**, where `M` is the number of rows and `N` is the number of columns  in the given matrix.\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Compute prefix sum for each Row or Column)***\\n\\nWe can optimize the above approach by reducing the time complexity of the `SUM` function in the above solution. We know that in a given array, the sum of range [i,j] can be calculated by `prefixSum[j] - prefixSum[i - 1]`. We can use this to optimize the solution.\\n\\nAfter computing prefix sum for each row of matrix (*you can do it for column as well*), we can get the sum of a given range in O(1) time. Thus, for any submatrix of the main matrix, we just need to iterate over all its rows and we can get sum of given range (`[colStart, colEnd]`) in O(1) time.\\n\\n1. We just start from row 0, calculate the sum for that row for the range `[colStart, colEnd]`.\\n2. Extend the sum by perform step-1 for row 1, row 2, ... and so on till last row.\\n3. Repeat this process for every `[colStart, colEnd]` combination.\\n\\n\\n```\\nint numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n\\tint res = 0, m = size(A), n = size(A[0]);\\n\\t// calculating prefix sum for each row of matrix\\n\\tfor (int row = 0; row < m; row++)\\n\\t\\tfor (int col = 1; col < n; col++)\\n\\t\\t\\tA[row][col] += A[row][col - 1];\\n\\t// calculate sum of each submatrix and check if it is equal to target\\n\\tfor (int colStart = 0; colStart < n; colStart++) {\\n\\t\\tfor (int colEnd = colStart; colEnd < n; colEnd++) {\\n\\t\\t\\tfor(int rowStart = 0; rowStart < m; rowStart++){\\n\\t\\t\\t\\tint sum = 0;\\n\\t\\t\\t\\tfor(int rowEnd = rowStart; rowEnd < m; rowEnd++){\\n\\t\\t\\t\\t\\tsum += A[rowEnd][colEnd] - (colStart ? A[rowEnd][colStart - 1] : 0);\\n\\t\\t\\t\\t\\tif(sum == target) res++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;    \\n}\\n```\\n***Time Complexity :*** **`O((M*N)^2)`**, where `M` is the number of rows and `N` is the number of columns  in the given matrix.\\n***Space Complexity :*** **`O(1)`**, since we are modifying the given matrix itself. If we use a new prefix sum matrix, the space complexity would be `O(M*N)`.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Further Optimization in Solution - II)***\\n\\nWe can further optimize the solution by using hashmap. The optimization done here is similar to the one in solution of [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/solution/).\\n\\nBasically, we will be maintaining a running submatrix sum starting from row 0 till m, for a given `[colStart, colEnd]` range. Each sum value and number of its occurence will be stored in hashmap. If there\\'s a submatrix which was found such that `cursum` at that time was equal to present sum (`cursum`) - target, then we are sure that there were occurences of submatrices which had sum equal to `target` and the count is given by `mp[cursum - target]`.\\n\\nIf the explanation didn\\'t make the approach clear, I really suggest you to try the *560. Subarray Sum Equals K* problem and read the hashmap solution. It took me some time reading that before I was able to clearly understand this solution.\\n\\n```\\nint numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n\\tint res = 0, m = size(A), n = size(A[0]);\\n\\tfor (int row = 0; row < m; row++)\\n\\t\\tfor (int col = 1; col < n; col++)\\n\\t\\t\\tA[row][col] += A[row][col - 1];\\n\\t//         cursum, occurences\\n\\tunordered_map<int, int> mp;\\n\\tfor (int colStart = 0; colStart < n; colStart++) {\\n\\t\\tfor (int colEnd = colStart; colEnd < n; colEnd++) {\\n\\t\\t\\tint cursum = 0;\\n\\t\\t\\tmp = {{0, 1}};\\n\\t\\t\\tfor(int row = 0; row < m; row++){\\n\\t\\t\\t\\tcursum += A[row][colEnd] - (colStart ? A[row][colStart - 1] : 0);    \\n\\t\\t\\t\\t// mp[sum-target] will give number of submatrices found having sum as \\'sum - target\\'\\n\\t\\t\\t\\tres += mp[cursum - target];\\n\\t\\t\\t\\tmp[cursum]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;    \\n}\\n```\\n***Time Complexity :*** **`O(N*N*M)`**, where `M` is the number of rows and `N` is the number of columns  in the given matrix.\\n***Space Complexity :*** **`O(N)`**\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any questions or mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n\\tint res = 0, m = size(A), n = size(A[0]);\\n\\t// calculate sum of each submatrix and check if it is equal to target\\n\\tfor(int rowStart = 0; rowStart < m; rowStart++)\\n\\t\\tfor(int rowSize = 1; rowStart + rowSize <= m; rowSize++)\\n\\t\\t\\tfor(int colStart = 0; colStart < n; colStart++)\\n\\t\\t\\t\\tfor(int colSize = 1; colStart + colSize <= n; colSize++)\\n\\t\\t\\t\\t\\tif(SUM(A, rowStart, rowSize, colStart, colSize) == target)\\n\\t\\t\\t\\t\\t\\tres++;\\n\\treturn res;    \\n}\\n// Calculates the sum of a submatrix with given bounds\\nint SUM(vector<vector<int> > &A, int rStart, int rSize, int cStart, int cSize){\\n\\tint subMatrixSum = 0;\\n\\tfor(int i = rStart; i < rStart + rSize; i++)\\n\\t\\tfor(int j = cStart; j < cStart + cSize; j++)\\n\\t\\t\\tsubMatrixSum += A[i][j];\\n\\treturn subMatrixSum;\\n}\\n```\n```\\nint numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n\\tint res = 0, m = size(A), n = size(A[0]);\\n\\t// calculating prefix sum for each row of matrix\\n\\tfor (int row = 0; row < m; row++)\\n\\t\\tfor (int col = 1; col < n; col++)\\n\\t\\t\\tA[row][col] += A[row][col - 1];\\n\\t// calculate sum of each submatrix and check if it is equal to target\\n\\tfor (int colStart = 0; colStart < n; colStart++) {\\n\\t\\tfor (int colEnd = colStart; colEnd < n; colEnd++) {\\n\\t\\t\\tfor(int rowStart = 0; rowStart < m; rowStart++){\\n\\t\\t\\t\\tint sum = 0;\\n\\t\\t\\t\\tfor(int rowEnd = rowStart; rowEnd < m; rowEnd++){\\n\\t\\t\\t\\t\\tsum += A[rowEnd][colEnd] - (colStart ? A[rowEnd][colStart - 1] : 0);\\n\\t\\t\\t\\t\\tif(sum == target) res++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;    \\n}\\n```\n```\\nint numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n\\tint res = 0, m = size(A), n = size(A[0]);\\n\\tfor (int row = 0; row < m; row++)\\n\\t\\tfor (int col = 1; col < n; col++)\\n\\t\\t\\tA[row][col] += A[row][col - 1];\\n\\t//         cursum, occurences\\n\\tunordered_map<int, int> mp;\\n\\tfor (int colStart = 0; colStart < n; colStart++) {\\n\\t\\tfor (int colEnd = colStart; colEnd < n; colEnd++) {\\n\\t\\t\\tint cursum = 0;\\n\\t\\t\\tmp = {{0, 1}};\\n\\t\\t\\tfor(int row = 0; row < m; row++){\\n\\t\\t\\t\\tcursum += A[row][colEnd] - (colStart ? A[row][colStart - 1] : 0);    \\n\\t\\t\\t\\t// mp[sum-target] will give number of submatrices found having sum as \\'sum - target\\'\\n\\t\\t\\t\\tres += mp[cursum - target];\\n\\t\\t\\t\\tmp[cursum]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1162873,
                "title": "c-prefix-sum-explanation-with-pictures-424ms-9mb",
                "content": "The problem is split in two parts. \\nFirst, compute 2D prefix sum matrix ```ps```, so that element ```p[i][j]``` is equal to the sum of elements in submatrix ```matrix[x][y]``` with ```0 <= x <= i, 0 <= y <= j```. For this purpose we compute 1D prefix sums for the first row and first column and then use the formula:\\n```ps[i][j] = matrix[i][j] + ps[i-1][j] + ps[i][j-1] - ps[i-1][j-1]```\\n\\n\\nHere is illustration:\\n<img src=\"https://assets.leetcode.com/users/images/fad46894-4b59-48a9-a0f8-a6e969cc7b29_1618664366.132954.png\" alt=\"drawing\" height=\"200\"/>\\n\\nThe sum of elements from ```(0,0)``` to ```(i,j)``` consists of element ```matrix[i][j]``` and sums of elemnts in submatrices ```A,B,C```. \\n\\nSum of elements in ```A``` is simply ```ps[i-1][j-1]```.\\nElements in ```B```: ```ps[i][j-1] - ps[i-1][j-1]```.\\nElements in ```C```: ```ps[i-1][j] - ps[i-1][j-1]```.\\nSumming of all this \\n\\nSecond part of the solution: use the prefix sum matrix to quickly compute sums of all the possible submatrices:\\n<img src=\"https://assets.leetcode.com/users/images/1d8e4609-5d06-4ad8-b97e-9f4af78e9906_1618665165.0758274.png\" alt=\"drawing\" height=\"250\"/>\\nSum of elements in submatrix ```matrix[x][y]``` with ```i0 <= x <= i1, j0 <= y <= j1``` is a difference between elements in ```D``` and elements in ```A```,```B``` and ```C```.  \\n\\nSum in ```D``` and ```A``` are prefix sums ```ps[i1][j1]``` and ```ps[i0-1][j0-1]```. For the remaining two submatrices we get:\\n```B=ps[i1][j0-1] - ps[i0-1][j0-1]```\\n```C=ps[i0-1][j1] - ps[i0-1][j0-1]```\\n\\nHence, the final formula is:\\n```sum = ps[i1][j1]-ps[i1][j0-1]-ps[i0-1][j1]+ps[i0-1][j0-1]```\\n\\nThe corner cases are when ```j0=0``` or ```i0=0```.\\n\\n```\\nclass Solution {\\n    int ps[101][101];\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& M, int target) {\\n        ios_base::sync_with_stdio(false);\\n        size_t n{ M.size() }, m{ M[0].size() };\\n        \\n\\t\\t// compute prefix sum\\n        ps[0][0] = M[0][0];\\n        for (int i = 1; i < n; i++) ps[i][0] = M[i][0] + ps[i-1][0];\\n        for (int j = 1; j < m; j++) ps[0][j] = M[0][j] + ps[0][j-1];\\n        \\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++)\\n                ps[i][j] = M[i][j] + ps[i-1][j] + ps[i][j-1] - ps[i-1][j-1];\\n\\n        \\n        int count{};\\n        // test all submatrices\\n        for (int i0 = 0; i0 < n; i0++)\\n            for (int j0 = 0; j0 < m; j0++)\\n                for (int i1 = i0; i1 < n; i1++)\\n                    for (int j1 = j0; j1 < m; j1++) {\\n                        int sum{ ps[i1][j1] };\\n\\n                        if (i0 > 0) sum -= ps[i0 - 1][j1];\\n                        if (j0 > 0) sum -= ps[i1][j0-1];\\n                        if (i0 > 0 && j0 > 0) sum += ps[i0 - 1][j0 - 1];\\n\\n                        if (sum == target) count++;\\n                    }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```ps```\n```p[i][j]```\n```matrix[x][y]```\n```0 <= x <= i, 0 <= y <= j```\n```ps[i][j] = matrix[i][j] + ps[i-1][j] + ps[i][j-1] - ps[i-1][j-1]```\n```(0,0)```\n```(i,j)```\n```matrix[i][j]```\n```A,B,C```\n```A```\n```ps[i-1][j-1]```\n```B```\n```ps[i][j-1] - ps[i-1][j-1]```\n```C```\n```ps[i-1][j] - ps[i-1][j-1]```\n```matrix[x][y]```\n```i0 <= x <= i1, j0 <= y <= j1```\n```D```\n```A```\n```B```\n```C```\n```D```\n```A```\n```ps[i1][j1]```\n```ps[i0-1][j0-1]```\n```B=ps[i1][j0-1] - ps[i0-1][j0-1]```\n```C=ps[i0-1][j1] - ps[i0-1][j0-1]```\n```sum = ps[i1][j1]-ps[i1][j0-1]-ps[i0-1][j1]+ps[i0-1][j0-1]```\n```j0=0```\n```i0=0```\n```\\nclass Solution {\\n    int ps[101][101];\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& M, int target) {\\n        ios_base::sync_with_stdio(false);\\n        size_t n{ M.size() }, m{ M[0].size() };\\n        \\n\\t\\t// compute prefix sum\\n        ps[0][0] = M[0][0];\\n        for (int i = 1; i < n; i++) ps[i][0] = M[i][0] + ps[i-1][0];\\n        for (int j = 1; j < m; j++) ps[0][j] = M[0][j] + ps[0][j-1];\\n        \\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++)\\n                ps[i][j] = M[i][j] + ps[i-1][j] + ps[i][j-1] - ps[i-1][j-1];\\n\\n        \\n        int count{};\\n        // test all submatrices\\n        for (int i0 = 0; i0 < n; i0++)\\n            for (int j0 = 0; j0 < m; j0++)\\n                for (int i1 = i0; i1 < n; i1++)\\n                    for (int j1 = j0; j1 < m; j1++) {\\n                        int sum{ ps[i1][j1] };\\n\\n                        if (i0 > 0) sum -= ps[i0 - 1][j1];\\n                        if (j0 > 0) sum -= ps[i1][j0-1];\\n                        if (i0 > 0 && j0 > 0) sum += ps[i0 - 1][j0 - 1];\\n\\n                        if (sum == target) count++;\\n                    }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1700090,
                "title": "c-explained-detailed-dp-prefix-sum",
                "content": "**!!!Please upvote if you like it..**\\nThe given question ask to `count the number of sub-matrix whose sum of all element is equal to target value.`\\n\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\n**How to find all sub-matrix??**\\n->Let\\'s think about 1-d array when we ask to f`ind all possible sub array we use prefix sum and do it `easily....\\n**Here is a case of 2-D matrix..**\\nIDEA:\\uD83D\\uDCAF\\n1.To use 2D-prefix sum to store sum of all sub-matrix .\\n2.Generate all  possible sub matrix-cordinate and find sum  and count possible value.\\n3.Checking will be of O(1) time.\\n\\n`1.How to create 2-d prefix sum??`\\n[![image](https://assets.leetcode.com/users/images/77f26df6-deac-4287-ac58-a6de3b77fd85_1642519275.3614054.jpeg)\\n` 2.Genrating all possible submatrix co-rdinate:`\\nThis can be done using 4-loops that  help to all sub-matrix.\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int dp[n+1][m+1];//2-ddp for prefix sum\\n       \\n       \\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=m;j++)\\n            {\\n                if(i==0||j==0)\\n                {\\n                    dp[i][j]=0;\\n                }\\n                else{\\n                    \\n                dp[i][j]=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]+matrix[i-1][j-1];//using prefix dp formulae\\n                    \\n                }\\n            }\\n        }\\n        int count=0;\\n\\t\\t//generate all possible sub matrix.\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                for(int k=i;k<=n;k++)\\n                {\\n                    for(int l=j;l<=m;l++)\\n                    {\\n                      int ans=dp[i-1][j-1]+dp[k][l]-dp[i-1][l]-dp[k][j-1];\\n                        if(ans==target)\\n                        {\\n                            count++;\\n                        }\\n                    }\\n                    \\n                }\\n                \\n            }\\n        }\\n        return count;\\n       \\n        \\n        \\n    }\\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int dp[n+1][m+1];//2-ddp for prefix sum\\n       \\n       \\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=m;j++)\\n            {\\n                if(i==0||j==0)\\n                {\\n                    dp[i][j]=0;\\n                }\\n                else{\\n                    \\n                dp[i][j]=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]+matrix[i-1][j-1];//using prefix dp formulae\\n                    \\n                }\\n            }\\n        }\\n        int count=0;\\n\\t\\t//generate all possible sub matrix.\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                for(int k=i;k<=n;k++)\\n                {\\n                    for(int l=j;l<=m;l++)\\n                    {\\n                      int ans=dp[i-1][j-1]+dp[k][l]-dp[i-1][l]-dp[k][j-1];\\n                        if(ans==target)\\n                        {\\n                            count++;\\n                        }\\n                    }\\n                    \\n                }\\n                \\n            }\\n        }\\n        return count;\\n       \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299066,
                "title": "c-easy-solution-detailed-explanation",
                "content": "**Prerequisite:** https://leetcode.com/problems/subarray-sum-equals-k/ (if you don\\'t know this question, please first solve it. Otherwise, understanding current problem is difficult)\\n```\\nint subarraySum(vector<int>& nums, int k) {\\n\\tunordered_map<int,int> um;\\n\\tum[0] = 1;\\n\\tint curr = 0;\\n\\tint ans = 0;\\n\\tfor(auto it: nums){\\n\\t\\tcurr += it;\\n\\t\\tint rem = curr-k;\\n\\t\\tif(um.find(rem) != um.end()){\\n\\t\\t\\tans += um[rem];\\n\\t\\t}\\n\\t\\tum[curr] += 1;\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\nBack to this problem:\\n```\\nclass Solution {\\npublic:\\n    int subarraySum(vector<int> &nums, int k){\\n        unordered_map<int,int> um;\\n        um[0] = 1;\\n        int curr = 0;\\n        int ans = 0;\\n        for(auto it: nums){    \\n            curr += it;\\n            int rem = curr-k;\\n            if(um.find(rem) != um.end()){\\n                ans += um[rem];\\n            }\\n            um[curr] += 1;\\n        }\\n        return ans;\\n    }\\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int ans = 0;\\n\\t\\t// Each iteration calculates the count for submatrix from row i to matrix.size()\\n        for(int i=0; i<matrix.size(); i++){\\n\\t\\t\\t// Sum stores the sum of the elements from row i to j \\n            vector<int> sum(matrix[0].size(), 0);\\n            for(int j=i; j<matrix.size(); j++){\\n                for(int k=0; k<matrix[0].size(); k++){\\n                    sum[k] += matrix[j][k];\\n                }\\n\\t\\t\\t\\t// Now calculate the count for the submatrix from row i to j\\n                ans += subarraySum(sum, target);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint subarraySum(vector<int>& nums, int k) {\\n\\tunordered_map<int,int> um;\\n\\tum[0] = 1;\\n\\tint curr = 0;\\n\\tint ans = 0;\\n\\tfor(auto it: nums){\\n\\t\\tcurr += it;\\n\\t\\tint rem = curr-k;\\n\\t\\tif(um.find(rem) != um.end()){\\n\\t\\t\\tans += um[rem];\\n\\t\\t}\\n\\t\\tum[curr] += 1;\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int subarraySum(vector<int> &nums, int k){\\n        unordered_map<int,int> um;\\n        um[0] = 1;\\n        int curr = 0;\\n        int ans = 0;\\n        for(auto it: nums){    \\n            curr += it;\\n            int rem = curr-k;\\n            if(um.find(rem) != um.end()){\\n                ans += um[rem];\\n            }\\n            um[curr] += 1;\\n        }\\n        return ans;\\n    }\\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int ans = 0;\\n\\t\\t// Each iteration calculates the count for submatrix from row i to matrix.size()\\n        for(int i=0; i<matrix.size(); i++){\\n\\t\\t\\t// Sum stores the sum of the elements from row i to j \\n            vector<int> sum(matrix[0].size(), 0);\\n            for(int j=i; j<matrix.size(); j++){\\n                for(int k=0; k<matrix[0].size(); k++){\\n                    sum[k] += matrix[j][k];\\n                }\\n\\t\\t\\t\\t// Now calculate the count for the submatrix from row i to j\\n                ans += subarraySum(sum, target);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2298548,
                "title": "c-java-python-subarray-sum-explained",
                "content": "**Plz Upvote if found helpful**\\n\\n**Explaination:**\\nThis problem is essentially a 2-dimensional version of #560. Subarray Sum Equals K (S.S.E.K). By using a prefix sum on each row or each column, we can compress this problem down to either N^2 iterations of the **O(M)** SSEK, or M^2 iterations of the **O(N)** SSEK.\\n\\nIn the SSEK solution, we can find the number of subarrays with the target sum by utilizing a result map (res) to store the different values found as we iterate through the array while keeping a running sum (csum). Just as in the case with a prefix sum array, the sum of a subarray between i and j is equal to the sum of the subarray from 0 to j minus the sum of the subarray from 0 to i-1.\\n\\nRather than iteratively checking if sum[0,j] - sum[0,i-1] = T for every pair of i, j values, we can flip it around to sum[0,j] - T = sum[0,i-1] and since every earlier sum value has been stored in res, we can simply perform a lookup on sum[0,j] - T to see if there are any matches.\\n\\nWhen extrapolating this solution to our 2-dimensional matrix (M), we will need to first prefix sum the rows or columns, (which we can do in-place to avoid extra space, as we will not need the original values again). Then we should iterate through M again in the opposite order of rows/columns where the prefix sums will allow us to treat a group of columns or rows as if it were a 1-dimensional array and apply the SSEK algorithm.\\n\\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n**C++  Code**\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size() , cols = matrix[0].size();\\n        \\n        if(rows < 1){\\n            return 0;\\n        }\\n        \\n        // calculate prefix sum for rows\\n        for(int row = 0 ; row < rows ; row++){\\n            for(int col = 1 ; col < cols ;col++){\\n                matrix[row][col] =  matrix[row][col] + matrix[row][col -1];\\n            }\\n        }\\n      \\n        int count = 0 , sum ;\\n        unordered_map<int , int> counter;\\n        for(int colstart = 0 ; colstart < cols ;colstart++){\\n            for(int col = colstart ; col < cols; col++){\\n                counter.clear();\\n                counter[0] = 1;\\n                sum =0;\\n                for(int row = 0 ; row < rows ;row++){\\n                    sum += matrix[row][col] - (colstart > 0 ? matrix[row][colstart - 1] : 0 );\\n                    count += (counter.find(sum- target) != counter.end() ? counter[sum-target] : 0);\\n                    counter[sum]++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n**Java Code:**\\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] M, int T) {\\n        int xlen = M[0].length, ylen = M.length, ans = 0;\\n        Map<Integer, Integer> res = new HashMap<>();\\n        for (int[] r : M)\\n            for (int j = 1; j < xlen; j++)\\n                r[j] += r[j-1];\\n        for (int j = 0; j < xlen; j++)\\n            for (int k = j; k < xlen; k++) {\\n                res.clear();\\n                res.put(0,1);\\n                int csum = 0;\\n                for (int i = 0; i < ylen; i++) {\\n                    csum += M[i][k] - (j > 0 ? M[i][j-1] : 0);\\n                    ans += res.getOrDefault(csum - T, 0);\\n                    res.put(csum, res.getOrDefault(csum, 0) + 1);\\n                }\\n            }\\n        return ans;\\n    }\\n}\\n```\\n\\n**Python Code**\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, M: List[List[int]], T: int) -> int:\\n        xlen, ylen, ans = len(M[0]), len(M), 0\\n        for r in M:\\n            for j in range(1, xlen):\\n                r[j] += r[j-1]\\n        for j in range(xlen):\\n            for k in range(j, xlen):\\n                res, csum = {0: 1}, 0\\n                for r in M:\\n                    csum += r[k] - (r[j-1] if j else 0)\\n                    if csum - T in res: ans += res[csum-T]\\n                    res[csum] = res[csum] + 1 if csum in res else 1  \\n        return ans\\n```\\n\\n**Please Upvote if found Helpful**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size() , cols = matrix[0].size();\\n        \\n        if(rows < 1){\\n            return 0;\\n        }\\n        \\n        // calculate prefix sum for rows\\n        for(int row = 0 ; row < rows ; row++){\\n            for(int col = 1 ; col < cols ;col++){\\n                matrix[row][col] =  matrix[row][col] + matrix[row][col -1];\\n            }\\n        }\\n      \\n        int count = 0 , sum ;\\n        unordered_map<int , int> counter;\\n        for(int colstart = 0 ; colstart < cols ;colstart++){\\n            for(int col = colstart ; col < cols; col++){\\n                counter.clear();\\n                counter[0] = 1;\\n                sum =0;\\n                for(int row = 0 ; row < rows ;row++){\\n                    sum += matrix[row][col] - (colstart > 0 ? matrix[row][colstart - 1] : 0 );\\n                    count += (counter.find(sum- target) != counter.end() ? counter[sum-target] : 0);\\n                    counter[sum]++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] M, int T) {\\n        int xlen = M[0].length, ylen = M.length, ans = 0;\\n        Map<Integer, Integer> res = new HashMap<>();\\n        for (int[] r : M)\\n            for (int j = 1; j < xlen; j++)\\n                r[j] += r[j-1];\\n        for (int j = 0; j < xlen; j++)\\n            for (int k = j; k < xlen; k++) {\\n                res.clear();\\n                res.put(0,1);\\n                int csum = 0;\\n                for (int i = 0; i < ylen; i++) {\\n                    csum += M[i][k] - (j > 0 ? M[i][j-1] : 0);\\n                    ans += res.getOrDefault(csum - T, 0);\\n                    res.put(csum, res.getOrDefault(csum, 0) + 1);\\n                }\\n            }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, M: List[List[int]], T: int) -> int:\\n        xlen, ylen, ans = len(M[0]), len(M), 0\\n        for r in M:\\n            for j in range(1, xlen):\\n                r[j] += r[j-1]\\n        for j in range(xlen):\\n            for k in range(j, xlen):\\n                res, csum = {0: 1}, 0\\n                for r in M:\\n                    csum += r[k] - (r[j-1] if j else 0)\\n                    if csum - T in res: ans += res[csum-T]\\n                    res[csum] = res[csum] + 1 if csum in res else 1  \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 562478,
                "title": "c-compact-prefix-sum-explained-65-speed-100-memory",
                "content": "For all possible row ranges, calculate cumulative matrix sums column by column identifying when sum equals target or when sum equals a previous sum (in the same row range) minus the target. In the y direction, the cumulative sum is added to each column incrementally using a vector representing the column sum of interest in the row.\\n\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int count = 0;\\n        \\n        for (int i = 0; i < m; i++){                      //Iterating over all possible row ranges between row i and row j\\n            vector<int> CumulativeColumns = matrix[i];    //Instead of setting up a prefix sum matrix, add to columns as we go row by row\\n            \\n            for (int j = i; j < m; j++){\\n                unordered_map<int,int> sumCount;          //track occurrences of corner matrix sums for the current row range\\n                int totalSum = 0;\\n                \\n                for (int k = 0; k < n; k++){\\n                    totalSum += CumulativeColumns[k];        //within the current row range, at every row cumulatively build matrix sums using cumulative column sums column by column\\n                    if (totalSum == target) count++;         //if the target is found or if a sum is found that has a difference with a previous sum in the same top/bottom bounds exactly equal to target, add submatrices found\\n                    if (sumCount.count(totalSum-target)) count += sumCount[totalSum-target];\\n                    sumCount[totalSum]++;                    //Store the current cumulative sum to be used later in the row to calculate target matrix counts        \\n                    if (j < m - 1) CumulativeColumns[k] += matrix[j+1][k];   //Increment the cumulative column sum for the next row iteration in the current row range if necessary\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int count = 0;\\n        \\n        for (int i = 0; i < m; i++){                      //Iterating over all possible row ranges between row i and row j\\n            vector<int> CumulativeColumns = matrix[i];    //Instead of setting up a prefix sum matrix, add to columns as we go row by row\\n            \\n            for (int j = i; j < m; j++){\\n                unordered_map<int,int> sumCount;          //track occurrences of corner matrix sums for the current row range\\n                int totalSum = 0;\\n                \\n                for (int k = 0; k < n; k++){\\n                    totalSum += CumulativeColumns[k];        //within the current row range, at every row cumulatively build matrix sums using cumulative column sums column by column\\n                    if (totalSum == target) count++;         //if the target is found or if a sum is found that has a difference with a previous sum in the same top/bottom bounds exactly equal to target, add submatrices found\\n                    if (sumCount.count(totalSum-target)) count += sumCount[totalSum-target];\\n                    sumCount[totalSum]++;                    //Store the current cumulative sum to be used later in the row to calculate target matrix counts        \\n                    if (j < m - 1) CumulativeColumns[k] += matrix[j+1][k];   //Increment the cumulative column sum for the next row iteration in the current row range if necessary\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297552,
                "title": "c-easy-solution-without-hashmap-prefix-sum-easy-understanding",
                "content": "# **C++ Easy Solution Without Hashmap || Prefix Sum || Easy Understanding**\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size(),m=matrix[0].size(),count=0;\\n        vector<vector<int>>temp(n+1,vector<int>(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp[i+1][j]=temp[i][j]+matrix[i][j];\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<=n;j++){\\n                for(int k=0;k<m;k++){\\n                    int sum=0;\\n                    for(int l=k;l<m;l++){\\n                        sum+=temp[j][l]-temp[i][l];\\n                        if(sum==target){\\n                            // cout<<j<<\" \"<<i<<\" \"<<k<<endl;\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n# **Please Share and Upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size(),m=matrix[0].size(),count=0;\\n        vector<vector<int>>temp(n+1,vector<int>(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp[i+1][j]=temp[i][j]+matrix[i][j];\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<=n;j++){\\n                for(int k=0;k<m;k++){\\n                    int sum=0;\\n                    for(int l=k;l<m;l++){\\n                        sum+=temp[j][l]-temp[i][l];\\n                        if(sum==target){\\n                            // cout<<j<<\" \"<<i<<\" \"<<k<<endl;\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1162721,
                "title": "python-go-o-w-2-h-by-prefix-sum-w-hint",
                "content": "Python O(w^2 * h)  by prefix sum\\n\\n---\\n\\n**Hint**:\\n\\nThis is **2D extented version** of [Leetcode 560 Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)\\n\\nThe concept of **prefix sum** and **dictionary** technique can be used again to help us.\\n\\n---\\n\\n**Implementation** by dictionary in Python\\n\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        \\n        # height and width of matrix\\n        h, w = len(matrix), len(matrix[0])\\n        \\n\\t\\t\\n        # update prefix sum on each row\\n        for y in range(h):\\n            for x in range(1,w):\\n                matrix[y][x] = matrix[y][x] + matrix[y][x-1]\\n                \\n        \\n        # number of submatrices that sum to target\\n        counter = 0\\n        \\n        # sliding windows on x-axis, in range [left, right]\\n        for left in range(w):\\n            for right in range(left, w):\\n                \\n                # accumulation of area so far\\n                accumulation = {0: 1}\\n                \\n                # area of current submatrices, bounded by [left, right] with height y\\n                area = 0\\n                \\n                # scan each possible height on y-axis\\n                for y in range(h):\\n                    \\n                    if left > 0:\\n                        area += matrix[y][right] - matrix[y][left-1]\\n                    \\n                    else:\\n                        area += matrix[y][right]\\n                    \\n                    # if ( area - target ) exist, then target must exist in submatrices\\n                    counter += accumulation.get( area - target, 0)\\n                    \\n                    # update dictionary with current accumulation area\\n                    accumulation[area] = accumulation.get(area, 0) + 1\\n        \\n        return counter\\n```\\n\\n---\\n\\n**Implementatin** by map in Go\\n\\n```\\nfunc numSubmatrixSumTarget(matrix [][]int, target int) int {\\n    \\n    // height and width of matrix\\n    h, w := len(matrix), len(matrix[0])\\n    \\n    // update prefix sum on each row\\n    for y := 0 ; y < h ; y++{\\n        for x:= 1 ; x < w; x++{\\n            matrix[y][x] = matrix[y][x] + matrix[y][x-1]\\n        }\\n    }\\n    \\n    // number of submatrices that sum to target\\n    counter := 0\\n    \\n    // sliding windows on x-axis, in range[left, right]\\n    for left := 0 ; left < w ; left ++{\\n        for right := left ; right < w ; right++{\\n            \\n            // accumulation for area so far\\n            accumulation := map[int]int{ 0 : 1}\\n            \\n            // area of current submatrices, bounded by [left, right] with height y\\n            area := 0\\n            \\n            // scan each possible height on y-axis\\n            for y := 0 ; y < h ; y++{\\n                \\n                if left > 0 {\\n                    area += matrix[y][right] - matrix[y][left-1]\\n                }else{\\n                    area += matrix[y][right]\\n                }\\n                \\n                // if ( area - target ) exists, then target must exist in submatrices\\n                counter += accumulation[ (area - target) ]\\n                \\n                // update dictionary with current accumulation area\\n                accumulation[area] += 1\\n                \\n            }\\n            \\n        }//end of right loop\\n        \\n    }//end of left loop\\n    \\n    return counter\\n    \\n}\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[1]  [Leetcode 560 Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about dictioanry](https://docs.python.org/3/tutorial/datastructures.html#dictionaries)\\n\\n[2] [Golang official docs about map[]](https://blog.golang.org/maps)\\n\\n[3] [Wiki: prefix sum](https://en.wikipedia.org/wiki/Prefix_sum)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        \\n        # height and width of matrix\\n        h, w = len(matrix), len(matrix[0])\\n        \\n\\t\\t\\n        # update prefix sum on each row\\n        for y in range(h):\\n            for x in range(1,w):\\n                matrix[y][x] = matrix[y][x] + matrix[y][x-1]\\n                \\n        \\n        # number of submatrices that sum to target\\n        counter = 0\\n        \\n        # sliding windows on x-axis, in range [left, right]\\n        for left in range(w):\\n            for right in range(left, w):\\n                \\n                # accumulation of area so far\\n                accumulation = {0: 1}\\n                \\n                # area of current submatrices, bounded by [left, right] with height y\\n                area = 0\\n                \\n                # scan each possible height on y-axis\\n                for y in range(h):\\n                    \\n                    if left > 0:\\n                        area += matrix[y][right] - matrix[y][left-1]\\n                    \\n                    else:\\n                        area += matrix[y][right]\\n                    \\n                    # if ( area - target ) exist, then target must exist in submatrices\\n                    counter += accumulation.get( area - target, 0)\\n                    \\n                    # update dictionary with current accumulation area\\n                    accumulation[area] = accumulation.get(area, 0) + 1\\n        \\n        return counter\\n```\n```\\nfunc numSubmatrixSumTarget(matrix [][]int, target int) int {\\n    \\n    // height and width of matrix\\n    h, w := len(matrix), len(matrix[0])\\n    \\n    // update prefix sum on each row\\n    for y := 0 ; y < h ; y++{\\n        for x:= 1 ; x < w; x++{\\n            matrix[y][x] = matrix[y][x] + matrix[y][x-1]\\n        }\\n    }\\n    \\n    // number of submatrices that sum to target\\n    counter := 0\\n    \\n    // sliding windows on x-axis, in range[left, right]\\n    for left := 0 ; left < w ; left ++{\\n        for right := left ; right < w ; right++{\\n            \\n            // accumulation for area so far\\n            accumulation := map[int]int{ 0 : 1}\\n            \\n            // area of current submatrices, bounded by [left, right] with height y\\n            area := 0\\n            \\n            // scan each possible height on y-axis\\n            for y := 0 ; y < h ; y++{\\n                \\n                if left > 0 {\\n                    area += matrix[y][right] - matrix[y][left-1]\\n                }else{\\n                    area += matrix[y][right]\\n                }\\n                \\n                // if ( area - target ) exists, then target must exist in submatrices\\n                counter += accumulation[ (area - target) ]\\n                \\n                // update dictionary with current accumulation area\\n                accumulation[area] += 1\\n                \\n            }\\n            \\n        }//end of right loop\\n        \\n    }//end of left loop\\n    \\n    return counter\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 486864,
                "title": "c-short-easy-solution",
                "content": "```\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n        int count = 0;\\n        for(int L=0; L<cols; L++) {\\n            vector<int> running_rows(rows,0); //intialize the running row\\n            for(int R=L; R<cols; R++) { //calculate running rows sum\\n                for(int i=0; i<rows; i++) running_rows[i] += matrix[i][R]; \\n                int sum = 0;\\n                unordered_map<int, int> visited;\\n                for(int i=0; i<rows; i++) { //check for subarrays in every running row\\n                    visited[sum]++;\\n                    sum = sum + running_rows[i];\\n                    if(visited[sum - target]) \\n                        count += visited[sum - target];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```\\n\\nRuntime - O(cols^2 rows) i.e cubic runtime\\nSpace - O(rows)\\n\\nTo understand what are running rows, watch : https://www.youtube.com/watch?v=-FgseNO-6Gk\\nTo understand how I\\'m checking for subarrays in every single running row, try : https://leetcode.com/problems/subarray-sum-equals-k/ or check out this video on youtube to understand the solution https://www.youtube.com/watch?v=AmlVSNBHzJg",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n        int count = 0;\\n        for(int L=0; L<cols; L++) {\\n            vector<int> running_rows(rows,0); //intialize the running row\\n            for(int R=L; R<cols; R++) { //calculate running rows sum\\n                for(int i=0; i<rows; i++) running_rows[i] += matrix[i][R]; \\n                int sum = 0;\\n                unordered_map<int, int> visited;\\n                for(int i=0; i<rows; i++) { //check for subarrays in every running row\\n                    visited[sum]++;\\n                    sum = sum + running_rows[i];\\n                    if(visited[sum - target]) \\n                        count += visited[sum - target];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 336388,
                "title": "java-o-n-3-with-detailed-explanation-step-by-step",
                "content": "* The idea is to fix the left and right columns one by one and count sub-arrays for every left and right column pair. Calculate sum of elements in every row from left to right and store these sums in an array say temp[]. So temp[i] indicates sum of elements from left to right in row i.\\n\\n* Count sub-arrays in temp[] having sum equal to  target. This count is the number of sub-matrices having sum equal to  target with left and right as boundary columns. Sum up all the counts for each temp[] with different left and right column pairs.\\n\\n```\\nclass Solution {\\n    \\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        // Number of columns\\n        int n=matrix[0].length;\\n        // Number of rows\\n        int m=matrix.length;\\n        // store the total count of such sub matrices in result variable\\n        int result=0;\\n        \\n        // Fix the left boundary\\n        for(int left=0;left<n;left++){\\n            // Fix the right boundary\\n            int[] temp=new int[m];\\n            for(int right=left;right<n;right++){\\n                // Compute sum of row elements between the left and right boundary\\n                for(int k=0;k<m;k++){\\n                    temp[k]+=matrix[k][right];\\n                }\\n                // Check for target sum\\n                result+=subArraySumToTarget(temp,target);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    // Works in O(n)\\n    int subArraySumToTarget(int[] temp,int target){\\n        // Use a hashmap of running sum and frequency of that sum\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int runningSum=0;\\n        int count=0;\\n        map.put(0,1);\\n        for(int i=0;i<temp.length;i++){\\n            runningSum+=temp[i];\\n            if(map.containsKey(runningSum-target)){\\n                count+=map.get(runningSum-target);\\n            }\\n            map.put(runningSum,map.getOrDefault(runningSum,0)+1);\\n        }\\n        return count;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        // Number of columns\\n        int n=matrix[0].length;\\n        // Number of rows\\n        int m=matrix.length;\\n        // store the total count of such sub matrices in result variable\\n        int result=0;\\n        \\n        // Fix the left boundary\\n        for(int left=0;left<n;left++){\\n            // Fix the right boundary\\n            int[] temp=new int[m];\\n            for(int right=left;right<n;right++){\\n                // Compute sum of row elements between the left and right boundary\\n                for(int k=0;k<m;k++){\\n                    temp[k]+=matrix[k][right];\\n                }\\n                // Check for target sum\\n                result+=subArraySumToTarget(temp,target);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    // Works in O(n)\\n    int subArraySumToTarget(int[] temp,int target){\\n        // Use a hashmap of running sum and frequency of that sum\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int runningSum=0;\\n        int count=0;\\n        map.put(0,1);\\n        for(int i=0;i<temp.length;i++){\\n            runningSum+=temp[i];\\n            if(map.containsKey(runningSum-target)){\\n                count+=map.get(runningSum-target);\\n            }\\n            map.put(runningSum,map.getOrDefault(runningSum,0)+1);\\n        }\\n        return count;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297831,
                "title": "easy-prefix-sum-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int n,m;\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        n=matrix.size(),m=matrix[0].size();\\n        fun(matrix);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n               int si=i,sj=j;\\n               \\n                for(int p=si;p<n;p++){\\n                    for(int q=sj;q<m;q++){\\n                     \\n                        if(p==si && q==sj){\\n                           \\n                            ans+=(target==matrix[p][q])?1:0;\\n                        }else{\\n                          \\n                             ans+=(target==getans(si,sj,p,q))?1:0;\\n                        }\\n                    }\\n                }\\n               \\n            }\\n        }\\n        return ans;\\n    }\\n   void fun(vector<vector<int>>& matrix){\\n        dp[0][0]=matrix[0][0];      // Getting the sum of matrix from index(0,0) for every (i,j);\\n        for(int i=1;i<m;i++){\\n            dp[0][i]=(dp[0][i-1]+matrix[0][i]);\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]=(dp[i-1][0]+matrix[i][0]);\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]+matrix[i][j];\\n            }\\n        }\\n       \\n    }\\n    \\n  int getans(int si,int sj,int ei,int ej){\\n        if(si==0 && sj==0){\\n            return dp[ei][ej];\\n        }else if(si==0 && sj!=0){\\n            return dp[ei][ej]-dp[ei][sj-1];\\n        }else if(si!=0 && sj==0){\\n            return dp[ei][ej]-dp[si-1][ej];\\n        }else{\\n             return dp[ei][ej]-dp[ei][sj-1]-dp[si-1][ej]+dp[si-1][sj-1];\\n        }\\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int n,m;\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        n=matrix.size(),m=matrix[0].size();\\n        fun(matrix);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n               int si=i,sj=j;\\n               \\n                for(int p=si;p<n;p++){\\n                    for(int q=sj;q<m;q++){\\n                     \\n                        if(p==si && q==sj){\\n                           \\n                            ans+=(target==matrix[p][q])?1:0;\\n                        }else{\\n                          \\n                             ans+=(target==getans(si,sj,p,q))?1:0;\\n                        }\\n                    }\\n                }\\n               \\n            }\\n        }\\n        return ans;\\n    }\\n   void fun(vector<vector<int>>& matrix){\\n        dp[0][0]=matrix[0][0];      // Getting the sum of matrix from index(0,0) for every (i,j);\\n        for(int i=1;i<m;i++){\\n            dp[0][i]=(dp[0][i-1]+matrix[0][i]);\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]=(dp[i-1][0]+matrix[i][0]);\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]+matrix[i][j];\\n            }\\n        }\\n       \\n    }\\n    \\n  int getans(int si,int sj,int ei,int ej){\\n        if(si==0 && sj==0){\\n            return dp[ei][ej];\\n        }else if(si==0 && sj!=0){\\n            return dp[ei][ej]-dp[ei][sj-1];\\n        }else if(si!=0 && sj==0){\\n            return dp[ei][ej]-dp[si-1][ej];\\n        }else{\\n             return dp[ei][ej]-dp[ei][sj-1]-dp[si-1][ej]+dp[si-1][sj-1];\\n        }\\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297649,
                "title": "c-91-faster-easy-to-understand-have-a-look-explained",
                "content": "\\nclass Solution {\\npublic:\\n\\n    // this part you have already solve on leetcode here we are just solving famous leetcode problem number of subarrays with sum k\\n\\t// we are just converting this bigger problem into one of the most renowed problem\\n\\t\\t\\n\\t\\tint solve(vector<int>&nums,int k)\\n    {unordered_map<int,int>mp;\\n     int cs=0;\\n     int ans=0;\\n     for(int i=0;i<nums.size();++i)\\n     {\\n         cs+=nums[i];\\n         if(cs==k)\\n         {\\n            ans++; \\n         }\\n         if(mp.find(cs-k)!=mp.end())\\n         {\\n             ans+=mp[cs-k];\\n          \\n         }\\n         mp[cs]++;\\n     }\\n     return ans;\\n        \\n    }\\n    int numSubmatrixSumTarget(vector<vector<int>>& a, int t) {\\n         int ans=0;\\n        //we will actually work row wise because we already know  the problem to find number of subarray in a row with a given sum\\n        for(int srow=0;srow<a.size();++srow)\\n        {vector<int>v(a[0].size(),0);\\n            for(int crow =srow;crow<a.size();++crow)//crow-->currrow\\n            {\\n                // now storing sum in  a particular array\\n                for(int j=0;j<a[0].size();++j)\\n                {\\n                    v[j]+=a[crow][j];\\n                }\\n                ans+=solve(v,t);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n/*\\n**Taking an example**\\n**step 1--\\nsolving like this\\n1 1 1 1->srow v=> 1 1 1 1\\n1 1 1 1       v=> 2 2 2 2\\n1 1 1 1       v=> 3 3 3 3\\n1 1 1 1       v=> 4 4 4 4\\nstep 2--\\n1 1 1 1 \\n1 1 1 1=>srow v=> 1 1 1 1\\n1 1 1 1       v=> 2 2 2 2\\n1 1 1 1       v=> 3 3 3 3\\nstep 3--\\n1 1 1 1 \\n1 1 1 1\\n1 1 1 1  =>srow v=> 1 1 1 1    \\n1 1 1 1        v=> 2 2 2 2\\nstep 4--\\n1 1 1 1 \\n1 1 1 1\\n1 1 1 1  \\n1 1 1 1   =>srow v=> 1 1 1 1    \\nevery time  we are calculating the cumulative sum starting from the srow index\\nand you will get your ans**\\n*/\\n**Upvote if it helped**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    // this part you have already solve on leetcode here we are just solving famous leetcode problem number of subarrays with sum k\\n\\t// we are just converting this bigger problem into one of the most renowed problem\\n\\t\\t\\n\\t\\tint solve(vector<int>&nums,int k)\\n    {unordered_map<int,int>mp;\\n     int cs=0;\\n     int ans=0;\\n     for(int i=0;i<nums.size();++i)\\n     {\\n         cs+=nums[i];\\n         if(cs==k)\\n         {\\n            ans++; \\n         }",
                "codeTag": "Java"
            },
            {
                "id": 303755,
                "title": "java-simple-solution-with-explanation",
                "content": "* Counting all sub-arrays with a given sum k for 1-Dimensional array can be used to reduce the time complexity.\\n* We fix the left and right columns one by one and count sub-arrays for every left and right column pair.\\n* The sum of elements in every row from left to right and store these sums in a temporary array say temp[].\\n* So temp[i] indicates sum of elements from left to right in row i.\\n* Count sub-arrays in temp[] having sum k.\\n* Sum up all the counts for each temp[] with different left and right column pairs.\\n```\\npublic int numSubmatrixSumTarget(int[][] matrix, int target) {\\n\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n\\n        int[] temp = new int[m];\\n        int ans=0;\\n        for (int left = 0;left<n;left++) {\\n            Arrays.fill(temp,0);\\n            for (int right=left;right<n;right++) {\\n                for (int i=0;i<m;i++) {\\n                    temp[i]+=matrix[i][right];\\n                }\\n                ans+= subCount(temp,target);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int subCount(int[] temp,int target) {\\n        HashMap<Integer, Integer> prevSum = new HashMap<>();\\n\\n        int res = 0;\\n        int currentSum = 0;\\n\\n        for (int t : temp) {\\n\\n            currentSum += t;\\n            if (currentSum == target) {\\n                res++;\\n            }\\n            if (prevSum.containsKey(currentSum - target)) {\\n                res += prevSum.get(currentSum - target);\\n            }\\n            prevSum.merge(currentSum, 1, (a, b) -> a + b);\\n        }\\n\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numSubmatrixSumTarget(int[][] matrix, int target) {\\n\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n\\n        int[] temp = new int[m];\\n        int ans=0;\\n        for (int left = 0;left<n;left++) {\\n            Arrays.fill(temp,0);\\n            for (int right=left;right<n;right++) {\\n                for (int i=0;i<m;i++) {\\n                    temp[i]+=matrix[i][right];\\n                }\\n                ans+= subCount(temp,target);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int subCount(int[] temp,int target) {\\n        HashMap<Integer, Integer> prevSum = new HashMap<>();\\n\\n        int res = 0;\\n        int currentSum = 0;\\n\\n        for (int t : temp) {\\n\\n            currentSum += t;\\n            if (currentSum == target) {\\n                res++;\\n            }\\n            if (prevSum.containsKey(currentSum - target)) {\\n                res += prevSum.get(currentSum - target);\\n            }\\n            prevSum.merge(currentSum, 1, (a, b) -> a + b);\\n        }\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2298375,
                "title": "c-easy-to-understand-explained-prefix-map",
                "content": "HOPE IT HELPS...\\n\\nCODE : \\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& mat, int target) {\\n        int r,c;\\n        r = mat.size();\\n        c = mat[0].size();\\n        int prefix[r+1][c];\\n        prefix[r-1][c-1] = mat[r-1][c-1];\\n        prefix[r][c-1] = 0;\\n        for(int i = c-2 ; i >= 0 ; i--)\\n        {\\n            prefix[r-1][i] = prefix[r-1][i+1] + mat[r-1][i];\\n            prefix[r][i] = 0;\\n        }\\n        for(int j = r-2 ; j >= 0 ; j--)\\n            prefix[j][c-1] = prefix[j+1][c-1] + mat[j][c-1];\\n        for(int i = r-2 ; i >= 0 ; i--)\\n            for(int j = c-2 ; j >= 0 ;j--)\\n                prefix[i][j] = prefix[i+1][j] + prefix[i][j+1] - prefix[i+1][j+1] + mat[i][j];\\n      \\n        int cnt = 0;\\n        for(int i = 0 ; i < r ; i++)\\n        {\\n            for(int j = i+1; j <= r ; j++)\\n            {\\n                map<int , int> mp;\\n                mp[0] = 1;\\n                for(int k = c-1 ; k >= 0 ; k--)\\n                {\\n                    int sum = prefix[i][k] - prefix[j][k];\\n                    int reqSum = sum - target;\\n                    cnt += mp[reqSum];\\n                    mp[sum]++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\nEXPLANATION (By pictures)  : \\n![image](https://assets.leetcode.com/users/images/21d220cd-db50-4c51-9fd6-5b8648c51c84_1658128270.3572967.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/853219d3-7a98-4747-83db-7bcd862483e7_1658128300.1421673.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/981838f9-f919-4724-bc0e-74267d482c7f_1658128331.2134755.jpeg)\\n\\nCOMPLEXITY : \\n\\n\\n![image](https://assets.leetcode.com/users/images/81f93fd5-cc8e-4954-9a9a-5d771219c759_1658128365.2356606.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& mat, int target) {\\n        int r,c;\\n        r = mat.size();\\n        c = mat[0].size();\\n        int prefix[r+1][c];\\n        prefix[r-1][c-1] = mat[r-1][c-1];\\n        prefix[r][c-1] = 0;\\n        for(int i = c-2 ; i >= 0 ; i--)\\n        {\\n            prefix[r-1][i] = prefix[r-1][i+1] + mat[r-1][i];\\n            prefix[r][i] = 0;\\n        }\\n        for(int j = r-2 ; j >= 0 ; j--)\\n            prefix[j][c-1] = prefix[j+1][c-1] + mat[j][c-1];\\n        for(int i = r-2 ; i >= 0 ; i--)\\n            for(int j = c-2 ; j >= 0 ;j--)\\n                prefix[i][j] = prefix[i+1][j] + prefix[i][j+1] - prefix[i+1][j+1] + mat[i][j];\\n      \\n        int cnt = 0;\\n        for(int i = 0 ; i < r ; i++)\\n        {\\n            for(int j = i+1; j <= r ; j++)\\n            {\\n                map<int , int> mp;\\n                mp[0] = 1;\\n                for(int k = c-1 ; k >= 0 ; k--)\\n                {\\n                    int sum = prefix[i][k] - prefix[j][k];\\n                    int reqSum = sum - target;\\n                    cnt += mp[reqSum];\\n                    mp[sum]++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492231,
                "title": "java-o-r-r-c-or-o-c-c-r-solution",
                "content": "* Convert it to 1-D array, then the problem turns into \"search for subarray sums that equal to the target\", which uses hashmap to track prefix sum count during iteration.\\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int res = 0, r = matrix.length, c = matrix[0].length;\\n        \\n        for (int i = 0; i < c; i++) {\\n            int[] rowSums = new int[r];\\n            for (int j = i; j < c; j++) {\\n                Map<Integer, Integer> count = new HashMap<>();\\n                count.put(0, 1);\\n                int prefixSum = 0;\\n                for (int k = 0; k < r; k++) {\\n                    rowSums[k] += matrix[k][j];\\n                    prefixSum += rowSums[k];\\n                    res += count.getOrDefault(prefixSum - target, 0);\\n                    count.put(prefixSum, count.getOrDefault(prefixSum, 0) + 1);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int res = 0, r = matrix.length, c = matrix[0].length;\\n        \\n        for (int i = 0; i < c; i++) {\\n            int[] rowSums = new int[r];\\n            for (int j = i; j < c; j++) {\\n                Map<Integer, Integer> count = new HashMap<>();\\n                count.put(0, 1);\\n                int prefixSum = 0;\\n                for (int k = 0; k < r; k++) {\\n                    rowSums[k] += matrix[k][j];\\n                    prefixSum += rowSums[k];\\n                    res += count.getOrDefault(prefixSum - target, 0);\\n                    count.put(prefixSum, count.getOrDefault(prefixSum, 0) + 1);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300524,
                "title": "c-o-n-4-time-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int n = matrix.size(), m = matrix[0].size(), ans = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                \\n                vector<int>tmp(m, 0);\\n                for(int k=i; k<n; k++){\\n                    int s = 0;\\n                    for(int l=j; l<m; l++){\\n                        s += matrix[k][l];\\n                        tmp[l] += s;\\n                        if(tmp[l]==target)\\n                            ans++;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nComplextiy:\\n\\u2981\\tTime: O((m*n)^2)\\n\\u2981\\tSpace: O(n)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int n = matrix.size(), m = matrix[0].size(), ans = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                \\n                vector<int>tmp(m, 0);\\n                for(int k=i; k<n; k++){\\n                    int s = 0;\\n                    for(int l=j; l<m; l++){\\n                        s += matrix[k][l];\\n                        tmp[l] += s;\\n                        if(tmp[l]==target)\\n                            ans++;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298094,
                "title": "c-hashmap-easy-understandable",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n        int res = 0, m = A.size(), n = A[0].size();\\n\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t\\tfor (int j = 1; j < n; j++)\\n\\t\\t\\t\\tA[i][j] += A[i][j - 1];\\n\\n\\t\\tunordered_map<int, int> counter;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tfor (int j = i; j < n; j++) {\\n\\t\\t\\t\\tcounter = {{0,1}};\\n\\t\\t\\t\\tint cur = 0;\\n\\t\\t\\t\\tfor (int k = 0; k < m; k++) {\\n\\t\\t\\t\\t  cur += A[k][j] - (i > 0 ? A[k][i - 1] : 0);\\n\\t\\t\\t\\t  res += counter.find(cur - target) != counter.end() ? counter[cur - target] : 0;\\n\\t\\t\\t\\t  counter[cur]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n        int res = 0, m = A.size(), n = A[0].size();\\n\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t\\tfor (int j = 1; j < n; j++)\\n\\t\\t\\t\\tA[i][j] += A[i][j - 1];\\n\\n\\t\\tunordered_map<int, int> counter;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tfor (int j = i; j < n; j++) {\\n\\t\\t\\t\\tcounter = {{0,1}};\\n\\t\\t\\t\\tint cur = 0;\\n\\t\\t\\t\\tfor (int k = 0; k < m; k++) {\\n\\t\\t\\t\\t  cur += A[k][j] - (i > 0 ? A[k][i - 1] : 0);\\n\\t\\t\\t\\t  res += counter.find(cur - target) != counter.end() ? counter[cur - target] : 0;\\n\\t\\t\\t\\t  counter[cur]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747611,
                "title": "c-prefix-sum-subarray-sum-based-explanation",
                "content": "The problem can be reduced to finding subarray sum in a 1D array with target value. We can find the 1D subarray sum for each combination of rows and then each subarray sum takes O(n) which makes the total time complexity O(n^3) since there will be n^2 combinations of rows.\\n\\nFirst we calculate the row prefix sum for the matrix so that each time we need to find the elements of rows r1 to r2 we can get it in O(n) since we won\\'t need to sum all the elements in the row range again. And the sum of that row range can be calculated as sum[r2] - sum[r1-1]. \\nFor Example1 the row prefix sum matrix would be: \\n```\\n0 1 0                                          0 1 0\\n1 1 1                 =>                       1 2 1\\n0 1 0                                          1 3 1\\n\\nRange [1,2] would sum to: [1 3 1]-[0 1 0] = [1 2 1] in the original matrix.\\n```\\nAnd then we can find the subarray sum equal to target in the above formed 1D array in linear time. For this refer [@560](https://leetcode.com/problems/subarray-sum-equals-k). And in the above 1D array any subarray sum from index l,r would correspond to sum of submatrix having upper left as [r1,l] and lower right as [r2,r]. Thus we can just find the subarray sum for a 1D array for each combination of rows and we would be covering all the possible submatrices.\\n\\n**Implementation:**\\n\\n```\\nclass Solution {\\npublic:\\n    int checksub(vector<vector<int>>& matrix,int r1,int r2,int target){\\n        unordered_map<int,int> m;\\n        int curr=0,ans=0;\\n        m[0]=1;\\n\\t\\t//  ith element of 1D array = matrix[r2][i]-matrix[r1-1][i]\\n        for(int i=0;i<matrix[0].size();i++){                  \\n            if(r1>0)                    \\n                curr+=matrix[r2][i]-matrix[r1-1][i];\\n            else\\n                curr+=matrix[r2][i];\\n            \\n            if(m.find(curr-target)!=m.end())\\n                ans+=m[curr-target];\\n            m[curr]++;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        \\n        int m=matrix.size(),n=matrix[0].size();\\n        if(m==0 || n==0)\\n            return 0;\\n        vector<vector<int>> dp(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++)       // Creating row prefix sum matrix\\n            for(int j=0;j<n;j++){\\n                if(i>0)\\n                    matrix[i][j]+=matrix[i-1][j];\\n            }\\n        int ans=0;\\n        for(int i=0;i<m;i++)     // For each row pair find 1D subarray sum with target\\n            for(int j=i;j<m;j++)  \\n                ans+=checksub(matrix,i,j,target);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n0 1 0                                          0 1 0\\n1 1 1                 =>                       1 2 1\\n0 1 0                                          1 3 1\\n\\nRange [1,2] would sum to: [1 3 1]-[0 1 0] = [1 2 1] in the original matrix.\\n```\n```\\nclass Solution {\\npublic:\\n    int checksub(vector<vector<int>>& matrix,int r1,int r2,int target){\\n        unordered_map<int,int> m;\\n        int curr=0,ans=0;\\n        m[0]=1;\\n\\t\\t//  ith element of 1D array = matrix[r2][i]-matrix[r1-1][i]\\n        for(int i=0;i<matrix[0].size();i++){                  \\n            if(r1>0)                    \\n                curr+=matrix[r2][i]-matrix[r1-1][i];\\n            else\\n                curr+=matrix[r2][i];\\n            \\n            if(m.find(curr-target)!=m.end())\\n                ans+=m[curr-target];\\n            m[curr]++;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        \\n        int m=matrix.size(),n=matrix[0].size();\\n        if(m==0 || n==0)\\n            return 0;\\n        vector<vector<int>> dp(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++)       // Creating row prefix sum matrix\\n            for(int j=0;j<n;j++){\\n                if(i>0)\\n                    matrix[i][j]+=matrix[i-1][j];\\n            }\\n        int ans=0;\\n        for(int i=0;i<m;i++)     // For each row pair find 1D subarray sum with target\\n            for(int j=i;j<m;j++)  \\n                ans+=checksub(matrix,i,j,target);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2533076,
                "title": "java-using-hashmap",
                "content": "```\\nclass Solution {\\n\\tpublic int numSubmatrixSumTarget(int[][] arr, int target) {\\n\\t\\tint n = arr.length;\\n\\t\\tint m = arr[0].length;\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint[] temp = new int[m];\\n\\t\\t\\tfor (int row = i; row < n; row++) {\\n\\t\\t\\t\\tfor (int col = 0; col < m; col++) {\\n\\t\\t\\t\\t\\ttemp[col] += arr[row][col];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcount += helper(temp, target);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n\\n\\tpublic int helper(int[] arr, int target) {\\n\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\tmap.put(0, 1);\\n\\t\\tint count = 0, sum = 0;\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tsum += arr[i];\\n\\t\\t\\tcount += map.getOrDefault(sum - target, 0);\\n\\t\\t\\tmap.put(sum, map.getOrDefault(sum, 0) + 1);\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic int numSubmatrixSumTarget(int[][] arr, int target) {\\n\\t\\tint n = arr.length;\\n\\t\\tint m = arr[0].length;\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint[] temp = new int[m];\\n\\t\\t\\tfor (int row = i; row < n; row++) {\\n\\t\\t\\t\\tfor (int col = 0; col < m; col++) {\\n\\t\\t\\t\\t\\ttemp[col] += arr[row][col];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcount += helper(temp, target);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n\\n\\tpublic int helper(int[] arr, int target) {\\n\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\tmap.put(0, 1);\\n\\t\\tint count = 0, sum = 0;\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tsum += arr[i];\\n\\t\\t\\tcount += map.getOrDefault(sum - target, 0);\\n\\t\\t\\tmap.put(sum, map.getOrDefault(sum, 0) + 1);\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300710,
                "title": "very-easy-explanation-solution-subarray-sum-equal-to-k",
                "content": "Before you go with this problem I will suggest you to first solve [Subarray Sum Equal to K](https://leetcode.com/problems/subarray-sum-equals-k/). This problem is quite modified version of that problem. Upvote if you like it.\\n\\n\\n**Approach**\\nFirst we will find the subarrays that contribute to sum equal to target, considering each row.\\n\\n| a | b | c | ------------------row1 \\n| d | e | f  | ------------------row2\\n| g | h | i  |-------------------row3\\n\\n\\n\\nCombine consecutive rows and find answer again, as submatrix can also combination of two or more rows.\\n\\n| a          | b           | c        |            ------find for this\\n| d+a      | e+b      | f+c     |             -----find for this row\\n| g+d+a  | h+e+b | i+f+c   |             ------find for this row\\n\\nsimilarly,\\n\\n| d     | e      | f     |                    -----for this row\\n| g+d | h+e  | i+f  |                    -----for this row\\n\\nand,\\n| g | h | i  |                                -----for this row\\n\\n\\nadd the answers of all these rows, and have the final answer,\\n\\n\\n**My Solution**\\n```\\nclass Solution {\\npublic:\\n    int sumEqualToK(vector<int>& nums, int k)\\n    {\\n        unordered_map<int,int> mp;\\n        mp[0] =1;\\n        int sum = 0,ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum += nums[i];\\n            ans += mp[sum-k];   \\n            mp[sum]++;\\n        }\\n        return ans;\\n    }\\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int count=0;\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            vector<int> prefSum(matrix[i].size(),0);\\n            for(int j=i;j<matrix.size();j++)\\n            {\\n                for(int k=0;k<matrix[j].size();k++)\\n                {\\n                    prefSum[k] += matrix[j][k];\\n                }\\n                count += sumEqualToK(prefSum, target);\\n\\n            }  \\n        }\\n        return count;\\n        \\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumEqualToK(vector<int>& nums, int k)\\n    {\\n        unordered_map<int,int> mp;\\n        mp[0] =1;\\n        int sum = 0,ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum += nums[i];\\n            ans += mp[sum-k];   \\n            mp[sum]++;\\n        }\\n        return ans;\\n    }\\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int count=0;\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            vector<int> prefSum(matrix[i].size(),0);\\n            for(int j=i;j<matrix.size();j++)\\n            {\\n                for(int k=0;k<matrix[j].size();k++)\\n                {\\n                    prefSum[k] += matrix[j][k];\\n                }\\n                count += sumEqualToK(prefSum, target);\\n\\n            }  \\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297893,
                "title": "brute-force-and-optimised-number-of-submatrices-that-sum-to-target",
                "content": "From Bruteforce to optimised code.\\n**Brute force code(TLE)**\\nSimply check sum of all possible (x1, y1), (x2, y2) pairs in matrix.\\nWe can easily optmise this using prefix 2 D array\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size(), m = matrix[0].size();\\n\\n        vector<vector<int>>pre(n + 1, vector<int>(m + 1, 0));\\n\\n        for(int i = 1; i<=n; i++)\\n            for(int j = 1; j<=m; j++)\\n                pre[i][j] += pre[i-1][j] + pre[i][j-1] - pre[i-1][j-1] + matrix[i-1][j-1];\\n\\n        int cnt = 0;\\n\\n        for(int i = 1; i<=n; i++) {\\n            for(int j = 1; j<=m; j++) {\\n                for(int k = i; k <= n; k++) {\\n                    for(int l = j; l <=m; l++) {\\n                        if(pre[k][l] - pre[k][j-1] - pre[i - 1][l] + pre[i - 1][j - 1] == target) {\\n                            cout << k << \" \" << l << \" \" << i << \" \" << j << \"\\\\n\";\\n                            cnt++;\\n                        }\\n                    }\\n                }\\n            }\\n        }      \\n\\n        return cnt;\\n    }\\n};\\n```\\nBut this code leads to TLE since it is O(N^4)\\n\\n**Optimised approach**\\nWe can iterate over all column pairs and store the prefix sum of rows between two columns.\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size(), m = matrix[0].size();\\n\\n        vector<vector<int>>pre(n + 1, vector<int>(m + 1, 0));\\n\\n        for(int i = 1; i<=n; i++)\\n            for(int j = 1; j<=m; j++)\\n                pre[i][j] = matrix[i-1][j-1] + pre[i][j-1];\\n\\n\\n        unordered_map<int, int>hsh;\\n        int res = 0;\\n\\n        for(int col1 = 1; col1 <= m; col1++) {\\n            for(int col2 = col1; col2 <= m; col2++) {\\n                hsh = {{0, 1}};\\n                int curr = 0;\\n                for(int row = 1; row <= n; row++) {\\n                    curr += pre[row][col2] - pre[row][col1 - 1];\\n                    if(hsh.count(curr - target))\\n                        res += hsh[curr - target];\\n                    hsh[curr]++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nTime Complexity: O(N^3)\\n\\nThank You \\u2764\\uFE0F",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size(), m = matrix[0].size();\\n\\n        vector<vector<int>>pre(n + 1, vector<int>(m + 1, 0));\\n\\n        for(int i = 1; i<=n; i++)\\n            for(int j = 1; j<=m; j++)\\n                pre[i][j] += pre[i-1][j] + pre[i][j-1] - pre[i-1][j-1] + matrix[i-1][j-1];\\n\\n        int cnt = 0;\\n\\n        for(int i = 1; i<=n; i++) {\\n            for(int j = 1; j<=m; j++) {\\n                for(int k = i; k <= n; k++) {\\n                    for(int l = j; l <=m; l++) {\\n                        if(pre[k][l] - pre[k][j-1] - pre[i - 1][l] + pre[i - 1][j - 1] == target) {\\n                            cout << k << \" \" << l << \" \" << i << \" \" << j << \"\\\\n\";\\n                            cnt++;\\n                        }\\n                    }\\n                }\\n            }\\n        }      \\n\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size(), m = matrix[0].size();\\n\\n        vector<vector<int>>pre(n + 1, vector<int>(m + 1, 0));\\n\\n        for(int i = 1; i<=n; i++)\\n            for(int j = 1; j<=m; j++)\\n                pre[i][j] = matrix[i-1][j-1] + pre[i][j-1];\\n\\n\\n        unordered_map<int, int>hsh;\\n        int res = 0;\\n\\n        for(int col1 = 1; col1 <= m; col1++) {\\n            for(int col2 = col1; col2 <= m; col2++) {\\n                hsh = {{0, 1}};\\n                int curr = 0;\\n                for(int row = 1; row <= n; row++) {\\n                    curr += pre[row][col2] - pre[row][col1 - 1];\\n                    if(hsh.count(curr - target))\\n                        res += hsh[curr - target];\\n                    hsh[curr]++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 816242,
                "title": "o-n-3-solution-c-approach-fully-explained-must-watch",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n    \\n    APPROACH :\\n    \\n    GIVEN ARRAY\\n    \\n    0 1 0\\n    1 1 1\\n    0 1 0\\n    \\n    no of rows(m) = 3;\\n    no of cols(n) = 4;\\n    \\n    First construct a prefix sum array of size {m+1 , n}\\n    \\n    And calculate prefix sum for every column\\n    \\n    Prefix Sum array\\n    0 0 0\\n    0 1 0\\n    1 2 1\\n    1 3 1\\n    \\n    Now for each row\\n    \\n        We search for all the downward sub matrics end {i,j}\\n        here i>=row and i<m\\n        and j>=0 and j<n\\n        \\n        we sum prefixSum[i+1][0] to prefixSum[i+1][j] to calulate sum of all the elements from (0,0) to (i,j) (Let Say sum)\\n        we sum prefixSum[row][0] to prefixSum[row][j] to calulate sum of all the elements from (0,0) to (row-1,j) (Let Say Subsum)\\n        \\n        for each j\\n            if we subtract sum = (sum- Subsum), we get sum of all the elements from (row,0) to (i,j)\\n            \\n            if(sum=target) in increase the counter\\n            \\n            for for this sum we check if (sum-target) exists in the map or not;\\n            if exsits we can confirm that how many times we have encountered an l (0<l<j) \\n                Such that\\n                    sum of all the elements from (row,0) to (i,l) is (sum-target)\\n                    Which indirectly confirms sum of all the elements from (row,l+1) to (i,j) is target\\n                    \\n            Increase mp[sum] by 1\\n    \\n    \\n    */\\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        \\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        \\n        int pre[m+1][n];\\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<n;j++){\\n                pre[i][j]=0;\\n            }\\n        }\\n        \\n        for(int j=0;j<n;j++){\\n            for(int i=0;i<m;i++){\\n            \\n                pre[i+1][j]=pre[i][j]+matrix[i][j];\\n            }\\n        }\\n        \\n        unordered_map<int,int> mp;\\n        int cnt=0;\\n   /*     \\n    0 0 0\\n    0 1 0\\n    1 2 1\\n    0 3 0\\n    */\\n        \\n        for(int row =0 ; row<m; row++){\\n            \\n            for(int i=row; i<m;i++){\\n                mp.clear();\\n                int sum=0;\\n                for(int j=0; j<n;j++){\\n                     sum+= pre[i+1][j]-pre[row][j];\\n                    if(sum==target)\\n                        cnt++;\\n                    if(mp.find(sum-target)!=mp.end()){\\n                        cnt+=mp[sum-target];\\n                    }\\n                    mp[sum]++;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    \\n    APPROACH :\\n    \\n    GIVEN ARRAY\\n    \\n    0 1 0\\n    1 1 1\\n    0 1 0\\n    \\n    no of rows(m) = 3;\\n    no of cols(n) = 4;\\n    \\n    First construct a prefix sum array of size {m+1 , n}\\n    \\n    And calculate prefix sum for every column\\n    \\n    Prefix Sum array\\n    0 0 0\\n    0 1 0\\n    1 2 1\\n    1 3 1\\n    \\n    Now for each row\\n    \\n        We search for all the downward sub matrics end {i,j}\\n        here i>=row and i<m\\n        and j>=0 and j<n\\n        \\n        we sum prefixSum[i+1][0] to prefixSum[i+1][j] to calulate sum of all the elements from (0,0) to (i,j) (Let Say sum)\\n        we sum prefixSum[row][0] to prefixSum[row][j] to calulate sum of all the elements from (0,0) to (row-1,j) (Let Say Subsum)\\n        \\n        for each j\\n            if we subtract sum = (sum- Subsum), we get sum of all the elements from (row,0) to (i,j)\\n            \\n            if(sum=target) in increase the counter\\n            \\n            for for this sum we check if (sum-target) exists in the map or not;\\n            if exsits we can confirm that how many times we have encountered an l (0<l<j) \\n                Such that\\n                    sum of all the elements from (row,0) to (i,l) is (sum-target)\\n                    Which indirectly confirms sum of all the elements from (row,l+1) to (i,j) is target\\n                    \\n            Increase mp[sum] by 1\\n    \\n    \\n    */\\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        \\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        \\n        int pre[m+1][n];\\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<n;j++){\\n                pre[i][j]=0;\\n            }\\n        }\\n        \\n        for(int j=0;j<n;j++){\\n            for(int i=0;i<m;i++){\\n            \\n                pre[i+1][j]=pre[i][j]+matrix[i][j];\\n            }\\n        }\\n        \\n        unordered_map<int,int> mp;\\n        int cnt=0;\\n   /*     \\n    0 0 0\\n    0 1 0\\n    1 2 1\\n    0 3 0\\n    */\\n        \\n        for(int row =0 ; row<m; row++){\\n            \\n            for(int i=row; i<m;i++){\\n                mp.clear();\\n                int sum=0;\\n                for(int j=0; j<n;j++){\\n                     sum+= pre[i+1][j]-pre[row][j];\\n                    if(sum==target)\\n                        cnt++;\\n                    if(mp.find(sum-target)!=mp.end()){\\n                        cnt+=mp[sum-target];\\n                    }\\n                    mp[sum]++;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 800988,
                "title": "javascript-2d-prefix-sums-clean-and-simple",
                "content": "```js\\nvar numSubmatrixSumTarget = function(matrix, target) {\\n    const prefixSums = new Array(matrix.length + 1)\\n        .fill()\\n        .map(() => new Array(matrix[0].length + 1).fill(0));\\n    \\n    for (let i = 1; i <= matrix.length; i++) {\\n        for (let j = 1; j <= matrix[0].length; j++) {\\n            prefixSums[i][j] = matrix[i-1][j-1] + prefixSums[i-1][j] + prefixSums[i][j-1] - prefixSums[i-1][j-1];\\n        }\\n    }\\n    \\n    let count = 0;\\n    for (let r1 = 1; r1 <= matrix.length; r1++) {\\n        for (let r2 = r1; r2 <= matrix.length; r2++) {\\n            const counts = {};\\n            counts[0] = 1;\\n            for (let c = 1; c <= matrix[0].length; c++) {\\n                const sum = prefixSums[r2][c] - prefixSums[r1 - 1][c];\\n                count += counts[sum - target] || 0;\\n                counts[sum] = (counts[sum] || 0) + 1;\\n            }\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar numSubmatrixSumTarget = function(matrix, target) {\\n    const prefixSums = new Array(matrix.length + 1)\\n        .fill()\\n        .map(() => new Array(matrix[0].length + 1).fill(0));\\n    \\n    for (let i = 1; i <= matrix.length; i++) {\\n        for (let j = 1; j <= matrix[0].length; j++) {\\n            prefixSums[i][j] = matrix[i-1][j-1] + prefixSums[i-1][j] + prefixSums[i][j-1] - prefixSums[i-1][j-1];\\n        }\\n    }\\n    \\n    let count = 0;\\n    for (let r1 = 1; r1 <= matrix.length; r1++) {\\n        for (let r2 = r1; r2 <= matrix.length; r2++) {\\n            const counts = {};\\n            counts[0] = 1;\\n            for (let c = 1; c <= matrix[0].length; c++) {\\n                const sum = prefixSums[r2][c] - prefixSums[r1 - 1][c];\\n                count += counts[sum - target] || 0;\\n                counts[sum] = (counts[sum] || 0) + 1;\\n            }\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 693111,
                "title": "python-beat-97-25-easy-understanding",
                "content": "```\\nclass Solution(object):\\n    def numSubmatrixSumTarget(self, matrix, target):\\n        m = len(matrix[0])\\n        n = len(matrix)\\n        res = 0\\n        \\n        prefix = [[0] * m for _ in range(n)]\\n        \\n        \\n        for i in range(n):\\n            for j in range(m):\\n                if i == 0:\\n                    prefix[i][j] = matrix[i][j]\\n                else:\\n                    prefix[i][j] = matrix[i][j] + prefix[i-1][j]\\n        \\n        for i in range(n):\\n            for j in range(i, n):\\n                d = {0:1}\\n                cur = 0\\n                for k in range(m):\\n                    if i == 0:\\n                        cur += prefix[j][k]\\n                    else:\\n                        cur += prefix[j][k] - prefix[i-1][k]\\n                \\n                    if cur - target in d:\\n                        res += d[cur-target]\\n\\n                    if cur in d:\\n                        d[cur] += 1\\n                    else:\\n                        d[cur] = 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numSubmatrixSumTarget(self, matrix, target):\\n        m = len(matrix[0])\\n        n = len(matrix)\\n        res = 0\\n        \\n        prefix = [[0] * m for _ in range(n)]\\n        \\n        \\n        for i in range(n):\\n            for j in range(m):\\n                if i == 0:\\n                    prefix[i][j] = matrix[i][j]\\n                else:\\n                    prefix[i][j] = matrix[i][j] + prefix[i-1][j]\\n        \\n        for i in range(n):\\n            for j in range(i, n):\\n                d = {0:1}\\n                cur = 0\\n                for k in range(m):\\n                    if i == 0:\\n                        cur += prefix[j][k]\\n                    else:\\n                        cur += prefix[j][k] - prefix[i-1][k]\\n                \\n                    if cur - target in d:\\n                        res += d[cur-target]\\n\\n                    if cur in d:\\n                        d[cur] += 1\\n                    else:\\n                        d[cur] = 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 620241,
                "title": "cpp-brute-force-o-n-6-time-complexity-just-for-fun-time-limit-exceeds",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int sum(vector<vector<int>>& matrix, int i,int j,int k,int l){\\n        int s=0;\\n        for(int p=i;p<=k;p++){\\n            for(int q=j;q<=l;q++){\\n                s+=matrix[p][q];\\n            }\\n        }\\n        return s;\\n    }\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int c=0;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                for(int k=i;k<matrix.size();k++){\\n                    for(int l=j;l<matrix[k].size();l++){\\n                        if(sum(matrix,i,j,k,l)==target)\\n                            c++;\\n                    }\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int sum(vector<vector<int>>& matrix, int i,int j,int k,int l){\\n        int s=0;\\n        for(int p=i;p<=k;p++){\\n            for(int q=j;q<=l;q++){\\n                s+=matrix[p][q];\\n            }\\n        }\\n        return s;\\n    }\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int c=0;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                for(int k=i;k<matrix.size();k++){\\n                    for(int l=j;l<matrix[k].size();l++){\\n                        if(sum(matrix,i,j,k,l)==target)\\n                            c++;\\n                    }\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470445,
                "title": "python-solution-o-n-3-beats-98",
                "content": "This question is related to https://leetcode.com/problems/subarray-sum-equals-k/. We can use the same idea to find out the number of subarray with target sum for one row in linear time. Basically, we generate O(m^2) combinations of rows and apply O(n) algorithm to find the target sum for each combination. \\n\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        if not matrix:\\n            return 0\\n        \\n        def num_for_one_row(nums):\\n            prev = {}\\n            prev[0] = 1\\n            cur_sum = 0\\n            ans = 0\\n            for num in nums:\\n                cur_sum += num\\n                if cur_sum - target in prev:\\n                    ans += prev[cur_sum - target]\\n                if cur_sum not in prev:\\n                    prev[cur_sum] = 1\\n                else:\\n                    prev[cur_sum] += 1\\n            return ans \\n        \\n        res = 0\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n        for i in range(m):\\n            nums = [0]*n\\n            for j in range(i,m):\\n                for k in range(n):\\n                    nums[k]+=matrix[j][k]\\n                res += num_for_one_row(nums)\\n                \\n        return res\\n```\\n\\nIn this solution, the time complexity is O(m^2*n)  where m is the number of rows and n is the number of columns. The space complexity is O(n).",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        if not matrix:\\n            return 0\\n        \\n        def num_for_one_row(nums):\\n            prev = {}\\n            prev[0] = 1\\n            cur_sum = 0\\n            ans = 0\\n            for num in nums:\\n                cur_sum += num\\n                if cur_sum - target in prev:\\n                    ans += prev[cur_sum - target]\\n                if cur_sum not in prev:\\n                    prev[cur_sum] = 1\\n                else:\\n                    prev[cur_sum] += 1\\n            return ans \\n        \\n        res = 0\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n        for i in range(m):\\n            nums = [0]*n\\n            for j in range(i,m):\\n                for k in range(n):\\n                    nums[k]+=matrix[j][k]\\n                res += num_for_one_row(nums)\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298611,
                "title": "python-99-94-fastest",
                "content": "```\\ndef numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:    \\n        n,m = len(matrix),len(matrix[0])\\n        dp = [[0]*m for _ in range(n)]\\n        \\n        # make prefix sum for every row\\n        for i in range(n):\\n            for j in range(m):\\n                dp[i][j] = matrix[i][j] + (dp[i][j-1] if j-1>=0 else 0)\\n        # print(*dp,sep=\"\\\\n\")        \\n        ans = 0\\n        # for every column see row sum\\n        for i in range(m):\\n            for j in range(i,m):\\n                d = {0:1}\\n                s = 0\\n                for r in range(n):\\n                    s += dp[r][j] - (dp[r][i-1] if i-1>=0 else 0)\\n                    if s-target in d:\\n                        ans += d[s-target] \\n                        \\n                    if s in d:\\n                        d[s] += 1\\n                    else:\\n                        d[s] = 1\\n                        \\n        return ans\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\ndef numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:    \\n        n,m = len(matrix),len(matrix[0])\\n        dp = [[0]*m for _ in range(n)]\\n        \\n        # make prefix sum for every row\\n        for i in range(n):\\n            for j in range(m):\\n                dp[i][j] = matrix[i][j] + (dp[i][j-1] if j-1>=0 else 0)\\n        # print(*dp,sep=\"\\\\n\")        \\n        ans = 0\\n        # for every column see row sum\\n        for i in range(m):\\n            for j in range(i,m):\\n                d = {0:1}\\n                s = 0\\n                for r in range(n):\\n                    s += dp[r][j] - (dp[r][i-1] if i-1>=0 else 0)\\n                    if s-target in d:\\n                        ans += d[s-target] \\n                        \\n                    if s in d:\\n                        d[s] += 1\\n                    else:\\n                        d[s] = 1\\n                        \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2298559,
                "title": "python-prefix-sum-hashmap-with-explanation",
                "content": "To solve this probelm, let us solve [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/) at first.\\n\\n### 560. Subarray Sum Equals K\\nThe basic idea it to handle this problem with `hashmap`. The hashmap will store with the key being any particular `sum`, and the value being the number of time it has happened yet. Suppose we iterate the arrary from left to right and keep track of cumulative sum up to `i` in each position.\\n\\nIf there is an increase of `k` in `preSum[i]`, we can find `preSum[j] = preSum[i] + k`. (j > i)\\n\\nThe origin problem `find a subarry whose sum equals to k (preSum[j] - preSum[i])` can be changed to `find a subarray whose sum equals to preSum[i] (preSum[j] - k)`\\n\\nSo, the solution is here:\\n```python\\n```python\\nclass Solution:\\n    def subarraySum(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        pre_sum = 0\\n        res = defaultdict(int)\\n        res[0] = 1 # it means that we\\'ve already seen sum of 0 once before iterating the list.\\n        \\n        for num in nums:\\n            pre_sum += num\\n            ans += res[pre_sum - k]\\n            res[pre_sum] += 1\\n        return ans\\n```\\n\\n### 1074. Number of Submatrices That Sum to Target\\nActually, this problem is a variation of `560`. We enumerate the submatrixs by setting different `upper` and `lower` boundaries. Then we calculate the `sum` of each column. So the origin problem can be changed to:\\n- Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.\\n\\nFor the calculation of sum of each column, every time we extend lower boundary `j` downwards, the elements in the `jth` row of the matrix are added to the `sum`.\\n\\n```python\\nclass Solution:\\n    def numSubmatrixSumTarget(self, M: List[List[int]], T: int) -> int:\\n        def subarrSum(nums, target):\\n            res = defaultdict(int)\\n            res[0] = 1\\n            ans, pre_sum = 0, 0\\n            \\n            for num in nums:\\n                pre_sum += num\\n                ans += res[pre_sum - target]\\n                res[pre_sum] += 1\\n            return ans\\n                \\n                \\n        rows, cols = len(M), len(M[0])\\n        ans = 0\\n        for i1 in range(rows):\\n            total = [0]*cols\\n            for i2 in range(i1, rows):\\n                for j in range(cols):\\n                    total[j] += M[i2][j]\\n                ans += subarrSum(total, T)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```python\\n```\n```\\n\\n### 1074. Number of Submatrices That Sum to Target\\nActually, this problem is a variation of `560`. We enumerate the submatrixs by setting different `upper` and `lower` boundaries. Then we calculate the `sum` of each column. So the origin problem can be changed to:\\n- Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.\\n\\nFor the calculation of sum of each column, every time we extend lower boundary `j` downwards, the elements in the `jth` row of the matrix are added to the `sum`.\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2297678,
                "title": "91-faster-and-memory-efficient-solution",
                "content": "\\t\\n\\tclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n        ans = 0\\n        \\n        for i in range(m): # enum upper bound\\n            total = [0] * n\\n            \\n            for j in range(i, m): # enum lower bound\\n                for c in range(n):\\n                    # update each row\\'s sum\\n                    total[c] += matrix[j][c]\\n                    \\n                ans += self.subarrSum(total, target)\\n                \\n                \\n        return ans\\n    \\n    \\n    \\n    def subarrSum(self, nums, k):\\n        hashmap = defaultdict(int)\\n        hashmap[0] = 1\\n\\n        cnt = presum = 0\\n        for x in nums:\\n            presum += x \\n\\n            if presum - k in hashmap:\\n                cnt += hashmap[presum-k]\\n\\n            hashmap[presum] += 1\\n\\n        return cnt",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\t\\n\\tclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n        ans = 0\\n        \\n        for i in range(m): # enum upper bound\\n            total = [0] * n\\n            \\n            for j in range(i, m): # enum lower bound\\n                for c in range(n):\\n                    # update each row\\'s sum\\n                    total[c] += matrix[j][c]\\n                    \\n                ans += self.subarrSum(total, target)\\n                \\n                \\n        return ans\\n    \\n    \\n    \\n    def subarrSum(self, nums, k):\\n        hashmap = defaultdict(int)\\n        hashmap[0] = 1\\n\\n        cnt = presum = 0\\n        for x in nums:\\n            presum += x \\n\\n            if presum - k in hashmap:\\n                cnt += hashmap[presum-k]\\n\\n            hashmap[presum] += 1\\n\\n        return cnt",
                "codeTag": "Java"
            },
            {
                "id": 2297572,
                "title": "c-easy-prefix-sum-sliding-window",
                "content": "````\\nclass Solution\\n{\\n    public:\\n        int numSubmatrixSumTarget(vector<vector < int>> &matrix, int target)\\n        {\\n            int m = matrix.size();\\n            int n = matrix[0].size();\\n            \\n            for (int i = 0; i < m; i++)\\n            {\\n                for (int j = 1; j < n; j++)\\n                {\\n                    matrix[i][j] += matrix[i][j - 1];\\n                }\\n            }\\n            \\n            int count = 0;\\n            \\n            for (int i = 0; i < n; i++)\\n            {\\n                for (int j = i; j < n; j++)\\n                {\\n                    map<int, int> mp;\\n                    mp[0] = 1;\\n                    int sum = 0;\\n                    for (int k = 0; k < m; k++)\\n                    {\\n                        sum += matrix[k][j] - (i > 0 ? matrix[k][i - 1] : 0);\\n                        count += mp[sum - target];\\n                        mp[sum]++;\\n                    }\\n                }\\n            }\\n            \\n            return count;\\n        }\\n};\\n````",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "````\\nclass Solution\\n{\\n    public:\\n        int numSubmatrixSumTarget(vector<vector < int>> &matrix, int target)\\n        {\\n            int m = matrix.size();\\n            int n = matrix[0].size();\\n            \\n            for (int i = 0; i < m; i++)\\n            {\\n                for (int j = 1; j < n; j++)\\n                {\\n                    matrix[i][j] += matrix[i][j - 1];\\n                }\\n            }\\n            \\n            int count = 0;\\n            \\n            for (int i = 0; i < n; i++)\\n            {\\n                for (int j = i; j < n; j++)\\n                {\\n                    map<int, int> mp;\\n                    mp[0] = 1;\\n                    int sum = 0;\\n                    for (int k = 0; k < m; k++)\\n                    {\\n                        sum += matrix[k][j] - (i > 0 ? matrix[k][i - 1] : 0);\\n                        count += mp[sum - target];\\n                        mp[sum]++;\\n                    }\\n                }\\n            }\\n            \\n            return count;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128489,
                "title": "java-easy-explained-very-simple-o-m-n-m",
                "content": "```\\nsee u can first find the row prefix sum\\nthen take two pointer one on 0 and other on say x  then traverse row and as u did in to find the subarray sum equal to k just do that that is sum-target+target=sum if u can store sum at some point u will realise that u are finding target because sum-(sum-target)=target if u have the count of sum-target u hv to just add it up\\n```\\n\\n\\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target)\\n    {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        long dp[][]=new long[n][m];\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i][0]=matrix[i][0];\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<m;j++)\\n            {\\n                dp[i][j]=dp[i][j-1]+matrix[i][j];\\n            }\\n        }\\n        int count=0;\\n        for(int start=0;start<m;start++)\\n        {\\n            for(int end=start;end<m;end++)\\n            {\\n                HashMap<Long,Integer> map=new  HashMap<Long,Integer>();\\n                long sum=0;\\n                for(int i=0;i<n;i++)\\n                {\\n                    map.put(sum,map.getOrDefault(sum,0)+1);\\n                    long pre=start!=0?dp[i][start-1]:0;\\n                    sum+=dp[i][end]-pre;\\n                    if(map.containsKey(sum-target))\\n                    {\\n                        count+=map.get(sum-target);\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```\\n\\n# ***PLS UPVOTE IF U LIKE THE SOLUTION* **",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nsee u can first find the row prefix sum\\nthen take two pointer one on 0 and other on say x  then traverse row and as u did in to find the subarray sum equal to k just do that that is sum-target+target=sum if u can store sum at some point u will realise that u are finding target because sum-(sum-target)=target if u have the count of sum-target u hv to just add it up\\n```\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target)\\n    {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        long dp[][]=new long[n][m];\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i][0]=matrix[i][0];\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<m;j++)\\n            {\\n                dp[i][j]=dp[i][j-1]+matrix[i][j];\\n            }\\n        }\\n        int count=0;\\n        for(int start=0;start<m;start++)\\n        {\\n            for(int end=start;end<m;end++)\\n            {\\n                HashMap<Long,Integer> map=new  HashMap<Long,Integer>();\\n                long sum=0;\\n                for(int i=0;i<n;i++)\\n                {\\n                    map.put(sum,map.getOrDefault(sum,0)+1);\\n                    long pre=start!=0?dp[i][start-1]:0;\\n                    sum+=dp[i][end]-pre;\\n                    if(map.containsKey(sum-target))\\n                    {\\n                        count+=map.get(sum-target);\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1163041,
                "title": "c-dp-brute-force-and-2-sum-flavored-a-legend-a-1-d-guy-manage-2-d-dream",
                "content": "Approach 1: DP [1]\\nTime/Space: O(M*N^2); O(1); where M, N is the row and column size of the given matrix\\nmotivation:\\nIt is about a legend a 1-D guy manage 2-D dream\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        const int m = matrix.size(), n = matrix[0].size();\\n        for(int i = 0; i < m; i++)\\n            for(int j = 1; j < n; j++)\\n                matrix[i][j] += matrix[i][j-1];\\n        \\n        int ans = 0;\\n        for(int l = 0; l < n; l++) // l: left column index\\n            for(int r = l; r < n; r++){ //r: right column index\\n                unordered_map<int, int> counts{{0, 1}};\\n                int cur = 0; //this guy working hard, coming from 1-D world, but can watch 2-D by collecting runnign rums of different rows between col l & r\\n                for(int i = 0; i < m; i++){\\n                    cur += matrix[i][r] - (l > 0 ? matrix[i][l - 1] : 0);                    \\n                    ans += counts[cur - target];\\n                    ++counts[cur];\\n                }                \\n            }\\n        return ans;        \\n    }\\n};\\n```\\n\\n\\nApproach 2: DP brute force (WARNING: will cause TLE error)\\nTime/Space: O(N^4); O(N)\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        const int m = matrix.size(), n = matrix[0].size();\\n        vector<vector<int>> sums(m + 1, vector<int>(n + 1, 0));\\n        for(int i = 1; i <= m; i++)\\n            for(int j = 1; j <= n; j++)\\n                sums[i][j] = sums[i - 1][j] + sums[i][j - 1] - sums[i - 1][j - 1] + matrix[i-1][j-1];\\n        \\n        int ans = 0;\\n        for(int i = 1; i <= m; i++)\\n            for(int j = 1; j <= n; j++)\\n                for(int r = 1; r <= i; r++)\\n                    for(int c = 1; c <= j; c++)\\n                        if(target == sums[i][j] - sums[i][c - 1] - sums[r - 1][j] + sums[r - 1][c - 1]) ans++;\\n        return ans;\\n    }\\n};\\n```\\n\\n[1] https://www.cnblogs.com/grandyang/p/14588186.html",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        const int m = matrix.size(), n = matrix[0].size();\\n        for(int i = 0; i < m; i++)\\n            for(int j = 1; j < n; j++)\\n                matrix[i][j] += matrix[i][j-1];\\n        \\n        int ans = 0;\\n        for(int l = 0; l < n; l++) // l: left column index\\n            for(int r = l; r < n; r++){ //r: right column index\\n                unordered_map<int, int> counts{{0, 1}};\\n                int cur = 0; //this guy working hard, coming from 1-D world, but can watch 2-D by collecting runnign rums of different rows between col l & r\\n                for(int i = 0; i < m; i++){\\n                    cur += matrix[i][r] - (l > 0 ? matrix[i][l - 1] : 0);                    \\n                    ans += counts[cur - target];\\n                    ++counts[cur];\\n                }                \\n            }\\n        return ans;        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        const int m = matrix.size(), n = matrix[0].size();\\n        vector<vector<int>> sums(m + 1, vector<int>(n + 1, 0));\\n        for(int i = 1; i <= m; i++)\\n            for(int j = 1; j <= n; j++)\\n                sums[i][j] = sums[i - 1][j] + sums[i][j - 1] - sums[i - 1][j - 1] + matrix[i-1][j-1];\\n        \\n        int ans = 0;\\n        for(int i = 1; i <= m; i++)\\n            for(int j = 1; j <= n; j++)\\n                for(int r = 1; r <= i; r++)\\n                    for(int c = 1; c <= j; c++)\\n                        if(target == sums[i][j] - sums[i][c - 1] - sums[r - 1][j] + sums[r - 1][c - 1]) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1046314,
                "title": "simple-java-solution-no-hash-map",
                "content": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int ans = 0;\\n\\n        for(int i = 0; i<matrix[0].length;i++){//left col\\n            int[] sum = new int[matrix.length];\\n            for(int m = i; m<matrix[0].length;m++){//right col\\n                for(int j = 0; j<matrix.length;j++){\\n                    sum[j]+=matrix[j][m];//add left to right\\n                    if(sum[j]==target)ans++;            \\n                }\\n                for(int j = 0; j<matrix.length;j++){//up row\\n                    int summe=0;    \\n                    for(int n = j; n<matrix.length;n++){//down row\\n                        summe+=sum[n];add up to down\\n                        if(n!=j&&summe==target)ans++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int ans = 0;\\n\\n        for(int i = 0; i<matrix[0].length;i++){//left col\\n            int[] sum = new int[matrix.length];\\n            for(int m = i; m<matrix[0].length;m++){//right col\\n                for(int j = 0; j<matrix.length;j++){\\n                    sum[j]+=matrix[j][m];//add left to right\\n                    if(sum[j]==target)ans++;            \\n                }\\n                for(int j = 0; j<matrix.length;j++){//up row\\n                    int summe=0;    \\n                    for(int n = j; n<matrix.length;n++){//down row\\n                        summe+=sum[n];add up to down\\n                        if(n!=j&&summe==target)ans++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941587,
                "title": "dynamic-programming-approach-with-video-explanation",
                "content": "https://www.youtube.com/watch?v=i5UoDZbQ94Q",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=i5UoDZbQ94Q",
                "codeTag": "Unknown"
            },
            {
                "id": 684948,
                "title": "c-well-commented-o-n-n-m-std-unordered-map-explanation-maximumsumsubmatrix",
                "content": "In a nutshell the approach is to choose all pairs of rows and shrink the bundle (chosen rows  alongwith rows in between them) into an array (summing up entries in each column together) and now **finding the number of subarrays in this array whose sum is equal to the target in O(M).**\\n\\nThe overall complexity becomes O(N * N * M).\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    //Another classical problem of finding number of subarrays having sum equal to target in the array\\n    int numSubarraySumTarget(vector<int> &arr,int target){\\n        int num_of_subarray=0;\\n        unordered_map<int,int> mp;\\n        mp.insert({0,1});\\n        int curr_sum=0;\\n        for(int i=0;i<arr.size();i++){\\n            curr_sum+=arr[i];\\n            if(mp.find(curr_sum-target)!=mp.end()) num_of_subarray+=mp[curr_sum-target];\\n            mp[curr_sum]++;\\n        }\\n        return num_of_subarray;\\n    }\\n    \\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int n=matrix.size();        //number of rows in the matrix\\n        if(n==0) return 0;          //If there are no rows in a matrix then there is no submatrix for any target \\n        int m=matrix[0].size();     //number of columns in the matrix\\n        \\n        int number_of_submatrices=0;\\n        \\n        \\n        //choosing two rows adding there elements of same columns and creating the array out of it / Simply shrinking the bundle of rows to a 1-D array\\n        for(int row_x1=0;row_x1<n;row_x1++){\\n            vector<int> sum_array(m,0);\\n            for(int row_x2=row_x1;row_x2<n;row_x2++){\\n                \\n                for(int i=0;i<m;i++) sum_array[i]+=matrix[row_x2][i];\\n                \\n                //Find the number of subarrays that equal to the target in this shrinked array. \\n                number_of_submatrices+=numSubarraySumTarget(sum_array,target);\\n                \\n            }\\n            \\n        }\\n        \\n        return number_of_submatrices;\\n    }\\n};\\n```\\n\\n***There is another variation of the same problem where we find the submatrix with the maximum sum.This can be done by following the first part of choosing rows and bundelling up similarly and then applying the kaden\\'s algorithm of the array in O(M).***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //Another classical problem of finding number of subarrays having sum equal to target in the array\\n    int numSubarraySumTarget(vector<int> &arr,int target){\\n        int num_of_subarray=0;\\n        unordered_map<int,int> mp;\\n        mp.insert({0,1});\\n        int curr_sum=0;\\n        for(int i=0;i<arr.size();i++){\\n            curr_sum+=arr[i];\\n            if(mp.find(curr_sum-target)!=mp.end()) num_of_subarray+=mp[curr_sum-target];\\n            mp[curr_sum]++;\\n        }\\n        return num_of_subarray;\\n    }\\n    \\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int n=matrix.size();        //number of rows in the matrix\\n        if(n==0) return 0;          //If there are no rows in a matrix then there is no submatrix for any target \\n        int m=matrix[0].size();     //number of columns in the matrix\\n        \\n        int number_of_submatrices=0;\\n        \\n        \\n        //choosing two rows adding there elements of same columns and creating the array out of it / Simply shrinking the bundle of rows to a 1-D array\\n        for(int row_x1=0;row_x1<n;row_x1++){\\n            vector<int> sum_array(m,0);\\n            for(int row_x2=row_x1;row_x2<n;row_x2++){\\n                \\n                for(int i=0;i<m;i++) sum_array[i]+=matrix[row_x2][i];\\n                \\n                //Find the number of subarrays that equal to the target in this shrinked array. \\n                number_of_submatrices+=numSubarraySumTarget(sum_array,target);\\n                \\n            }\\n            \\n        }\\n        \\n        return number_of_submatrices;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 542947,
                "title": "easy-to-understand-solution",
                "content": "It is actually a combination of 2 problems but slightly twisted:\\nproblem 1: Find number of sub arrays with target sum\\nproblem 2: Find largest sub matrix with target sum\\n\\nFor problem 1: I followed the same hashmap approach as listed in this leetcode problem: https://leetcode.com/problems/subarray-sum-equals-k/solution/\\nFor problem 2: here is an excellent video which you will understand in 1 go. https://www.youtube.com/watch?time_continue=173&v=yCQN096CwWM&feature=emb_logo\\n\\nNow just twist problem 2 and instead of saying find Maximum Sum Rectangular Submatrix, find all subarrays with sum equal to k.\\n\\nIf you understand problem 2 deeply then you will understand that the problem is actually very simple and not complex at all.\\n\\n***Java***\\n```\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        if(matrix == null) {\\n            return 0;\\n        }\\n        int rowLen = matrix.length;\\n        int colLen = matrix[0].length;\\n        int answer = 0;\\n\\n        for(int left = 0;left < colLen;left++) {\\n            int[] tempArr = new int[rowLen];\\n            for(int right = left; right < colLen; right++) {\\n                for(int row = 0; row < rowLen; row++) {\\n                    tempArr[row] = tempArr[row] + matrix[row][right];\\n                }\\n                answer = answer + subarraySum(tempArr, target);\\n            }\\n        }\\n        return answer;\\n    }\\n\\n    public int subarraySum(int[] arr, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n        int ans = 0;\\n        int sumSoFar = 0;\\n        for(int i=0;i<arr.length ;i++) {\\n            sumSoFar = sumSoFar + arr[i];\\n            int requiredSum = sumSoFar - target;\\n            if(map.containsKey(requiredSum)) {\\n                ans = ans + map.get(requiredSum);\\n            }\\n            map.put(sumSoFar, map.get(sumSoFar) != null ? map.get(sumSoFar) + 1 : 1);\\n        }\\n        return ans;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "It is actually a combination of 2 problems but slightly twisted:\\nproblem 1: Find number of sub arrays with target sum\\nproblem 2: Find largest sub matrix with target sum\\n\\nFor problem 1: I followed the same hashmap approach as listed in this leetcode problem: https://leetcode.com/problems/subarray-sum-equals-k/solution/\\nFor problem 2: here is an excellent video which you will understand in 1 go. https://www.youtube.com/watch?time_continue=173&v=yCQN096CwWM&feature=emb_logo\\n\\nNow just twist problem 2 and instead of saying find Maximum Sum Rectangular Submatrix, find all subarrays with sum equal to k.\\n\\nIf you understand problem 2 deeply then you will understand that the problem is actually very simple and not complex at all.\\n\\n***Java***\\n```\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        if(matrix == null) {\\n            return 0;\\n        }\\n        int rowLen = matrix.length;\\n        int colLen = matrix[0].length;\\n        int answer = 0;\\n\\n        for(int left = 0;left < colLen;left++) {\\n            int[] tempArr = new int[rowLen];\\n            for(int right = left; right < colLen; right++) {\\n                for(int row = 0; row < rowLen; row++) {\\n                    tempArr[row] = tempArr[row] + matrix[row][right];\\n                }\\n                answer = answer + subarraySum(tempArr, target);\\n            }\\n        }\\n        return answer;\\n    }\\n\\n    public int subarraySum(int[] arr, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n        int ans = 0;\\n        int sumSoFar = 0;\\n        for(int i=0;i<arr.length ;i++) {\\n            sumSoFar = sumSoFar + arr[i];\\n            int requiredSum = sumSoFar - target;\\n            if(map.containsKey(requiredSum)) {\\n                ans = ans + map.get(requiredSum);\\n            }\\n            map.put(sumSoFar, map.get(sumSoFar) != null ? map.get(sumSoFar) + 1 : 1);\\n        }\\n        return ans;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 392399,
                "title": "python-simple-intuitive-solution",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def numSubmatrixSumTarget(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        row,col = len(matrix),len(matrix[0])\\n        for k in xrange(row):\\n            nums = [0 for _ in xrange(col)]\\n            for i in xrange(k,row):\\n                for j in xrange(col):\\n                    nums[j] += matrix[i][j]\\n                res += self.check(nums,target)\\n        return res\\n    \\n    def check(self,nums,target):\\n        counter,res = defaultdict(int),0\\n        counter[0],cum_sum = 1,0\\n        for i,num in enumerate(nums):\\n            cum_sum += num\\n            res += counter[cum_sum - target]\\n            counter[cum_sum] += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def numSubmatrixSumTarget(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        row,col = len(matrix),len(matrix[0])\\n        for k in xrange(row):\\n            nums = [0 for _ in xrange(col)]\\n            for i in xrange(k,row):\\n                for j in xrange(col):\\n                    nums[j] += matrix[i][j]\\n                res += self.check(nums,target)\\n        return res\\n    \\n    def check(self,nums,target):\\n        counter,res = defaultdict(int),0\\n        counter[0],cum_sum = 1,0\\n        for i,num in enumerate(nums):\\n            cum_sum += num\\n            res += counter[cum_sum - target]\\n            counter[cum_sum] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 303774,
                "title": "from-o-n-4-to-o-n-3",
                "content": "O(N^4):\\n* Enumerate all (r0, r1, c0, c1) pairs. Each variable is 1 layer in a nested loop. With 4 levels of loop, complexity gets to O(N^4).\\n\\nO(N^3):\\n* Enumerate all (c0, c1) pairs. This gives O(N^2) complexity.\\n* Then, for a pair, we get a sub-slice of the matrix. We compute the prefix-sum that says (what\\'s the sum of the first `r` rows in the slice?) and convert this into \"find a subsequence that sums to a certain target\" problem. This can be solved in O(N) by storing all prefix sums into a hash table.\\n* In total, the O(N) loop is nested in the O(N^2) loop, giving O(N^3) overall.\\n\\nIn the following code, setting variable `SLOW` to true gives O(N^4). Setting it to false gives O(N^3).\\n\\n(However I was not debugging fast enough so I could not submit the solution before the end of the context X_X )\\n\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        const int R = int(matrix.size()), C = int(matrix[0].size());\\n\\t\\tint the_sum = 0;\\n\\n        for (int r=0; r<R; r++) {\\n            for (int c=0; c<C; c++) {\\n\\t\\t\\t\\tthe_sum += int(abs(matrix[r][c]));\\n                if (c>0) matrix[r][c] += matrix[r][c-1];\\n            }\\n        }\\n\\n\\t\\tif (target > the_sum) return 0;\\n\\t\\tif (target < -the_sum)return 0;\\n        \\n        for (int r=0; r<R; r++) {\\n            for (int c=0; c<C; c++) {\\n                if (r>0) matrix[r][c] += matrix[r-1][c];\\n            }\\n        }\\n        \\n        if (0) {\\n            for (int r=0; r<R; r++) {\\n                for (int c=0; c<C; c++) {\\n                    printf(\"%d \", matrix[r][c]);\\n                }\\n                printf(\"\\\\n\");\\n            }\\n        }\\n        \\n        int ret = 0;\\n\\n\\t\\tconst bool SLOW = false;\\n\\t\\tif (SLOW) {\\n\\t\\t\\tfor (int r0=0; r0<R; r0++) {\\n\\t\\t\\t\\tfor (int c0=0; c0<C; c0++) {\\n\\t\\t\\t\\t\\tfor (int r1=r0; r1<R; r1++) {\\n\\t\\t\\t\\t\\t\\tfor (int c1=c0; c1<C; c1++) {\\n\\t\\t\\t\\t\\t\\t\\tint x = matrix[r1][c1];\\n\\t\\t\\t\\t\\t\\t\\tif (r0>0) x -= matrix[r0-1][c1];\\n\\t\\t\\t\\t\\t\\t\\tif (c0>0) x -= matrix[r1][c0-1];\\n\\t\\t\\t\\t\\t\\t\\tif (r0>0 && c0>0) x += matrix[r0-1][c0-1];\\n\\t\\t\\t\\t\\t\\t\\t//printf(\"[%d,%d,%d,%d] = %d\\\\n\", r0,c0,r1,c1,x);\\n\\t\\t\\t\\t\\t\\t\\tif (x == target) {\\n\\t\\t\\t\\t\\t\\t\\t\\tret++;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor (int c0 = 0; c0 < C; c0 ++) {\\n\\t\\t\\t\\tfor (int c1 = c0; c1 < C; c1 ++) {\\n\\t\\t\\t\\t\\tunordered_map<int, int> prefix_sums;\\n\\t\\t\\t\\t\\tfor (int r=0; r<R; r++) {\\n\\t\\t\\t\\t\\t\\tint curr = matrix[r][c1];\\n\\t\\t\\t\\t\\t\\tif (c0 > 0) curr -= matrix[r][c0-1];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tint key = -(target - curr);\\n\\t\\t\\t\\t\\t\\tif (prefix_sums.find(key) != prefix_sums.end()) {\\n\\t\\t\\t\\t\\t\\t\\tret += prefix_sums[key];\\n\\t\\t\\t\\t\\t\\t}\\n//\\t\\t\\t\\t\\t\\tprintf(\"Cols[%d,%d] Rows[0,%d] sum=%d, key=%d\\\\n\", c0, c1, r, curr, key);\\n\\t\\t\\t\\t\\t\\tif (curr == target) ret ++;\\n\\n\\t\\t\\t\\t\\t\\tprefix_sums[curr] ++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n        return ret;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        const int R = int(matrix.size()), C = int(matrix[0].size());\\n\\t\\tint the_sum = 0;\\n\\n        for (int r=0; r<R; r++) {\\n            for (int c=0; c<C; c++) {\\n\\t\\t\\t\\tthe_sum += int(abs(matrix[r][c]));\\n                if (c>0) matrix[r][c] += matrix[r][c-1];\\n            }\\n        }\\n\\n\\t\\tif (target > the_sum) return 0;\\n\\t\\tif (target < -the_sum)return 0;\\n        \\n        for (int r=0; r<R; r++) {\\n            for (int c=0; c<C; c++) {\\n                if (r>0) matrix[r][c] += matrix[r-1][c];\\n            }\\n        }\\n        \\n        if (0) {\\n            for (int r=0; r<R; r++) {\\n                for (int c=0; c<C; c++) {\\n                    printf(\"%d \", matrix[r][c]);\\n                }\\n                printf(\"\\\\n\");\\n            }\\n        }\\n        \\n        int ret = 0;\\n\\n\\t\\tconst bool SLOW = false;\\n\\t\\tif (SLOW) {\\n\\t\\t\\tfor (int r0=0; r0<R; r0++) {\\n\\t\\t\\t\\tfor (int c0=0; c0<C; c0++) {\\n\\t\\t\\t\\t\\tfor (int r1=r0; r1<R; r1++) {\\n\\t\\t\\t\\t\\t\\tfor (int c1=c0; c1<C; c1++) {\\n\\t\\t\\t\\t\\t\\t\\tint x = matrix[r1][c1];\\n\\t\\t\\t\\t\\t\\t\\tif (r0>0) x -= matrix[r0-1][c1];\\n\\t\\t\\t\\t\\t\\t\\tif (c0>0) x -= matrix[r1][c0-1];\\n\\t\\t\\t\\t\\t\\t\\tif (r0>0 && c0>0) x += matrix[r0-1][c0-1];\\n\\t\\t\\t\\t\\t\\t\\t//printf(\"[%d,%d,%d,%d] = %d\\\\n\", r0,c0,r1,c1,x);\\n\\t\\t\\t\\t\\t\\t\\tif (x == target) {\\n\\t\\t\\t\\t\\t\\t\\t\\tret++;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor (int c0 = 0; c0 < C; c0 ++) {\\n\\t\\t\\t\\tfor (int c1 = c0; c1 < C; c1 ++) {\\n\\t\\t\\t\\t\\tunordered_map<int, int> prefix_sums;\\n\\t\\t\\t\\t\\tfor (int r=0; r<R; r++) {\\n\\t\\t\\t\\t\\t\\tint curr = matrix[r][c1];\\n\\t\\t\\t\\t\\t\\tif (c0 > 0) curr -= matrix[r][c0-1];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tint key = -(target - curr);\\n\\t\\t\\t\\t\\t\\tif (prefix_sums.find(key) != prefix_sums.end()) {\\n\\t\\t\\t\\t\\t\\t\\tret += prefix_sums[key];\\n\\t\\t\\t\\t\\t\\t}\\n//\\t\\t\\t\\t\\t\\tprintf(\"Cols[%d,%d] Rows[0,%d] sum=%d, key=%d\\\\n\", c0, c1, r, curr, key);\\n\\t\\t\\t\\t\\t\\tif (curr == target) ret ++;\\n\\n\\t\\t\\t\\t\\t\\tprefix_sums[curr] ++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n        return ret;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118690,
                "title": "easy-java-solution-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int result = 0;\\n        //Calculating prefix sum in all rows\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=1;j<matrix[0].length;j++){\\n                matrix[i][j] = matrix[i][j-1] + matrix[i][j]; \\n            }\\n        }\\n\\n        //applying prefix Sum - HashMap technique\\n        for(int i=0;i<matrix.length;i++){\\n            int[] arr = new int[matrix[0].length+1];\\n            for(int j = i;j<matrix.length;j++){\\n                for(int k=0;k<matrix[0].length;k++){\\n                    arr[k+1] = arr[k+1] + matrix[j][k];\\n                }\\n                result += targetSum(arr,target);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    // method for prefix sum - HashMap techinique\\n    private int targetSum(int[] arr,int k){\\n        int result = 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(map.containsKey(arr[i]-k))\\n                result += map.get(arr[i]-k);\\n                map.put(arr[i],map.getOrDefault(arr[i],0) + 1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int result = 0;\\n        //Calculating prefix sum in all rows\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=1;j<matrix[0].length;j++){\\n                matrix[i][j] = matrix[i][j-1] + matrix[i][j]; \\n            }\\n        }\\n\\n        //applying prefix Sum - HashMap technique\\n        for(int i=0;i<matrix.length;i++){\\n            int[] arr = new int[matrix[0].length+1];\\n            for(int j = i;j<matrix.length;j++){\\n                for(int k=0;k<matrix[0].length;k++){\\n                    arr[k+1] = arr[k+1] + matrix[j][k];\\n                }\\n                result += targetSum(arr,target);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    // method for prefix sum - HashMap techinique\\n    private int targetSum(int[] arr,int k){\\n        int result = 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(map.containsKey(arr[i]-k))\\n                result += map.get(arr[i]-k);\\n                map.put(arr[i],map.getOrDefault(arr[i],0) + 1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658472,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Prefix && Hashmap***\\n\\n* ***Time Complexity :- O(N * N * M)***\\n\\n* ***Sapce Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // this function is for finding the no. of subarray which has sum equal to target\\n    \\n    int find(vector<int>& arr, int target)\\n    {\\n        int n = arr.size();\\n        \\n        int count = 0;\\n        \\n        unordered_map<int, int> mp;\\n        \\n        mp[0] = 1;\\n        \\n        int curr_sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            curr_sum += arr[i];\\n            \\n            int need = curr_sum - target;\\n            \\n            if(mp.count(need))\\n            {\\n                count += mp[need];\\n            }\\n            \\n            mp[curr_sum]++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int n = matrix.size();\\n        \\n        int m = matrix[0].size();\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // arr will store the prefix sum between row [i, k]\\n            \\n            vector<int> arr(m, 0);\\n            \\n            for(int k = i; k < n; k++)\\n            {\\n                for(int j = 0; j < m; j++)\\n                {\\n                    arr[j] += matrix[k][j];\\n                }\\n                \\n                // call find function\\n                \\n                count += find(arr, target);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // this function is for finding the no. of subarray which has sum equal to target\\n    \\n    int find(vector<int>& arr, int target)\\n    {\\n        int n = arr.size();\\n        \\n        int count = 0;\\n        \\n        unordered_map<int, int> mp;\\n        \\n        mp[0] = 1;\\n        \\n        int curr_sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            curr_sum += arr[i];\\n            \\n            int need = curr_sum - target;\\n            \\n            if(mp.count(need))\\n            {\\n                count += mp[need];\\n            }\\n            \\n            mp[curr_sum]++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int n = matrix.size();\\n        \\n        int m = matrix[0].size();\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // arr will store the prefix sum between row [i, k]\\n            \\n            vector<int> arr(m, 0);\\n            \\n            for(int k = i; k < n; k++)\\n            {\\n                for(int j = 0; j < m; j++)\\n                {\\n                    arr[j] += matrix[k][j];\\n                }\\n                \\n                // call find function\\n                \\n                count += find(arr, target);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300781,
                "title": "c-modified-kadene-s-algorithm-o-n-n-m-m",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    //number of subarrays having sum equals to k\\n    int go(vector<int> &nums, int k)\\n    {\\n        unordered_map<int,int> m;\\n        \\n        int sum=0,ans=0;\\n        \\n        m[0] = 1;\\n        \\n        for(int num:nums)\\n        {\\n            sum += num;\\n            int target = sum - k;\\n            if(m.count(target))\\n                ans += m[target];\\n            \\n            m[sum]++;\\n        }\\n        return ans;\\n    } \\n    //----------------------------------------------------------------\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int n = matrix.size(), m = matrix[0].size();\\n        \\n        int res = 0;\\n       \\n        for(int i=0; i<n; i++)\\n        {\\n            vector<int> temp(m,0);         \\n            for(int j=i; j<n; j++)\\n            {\\n                for(int k=0; k<m; k++)\\n                    temp[k] += matrix[j][k];\\n                \\n                //all sub-matrices between row i and j.\\n                res += go(temp, target);\\n            }       \\n        }\\n        return res;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //number of subarrays having sum equals to k\\n    int go(vector<int> &nums, int k)\\n    {\\n        unordered_map<int,int> m;\\n        \\n        int sum=0,ans=0;\\n        \\n        m[0] = 1;\\n        \\n        for(int num:nums)\\n        {\\n            sum += num;\\n            int target = sum - k;\\n            if(m.count(target))\\n                ans += m[target];\\n            \\n            m[sum]++;\\n        }\\n        return ans;\\n    } \\n    //----------------------------------------------------------------\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int n = matrix.size(), m = matrix[0].size();\\n        \\n        int res = 0;\\n       \\n        for(int i=0; i<n; i++)\\n        {\\n            vector<int> temp(m,0);         \\n            for(int j=i; j<n; j++)\\n            {\\n                for(int k=0; k<m; k++)\\n                    temp[k] += matrix[j][k];\\n                \\n                //all sub-matrices between row i and j.\\n                res += go(temp, target);\\n            }       \\n        }\\n        return res;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300652,
                "title": "similar-to-subarray-with-target-k",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int ro=matrix.size(),co=matrix[0].size();\\n        \\n        if(ro<1)\\n            return 0;\\n        //prefix sum \\n        for(int r=0;r<ro;r++)\\n            for(int c=1;c<co;c++)\\n                matrix[r][c]+=matrix[r][c-1];\\n        \\n        int count=0;\\n        for(int c1=0;c1<co;c1++)\\n        for(int c2=c1;c2<co;c2++)\\n        {\\n            //appling \"subarray with sum k\" between the c1 and c2 || no of element is no of rows  \\n            unordered_map<int,int>mp;\\n            int sum=0;\\n            mp[0]=1;\\n            for(int r=0;r<ro;r++)\\n            {\\n                sum+=matrix[r][c2]-(c1>0?matrix[r][c1-1]:0);// sum of row between c1 and c2;\\n                    int find=sum-target;          \\n                if(mp.find(find)!=mp.end())\\n                    count+=mp[find];\\n                mp[sum]++;\\n            }\\n        }\\n        return count++;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int ro=matrix.size(),co=matrix[0].size();\\n        \\n        if(ro<1)\\n            return 0;\\n        //prefix sum \\n        for(int r=0;r<ro;r++)\\n            for(int c=1;c<co;c++)\\n                matrix[r][c]+=matrix[r][c-1];\\n        \\n        int count=0;\\n        for(int c1=0;c1<co;c1++)\\n        for(int c2=c1;c2<co;c2++)\\n        {\\n            //appling \"subarray with sum k\" between the c1 and c2 || no of element is no of rows  \\n            unordered_map<int,int>mp;\\n            int sum=0;\\n            mp[0]=1;\\n            for(int r=0;r<ro;r++)\\n            {\\n                sum+=matrix[r][c2]-(c1>0?matrix[r][c1-1]:0);// sum of row between c1 and c2;\\n                    int find=sum-target;          \\n                if(mp.find(find)!=mp.end())\\n                    count+=mp[find];\\n                mp[sum]++;\\n            }\\n        }\\n        return count++;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300306,
                "title": "c-detailed-explained-solution-with-workflow",
                "content": "Steps involved here:\\n1. We will create a prefixSum Array - (Loops1 in diagram)\\n2. We use LoopA to leave behind the checked columns. Each iteration the matrix which we will check will decrease by 1 column.\\nthis line will take care of that - ![image](https://assets.leetcode.com/users/images/07475203-3d6c-43b7-b4da-ffbdeda1a584_1658163863.0686345.png)\\n\\n![image](https://assets.leetcode.com/users/images/53c6a404-38e4-40ba-b7bd-b30868469365_1658162903.8814688.png)\\n\\n3. LoopB to check all the posisble sums in the active sub matrix\\n![image](https://assets.leetcode.com/users/images/b6edd7c7-c86f-4fd1-a1c2-56e56ce550f8_1658163012.0017807.png)\\n\\n\\n4. Loop C to iterate over each row and find the number of sums we can get.\\n![image](https://assets.leetcode.com/users/images/9081460c-72b8-4f73-84b4-b2241ed3403a_1658163139.1419709.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/9c52cb1c-da8b-4380-b22e-bdcd4bbc77c3_1658162353.179597.png)\\n\\n```\\npublic class Solution {\\n    public int NumSubmatrixSumTarget(int[][] matrix, int target) {\\n        for(int i=0; i< matrix.Length; i++){\\n            for(int j=1; j< matrix[0].Length; j++){\\n                matrix[i][j] += matrix[i][j-1]; \\n            }\\n        }\\n        int counter = 0;\\n        //this loop will remove previous column by 1 so that remaining columns will be checked\\n        for(int col1=0; col1 < matrix[0].Length; col1++){\\n            //this loop will be used to check the column starting from above and ending till end\\n            for(int col2=col1; col2< matrix[0].Length; col2++){\\n                Dictionary<int,int> records = new Dictionary<int,int>();\\n                records[0] = 1;\\n                int sum = 0;\\n                for(int row=0; row < matrix.Length; row++){\\n                    sum += matrix[row][col2] - (col1 > 0 ? matrix[row][col1-1] : 0);\\n                    int prefixSum = sum - target;\\n                    if(records.ContainsKey(prefixSum)){\\n                        counter += records[prefixSum];\\n                    }\\n                    if(records.ContainsKey(sum))\\n                        records[sum] += 1;\\n                    else\\n                    records[sum] = 1;\\n                    \\n                }\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumSubmatrixSumTarget(int[][] matrix, int target) {\\n        for(int i=0; i< matrix.Length; i++){\\n            for(int j=1; j< matrix[0].Length; j++){\\n                matrix[i][j] += matrix[i][j-1]; \\n            }\\n        }\\n        int counter = 0;\\n        //this loop will remove previous column by 1 so that remaining columns will be checked\\n        for(int col1=0; col1 < matrix[0].Length; col1++){\\n            //this loop will be used to check the column starting from above and ending till end\\n            for(int col2=col1; col2< matrix[0].Length; col2++){\\n                Dictionary<int,int> records = new Dictionary<int,int>();\\n                records[0] = 1;\\n                int sum = 0;\\n                for(int row=0; row < matrix.Length; row++){\\n                    sum += matrix[row][col2] - (col1 > 0 ? matrix[row][col1-1] : 0);\\n                    int prefixSum = sum - target;\\n                    if(records.ContainsKey(prefixSum)){\\n                        counter += records[prefixSum];\\n                    }\\n                    if(records.ContainsKey(sum))\\n                        records[sum] += 1;\\n                    else\\n                    records[sum] = 1;\\n                    \\n                }\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299842,
                "title": "prefix-sum-easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n   int numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n        int res = 0, m = A.size(), n = A[0].size();\\n        for (int i = 0; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                A[i][j] += A[i][j - 1];  // prefix sum of matrix row wise \\n\\n        unordered_map<int, int> counter;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                counter = {{0,1}};\\n                int cur = 0;\\n                for (int k = 0; k < m; k++) {\\n                    cur += A[k][j] - (i > 0 ? A[k][i - 1] : 0);\\n                    res += counter.find(cur - target) != counter.end() ? counter[cur - target] : 0; \\n                    counter[cur]++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   int numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n        int res = 0, m = A.size(), n = A[0].size();\\n        for (int i = 0; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                A[i][j] += A[i][j - 1];  // prefix sum of matrix row wise \\n\\n        unordered_map<int, int> counter;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                counter = {{0,1}};\\n                int cur = 0;\\n                for (int k = 0; k < m; k++) {\\n                    cur += A[k][j] - (i > 0 ? A[k][i - 1] : 0);\\n                    res += counter.find(cur - target) != counter.end() ? counter[cur - target] : 0; \\n                    counter[cur]++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299771,
                "title": "python-using-range-sum-query-2d-o-m-2n-m-n-faster-99",
                "content": "Similar to [LC 304: Range Sum Query 2D| Approach 4](https://leetcode.com/problems/range-sum-query-2d-immutable/), create a 2D cache : dp such that  dp(row,col) is the sum of the subarray (0,0) to (row,col)\\n\\nNow, applying logic similar to [LC 560: Subarray sum equals k](https://leetcode.com/problems/subarray-sum-equals-k/) we need to create a hashmap but since this is in 2D, we fix the row limits row1 and row2. Then iterate through the columns calculating the presum of the subarray up till that column for the fixed (row1, row2), simultaneuously increasing the hashmap value by 1.\\nFor a given presum, if presum-target exists in the hash, we increase the ans count by the value of hash[presum-target]\\n\\nNote: We don\\'t increment the presum variable and instead assign it directly since our 2d dp already accounts for the prefix sum up until that point! \\n\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        \\n        if len(matrix)>len(matrix[0]):\\n            new=[[0]*len(matrix) for i in range(len(matrix[0]))]\\n            for i in range(len(matrix)):\\n                for j in range(len(matrix[0])):\\n                    new[j][i]=matrix[i][j]\\n            return self.numSubmatrixSumTarget(new,target)\\n\\n\\n        self.dp=[[0]*(len(matrix[0])+1)for i in range(len(matrix)+1)]\\n        for i in range(1,len(matrix)+1):\\n            for j in range(1,len(matrix[0])+1):\\n                self.dp[i][j]=self.dp[i][j-1]+self.dp[i-1][j]-self.dp[i-1][j-1]+matrix[i-1][j-1]\\n        \\n        ans=0\\n        for row1 in range(len(matrix)):\\n            for row2 in range(row1,len(matrix)):\\n                pres=0\\n                myhash={0:1}\\n                for col1 in range(len(matrix[0])):\\n                        presum=self.dp[row2+1][col1+1]-self.dp[row1][col1+1]\\n                        if presum-target in myhash:\\n                            ans+=myhash[pres-target]\\n                        myhash[pres]=myhash.get(pres,0)+1\\n                        \\n        return(ans)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        \\n        if len(matrix)>len(matrix[0]):\\n            new=[[0]*len(matrix) for i in range(len(matrix[0]))]\\n            for i in range(len(matrix)):\\n                for j in range(len(matrix[0])):\\n                    new[j][i]=matrix[i][j]\\n            return self.numSubmatrixSumTarget(new,target)\\n\\n\\n        self.dp=[[0]*(len(matrix[0])+1)for i in range(len(matrix)+1)]\\n        for i in range(1,len(matrix)+1):\\n            for j in range(1,len(matrix[0])+1):\\n                self.dp[i][j]=self.dp[i][j-1]+self.dp[i-1][j]-self.dp[i-1][j-1]+matrix[i-1][j-1]\\n        \\n        ans=0\\n        for row1 in range(len(matrix)):\\n            for row2 in range(row1,len(matrix)):\\n                pres=0\\n                myhash={0:1}\\n                for col1 in range(len(matrix[0])):\\n                        presum=self.dp[row2+1][col1+1]-self.dp[row1][col1+1]\\n                        if presum-target in myhash:\\n                            ans+=myhash[pres-target]\\n                        myhash[pres]=myhash.get(pres,0)+1\\n                        \\n        return(ans)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298801,
                "title": "least-runtime-solution",
                "content": "```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        n, m = len(matrix), len(matrix[0])\\n        answer = 0\\n        \\n        for i in range(n):\\n            for j in range(1, m):\\n                matrix[i][j] += matrix[i][j - 1]\\n                \\n        for j in range(m):\\n            for k in range(j, m):\\n                d, c = {0: 1}, 0\\n                for i in range(n):\\n                    c += matrix[i][k] - (matrix[i][j - 1] if j else 0)\\n                    if c - target in d:\\n                        answer += d[c - target]\\n                    d[c] = d[c] + 1 if c in d else 1  \\n        return answer\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        n, m = len(matrix), len(matrix[0])\\n        answer = 0\\n        \\n        for i in range(n):\\n            for j in range(1, m):\\n                matrix[i][j] += matrix[i][j - 1]\\n                \\n        for j in range(m):\\n            for k in range(j, m):\\n                d, c = {0: 1}, 0\\n                for i in range(n):\\n                    c += matrix[i][k] - (matrix[i][j - 1] if j else 0)\\n                    if c - target in d:\\n                        answer += d[c - target]\\n                    d[c] = d[c] + 1 if c in d else 1  \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297508,
                "title": "javascript-prefix-sum-solution",
                "content": "```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {number}\\n */\\nvar numSubmatrixSumTarget = function(matrix, target) {\\n    var sumMatrix = [],sum,hash={},counterPart,ans=0,prefixSum=0;\\n    //Do rowwise sum\\n    for(let i=0;i<matrix.length;i++){\\n        sum=0;\\n        for(let j=0;j<matrix[i].length;j++){\\n            sum+=matrix[i][j];\\n            if(sumMatrix[i]===undefined){\\n                sumMatrix[i]=[];\\n            }\\n            sumMatrix[i][j]=sum;\\n        }\\n    }\\n    \\n    //Do columnwise sum\\n    for(let j=0;j<matrix[0].length;j++){\\n        sum=0;\\n        for(let i=0;i<matrix.length;i++){\\n            sum+=sumMatrix[i][j];\\n            if(sumMatrix[i]===undefined){\\n                sumMatrix[i]=[];\\n            }\\n            sumMatrix[i][j]=sum;\\n        }\\n    }\\n    //Check all submatrices one by one \\n    for(let i1=0;i1<sumMatrix.length;i1++){\\n        for(let i2=i1;i2<sumMatrix.length;i2++){\\n            hash={};\\n            hash[0]=1;\\n            for(let j=0;j<sumMatrix[i1].length;j++){\\n                if(i1>0){\\n                    prefixSum = sumMatrix[i2][j]-sumMatrix[i1-1][j];\\n                }else{\\n                    prefixSum = sumMatrix[i2][j];\\n                }\\n                counterPart = prefixSum-target;\\n                if(hash[counterPart]!==undefined){\\n                    ans+=hash[counterPart];\\n                }\\n                if(hash[prefixSum]===undefined){\\n                    hash[prefixSum]=1\\n                }else{\\n                    hash[prefixSum]++;\\n                }\\n            }\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Prefix Sum"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {number}\\n */\\nvar numSubmatrixSumTarget = function(matrix, target) {\\n    var sumMatrix = [],sum,hash={},counterPart,ans=0,prefixSum=0;\\n    //Do rowwise sum\\n    for(let i=0;i<matrix.length;i++){\\n        sum=0;\\n        for(let j=0;j<matrix[i].length;j++){\\n            sum+=matrix[i][j];\\n            if(sumMatrix[i]===undefined){\\n                sumMatrix[i]=[];\\n            }\\n            sumMatrix[i][j]=sum;\\n        }\\n    }\\n    \\n    //Do columnwise sum\\n    for(let j=0;j<matrix[0].length;j++){\\n        sum=0;\\n        for(let i=0;i<matrix.length;i++){\\n            sum+=sumMatrix[i][j];\\n            if(sumMatrix[i]===undefined){\\n                sumMatrix[i]=[];\\n            }\\n            sumMatrix[i][j]=sum;\\n        }\\n    }\\n    //Check all submatrices one by one \\n    for(let i1=0;i1<sumMatrix.length;i1++){\\n        for(let i2=i1;i2<sumMatrix.length;i2++){\\n            hash={};\\n            hash[0]=1;\\n            for(let j=0;j<sumMatrix[i1].length;j++){\\n                if(i1>0){\\n                    prefixSum = sumMatrix[i2][j]-sumMatrix[i1-1][j];\\n                }else{\\n                    prefixSum = sumMatrix[i2][j];\\n                }\\n                counterPart = prefixSum-target;\\n                if(hash[counterPart]!==undefined){\\n                    ans+=hash[counterPart];\\n                }\\n                if(hash[prefixSum]===undefined){\\n                    hash[prefixSum]=1\\n                }else{\\n                    hash[prefixSum]++;\\n                }\\n            }\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2297345,
                "title": "using-subarray-sum-build-through-matrix-easy-way-o-n-3",
                "content": "```\\n int kadene(vector<int>&nums,int target){\\n       unordered_map<int,int>mp;\\n         mp[0]=1;\\n        int sum=0,count=0;\\n        for(auto c:nums)\\n        {\\n            sum+=c;\\n            count+=mp[sum-target];\\n            mp[sum]++;\\n        }\\n        return count;\\n    }\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n       int ans=0;\\n        for(int i=0;i<matrix.size();i++){\\n            vector<int>res=matrix[i];\\n             ans+=kadene(res,target);\\n            for(int j=i+1;j<matrix.size();j++){\\n                for(int k=0;k<matrix[0].size();k++){\\n                     res[k]+=matrix[j][k];\\n                }\\n                   ans+=kadene(res,target);\\n            }\\n        }\\n        return ans;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int kadene(vector<int>&nums,int target){\\n       unordered_map<int,int>mp;\\n         mp[0]=1;\\n        int sum=0,count=0;\\n        for(auto c:nums)\\n        {\\n            sum+=c;\\n            count+=mp[sum-target];\\n            mp[sum]++;\\n        }\\n        return count;\\n    }\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n       int ans=0;\\n        for(int i=0;i<matrix.size();i++){\\n            vector<int>res=matrix[i];\\n             ans+=kadene(res,target);\\n            for(int j=i+1;j<matrix.size();j++){\\n                for(int k=0;k<matrix[0].size();k++){\\n                     res[k]+=matrix[j][k];\\n                }\\n                   ans+=kadene(res,target);\\n            }\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2297272,
                "title": "daily-leetcoding-challenge-july-day-18",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Number of Subarrays that Sum to Target: Horizontal 1D Prefix Sum \n\n  \n**Approach 2:** Number of Subarrays that Sum to Target: Vertical 1D Prefix Sum \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2185624,
                "title": "c-code",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int solveIn1D(vector<int>&colSum,int target)\\n    {\\n        unordered_map<int,int>mp;\\n         mp[0]=1;\\n        int sum=0,count=0;\\n        for(auto c:colSum)\\n        {\\n            sum+=c;\\n            count+=mp[sum-target];\\n            mp[sum]++;\\n        }\\n        return count;\\n        \\n    }\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size(),m=matrix[0].size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n           vector<int>colSum(m,0);\\n            for(int k=i;k<n;k++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                     colSum[j]+=matrix[k][j];\\n                }\\n                ans+=solveIn1D(colSum, target);\\n               \\n            }\\n                \\n        }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solveIn1D(vector<int>&colSum,int target)\\n    {\\n        unordered_map<int,int>mp;\\n         mp[0]=1;\\n        int sum=0,count=0;\\n        for(auto c:colSum)\\n        {\\n            sum+=c;\\n            count+=mp[sum-target];\\n            mp[sum]++;\\n        }\\n        return count;\\n        \\n    }\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size(),m=matrix[0].size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n           vector<int>colSum(m,0);\\n            for(int k=i;k<n;k++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                     colSum[j]+=matrix[k][j];\\n                }\\n                ans+=solveIn1D(colSum, target);\\n               \\n            }\\n                \\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118388,
                "title": "python-sol-easy-explained-very-simple-commented",
                "content": "\\n# EXPLANATION\\n```\\nThe problem can be solved by using the following idea\\n\\nWe take two boundary for the column and add all the elements for each row within the column .\\nNow our 2D matrix is changed to a single array in which we need to find the subarray having sum = target\\n\\nWe use prefixsum so we dont need to do the sum again and again\\n```\\n\\n\\n\\n# CODE\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        # find the rows and columns of the matrix\\n        n,m = len(matrix) , len(matrix[0])\\n        # find the prefix sum for each row\\n        for i in range(n):\\n            for j in range(1,m):\\n                matrix[i][j] += matrix[i][j-1]\\n        ans = 0\\n        # fix the left boundary of the column\\n        for start in range(m):\\n            # fix the right boundary of the column\\n            for end in range(start,m):\\n                # a dictionary to map data\\n                d = defaultdict(lambda:0)\\n                d[0] = 1\\n                summ = 0\\n                # now we do check at each row\\n                for i in range(n):\\n                    curr = matrix[i][end]\\n                    if start > 0: curr -= matrix[i][start-1]\\n                    summ += curr\\n                    ans += d[summ - target]\\n                    d[summ] += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nThe problem can be solved by using the following idea\\n\\nWe take two boundary for the column and add all the elements for each row within the column .\\nNow our 2D matrix is changed to a single array in which we need to find the subarray having sum = target\\n\\nWe use prefixsum so we dont need to do the sum again and again\\n```\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        # find the rows and columns of the matrix\\n        n,m = len(matrix) , len(matrix[0])\\n        # find the prefix sum for each row\\n        for i in range(n):\\n            for j in range(1,m):\\n                matrix[i][j] += matrix[i][j-1]\\n        ans = 0\\n        # fix the left boundary of the column\\n        for start in range(m):\\n            # fix the right boundary of the column\\n            for end in range(start,m):\\n                # a dictionary to map data\\n                d = defaultdict(lambda:0)\\n                d[0] = 1\\n                summ = 0\\n                # now we do check at each row\\n                for i in range(n):\\n                    curr = matrix[i][end]\\n                    if start > 0: curr -= matrix[i][start-1]\\n                    summ += curr\\n                    ans += d[summ - target]\\n                    d[summ] += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271854,
                "title": "c-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/85f0b8b6-ab82-472b-ae76-2db6bf01f1e1_1623670028.9009478.jpeg)\\n\\nclass Solution {\\npublic:\\n\\n    int numSubmatrixSumTarget(vector<vector<int>>& A, int k) {\\n        // same logic as count subarray with sum k HASHING\\n        \\n        int row = A.size();\\n        int col = A[0].size();\\n        \\n\\t\\t//Calculating Prefix Sum of Columns\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=1;j<col;j++)\\n                A[i][j]+=A[i][j-1]; \\n        }\\n        \\n        int count = 0;\\n        \\n        for(int c1=0;c1<col;c1++)\\n        {\\n            for(int c2=c1;c2<col;c2++)\\n            {\\n                unordered_map<int,int>mp;\\n                int sum=0;\\n                mp[sum]=1;\\n                \\n                for(int r=0;r<row;r++)\\n                {\\n                    sum +=A[r][c2] - (c1>0 ? A[r][c1-1] : 0);\\n                    \\n                    if(mp.find(sum-k)!=mp.end())\\n                        count+=mp[sum-k];\\n                    \\n                    mp[sum]+=1;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int numSubmatrixSumTarget(vector<vector<int>>& A, int k) {\\n        // same logic as count subarray with sum k HASHING\\n        \\n        int row = A.size();\\n        int col = A[0].size();\\n        \\n\\t\\t//Calculating Prefix Sum of Columns\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=1;j<col;j++)\\n                A[i][j]+=A[i][j-1]; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1170050,
                "title": "using-map-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n\\t\\t\\tint n=matrix.size();\\n\\t\\t\\tint count=0;\\n\\t\\t\\tint m=matrix[0].size();\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=1;j<m;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmatrix[i][j]+=matrix[i][j-1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tmap<int,int>mp;\\n\\t\\t\\tfor(int i=0;i<m;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=i;j<m;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmp.clear();\\n\\t\\t\\t\\t\\tmp[0]=1;\\n\\t\\t\\t\\t\\tint sum=0;\\n\\t\\t\\t\\t\\tfor(int k=0;k<n;k++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tsum+=matrix[k][j]-(i>0 ?matrix[k][i-1]:0);\\n\\t\\t\\t\\t\\t\\tif(mp.find(sum-target)!=mp.end())\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tcount+=mp[sum-target];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tmp[sum]++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n\\t\\t\\tint n=matrix.size();\\n\\t\\t\\tint count=0;\\n\\t\\t\\tint m=matrix[0].size();\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=1;j<m;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmatrix[i][j]+=matrix[i][j-1];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1162790,
                "title": "ruby-dp",
                "content": "```\\n# @param {Integer[][]} matrix\\n# @param {Integer} target\\n# @return {Integer}\\ndef num_submatrix_sum_target(matrix, target)\\n  m, n = matrix.count, matrix[0].count\\n  m.times{|x| (n-1).times{|y| matrix[x][y+1] += matrix[x][y]}}\\n\\n  result = 0\\n  \\n  n.times do |y1|\\n    (y1...n).each do |y2|\\n      h = {0 => 1}\\n      s = 0\\n\\n      m.times do |x|\\n        s += matrix[x][y2] - (y1 > 0 ? matrix[x][y1-1] : 0)\\n        result += h[s - target] || 0\\n        h[s] = (h[s] || 0) + 1\\n      end\\n    end\\n  end\\n  \\n  result\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Dynamic Programming"
                ],
                "code": "```\\n# @param {Integer[][]} matrix\\n# @param {Integer} target\\n# @return {Integer}\\ndef num_submatrix_sum_target(matrix, target)\\n  m, n = matrix.count, matrix[0].count\\n  m.times{|x| (n-1).times{|y| matrix[x][y+1] += matrix[x][y]}}\\n\\n  result = 0\\n  \\n  n.times do |y1|\\n    (y1...n).each do |y2|\\n      h = {0 => 1}\\n      s = 0\\n\\n      m.times do |x|\\n        s += matrix[x][y2] - (y1 > 0 ? matrix[x][y1-1] : 0)\\n        result += h[s - target] || 0\\n        h[s] = (h[s] || 0) + 1\\n      end\\n    end\\n  end\\n  \\n  result\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1162625,
                "title": "hashmap-implementation-c-break-down",
                "content": "->Calculate the prefix sum of each element of a row\\n->picking every pair. of column accumulate the row sum to it\\n-> now the question is been break down to finding the number of subarrays with a target sum.\\n\\t\\n\\tint numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n\\t\\t//calculate the prefix sum of each row\\n        for(int i=0; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                matrix[i][j] += matrix[i][j-1];\\n            }\\n        }\\n        \\n        int ans = 0;\\n        unordered_map<int,int> mp;   //to store a already seen sum (its frequency)\\n        \\n        for(int j=0; j<m; j++){ // starting column index\\n            for(int k=j; k<m; k++){  // ending column index \\n                mp.clear();  //clear the map to wipe out previous data\\n                mp = {{0,1}}; //initialize the map\\n                \\n                int curr = 0;\\n                \\n                for(int i=0; i<n; i++){\\n                    curr += matrix[i][k] - (j > 0 ? matrix[i][j-1] : 0);  // subtact the prefix sum of a[left-1] from a[rught] to find the sum from left to right.\\n                    \\n                    ans += mp.find(curr - target) != mp.end() ? mp[curr - target] : 0; \\n                    \\n                    mp[curr]++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "->Calculate the prefix sum of each element of a row\\n->picking every pair. of column accumulate the row sum to it\\n-> now the question is been break down to finding the number of subarrays with a target sum.\\n\\t\\n\\tint numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n\\t\\t//calculate the prefix sum of each row\\n        for(int i=0; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                matrix[i][j] += matrix[i][j-1];\\n            }\\n        }\\n        \\n        int ans = 0;\\n        unordered_map<int,int> mp;   //to store a already seen sum (its frequency)\\n        \\n        for(int j=0; j<m; j++){ // starting column index\\n            for(int k=j; k<m; k++){  // ending column index \\n                mp.clear();  //clear the map to wipe out previous data\\n                mp = {{0,1}}; //initialize the map\\n                \\n                int curr = 0;\\n                \\n                for(int i=0; i<n; i++){\\n                    curr += matrix[i][k] - (j > 0 ? matrix[i][j-1] : 0);  // subtact the prefix sum of a[left-1] from a[rught] to find the sum from left to right.\\n                    \\n                    ans += mp.find(curr - target) != mp.end() ? mp[curr - target] : 0; \\n                    \\n                    mp[curr]++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1162570,
                "title": "java-clean-solution-o-r2-c-compexity",
                "content": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        HashMap<Integer, Integer> count = new HashMap();\\n        int [] dp = new int [matrix[0].length];\\n        int res = 0;\\n        for(int i = 0;i <matrix.length;i++){\\n            for(int j =i; j < matrix.length;j++){\\n                count.put(0, 1);\\n                res += numSubmatrixSumTarget(i, j, matrix, target, count, dp);\\n                count.clear();\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int numSubmatrixSumTarget(int first, int second, int [][] matrix, int target, HashMap<Integer, Integer> count, int [] dp){\\n        int res = 0;\\n        int sum = 0;\\n        for(int i  = 0;i<matrix[first].length;i++){\\n            sum += matrix[second][i];\\n            dp[i] = sum+ (first == second?0:dp[i]);\\n            res += count.getOrDefault(dp[i] - target, 0);\\n            count.put(dp[i], count.getOrDefault(dp[i], 0)+1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        HashMap<Integer, Integer> count = new HashMap();\\n        int [] dp = new int [matrix[0].length];\\n        int res = 0;\\n        for(int i = 0;i <matrix.length;i++){\\n            for(int j =i; j < matrix.length;j++){\\n                count.put(0, 1);\\n                res += numSubmatrixSumTarget(i, j, matrix, target, count, dp);\\n                count.clear();\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int numSubmatrixSumTarget(int first, int second, int [][] matrix, int target, HashMap<Integer, Integer> count, int [] dp){\\n        int res = 0;\\n        int sum = 0;\\n        for(int i  = 0;i<matrix[first].length;i++){\\n            sum += matrix[second][i];\\n            dp[i] = sum+ (first == second?0:dp[i]);\\n            res += count.getOrDefault(dp[i] - target, 0);\\n            count.put(dp[i], count.getOrDefault(dp[i], 0)+1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162515,
                "title": "easy-c-solution-using-unordered-map",
                "content": "```\\nclass Solution {\\n   public:\\n   int numSubmatrixSumTarget(vector<vector<int>>& matrix, int\\n   target) {\\n      int ans = 0;\\n      int col = matrix[0].size();\\n      int row = matrix.size();\\n      for(int i = 0; i < row; i++){\\n         for(int j = 1; j < col; j++){\\n            matrix[i][j] += matrix[i][j - 1];\\n         }\\n      }\\n      unordered_map <int, int> m;\\n      for(int i = 0; i < col; i++){\\n         for(int j = i; j < col; j++){\\n            m.clear();\\n            m[0] = 1;\\n            int sum = 0;\\n            for(int k = 0; k < row; k++){\\n               int current = matrix[k][j];\\n               if(i - 1 >= 0)current -= matrix[k][i - 1];\\n               sum += current;\\n               ans += m[target - sum];\\n               m[-sum]++;\\n            }\\n         }\\n      }\\n      return ans;\\n   }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public:\\n   int numSubmatrixSumTarget(vector<vector<int>>& matrix, int\\n   target) {\\n      int ans = 0;\\n      int col = matrix[0].size();\\n      int row = matrix.size();\\n      for(int i = 0; i < row; i++){\\n         for(int j = 1; j < col; j++){\\n            matrix[i][j] += matrix[i][j - 1];\\n         }\\n      }\\n      unordered_map <int, int> m;\\n      for(int i = 0; i < col; i++){\\n         for(int j = i; j < col; j++){\\n            m.clear();\\n            m[0] = 1;\\n            int sum = 0;\\n            for(int k = 0; k < row; k++){\\n               int current = matrix[k][j];\\n               if(i - 1 >= 0)current -= matrix[k][i - 1];\\n               sum += current;\\n               ans += m[target - sum];\\n               m[-sum]++;\\n            }\\n         }\\n      }\\n      return ans;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131751,
                "title": "same-as-target-sum-for-1d",
                "content": "```python\\ndef findSubarray(nums, target):\\n    counts, cur, ans = {0: 1}, 0, 0\\n    for n in nums:\\n        cur += n\\n        need = cur - target\\n        if need in counts:\\n            ans += counts[need]\\n        counts[cur] = counts.get(cur, 0) + 1\\n    return ans\\n\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        M, N, total = len(matrix), len(matrix[0]), 0\\n        for r in range(N):\\n            columns = [0] * M\\n            for j in range(r, N):\\n                for i in range(M):\\n                    columns[i] += matrix[i][j]\\n                total += findSubarray(columns, target)\\n        return total\\n```",
                "solutionTags": [],
                "code": "```python\\ndef findSubarray(nums, target):\\n    counts, cur, ans = {0: 1}, 0, 0\\n    for n in nums:\\n        cur += n\\n        need = cur - target\\n        if need in counts:\\n            ans += counts[need]\\n        counts[cur] = counts.get(cur, 0) + 1\\n    return ans\\n\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        M, N, total = len(matrix), len(matrix[0]), 0\\n        for r in range(N):\\n            columns = [0] * M\\n            for j in range(r, N):\\n                for i in range(M):\\n                    columns[i] += matrix[i][j]\\n                total += findSubarray(columns, target)\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1014774,
                "title": "c-36ms-9-1mb-beat-100-both-in-time-space",
                "content": "The whole idea is to calculate the sum of the row prefix and the sum of the column prefix(using row prefix), the submatrix can be described by row & column prefix.\\nYeah, I defined a special version of hashtable(linear probe) instead of using `unordered_map` in STL.\\nDO NOT USE `vector` OR `unordered_map` which may causing TLE (STL in Leetcode is not stable).\\n```\\n#define HT_LENGTH 256\\n\\nstruct HashTable {\\n    int keys[HT_LENGTH];\\n    int vals[HT_LENGTH];\\n    \\n    HashTable() { this->clear();}\\n    \\n    void clear() {\\n        keys[0] = 0; vals[0] = 1;\\n        for (int i = 1;i < HT_LENGTH;i++) keys[i] = -1;\\n    }\\n    \\n    int find(int key) {\\n        uint32_t ikey = (uint32_t)key % HT_LENGTH;\\n        for (int i = 0;i < HT_LENGTH;i++) {\\n            if (keys[ikey] == -1)  return 0;\\n            if (keys[ikey] == key) return vals[ikey];\\n            ikey = ++ikey == HT_LENGTH ? 0 : ikey;\\n        }\\n        return false;\\n    }\\n    \\n    void inc(int key) {\\n        uint32_t ikey = (uint32_t)key % HT_LENGTH;\\n        for (int i = 0;i < HT_LENGTH;i++) {\\n            if (keys[ikey] == -1) {\\n                keys[ikey] = key;\\n                vals[ikey] = 1;\\n                return;\\n            }\\n            if (keys[ikey] == key) {\\n                vals[ikey]++;\\n                return;\\n            }\\n            ikey = ++ikey == HT_LENGTH ? 0 : ikey;\\n        }\\n    }\\n};\\n\\nclass Solution {\\nprivate:\\n    HashTable ht;\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int rprefix[100][101];\\n        int m = matrix.size(), n = matrix[0].size();\\n        int ret = 0;\\n        for (int i = 0;i < m;i++) {\\n            rprefix[i][0] = 0;\\n            for (int j = 1;j <= n;j ++) {\\n                rprefix[i][j] = rprefix[i][j - 1] + matrix[i][j - 1];\\n            }\\n        }\\n        \\n        for (int i = 1;i <= n;i++) {\\n            for (int j = i;j <= n;j++) {\\n                ht.clear();\\n                int cprefix = 0;\\n                for (int row = 0;row < m;row++) {\\n                    cprefix += rprefix[row][j] - rprefix[row][i - 1];\\n                    ret += ht.find(cprefix - target);\\n                    ht.inc(cprefix);\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define HT_LENGTH 256\\n\\nstruct HashTable {\\n    int keys[HT_LENGTH];\\n    int vals[HT_LENGTH];\\n    \\n    HashTable() { this->clear();}\\n    \\n    void clear() {\\n        keys[0] = 0; vals[0] = 1;\\n        for (int i = 1;i < HT_LENGTH;i++) keys[i] = -1;\\n    }\\n    \\n    int find(int key) {\\n        uint32_t ikey = (uint32_t)key % HT_LENGTH;\\n        for (int i = 0;i < HT_LENGTH;i++) {\\n            if (keys[ikey] == -1)  return 0;\\n            if (keys[ikey] == key) return vals[ikey];\\n            ikey = ++ikey == HT_LENGTH ? 0 : ikey;\\n        }\\n        return false;\\n    }\\n    \\n    void inc(int key) {\\n        uint32_t ikey = (uint32_t)key % HT_LENGTH;\\n        for (int i = 0;i < HT_LENGTH;i++) {\\n            if (keys[ikey] == -1) {\\n                keys[ikey] = key;\\n                vals[ikey] = 1;\\n                return;\\n            }\\n            if (keys[ikey] == key) {\\n                vals[ikey]++;\\n                return;\\n            }\\n            ikey = ++ikey == HT_LENGTH ? 0 : ikey;\\n        }\\n    }\\n};\\n\\nclass Solution {\\nprivate:\\n    HashTable ht;\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int rprefix[100][101];\\n        int m = matrix.size(), n = matrix[0].size();\\n        int ret = 0;\\n        for (int i = 0;i < m;i++) {\\n            rprefix[i][0] = 0;\\n            for (int j = 1;j <= n;j ++) {\\n                rprefix[i][j] = rprefix[i][j - 1] + matrix[i][j - 1];\\n            }\\n        }\\n        \\n        for (int i = 1;i <= n;i++) {\\n            for (int j = i;j <= n;j++) {\\n                ht.clear();\\n                int cprefix = 0;\\n                for (int row = 0;row < m;row++) {\\n                    cprefix += rprefix[row][j] - rprefix[row][i - 1];\\n                    ret += ht.find(cprefix - target);\\n                    ht.inc(cprefix);\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 960894,
                "title": "c-prefix-sums-subarray-sums",
                "content": "```\\npublic class Solution\\n{\\n  public int NumSubmatrixSumTarget(int[][] matrix, int target)\\n  {\\n    var ans = 0;\\n    var pre = new int[matrix.Length + 1, matrix[0].Length];\\n\\n    // prefix sums for cols\\n    for (var i = 0; i < matrix.Length; i++)\\n      for (var j = 0; j < matrix[0].Length; j++)\\n        pre[i + 1, j] = pre[i, j] + matrix[i][j];\\n\\n    // subarray sums equal to target\\n    // where array equals to prefix sums\\n    for (var r1 = 0; r1 < matrix.Length; r1++)\\n    {\\n      for (var r2 = r1; r2 < matrix.Length; r2++)\\n      {\\n        var curr = 0;\\n        var dict = new Dictionary<int, int>();\\n\\n        for (var j = 0; j < matrix[0].Length; j++)\\n        {\\n          var el = pre[r2 + 1, j] - pre[r1, j];\\n          curr += el;\\n\\n          if (curr == target)\\n            ans++;\\n\\n          if (dict.ContainsKey(curr - target))\\n            ans += dict[curr - target];\\n\\n          dict[curr] = dict.ContainsKey(curr)\\n            ? dict[curr] + 1\\n            : 1;\\n        }\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\npublic class Solution\\n{\\n  public int NumSubmatrixSumTarget(int[][] matrix, int target)\\n  {\\n    var ans = 0;\\n    var pre = new int[matrix.Length + 1, matrix[0].Length];\\n\\n    // prefix sums for cols\\n    for (var i = 0; i < matrix.Length; i++)\\n      for (var j = 0; j < matrix[0].Length; j++)\\n        pre[i + 1, j] = pre[i, j] + matrix[i][j];\\n\\n    // subarray sums equal to target\\n    // where array equals to prefix sums\\n    for (var r1 = 0; r1 < matrix.Length; r1++)\\n    {\\n      for (var r2 = r1; r2 < matrix.Length; r2++)\\n      {\\n        var curr = 0;\\n        var dict = new Dictionary<int, int>();\\n\\n        for (var j = 0; j < matrix[0].Length; j++)\\n        {\\n          var el = pre[r2 + 1, j] - pre[r1, j];\\n          curr += el;\\n\\n          if (curr == target)\\n            ans++;\\n\\n          if (dict.ContainsKey(curr - target))\\n            ans += dict[curr - target];\\n\\n          dict[curr] = dict.ContainsKey(curr)\\n            ? dict[curr] + 1\\n            : 1;\\n        }\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888457,
                "title": "c-n-4-and-n-3",
                "content": "```O(n^4)```\\n```\\n    int numSubmatrixSumTarget(vector<vector<int>>& arr, int target) {\\n         int R = arr.size(); if (R == 0) return 0; int C = arr[0].size();    \\n         vector<vector<int>> sum(R + 1, vector<int> (C + 1, 0));\\n        \\n        for (int r = 1; r <= R; r ++) {\\n            for (int c = 1; c <= C; c ++) {\\n                sum[r][c] = arr[r - 1][c - 1] + sum[r - 1][c] + sum[r][c - 1] - sum[r - 1][c - 1];\\n            }\\n        }\\n        \\n        int count = 0;\\n        \\n        for (int r = 1; r <= R; r ++) {\\n            for (int c = 1; c <= C; c ++) {\\n                int cnt = 0;\\n                for (int r1 = 1; r1 <= r; r1 ++) {\\n                    for (int c1 = 1; c1 <= c; c1 ++) {\\n                        int arrsum = sum[r][c] - sum[r1 - 1][c] - sum[r][c1 - 1] + sum[r1 - 1][c1 - 1];\\n                        if (arrsum == target) {\\n                            cnt ++;\\n                        }       \\n                    }\\n                }\\n                count += cnt;\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n\\t\\n\\t// O(N^3)\\n\\tint numSubmatrixSumTarget(vector<vector<int>>& arr, int target) {\\n         int R = arr.size(); if (R == 0) return 0; int C = arr[0].size();    \\n         vector<vector<int>> sum(R + 1, vector<int> (C + 1, 0));\\n        \\n        for (int r = 1; r <= R; r ++) {\\n            for (int c = 1; c <= C; c ++) {\\n                sum[r][c] = arr[r - 1][c - 1] + sum[r - 1][c] + sum[r][c - 1] - sum[r - 1][c - 1];\\n            }\\n        }\\n        \\n        int count = 0;\\n        map<pair<int, int>, int> m; // {col, sum} -> frequency\\n        for (int c = 0; c <= C; c ++) m[{c, 0}] ++;        \\n        \\n            for (int c = 1; c <= C; c ++) {\\n                for (int c1 = 1; c1 <= c; c1 ++) {\\n                    for (int r = 1; r <= R; r ++) { // you beauty! for each row for each c and c1 < c\\n\\t\\t\\t\\t\\t\\tint sum1 = sum[r][c] - sum[r][c1 - 1];\\n\\t\\t\\t\\t\\t\\tcount += m[{c, sum1 - target}];\\n\\t\\t\\t\\t\\t\\tm[{c, sum1}] ++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        return count;\\n    }\\n",
                "solutionTags": [],
                "code": "```O(n^4)```",
                "codeTag": "Unknown"
            },
            {
                "id": 718255,
                "title": "java-prefix-sum-hashmap",
                "content": "```\\n    public int numSubmatrixSumTarget(int[][] mx, int t) {\\n        int res = 0, m = mx.length, n = mx[0].length;\\n        for (int i = 0;i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                mx[i][j] += mx[i][j - 1];\\n            }\\n        }\\n        for (int l = 0; l < n; l++) {\\n            for (int r = l; r < n; r++) {\\n                Map<Integer, Integer> map = new HashMap<>(); \\n                map.put(0, 1);// init empty sub mx;\\n                for (int i = 0, sum = 0; i < m; i++) {\\n                    sum += (mx[i][r] - (l == 0 ? 0 : mx[i][l - 1]));\\n                    res += map.getOrDefault(sum - t, 0);\\n                    map.put(sum, map.getOrDefault(sum, 0) + 1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numSubmatrixSumTarget(int[][] mx, int t) {\\n        int res = 0, m = mx.length, n = mx[0].length;\\n        for (int i = 0;i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                mx[i][j] += mx[i][j - 1];\\n            }\\n        }\\n        for (int l = 0; l < n; l++) {\\n            for (int r = l; r < n; r++) {\\n                Map<Integer, Integer> map = new HashMap<>(); \\n                map.put(0, 1);// init empty sub mx;\\n                for (int i = 0, sum = 0; i < m; i++) {\\n                    sum += (mx[i][r] - (l == 0 ? 0 : mx[i][l - 1]));\\n                    res += map.getOrDefault(sum - t, 0);\\n                    map.put(sum, map.getOrDefault(sum, 0) + 1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 591215,
                "title": "convert-the-problem-to-range-sum-2d-array-immutable-o-x-2-solution",
                "content": "**X = rows * cols**\\n\\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        NumMatrix nm = new NumMatrix(matrix);\\n        int count = 0;\\n        int r = matrix.length;\\n        int c = matrix[0].length;\\n        for(int i0 = 0 ; i0 < r; i0++){\\n            for(int j0 = 0 ; j0 < c; j0++){\\n                for(int i1 = i0 ; i1 < r; i1++){\\n                    for(int j1 = j0 ; j1 < c; j1++){\\n                       if(nm.sumRegion(i0,j0,i1,j1) == target){\\n                           count++;\\n                       }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\nclass NumMatrix {\\n    int[][] ps;\\n    public NumMatrix(int[][] matrix) {\\n      if (matrix == null || matrix.length == 0) return;\\n      ps = new int[matrix.length + 1][matrix[0].length + 1];\\n      int r = ps.length;\\n      int c = ps[0].length;\\n      for (int i = 1; i < r; i++) {\\n        for (int j = 1; j < c; j++) {\\n          int top = ps[i - 1][j];\\n          int left = ps[i][j - 1];\\n          int diag = ps[i - 1][j - 1];\\n          int current = matrix[i - 1][j - 1];\\n          ps[i][j] = current + top + left  - diag;\\n        }\\n      }\\n    }\\n    \\n    public int sumRegion(int x1, int y1, int x2, int y2) {\\n      if (ps == null) return 0;\\n      x2++;\\n      y2++;\\n      x1++;\\n      y1++;\\n      int current = ps[x2][y2];\\n      int top = ps[x1 - 1][y2];\\n      int left = ps[x2][y1 - 1];\\n      int diag = ps[x1-1][y1-1];\\n      return current - top - left + diag;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        NumMatrix nm = new NumMatrix(matrix);\\n        int count = 0;\\n        int r = matrix.length;\\n        int c = matrix[0].length;\\n        for(int i0 = 0 ; i0 < r; i0++){\\n            for(int j0 = 0 ; j0 < c; j0++){\\n                for(int i1 = i0 ; i1 < r; i1++){\\n                    for(int j1 = j0 ; j1 < c; j1++){\\n                       if(nm.sumRegion(i0,j0,i1,j1) == target){\\n                           count++;\\n                       }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\nclass NumMatrix {\\n    int[][] ps;\\n    public NumMatrix(int[][] matrix) {\\n      if (matrix == null || matrix.length == 0) return;\\n      ps = new int[matrix.length + 1][matrix[0].length + 1];\\n      int r = ps.length;\\n      int c = ps[0].length;\\n      for (int i = 1; i < r; i++) {\\n        for (int j = 1; j < c; j++) {\\n          int top = ps[i - 1][j];\\n          int left = ps[i][j - 1];\\n          int diag = ps[i - 1][j - 1];\\n          int current = matrix[i - 1][j - 1];\\n          ps[i][j] = current + top + left  - diag;\\n        }\\n      }\\n    }\\n    \\n    public int sumRegion(int x1, int y1, int x2, int y2) {\\n      if (ps == null) return 0;\\n      x2++;\\n      y2++;\\n      x1++;\\n      y1++;\\n      int current = ps[x2][y2];\\n      int top = ps[x1 - 1][y2];\\n      int left = ps[x2][y1 - 1];\\n      int diag = ps[x1-1][y1-1];\\n      return current - top - left + diag;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556875,
                "title": "c-o-n-2-m-time-o-n-m-space-with-comments-in-code",
                "content": "The idea is like many others pointed out  - to use DP and calculate prefix sums either for rows or for columns, I used rows below. \\n\\nAfter that by changing the width of the submatrix (imaging vertically slicing it),we go from top to the bottom processing each row and calculate the sum of the submatrix composed of the intervals limited by the left and right border of the slice. Prefix sums in dp array calculated before help here. What we get as a result is a prefix sum of submatrices.\\n\\nFor every such submatrix we check if we could start somewhere in the past and sum to the target by using a hashtable where we store the count of every submatrix prefix we\\'ve seen.\\n\\nWe essentially check if we\\'ve seen the prefix = currentsum-target before and how many times and sum these values to get the answer. Hope it helps!\\n\\n```\\npublic class Solution {\\n    public int NumSubmatrixSumTarget(int[][] matrix, int target) \\n    {\\n        if(matrix==null || matrix.Length ==0)\\n        {\\n            return 0;\\n        }\\n        \\n        int w = matrix[0].Length;\\n        int h = matrix.Length;\\n        \\n        // use new matrix, however if reuseif allowed it\\'s possible to have O(1) space\\n        // by overwriting the values in the source matrix\\n        int[,] dp = new int[h,w+1];\\n        \\n        for (int i = 0; i < h; i++) {\\n            for (int j = 0; j < w; j++) {\\n                //prefix sum for the row\\n                dp[i,j+1] = dp[i,j] + matrix[i][j];\\n            }\\n        }\\n        \\n        // holds the remainder sums of the matrices which could serve as a\\n        // starting point for our submatrix.\\n        Dictionary<int, int> starts = new Dictionary<int,int>();\\n\\n        int res = 0;\\n        // iterate through all possible vertical submatrices\\n        for (int i = 1; i <= w; i++) \\n        {\\n            for (int j = i; j <= w; j++) \\n            {\\n                starts.Clear();\\n                starts[0] = 1;\\n                \\n                // holds the submatrix sum, it\\'s the frontier of the imaginary 1D array where each\\n                // element is a matrix sum seen up and including this element, can be seen as a prefix sum of submatrices\\n                int end = 0;\\n                \\n                for (int k = 0; k < h; k++) \\n                {\\n                    // find the sum of the matrix elements up to this point,\\n                    // by summing up the interval sums [i,j] row by row using the prefix sums calculated before\\n                    end += dp[k,j] - dp[k,i - 1];\\n                    \\n                    // \"start\" prefix sum, \\n                    // it means that  if somewhere in the past we saw sum==start -> \\n                    // we found a suitable matrix now as we could start from there.\\n                    // end-start = target => start = end - target;\\n                    int start = end - target; \\n                    \\n                    // add the number of matrices we\\'ve seen so far, so that they had the sum equal to the\\n                    // complement we need\\n                    res += starts.ContainsKey(start) ? starts[start]: 0;\\n                    \\n                    // log the sum for the current matrix, \\n                    // it will serve as a start prefix sum (\"start\") later when will be checking for possible complements\\n                    starts[end] = (starts.ContainsKey(end) ? starts[end]+1 : 1);                 \\n                }\\n            }\\n        }            \\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumSubmatrixSumTarget(int[][] matrix, int target) \\n    {\\n        if(matrix==null || matrix.Length ==0)\\n        {\\n            return 0;\\n        }\\n        \\n        int w = matrix[0].Length;\\n        int h = matrix.Length;\\n        \\n        // use new matrix, however if reuseif allowed it\\'s possible to have O(1) space\\n        // by overwriting the values in the source matrix\\n        int[,] dp = new int[h,w+1];\\n        \\n        for (int i = 0; i < h; i++) {\\n            for (int j = 0; j < w; j++) {\\n                //prefix sum for the row\\n                dp[i,j+1] = dp[i,j] + matrix[i][j];\\n            }\\n        }\\n        \\n        // holds the remainder sums of the matrices which could serve as a\\n        // starting point for our submatrix.\\n        Dictionary<int, int> starts = new Dictionary<int,int>();\\n\\n        int res = 0;\\n        // iterate through all possible vertical submatrices\\n        for (int i = 1; i <= w; i++) \\n        {\\n            for (int j = i; j <= w; j++) \\n            {\\n                starts.Clear();\\n                starts[0] = 1;\\n                \\n                // holds the submatrix sum, it\\'s the frontier of the imaginary 1D array where each\\n                // element is a matrix sum seen up and including this element, can be seen as a prefix sum of submatrices\\n                int end = 0;\\n                \\n                for (int k = 0; k < h; k++) \\n                {\\n                    // find the sum of the matrix elements up to this point,\\n                    // by summing up the interval sums [i,j] row by row using the prefix sums calculated before\\n                    end += dp[k,j] - dp[k,i - 1];\\n                    \\n                    // \"start\" prefix sum, \\n                    // it means that  if somewhere in the past we saw sum==start -> \\n                    // we found a suitable matrix now as we could start from there.\\n                    // end-start = target => start = end - target;\\n                    int start = end - target; \\n                    \\n                    // add the number of matrices we\\'ve seen so far, so that they had the sum equal to the\\n                    // complement we need\\n                    res += starts.ContainsKey(start) ? starts[start]: 0;\\n                    \\n                    // log the sum for the current matrix, \\n                    // it will serve as a start prefix sum (\"start\") later when will be checking for possible complements\\n                    starts[end] = (starts.ContainsKey(end) ? starts[end]+1 : 1);                 \\n                }\\n            }\\n        }            \\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520659,
                "title": "one-simple-graph-can-explain-the-algorithm-entirely-and-clearly-2d-prefix-sum",
                "content": "One graph can explain everything. \\n\\n![image](https://assets.leetcode.com/users/qiuqiushasha/image_1582667961.png)\\n\\n\\n```Scala\\n  def numSubmatrixSumTarget(matrix: Array[Array[Int]], target: Int): Int = {\\n\\n    val m = matrix.length\\n    val n = matrix(0).length\\n    if (m == 1 && n == 1) return if (matrix(0)(0) == target) 1 else 0\\n    var res = 0\\n    val table = Array.ofDim[Int](m, n + 1)\\n    for (i <- 0 until m; j <- 1 to n) table(i)(j) = table(i)(j - 1) + matrix(i)(j - 1)\\n    for (i <- 1 to n; j <- i to n) {\\n      var prefixSum = 0\\n      import scala.collection.mutable.Map\\n      val map = Map[Int, Int]()\\n      map.put(0, 1)\\n      for (k <- 0 until m) {\\n        prefixSum += table(k)(j) - table(k)(i - 1)\\n        res += map.getOrElse(prefixSum - target, 0)\\n        map.put(prefixSum, map.getOrElse(prefixSum, 0) + 1)\\n      }\\n    }\\n    res\\n  }\\n```",
                "solutionTags": [],
                "code": "```Scala\\n  def numSubmatrixSumTarget(matrix: Array[Array[Int]], target: Int): Int = {\\n\\n    val m = matrix.length\\n    val n = matrix(0).length\\n    if (m == 1 && n == 1) return if (matrix(0)(0) == target) 1 else 0\\n    var res = 0\\n    val table = Array.ofDim[Int](m, n + 1)\\n    for (i <- 0 until m; j <- 1 to n) table(i)(j) = table(i)(j - 1) + matrix(i)(j - 1)\\n    for (i <- 1 to n; j <- i to n) {\\n      var prefixSum = 0\\n      import scala.collection.mutable.Map\\n      val map = Map[Int, Int]()\\n      map.put(0, 1)\\n      for (k <- 0 until m) {\\n        prefixSum += table(k)(j) - table(k)(i - 1)\\n        res += map.getOrElse(prefixSum - target, 0)\\n        map.put(prefixSum, map.getOrElse(prefixSum, 0) + 1)\\n      }\\n    }\\n    res\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 471030,
                "title": "python-easy-to-understand-using-560-beats-91-explained-in-description",
                "content": "```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        count = 0\\n        for i in range(m):\\n            nums = [0] * n\\n            for j in range(i, m):\\n                for k in range(n):\\n                    nums[k] += matrix[j][k]\\n                print(nums)\\n                count += self.subarraySum(nums, target)\\n        return count\\n    \\n    def subarraySum(self, nums: List[int], k: int) -> int:\\n        freq_map = {0: 1}\\n        result = 0\\n        curr_sum = 0 \\n        for i in range(len(nums)):\\n            curr_sum += nums[i]\\n            if curr_sum - k in freq_map:\\n                result+=freq_map[curr_sum - k]\\n            freq_map[curr_sum] = freq_map.get(curr_sum, 0) + 1\\n        return result\\n```\\t\\t\\n\\nExample:\\ntarget = 0 \\n[[ 1, -1,  2],\\n [ 0,  1, -2],\\n [-3, 2,  1 ]]\\nThis is the easiest way to think about this problem: \\n1) We need to find the number of rectangles in the matrix that sum upto the target. \\nThe first time SubarraySum() from problem #560 is called, only the first row of the matrix is sent. The function will return the number of contiguous sub arrays which add upto 0. For the first row this is just 1,  the array containing [1, -1]\\n\\n2) The second time it is called, the input to the function is the sum of the first and second rows: [1, 0, 0]. By doing this we are in a way \"collapsing\" the second row into the first. The number of subarrays in this combined array that add upto 0 will give us the number of submatrices with sizes in the range (2, 6). [why is it in the range 2,6? keep reading]\\n\\n3)  The third time it is called the input to the function is the sum of first, second and third rows: [-2, 2, 1]. The subarraySum function will find that the only contiguous sub array that adds to 0 is [-2, 2]. [-2,2]  essentially represents: \\n[[ 1, -1],\\n [ 0,  1],\\n [-3, 2]]\\nin the original array\\n4) Similarly subarraySum is called a total of 8 times. \\nO(M^2 *N)\\nHope this helps.\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        count = 0\\n        for i in range(m):\\n            nums = [0] * n\\n            for j in range(i, m):\\n                for k in range(n):\\n                    nums[k] += matrix[j][k]\\n                print(nums)\\n                count += self.subarraySum(nums, target)\\n        return count\\n    \\n    def subarraySum(self, nums: List[int], k: int) -> int:\\n        freq_map = {0: 1}\\n        result = 0\\n        curr_sum = 0 \\n        for i in range(len(nums)):\\n            curr_sum += nums[i]\\n            if curr_sum - k in freq_map:\\n                result+=freq_map[curr_sum - k]\\n            freq_map[curr_sum] = freq_map.get(curr_sum, 0) + 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431893,
                "title": "prefix-sum-and-hash-table-time-complxity-o-n-3-faster-than-95-84",
                "content": "Runtime: 3540 ms, faster than 95.84% of C++ online submissions for Number of Submatrices That Sum to Target.\\nMemory Usage: 456.8 MB, less than 100.00% of C++ online submissions for Number of Submatrices That Sum to Target.\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        size_t rows = matrix.size(), cols = matrix[0].size();\\n\\n        // calculate prefix sum\\n        for (size_t row = 0; row < rows; ++row) {\\n            for (size_t col = 1; col < cols; ++col) {\\n                matrix[row][col] += matrix[row][col - 1];\\n            }\\n        }\\n        for (size_t col = 0; col < cols; ++col) {\\n            for (size_t row = 1; row < rows; ++row) {\\n                matrix[row][col] += matrix[row - 1][col];\\n            }\\n        }\\n\\n        int cnt = 0;\\n        // calculate the sum of matrix[r1, r2][c1, c2]\\n        // target = matrix[r2][c2] - matrix[r1 - 1][c2] - matrix[r2][c1 - 1] + matrix[r1 - 1][c1 - 1]\\n        // ==> seperate c1 and c2\\n        // ==> matrix[r2][c2] - matrix[r1 - 1][c2] = target + (matrix[r2][c1 - 1] - matrix[r1 - 1][c1 - 1])\\n        for (size_t r1 = 0; r1 < rows; ++r1) {\\n            for (size_t r2 = r1; r2 < rows; ++r2) {\\n\\t\\t\\t\\t// Instead of iteration by c1 then by c2 (this solution\\'s time complxity is O(N^4)), \\n\\t\\t\\t\\t// cache data in hash table when iterating c and then find result in hash table during later iteration.\\n\\t\\t\\t\\t// In this way, the time complxity reduces to O(N^3)\\n                unordered_multiset<int> sums;  // cache the sums of matrix[r1...r2][0...c] to reduce the loop by one layer\\n                for (size_t c = 0; c < cols; ++c) {\\n                    int sum = r1 == 0 ? matrix[r2][c] : matrix[r2][c] - matrix[r1 - 1][c];\\n                    if (sum == target) ++cnt;\\n                    cnt += sums.count(sum - target);\\n                    sums.insert(sum);\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        size_t rows = matrix.size(), cols = matrix[0].size();\\n\\n        // calculate prefix sum\\n        for (size_t row = 0; row < rows; ++row) {\\n            for (size_t col = 1; col < cols; ++col) {\\n                matrix[row][col] += matrix[row][col - 1];\\n            }\\n        }\\n        for (size_t col = 0; col < cols; ++col) {\\n            for (size_t row = 1; row < rows; ++row) {\\n                matrix[row][col] += matrix[row - 1][col];\\n            }\\n        }\\n\\n        int cnt = 0;\\n        // calculate the sum of matrix[r1, r2][c1, c2]\\n        // target = matrix[r2][c2] - matrix[r1 - 1][c2] - matrix[r2][c1 - 1] + matrix[r1 - 1][c1 - 1]\\n        // ==> seperate c1 and c2\\n        // ==> matrix[r2][c2] - matrix[r1 - 1][c2] = target + (matrix[r2][c1 - 1] - matrix[r1 - 1][c1 - 1])\\n        for (size_t r1 = 0; r1 < rows; ++r1) {\\n            for (size_t r2 = r1; r2 < rows; ++r2) {\\n\\t\\t\\t\\t// Instead of iteration by c1 then by c2 (this solution\\'s time complxity is O(N^4)), \\n\\t\\t\\t\\t// cache data in hash table when iterating c and then find result in hash table during later iteration.\\n\\t\\t\\t\\t// In this way, the time complxity reduces to O(N^3)\\n                unordered_multiset<int> sums;  // cache the sums of matrix[r1...r2][0...c] to reduce the loop by one layer\\n                for (size_t c = 0; c < cols; ++c) {\\n                    int sum = r1 == 0 ? matrix[r2][c] : matrix[r2][c] - matrix[r1 - 1][c];\\n                    if (sum == target) ++cnt;\\n                    cnt += sums.count(sum - target);\\n                    sums.insert(sum);\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 357633,
                "title": "java-solution",
                "content": "```\\npublic int numSubmatrixSumTarget(int[][] matrix, int target) {\\n\\tint m = matrix.length;\\n\\tint n = matrix[0].length;\\n\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 1; j < n; j++) {\\n\\t\\t\\tmatrix[i][j] += matrix[i][j - 1];\\n\\t\\t}\\n\\t}\\n\\tint ans = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tfor (int j = i; j < n; j++) {\\n\\t\\t\\tMap<Integer, Integer> cnt = new HashMap<>();\\n\\t\\t\\tcnt.put(0, 1);\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int k = 0; k < m; k++) {\\n\\t\\t\\t\\tsum += matrix[k][j] - (i > 0 ? matrix[k][i - 1] : 0);\\n\\t\\t\\t\\tans += cnt.getOrDefault(sum - target, 0);\\n\\t\\t\\t\\tcnt.put(sum, cnt.getOrDefault(sum, 0) + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numSubmatrixSumTarget(int[][] matrix, int target) {\\n\\tint m = matrix.length;\\n\\tint n = matrix[0].length;\\n\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 1; j < n; j++) {\\n\\t\\t\\tmatrix[i][j] += matrix[i][j - 1];\\n\\t\\t}\\n\\t}\\n\\tint ans = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tfor (int j = i; j < n; j++) {\\n\\t\\t\\tMap<Integer, Integer> cnt = new HashMap<>();\\n\\t\\t\\tcnt.put(0, 1);\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int k = 0; k < m; k++) {\\n\\t\\t\\t\\tsum += matrix[k][j] - (i > 0 ? matrix[k][i - 1] : 0);\\n\\t\\t\\t\\tans += cnt.getOrDefault(sum - target, 0);\\n\\t\\t\\t\\tcnt.put(sum, cnt.getOrDefault(sum, 0) + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 305264,
                "title": "c-optimal-time-complexity-with-preprocessing-practice-in-2019",
                "content": "It is hard level algorithm. The challenge is to lower time complexity and avoid redundant calculation. I will write down what I learn later, this solution is written just by code study one of most popular post. \\n\\n**Case study matrix with value 1, 5 x 5, target value 4**\\n\\nLet us work on a case study a matrix with value 1, 5 x 5, target value 4. Let us count how many submatrix with value 4. \\n\\n 1    1     1    1     1\\n 1    1     1    1     1\\n 1    1     1    1     1\\n 1    1     1    1     1\\n 1    1     1    1     1\\n\\nCase: Rows = 1\\n\\nFirst we can try one row, how many submatrix with value 4, we know that the matrix should be 4 columns, each row there are two options, starting from column = 0 or column = 1; all five rows should be counted. Total is 2 x 5 = 10;\\n\\nBut in general, we should try all options for column in total, from 1 to 5. \\n\\nCase: Rows = 2\\nFirst we can try matrix 2 x 2, how many choices we have, there are 4 x 4 = 16 choices. \\n\\nBut in reality, we should try all options for 2 rows matrix, column can be from 1 to 5, target value is 4. \\n\\nI will add the detail to explain how to make this simple case work, and also time complexity is optimal. The posts I study are [here](https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/discuss/303773/C%2B%2B-O(n3)-Simple-1D-Subarray-target-sum-applied-to-2D-array). \\n\\n```\\npublic class Solution {\\n    public int NumSubmatrixSumTarget(int[][] matrix, int target)\\n        {\\n            var rows = matrix.Length;\\n            var columns = matrix[0].Length;\\n            var sum =  new int[columns];            \\n        \\n            int answer = 0;\\n            for (int row = 0; row < rows; row++)\\n            {\\n                for (int col = 0; col < columns; col++)\\n                {\\n                    sum[col] = 0;\\n                }\\n            \\n                for(int subRow = row; subRow < rows; subRow++)\\n                {\\n                    for (int col = 0; col < columns; col++)\\n                    {\\n                        sum[col] += matrix[subRow][col];\\n                    }\\n                \\n                    var preSet = new Dictionary<int,int>();\\n\\n                    int preSum = 0;\\n                    preSet.Add(preSum, 1);\\n                \\n                    for(int col = 0;col < columns;col++){\\n                        preSum += sum[col];\\n\\n                        int search = preSum - target;\\n\\n                        if(preSet.ContainsKey(search)){\\n                            answer += preSet[search];\\n                        }\\n\\n                        if (!preSet.ContainsKey(preSum))\\n                            preSet.Add(preSum, 0);\\n                        \\n                        preSet[preSum]++;\\n                    }\\n                }            \\n            }\\n        \\n            return answer;\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumSubmatrixSumTarget(int[][] matrix, int target)\\n        {\\n            var rows = matrix.Length;\\n            var columns = matrix[0].Length;\\n            var sum =  new int[columns];            \\n        \\n            int answer = 0;\\n            for (int row = 0; row < rows; row++)\\n            {\\n                for (int col = 0; col < columns; col++)\\n                {\\n                    sum[col] = 0;\\n                }\\n            \\n                for(int subRow = row; subRow < rows; subRow++)\\n                {\\n                    for (int col = 0; col < columns; col++)\\n                    {\\n                        sum[col] += matrix[subRow][col];\\n                    }\\n                \\n                    var preSet = new Dictionary<int,int>();\\n\\n                    int preSum = 0;\\n                    preSet.Add(preSum, 1);\\n                \\n                    for(int col = 0;col < columns;col++){\\n                        preSum += sum[col];\\n\\n                        int search = preSum - target;\\n\\n                        if(preSet.ContainsKey(search)){\\n                            answer += preSet[search];\\n                        }\\n\\n                        if (!preSet.ContainsKey(preSum))\\n                            preSet.Add(preSum, 0);\\n                        \\n                        preSet[preSum]++;\\n                    }\\n                }            \\n            }\\n        \\n            return answer;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 303765,
                "title": "my-java-solution",
                "content": "```\\npublic int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        \\n        int[][] dp = new int[m+1][n+1];\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i+1][j+1] = dp[i+1][j] + matrix[i][j];\\n            }\\n        }\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i+1][j+1] += dp[i][j+1];\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int a = 0; a < m ; a++) {\\n            for(int b = 0; b < n; b++) {\\n                \\n                for(int c = a + 1; c <= m; c++) {\\n                    for(int d = b + 1; d <= n; d++) {\\n                        int sum = dp[c][d] - dp[c][b] - dp[a][d] + dp[a][b];\\n                        if(sum == target) res++;\\n                    }\\n                }\\n\\n            }\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        \\n        int[][] dp = new int[m+1][n+1];\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i+1][j+1] = dp[i+1][j] + matrix[i][j];\\n            }\\n        }\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i+1][j+1] += dp[i][j+1];\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int a = 0; a < m ; a++) {\\n            for(int b = 0; b < n; b++) {\\n                \\n                for(int c = a + 1; c <= m; c++) {\\n                    for(int d = b + 1; d <= n; d++) {\\n                        int sum = dp[c][d] - dp[c][b] - dp[a][d] + dp[a][b];\\n                        if(sum == target) res++;\\n                    }\\n                }\\n\\n            }\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3977216,
                "title": "concise-easy-to-understand-intuition-and-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFor each pair of columns (i, j) from index i to j inclusive:\\n\\nCreate a hashmap (freq) to store the frequency of cumulative sums.\\nInitialize the cumulative sum sum as 0.\\nInitialize cumuColSum to track the cumulative column sums for each row, starting from column i to column j.\\nTraverse each row (k) from 0 to n-1:\\n\\nUpdate the cumuColSum[k] with the current value in matrix[k][j] plus the previous cumulative sum value.\\nIncrement the frequency of the current cumulative sum sum in the freq map.\\nUpdate sum by adding the current cumuColSum[k].\\nAt each step in row traversal:\\n\\nIncrement the count by the frequency of (sum - target) in the freq map. This implies that there are freq[sum - target] submatrices that sum to the target value ending at the current row.\\nThe count is the final result representing the total number of submatrices across all column pairs that sum up to the target value.\\n\\n\\n\\n# Complexity\\n- Time complexity:O(m^2*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n\\n        int count =0;\\n\\n        for(int i=0;i<m;i++){\\n            vector<int> cumuColSum(n,0);\\n\\n            for(int j=i;j<m;j++){\\n                unordered_map<int,int> freq;\\n                int sum = 0;\\n                for(int k=0;k<n;k++){\\n                    cumuColSum[k] = matrix[k][j] + cumuColSum[k];\\n                    freq[sum]++;\\n                    sum += cumuColSum[k];\\n                    count += freq[sum-target];\\n                    \\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n\\n        int count =0;\\n\\n        for(int i=0;i<m;i++){\\n            vector<int> cumuColSum(n,0);\\n\\n            for(int j=i;j<m;j++){\\n                unordered_map<int,int> freq;\\n                int sum = 0;\\n                for(int k=0;k<n;k++){\\n                    cumuColSum[k] = matrix[k][j] + cumuColSum[k];\\n                    freq[sum]++;\\n                    sum += cumuColSum[k];\\n                    count += freq[sum-target];\\n                    \\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567068,
                "title": "c-cleanest-code-with-comments-easiest-to-understand",
                "content": "Please Upvote\\nBasic idea: Fix the position of the upper and lower rows and add each column in the vertical direction to get a one-dimensional array. Then scan each presum from left to right and put it into a Hash table. Check to see if the current presum-target is already in the hash table. If it exists, then the sum of submatrix equals target.\\n\\nTime complexity: o(N^3)\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int r=matrix.size();\\n        int c=matrix[0].size();\\n        int ans=0;\\n        for(int i=0;i<r;i++){\\n            vector<int> v(c,0);\\n            //taking the sum of each column\\n            for(int j=i;j<r;j++){\\n                for(int k=0;k<c;k++)\\n                {\\n                    v[k]+=matrix[j][k];//taking the sum of each column(vertcially)\\n                }\\n                /*\\n                i:------------\\n                \\n                j:------------\\n                */\\n                //converted whole i to j submatric to a simple 1 d horizontal array by collecting the sum of columns vertcially\\n                //now thats a 1d problem of how many subarrays sum up to target\\n                map<int,int> mp;\\n                mp[0]=1;\\n                int sm=0;\\n                for(int p=0;p<v.size();p++){\\n                    sm+=v[p];\\n                    ans+=mp[sm-target];\\n                    mp[sm]++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int r=matrix.size();\\n        int c=matrix[0].size();\\n        int ans=0;\\n        for(int i=0;i<r;i++){\\n            vector<int> v(c,0);\\n            //taking the sum of each column\\n            for(int j=i;j<r;j++){\\n                for(int k=0;k<c;k++)\\n                {\\n                    v[k]+=matrix[j][k];//taking the sum of each column(vertcially)\\n                }\\n                /*\\n                i:------------\\n                \\n                j:------------\\n                */\\n                //converted whole i to j submatric to a simple 1 d horizontal array by collecting the sum of columns vertcially\\n                //now thats a 1d problem of how many subarrays sum up to target\\n                map<int,int> mp;\\n                mp[0]=1;\\n                int sm=0;\\n                for(int p=0;p<v.size();p++){\\n                    sm+=v[p];\\n                    ans+=mp[sm-target];\\n                    mp[sm]++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415777,
                "title": "c-prefix-sum-o-n-3",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // standard problem of number of subarrays with given target sum\\n    int func(vector<int> a,int target){\\n        map<int,int> mp;\\n        int pref = 0;\\n        mp[0]=1;\\n        int cnt=0;\\n        int n = a.size();\\n        for(int i=0;i<n;i++){\\n            pref+=a[i];\\n            // prefj-prefi = target\\n            // for current prefj looking for prefixes with sum of prefj-target\\n            if(mp.find(pref-target) != mp.end()) cnt+=mp[pref-target];\\n            mp[pref]++;\\n        }\\n        return cnt;\\n    }\\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int ans = 0;\\n        for(int row1 = 0;row1<n;row1++){\\n            vector<int> psum(m,0);\\n            for(int row2=row1;row2<n;row2++){\\n                for(int i=0;i<m;i++)psum[i]+=matrix[row2][i];\\n                ans+=func(psum,target);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // standard problem of number of subarrays with given target sum\\n    int func(vector<int> a,int target){\\n        map<int,int> mp;\\n        int pref = 0;\\n        mp[0]=1;\\n        int cnt=0;\\n        int n = a.size();\\n        for(int i=0;i<n;i++){\\n            pref+=a[i];\\n            // prefj-prefi = target\\n            // for current prefj looking for prefixes with sum of prefj-target\\n            if(mp.find(pref-target) != mp.end()) cnt+=mp[pref-target];\\n            mp[pref]++;\\n        }\\n        return cnt;\\n    }\\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int ans = 0;\\n        for(int row1 = 0;row1<n;row1++){\\n            vector<int> psum(m,0);\\n            for(int row2=row1;row2<n;row2++){\\n                for(int i=0;i<m;i++)psum[i]+=matrix[row2][i];\\n                ans+=func(psum,target);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300831,
                "title": "96-tc-and-71-sc-easy-python-solution",
                "content": "```\\ndef numSubmatrixSumTarget(self, mat: List[List[int]], target: int) -> int:\\n\\tm, n = len(mat), len(mat[0])\\n\\tfor i in range(m):\\n\\t\\tfor j in range(1, n):\\n\\t\\t\\tmat[i][j] += mat[i][j-1]\\n\\t\\tmat[i] = [0] + mat[i]\\n\\tans = 0\\n\\td = defaultdict(int)\\n\\tfor col1 in range(n):\\n\\t\\tfor col2 in range(col1+1, n+1):\\n\\t\\t\\ttemp = 0\\n\\t\\t\\td[0] = 1\\n\\t\\t\\tfor r in range(m):\\n\\t\\t\\t\\ttemp += mat[r][col2] - mat[r][col1]\\n\\t\\t\\t\\tif(temp - target in d):\\n\\t\\t\\t\\t\\tans += d[temp - target]\\n\\t\\t\\t\\td[temp] += 1\\n\\t\\t\\td.clear()\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef numSubmatrixSumTarget(self, mat: List[List[int]], target: int) -> int:\\n\\tm, n = len(mat), len(mat[0])\\n\\tfor i in range(m):\\n\\t\\tfor j in range(1, n):\\n\\t\\t\\tmat[i][j] += mat[i][j-1]\\n\\t\\tmat[i] = [0] + mat[i]\\n\\tans = 0\\n\\td = defaultdict(int)\\n\\tfor col1 in range(n):\\n\\t\\tfor col2 in range(col1+1, n+1):\\n\\t\\t\\ttemp = 0\\n\\t\\t\\td[0] = 1\\n\\t\\t\\tfor r in range(m):\\n\\t\\t\\t\\ttemp += mat[r][col2] - mat[r][col1]\\n\\t\\t\\t\\tif(temp - target in d):\\n\\t\\t\\t\\t\\tans += d[temp - target]\\n\\t\\t\\t\\td[temp] += 1\\n\\t\\t\\td.clear()\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2300379,
                "title": "c-variation-of-subarray-sum-equals-k",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& mat, int target) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        \\n        // STEP 01 : prefix sum\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        \\n        int res=0;\\n        \\n        // STEP 02 : for every pair of column perform operation - subarray sum technique with \\n        //           with sliding window to get every apir of column\\n        for(int c1=0;c1<m;c1++){\\n            for(int c2=c1;c2<m;c2++){\\n                \\n                // since we handled every column pair now work on operation on every rows\\n                // subarray sum equals k technique\\n                int sum=0;\\n                unordered_map<int,int> mp;\\n                mp[0]=1;\\n                \\n                for(int row=0;row<n;row++){\\n                    \\n                    sum+=mat[row][c2];\\n                    \\n                    // remove extra left part(search space) if there \\n                    if(c1>0) sum-=mat[row][c1-1];\\n                    \\n                    // exact same as subarray sum equals k\\n                    int srch = sum-target;\\n                    \\n                    if(mp.find(srch)!=mp.end()) res += mp[srch];\\n                    \\n                    mp[sum]++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Hash Table",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& mat, int target) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        \\n        // STEP 01 : prefix sum\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        \\n        int res=0;\\n        \\n        // STEP 02 : for every pair of column perform operation - subarray sum technique with \\n        //           with sliding window to get every apir of column\\n        for(int c1=0;c1<m;c1++){\\n            for(int c2=c1;c2<m;c2++){\\n                \\n                // since we handled every column pair now work on operation on every rows\\n                // subarray sum equals k technique\\n                int sum=0;\\n                unordered_map<int,int> mp;\\n                mp[0]=1;\\n                \\n                for(int row=0;row<n;row++){\\n                    \\n                    sum+=mat[row][c2];\\n                    \\n                    // remove extra left part(search space) if there \\n                    if(c1>0) sum-=mat[row][c1-1];\\n                    \\n                    // exact same as subarray sum equals k\\n                    int srch = sum-target;\\n                    \\n                    if(mp.find(srch)!=mp.end()) res += mp[srch];\\n                    \\n                    mp[sum]++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300145,
                "title": "c-o-n-3-generic-solution-that-reduces-to-lc-560-subarray-sum-equals-k",
                "content": "The principal observation here is that this problem is reducable to solving multiple problems of the type [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/) . How?\\n\\n- Finding all sub-matrices that sum to `target` can be tackled by going over all sub-matrices. We can do this traversal by consider all submatrices whose ends lie between column indices `lo` and `hi` (inclusive and `lo <= hi`) for all valid pairs of column indices `(lo, hi)`. We argue that each such **sub-problem** (i.e. all sub-matrices between a given pair of column indices `(lo, hi)` is an instance of [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/) . This we show below.\\n- Imagine that we have calculated the **prefix-sum for each row** of the `matrix` i.e. `sum[r][c]` holds the sum `matrix[r][0] + matrix[r][1] + ... + matrix[r][c]` for all `(r, c)`. (We don\\'t create a separate 2D array `sum` for this, but do it in-place in the input 2D array `matrix` itself, but using a separate 2D array avoids confusion when explaining the concept).\\n- Now, consider a pair of columns `lo` and `hi`. For each such pair, we can create an array (say `submat` such that `submat[r] = sum[r][hi] - sum[r][lo-1]` i.e. `submat[r]` is the sum of all values in the row `r` of the original matrix between columns `lo` and `hi` (inclusive). Finding all non-empty subarrays in `submat` that sum to target is precisely what we\\'re looking for as the **sub-problem**.\\n- We use the class `SubarraySumCount` that abstracts away the details of [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/) in a clean interface.\\n\\n```\\n/*\\n// Usage:\\n    SubarraySumCount s {target};\\n    for(auto const &v : values)\\n        s.add(v);\\n    auto res = s.count();\\n// `res` holds the count of all non-empty subarrays from `values`\\n// that have a sum equal to `target`\\n\\n*/\\n\\ntemplate <typename T>\\nclass SubarraySumCount {\\n    static_assert(is_integral_v<T>, \"Must specify an Integral Type\");\\n    \\n    unordered_map<T, size_t> ct;\\n    T target;\\n    T cum {0};\\n    size_t res {0};\\npublic:\\n    SubarraySumCount(const T &target) : target(target) {\\n        ct[0] = 1;\\n    }\\n    \\n    inline void add(const T& val) {\\n        cum += val;\\n        auto const &complement = cum - target;\\n        if(auto it = ct.find(complement); it != ct.end())\\n            res += it->second;\\n        ct[cum]++;\\n    }\\n    \\n    inline size_t count() const {\\n        return res;\\n    }\\n    \\n    void reset() {\\n        ct.clear();\\n        cum = 0;\\n        res = 0;\\n        \\n        ct[0] = 1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        const int rows = matrix.size();\\n        const int cols = matrix[0].size();\\n        \\n        // row-wise prefix sums\\n        for(auto &row : matrix)\\n            partial_sum(begin(row), end(row), begin(row));\\n        \\n        int res {0};\\n\\t\\t// [CHOICE-A]: Single `SubarraySumCount` object during this function\\'s lifetime that is `reset()`\\n\\t\\t// multiple times\\n        SubarraySumCount s {target};\\n        \\n        for(int lo = 0; lo < cols; lo++) {\\n            for(int hi = lo; hi < cols; hi++) {\\n\\t\\t\\t    // [CHOICE-B]: Multiple `SubarraySumCount` objects during function\\'s lifetime\\n\\t\\t\\t\\t// Once per pair of column indices that is destroyed rather than being `reset`.\\n\\t\\t\\t\\t// SubarraySumCount s {target};\\n                for(int r = 0; r < rows; r++)\\n                    s.add(matrix[r][hi] - (lo > 0 ? matrix[r][lo-1] : 0));\\n                res += s.count();\\n                // [CHOICE-A]\\n\\t\\t\\t\\ts.reset();\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nTime-Complexity: `O(cols * cols * rows)`\\nSpace-Complexity: Ignoring the in-place use of the input `matrix`\\n- Choice **A**: `O(cols * cols * rows)` in worst case (Is the time better though? IDK.)\\n- Choice **B**: `O(rows)` in worst case.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n// Usage:\\n    SubarraySumCount s {target};\\n    for(auto const &v : values)\\n        s.add(v);\\n    auto res = s.count();\\n// `res` holds the count of all non-empty subarrays from `values`\\n// that have a sum equal to `target`\\n\\n*/\\n\\ntemplate <typename T>\\nclass SubarraySumCount {\\n    static_assert(is_integral_v<T>, \"Must specify an Integral Type\");\\n    \\n    unordered_map<T, size_t> ct;\\n    T target;\\n    T cum {0};\\n    size_t res {0};\\npublic:\\n    SubarraySumCount(const T &target) : target(target) {\\n        ct[0] = 1;\\n    }\\n    \\n    inline void add(const T& val) {\\n        cum += val;\\n        auto const &complement = cum - target;\\n        if(auto it = ct.find(complement); it != ct.end())\\n            res += it->second;\\n        ct[cum]++;\\n    }\\n    \\n    inline size_t count() const {\\n        return res;\\n    }\\n    \\n    void reset() {\\n        ct.clear();\\n        cum = 0;\\n        res = 0;\\n        \\n        ct[0] = 1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        const int rows = matrix.size();\\n        const int cols = matrix[0].size();\\n        \\n        // row-wise prefix sums\\n        for(auto &row : matrix)\\n            partial_sum(begin(row), end(row), begin(row));\\n        \\n        int res {0};\\n\\t\\t// [CHOICE-A]: Single `SubarraySumCount` object during this function\\'s lifetime that is `reset()`\\n\\t\\t// multiple times\\n        SubarraySumCount s {target};\\n        \\n        for(int lo = 0; lo < cols; lo++) {\\n            for(int hi = lo; hi < cols; hi++) {\\n\\t\\t\\t    // [CHOICE-B]: Multiple `SubarraySumCount` objects during function\\'s lifetime\\n\\t\\t\\t\\t// Once per pair of column indices that is destroyed rather than being `reset`.\\n\\t\\t\\t\\t// SubarraySumCount s {target};\\n                for(int r = 0; r < rows; r++)\\n                    s.add(matrix[r][hi] - (lo > 0 ? matrix[r][lo-1] : 0));\\n                res += s.count();\\n                // [CHOICE-A]\\n\\t\\t\\t\\ts.reset();\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300092,
                "title": "c-prefix-sum",
                "content": "***Comment down your queries***\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        //calculate the prefix sum\\n         for(int r = 0;r<matrix.size();r++)\\n         {\\n             for(int c = 1;c<matrix[0].size();c++)\\n             {\\n                 matrix[r][c] += matrix[r][c-1];\\n             }\\n         }\\n        //Here the magic begin\\n        int res = 0;\\n        for(int fixColumn = 0;fixColumn < matrix[0].size();fixColumn++)\\n        {\\n            for(int subMatrixCol = fixColumn;subMatrixCol < matrix[0].size();subMatrixCol++)\\n            {\\n                unordered_map<int,int>mp;\\n                mp[0] = 1;\\n                int sum = 0;//sum of current sub-matrix\\n                for(int currentRow = 0;currentRow<matrix.size();currentRow++)\\n                {\\n                    //when fixed point is 2nd col and onward, we have to subtract previous cols\\n                    if(fixColumn>0) matrix[currentRow][subMatrixCol] -=  matrix[currentRow][fixColumn-1];\\n                    sum+=(matrix[currentRow][subMatrixCol]); // calculating the sum w.r.t column\\n                    if(mp[sum-target]) res+=mp[sum-target];\\n                    mp[sum]++; // you can get this idea by solving, sub-array target problem\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        //calculate the prefix sum\\n         for(int r = 0;r<matrix.size();r++)\\n         {\\n             for(int c = 1;c<matrix[0].size();c++)\\n             {\\n                 matrix[r][c] += matrix[r][c-1];\\n             }\\n         }\\n        //Here the magic begin\\n        int res = 0;\\n        for(int fixColumn = 0;fixColumn < matrix[0].size();fixColumn++)\\n        {\\n            for(int subMatrixCol = fixColumn;subMatrixCol < matrix[0].size();subMatrixCol++)\\n            {\\n                unordered_map<int,int>mp;\\n                mp[0] = 1;\\n                int sum = 0;//sum of current sub-matrix\\n                for(int currentRow = 0;currentRow<matrix.size();currentRow++)\\n                {\\n                    //when fixed point is 2nd col and onward, we have to subtract previous cols\\n                    if(fixColumn>0) matrix[currentRow][subMatrixCol] -=  matrix[currentRow][fixColumn-1];\\n                    sum+=(matrix[currentRow][subMatrixCol]); // calculating the sum w.r.t column\\n                    if(mp[sum-target]) res+=mp[sum-target];\\n                    mp[sum]++; // you can get this idea by solving, sub-array target problem\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299773,
                "title": "c-solution-faster-than-96-less-than-98",
                "content": "The idea:\\n\\n1. Create a prefix array of top row and leftmost column. \\ne.g. if top row = 1 2 3, then prefix row = 1 3 6, same for leftmost column from top to bottom\\n2. Create a 2D prefix array. Sum at a position [i, j], such that both i, j > 0 = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]\\n\\n```\\n    --------------------\\n    [i-1,j-1]|[i-1,j]\\n    --------------------\\n    [i,j-1]  |[i,j]\\n    --------------------\\n```\\n\\n[i-1,j-1] is the overlapped region, that\\'s why you cancel that out.\\n\\nThat\\'s it.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    const static int MAX = 120;\\n    int rec[MAX][MAX];\\n    int R, C;\\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        rec[0][0] = matrix[0][0];\\n        int res_cnt = 0;\\n        if (rec[0][0] == target)\\n            res_cnt++;\\n        R = matrix.size();\\n        C = matrix[0].size();\\n        for (int i = 1; i < R; i++) {\\n            rec[i][0] = rec[i - 1][0] + matrix[i][0];\\n            if (rec[i][0] == target)\\n                res_cnt++;\\n        }\\n        for (int i = 1; i < C; i++) {\\n            rec[0][i] = rec[0][i - 1] + matrix[0][i];\\n            if (rec[0][i] == target)\\n                res_cnt++;\\n        }\\n        for (int i = 1; i < R; i++) {\\n            for (int j = 1; j < C; j++) {\\n                rec[i][j] = matrix[i][j] + rec[i][j - 1] + rec[i - 1][j] - rec[i - 1][j - 1];\\n            }\\n        }\\n        // top row\\n        for (int j = 1; j < C; j++) {\\n            for (int k = 0; k < j; k++) {\\n                if (rec[0][j] - rec[0][k] == target)\\n                    res_cnt++;\\n            }\\n        }\\n        // top col\\n        for (int i = 1; i < R; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (rec[i][0] - rec[j][0] == target)\\n                    res_cnt++;\\n            }\\n        }\\n        for (int i = 1; i < R; i++) {\\n            for (int j = 1; j < C; j++) {\\n                // init case\\n                if (rec[i][j] == target) {\\n                    res_cnt++;\\n                }\\n                // row case\\n                for (int k = 0; k < i; k++) {\\n                    if (rec[i][j] - rec[k][j] == target)\\n                        res_cnt++;\\n                }\\n                // col case\\n                for (int l = 0; l < j; l++) {\\n                    if (rec[i][j] - rec[i][l] == target) {\\n                        res_cnt++;\\n                    }\\n                }\\n                // wow case\\n                for (int k = 0; k < i; k++) {\\n                    for (int l = 0; l < j; l++) {\\n                        if (rec[i][j] - rec[k][j] - rec[i][l] + rec[k][l] == target)\\n                            res_cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        return res_cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n    --------------------\\n    [i-1,j-1]|[i-1,j]\\n    --------------------\\n    [i,j-1]  |[i,j]\\n    --------------------\\n```\n```cpp\\nclass Solution {\\npublic:\\n    const static int MAX = 120;\\n    int rec[MAX][MAX];\\n    int R, C;\\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        rec[0][0] = matrix[0][0];\\n        int res_cnt = 0;\\n        if (rec[0][0] == target)\\n            res_cnt++;\\n        R = matrix.size();\\n        C = matrix[0].size();\\n        for (int i = 1; i < R; i++) {\\n            rec[i][0] = rec[i - 1][0] + matrix[i][0];\\n            if (rec[i][0] == target)\\n                res_cnt++;\\n        }\\n        for (int i = 1; i < C; i++) {\\n            rec[0][i] = rec[0][i - 1] + matrix[0][i];\\n            if (rec[0][i] == target)\\n                res_cnt++;\\n        }\\n        for (int i = 1; i < R; i++) {\\n            for (int j = 1; j < C; j++) {\\n                rec[i][j] = matrix[i][j] + rec[i][j - 1] + rec[i - 1][j] - rec[i - 1][j - 1];\\n            }\\n        }\\n        // top row\\n        for (int j = 1; j < C; j++) {\\n            for (int k = 0; k < j; k++) {\\n                if (rec[0][j] - rec[0][k] == target)\\n                    res_cnt++;\\n            }\\n        }\\n        // top col\\n        for (int i = 1; i < R; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (rec[i][0] - rec[j][0] == target)\\n                    res_cnt++;\\n            }\\n        }\\n        for (int i = 1; i < R; i++) {\\n            for (int j = 1; j < C; j++) {\\n                // init case\\n                if (rec[i][j] == target) {\\n                    res_cnt++;\\n                }\\n                // row case\\n                for (int k = 0; k < i; k++) {\\n                    if (rec[i][j] - rec[k][j] == target)\\n                        res_cnt++;\\n                }\\n                // col case\\n                for (int l = 0; l < j; l++) {\\n                    if (rec[i][j] - rec[i][l] == target) {\\n                        res_cnt++;\\n                    }\\n                }\\n                // wow case\\n                for (int k = 0; k < i; k++) {\\n                    for (int l = 0; l < j; l++) {\\n                        if (rec[i][j] - rec[k][j] - rec[i][l] + rec[k][l] == target)\\n                            res_cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        return res_cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299708,
                "title": "simple-python-solution-using-prefix-sum",
                "content": "```from typing import List\\n\\n\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        n = len(matrix)\\n        m = len(matrix[0])\\n        ans = 0\\n\\n        for start in range(n):\\n            tempSum = [0] * m\\n            for i in range(start, n):\\n                for j in range(m):\\n                    tempSum[j] += matrix[i][j]\\n                ans += self.subSetSum(tempSum, target)\\n        return ans\\n\\n    def subSetSum(self, arr, k):\\n        res = 0\\n        currSum = 0\\n        prefixSum = {0: 1}\\n        for n in arr:\\n            currSum += n\\n            diff = currSum - k\\n            res += prefixSum.get(diff, 0)\\n            prefixSum[currSum] = 1 + prefixSum.get(currSum, 0)\\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```from typing import List\\n\\n\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        n = len(matrix)\\n        m = len(matrix[0])\\n        ans = 0\\n\\n        for start in range(n):\\n            tempSum = [0] * m\\n            for i in range(start, n):\\n                for j in range(m):\\n                    tempSum[j] += matrix[i][j]\\n                ans += self.subSetSum(tempSum, target)\\n        return ans\\n\\n    def subSetSum(self, arr, k):\\n        res = 0\\n        currSum = 0\\n        prefixSum = {0: 1}\\n        for n in arr:\\n            currSum += n\\n            diff = currSum - k\\n            res += prefixSum.get(diff, 0)\\n            prefixSum[currSum] = 1 + prefixSum.get(currSum, 0)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299321,
                "title": "python-98-faster",
                "content": "```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        for row in matrix:\\n            for i in range(1,len(row)):\\n                row[i] += row[i-1]\\n        res = 0\\n        for i in range(len(matrix)):\\n            tmp = [0 for val in matrix[i]]\\n            for j in range(i,len(matrix)):\\n                need = collections.defaultdict(int)\\n                need[target] = 1\\n                for k in range(len(matrix[0])):\\n                    tmp[k] += matrix[j][k]\\n                    if tmp[k] in need:\\n                        res += need[tmp[k]]\\n                    need[tmp[k]+target] += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        for row in matrix:\\n            for i in range(1,len(row)):\\n                row[i] += row[i-1]\\n        res = 0\\n        for i in range(len(matrix)):\\n            tmp = [0 for val in matrix[i]]\\n            for j in range(i,len(matrix)):\\n                need = collections.defaultdict(int)\\n                need[target] = 1\\n                for k in range(len(matrix[0])):\\n                    tmp[k] += matrix[j][k]\\n                    if tmp[k] in need:\\n                        res += need[tmp[k]]\\n                    need[tmp[k]+target] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299303,
                "title": "java-solution",
                "content": "class Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        \\n        \\n        int dp[][]=new int[matrix.length][matrix[0].length];\\n        for(int i=0;i<matrix[0].length;i++)\\n        {\\n            int sum=0;\\n            for(int j=matrix.length-1;j>=0;j--)\\n            {\\n                sum+=matrix[j][i];\\n                dp[j][i]=sum;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<dp.length;i++)\\n        {\\n            for(int j=0;j<matrix[0].length;j++)\\n            {\\n               for(int p=i;p>=0;p--)\\n               {\\n                  int sum=0; \\n                  for(int k=j;k>=0;k--)\\n                  {\\n                     if(i==dp.length-1)\\n                     {\\n                         sum+=dp[p][k];\\n                     }\\n                     else\\n                         sum+=dp[p][k]-dp[i+1][k];\\n                     if(sum==target)\\n                     {\\n                         ans++;\\n                     }\\n                  }\\n               }\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        \\n        \\n        int dp[][]=new int[matrix.length][matrix[0].length];\\n        for(int i=0;i<matrix[0].length;i++)\\n        {\\n            int sum=0;\\n            for(int j=matrix.length-1;j>=0;j--)\\n            {\\n                sum+=matrix[j][i];\\n                dp[j][i]=sum;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2299086,
                "title": "java-approach-and-code-detailed-explaination",
                "content": "Approach :\\n\\nThis problem is essentially a 2-dimensional version Subarray Sum Equals K (S.S.E.K). By using a prefix sum on each row or each column, we can compress this problem down to either N^2 iterations of the O(M) SSEK, or M^2 iterations of the O(N) SSEK.\\n\\nIn the SSEK solution, we can find the number of subarrays with the target sum by utilizing a result map (res) to store the different values found as we iterate through the array while keeping a running sum (csum). Just as in the case with a prefix sum array, the sum of a subarray between i and j is equal to the sum of the subarray from 0 to j minus the sum of the subarray from 0 to i-1.\\n\\nRather than iteratively checking if sum[0,j] - sum[0,i-1] = T for every pair of i, j values, we can flip it around to sum[0,j] - T = sum[0,i-1] and since every earlier sum value has been stored in res, we can simply perform a lookup on sum[0,j] - T to see if there are any matches.\\n\\nWhen extrapolating this solution to our 2-dimensional matrix (M), we will need to first prefix sum the rows or columns, (which we can do in-place to avoid extra space, as we will not need the original values again). Then we should iterate through M again in the opposite order of rows/columns where the prefix sums will allow us to treat a group of columns or rows as if it were a 1-dimensional array and apply the SSEK algorithm.\\n\\nCode:\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int xlen = matrix[0].length, ylen = matrix.length, ans = 0;\\n        Map<Integer, Integer> res = new HashMap<>();\\n        for (int[] r : matrix)\\n            for (int j = 1; j < xlen; j++)\\n                r[j] += r[j-1];\\n        for (int j = 0; j < xlen; j++)\\n            for (int k = j; k < xlen; k++) {\\n                res.clear();\\n                res.put(0,1);\\n                int csum = 0;\\n                for (int i = 0; i < ylen; i++) {\\n                    csum += matrix[i][k] - (j > 0 ? matrix[i][j-1] : 0);\\n                    ans += res.getOrDefault(csum - target, 0);\\n                    res.put(csum, res.getOrDefault(csum, 0) + 1);\\n                }\\n            }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int xlen = matrix[0].length, ylen = matrix.length, ans = 0;\\n        Map<Integer, Integer> res = new HashMap<>();\\n        for (int[] r : matrix)\\n            for (int j = 1; j < xlen; j++)\\n                r[j] += r[j-1];\\n        for (int j = 0; j < xlen; j++)\\n            for (int k = j; k < xlen; k++) {\\n                res.clear();\\n                res.put(0,1);\\n                int csum = 0;\\n                for (int i = 0; i < ylen; i++) {\\n                    csum += matrix[i][k] - (j > 0 ? matrix[i][j-1] : 0);\\n                    ans += res.getOrDefault(csum - target, 0);\\n                    res.put(csum, res.getOrDefault(csum, 0) + 1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2299058,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(int i=0;i<m;i++)\\n            for(int j=1;j<n;j++)\\n                matrix[i][j]+=matrix[i][j-1];\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n            for(int j=i;j<n;j++)\\n            {\\n                map<int,int>m1;\\n                m1[0]++;\\n                int sum=0;\\n                for(int k=0;k<m;k++)\\n                {\\n                    sum+=matrix[k][j]-(i>0 ? matrix[k][i-1] : 0);\\n                    if(m1[sum-target])\\n                        ans+=m1[sum-target];\\n                    m1[sum]++;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(int i=0;i<m;i++)\\n            for(int j=1;j<n;j++)\\n                matrix[i][j]+=matrix[i][j-1];\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n            for(int j=i;j<n;j++)\\n            {\\n                map<int,int>m1;\\n                m1[0]++;\\n                int sum=0;\\n                for(int k=0;k<m;k++)\\n                {\\n                    sum+=matrix[k][j]-(i>0 ? matrix[k][i-1] : 0);\\n                    if(m1[sum-target])\\n                        ans+=m1[sum-target];\\n                    m1[sum]++;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298739,
                "title": "java-easy-subarray-with-target-sum-based-approach",
                "content": "class Solution {\\n    \\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        if(matrix.length==0){\\n            return 0;\\n        }\\n        \\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int count = 0;\\n        for(int i = 0; i<row; i++){\\n            for(int j = 1; j<col; j++){\\n                matrix[i][j] += matrix[i][j-1];\\n            }\\n        }\\n        \\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int startCol = 0; startCol<col; startCol++){\\n            for(int currCol = startCol; currCol<col; currCol++){\\n                map.clear();\\n                map.put(0,1);\\n                int sum = 0;\\n                for(int i = 0; i<row; i++){\\n                    sum += matrix[i][currCol] - (startCol>0 ? matrix[i][startCol-1]:0);\\n                    if(map.containsKey(sum-target)){\\n                        count+=map.get(sum-target);\\n                    }\\n                    map.put(sum,map.getOrDefault(sum,0)+1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    \\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        if(matrix.length==0){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2298693,
                "title": "c-prefix-sum-hashmap",
                "content": "**Explantion:**\\n![image](https://assets.leetcode.com/users/images/adbe68e4-aab2-4e88-af67-a714a7b8ccee_1658133221.2636046.png)\\n\\n\\n**Implementation:**\\n```\\nclass Solution {\\npublic:\\n    // TC-> O(n*m^2)\\n    // SC-> O(n)\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        // forming prefix -sum\\n        for(int i = 0; i < n; i++){\\n            for(int j = 1; j < m; j++){\\n                matrix[i][j] += matrix[i][j-1];\\n            }\\n        }\\n        \\n        int count = 0;\\n        // For each pair of columns, calculate the accumulated sum of rows.\\n        // Now this problem is same as, \"Subarray sum with given Target Sum\".\\n        for(int c1 = 0; c1 < m; c1++){\\n            for(int c2 = c1; c2 < m; c2++){\\n                unordered_map<int, int> mp; // sum->freq\\n                mp[0] = 1;\\n                // cout<<\"c1=\"<<c1<<\" \"<<\"c2=\"<<c2<<\" \";\\n                int sum = 0;\\n                for(int r = 0; r < n; r++){\\n                    sum += matrix[r][c2] - (c1 > 0? matrix[r][c1-1]: 0);\\n                    // cout<<\"r=\"<<r<<\" \"<<\"sum=\"<<sum<<\" \";\\n                    // there exist contiguous sum equal to target\\n                    if(mp.count(sum-target))\\n                        count += mp[sum-target];\\n                    // cout<<\"count=\"<<count<<\" \";\\n                    // add the sum obtained in the map\\n                    mp[sum]++;\\n                }\\n                // cout<<endl;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // TC-> O(n*m^2)\\n    // SC-> O(n)\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        // forming prefix -sum\\n        for(int i = 0; i < n; i++){\\n            for(int j = 1; j < m; j++){\\n                matrix[i][j] += matrix[i][j-1];\\n            }\\n        }\\n        \\n        int count = 0;\\n        // For each pair of columns, calculate the accumulated sum of rows.\\n        // Now this problem is same as, \"Subarray sum with given Target Sum\".\\n        for(int c1 = 0; c1 < m; c1++){\\n            for(int c2 = c1; c2 < m; c2++){\\n                unordered_map<int, int> mp; // sum->freq\\n                mp[0] = 1;\\n                // cout<<\"c1=\"<<c1<<\" \"<<\"c2=\"<<c2<<\" \";\\n                int sum = 0;\\n                for(int r = 0; r < n; r++){\\n                    sum += matrix[r][c2] - (c1 > 0? matrix[r][c1-1]: 0);\\n                    // cout<<\"r=\"<<r<<\" \"<<\"sum=\"<<sum<<\" \";\\n                    // there exist contiguous sum equal to target\\n                    if(mp.count(sum-target))\\n                        count += mp[sum-target];\\n                    // cout<<\"count=\"<<count<<\" \";\\n                    // add the sum obtained in the map\\n                    mp[sum]++;\\n                }\\n                // cout<<endl;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2298477,
                "title": "c-approach-straightforward-no-hashmap-beats-99-5",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int numSubArraywTarget(vector<int>& make, int target)\\n    {\\n        int n= make.size();\\n        //find the number of contiguous sub-arrays with sum target\\n        \\n        \\n        int sum=0;\\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum=0; \\n            for(int j=i;j<n;j++)\\n            {\\n                sum+= make[j];\\n            \\n                if(sum==target)\\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int n= matrix.size();\\n        int m= matrix[0].size();\\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> make(m, 0);\\n            \\n            for(int row=i;row<n;row++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                    make[j]+= matrix[row][j];        \\n                }\\n                ans+= numSubArraywTarget(make, target);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int numSubArraywTarget(vector<int>& make, int target)\\n    {\\n        int n= make.size();\\n        //find the number of contiguous sub-arrays with sum target\\n        \\n        \\n        int sum=0;\\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum=0; \\n            for(int j=i;j<n;j++)\\n            {\\n                sum+= make[j];\\n            \\n                if(sum==target)\\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int n= matrix.size();\\n        int m= matrix[0].size();\\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> make(m, 0);\\n            \\n            for(int row=i;row<n;row++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                    make[j]+= matrix[row][j];        \\n                }\\n                ans+= numSubArraywTarget(make, target);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298443,
                "title": "simple-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n       int n=matrix.size();\\n    int m=matrix[0].size();\\n        map<int,int>mp;\\n        for(int i=0; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                matrix[i][j]+=matrix[i][j-1];\\n            }\\n        }\\n        int ans=0;\\n        for(int c1=0; c1<m; c1++){\\n            for(int c2=c1; c2<m; c2++){\\n                mp.clear();\\n                mp[0]=1;\\n                int sum=0;\\n                for(int i=0; i<n; i++){\\n                    sum=sum+matrix[i][c2]-(c1>0?matrix[i][c1-1]: 0);\\n                    if(mp.find(sum-target)!=mp.end()){\\n                        ans=ans+mp[sum-target];\\n                    }\\n                    mp[sum]++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n       int n=matrix.size();\\n    int m=matrix[0].size();\\n        map<int,int>mp;\\n        for(int i=0; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                matrix[i][j]+=matrix[i][j-1];\\n            }\\n        }\\n        int ans=0;\\n        for(int c1=0; c1<m; c1++){\\n            for(int c2=c1; c2<m; c2++){\\n                mp.clear();\\n                mp[0]=1;\\n                int sum=0;\\n                for(int i=0; i<n; i++){\\n                    sum=sum+matrix[i][c2]-(c1>0?matrix[i][c1-1]: 0);\\n                    if(mp.find(sum-target)!=mp.end()){\\n                        ans=ans+mp[sum-target];\\n                    }\\n                    mp[sum]++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298401,
                "title": "java-solution-with-comments-easy-to-understand-t-c-is-o-cols-cols-rows",
                "content": "Please go through the comments to understand the code. Anyone can solve it after getting the intuition. \\n```java\\nclass Solution {\\n    //Approach - we are fixing two columns. Then for it we are iterating row from 0 to rows. For the region\\n    //between the two columns and the row, we are storing this sum in a hashMap with frequencies.\\n    //If sum-target exists then we will increase the count.\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int rows = matrix.length, cols = matrix[0].length;\\n        int[][] prefix = new int[rows+1][cols+1];\\n        for(int row = 0; row<rows; ++row){\\n            for(int col = 0; col<cols; ++col){\\n                prefix[row+1][col+1] = matrix[row][col] + prefix[row][col+1] + prefix[row+1][col] - prefix[row][col];\\n            }\\n        }\\n        // for(int i = 0; i<prefix.length; ++i){\\n        //     System.out.println(Arrays.toString(prefix[i]));\\n        // }\\n        int count = 0;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        //fixing two columns\\n        for(int col1 = 0; col1<cols; ++col1){\\n            for(int col2 = col1; col2<cols; ++col2){\\n                map.clear();\\n                //to handle the cases when sum is equal to target.\\n                map.put(0,1);\\n                int sum = 0;\\n                // System.out.printf(\"Col1 :%d , Col2 :%d \\\\n\",col1,col2);\\n                for(int row = 0; row<rows; ++row){\\n                    sum = prefix[row+1][col2+1] - prefix[row+1][col1];\\n                    Integer key = map.get(sum-target);\\n                    if(key != null){\\n                        count += key;\\n                    }\\n                    map.put(sum,map.getOrDefault(sum,0)+1);\\n                    // System.out.printf(\"Row : %d , sum = %d \\\\n\",row,sum);\\n                }\\n                // System.out.println();\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\nWith same approach we can solve it using T.C of O(rows*rows*cols) by fixing two rows and iterating each column for it.\\n",
                "solutionTags": [
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```java\\nclass Solution {\\n    //Approach - we are fixing two columns. Then for it we are iterating row from 0 to rows. For the region\\n    //between the two columns and the row, we are storing this sum in a hashMap with frequencies.\\n    //If sum-target exists then we will increase the count.\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int rows = matrix.length, cols = matrix[0].length;\\n        int[][] prefix = new int[rows+1][cols+1];\\n        for(int row = 0; row<rows; ++row){\\n            for(int col = 0; col<cols; ++col){\\n                prefix[row+1][col+1] = matrix[row][col] + prefix[row][col+1] + prefix[row+1][col] - prefix[row][col];\\n            }\\n        }\\n        // for(int i = 0; i<prefix.length; ++i){\\n        //     System.out.println(Arrays.toString(prefix[i]));\\n        // }\\n        int count = 0;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        //fixing two columns\\n        for(int col1 = 0; col1<cols; ++col1){\\n            for(int col2 = col1; col2<cols; ++col2){\\n                map.clear();\\n                //to handle the cases when sum is equal to target.\\n                map.put(0,1);\\n                int sum = 0;\\n                // System.out.printf(\"Col1 :%d , Col2 :%d \\\\n\",col1,col2);\\n                for(int row = 0; row<rows; ++row){\\n                    sum = prefix[row+1][col2+1] - prefix[row+1][col1];\\n                    Integer key = map.get(sum-target);\\n                    if(key != null){\\n                        count += key;\\n                    }\\n                    map.put(sum,map.getOrDefault(sum,0)+1);\\n                    // System.out.printf(\"Row : %d , sum = %d \\\\n\",row,sum);\\n                }\\n                // System.out.println();\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298370,
                "title": "unorder-map-prefix-sum-easy-matrix-hash-map-cpp",
                "content": "\\n\\n## C++ code Easy to Understand ##\\n```\\n\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int ans=0;\\n        unordered_map<int, int> ump;\\n\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t\\tfor (int j = 1; j < n; j++)\\n\\t\\t\\t\\tmatrix[i][j] += matrix[i][j - 1];\\n\\n\\t\\t\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tfor (int j = i; j < n; j++) {\\n\\t\\t\\t\\tump = {{0,1}};\\n\\t\\t\\t\\tint curr = 0;\\n\\t\\t\\t\\tfor (int k = 0; k < m; k++) {\\n\\t\\t\\t\\t  curr += matrix[k][j] - (i > 0 ? matrix[k][i - 1] : 0);\\n\\t\\t\\t\\t  ans += ump.find(curr - target) != ump.end() ? ump[curr - target] : 0;\\n\\t\\t\\t\\t  ump[curr]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```\\n## Please upvotes if you understood the solution ##",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int ans=0;\\n        unordered_map<int, int> ump;\\n\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t\\tfor (int j = 1; j < n; j++)\\n\\t\\t\\t\\tmatrix[i][j] += matrix[i][j - 1];\\n\\n\\t\\t\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tfor (int j = i; j < n; j++) {\\n\\t\\t\\t\\tump = {{0,1}};\\n\\t\\t\\t\\tint curr = 0;\\n\\t\\t\\t\\tfor (int k = 0; k < m; k++) {\\n\\t\\t\\t\\t  curr += matrix[k][j] - (i > 0 ? matrix[k][i - 1] : 0);\\n\\t\\t\\t\\t  ans += ump.find(curr - target) != ump.end() ? ump[curr - target] : 0;\\n\\t\\t\\t\\t  ump[curr]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298351,
                "title": "c-hashmap-simple-and-easy-to-understand",
                "content": "****please upvote if you like****\\n\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                matrix[i][j]+=matrix[i][j-1];\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=i;j<m;j++){\\n                unordered_map<int,int>mp;\\n                mp[0]=1;\\n                int sum=0;\\n                for(int k=0;k<n;k++){\\n                    sum+=matrix[k][j]-(i==0 ? 0 : matrix[k][i-1]);\\n                    count+=mp[sum-target];\\n                    mp[sum]+=1;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n****if you have any trouble to understand you can comment and I will  reply very soon****",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                matrix[i][j]+=matrix[i][j-1];\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=i;j<m;j++){\\n                unordered_map<int,int>mp;\\n                mp[0]=1;\\n                int sum=0;\\n                for(int k=0;k<n;k++){\\n                    sum+=matrix[k][j]-(i==0 ? 0 : matrix[k][i-1]);\\n                    count+=mp[sum-target];\\n                    mp[sum]+=1;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298305,
                "title": "c-prefixsum-hashing",
                "content": "This question is advancement of the question \"finding the count of subarrays with a given sum\"\\nThere we used to find the subarray sum in horizontal array but here we will consider vertical array\\nWe will check for every combination of coloums that 0 0, 0 1, 0 2, etc then 1 1, 1 2, 1 3 etc similarly other also\\nThe elements in our considered array will be sum of element from col1 to col2 of that particular row\\nFor that we will precompute the sum of a particular row (we will change our original row with the presum row)i.e each element in a particular row will chaged to the prefix sum upto it (this will help us to get the sum between col2 and col1 in O(1) time\\nNow when we have our elements we will do the same thing we do for finding the subarray with a given sum\\n\\n```\\n   int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        for(int row = 0; row<m; row++) \\n        {\\n            for(int col = 1; col<n; col++)\\n            {\\n                matrix[row][col] += matrix[row][col-1];\\n            }\\n        }\\n        int count = 0; \\n        for(int col1 = 0; col1<n; col1++) \\n        {\\n            for(int col2 = col1; col2<n; col2++)\\n            {\\n                int sum = 0; // now the same thing which we do to find subarray problem\\n                unordered_map<int, int>um;\\n                for(int row = 0; row<m; row++) // to get all the elements from top to down\\n                {\\n                    int val = matrix[row][col2] - (col1>0?matrix[row][col1-1]:0); \\n                    sum += val; \\n                    if(sum == target) // this is to check if our prefix is itself equal to given target so we have to compute it independentally\\n                    {\\n                        count++;\\n                    }\\n                    if(um.find(sum-target) != um.end())\\n                    {\\n                        count += um[sum-target];\\n                    }\\n                    um[sum]++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```\\nUpvote if found usefull",
                "solutionTags": [],
                "code": "```\\n   int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        for(int row = 0; row<m; row++) \\n        {\\n            for(int col = 1; col<n; col++)\\n            {\\n                matrix[row][col] += matrix[row][col-1];\\n            }\\n        }\\n        int count = 0; \\n        for(int col1 = 0; col1<n; col1++) \\n        {\\n            for(int col2 = col1; col2<n; col2++)\\n            {\\n                int sum = 0; // now the same thing which we do to find subarray problem\\n                unordered_map<int, int>um;\\n                for(int row = 0; row<m; row++) // to get all the elements from top to down\\n                {\\n                    int val = matrix[row][col2] - (col1>0?matrix[row][col1-1]:0); \\n                    sum += val; \\n                    if(sum == target) // this is to check if our prefix is itself equal to given target so we have to compute it independentally\\n                    {\\n                        count++;\\n                    }\\n                    if(um.find(sum-target) != um.end())\\n                    {\\n                        count += um[sum-target];\\n                    }\\n                    um[sum]++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2298179,
                "title": "c-solution",
                "content": "Based on  [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k)\\n```\\npublic class Solution {\\n    public int NumSubmatrixSumTarget(int[][] matrix, int target) {\\n        int res = 0;\\n        for(int i = 0; i < matrix.Length; i++){\\n            int[] nums = new int[matrix[0].Length];\\n            for(int j = i; j < matrix.Length; j++){\\n                for(int c = 0; c < matrix[0].Length; c++){\\n                    nums[c] += matrix[j][c];\\n                }\\n                res += getNumOfSubarrays(nums, target);\\n            }\\n        }\\n        return res;\\n    }\\n\\t\\n    private int getNumOfSubarrays(int[] nums, int k){\\n        Dictionary<int,int> map = new Dictionary<int,int>();\\n        map.Add(0,1);\\n        int res = 0, sum = 0;\\n        for(int i = 0; i < nums.Length; i++){\\n            sum += nums[i];\\n            if(map.ContainsKey(sum-k)){\\n                res += map[sum-k];\\n            }\\n            if(map.ContainsKey(sum))\\n                map[sum]++;\\n            else\\n                map.Add(sum,1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumSubmatrixSumTarget(int[][] matrix, int target) {\\n        int res = 0;\\n        for(int i = 0; i < matrix.Length; i++){\\n            int[] nums = new int[matrix[0].Length];\\n            for(int j = i; j < matrix.Length; j++){\\n                for(int c = 0; c < matrix[0].Length; c++){\\n                    nums[c] += matrix[j][c];\\n                }\\n                res += getNumOfSubarrays(nums, target);\\n            }\\n        }\\n        return res;\\n    }\\n\\t\\n    private int getNumOfSubarrays(int[] nums, int k){\\n        Dictionary<int,int> map = new Dictionary<int,int>();\\n        map.Add(0,1);\\n        int res = 0, sum = 0;\\n        for(int i = 0; i < nums.Length; i++){\\n            sum += nums[i];\\n            if(map.ContainsKey(sum-k)){\\n                res += map[sum-k];\\n            }\\n            if(map.ContainsKey(sum))\\n                map[sum]++;\\n            else\\n                map.Add(sum,1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298127,
                "title": "python-code-with-itertools",
                "content": "```\\nclass Solution:\\n  def numSubmatrixSumTarget(self, M: List[List[int]], t: int) -> int:\\n    res,rs = 0,[list(accumulate(r,operator.add))+[0] for r in M]\\n    for y1,y2 in combinations(range(-1,len(M[0])),2):\\n      su,d = 0,{0:1}\\n      for r in rs:\\n        su += r[y2] - r[y1]\\n        res += d.get(su-t,0)\\n        d[su] = d.get(su,0) + 1\\n    return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def numSubmatrixSumTarget(self, M: List[List[int]], t: int) -> int:\\n    res,rs = 0,[list(accumulate(r,operator.add))+[0] for r in M]\\n    for y1,y2 in combinations(range(-1,len(M[0])),2):\\n      su,d = 0,{0:1}\\n      for r in rs:\\n        su += r[y2] - r[y1]\\n        res += d.get(su-t,0)\\n        d[su] = d.get(su,0) + 1\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298022,
                "title": "easy-understanding",
                "content": "def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        xlen, ylen, ans, res = len(matrix[0]), len(matrix), 0, defaultdict(int)\\n        for r in matrix:\\n            for j in range(1, xlen):\\n                r[j] += r[j-1]\\n        for j in range(xlen):\\n            for k in range(j, xlen):\\n                res.clear()\\n                res[0], csum = 1, 0\\n                for i in range(ylen):\\n                    csum += matrix[i][k] - (matrix[i][j-1] if j else 0)\\n                    ans += res[csum - target]\\n                    res[csum] += 1\\n        return ans\\n\\t\\t\\n\\t\\t##just lemme know if you have any doubt\\n\\t\\t##Happy Coding Guys",
                "solutionTags": [
                    "Python"
                ],
                "code": "def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        xlen, ylen, ans, res = len(matrix[0]), len(matrix), 0, defaultdict(int)\\n        for r in matrix:\\n            for j in range(1, xlen):\\n                r[j] += r[j-1]\\n        for j in range(xlen):\\n            for k in range(j, xlen):\\n                res.clear()\\n                res[0], csum = 1, 0\\n                for i in range(ylen):\\n                    csum += matrix[i][k] - (matrix[i][j-1] if j else 0)\\n                    ans += res[csum - target]\\n                    res[csum] += 1\\n        return ans\\n\\t\\t\\n\\t\\t##just lemme know if you have any doubt\\n\\t\\t##Happy Coding Guys",
                "codeTag": "Python3"
            },
            {
                "id": 2297606,
                "title": "rust-prefix-sum-dp-hashmap-for-o-m-n-n",
                "content": "Firstly make a basic prefix sum DP solution for O(m * m * n * n) time.\\n```rust\\npub fn num_submatrix_sum_target_old(matrix: Vec<Vec<i32>>, target: i32) -> i32 {\\n    let mut dp = vec![vec![0; matrix[0].len() + 1]; matrix.len() + 1];\\n    let mut ans = 0;        \\n    for i in 0..matrix.len() {\\n        for j in 0..matrix[0].len() {\\n            dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j + 1] - dp[i][j] + matrix[i][j];\\n            for x in 0..i + 1 {\\n                for y in 0..j + 1 {\\n                    if dp[i + 1][j + 1] - dp[i + 1][y] - (dp[x][j + 1] - dp[x][y]) == target {\\n                        ans += 1;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    ans\\n}\\n```\\nThen we can find that the count of previous results of `dp[x][j + 1] - dp[x][y]` can be grouped up with a HashMap. Simple modification but having a O(m * n * n) space HashMap.\\n```rust\\npub fn num_submatrix_sum_target_hash(matrix: Vec<Vec<i32>>, target: i32) -> i32 {\\n    let mut dp = vec![vec![0; matrix[0].len() + 1]; matrix.len() + 1];\\n    let mut ans = 0;        \\n    let mut hash: HashMap<(usize, usize, i32), i32> = HashMap::new();\\n    for j in 0..matrix[0].len() {\\n        for y in 0..j + 1 {\\n            hash.insert((y, j + 1, 0), 1);\\n        }\\n    }\\n    for i in 0..matrix.len() {\\n        for j in 0..matrix[0].len() {\\n            dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j + 1] - dp[i][j] + matrix[i][j];\\n            for y in 0..j + 1 {\\n                let diff = dp[i + 1][j + 1] - dp[i + 1][y];\\n                if let Some(c) = hash.get(&(y, j + 1, diff - target)) {\\n                    ans += c;\\n                }\\n                *hash.entry((y, j + 1, diff)).or_insert(0) += 1;\\n            }\\n        }\\n    }\\n    ans\\n}\\n```\\nThen optimize the HashMap space usage by eliminating the `(y, j + 1)` part, making it O(n) space.\\n```rust\\npub fn num_submatrix_sum_target(matrix: Vec<Vec<i32>>, target: i32) -> i32 {\\n    let mut dp = vec![vec![0; matrix[0].len() + 1]; matrix.len() + 1];\\n    let mut ans = 0;\\n    for i in 0..matrix.len() {\\n        for j in 0..matrix[0].len() {\\n            dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j + 1] - dp[i][j] + matrix[i][j];\\n        }\\n    }\\n    for j in 0..matrix[0].len() {\\n        for y in 0..j + 1 {\\n            let mut hash: HashMap<i32, i32> = HashMap::new();\\n            hash.insert(0, 1);\\n            for i in 0..matrix.len() {\\n                let diff = dp[i + 1][j + 1] - dp[i + 1][y];\\n                if let Some(c) = hash.get(&(diff - target)) {\\n                    ans += c;\\n                }\\n                *hash.entry(diff).or_insert(0) += 1;\\n            }\\n        }\\n    }\\n    ans\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Prefix Sum"
                ],
                "code": "```rust\\npub fn num_submatrix_sum_target_old(matrix: Vec<Vec<i32>>, target: i32) -> i32 {\\n    let mut dp = vec![vec![0; matrix[0].len() + 1]; matrix.len() + 1];\\n    let mut ans = 0;        \\n    for i in 0..matrix.len() {\\n        for j in 0..matrix[0].len() {\\n            dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j + 1] - dp[i][j] + matrix[i][j];\\n            for x in 0..i + 1 {\\n                for y in 0..j + 1 {\\n                    if dp[i + 1][j + 1] - dp[i + 1][y] - (dp[x][j + 1] - dp[x][y]) == target {\\n                        ans += 1;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    ans\\n}\\n```\n```rust\\npub fn num_submatrix_sum_target_hash(matrix: Vec<Vec<i32>>, target: i32) -> i32 {\\n    let mut dp = vec![vec![0; matrix[0].len() + 1]; matrix.len() + 1];\\n    let mut ans = 0;        \\n    let mut hash: HashMap<(usize, usize, i32), i32> = HashMap::new();\\n    for j in 0..matrix[0].len() {\\n        for y in 0..j + 1 {\\n            hash.insert((y, j + 1, 0), 1);\\n        }\\n    }\\n    for i in 0..matrix.len() {\\n        for j in 0..matrix[0].len() {\\n            dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j + 1] - dp[i][j] + matrix[i][j];\\n            for y in 0..j + 1 {\\n                let diff = dp[i + 1][j + 1] - dp[i + 1][y];\\n                if let Some(c) = hash.get(&(y, j + 1, diff - target)) {\\n                    ans += c;\\n                }\\n                *hash.entry((y, j + 1, diff)).or_insert(0) += 1;\\n            }\\n        }\\n    }\\n    ans\\n}\\n```\n```rust\\npub fn num_submatrix_sum_target(matrix: Vec<Vec<i32>>, target: i32) -> i32 {\\n    let mut dp = vec![vec![0; matrix[0].len() + 1]; matrix.len() + 1];\\n    let mut ans = 0;\\n    for i in 0..matrix.len() {\\n        for j in 0..matrix[0].len() {\\n            dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j + 1] - dp[i][j] + matrix[i][j];\\n        }\\n    }\\n    for j in 0..matrix[0].len() {\\n        for y in 0..j + 1 {\\n            let mut hash: HashMap<i32, i32> = HashMap::new();\\n            hash.insert(0, 1);\\n            for i in 0..matrix.len() {\\n                let diff = dp[i + 1][j + 1] - dp[i + 1][y];\\n                if let Some(c) = hash.get(&(diff - target)) {\\n                    ans += c;\\n                }\\n                *hash.entry(diff).or_insert(0) += 1;\\n            }\\n        }\\n    }\\n    ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2297328,
                "title": "easy-to-understand-python-solution",
                "content": "Time Complexity -  O(m*n*n)\\nSpace Complexity - O(m*n)\\n\\nm,n - no. of rows, cols of matrix\\n\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m,n = len(matrix), len(matrix[0])\\n        for i in range(m):\\n            for j in range(1,n):\\n                matrix[i][j] += matrix[i][j-1]\\n        \\n        # print(matrix)\\n        ans = 0\\n        #submatrix column division for each pair of columns\\n        for sc1 in range(n):\\n            for sc2 in range(sc1,n):\\n                d = collections.defaultdict(int)\\n                ## sum 0\\n                d[0] = 1\\n                #submatrix sum\\n                s = 0\\n                for i in range(m):\\n                    s += matrix[i][sc2]\\n                    #remove previous column sums\\n                    if sc1:\\n                        s -= matrix[i][sc1-1]\\n                    ans += d[s-target]\\n                    d[s] += 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m,n = len(matrix), len(matrix[0])\\n        for i in range(m):\\n            for j in range(1,n):\\n                matrix[i][j] += matrix[i][j-1]\\n        \\n        # print(matrix)\\n        ans = 0\\n        #submatrix column division for each pair of columns\\n        for sc1 in range(n):\\n            for sc2 in range(sc1,n):\\n                d = collections.defaultdict(int)\\n                ## sum 0\\n                d[0] = 1\\n                #submatrix sum\\n                s = 0\\n                for i in range(m):\\n                    s += matrix[i][sc2]\\n                    #remove previous column sums\\n                    if sc1:\\n                        s -= matrix[i][sc1-1]\\n                    ans += d[s-target]\\n                    d[s] += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2215262,
                "title": "c-using-prefix-matrix",
                "content": "```\\n/**\\n   @brief   First thing about this problem. its constraints demand O(m*n*n) solution. So dont waste your time thinking of something better.\\n            Now, you must have noted the fact that in problems where we have to store the data of a submatrix or something like that, we go\\n            with prefix matrix. Like in the question, Largest Area of Rectangle, we did the same. Here too, we do the same. We make a prefix\\n            matrix, storing the sum of all the elements in a coloumn upto current cell. Now, we use this prefix matrix to compute our answer.\\n            So, as i said, this question demands a O(n^3), the third loop is actually to set a region of rows to be processed at a time. So\\n            we move down, row wise, and at each row, we proces all the submatrices, that could be formed between any row above it and current \\n            row. Therefore, we run another loop, r, which starts from 0 to i, and using this loop, we update the current prefix row, by subtracting\\n            the values on that row, so that to eliminate all the subarrays above row r. Then, we will have a single array, the current row with \\n            updated values, and we compute our answer with that. Doing so for all the row pairs will give our final answer. \\n\\n */\\n\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<vector<int>> prefix(m,vector<int>(n,0));\\n        for(int j = 0; j<n; j++){\\n            int sum = 0;\\n            for(int i = 0; i<m; i++){\\n                sum += matrix[i][j];\\n                prefix[i][j] = sum;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i = 0; i<m; i++){\\n            for(int r = 0; r<=i; r++){\\n                vector <int> arr = prefix[i];\\n                if(r==i) ans += fun(arr,target);\\n                else{\\n                    for(int j = 0; j<n; j++) arr[j] -= prefix[r][j];\\n                    ans += fun(arr,target);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\nprotected:\\n    int fun(vector<int>&arr, int target){\\n        unordered_map <int,int> mp;\\n        int sum = 0, ans = 0;\\n        for(int i = 0; i<arr.size(); i++){\\n            sum += arr[i];\\n            if(sum == target) ans++;\\n            if(mp.find(sum-target)!=mp.end()) ans += mp[sum-target];\\n            mp[sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n   @brief   First thing about this problem. its constraints demand O(m*n*n) solution. So dont waste your time thinking of something better.\\n            Now, you must have noted the fact that in problems where we have to store the data of a submatrix or something like that, we go\\n            with prefix matrix. Like in the question, Largest Area of Rectangle, we did the same. Here too, we do the same. We make a prefix\\n            matrix, storing the sum of all the elements in a coloumn upto current cell. Now, we use this prefix matrix to compute our answer.\\n            So, as i said, this question demands a O(n^3), the third loop is actually to set a region of rows to be processed at a time. So\\n            we move down, row wise, and at each row, we proces all the submatrices, that could be formed between any row above it and current \\n            row. Therefore, we run another loop, r, which starts from 0 to i, and using this loop, we update the current prefix row, by subtracting\\n            the values on that row, so that to eliminate all the subarrays above row r. Then, we will have a single array, the current row with \\n            updated values, and we compute our answer with that. Doing so for all the row pairs will give our final answer. \\n\\n */\\n\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<vector<int>> prefix(m,vector<int>(n,0));\\n        for(int j = 0; j<n; j++){\\n            int sum = 0;\\n            for(int i = 0; i<m; i++){\\n                sum += matrix[i][j];\\n                prefix[i][j] = sum;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i = 0; i<m; i++){\\n            for(int r = 0; r<=i; r++){\\n                vector <int> arr = prefix[i];\\n                if(r==i) ans += fun(arr,target);\\n                else{\\n                    for(int j = 0; j<n; j++) arr[j] -= prefix[r][j];\\n                    ans += fun(arr,target);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\nprotected:\\n    int fun(vector<int>&arr, int target){\\n        unordered_map <int,int> mp;\\n        int sum = 0, ans = 0;\\n        for(int i = 0; i<arr.size(); i++){\\n            sum += arr[i];\\n            if(sum == target) ans++;\\n            if(mp.find(sum-target)!=mp.end()) ans += mp[sum-target];\\n            mp[sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2190325,
                "title": "c-brute-force-o-m-m-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>pref;\\n    int getVal(int i,int j){\\n        if(i < 0 || j < 0 || i>=pref.size() || j>=pref[0].size())\\n            return 0;\\n        return pref[i][j];\\n    }\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        pref.assign(m,vector<int>(n,0));\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                pref[i][j] = matrix[i][j] + getVal(i-1,j) + getVal(i,j-1) - getVal(i-1,j-1);\\n            }\\n        }\\n        int ans = 0;\\n        for(int r1 = 0;r1<m;r1++){\\n            for(int r2 = r1;r2<m;r2++){\\n                for(int c1 = 0;c1<n;c1++){\\n                    for(int c2 = c1;c2<n;c2++){\\n                        int sum = pref[r2][c2] - getVal(r2,c1-1) - getVal(r1-1,c2) + getVal(r1-1,c1-1);\\n                        if(sum == target)\\n                            ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>pref;\\n    int getVal(int i,int j){\\n        if(i < 0 || j < 0 || i>=pref.size() || j>=pref[0].size())\\n            return 0;\\n        return pref[i][j];\\n    }\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        pref.assign(m,vector<int>(n,0));\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                pref[i][j] = matrix[i][j] + getVal(i-1,j) + getVal(i,j-1) - getVal(i-1,j-1);\\n            }\\n        }\\n        int ans = 0;\\n        for(int r1 = 0;r1<m;r1++){\\n            for(int r2 = r1;r2<m;r2++){\\n                for(int c1 = 0;c1<n;c1++){\\n                    for(int c2 = c1;c2<n;c2++){\\n                        int sum = pref[r2][c2] - getVal(r2,c1-1) - getVal(r1-1,c2) + getVal(r1-1,c1-1);\\n                        if(sum == target)\\n                            ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2146393,
                "title": "easy-accepted-c-code-with-explanation-and-analysis-of-analogy-with-1d-array-question",
                "content": "Question :- To find number of subarrays with sum = target. \\n\\nConcept :- We have total 3 ways to do :- One is sliding window, second is niave by taking all possible subarrays and third is O(n) approach using prefix sum and map which stores all occured prefix sums till current index.\\n\\nSo, first two approaches are straightforward, lets discuss third approach :-\\n\\nCrux :- We iterate from left to right and continuously calculate prefix sum at each index and also storing them in a map and also at current index, we apply map.find(prefix sum - target), if found then we increment our answer or count by map[prefix sum - target] means frequency of compliment (prefix sum - target) already occured.\\n\\nWhat it indicates :- Suppose we have an array and we are at current index 5, means we have already stored all previous prefix sums in map. So, current prefix sum - target = value and if this value exists in map, means the subarray from the index after that found previous sum till current index has a sum = target.\\n\\nSo, if this value has occured for suppose 3 times, means there are 3 subarays which are ending at current index with sum = target and starting after the index till which previous found value has occured.\\n\\nSo, in this way we can calculate all the subarrays with sum = target.\\n\\n\\n\\nNow, we have to just use this concept to solve it for a matrix :-\\n\\nSuppose we have a matrix of size (n * m) , means each row has m elements. \\nThink matrix as a 1d array, BUT we have to find what elements actually matching the analogy with 1d array elements which we discussed above then only we can solve it for matrix.\\n\\nSo, if we think, we can use each row with total m^2 ranges from any left column till any right column, so for this we use all pairs of columns as extremes and consider the range of all rows between current pair of columns inclusive both.\\n\\nSo, the sum of each row elements in the given current range will be considered as the analogy elements of a 1d array.\\n\\nSo for any current range, we have n (number of rows of matrix) elements which are actually the sum of elements in this range for each ith row.\\n\\nNow apply same concept as we did in 1d array case, the only difference is that there we had only 1 occurence of working, here we have m^2 occurences of working, for each possible range of row.\\n\\nNOTE :- Why we are considering all possible ranges in each row? \\n\\nSuppose we have 5 columns or 5 elements in each row then we can select any possible range of continuous elements to form a submatrix whose column length will be this range\\'s length.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        vector<vector<int>> prefix_row(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(j == 0)\\n                {\\n                    prefix_row[i][j] = matrix[i][j];\\n                }\\n                else\\n                {\\n                    prefix_row[i][j] = prefix_row[i][j-1] + matrix[i][j];\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        \\n        for(int lc=0;lc<m;lc++)\\n        {\\n            for(int rc=lc;rc<m;rc++)\\n            {\\n                map<int,int> m;\\n                int prefix = 0;\\n                \\n                m[0] = 1;\\n                \\n                for(int i=0;i<n;i++)\\n                {\\n                    if(lc == 0)\\n                    {\\n                        prefix += prefix_row[i][rc];\\n                    }\\n                    else\\n                    {\\n                        prefix += prefix_row[i][rc] - prefix_row[i][lc - 1];\\n                    }\\n                    \\n                    if(m.find(prefix - target) != m.end())\\n                    {\\n                        res += m[prefix - target];\\n                    }\\n                    \\n                    m[prefix]++;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        vector<vector<int>> prefix_row(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(j == 0)\\n                {\\n                    prefix_row[i][j] = matrix[i][j];\\n                }\\n                else\\n                {\\n                    prefix_row[i][j] = prefix_row[i][j-1] + matrix[i][j];\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        \\n        for(int lc=0;lc<m;lc++)\\n        {\\n            for(int rc=lc;rc<m;rc++)\\n            {\\n                map<int,int> m;\\n                int prefix = 0;\\n                \\n                m[0] = 1;\\n                \\n                for(int i=0;i<n;i++)\\n                {\\n                    if(lc == 0)\\n                    {\\n                        prefix += prefix_row[i][rc];\\n                    }\\n                    else\\n                    {\\n                        prefix += prefix_row[i][rc] - prefix_row[i][lc - 1];\\n                    }\\n                    \\n                    if(m.find(prefix - target) != m.end())\\n                    {\\n                        res += m[prefix - target];\\n                    }\\n                    \\n                    m[prefix]++;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108120,
                "title": "c-2d-prefix-sum",
                "content": "```\\n// Time complexity = O(M*N*N) where M = number of rows in matrix, N = number of columns in matrix\\nclass Solution {\\nprivate:\\n    int get2dSum(vector<vector<int>> &ps, int c1, int c2, int r) {\\n        return ps[r + 1][c2 + 1] - ps[r + 1][c1];\\n    }\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int rSize = matrix.size();\\n        int cSize = matrix[0].size();\\n        vector<vector<int>> ps(rSize + 1, vector<int>(cSize + 1, 0));\\n        \\n        for (int r = 1; r <= rSize; r++) {\\n            for (int c = 1; c <= cSize; c++) {\\n                ps[r][c] = ps[r - 1][c] + ps[r][c - 1] - ps[r - 1][c - 1] + matrix[r - 1][c - 1];\\n            }\\n        }\\n        \\n        int res = 0;\\n        \\n        unordered_map<int, int> prevSum;\\n        for (int c1 = 0; c1 < cSize; c1++) {\\n            for (int c2 = c1; c2 < cSize; c2++) {\\n                prevSum[0] = 1;\\n                for (int r = 0; r < rSize; r++) {\\n                    int currSum = get2dSum(ps, c1, c2, r);\\n                    if (prevSum.count(currSum - target)) {\\n                        res += prevSum[currSum -target];\\n                    }\\n                    prevSum[currSum]++;\\n                }\\n                prevSum.clear();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n// Time complexity = O(M*N*N) where M = number of rows in matrix, N = number of columns in matrix\\nclass Solution {\\nprivate:\\n    int get2dSum(vector<vector<int>> &ps, int c1, int c2, int r) {\\n        return ps[r + 1][c2 + 1] - ps[r + 1][c1];\\n    }\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int rSize = matrix.size();\\n        int cSize = matrix[0].size();\\n        vector<vector<int>> ps(rSize + 1, vector<int>(cSize + 1, 0));\\n        \\n        for (int r = 1; r <= rSize; r++) {\\n            for (int c = 1; c <= cSize; c++) {\\n                ps[r][c] = ps[r - 1][c] + ps[r][c - 1] - ps[r - 1][c - 1] + matrix[r - 1][c - 1];\\n            }\\n        }\\n        \\n        int res = 0;\\n        \\n        unordered_map<int, int> prevSum;\\n        for (int c1 = 0; c1 < cSize; c1++) {\\n            for (int c2 = c1; c2 < cSize; c2++) {\\n                prevSum[0] = 1;\\n                for (int r = 0; r < rSize; r++) {\\n                    int currSum = get2dSum(ps, c1, c2, r);\\n                    if (prevSum.count(currSum - target)) {\\n                        res += prevSum[currSum -target];\\n                    }\\n                    prevSum[currSum]++;\\n                }\\n                prevSum.clear();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039528,
                "title": "java-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int res = 0;\\n        \\n        // traverse upper boundary\\n        for (int top = 0; top < m; top++) {\\n            \\n            // for each upper boundary, we have a prefix sum array\\n            int[] sum = new int[n];\\n            \\n            // traverse lower boundary\\n            for (int bottom = top; bottom < m; bottom++) {\\n                \\n                // count the prefix sum for each column\\n                for (int col = 0; col < n; col++) {\\n                    sum[col] += matrix[bottom][col];\\n                }\\n          \\n                // traverse left and right boundary\\n                for (int left = 0; left < n; left++) {\\n                    int cnt = 0;\\n                    for (int right = left; right < n; right++) {\\n                        cnt += sum[right];\\n                        if (cnt == target) res++;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int res = 0;\\n        \\n        // traverse upper boundary\\n        for (int top = 0; top < m; top++) {\\n            \\n            // for each upper boundary, we have a prefix sum array\\n            int[] sum = new int[n];\\n            \\n            // traverse lower boundary\\n            for (int bottom = top; bottom < m; bottom++) {\\n                \\n                // count the prefix sum for each column\\n                for (int col = 0; col < n; col++) {\\n                    sum[col] += matrix[bottom][col];\\n                }\\n          \\n                // traverse left and right boundary\\n                for (int left = 0; left < n; left++) {\\n                    int cnt = 0;\\n                    for (int right = left; right < n; right++) {\\n                        cnt += sum[right];\\n                        if (cnt == target) res++;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1873139,
                "title": "java-solution-easy-to-understand-tc-o-mnn-space-o-m",
                "content": "Preaquis: 560. Subarray Sum Equals K\\n\\nExplanation\\n* For each row, calculate the prefix sum.\\n* For each pair of columns,\\n* calculate the accumulated sum of rows.\\n* Now this problem is same to, \"Find the Subarray with Target Sum\".\\n\\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int res = 0;\\n        //int[][] sum = new int[row][col];\\n        \\n        for(int i = 0; i < row; i++){\\n            for(int j = 1; j < col; j++){\\n                //sum[i][j] =sum[i][j-1] + matrix[i][j-1];\\n                matrix[i][j] += matrix[i][j-1];\\n            }\\n        }\\n        \\n        for(int start = 0; start < col; start++){\\n            for(int end = start; end < col; end++){\\n                int subMatrixSum = 0;\\n                \\n                Map<Integer, Integer> countElm = new HashMap<Integer, Integer>();\\n                countElm.put(0,1);\\n                \\n                for(int k = 0; k < row; k++){\\n                    //subMatrixSum += sum[k][end] - sum[k][start];\\n                    int prefixSum = start == 0 ? 0:matrix[k][start-1];\\n                    subMatrixSum += matrix[k][end] - prefixSum;\\n                    \\n                    if(countElm.containsKey(subMatrixSum - target))\\n                        res += countElm.get(subMatrixSum - target);\\n                    \\n                    int r = countElm.getOrDefault(subMatrixSum, 0);\\n                    countElm.put(subMatrixSum, r+1);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\nCredit: https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/discuss/803353/Java-Solution-with-Detailed-Explanation",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int res = 0;\\n        //int[][] sum = new int[row][col];\\n        \\n        for(int i = 0; i < row; i++){\\n            for(int j = 1; j < col; j++){\\n                //sum[i][j] =sum[i][j-1] + matrix[i][j-1];\\n                matrix[i][j] += matrix[i][j-1];\\n            }\\n        }\\n        \\n        for(int start = 0; start < col; start++){\\n            for(int end = start; end < col; end++){\\n                int subMatrixSum = 0;\\n                \\n                Map<Integer, Integer> countElm = new HashMap<Integer, Integer>();\\n                countElm.put(0,1);\\n                \\n                for(int k = 0; k < row; k++){\\n                    //subMatrixSum += sum[k][end] - sum[k][start];\\n                    int prefixSum = start == 0 ? 0:matrix[k][start-1];\\n                    subMatrixSum += matrix[k][end] - prefixSum;\\n                    \\n                    if(countElm.containsKey(subMatrixSum - target))\\n                        res += countElm.get(subMatrixSum - target);\\n                    \\n                    int r = countElm.getOrDefault(subMatrixSum, 0);\\n                    countElm.put(subMatrixSum, r+1);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596840,
                "title": "c-o-n-3-cumulative-sum-compress-rows",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n\\n        int R = matrix.size();\\n        int C = matrix[0].size();\\n\\n        int ans = 0;\\n\\n        for(int topBoundary = 0; topBoundary<R; topBoundary++){\\n\\n            vector<int> nums(C,0);\\n\\n            for(int bottomBoundary = topBoundary; bottomBoundary<R; bottomBoundary++){\\n                \\n                for(int j=0;j<C;j++)    nums[j] += matrix[bottomBoundary][j];\\n\\n                // Now do exactly this: https://leetcode.com/problems/subarray-sum-equals-k/\\n                unordered_map<int,int> mp; // <cumulative sum , number of such subarrays>\\n                mp[0] = +1;\\n\\n                int cumuSum = 0;\\n                for(int i=0;i<C;i++){\\n                    \\n                    cumuSum += nums[i];\\n                    ans += (mp.count(cumuSum - target) > 0 ? mp[cumuSum - target] : 0);\\n                    mp[cumuSum] ++;\\n\\n                }\\n                //---------------------------------------------------------------------------\\n            }\\n\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n\\n        int R = matrix.size();\\n        int C = matrix[0].size();\\n\\n        int ans = 0;\\n\\n        for(int topBoundary = 0; topBoundary<R; topBoundary++){\\n\\n            vector<int> nums(C,0);\\n\\n            for(int bottomBoundary = topBoundary; bottomBoundary<R; bottomBoundary++){\\n                \\n                for(int j=0;j<C;j++)    nums[j] += matrix[bottomBoundary][j];\\n\\n                // Now do exactly this: https://leetcode.com/problems/subarray-sum-equals-k/\\n                unordered_map<int,int> mp; // <cumulative sum , number of such subarrays>\\n                mp[0] = +1;\\n\\n                int cumuSum = 0;\\n                for(int i=0;i<C;i++){\\n                    \\n                    cumuSum += nums[i];\\n                    ans += (mp.count(cumuSum - target) > 0 ? mp[cumuSum - target] : 0);\\n                    mp[cumuSum] ++;\\n\\n                }\\n                //---------------------------------------------------------------------------\\n            }\\n\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579357,
                "title": "c-explained-with-stepwise-algorithm-prefix-sum-hash-table",
                "content": "**Algorithm**\\n1.  find prefix sum of matrix\\n2.  take a pair of rows(r1 and r2) and traverse along row.\\n3.  while traversing along the row for each column, find submatrix Sum between r1 and r2 using prefix sum in O(1) time.\\n4.  check if the sum - target is already present in map (i.e sumatrix with sum = sum - target is present) and increase the count accordingly\\n5.  now put the sum in map and increase its count.\\n\\n**Note-**\\nfor r1 = 0, there is no *sub*matrix so take sum of submatrix for r2 only\\n**Upvote Please!**\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& m, int target) {\\n        \\n        int r = m.size(), c = m[0].size();\\n        int res = 0;\\n        for(int i = 1;i < c; i++)\\n            m[0][i] += m[0][i-1];\\n        for(int i = 1; i < r; i++)\\n            m[i][0] += m[i-1][0];\\n        for(int i = 1; i < r; i++)\\n            for(int j = 1; j < c; j++)\\n                m[i][j] += m[i-1][j] + m[i][j-1] - m[i-1][j-1];\\n        \\n        for(int r1 = 0; r1 < r; r1++)\\n        {\\n            for(int r2 = r1; r2 < r; r2++)\\n            {\\n                unordered_map<int, int> map;\\n                map[0]++;\\n                for(int y = 0; y < c; y++)\\n                {\\n                    int sum = m[r2][y];\\n                    if(r1 != 0)sum -= m[r1-1][y];\\n                    if(map.find(sum-target) != map.end())res+= map[sum-target];\\n                    map[sum]++;\\n                }\\n            }\\n        }\\n        return res;                \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& m, int target) {\\n        \\n        int r = m.size(), c = m[0].size();\\n        int res = 0;\\n        for(int i = 1;i < c; i++)\\n            m[0][i] += m[0][i-1];\\n        for(int i = 1; i < r; i++)\\n            m[i][0] += m[i-1][0];\\n        for(int i = 1; i < r; i++)\\n            for(int j = 1; j < c; j++)\\n                m[i][j] += m[i-1][j] + m[i][j-1] - m[i-1][j-1];\\n        \\n        for(int r1 = 0; r1 < r; r1++)\\n        {\\n            for(int r2 = r1; r2 < r; r2++)\\n            {\\n                unordered_map<int, int> map;\\n                map[0]++;\\n                for(int y = 0; y < c; y++)\\n                {\\n                    int sum = m[r2][y];\\n                    if(r1 != 0)sum -= m[r1-1][y];\\n                    if(map.find(sum-target) != map.end())res+= map[sum-target];\\n                    map[sum]++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1526961,
                "title": "python-solution-with-600ms",
                "content": "```\\nimport numpy as np\\nimport copy\\nclass Solution(object):\\n    def numSubmatrixSumTarget(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        xs, ys = len(matrix), len(matrix[0])\\n        res = []\\n        for x1 in range(xs):\\n            #x2 = x1\\n            line = []\\n            for y1 in range(ys):\\n                prev = 0\\n                for y2 in range(y1, ys):\\n                    prev += matrix[x1][y2]\\n                    line += [prev]\\n            res += [line]\\n        res = np.array(res)\\n        tmp = copy.deepcopy(res)\\n        tot = np.sum(tmp == target)\\n        for step in range(1, xs):\\n            tmp = tmp[:-1] + res[step:]\\n            tot += np.sum(tmp == target)\\n        return tot\\n```",
                "solutionTags": [],
                "code": "```\\nimport numpy as np\\nimport copy\\nclass Solution(object):\\n    def numSubmatrixSumTarget(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        xs, ys = len(matrix), len(matrix[0])\\n        res = []\\n        for x1 in range(xs):\\n            #x2 = x1\\n            line = []\\n            for y1 in range(ys):\\n                prev = 0\\n                for y2 in range(y1, ys):\\n                    prev += matrix[x1][y2]\\n                    line += [prev]\\n            res += [line]\\n        res = np.array(res)\\n        tmp = copy.deepcopy(res)\\n        tot = np.sum(tmp == target)\\n        for step in range(1, xs):\\n            tmp = tmp[:-1] + res[step:]\\n            tot += np.sum(tmp == target)\\n        return tot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435108,
                "title": "c-easy-peasy-solution",
                "content": "class Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        \\n        int count=0;\\n        \\n        for(int i=0;i<m;i++){\\n            \\n            for(int j=1;j<n;j++){\\n                \\n                matrix[i][j]+=matrix[i][j-1];\\n                \\n            }\\n            \\n        }\\n        \\n        for(int c1=0;c1<n;c1++){\\n            \\n            for(int c2=c1;c2<n;c2++){\\n                \\n                map<int,int>mp;\\n                mp[0]=1;\\n                int sum=0;\\n                \\n                for(int row=0;row<m;row++){\\n                    \\n                    sum+=matrix[row][c2]-(c1>0?matrix[row][c1-1]:0);\\n                    \\n                    count+=mp[sum-target];\\n                    \\n                    mp[sum]++;\\n                    \\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        \\n        int count=0;\\n        \\n        for(int i=0;i<m;i++){\\n            \\n            for(int j=1;j<n;j++){\\n                \\n                matrix[i][j]+=matrix[i][j-1];\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1434544,
                "title": "o-n-3-converting-to-1d-then-applying-kadane",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& mat, int target) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int ans=0;\\n        int dp[m];\\n        for(int i=0;i<n;i++){\\n            memset(dp,0,sizeof(dp));\\n            for(int j=i;j<n;j++){\\n                int cs=0;\\n                unordered_map<int,int>maps;\\n                maps[0]=1;\\n                for(int k=0;k<m;k++){\\n                    dp[k]+=mat[j][k];\\n                    cs+=dp[k];\\n                    if(maps.find(cs-target)!=maps.end()){\\n                        ans+=maps[cs-target];\\n                    }\\n                    maps[cs]++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& mat, int target) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int ans=0;\\n        int dp[m];\\n        for(int i=0;i<n;i++){\\n            memset(dp,0,sizeof(dp));\\n            for(int j=i;j<n;j++){\\n                int cs=0;\\n                unordered_map<int,int>maps;\\n                maps[0]=1;\\n                for(int k=0;k<m;k++){\\n                    dp[k]+=mat[j][k];\\n                    cs+=dp[k];\\n                    if(maps.find(cs-target)!=maps.end()){\\n                        ans+=maps[cs-target];\\n                    }\\n                    maps[cs]++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287019,
                "title": "c-prefix-sum-solution",
                "content": "**Intuition**\\n![image](https://assets.leetcode.com/users/images/95b29370-2238-46b5-a12b-5146389b9037_1624256582.071004.png)\\n\\n**complexity**\\n- time: O(M^2 * N) where M is the number of rows of matrix, N is the number of columns of matrix\\n- space: O(MN)\\n\\n**implementation**\\n```\\npublic class Solution {\\n    public int NumSubmatrixSumTarget(int[][] matrix, int target) {\\n        \\n        if(matrix == null || matrix.Length == 0)\\n            return 0;\\n        \\n        int m = matrix.Length, n = matrix[0].Length;\\n        int[,] prefixSum = new int[m + 1, n + 1];\\n        for(int i = 1; i <= m; i++)\\n        {\\n            for(int j = 1; j <= n; j++)      \\n            {\\n                // prefixSum[i,j] denotes the sum of elements between matrix[0][0] ~ matrix[i-1][j-1]\\n                prefixSum[i,j] = prefixSum[i-1,j] + prefixSum[i,j-1] - prefixSum[i-1,j-1] + matrix[i-1][j-1];\\n            }\\n        }\\n            \\n        // Key: rangeSum, Value: count\\n        Dictionary<int,int> dic = new Dictionary<int,int>();\\n        int cnt = 0;\\n        for(int r1 = 1; r1 <= m; r1++)\\n        {\\n            for(int r2 = r1; r2 <= m; r2++)\\n            {\\n                dic.Clear();\\n                // count of range sum starting with 0-th element\\n                dic.Add(0,1);\\n                \\n                for(int col = 1; col <= n; col++)\\n                {\\n                    // fix r1, then move r2 to enlarge the range\\n                    // prefixSum[r1 - 1,col] dentoes the sum of r1-th row\\n                    int rangeSum = prefixSum[r2,col] - prefixSum[r1 - 1,col];\\n                    \\n                    // rangeSum - need = target\\n                    int need = rangeSum - target;\\n                    if(dic.ContainsKey(need))\\n                        cnt += dic[need];\\n                    \\n                    if(dic.ContainsKey(rangeSum))\\n                        dic[rangeSum]++;\\n                    else\\n                        dic.Add(rangeSum,1);\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumSubmatrixSumTarget(int[][] matrix, int target) {\\n        \\n        if(matrix == null || matrix.Length == 0)\\n            return 0;\\n        \\n        int m = matrix.Length, n = matrix[0].Length;\\n        int[,] prefixSum = new int[m + 1, n + 1];\\n        for(int i = 1; i <= m; i++)\\n        {\\n            for(int j = 1; j <= n; j++)      \\n            {\\n                // prefixSum[i,j] denotes the sum of elements between matrix[0][0] ~ matrix[i-1][j-1]\\n                prefixSum[i,j] = prefixSum[i-1,j] + prefixSum[i,j-1] - prefixSum[i-1,j-1] + matrix[i-1][j-1];\\n            }\\n        }\\n            \\n        // Key: rangeSum, Value: count\\n        Dictionary<int,int> dic = new Dictionary<int,int>();\\n        int cnt = 0;\\n        for(int r1 = 1; r1 <= m; r1++)\\n        {\\n            for(int r2 = r1; r2 <= m; r2++)\\n            {\\n                dic.Clear();\\n                // count of range sum starting with 0-th element\\n                dic.Add(0,1);\\n                \\n                for(int col = 1; col <= n; col++)\\n                {\\n                    // fix r1, then move r2 to enlarge the range\\n                    // prefixSum[r1 - 1,col] dentoes the sum of r1-th row\\n                    int rangeSum = prefixSum[r2,col] - prefixSum[r1 - 1,col];\\n                    \\n                    // rangeSum - need = target\\n                    int need = rangeSum - target;\\n                    if(dic.ContainsKey(need))\\n                        cnt += dic[need];\\n                    \\n                    if(dic.ContainsKey(rangeSum))\\n                        dic[rangeSum]++;\\n                    else\\n                        dic.Add(rangeSum,1);\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250673,
                "title": "java-vs-python3-brute-force-with-prefixes-java-succeeds-python-fails",
                "content": "Trying brute-force with prefixes in different languages, i.e., caclulating 2D prefix sums and iterating over every submatrice. \\nThis is a great example to see how Python execution time suffers when using plain `for` loops.\\nDoing this in Java, it succeeds all tests after 250 ms. Doing the same in Python3 fails with `Time Limit Exceeded`, i.e., >10s. \\n\\n**Java 250 ms**\\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[][] prefixes = calculatePrefixes(matrix);\\n        int ans = 0;\\n        for(int i=1; i<=m; i++) {\\n            for(int j=1; j<=n; j++) {\\n                for(int a=i; a<=m; a++) {\\n                    for(int b=j; b<=n; b++) {\\n                        if(prefixes[a][b] - prefixes[i-1][b] - prefixes[a][j-1] + prefixes[i-1][j-1] == target) {\\n                            ans += 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int[][] calculatePrefixes(int[][] matrix) {\\n        int[][] prefixes = new int[matrix.length + 1][matrix[0].length + 1];\\n        prefixes[0] = new int[matrix[0].length + 1];\\n        for(int i=0; i<=matrix[0].length; i++) {\\n            prefixes[0][i] = 0;\\n        }\\n\\n        for(int i=1; i<=matrix.length; i++) {\\n            prefixes[i][0] = 0;\\n            for(int j=1; j<=matrix[0].length; j++) {\\n                prefixes[i][j] = prefixes[i][j-1] + matrix[i-1][j-1];\\n            }\\n        }\\n\\n        for(int j=1; j<=matrix[0].length; j++) {\\n            for(int i=1; i<=matrix.length; i++) {\\n                prefixes[i][j] += prefixes[i-1][j];\\n            }\\n        }\\n\\n        return prefixes;\\n    }\\n}\\n```\\n\\n**Python3 - Time Limit Exceeded**\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        ans = 0\\n        \\n        # 2d prefix sums with [0] prefix:\\n        # accumulate rows -> transpose -> accumulate rows -> transpose\\n\\t\\t# calculating the 2D prefixes takes around 10-20 ms\\n        acc_rows = [list(accumulate(row)) for row in matrix]\\n        transposed = [list(tup) for tup in zip(*acc_rows)]\\n        acc_rows = [[0]*m] + [list(accumulate(row)) for row in transposed]\\n        prefixes = [[0]*(n+1)] + [list(tup) for tup in zip(*acc_rows)]\\n        \\n\\t\\t# access to local variables is much faster than to global\\n\\t\\tr = range\\n\\t\\t\\n        # Iterate over all submatrices\\n        for i in r(1, m+1):\\n            for j in r(1, n+1):\\n                for a in r(i, m+1):\\n                    for b in r(j, n+1):\\n                        if prefixes[a][b] - prefixes[i-1][b] - prefixes[a][j-1] + prefixes[i-1][j-1] == target:\\n                            ans += 1\\n        return ans\\n```\\n\\nCalculating the 2D prefixes takes up to 20 ms, so that is not the core problem here. In general Python3 execution time suffers heavily from accessing attributes or making function calls. Further, plain `for` loops are pretty slow too compared to built-in functions and list comprehension. Best performance boost can be gained by using numpy arrays, but that is also more complex than using plain built-in `for` loops.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[][] prefixes = calculatePrefixes(matrix);\\n        int ans = 0;\\n        for(int i=1; i<=m; i++) {\\n            for(int j=1; j<=n; j++) {\\n                for(int a=i; a<=m; a++) {\\n                    for(int b=j; b<=n; b++) {\\n                        if(prefixes[a][b] - prefixes[i-1][b] - prefixes[a][j-1] + prefixes[i-1][j-1] == target) {\\n                            ans += 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int[][] calculatePrefixes(int[][] matrix) {\\n        int[][] prefixes = new int[matrix.length + 1][matrix[0].length + 1];\\n        prefixes[0] = new int[matrix[0].length + 1];\\n        for(int i=0; i<=matrix[0].length; i++) {\\n            prefixes[0][i] = 0;\\n        }\\n\\n        for(int i=1; i<=matrix.length; i++) {\\n            prefixes[i][0] = 0;\\n            for(int j=1; j<=matrix[0].length; j++) {\\n                prefixes[i][j] = prefixes[i][j-1] + matrix[i-1][j-1];\\n            }\\n        }\\n\\n        for(int j=1; j<=matrix[0].length; j++) {\\n            for(int i=1; i<=matrix.length; i++) {\\n                prefixes[i][j] += prefixes[i-1][j];\\n            }\\n        }\\n\\n        return prefixes;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        ans = 0\\n        \\n        # 2d prefix sums with [0] prefix:\\n        # accumulate rows -> transpose -> accumulate rows -> transpose\\n\\t\\t# calculating the 2D prefixes takes around 10-20 ms\\n        acc_rows = [list(accumulate(row)) for row in matrix]\\n        transposed = [list(tup) for tup in zip(*acc_rows)]\\n        acc_rows = [[0]*m] + [list(accumulate(row)) for row in transposed]\\n        prefixes = [[0]*(n+1)] + [list(tup) for tup in zip(*acc_rows)]\\n        \\n\\t\\t# access to local variables is much faster than to global\\n\\t\\tr = range\\n\\t\\t\\n        # Iterate over all submatrices\\n        for i in r(1, m+1):\\n            for j in r(1, n+1):\\n                for a in r(i, m+1):\\n                    for b in r(j, n+1):\\n                        if prefixes[a][b] - prefixes[i-1][b] - prefixes[a][j-1] + prefixes[i-1][j-1] == target:\\n                            ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248486,
                "title": "please-help-with-this-error",
                "content": "**My code is all correct but getting this error**\\nEdit : problem is solved.\\n\\nIn the innermost loop\\n```\\nfor{int k=0;k<matrix.size();k++)\\n                {\\n                    sum+=matrix[k][j];\\n```\\nBy mistake i wrote { instead of (  in \"for{int k=0;k<matrix.size();k++)\".\\nThat was the error.\\n\\nx---------------x-----------------x--------------------x----------------x\\n\\nLine 86: Char 28: error: expected \\'}\\'\\n#pragma GCC optimize (\"O2\")\\n                           ^\\nLine 1: Char 16: note: to match this \\'{\\'\\nclass Solution {\\n               ^\\n\\t\\t\\t   **CODE**\\n```cpp\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        for(int i=0;i<matrix.size();i++)\\n            for(int j=1;j<matrix[0].size();j++)\\n                matrix[i][j]+=matrix[i][j-1];\\n        \\n        int ans=0;\\n        for(int i=0;i<matrix[0].size();i++)\\n        {\\n            for(int j=i;j<matrix[0].size();j++)\\n            {\\n                unordered_map <int,int> mp;\\n                mp[0]=1;\\n                int sum=0;\\n                for{int k=0;k<matrix.size();k++)\\n                {\\n                    sum+=matrix[k][j];\\n                    if(i>0) sum-=matrix[k][i-1];\\n                    if(mp.find(sum-target)!=mp.end()) \\n                    ans+=mp[sum-target];\\n                    mp[sum]++;\\n                }\\n            }\\n        }\\n        return ans;\\n     }\\n\\t };\\n\\t",
                "solutionTags": [],
                "code": "```\\nfor{int k=0;k<matrix.size();k++)\\n                {\\n                    sum+=matrix[k][j];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1222975,
                "title": "java-easy-solution",
                "content": "```\\npublic int numSubmatrixSumTarget(int[][] matrix, int target) {\\n   // by max summ rectangle logic\\'\\n       int n = matrix.length; int m = matrix[0].length; \\n       HashMap<Integer,Integer> map = new HashMap<>();\\n       int count=0;\\n        for(int fixedR = 0;fixedR<n;fixedR++){\\n         int[] prefixCol = new int[m];   \\n           for(int row = fixedR ; row< n;row++){\\n              for(int col = 0;col<m;col++)\\n                 prefixCol[col] += matrix[row][col];\\n               \\n               count += countSubarraysGivenTarget(prefixCol,target);\\n             \\n           }\\n            \\n       }\\n        \\n     return count;   \\n    }\\n        public static int countSubarraysGivenTarget(int[] arr , int tar){\\n            HashMap<Integer,Integer> map = new HashMap<>();\\n            map.put(0,1);\\n            int count = 0;\\n            int sum=0;\\n            for(int ele : arr){\\n                sum+=ele;\\n                count+=map.getOrDefault(sum - tar,0);\\n                \\n                map.put(sum,map.getOrDefault(sum,0)+1);\\n                \\n            }\\n            return count;\\n        }\\n    \\n```",
                "solutionTags": [],
                "code": "```\\npublic int numSubmatrixSumTarget(int[][] matrix, int target) {\\n   // by max summ rectangle logic\\'\\n       int n = matrix.length; int m = matrix[0].length; \\n       HashMap<Integer,Integer> map = new HashMap<>();\\n       int count=0;\\n        for(int fixedR = 0;fixedR<n;fixedR++){\\n         int[] prefixCol = new int[m];   \\n           for(int row = fixedR ; row< n;row++){\\n              for(int col = 0;col<m;col++)\\n                 prefixCol[col] += matrix[row][col];\\n               \\n               count += countSubarraysGivenTarget(prefixCol,target);\\n             \\n           }\\n            \\n       }\\n        \\n     return count;   \\n    }\\n        public static int countSubarraysGivenTarget(int[] arr , int tar){\\n            HashMap<Integer,Integer> map = new HashMap<>();\\n            map.put(0,1);\\n            int count = 0;\\n            int sum=0;\\n            for(int ele : arr){\\n                sum+=ele;\\n                count+=map.getOrDefault(sum - tar,0);\\n                \\n                map.put(sum,map.getOrDefault(sum,0)+1);\\n                \\n            }\\n            return count;\\n        }\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1218138,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int count = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 1; j < m; j++) {\\n                matrix[i][j] += matrix[i][j-1];\\n            }\\n        }\\n        int ans = 0;\\n        map<int, int> god;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = i; j < m; j++) {\\n                god.clear();\\n                god[0] = 1;\\n                int sum = 0;\\n                for(int row = 0; row < n; row++) {\\n                    sum += matrix[row][j] - (i>0 ? matrix[row][i-1]: 0);\\n                    if(god.find(sum-target) != god.end()) {\\n                        ans += god[sum - target];\\n                    }\\n                    god[sum]++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int count = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 1; j < m; j++) {\\n                matrix[i][j] += matrix[i][j-1];\\n            }\\n        }\\n        int ans = 0;\\n        map<int, int> god;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = i; j < m; j++) {\\n                god.clear();\\n                god[0] = 1;\\n                int sum = 0;\\n                for(int row = 0; row < n; row++) {\\n                    sum += matrix[row][j] - (i>0 ? matrix[row][i-1]: 0);\\n                    if(god.find(sum-target) != god.end()) {\\n                        ans += god[sum - target];\\n                    }\\n                    god[sum]++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169444,
                "title": "c-easy-solution",
                "content": "Remebr this from your high school Maths class ?\\n**n(A\\u222AB) = n(A) + n(B) - n(A\\u2229B)** \\nI have tried to use concept of *prefix sum matrix* here(which was the solution for similar problem in 1D array) and *basic concept of set theory (stated above)* to solve a problem which was to efficiently calculate prefix sum matrix.\\nAfter that for every possible submatrix we check wether it\\'s sum is equal to target or not and collect our required answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        // Make the Plan\\n        int n = matrix.size(), m = matrix[0].size(), ans = 0;\\n        vector<vector<int> > preSum(n+1,vector<int>(m+1));\\n        \\n        // Execute The Plan\\n        for ( int i = 0 ; i < n ; ++i ) \\n            for ( int j = 0 ; j < m ; ++j ) \\n                preSum[i+1][j+1] = matrix[i][j] + preSum[i][j+1] + preSum[i+1][j] - preSum[i][j];\\n        \\n        // Expect the plan to go off the rails\\n        for ( int x1 = 1 ; x1 < n+1 ; ++x1 )\\n            for ( int y1 = 1 ; y1 < m+1 ; ++y1 )\\n                for ( int x2 = x1 ; x2 < n+1 ; ++x2 )\\n                    for ( int y2 = y1 ; y2 < m+1 ; ++y2 ) \\n                        ans += ( preSum[x2][y2] - preSum[x1-1][y2] - preSum[x2][y1-1] + preSum[x1-1][y1-1]==target );\\n        \\n        // Throw the plan\\n        return ans;\\n    }\\n};\\n```\\n**PS: Hail Leo Snart!**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        // Make the Plan\\n        int n = matrix.size(), m = matrix[0].size(), ans = 0;\\n        vector<vector<int> > preSum(n+1,vector<int>(m+1));\\n        \\n        // Execute The Plan\\n        for ( int i = 0 ; i < n ; ++i ) \\n            for ( int j = 0 ; j < m ; ++j ) \\n                preSum[i+1][j+1] = matrix[i][j] + preSum[i][j+1] + preSum[i+1][j] - preSum[i][j];\\n        \\n        // Expect the plan to go off the rails\\n        for ( int x1 = 1 ; x1 < n+1 ; ++x1 )\\n            for ( int y1 = 1 ; y1 < m+1 ; ++y1 )\\n                for ( int x2 = x1 ; x2 < n+1 ; ++x2 )\\n                    for ( int y2 = y1 ; y2 < m+1 ; ++y2 ) \\n                        ans += ( preSum[x2][y2] - preSum[x1-1][y2] - preSum[x2][y1-1] + preSum[x1-1][y1-1]==target );\\n        \\n        // Throw the plan\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165850,
                "title": "python3-prefix-sum",
                "content": "\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0]) # dimensions \\n        \\n        ans = 0 \\n        freq = defaultdict(int)\\n        prefix = [[0]*(n+1) for _ in range(m+1)]\\n        for i in range(m): \\n            for j in range(n): \\n                prefix[i+1][j+1] = matrix[i][j] + prefix[i+1][j] + prefix[i][j+1] - prefix[i][j]\\n                for jj in range(-1, j): \\n                    diff = prefix[i+1][j+1] - prefix[i+1][jj+1] \\n                    ans += freq[jj, j, diff - target]\\n                    if diff == target: ans += 1\\n                    freq[jj, j, diff] += 1\\n        return ans \\n```\\n\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        ans = 0 \\n        m, n = len(matrix), len(matrix[0]) # dimensions \\n        prefix = [[0]*(n+1) for _ in range(m+1)]\\n        \\n        for i in range(m): \\n            for j in range(n): \\n                prefix[i+1][j+1] = matrix[i][j] + prefix[i+1][j] + prefix[i][j+1] - prefix[i][j]\\n                \\n            for ii in range(i+1):\\n                freq = {0: 1}\\n                for j in range(n): \\n                    diff = prefix[i+1][j+1] - prefix[ii][j+1] \\n                    ans += freq.get(diff - target, 0)\\n                    freq[diff] = 1 + freq.get(diff, 0)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0]) # dimensions \\n        \\n        ans = 0 \\n        freq = defaultdict(int)\\n        prefix = [[0]*(n+1) for _ in range(m+1)]\\n        for i in range(m): \\n            for j in range(n): \\n                prefix[i+1][j+1] = matrix[i][j] + prefix[i+1][j] + prefix[i][j+1] - prefix[i][j]\\n                for jj in range(-1, j): \\n                    diff = prefix[i+1][j+1] - prefix[i+1][jj+1] \\n                    ans += freq[jj, j, diff - target]\\n                    if diff == target: ans += 1\\n                    freq[jj, j, diff] += 1\\n        return ans \\n```\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        ans = 0 \\n        m, n = len(matrix), len(matrix[0]) # dimensions \\n        prefix = [[0]*(n+1) for _ in range(m+1)]\\n        \\n        for i in range(m): \\n            for j in range(n): \\n                prefix[i+1][j+1] = matrix[i][j] + prefix[i+1][j] + prefix[i][j+1] - prefix[i][j]\\n                \\n            for ii in range(i+1):\\n                freq = {0: 1}\\n                for j in range(n): \\n                    diff = prefix[i+1][j+1] - prefix[ii][j+1] \\n                    ans += freq.get(diff - target, 0)\\n                    freq[diff] = 1 + freq.get(diff, 0)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164993,
                "title": "easy-to-understand-prefix-sum-o-n-n-m",
                "content": "All solution are a bit confusion. So writing this.\\n\\nPlease solve [this](https://leetcode.com/problems/subarray-sum-equals-k/solution/) before reading below explanation.\\n\\n1. Create a prefix sum for every row.\\n2. Create start and end using colums length such that 0 <= start <= end < len(array)\\n```\\nfor start in range(len(matrix[0)):\\n\\tfor end in range(start, len(matrix[0)):\\n```\\nApply [this](https://leetcode.com/problems/subarray-sum-equals-k/discuss/1164884/Easy-to-Understand-O(n)) within the inner loop in terms of rows.\\n\\nplease go through the comment for clear understanding.\\n\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, ma: List[List[int]], t: int) -> int:\\n\\t\\t# row - m, column - n\\n        m, n = len(ma), len(ma[0])\\n\\t\\t# building prefix Sum on rows\\n        for i in range(m):\\n            for j in range(1,n):\\n                ma[i][j]+=ma[i][j-1]\\n        print(ma)\\n\\t\\t# result that we want to emit\\n        res = 0\\n\\t\\t# creating combination of i, j where 0 <= i <= j <= len(martix[0])\\n        for i in range(n):\\n            for j in range(i,n):\\n\\t\\t\\t\\t# creating map for storing previous sums\\n                c = collections.defaultdict(int)\\n                cur, c[0] = 0, 1\\n\\t\\t\\t\\t# iterating 0 to rowlength\\n\\t\\t\\t\\t# for k  = 0 \\n\\t\\t\\t\\t# only row 0\\n\\t\\t\\t\\t# for k = 1\\n\\t\\t\\t\\t# row row 0 + row 1\\n\\t\\t\\t\\t# and so on\\n                for k in range(m):\\n\\t\\t\\t\\t\\t# Calculating sum of elements in range i to j indexes of columns using prefix sum\\n                    cur += ma[k][j] - (ma[k][i - 1] if i > 0 else 0)\\n\\t\\t\\t\\t\\t# checking if sum - target is present previously or not\\n                    res += c[cur - t]\\n                    c[cur] += 1\\n        return res\\n```\\n\\nTime complexity: O(n*n*m)\\nspace complexity: O(m)\\nPlease Upvote! if it is helpful.\\n\\n",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nfor start in range(len(matrix[0)):\\n\\tfor end in range(start, len(matrix[0)):\\n```\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, ma: List[List[int]], t: int) -> int:\\n\\t\\t# row - m, column - n\\n        m, n = len(ma), len(ma[0])\\n\\t\\t# building prefix Sum on rows\\n        for i in range(m):\\n            for j in range(1,n):\\n                ma[i][j]+=ma[i][j-1]\\n        print(ma)\\n\\t\\t# result that we want to emit\\n        res = 0\\n\\t\\t# creating combination of i, j where 0 <= i <= j <= len(martix[0])\\n        for i in range(n):\\n            for j in range(i,n):\\n\\t\\t\\t\\t# creating map for storing previous sums\\n                c = collections.defaultdict(int)\\n                cur, c[0] = 0, 1\\n\\t\\t\\t\\t# iterating 0 to rowlength\\n\\t\\t\\t\\t# for k  = 0 \\n\\t\\t\\t\\t# only row 0\\n\\t\\t\\t\\t# for k = 1\\n\\t\\t\\t\\t# row row 0 + row 1\\n\\t\\t\\t\\t# and so on\\n                for k in range(m):\\n\\t\\t\\t\\t\\t# Calculating sum of elements in range i to j indexes of columns using prefix sum\\n                    cur += ma[k][j] - (ma[k][i - 1] if i > 0 else 0)\\n\\t\\t\\t\\t\\t# checking if sum - target is present previously or not\\n                    res += c[cur - t]\\n                    c[cur] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164702,
                "title": "prefix-sum-find-subarray-with-target-sum",
                "content": "### Prefix Sum + Subarray Target Sum\\nIt\\'s apparent that we should calculate the sum of submatrix using 2D prefix sum array, where `prefix[i][j] = prefix[i][j-1] + prefix[i-1][j] - prefix[i -1][j-1]`. Note the reason that we have to remove *prefix[i-1][j-1]* is that we add that part twice. For the sake of easy implementation, we need add one blank row on the top and one blank column on the most left side.\\nMy first idea is for each *(i, j)*, we check each cell *(x, y)* where `x <= i and y <= j` for possible submatix to get the sum to see if it equals to *target*. It denote *O(m^2n^2)* time complexity. Is there any better solution?\\nThe intuition tells me that there must be a better approach using hashtable, because it\\'s similar with two sum problem. What\\'s more, it\\'s similar with sum of subarray problem that is resolved using hashtable.\\nSo we can specifiy the length of rows each submatrix covers, then we can convert the problem to find the sum of subarray that equals to *target*. You have to treate the multiple rows to one element. \\nThen we need check each pair of rows *(r1, r2)*, which reduces complexity to *O(m^2n)*. \\n\\nalternatively, if we have much smaller *n*, then we can do same trick on columns instead of rows, which takes *O(n^2m)* time complexity.\\n```python\\n   def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        prefix = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):   \\n                prefix[i][j] = matrix[i - 1][j - 1] + prefix[i][j - 1] + prefix[i- 1][j] - prefix[i - 1][j -1]\\n \\n        count = 0\\n        for i in range(1, m + 1):\\n            for j in range(i, m + 1):\\n                counter = defaultdict(int)\\n                for k in range(n + 1):\\n                    current_sum = prefix[j][k] - prefix[i - 1][k]\\n                    count += counter[current_sum - target]\\n                    counter[current_sum] += 1\\n                    \\n        return count\\n```\\n\\n*Time Complexity*= **O(m^2n)**\\n*Space Complexity*= **O(mn)**\\n",
                "solutionTags": [],
                "code": "```python\\n   def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        prefix = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):   \\n                prefix[i][j] = matrix[i - 1][j - 1] + prefix[i][j - 1] + prefix[i- 1][j] - prefix[i - 1][j -1]\\n \\n        count = 0\\n        for i in range(1, m + 1):\\n            for j in range(i, m + 1):\\n                counter = defaultdict(int)\\n                for k in range(n + 1):\\n                    current_sum = prefix[j][k] - prefix[i - 1][k]\\n                    count += counter[current_sum - target]\\n                    counter[current_sum] += 1\\n                    \\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1163320,
                "title": "c-solution-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size(), m = matrix[0].size();\\n        \\n        for(int i = 0; i < n; i++)\\n            for(int j = 1; j < m; j++)\\n                matrix[i][j] += matrix[i][j-1];\\n        \\n        int ans = 0;\\n        unordered_map<int,int>mp;\\n        \\n        for(int i = 0; i < m; i++)\\n            for(int j = i; j < m; j++)\\n            {\\n                mp.clear();\\n                mp[0]++;\\n                int sum = 0;\\n                for(int k = 0; k < n; k++)\\n                {\\n                    int curr = matrix[k][j];\\n                    if(i > 0)\\n                        curr -= matrix[k][i-1];\\n                    sum+= curr;\\n                    ans += mp[sum - target];\\n                    mp[sum]++;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size(), m = matrix[0].size();\\n        \\n        for(int i = 0; i < n; i++)\\n            for(int j = 1; j < m; j++)\\n                matrix[i][j] += matrix[i][j-1];\\n        \\n        int ans = 0;\\n        unordered_map<int,int>mp;\\n        \\n        for(int i = 0; i < m; i++)\\n            for(int j = i; j < m; j++)\\n            {\\n                mp.clear();\\n                mp[0]++;\\n                int sum = 0;\\n                for(int k = 0; k < n; k++)\\n                {\\n                    int curr = matrix[k][j];\\n                    if(i > 0)\\n                        curr -= matrix[k][i-1];\\n                    sum+= curr;\\n                    ans += mp[sum - target];\\n                    mp[sum]++;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1163230,
                "title": "swift-find-subarray-with-target-sum",
                "content": "```swift\\n    func numSubmatrixSumTarget(_ matrix: [[Int]], _ target: Int) -> Int {\\n        let rows = matrix.endIndex\\n        let cols = matrix[0].endIndex\\n        var matrix = matrix\\n        var res = 0\\n        for i in 0..<rows {\\n            for j in 1..<cols {\\n                matrix[i][j] += matrix[i][j-1]\\n            }\\n        }\\n        for i in 0..<cols {\\n            for j in i..<cols {\\n                var dict = [0:1]\\n                var sum = 0\\n                for row in 0..<rows {\\n                    sum += matrix[row][j] - (i > 0 ? matrix[row][i-1] : 0)\\n                    res += dict[sum-target, default:0]\\n                    dict[sum, default: 0]+=1\\n                }\\n            }\\n        }\\n        return res\\n    }\\n```",
                "solutionTags": [],
                "code": "```swift\\n    func numSubmatrixSumTarget(_ matrix: [[Int]], _ target: Int) -> Int {\\n        let rows = matrix.endIndex\\n        let cols = matrix[0].endIndex\\n        var matrix = matrix\\n        var res = 0\\n        for i in 0..<rows {\\n            for j in 1..<cols {\\n                matrix[i][j] += matrix[i][j-1]\\n            }\\n        }\\n        for i in 0..<cols {\\n            for j in i..<cols {\\n                var dict = [0:1]\\n                var sum = 0\\n                for row in 0..<rows {\\n                    sum += matrix[row][j] - (i > 0 ? matrix[row][i-1] : 0)\\n                    res += dict[sum-target, default:0]\\n                    dict[sum, default: 0]+=1\\n                }\\n            }\\n        }\\n        return res\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1163043,
                "title": "c-comments-easy-to-read-and-understand-variables",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size();\\n        if(rows == 0)\\n            return 0;\\n        int cols = matrix[0].size();\\n        \\n        //First take the cumulative sum row-wise\\n        for(int row = 0; row<rows; row++) {\\n            for(int col = 1; col<cols; col++) {\\n                matrix[row][col] += matrix[row][col-1];\\n            }\\n        }\\n        \\n        //Now, you need to find the \"No. of subarrays with sum k\" in downward direction\\n\\t\\t//which is a prerequisite to this question : Please solve that first and then come to this question : Leetcode-560\\n        int result = 0;\\n        for(int startCol = 0; startCol<cols; startCol++) {\\n            \\n            for(int currCol = startCol; currCol<cols; currCol++) {\\n                //We need to find all sub matrices sum\\n                \\n                //Now comes the concept of \"No. of subarrays with sum k\"\\n                unordered_map<int, int> mp;\\n                mp[0] = 1;\\n                int sum = 0;\\n                //Go downwards row wise\\n                for(int row = 0; row<rows; row++) {\\n                    sum += matrix[row][currCol] - (startCol > 0 ? matrix[row][startCol-1] : 0);\\n                    \\n                    if(mp.count(sum-target)) {\\n                        result += mp[sum-target];\\n                    }\\n                    \\n                    mp[sum]++;\\n                    \\n                }\\n                \\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size();\\n        if(rows == 0)\\n            return 0;\\n        int cols = matrix[0].size();\\n        \\n        //First take the cumulative sum row-wise\\n        for(int row = 0; row<rows; row++) {\\n            for(int col = 1; col<cols; col++) {\\n                matrix[row][col] += matrix[row][col-1];\\n            }\\n        }\\n        \\n        //Now, you need to find the \"No. of subarrays with sum k\" in downward direction\\n\\t\\t//which is a prerequisite to this question : Please solve that first and then come to this question : Leetcode-560\\n        int result = 0;\\n        for(int startCol = 0; startCol<cols; startCol++) {\\n            \\n            for(int currCol = startCol; currCol<cols; currCol++) {\\n                //We need to find all sub matrices sum\\n                \\n                //Now comes the concept of \"No. of subarrays with sum k\"\\n                unordered_map<int, int> mp;\\n                mp[0] = 1;\\n                int sum = 0;\\n                //Go downwards row wise\\n                for(int row = 0; row<rows; row++) {\\n                    sum += matrix[row][currCol] - (startCol > 0 ? matrix[row][startCol-1] : 0);\\n                    \\n                    if(mp.count(sum-target)) {\\n                        result += mp[sum-target];\\n                    }\\n                    \\n                    mp[sum]++;\\n                    \\n                }\\n                \\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162957,
                "title": "rust-solution",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn num_submatrix_sum_target(matrix: Vec<Vec<i32>>, target: i32) -> i32 {\\n        let sums = matrix\\n            .iter()\\n            .map(|row| {\\n                row.iter()\\n                    .scan(0, |sum, &x| {\\n                        *sum += x;\\n                        Some(*sum)\\n                    })\\n                    .collect::<Vec<_>>()\\n            })\\n            .collect::<Vec<_>>();\\n        let len = matrix[0].len();\\n        let mut answer = 0;\\n        let mut hm = HashMap::new();\\n        for i in 0..len {\\n            for j in i..len {\\n                hm.clear();\\n                hm.insert(0, 1);\\n                let mut sum = 0;\\n                for row in &sums {\\n                    sum += row[j] - if i > 0 { row[i - 1] } else { 0 };\\n                    if let Some(&count) = hm.get(&(sum - target)) {\\n                        answer += count;\\n                    }\\n                    *hm.entry(sum).or_default() += 1;\\n                }\\n            }\\n        }\\n        answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn num_submatrix_sum_target(matrix: Vec<Vec<i32>>, target: i32) -> i32 {\\n        let sums = matrix\\n            .iter()\\n            .map(|row| {\\n                row.iter()\\n                    .scan(0, |sum, &x| {\\n                        *sum += x;\\n                        Some(*sum)\\n                    })\\n                    .collect::<Vec<_>>()\\n            })\\n            .collect::<Vec<_>>();\\n        let len = matrix[0].len();\\n        let mut answer = 0;\\n        let mut hm = HashMap::new();\\n        for i in 0..len {\\n            for j in i..len {\\n                hm.clear();\\n                hm.insert(0, 1);\\n                let mut sum = 0;\\n                for row in &sums {\\n                    sum += row[j] - if i > 0 { row[i - 1] } else { 0 };\\n                    if let Some(&count) = hm.get(&(sum - target)) {\\n                        answer += count;\\n                    }\\n                    *hm.entry(sum).or_default() += 1;\\n                }\\n            }\\n        }\\n        answer\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1162684,
                "title": "java-hashmap",
                "content": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0){\\n            return 0;\\n        }\\n    \\n        int rows = matrix.length;\\n        int columns = matrix[0].length;\\n        int[][] prefixSum = new int[rows+1][columns];\\n        \\n        for (int i=0; i<columns; i++) {\\n            for (int j=0; j<rows; j++) {\\n                prefixSum[j+1][i] = prefixSum[j][i] + matrix[j][i];\\n            }\\n        }\\n        \\n        int result= 0;\\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\\n        \\n        for (int i=0; i<rows; i++) {\\n            for (int j=i; j<rows; j++) {\\n                map.clear();\\n                int sum = 0;\\n                for (int k=0; k<columns; k++) {\\n                    sum += prefixSum[j+1][k] - prefixSum[i][k];\\n                    \\n                    if (sum == target) {\\n                        result++;\\n                    }\\n                    \\n                    int difference = sum - target;\\n                    if (map.containsKey(difference)) {\\n                        result+= map.get(difference);\\n                    }\\n                    \\n                    if (map.containsKey(sum)) {\\n                        map.put(sum, map.get(sum) + 1);\\n                    } else {\\n                        map.put(sum, 1);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1162626,
                "title": "number-of-submatrices-that-sum-to-target",
                "content": "The approach for the problem is that we will look for all the submatrices which are possible for a given matrix and find the sum of all the elements if it will be equal to target then we will consider it for answer and increment one to our answer.\\nwe will iterate to each cell of the given matrix and check all the possible submatrices which will start from that cell.\\nExample if we are given 2X2 matrix then all submatrices which will be passing through all four cells are:\\n(i)(0,0)->{((0,0)->(0,0)),((0,0)->(0,1)),((0,0)->(1,0)),((0,0)->(1,1))}\\n(ii)(0,1)->{((0,1)->(0,1)),((0,1)->(1,1))}\\n(iii)(1,0)->{((1,0)->(1,0)),((1,0)->(1,1))}\\n(iv)(1,1)->{((1,1)->(1,1))}\\nThe given constraints are only upto 100 so this approach will not give any TLE error. \\n\\n\\n\\n```\\nint R,C,Ans,Ans1,Ans2=0,i,j,k,l,S;\\n        vector<vector<int>> E;\\n        R=matrix.size();\\n        C=matrix[0].size();\\n        for(i=0;i<R;i++)\\n        {\\n            vector<int> F;\\n            S=0;\\n            for(j=0;j<C;j++)\\n            {\\n                S+=matrix[i][j];\\n                F.push_back(S);\\n            }\\n            E.push_back(F);\\n        }\\n        for(i=0;i<R;i++)\\n        {\\n            for(j=0;j<C;j++)\\n            {\\n                S=0;\\n                for(k=j;k<C;k++)\\n                {\\n                    if(j==0)\\n                    Ans=E[i][k];\\n                    else\\n                    Ans=E[i][k]-E[i][j-1];\\n                    if(k==(C-1))\\n                    S+=Ans; \\n                    Ans1=Ans;\\n                    for(l=i;l<R;l++)\\n                    {\\n                        if(l!=i)\\n                        {\\n                            if(j==0)\\n                            Ans1+=E[l][k];\\n                            else\\n                            Ans1+=(E[l][k]-E[l][j-1]);    \\n                        }\\n                        if(Ans1==target)\\n                            ++Ans2;\\n                    }\\n                }\\n            }\\n        }\\n        return Ans2;\\n\\t\\t",
                "solutionTags": [],
                "code": "The approach for the problem is that we will look for all the submatrices which are possible for a given matrix and find the sum of all the elements if it will be equal to target then we will consider it for answer and increment one to our answer.\\nwe will iterate to each cell of the given matrix and check all the possible submatrices which will start from that cell.\\nExample if we are given 2X2 matrix then all submatrices which will be passing through all four cells are:\\n(i)(0,0)->{((0,0)->(0,0)),((0,0)->(0,1)),((0,0)->(1,0)),((0,0)->(1,1))}\\n(ii)(0,1)->{((0,1)->(0,1)),((0,1)->(1,1))}\\n(iii)(1,0)->{((1,0)->(1,0)),((1,0)->(1,1))}\\n(iv)(1,1)->{((1,1)->(1,1))}\\nThe given constraints are only upto 100 so this approach will not give any TLE error. \\n\\n\\n\\n```\\nint R,C,Ans,Ans1,Ans2=0,i,j,k,l,S;\\n        vector<vector<int>> E;\\n        R=matrix.size();\\n        C=matrix[0].size();\\n        for(i=0;i<R;i++)\\n        {\\n            vector<int> F;\\n            S=0;\\n            for(j=0;j<C;j++)\\n            {\\n                S+=matrix[i][j];\\n                F.push_back(S);\\n            }\\n            E.push_back(F);\\n        }\\n        for(i=0;i<R;i++)\\n        {\\n            for(j=0;j<C;j++)\\n            {\\n                S=0;\\n                for(k=j;k<C;k++)\\n                {\\n                    if(j==0)\\n                    Ans=E[i][k];\\n                    else\\n                    Ans=E[i][k]-E[i][j-1];\\n                    if(k==(C-1))\\n                    S+=Ans; \\n                    Ans1=Ans;\\n                    for(l=i;l<R;l++)\\n                    {\\n                        if(l!=i)\\n                        {\\n                            if(j==0)\\n                            Ans1+=E[l][k];\\n                            else\\n                            Ans1+=(E[l][k]-E[l][j-1]);    \\n                        }\\n                        if(Ans1==target)\\n                            ++Ans2;\\n                    }\\n                }\\n            }\\n        }\\n        return Ans2;\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1162495,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& A, int t) \\n    {\\n        \\n        int i,n,m;\\n        n=A.size();\\n        if(n==0)\\n        {\\n            return 0;\\n        }\\n        m=A[0].size();\\n        if(m==0)\\n        {\\n            return 0;\\n        }\\n        \\n        int j;\\n        for(i=0;i<n;i++)\\n        {\\n            for(j=1;j<m;j++)\\n            {\\n                A[i][j]+=A[i][j-1];\\n            }\\n        }\\n        \\n        int ans=0;\\n        map<int,int>ma;\\n        \\n        for(int sc=0;sc<m;sc++)\\n        {\\n            for(int cc=sc;cc<m;cc++)\\n            {\\n                ma.clear();\\n                ma[0]=1;\\n                int sum=0;\\n                for(i=0;i<n;i++)\\n                {\\n                    sum+=A[i][cc]-(sc>0?A[i][sc-1]:0);\\n                    ans+=ma[sum-t];        \\n                    ma[sum]++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& A, int t) \\n    {\\n        \\n        int i,n,m;\\n        n=A.size();\\n        if(n==0)\\n        {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1103444,
                "title": "using-dp-java",
                "content": "class Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        \\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        \\n        int[][] sum = new int[m][n];\\n        int sumSoFar = 0;\\n        for(int i=0;i<m;i++) {\\n            sumSoFar+=matrix[i][0];\\n            sum[i][0] = sumSoFar;\\n        }\\n        sumSoFar = 0;\\n        for(int i=0;i<n;i++) {\\n            sumSoFar+=matrix[0][i];\\n            sum[0][i] = sumSoFar;\\n        }\\n        \\n        for(int i=1; i< m;i++) {\\n            for(int j=1;j < n; j++) {\\n                sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + matrix[i][j];\\n            }\\n        }\\n        int count =0;\\n        \\n        for(int i=0;i<m;i++) {\\n            for (int j=0;j<n;j++) {\\n                for(int k=i;k<m;k++) {\\n                    for (int l=j; l<n;l++) {\\n                        int tempSum = sum[k][l];\\n                        if(i>0) {\\n                            tempSum -= sum[i-1][l];\\n                        }\\n                        if(j>0) {\\n                            tempSum -= sum[k][j-1];\\n                        }\\n                        if(i>0 && j>0) {\\n                            tempSum += sum[i-1][j-1];\\n                        }\\n                        if(tempSum == target) {\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        \\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        \\n        int[][] sum = new int[m][n];\\n        int sumSoFar = 0;\\n        for(int i=0;i<m;i++) {\\n            sumSoFar+=matrix[i][0];\\n            sum[i][0] = sumSoFar;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 972074,
                "title": "java-easiest",
                "content": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int k) {\\n        int m = matrix[0].length, n = matrix.length;\\n        for(int i = 1; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                matrix[i][j] += matrix[i-1][j];\\n            }\\n        }\\n        \\n        int count = 0;\\n        for(int base = 0; base <n ; base++){\\n            \\n            for(int row = base; row<n; row++){\\n                \\n                HashMap<Integer,Integer> map = new HashMap<>();\\n                map.put(0,1);\\n                int prefixsum = 0;\\n                \\n                for(int j = 0; j<m ; j++){\\n                    \\n                    prefixsum += matrix[row][j] - (base != 0 ? matrix[base - 1][j] : 0);\\n                    count += map.getOrDefault(prefixsum - k, 0);\\n                    map.put(prefixsum, map.getOrDefault(prefixsum,0) + 1);\\n                    \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int k) {\\n        int m = matrix[0].length, n = matrix.length;\\n        for(int i = 1; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                matrix[i][j] += matrix[i-1][j];\\n            }\\n        }\\n        \\n        int count = 0;\\n        for(int base = 0; base <n ; base++){\\n            \\n            for(int row = base; row<n; row++){\\n                \\n                HashMap<Integer,Integer> map = new HashMap<>();\\n                map.put(0,1);\\n                int prefixsum = 0;\\n                \\n                for(int j = 0; j<m ; j++){\\n                    \\n                    prefixsum += matrix[row][j] - (base != 0 ? matrix[base - 1][j] : 0);\\n                    count += map.getOrDefault(prefixsum - k, 0);\\n                    map.put(prefixsum, map.getOrDefault(prefixsum,0) + 1);\\n                    \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 890948,
                "title": "python-o-r-2-c-solution-beats-98-57",
                "content": "```\\nclass Solution:\\n    \\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        rows, cols = len(matrix)+1, len(matrix[0])+1\\n        psum = [[0]*cols for _ in range(rows)]\\n        \\n        for r in range(1, rows):\\n            t = 0\\n            for c in range(1, cols):\\n                t += matrix[r-1][c-1]\\n                psum[r][c] = psum[r-1][c] + t\\n        \\n        ans = 0\\n        for r1 in range(rows-1):\\n            for r2 in range(r1+1, rows):\\n                d = {target: 1}\\n                for c in range(1, cols):\\n                    x = psum[r2][c] - psum[r1][c]\\n                    if x in d: \\n                        ans += d[x]\\n                    x += target\\n                    d[x] = d.get(x, 0) + 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        rows, cols = len(matrix)+1, len(matrix[0])+1\\n        psum = [[0]*cols for _ in range(rows)]\\n        \\n        for r in range(1, rows):\\n            t = 0\\n            for c in range(1, cols):\\n                t += matrix[r-1][c-1]\\n                psum[r][c] = psum[r-1][c] + t\\n        \\n        ans = 0\\n        for r1 in range(rows-1):\\n            for r2 in range(r1+1, rows):\\n                d = {target: 1}\\n                for c in range(1, cols):\\n                    x = psum[r2][c] - psum[r1][c]\\n                    if x in d: \\n                        ans += d[x]\\n                    x += target\\n                    d[x] = d.get(x, 0) + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 864371,
                "title": "java-noob-friendly-o-n-4-solution-accepted-beats-82-7",
                "content": "Claculates Prefix sum for all co-ordinates then goes for N^4 loop to serach for target sum.\\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int[][] sum = new int[matrix.length][matrix[0].length];\\n        \\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        sum[0][0] = matrix[0][0];\\n        for(int i=1;i<row;i++){\\n            sum[i][0] = sum[i-1][0] + matrix[i][0];\\n        }\\n        \\n        for(int j=1; j<col;j++){\\n            sum[0][j] = sum[0][j-1]+matrix[0][j];\\n        }\\n        \\n        for(int i=1;i<row;i++){\\n            for(int j=1;j<col;j++){\\n                sum[i][j] = sum[i-1][j]+sum[i][j-1]+matrix[i][j]-sum[i-1][j-1];\\n            }\\n        }\\n        \\n\\n        int res = 0;\\n        \\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                int tempSum = 0;\\n                \\n                for(int m=i;m<row;m++){\\n                    for(int n=j;n<col;n++){\\n                        tempSum = sum[m][n];\\n                        if(i>0){\\n                            tempSum -= sum[i-1][n];\\n                        }\\n                        if(j>0){\\n                            tempSum -= sum[m][j-1];\\n                        }\\n                        if(i>0 && j>0){\\n                            tempSum += sum[i-1][j-1];\\n                        }\\n                        \\n                        if(tempSum == target){\\n                            res++;        \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int[][] sum = new int[matrix.length][matrix[0].length];\\n        \\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        sum[0][0] = matrix[0][0];\\n        for(int i=1;i<row;i++){\\n            sum[i][0] = sum[i-1][0] + matrix[i][0];\\n        }\\n        \\n        for(int j=1; j<col;j++){\\n            sum[0][j] = sum[0][j-1]+matrix[0][j];\\n        }\\n        \\n        for(int i=1;i<row;i++){\\n            for(int j=1;j<col;j++){\\n                sum[i][j] = sum[i-1][j]+sum[i][j-1]+matrix[i][j]-sum[i-1][j-1];\\n            }\\n        }\\n        \\n\\n        int res = 0;\\n        \\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                int tempSum = 0;\\n                \\n                for(int m=i;m<row;m++){\\n                    for(int n=j;n<col;n++){\\n                        tempSum = sum[m][n];\\n                        if(i>0){\\n                            tempSum -= sum[i-1][n];\\n                        }\\n                        if(j>0){\\n                            tempSum -= sum[m][j-1];\\n                        }\\n                        if(i>0 && j>0){\\n                            tempSum += sum[i-1][j-1];\\n                        }\\n                        \\n                        if(tempSum == target){\\n                            res++;        \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788134,
                "title": "javascript-clean-easy-fast",
                "content": "```\\n//this question is very similar to \"Subarray Sum Equals k.\" \\n//https://leetcode.com/problems/subarray-sum-equals-k/\\n//it\\'s a 2D array variation of the original 1D problem\\nvar numSubmatrixSumTarget = function(matrix, target) {    \\n    let rlen = matrix.length\\n    let clen = matrix[0].length\\n\\t//pfsum is a 2D array that will be used to store the sum from [0][0] to [r][c] (inclusive)\\n\\t//eg pfsum[1][1] will be sum of (matrix[0][0],matrix[0][1],matrix[1][0],matrix[1][1])\\n    let pfsum = []\\n    for(let i = 0;i<rlen;i++){\\n        let t = Array(clen).fill(0)\\n        pfsum.push(t)\\n    }\\n    for(let i = 0;i<rlen;i++){\\n        let rowsum = 0\\n        for(let j=0;j<clen;j++){\\n            rowsum+=matrix[i][j]\\n            pfsum[i][j] = rowsum\\n            if(i===0)\\n                continue\\n            pfsum[i][j] += pfsum[i-1][j] \\n        }\\n    }\\n    let count = 0\\n    //prefix sum\\n    for(let jlen = 0;jlen<clen;jlen++){\\n        for(let j = 0;j+jlen<clen;j++){\\n            let pf = new Map()\\n            pf.set(0,1)\\n            for(let i = 0;i<rlen;i++){\\n                let left = 0\\n                if((j-1)>=0)\\n                    left = pfsum[i][j-1]\\n                \\n                let sum = pfsum[i][j+jlen] - left\\n                \\n                if(pf.has(sum-target))\\n                    count+=pf.get(sum-target)\\n                \\n                if(!pf.has(sum))\\n                    pf.set(sum,1)\\n                else\\n                    pf.set(sum,pf.get(sum)+1)\\n            }\\n        }\\n    }  \\n    return count\\n```",
                "solutionTags": [],
                "code": "```\\n//this question is very similar to \"Subarray Sum Equals k.\" \\n//https://leetcode.com/problems/subarray-sum-equals-k/\\n//it\\'s a 2D array variation of the original 1D problem\\nvar numSubmatrixSumTarget = function(matrix, target) {    \\n    let rlen = matrix.length\\n    let clen = matrix[0].length\\n\\t//pfsum is a 2D array that will be used to store the sum from [0][0] to [r][c] (inclusive)\\n\\t//eg pfsum[1][1] will be sum of (matrix[0][0],matrix[0][1],matrix[1][0],matrix[1][1])\\n    let pfsum = []\\n    for(let i = 0;i<rlen;i++){\\n        let t = Array(clen).fill(0)\\n        pfsum.push(t)\\n    }\\n    for(let i = 0;i<rlen;i++){\\n        let rowsum = 0\\n        for(let j=0;j<clen;j++){\\n            rowsum+=matrix[i][j]\\n            pfsum[i][j] = rowsum\\n            if(i===0)\\n                continue\\n            pfsum[i][j] += pfsum[i-1][j] \\n        }\\n    }\\n    let count = 0\\n    //prefix sum\\n    for(let jlen = 0;jlen<clen;jlen++){\\n        for(let j = 0;j+jlen<clen;j++){\\n            let pf = new Map()\\n            pf.set(0,1)\\n            for(let i = 0;i<rlen;i++){\\n                let left = 0\\n                if((j-1)>=0)\\n                    left = pfsum[i][j-1]\\n                \\n                let sum = pfsum[i][j+jlen] - left\\n                \\n                if(pf.has(sum-target))\\n                    count+=pf.get(sum-target)\\n                \\n                if(!pf.has(sum))\\n                    pf.set(sum,1)\\n                else\\n                    pf.set(sum,pf.get(sum)+1)\\n            }\\n        }\\n    }  \\n    return count\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 744453,
                "title": "clear-java-solution",
                "content": "2 steps\\n1. compress the matrix to array \\n2. same as solve problem 560\\n\\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length, n = matrix[0].length;\\n        int cnt = 0;\\n\\t\\t//step1: compress the matrix to array for by row. \\n        for (int i = 0; i < m; i++){\\n            int[] tmp = new int[n];\\n            for (int j = i; j < m; j++){\\n                for (int l = 0; l < n; l++){\\n                    tmp[l] += matrix[j][l];\\n                }\\n                cnt += helper(tmp, target);\\n            }\\n        }\\n        return cnt;\\n    }\\n\\t\\n    //this is same as solution for problem 560\\n    private int helper(int[] nums, int k){\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int[] preSum = new int[nums.length + 1];\\n        for (int i = 0; i < nums.length; i++){\\n            preSum[i + 1] = preSum[i] + nums[i];\\n        }\\n        int cnt = 0;\\n        for (int n : preSum){\\n            if (map.containsKey(n)){\\n                cnt += map.get(n);\\n            }\\n            map.put(n + k, map.getOrDefault(n + k, 0) + 1);\\n        }\\n        return cnt;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length, n = matrix[0].length;\\n        int cnt = 0;\\n\\t\\t//step1: compress the matrix to array for by row. \\n        for (int i = 0; i < m; i++){\\n            int[] tmp = new int[n];\\n            for (int j = i; j < m; j++){\\n                for (int l = 0; l < n; l++){\\n                    tmp[l] += matrix[j][l];\\n                }\\n                cnt += helper(tmp, target);\\n            }\\n        }\\n        return cnt;\\n    }\\n\\t\\n    //this is same as solution for problem 560\\n    private int helper(int[] nums, int k){\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int[] preSum = new int[nums.length + 1];\\n        for (int i = 0; i < nums.length; i++){\\n            preSum[i + 1] = preSum[i] + nums[i];\\n        }\\n        int cnt = 0;\\n        for (int n : preSum){\\n            if (map.containsKey(n)){\\n                cnt += map.get(n);\\n            }\\n            map.put(n + k, map.getOrDefault(n + k, 0) + 1);\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738572,
                "title": "too-strict-threshold-for-c-submission",
                "content": "I have first tried to slove the problem in c++. The time complexity of my code is O(|R|^2*|C|), but I got \"\\tTime Limit Exceeded\" error. \\nI then translated my c++ code to java code word by word, they are exactly the same. But this time my java code pass the OJ. \\nI think the threshold for c++ submission is too strict. It\\'s unfair. \\n# My c++ code:\\n```\\nstatic int _ = [](){\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    cout.tie(NULL);\\n    return 0;\\n}();\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int dp[300] = {0};\\n        int ret = 0;\\n        unordered_map<int,int> m;\\n        for(int i = 0;i<matrix.size();i++){\\n            for(int j = i;j<matrix.size();j++){\\n                int sum = 0;\\n                m.clear();\\n                for(int k = 0;k<matrix[0].size();k++) {\\n                    dp[k] += matrix[j][k];\\n                    sum += dp[k];\\n                    if(sum == target) {\\n                        ret++;\\n                    }\\n                    ret += m[sum-target];\\n                    m[sum]++;\\n                }\\n            }\\n            memset(dp,0,sizeof(dp));\\n        }\\n        return ret;\\n    }\\n};\\n```\\n\\n# My java code: \\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int []dp = new int[300];\\n        HashMap<Integer,Integer> m = new HashMap();\\n        int ret = 0;\\n        for(int i = 0;i<matrix.length;i++){\\n            for(int j = i;j<matrix.length;j++){\\n                int sum = 0;\\n                m.clear();\\n                for(int k = 0;k<matrix[0].length;k++) {\\n                    dp[k] += matrix[j][k];\\n                    sum += dp[k];\\n                    if(sum == target) {\\n                        ret++;\\n                    }\\n                    ret += m.getOrDefault(sum-target,0);\\n                    m.merge(sum,1,Integer::sum);\\n                }\\n            }\\n            dp = new int[300];\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstatic int _ = [](){\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    cout.tie(NULL);\\n    return 0;\\n}();\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int dp[300] = {0};\\n        int ret = 0;\\n        unordered_map<int,int> m;\\n        for(int i = 0;i<matrix.size();i++){\\n            for(int j = i;j<matrix.size();j++){\\n                int sum = 0;\\n                m.clear();\\n                for(int k = 0;k<matrix[0].size();k++) {\\n                    dp[k] += matrix[j][k];\\n                    sum += dp[k];\\n                    if(sum == target) {\\n                        ret++;\\n                    }\\n                    ret += m[sum-target];\\n                    m[sum]++;\\n                }\\n            }\\n            memset(dp,0,sizeof(dp));\\n        }\\n        return ret;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int []dp = new int[300];\\n        HashMap<Integer,Integer> m = new HashMap();\\n        int ret = 0;\\n        for(int i = 0;i<matrix.length;i++){\\n            for(int j = i;j<matrix.length;j++){\\n                int sum = 0;\\n                m.clear();\\n                for(int k = 0;k<matrix[0].length;k++) {\\n                    dp[k] += matrix[j][k];\\n                    sum += dp[k];\\n                    if(sum == target) {\\n                        ret++;\\n                    }\\n                    ret += m.getOrDefault(sum-target,0);\\n                    m.merge(sum,1,Integer::sum);\\n                }\\n            }\\n            dp = new int[300];\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 633989,
                "title": "python-dict-92-vs-defaultdict-51",
                "content": "I was playing with python `dict` and `defaultdict`. It apears that `dict` is lot faster than `defaultdict` when the size of the dictionary is relatively small. But over a large dictionary `defaultdict` beats `dict`. In this particular problem the datasize favors `dict`.\\n1. Below is the `defaultdict` solution. It looks cleaner. Beats 51%.\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix, target):\\n        r, c = len(matrix), len(matrix[0])\\n        ans, bsum = 0, [ [0 for j in range(c+1)] for i in range(r+1)]\\n        \\n        for i in range(r):\\n            for j in range(c):\\n                bsum[i+1][j+1] = bsum[i+1][j] + bsum[i][j+1] - bsum[i][j] + matrix[i][j]\\n\\n        for i in range(c):\\n            for j in range(i+1,c+1):\\n                dp = defaultdict(int)\\n                dp[0]=1\\n                for k in range(1,r+1):\\n                    val = bsum[k][j] - bsum[k][i]\\n                    ans += dp[val-target]\\n                    dp[val] += 1\\n        return ans\\n```\\n2. Then below is the `dict` based solution that beats 92%.\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix, target):\\n        r, c = len(matrix), len(matrix[0])\\n        ans, bsum = 0, [ [0 for j in range(c+1)] for i in range(r+1)]\\n        \\n        for i in range(r):\\n            for j in range(c):\\n                bsum[i+1][j+1] = bsum[i+1][j] + bsum[i][j+1] - bsum[i][j] + matrix[i][j]\\n\\n        for i in range(c):\\n            for j in range(i+1,c+1):\\n                dp = {0:1}\\n                for k in range(1,r+1):\\n                    val = bsum[k][j] - bsum[k][i]\\n                    ans += dp.get(val-target,0)\\n                    \\n                    if val in dp:\\n                        dp[val] += 1\\n                    else:\\n                        dp[val]=1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix, target):\\n        r, c = len(matrix), len(matrix[0])\\n        ans, bsum = 0, [ [0 for j in range(c+1)] for i in range(r+1)]\\n        \\n        for i in range(r):\\n            for j in range(c):\\n                bsum[i+1][j+1] = bsum[i+1][j] + bsum[i][j+1] - bsum[i][j] + matrix[i][j]\\n\\n        for i in range(c):\\n            for j in range(i+1,c+1):\\n                dp = defaultdict(int)\\n                dp[0]=1\\n                for k in range(1,r+1):\\n                    val = bsum[k][j] - bsum[k][i]\\n                    ans += dp[val-target]\\n                    dp[val] += 1\\n        return ans\\n```\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix, target):\\n        r, c = len(matrix), len(matrix[0])\\n        ans, bsum = 0, [ [0 for j in range(c+1)] for i in range(r+1)]\\n        \\n        for i in range(r):\\n            for j in range(c):\\n                bsum[i+1][j+1] = bsum[i+1][j] + bsum[i][j+1] - bsum[i][j] + matrix[i][j]\\n\\n        for i in range(c):\\n            for j in range(i+1,c+1):\\n                dp = {0:1}\\n                for k in range(1,r+1):\\n                    val = bsum[k][j] - bsum[k][i]\\n                    ans += dp.get(val-target,0)\\n                    \\n                    if val in dp:\\n                        dp[val] += 1\\n                    else:\\n                        dp[val]=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 560881,
                "title": "java-accepted-simple-but-slow",
                "content": "The idea is to flatten one dimension of the array, by obtaining sums of all numbers between each set of two columns.\\n\\nWe can then iterate over every possible range of these sums, to find the target sum.\\n\\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int result = 0;\\n        \\n        int rows = matrix.length;\\n        if (rows == 0) return 0;\\n        \\n        int cols = matrix[0].length;\\n        if (cols == 0) return 0;\\n        \\n        for (int ileft = 0; ileft < cols; ileft++) {\\n            // Contains sum of numbers between ileft and iright\\n            int[] rowSums = new int[rows];\\n                \\n            for (int iright = ileft; iright < cols; iright++) {\\n                \\n                for (int row = 0; row < rows; row++) {\\n                    rowSums[row] += matrix[row][iright];\\n                }\\n                \\n                // Brute force: find all ranges in rowSums that add up to target\\n                for (int isum = 0; isum < rowSums.length; isum++) {\\n                \\n                    int curSum = 0; \\n                    for (int jsum = isum; jsum < rowSums.length; jsum++) {\\n                        curSum += rowSums[jsum];\\n                        \\n                        if (curSum == target) {\\n                            result++;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int result = 0;\\n        \\n        int rows = matrix.length;\\n        if (rows == 0) return 0;\\n        \\n        int cols = matrix[0].length;\\n        if (cols == 0) return 0;\\n        \\n        for (int ileft = 0; ileft < cols; ileft++) {\\n            // Contains sum of numbers between ileft and iright\\n            int[] rowSums = new int[rows];\\n                \\n            for (int iright = ileft; iright < cols; iright++) {\\n                \\n                for (int row = 0; row < rows; row++) {\\n                    rowSums[row] += matrix[row][iright];\\n                }\\n                \\n                // Brute force: find all ranges in rowSums that add up to target\\n                for (int isum = 0; isum < rowSums.length; isum++) {\\n                \\n                    int curSum = 0; \\n                    for (int jsum = isum; jsum < rowSums.length; jsum++) {\\n                        curSum += rowSums[jsum];\\n                        \\n                        if (curSum == target) {\\n                            result++;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539506,
                "title": "python3-kadane-algorithm-time-o-row-2-c-space-o-c-kind-of-similar-to-problem363",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        # Kind of similar to 363\\n        # kadane algorithm: find all possible sum in a matrix/rectangle\\n        # Time: O(row^2*c). Space: O(c)\\n        res = 0\\n        for l in range(len(matrix[0])):\\n            col = [0] * len(matrix)\\n            for r in range(l, len(matrix[0])):\\n                for i in range(len(matrix)):\\n                    col[i] += matrix[i][r]\\n                cumu_sum = defaultdict(int) # Need to memorize the number.\\n                sums = 0\\n                for i, n in enumerate(col):\\n                    sums += n\\n                    if sums == target: # If itself is target\\n                        res += 1\\n                    if sums - target in cumu_sum: # Range sum is target\\n                        res += cumu_sum[sums - target] # Here add up the number\\n                    cumu_sum[sums] += 1 # Update after two \\'if\\'\\n        return res\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        # Kind of similar to 363\\n        # kadane algorithm: find all possible sum in a matrix/rectangle\\n        # Time: O(row^2*c). Space: O(c)\\n        res = 0\\n        for l in range(len(matrix[0])):\\n            col = [0] * len(matrix)\\n            for r in range(l, len(matrix[0])):\\n                for i in range(len(matrix)):\\n                    col[i] += matrix[i][r]\\n                cumu_sum = defaultdict(int) # Need to memorize the number.\\n                sums = 0\\n                for i, n in enumerate(col):\\n                    sums += n\\n                    if sums == target: # If itself is target\\n                        res += 1\\n                    if sums - target in cumu_sum: # Range sum is target\\n                        res += cumu_sum[sums - target] # Here add up the number\\n                    cumu_sum[sums] += 1 # Update after two \\'if\\'\\n        return res\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 519657,
                "title": "c-3-2s-99-solution-using-prefix-sum",
                "content": "This solution is based on calculating contiguous array with `sum = k` for an array with possible negative numbers in `O(n)` time. This is problem 560 on LC. \\n\\nOnce you solve that problem, this one is straight forward. We iterate through all possible `x` and `x\\'`, using cumulative sum, and apply the algorithm from problem 560 to get all subarrays `y`, `y\\'` in `O(n)` time, which leads to a total run-time of `O(R*R*C)`, which is `O(N^3)`.  \\n\\nOnly 1 array is needed, since we only need the cumulative sum, so after calculating all submatrices of dimensions `{x, x\\', *, *}`, we can get cumulative sum for `{x, x\\'+1, *, *}` by just adding `matrix[x\\'+1]` onto the previous cumulative matrix.\\n\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        size_t R = matrix.size(), C = matrix[0].size();\\n        \\n        vector<int> rowAcc;\\n        unordered_map<int, int> m;\\n        int sum = 0, count = 0;\\n        for(int r = 0; r < R; ++r) {\\n            rowAcc = matrix[r];\\n            for(int i = r; i < R; ++i) {\\n                m.clear();\\n                m[0] = 1;\\n                sum = 0;\\n                for(int j = 0; j < C; ++j) {\\n                    sum += rowAcc[j];\\n                    if(m.count(sum - target)) count += m[sum-target];\\n                    ++m[sum];\\n                    if(i < R-1) rowAcc[j] += matrix[i+1][j];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        size_t R = matrix.size(), C = matrix[0].size();\\n        \\n        vector<int> rowAcc;\\n        unordered_map<int, int> m;\\n        int sum = 0, count = 0;\\n        for(int r = 0; r < R; ++r) {\\n            rowAcc = matrix[r];\\n            for(int i = r; i < R; ++i) {\\n                m.clear();\\n                m[0] = 1;\\n                sum = 0;\\n                for(int j = 0; j < C; ++j) {\\n                    sum += rowAcc[j];\\n                    if(m.count(sum - target)) count += m[sum-target];\\n                    ++m[sum];\\n                    if(i < R-1) rowAcc[j] += matrix[i+1][j];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 505938,
                "title": "c-solution",
                "content": "```\\n    int numSubmatrixSumTarget(vector<vector<int>>& m, int t) {\\n        for(auto & r : m) for(int i = 1; i < m[0].size(); i++) r[i] += r[i-1];\\n        \\n        int res = 0;\\n        for(int c1 = 0; c1 < m[0].size(); c1++) {\\n            for(int c2 = c1; c2 < m[0].size(); c2++) {\\n                unordered_map<int, int> map;\\n                map[0] = 1;\\n                int preSum = 0;\\n                for(int k = 0; k < m.size(); k++) {\\n                    int v = m[k][c2] - (c1 == 0 ? 0 : m[k][c1-1]);\\n                    preSum += v;\\n                    res += map[preSum-t];\\n                    map[preSum]++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int numSubmatrixSumTarget(vector<vector<int>>& m, int t) {\\n        for(auto & r : m) for(int i = 1; i < m[0].size(); i++) r[i] += r[i-1];\\n        \\n        int res = 0;\\n        for(int c1 = 0; c1 < m[0].size(); c1++) {\\n            for(int c2 = c1; c2 < m[0].size(); c2++) {\\n                unordered_map<int, int> map;\\n                map[0] = 1;\\n                int preSum = 0;\\n                for(int k = 0; k < m.size(); k++) {\\n                    int v = m[k][c2] - (c1 == 0 ? 0 : m[k][c1-1]);\\n                    preSum += v;\\n                    res += map[preSum-t];\\n                    map[preSum]++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502796,
                "title": "c-matrix-compression-3992ms-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint helper(vector<int>& temp,int target){\\n\\t\\t\\tint n=temp.size();\\n\\t\\t\\tunordered_map<int,int> m;\\n\\t\\t\\tm[0]=1;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tint prefixSum=0;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tprefixSum+=temp[i];\\n\\t\\t\\t\\tif(m.count(prefixSum-target)){\\n\\t\\t\\t\\t\\tans+=m[prefixSum-target];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tm[prefixSum]+=1;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tint numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n\\t\\t\\tint res=0;\\n\\t\\t\\tint m=matrix.size();\\n\\t\\t\\tint n=matrix[0].size();\\n\\t\\t\\tfor(int i=0;i<m;i++){\\n\\t\\t\\t\\tvector<int> temp(n,0);\\n\\t\\t\\t\\tfor(int j=i;j<m;j++){\\n\\t\\t\\t\\t\\tfor(int k=0;k<n;k++){\\n\\t\\t\\t\\t\\t\\ttemp[k]+=matrix[j][k];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t res+=helper(temp,target);\\n\\t\\t\\t\\t}    \\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint helper(vector<int>& temp,int target){\\n\\t\\t\\tint n=temp.size();\\n\\t\\t\\tunordered_map<int,int> m;\\n\\t\\t\\tm[0]=1;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tint prefixSum=0;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tprefixSum+=temp[i];\\n\\t\\t\\t\\tif(m.count(prefixSum-target)){\\n\\t\\t\\t\\t\\tans+=m[prefixSum-target];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565291,
                "content": [
                    {
                        "username": "mhelvens",
                        "content": "![image](https://assets.leetcode.com/users/mhelvens/image_1563627416.png)\\n"
                    },
                    {
                        "username": "crutch_user",
                        "content": "Generalize the this problem to K dimensions.\\n- 1-D: Given an array length n and number T. Count number of subarrays with sum T.\\nSolve by hash table and prefix sums with O(n) time complexity.\\n- 2-D: Given an square matrix (nxn) and number T.  Count number of submatrixes with sum T.\\nCompute prefix sums for all rows - `O(n^2)`. For all columns i and j (i <= j): translate (compress) submatrix  between this columns (inclusive) to array (all elements is sum of row this submatrix) with length n by prefix sums - `O(n)`. Now this is 1D case. Solve by `O(n)` for all (i, j).\\nTotal time complexity: `O(n^2 + n^2 * n) = O(n^3)`.\\n- 3-D: Given an cube (nxnxn) and number T. Count number of subcubes with sum T. \\nSuggest a solution: Cube is array of layers (matrixes). Compute prefix sums for all rows in layers  - `O(n^3)`. For all axes i and j (i <= j): given subcube between this axes (inclusive). Translate (compress) layer of this subcube to array (all elements is sum of row this submatrix) with length n by prefix sums - `O(n^2)`. This arrays form a matrix. Now this is 2D case. Solve by `O(n^3)` for all (i, j).\\nTotal time complexity: `O(n^3 + n^2 * n^3) = O(n^5)`.\\n- K-D: Given an hypercube with k dimensions (nxnxn...xn) and number T. Count number of subhypercubes with sum T.\\nSuggest a solution: use decreasing dimension. Like in cases above we slice hypercube by two axes and compress subhypercube beetween this axes (inclusive) two hypercube with dimension less by one. Use slice\\\\compress while we not giving a 1-D case. Proof this by mathematical induction?\\nTotal time complexity: `O(n^k + n^(1+2*(k-1))) = O(n^(1+2*(k-1)))`.\\n\\nWhat do you think about reasoning above? I would like to see this problem on hypercubes on LeetCode."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Please never add this thx <3 ;P"
                    },
                    {
                        "username": "Maristie",
                        "content": "I\\'ll just give several possible variants of this problem if you\\'re interested.\\n1. Decide whether there\\'s a submatrix summing to a target\\n2. Count submatrices summing to a target (exactly this one)\\n3. Decide whether there\\'s a submatrix whose sum is no larger than K\\n4. Count submatrices whose sum is no larger than K\\n5. Count submatrices whose sum is between `[k1, k2]`\\n6. Decide the maximum submatrix sum which is no larger than K ([363. Max Sum of Rectangle No Larger Than K](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/))\\n7. Decide the maximum number of elements in a submatrix whose sum is no larger than K"
                    },
                    {
                        "username": "NEU20133823",
                        "content": "![image](https://assets.leetcode.com/users/neu20133823/image_1559448784.png)\\nThe custom testcase was given from my failed submission before. I spent more than 30 minutes debugging it and still could not pass. Then I submitted near the final second of the contest and got AC??? Why?\\nMy solution is O(N^3)."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Asked in interview of MediaNet."
                    },
                    {
                        "username": "CodeMore19",
                        "content": "which college? for intern or placement??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Any similar easy problem to solve before this? I\\'m kind of not able to solve this."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "https://leetcode.com/problems/subarray-sum-equals-k/"
                    }
                ]
            },
            {
                "id": 1575831,
                "content": [
                    {
                        "username": "mhelvens",
                        "content": "![image](https://assets.leetcode.com/users/mhelvens/image_1563627416.png)\\n"
                    },
                    {
                        "username": "crutch_user",
                        "content": "Generalize the this problem to K dimensions.\\n- 1-D: Given an array length n and number T. Count number of subarrays with sum T.\\nSolve by hash table and prefix sums with O(n) time complexity.\\n- 2-D: Given an square matrix (nxn) and number T.  Count number of submatrixes with sum T.\\nCompute prefix sums for all rows - `O(n^2)`. For all columns i and j (i <= j): translate (compress) submatrix  between this columns (inclusive) to array (all elements is sum of row this submatrix) with length n by prefix sums - `O(n)`. Now this is 1D case. Solve by `O(n)` for all (i, j).\\nTotal time complexity: `O(n^2 + n^2 * n) = O(n^3)`.\\n- 3-D: Given an cube (nxnxn) and number T. Count number of subcubes with sum T. \\nSuggest a solution: Cube is array of layers (matrixes). Compute prefix sums for all rows in layers  - `O(n^3)`. For all axes i and j (i <= j): given subcube between this axes (inclusive). Translate (compress) layer of this subcube to array (all elements is sum of row this submatrix) with length n by prefix sums - `O(n^2)`. This arrays form a matrix. Now this is 2D case. Solve by `O(n^3)` for all (i, j).\\nTotal time complexity: `O(n^3 + n^2 * n^3) = O(n^5)`.\\n- K-D: Given an hypercube with k dimensions (nxnxn...xn) and number T. Count number of subhypercubes with sum T.\\nSuggest a solution: use decreasing dimension. Like in cases above we slice hypercube by two axes and compress subhypercube beetween this axes (inclusive) two hypercube with dimension less by one. Use slice\\\\compress while we not giving a 1-D case. Proof this by mathematical induction?\\nTotal time complexity: `O(n^k + n^(1+2*(k-1))) = O(n^(1+2*(k-1)))`.\\n\\nWhat do you think about reasoning above? I would like to see this problem on hypercubes on LeetCode."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Please never add this thx <3 ;P"
                    },
                    {
                        "username": "Maristie",
                        "content": "I\\'ll just give several possible variants of this problem if you\\'re interested.\\n1. Decide whether there\\'s a submatrix summing to a target\\n2. Count submatrices summing to a target (exactly this one)\\n3. Decide whether there\\'s a submatrix whose sum is no larger than K\\n4. Count submatrices whose sum is no larger than K\\n5. Count submatrices whose sum is between `[k1, k2]`\\n6. Decide the maximum submatrix sum which is no larger than K ([363. Max Sum of Rectangle No Larger Than K](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/))\\n7. Decide the maximum number of elements in a submatrix whose sum is no larger than K"
                    },
                    {
                        "username": "NEU20133823",
                        "content": "![image](https://assets.leetcode.com/users/neu20133823/image_1559448784.png)\\nThe custom testcase was given from my failed submission before. I spent more than 30 minutes debugging it and still could not pass. Then I submitted near the final second of the contest and got AC??? Why?\\nMy solution is O(N^3)."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Asked in interview of MediaNet."
                    },
                    {
                        "username": "CodeMore19",
                        "content": "which college? for intern or placement??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Any similar easy problem to solve before this? I\\'m kind of not able to solve this."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "https://leetcode.com/problems/subarray-sum-equals-k/"
                    }
                ]
            },
            {
                "id": 1570428,
                "content": [
                    {
                        "username": "mhelvens",
                        "content": "![image](https://assets.leetcode.com/users/mhelvens/image_1563627416.png)\\n"
                    },
                    {
                        "username": "crutch_user",
                        "content": "Generalize the this problem to K dimensions.\\n- 1-D: Given an array length n and number T. Count number of subarrays with sum T.\\nSolve by hash table and prefix sums with O(n) time complexity.\\n- 2-D: Given an square matrix (nxn) and number T.  Count number of submatrixes with sum T.\\nCompute prefix sums for all rows - `O(n^2)`. For all columns i and j (i <= j): translate (compress) submatrix  between this columns (inclusive) to array (all elements is sum of row this submatrix) with length n by prefix sums - `O(n)`. Now this is 1D case. Solve by `O(n)` for all (i, j).\\nTotal time complexity: `O(n^2 + n^2 * n) = O(n^3)`.\\n- 3-D: Given an cube (nxnxn) and number T. Count number of subcubes with sum T. \\nSuggest a solution: Cube is array of layers (matrixes). Compute prefix sums for all rows in layers  - `O(n^3)`. For all axes i and j (i <= j): given subcube between this axes (inclusive). Translate (compress) layer of this subcube to array (all elements is sum of row this submatrix) with length n by prefix sums - `O(n^2)`. This arrays form a matrix. Now this is 2D case. Solve by `O(n^3)` for all (i, j).\\nTotal time complexity: `O(n^3 + n^2 * n^3) = O(n^5)`.\\n- K-D: Given an hypercube with k dimensions (nxnxn...xn) and number T. Count number of subhypercubes with sum T.\\nSuggest a solution: use decreasing dimension. Like in cases above we slice hypercube by two axes and compress subhypercube beetween this axes (inclusive) two hypercube with dimension less by one. Use slice\\\\compress while we not giving a 1-D case. Proof this by mathematical induction?\\nTotal time complexity: `O(n^k + n^(1+2*(k-1))) = O(n^(1+2*(k-1)))`.\\n\\nWhat do you think about reasoning above? I would like to see this problem on hypercubes on LeetCode."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Please never add this thx <3 ;P"
                    },
                    {
                        "username": "Maristie",
                        "content": "I\\'ll just give several possible variants of this problem if you\\'re interested.\\n1. Decide whether there\\'s a submatrix summing to a target\\n2. Count submatrices summing to a target (exactly this one)\\n3. Decide whether there\\'s a submatrix whose sum is no larger than K\\n4. Count submatrices whose sum is no larger than K\\n5. Count submatrices whose sum is between `[k1, k2]`\\n6. Decide the maximum submatrix sum which is no larger than K ([363. Max Sum of Rectangle No Larger Than K](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/))\\n7. Decide the maximum number of elements in a submatrix whose sum is no larger than K"
                    },
                    {
                        "username": "NEU20133823",
                        "content": "![image](https://assets.leetcode.com/users/neu20133823/image_1559448784.png)\\nThe custom testcase was given from my failed submission before. I spent more than 30 minutes debugging it and still could not pass. Then I submitted near the final second of the contest and got AC??? Why?\\nMy solution is O(N^3)."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Asked in interview of MediaNet."
                    },
                    {
                        "username": "CodeMore19",
                        "content": "which college? for intern or placement??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Any similar easy problem to solve before this? I\\'m kind of not able to solve this."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "https://leetcode.com/problems/subarray-sum-equals-k/"
                    }
                ]
            },
            {
                "id": 1572723,
                "content": [
                    {
                        "username": "mhelvens",
                        "content": "![image](https://assets.leetcode.com/users/mhelvens/image_1563627416.png)\\n"
                    },
                    {
                        "username": "crutch_user",
                        "content": "Generalize the this problem to K dimensions.\\n- 1-D: Given an array length n and number T. Count number of subarrays with sum T.\\nSolve by hash table and prefix sums with O(n) time complexity.\\n- 2-D: Given an square matrix (nxn) and number T.  Count number of submatrixes with sum T.\\nCompute prefix sums for all rows - `O(n^2)`. For all columns i and j (i <= j): translate (compress) submatrix  between this columns (inclusive) to array (all elements is sum of row this submatrix) with length n by prefix sums - `O(n)`. Now this is 1D case. Solve by `O(n)` for all (i, j).\\nTotal time complexity: `O(n^2 + n^2 * n) = O(n^3)`.\\n- 3-D: Given an cube (nxnxn) and number T. Count number of subcubes with sum T. \\nSuggest a solution: Cube is array of layers (matrixes). Compute prefix sums for all rows in layers  - `O(n^3)`. For all axes i and j (i <= j): given subcube between this axes (inclusive). Translate (compress) layer of this subcube to array (all elements is sum of row this submatrix) with length n by prefix sums - `O(n^2)`. This arrays form a matrix. Now this is 2D case. Solve by `O(n^3)` for all (i, j).\\nTotal time complexity: `O(n^3 + n^2 * n^3) = O(n^5)`.\\n- K-D: Given an hypercube with k dimensions (nxnxn...xn) and number T. Count number of subhypercubes with sum T.\\nSuggest a solution: use decreasing dimension. Like in cases above we slice hypercube by two axes and compress subhypercube beetween this axes (inclusive) two hypercube with dimension less by one. Use slice\\\\compress while we not giving a 1-D case. Proof this by mathematical induction?\\nTotal time complexity: `O(n^k + n^(1+2*(k-1))) = O(n^(1+2*(k-1)))`.\\n\\nWhat do you think about reasoning above? I would like to see this problem on hypercubes on LeetCode."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Please never add this thx <3 ;P"
                    },
                    {
                        "username": "Maristie",
                        "content": "I\\'ll just give several possible variants of this problem if you\\'re interested.\\n1. Decide whether there\\'s a submatrix summing to a target\\n2. Count submatrices summing to a target (exactly this one)\\n3. Decide whether there\\'s a submatrix whose sum is no larger than K\\n4. Count submatrices whose sum is no larger than K\\n5. Count submatrices whose sum is between `[k1, k2]`\\n6. Decide the maximum submatrix sum which is no larger than K ([363. Max Sum of Rectangle No Larger Than K](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/))\\n7. Decide the maximum number of elements in a submatrix whose sum is no larger than K"
                    },
                    {
                        "username": "NEU20133823",
                        "content": "![image](https://assets.leetcode.com/users/neu20133823/image_1559448784.png)\\nThe custom testcase was given from my failed submission before. I spent more than 30 minutes debugging it and still could not pass. Then I submitted near the final second of the contest and got AC??? Why?\\nMy solution is O(N^3)."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Asked in interview of MediaNet."
                    },
                    {
                        "username": "CodeMore19",
                        "content": "which college? for intern or placement??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Any similar easy problem to solve before this? I\\'m kind of not able to solve this."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "https://leetcode.com/problems/subarray-sum-equals-k/"
                    }
                ]
            },
            {
                "id": 1971276,
                "content": [
                    {
                        "username": "mhelvens",
                        "content": "![image](https://assets.leetcode.com/users/mhelvens/image_1563627416.png)\\n"
                    },
                    {
                        "username": "crutch_user",
                        "content": "Generalize the this problem to K dimensions.\\n- 1-D: Given an array length n and number T. Count number of subarrays with sum T.\\nSolve by hash table and prefix sums with O(n) time complexity.\\n- 2-D: Given an square matrix (nxn) and number T.  Count number of submatrixes with sum T.\\nCompute prefix sums for all rows - `O(n^2)`. For all columns i and j (i <= j): translate (compress) submatrix  between this columns (inclusive) to array (all elements is sum of row this submatrix) with length n by prefix sums - `O(n)`. Now this is 1D case. Solve by `O(n)` for all (i, j).\\nTotal time complexity: `O(n^2 + n^2 * n) = O(n^3)`.\\n- 3-D: Given an cube (nxnxn) and number T. Count number of subcubes with sum T. \\nSuggest a solution: Cube is array of layers (matrixes). Compute prefix sums for all rows in layers  - `O(n^3)`. For all axes i and j (i <= j): given subcube between this axes (inclusive). Translate (compress) layer of this subcube to array (all elements is sum of row this submatrix) with length n by prefix sums - `O(n^2)`. This arrays form a matrix. Now this is 2D case. Solve by `O(n^3)` for all (i, j).\\nTotal time complexity: `O(n^3 + n^2 * n^3) = O(n^5)`.\\n- K-D: Given an hypercube with k dimensions (nxnxn...xn) and number T. Count number of subhypercubes with sum T.\\nSuggest a solution: use decreasing dimension. Like in cases above we slice hypercube by two axes and compress subhypercube beetween this axes (inclusive) two hypercube with dimension less by one. Use slice\\\\compress while we not giving a 1-D case. Proof this by mathematical induction?\\nTotal time complexity: `O(n^k + n^(1+2*(k-1))) = O(n^(1+2*(k-1)))`.\\n\\nWhat do you think about reasoning above? I would like to see this problem on hypercubes on LeetCode."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Please never add this thx <3 ;P"
                    },
                    {
                        "username": "Maristie",
                        "content": "I\\'ll just give several possible variants of this problem if you\\'re interested.\\n1. Decide whether there\\'s a submatrix summing to a target\\n2. Count submatrices summing to a target (exactly this one)\\n3. Decide whether there\\'s a submatrix whose sum is no larger than K\\n4. Count submatrices whose sum is no larger than K\\n5. Count submatrices whose sum is between `[k1, k2]`\\n6. Decide the maximum submatrix sum which is no larger than K ([363. Max Sum of Rectangle No Larger Than K](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/))\\n7. Decide the maximum number of elements in a submatrix whose sum is no larger than K"
                    },
                    {
                        "username": "NEU20133823",
                        "content": "![image](https://assets.leetcode.com/users/neu20133823/image_1559448784.png)\\nThe custom testcase was given from my failed submission before. I spent more than 30 minutes debugging it and still could not pass. Then I submitted near the final second of the contest and got AC??? Why?\\nMy solution is O(N^3)."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Asked in interview of MediaNet."
                    },
                    {
                        "username": "CodeMore19",
                        "content": "which college? for intern or placement??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Any similar easy problem to solve before this? I\\'m kind of not able to solve this."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "https://leetcode.com/problems/subarray-sum-equals-k/"
                    }
                ]
            },
            {
                "id": 2050719,
                "content": [
                    {
                        "username": "mhelvens",
                        "content": "![image](https://assets.leetcode.com/users/mhelvens/image_1563627416.png)\\n"
                    },
                    {
                        "username": "crutch_user",
                        "content": "Generalize the this problem to K dimensions.\\n- 1-D: Given an array length n and number T. Count number of subarrays with sum T.\\nSolve by hash table and prefix sums with O(n) time complexity.\\n- 2-D: Given an square matrix (nxn) and number T.  Count number of submatrixes with sum T.\\nCompute prefix sums for all rows - `O(n^2)`. For all columns i and j (i <= j): translate (compress) submatrix  between this columns (inclusive) to array (all elements is sum of row this submatrix) with length n by prefix sums - `O(n)`. Now this is 1D case. Solve by `O(n)` for all (i, j).\\nTotal time complexity: `O(n^2 + n^2 * n) = O(n^3)`.\\n- 3-D: Given an cube (nxnxn) and number T. Count number of subcubes with sum T. \\nSuggest a solution: Cube is array of layers (matrixes). Compute prefix sums for all rows in layers  - `O(n^3)`. For all axes i and j (i <= j): given subcube between this axes (inclusive). Translate (compress) layer of this subcube to array (all elements is sum of row this submatrix) with length n by prefix sums - `O(n^2)`. This arrays form a matrix. Now this is 2D case. Solve by `O(n^3)` for all (i, j).\\nTotal time complexity: `O(n^3 + n^2 * n^3) = O(n^5)`.\\n- K-D: Given an hypercube with k dimensions (nxnxn...xn) and number T. Count number of subhypercubes with sum T.\\nSuggest a solution: use decreasing dimension. Like in cases above we slice hypercube by two axes and compress subhypercube beetween this axes (inclusive) two hypercube with dimension less by one. Use slice\\\\compress while we not giving a 1-D case. Proof this by mathematical induction?\\nTotal time complexity: `O(n^k + n^(1+2*(k-1))) = O(n^(1+2*(k-1)))`.\\n\\nWhat do you think about reasoning above? I would like to see this problem on hypercubes on LeetCode."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Please never add this thx <3 ;P"
                    },
                    {
                        "username": "Maristie",
                        "content": "I\\'ll just give several possible variants of this problem if you\\'re interested.\\n1. Decide whether there\\'s a submatrix summing to a target\\n2. Count submatrices summing to a target (exactly this one)\\n3. Decide whether there\\'s a submatrix whose sum is no larger than K\\n4. Count submatrices whose sum is no larger than K\\n5. Count submatrices whose sum is between `[k1, k2]`\\n6. Decide the maximum submatrix sum which is no larger than K ([363. Max Sum of Rectangle No Larger Than K](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/))\\n7. Decide the maximum number of elements in a submatrix whose sum is no larger than K"
                    },
                    {
                        "username": "NEU20133823",
                        "content": "![image](https://assets.leetcode.com/users/neu20133823/image_1559448784.png)\\nThe custom testcase was given from my failed submission before. I spent more than 30 minutes debugging it and still could not pass. Then I submitted near the final second of the contest and got AC??? Why?\\nMy solution is O(N^3)."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Asked in interview of MediaNet."
                    },
                    {
                        "username": "CodeMore19",
                        "content": "which college? for intern or placement??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Any similar easy problem to solve before this? I\\'m kind of not able to solve this."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "https://leetcode.com/problems/subarray-sum-equals-k/"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Number of Coins You Can Get",
        "question_content": "<p>There are <code>3n</code> piles of coins of varying size, you and your friends will take piles of coins as follows:</p>\n\n<ul>\n\t<li>In each step, you will choose <strong>any </strong><code>3</code> piles of coins (not necessarily consecutive).</li>\n\t<li>Of your choice, Alice will pick the pile with the maximum number of coins.</li>\n\t<li>You will pick the next pile with the maximum number of coins.</li>\n\t<li>Your friend Bob will pick the last pile.</li>\n\t<li>Repeat until there are no more piles of coins.</li>\n</ul>\n\n<p>Given an array of integers <code>piles</code> where <code>piles[i]</code> is the number of coins in the <code>i<sup>th</sup></code> pile.</p>\n\n<p>Return the maximum number of coins that you can have.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> piles = [2,4,1,2,7,8]\n<strong>Output:</strong> 9\n<strong>Explanation: </strong>Choose the triplet (2, 7, 8), Alice Pick the pile with 8 coins, you the pile with <strong>7</strong> coins and Bob the last one.\nChoose the triplet (1, 2, 4), Alice Pick the pile with 4 coins, you the pile with <strong>2</strong> coins and Bob the last one.\nThe maximum number of coins which you can have are: 7 + 2 = 9.\nOn the other hand if we choose this arrangement (1, <strong>2</strong>, 8), (2, <strong>4</strong>, 7) you only get 2 + 4 = 6 coins which is not optimal.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> piles = [2,4,5]\n<strong>Output:</strong> 4\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> piles = [9,8,7,6,5,1,2,3,4]\n<strong>Output:</strong> 18\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= piles.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>piles.length % 3 == 0</code></li>\n\t<li><code>1 &lt;= piles[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 806730,
                "title": "java-c-python-stright-forward",
                "content": "## **Intuition**\\nWe want to compare the numbers, we need to sort.\\nWe give the smallest values Bob,\\ngive the biggest to Alice,\\nand leave the second biggest to us.\\nThen we repeat this process.\\n<br>\\n\\n## **Explanation**\\nWe give small value to Bob,\\ngive the large value to Alice,\\nand we pick the medium values.\\n\\nThe final assignment will be like:\\nS S S S S S M L M L M L M L M L\\n\\nThe first third part is given to Bob,\\nstart from `A[n/3]`, we pick one element from every two.\\n<br>\\n\\n## **Complexity**\\nTime `O(sort)`\\nSpace `O(sort)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int maxCoins(int[] A) {\\n        Arrays.sort(A);\\n        int res = 0, n = A.length;\\n        for (int i = n / 3; i < n; i += 2)\\n            res += A[i];\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int maxCoins(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int res = 0, n = A.size();\\n        for (int i = n / 3; i < n; i += 2)\\n            res += A[i];\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def maxCoins(self, A):\\n        return sum(sorted(A)[len(A) / 3::2])\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int maxCoins(int[] A) {\\n        Arrays.sort(A);\\n        int res = 0, n = A.length;\\n        for (int i = n / 3; i < n; i += 2)\\n            res += A[i];\\n        return res;\\n    }\\n```\n```cpp\\n    int maxCoins(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int res = 0, n = A.size();\\n        for (int i = n / 3; i < n; i += 2)\\n            res += A[i];\\n        return res;\\n    }\\n```\n```py\\n    def maxCoins(self, A):\\n        return sum(sorted(A)[len(A) / 3::2])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 806728,
                "title": "python-simple-solution-with-detailed-explanation-o-nlogn",
                "content": "**Idea**\\n\\nSince piles are not necessarily consecutive, my intuition is telling me to sort the piles first and use a greedy approach.\\n\\nSay that the sorted piles are `p[0], p[1], ..., p[n-2], p[n-1]`. Alice will get `p[n-1]` no matter which piles we pick first. \\n\\nIf we just let Alice get that pile, which pile should we pick next? Right, it\\'s the second largest pile, `p[n-2]`. \\n\\nAnd which pile should we give to poor Bob? The pile with lowest value, `p[0]`.\\n\\nWe just repeat this process and always go for the second largest pile. The piles each person ends up with will be:\\n\\n- Alice: `p[n-1], p[n-3], p[n-5], ...`\\n- We: `p[n-2], p[n-4], p[n-6], ...`\\n- Bob: `p[0], p[1], p[2], ...`\\n\\n <br />\\n\\n**Complexity**\\n\\nTime complexity: `O(NlogN)`\\nSpace complexity: `O(1)`\\n\\n<br />\\n\\n**Python**\\n```Python\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles.sort()\\n        ans, n = 0, len(piles)\\n        for i in range(n - 2, n // 3 - 1, -2):\\n            ans += piles[i]\\n        return ans\\n```\\n",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles.sort()\\n        ans, n = 0, len(piles)\\n        for i in range(n - 2, n // 3 - 1, -2):\\n            ans += piles[i]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825562,
                "title": "java-o-n-log-n-clear-with-explanation",
                "content": "This was a pretty fun question! I decided to share my thinking and how I got to my solution.\\n\\n**Thought Process**\\n\\u2022 We are given coins in a multiple of 3 so that Alice, Bob, and I all get the same amount of coins.\\n\\u2022 We can grab any 3 coins at a time, creating a pile in which we all take a coin from.\\n\\u2022 Alice takes the highest value, we take the next highest value, and Bob always takes the lowest value.\\n\\nSo, if Alice is always going to take the most valuable coin, we always need to select piles that include the 2 highest value coins and the lowest value coin that are left in the main pile. This will ensure we get the max value possible with Alice always being a little more greedy than we are. Forget about Bob.\\n\\nIn order to do this, we can sort the array and take every second coin from the end until we\\'ve taken our third of the coins.\\n\\n**But wait**, let\\'s not forget about Bob just yet! He is still of use to us.\\n\\nSince we all get a third, that means bob will always get the first third of the sorted array **[0... (n/3)-1]**.\\n\\nWe can just start iterating by 2 through the array at **i = n/3** until we reach n-1. Instead of iterating from the end which makes it a little easier to read.\\n\\nSo, here\\'s the code:\\n\\n```\\npublic int maxCoins(int[] piles) {\\n        Arrays.sort(piles); //Sort the array\\n        int n = piles.length; //Number of coins in the array\\n        int max = 0; //Track my coin value\\n        \\n        //Iterate from n/3 to n-2 inclusive (bob takes the first third in order to get the lowest amount)\\n        for(int i = n/3; i < n-1; i+=2) {\\n            max += piles[i]; //Add this value to max\\n        }\\n        \\n        return max; //Return the max value\\n    }\\n```\\n\\nHopefully you found this helpful! If you did, please leave an upvote **:)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxCoins(int[] piles) {\\n        Arrays.sort(piles); //Sort the array\\n        int n = piles.length; //Number of coins in the array\\n        int max = 0; //Track my coin value\\n        \\n        //Iterate from n/3 to n-2 inclusive (bob takes the first third in order to get the lowest amount)\\n        for(int i = n/3; i < n-1; i+=2) {\\n            max += piles[i]; //Add this value to max\\n        }\\n        \\n        return max; //Return the max value\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1500779,
                "title": "short-2-approaches-c-beginner-friendly",
                "content": "**Time: O(10001)\\nSpace : O(10001)**\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        int hash[10001] = {0};\\n        for (auto x: piles){\\n            hash[x]++;\\n        }\\n        int last = 10000;\\n        int front = 0;\\n        int n = ((piles.size()/3) );\\n        int ans = 0;\\n        while (n--){\\n            while (last > 0 && hash[last] == 0) last--;\\n            hash[last]--;\\n            while (last > 0 && hash[last] == 0) last --; // second largest\\n            ans += last;\\n            hash[last]--;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Time: O(nlogn)\\nSpace : O(1)**\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end());\\n        int n=piles.size(),res=0;\\n        for(int i=n/3;i<n;i+=2){\\n            res+=piles[i];\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        int hash[10001] = {0};\\n        for (auto x: piles){\\n            hash[x]++;\\n        }\\n        int last = 10000;\\n        int front = 0;\\n        int n = ((piles.size()/3) );\\n        int ans = 0;\\n        while (n--){\\n            while (last > 0 && hash[last] == 0) last--;\\n            hash[last]--;\\n            while (last > 0 && hash[last] == 0) last --; // second largest\\n            ans += last;\\n            hash[last]--;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end());\\n        int n=piles.size(),res=0;\\n        for(int i=n/3;i<n;i+=2){\\n            res+=piles[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526679,
                "title": "simple-python-solution-reverse-sort-explanation",
                "content": "Since we can choose any 3 piles of our choice in each step (from the given piles), we can choose 2 piles with the maximum value and the third pile with the minimum value. From these 3 chosen piles we will get the pile with the second largest value. \\n\\nTherefore when we reverse sort the array of piles, every second pile will be given to us. All we have to do is iterate through 2/3rd of the array and add every second element to our count.\\n\\n\\n```\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles.sort(reverse=True)\\n        \\n        count = 0\\n\\t\\t# Here we are starting from index 1 and have a step size of 2 so that we directly jump to our pile\\n        for i in range(1, len(piles) - (len(piles) // 3), 2):\\n            count += piles[i]\\n            \\n        return count\\n```\\n\\nPlease do upvote if you liked the solution :)",
                "solutionTags": [],
                "code": "```\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles.sort(reverse=True)\\n        \\n        count = 0\\n\\t\\t# Here we are starting from index 1 and have a step size of 2 so that we directly jump to our pile\\n        for i in range(1, len(piles) - (len(piles) // 3), 2):\\n            count += piles[i]\\n            \\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 806775,
                "title": "python-3-one-liner-pattern-example",
                "content": "**Idea:**\\n* Sort input list\\n* Add every 2nd term starting from len(plies)//3 \\n\\n**Explaination:**\\n* To play optimally each set must be formed (lowest, 2nd highest, highest)\\n* Using this pattern:\\n* Input = [1,2,3,4,5,6,7,8,9]\\n*  From set (1,8,9) I can take 8,     Remaining Piles = [2,3,4,5,6,7]\\n*  From set (2,6,7) I can take 6,     Remaining Piles = [3,4,5]\\n*  From set (3,4,5) I can take 4,     Remaining Piles = []\\n\\n**Pattern**\\n*  Bolded numbers are the piles we took\\n*  [1, 2, 3, **4**, 5, **6**,  7, **8**, 9] \\n*  [L, L, L, **X**, H, **X**, H, **X**, H]\\n*  Add every 2nd term starting from len(plies)//3 \\n*  This Pattern will be the same for all inputs\\n\\n\\n**Solution 1: One Liner**\\nEdited: Lee215 for cleaner one liner. Give him an upvote \\n```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n\\t    return sum(sorted(piles)[len(piles)//3 :: 2])\\n```\\n\\n**Solution 2: Reader Friendly**\\n```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles.sort()\\n        c = 0 \\n        for x in range(len(piles)//3, len(piles), 2):\\n            c += piles[x]\\n\\n        return c\\n ```\\n \\n \\nLike if this helped!\\nCheers,\\nArgent",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n\\t    return sum(sorted(piles)[len(piles)//3 :: 2])\\n```\n```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles.sort()\\n        c = 0 \\n        for x in range(len(piles)//3, len(piles), 2):\\n            c += piles[x]\\n\\n        return c\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 806746,
                "title": "java-python-3-5-1-liners-w-comment-and-analysis-sort-and-pick-the-2nd-largest-of-each-triple",
                "content": "Each time pick the remaining largest `2` and the smallest one to form a triple, choose the `2nd` largest out of the triple, repeats till the end; Therefore, we can simply sort the array and choose the `2nd, 4th, 6th`, ..., from the largest, till we have `n / 3` piles.\\nWe can equally start from the `(piles.length / 3 + 1)th` pile, followed by `(piles.length / 3 + 3)th`, `(piles.length / 3 + 5)th`, ..., till the end of the array `piles`.\\n\\n```java\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int ans = 0;\\n        for (int i = piles.length / 3; i < piles.length; i += 2)\\n            ans += piles[i];\\n        return ans;\\n    }\\n```\\n**Analysis:**\\nTime: O(nlogn), space: O(1) - excluding space used during sort.\\n\\n----\\n```python\\n    def maxCoins(self, piles: List[int]) -> int:\\n        return sum(sorted(piles)[len(piles)// 3 :: 2])\\n```\\n\\n**Analysis:**\\nTime: O(nlogn), space: O(n).",
                "solutionTags": [],
                "code": "```java\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int ans = 0;\\n        for (int i = piles.length / 3; i < piles.length; i += 2)\\n            ans += piles[i];\\n        return ans;\\n    }\\n```\n```python\\n    def maxCoins(self, piles: List[int]) -> int:\\n        return sum(sorted(piles)[len(piles)// 3 :: 2])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1245992,
                "title": "python-99-faster-2-lines-with-explanation",
                "content": "The nice thing about this problem is that we can choose the piles greedily. To do this, we want to give Bob the bottom third of the numbers, while we split the top two thirds of the numbers with Alice. So, at each step, we give Alice the largest pile, we take the 2nd largest pile, and we give Bob the smallest pile. The easiest (and presumably fastest) way to implement this in code is to sort the piles, and then sum every other stone in the latter two thirds of the piles.\\n\\nExmple:\\n1. The Input: piles = [9,8,7,6,5,1,2,3,4]\\n2. Sort the Piles: piles = [1,2,3,4,5,6,7,8,9]\\n3. Separate the Piles (in my code I use slicing to only find our piles):\\n\\t* \\tBob = [1,2,3]\\n\\t* \\tUs = [4,6,8]\\n\\t* \\tAlice = [5,7,9]\\n4. Sum our piles to compute the Solution: score = 4 + 6 + 8 = 18\\n\\nIf we were to actually play the game, the rounds might look like:\\n1. [1,8,9]\\n2. [2,6,7]\\n3. [3,4,5]\\n\\n(you can freely swap the order of the rounds, and you can do Bob\\'s stones in any order, so there are actually 36 distinct ways to play the game which acheive the optimal result; where 36 = ((9/3)!)^2)\\n\\nTime Complexity: O(nlogn)\\nMemory Complexity: O(n)?\\nBest Performance: 560 ms/26.4 MB : 99%/73%\\n\\'\\'\\'\\nclass Solution:\\n\\n    def maxCoins(self, piles: List[int]) -> int:\\n        #Sort the Piles\\n        piles.sort()\\n        \\n        #Compute the Answer\\n        return sum(piles[len(piles)//3::2])\\n\\'\\'\\'\\nI\\'m not entirely sure about this, but I think slicing a list in python creates a copy. This would imply that the memory complexity of my algorithm as presented would be O(n) since the slice would have n/3 elements. Assuming this is true, we should be able to improve the memory usage to O(1) by doing the sum with a pointer:\\n\\'\\'\\'\\n\\n\\tsum(piles[i] for i in range(len(piles)//3, len(piles), 2))\\n\\'\\'\\'\\ninstead of using the code I\\'ve presented above. When I tried this though, the code became significantly slower (presumably due to overhead) without noticably reducing the memory usage. Am I incorrect in how list slicing works? Or is there something else going on under the hood that causes this that I\\'m not aware of? Thanks!\\n\\nFinally, since it\\'s possible, here\\'s a 1-liner!\\n\\n\\'\\'\\'\\n\\n\\treturn sum(sorted(piles)[len(piles)//3::2])\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sorting"
                ],
                "code": "The nice thing about this problem is that we can choose the piles greedily. To do this, we want to give Bob the bottom third of the numbers, while we split the top two thirds of the numbers with Alice. So, at each step, we give Alice the largest pile, we take the 2nd largest pile, and we give Bob the smallest pile. The easiest (and presumably fastest) way to implement this in code is to sort the piles, and then sum every other stone in the latter two thirds of the piles.\\n\\nExmple:\\n1. The Input: piles = [9,8,7,6,5,1,2,3,4]\\n2. Sort the Piles: piles = [1,2,3,4,5,6,7,8,9]\\n3. Separate the Piles (in my code I use slicing to only find our piles):\\n\\t* \\tBob = [1,2,3]\\n\\t* \\tUs = [4,6,8]\\n\\t* \\tAlice = [5,7,9]\\n4. Sum our piles to compute the Solution: score = 4 + 6 + 8 = 18\\n\\nIf we were to actually play the game, the rounds might look like:\\n1. [1,8,9]\\n2. [2,6,7]\\n3. [3,4,5]\\n\\n(you can freely swap the order of the rounds, and you can do Bob\\'s stones in any order, so there are actually 36 distinct ways to play the game which acheive the optimal result; where 36 = ((9/3)!)^2)\\n\\nTime Complexity: O(nlogn)\\nMemory Complexity: O(n)?\\nBest Performance: 560 ms/26.4 MB : 99%/73%\\n\\'\\'\\'\\nclass Solution:\\n\\n    def maxCoins(self, piles: List[int]) -> int:\\n        #Sort the Piles\\n        piles.sort()\\n        \\n        #Compute the Answer\\n        return sum(piles[len(piles)//3::2])\\n\\'\\'\\'\\nI\\'m not entirely sure about this, but I think slicing a list in python creates a copy. This would imply that the memory complexity of my algorithm as presented would be O(n) since the slice would have n/3 elements. Assuming this is true, we should be able to improve the memory usage to O(1) by doing the sum with a pointer:\\n\\'\\'\\'\\n\\n\\tsum(piles[i] for i in range(len(piles)//3, len(piles), 2))\\n\\'\\'\\'\\ninstead of using the code I\\'ve presented above. When I tried this though, the code became significantly slower (presumably due to overhead) without noticably reducing the memory usage. Am I incorrect in how list slicing works? Or is there something else going on under the hood that causes this that I\\'m not aware of? Thanks!\\n\\nFinally, since it\\'s possible, here\\'s a 1-liner!\\n\\n\\'\\'\\'\\n\\n\\treturn sum(sorted(piles)[len(piles)//3::2])\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 806754,
                "title": "c-java-sort",
                "content": "Sort the array and return the sum of every other element starting from n.\\n\\n**C++**\\n```cpp\\nint maxCoins(vector<int>& p, int res = 0) {\\n    sort(begin(p), end(p));\\n    for (int j = p.size() / 3; j < p.size(); j += 2)\\n        res += p[j];\\n    return res;\\n}\\n```\\n\\n**Java**\\n```java\\npublic int maxCoins(int[] p) {\\n    Arrays.sort(p);\\n    int res = 0;\\n    for (int j = p.length / 3; j < p.length; j += 2)\\n        res += p[j];\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint maxCoins(vector<int>& p, int res = 0) {\\n    sort(begin(p), end(p));\\n    for (int j = p.size() / 3; j < p.size(); j += 2)\\n        res += p[j];\\n    return res;\\n}\\n```\n```java\\npublic int maxCoins(int[] p) {\\n    Arrays.sort(p);\\n    int res = 0;\\n    for (int j = p.length / 3; j < p.length; j += 2)\\n        res += p[j];\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2136054,
                "title": "c-straight-forward-average-simple",
                "content": "```\\nint maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end());\\n        int sum=0,i=0,j=piles.size()-2;\\n        for(;j>i;j=j-2)\\n            i++,sum+=piles[j];\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nint maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end());\\n        int sum=0,i=0,j=piles.size()-2;\\n        for(;j>i;j=j-2)\\n            i++,sum+=piles[j];\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2802986,
                "title": "python-easy-solution-using-sorting",
                "content": "\\n    def maxCoins(self, piles: List[int]) -> int:\\n        \\n\\t\\tpiles.sort()\\n        if len(piles)==3:\\n            return piles[1]\\n        ans=0\\n        itr=0\\n        l=len(piles)-2\\n        while l>=0 and itr<len(piles)//3:\\n            ans+=piles[l]\\n            l-=2\\n            itr+=1\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Sorting"
                ],
                "code": "\\n    def maxCoins(self, piles: List[int]) -> int:\\n        \\n\\t\\tpiles.sort()\\n        if len(piles)==3:\\n            return piles[1]\\n        ans=0\\n        itr=0\\n        l=len(piles)-2\\n        while l>=0 and itr<len(piles)//3:\\n            ans+=piles[l]\\n            l-=2\\n            itr+=1\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 1396455,
                "title": "c-greedy-solution",
                "content": "**Idea** : \\n* Initially we sort an array in ascending order.\\n* So, array after sorting will looks likew this -> 0 1 2 3 .... n-1 n.\\n* - First pile we will assign to Bob (minimum for current pair)\\n   - We will pick second last pile (middle for current pair) and\\n   -  Last pile to Alice (maximum for curent pair)\\n * Here we **making pair of (first, 2nd last, last element)** and add only **2nd last** to our answer - we do this **piles.size()/3 times.**\\n\\n\\n![image](https://assets.leetcode.com/users/images/0ac71c55-ccb3-4354-b6ec-23410c4b9c54_1628656735.3733516.jpeg)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) \\n    {\\n        int res=0, n=piles.size();    \\n        sort(piles.begin(), piles.end());\\n        for(int i=0; i<(n/3); i++)\\n            res += piles[n-2*i-2];\\n            return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) \\n    {\\n        int res=0, n=piles.size();    \\n        sort(piles.begin(), piles.end());\\n        for(int i=0; i<(n/3); i++)\\n            res += piles[n-2*i-2];\\n            return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079716,
                "title": "greedy-approch-with-proper-explaination",
                "content": "# Intuition\\nGreedy approach.\\nMain idea is that if we choose the the group of three as:\\narray = [9,8,7,6,5,4,3,2,1]\\nchoosen group1 : [9,8,1] => ans = 8\\nchoosen group2 : [7,6,2] => ans = 6\\nchoosen group3 : [5,4,3] => ans = 4\\nso ans is 18 which is maximum for all case.\\n\\n\\n# Approach\\nSort the array in descending order.\\nAdd the second element in answer and decrease the size so that first element is also eliminated.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& p) {\\n        sort(p.begin(),p.end(),greater<int>());\\n        int ans=0;\\n        int x=p.size();\\n        for(int i=0;i<x;i+=2){\\n            ans+=p[i+1];\\n            x-=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& p) {\\n        sort(p.begin(),p.end(),greater<int>());\\n        int ans=0;\\n        int x=p.size();\\n        for(int i=0;i<x;i+=2){\\n            ans+=p[i+1];\\n            x-=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546583,
                "title": "greedy-python-solution-easy-sorting-deque-with-explanation",
                "content": "Logic is that Alice always gets the max value no matter which pair you select. And poor Bob always gets the least in that pair. So you ideally select a pair in which there are 2 max items (1 for Alice, then you) and 1 min item (for Bob). Its ideal to sort and get top 2 and 1 bottom item in each iteration. \\n\\nUsed deque as it is faster to pop from left side.\\nUpvote if you like the solution.\\n\\n```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles.sort()\\n        piles = deque(piles)\\n        tot = 0\\n        \\n        while piles:\\n            piles.pop()\\n            tot += piles.pop()\\n            piles.popleft()\\n        \\n        return tot\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Queue",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles.sort()\\n        piles = deque(piles)\\n        tot = 0\\n        \\n        while piles:\\n            piles.pop()\\n            tot += piles.pop()\\n            piles.popleft()\\n        \\n        return tot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806902,
                "title": "javascript-clean-5-liner-one-pass-solution",
                "content": "```javascript\\nvar maxCoins = function(piles) {\\n    const start = piles.length / 3;\\n    piles.sort((a, b) => a - b);\\n    let res = 0;\\n    for(let i = start; i < piles.length; i+=2) res += piles[i];\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar maxCoins = function(piles) {\\n    const start = piles.length / 3;\\n    piles.sort((a, b) => a - b);\\n    let res = 0;\\n    for(let i = start; i < piles.length; i+=2) res += piles[i];\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3508946,
                "title": "c-c-javascript-explained-and-very-simple-solutions-for-all",
                "content": "\\n\\n# Approach:First of all,we have to sort the given array from min to max.PAy attention,to collect the maximum number of coins we always choose 3 piles,which contains two maximum piles and minimum pile.It means we always get the second maximum amount after Alice.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n```javascript []\\nvar maxCoins = function(piles) {\\n    piles.sort((a,b)=>a-b);\\n     let ans = 0;\\n        for (let i =0, j= piles.length -2; i < j; i++, j-=2)\\n        ans += piles[j];\\n        return ans; \\n};\\n```\\n```C# []\\npublic class Solution {\\n    public int MaxCoins(int[] piles) {\\n        Array.Sort(piles);\\n        int ans = 0;\\n        for (int i =0, j= piles.Length -2; i < j; i++, j-=2)\\n        {\\n            ans += piles[j];\\n        }\\n        return ans;    \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end());\\n        int total=0;\\n        int last=piles.size()-2;\\n        for(int i=0;i<piles.size()/3;i++){\\n           total+=piles[last];\\n           last-=2; \\n        }\\n        return total;\\n    }\\n};\\n```\\n![Vote.png](https://assets.leetcode.com/users/images/ede80eaa-f813-469f-b413-752e39afd490_1683726522.7683349.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C#",
                    "JavaScript"
                ],
                "code": "```javascript []\\nvar maxCoins = function(piles) {\\n    piles.sort((a,b)=>a-b);\\n     let ans = 0;\\n        for (let i =0, j= piles.length -2; i < j; i++, j-=2)\\n        ans += piles[j];\\n        return ans; \\n};\\n```\n```C# []\\npublic class Solution {\\n    public int MaxCoins(int[] piles) {\\n        Array.Sort(piles);\\n        int ans = 0;\\n        for (int i =0, j= piles.Length -2; i < j; i++, j-=2)\\n        {\\n            ans += piles[j];\\n        }\\n        return ans;    \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end());\\n        int total=0;\\n        int last=piles.size()-2;\\n        for(int i=0;i<piles.size()/3;i++){\\n           total+=piles[last];\\n           last-=2; \\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263897,
                "title": "easy-python-solution-beats-90-runtime",
                "content": "![image.png](https://assets.leetcode.com/users/images/368aeba8-2f0e-4a1f-bfa5-c0b75d1b5686_1678096686.3498604.png)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxCoins(self, piles):\\n        \"\"\"\\n        :type piles: List[int]\\n        :rtype: int\\n        \"\"\"\\n        you=0\\n        ln=len(piles)//3\\n        piles.sort(reverse=True)\\n        piles=piles[:-ln]\\n        for i in range(0,len(piles),2):\\n            you+=piles[i+1]\\n        return you\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Greedy",
                    "Sorting",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxCoins(self, piles):\\n        \"\"\"\\n        :type piles: List[int]\\n        :rtype: int\\n        \"\"\"\\n        you=0\\n        ln=len(piles)//3\\n        piles.sort(reverse=True)\\n        piles=piles[:-ln]\\n        for i in range(0,len(piles),2):\\n            you+=piles[i+1]\\n        return you\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858012,
                "title": "python3-solution-math-o-nlogn-time-complexity",
                "content": "Approach:\\n1. Find the number of pile n by dividing the length of piles 3n by 3.\\n2. sort the piles array \\n3. take the second maximum number from the sorted array\\n4. since you have taken the the second maximum number from the end of the piles, if i is n - 1, decrement i by 2 and decrement backT(tells us how many times we can take triplets by moving back ward) by 1.\\n5. then add the ith - 1 index element to my_coins variable whenever the backT is greater than zero.\\n6. finally return my_coins\\n# Please UPVOTE , It is free! You won\\'t pay a penny leetcoin!\\n```\\ndef maxCoins(self, piles: List[int]) -> int:\\n\\tn = len(piles)\\n\\tbackT = n//3\\n\\tpiles.sort()\\n\\ti = n-1\\n\\tmy_coins = piles[-2]\\n\\twhile i >=0:\\n\\t\\tif i == n-1:\\n\\t\\t\\ti -=2\\n\\t\\t\\tbackT -=1\\n\\t\\telif backT > 0:\\n\\t\\t\\tmy_coins += piles[i-1]\\n\\t\\t\\ti -= 2\\n\\t\\t\\tbackT -=1\\n\\t\\telse:\\n\\t\\t\\tbreak\\n\\treturn my_coins",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "Approach:\\n1. Find the number of pile n by dividing the length of piles 3n by 3.\\n2. sort the piles array \\n3. take the second maximum number from the sorted array\\n4. since you have taken the the second maximum number from the end of the piles, if i is n - 1, decrement i by 2 and decrement backT(tells us how many times we can take triplets by moving back ward) by 1.\\n5. then add the ith - 1 index element to my_coins variable whenever the backT is greater than zero.\\n6. finally return my_coins\\n# Please UPVOTE , It is free! You won\\'t pay a penny leetcoin!\\n```\\ndef maxCoins(self, piles: List[int]) -> int:\\n\\tn = len(piles)\\n\\tbackT = n//3\\n\\tpiles.sort()\\n\\ti = n-1\\n\\tmy_coins = piles[-2]\\n\\twhile i >=0:\\n\\t\\tif i == n-1:\\n\\t\\t\\ti -=2\\n\\t\\t\\tbackT -=1\\n\\t\\telif backT > 0:\\n\\t\\t\\tmy_coins += piles[i-1]\\n\\t\\t\\ti -= 2\\n\\t\\t\\tbackT -=1\\n\\t\\telse:\\n\\t\\t\\tbreak\\n\\treturn my_coins",
                "codeTag": "Python3"
            },
            {
                "id": 2857998,
                "title": "python3-easy-fast-and-efficient-way",
                "content": "We are required to find the maximum possible coins to take next to Alice, so\\n->First, just sort the array\\n->Next, take the next maximum value starting from the back with a step of -2\\n(Ingnore the first max(piles[-1]) because it\\'s Alice\\'s and just take the next!)\\n\\nIf you got it clear, please **Upvote!!**\\n```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        my_coins = 0\\n        piles.sort()\\n        for i in range(len(piles)//3):\\n            my_coins += piles[-2 - 2*i]\\n        \\n        return my_coins",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math",
                    "Sorting"
                ],
                "code": "We are required to find the maximum possible coins to take next to Alice, so\\n->First, just sort the array\\n->Next, take the next maximum value starting from the back with a step of -2\\n(Ingnore the first max(piles[-1]) because it\\'s Alice\\'s and just take the next!)\\n\\nIf you got it clear, please **Upvote!!**\\n```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        my_coins = 0\\n        piles.sort()\\n        for i in range(len(piles)//3):\\n            my_coins += piles[-2 - 2*i]\\n        \\n        return my_coins",
                "codeTag": "Java"
            },
            {
                "id": 2535731,
                "title": "java-solution-easy-understanding",
                "content": "```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        int sum = 0;\\n        Arrays.sort(piles);      //Sorting the array in ascending order\\n        int coinindex = piles.length-2;   //after sorting we will take the second largest value of the array\\n        for(int i=0;i<piles.length/3;i++) //the number of loops for which we need to iterate\\n        {\\n            sum+=piles[coinindex];\\n            coinindex-=2;\\n        }\\n        return sum;\\n    }\\n}\\n\\n/* piles = [9,8,7,6,5,1,2,3,4]\\nafter sorting => [1,2,3,4,5,6,7,8,9]\\nwe will take 2 values from end and 1 value from the beginning\\n=> [1,8,9] , [2,6,7] , [3,4,5]\\n\\ncoinindex = piles.length-2\\nso during 1st iteration we add to sum piles[coinindex]\\nnow we decrement coinindex by 2 This will ensure we get the max value possible with Alice always being a little more greedy than we are.\\n\\nduring 2nd iteration, =>[2,6,7] we add two values before coinindex of 1st iteration that (index of 8)-2 that is 6 to our sum \\n\\nand finally in the last and final iteration we add 4 to our sum \\n\\nAs for Bob, he always gets the least amount in the not consecutive array of integers.*/\\n\\n",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int maxCoins(int[] piles) {\\n        int sum = 0;\\n        Arrays.sort(piles);      //Sorting the array in ascending order\\n        int coinindex = piles.length-2;   //after sorting we will take the second largest value of the array\\n        for(int i=0;i<piles.length/3;i++) //the number of loops for which we need to iterate\\n        {\\n            sum+=piles[coinindex];\\n            coinindex-=2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1518949,
                "title": "javascript-solutions-2-18-38-371ms-also-a-1-liner",
                "content": "To solve this problem we must get the coin piles in an order that will ensure us an optimal return, we can do this by sorting the array.\\n\\nThe first thing we must do is instantiate a `result` variable and a `len` variable. The `len` variable is only going to be 2/3s of the length of the `piles` array because after we sort the array we know that we can allot the piles in the lower third to Bob.\\n- `let result = 0, len = (piles.length * (2/3))`\\n\\nNext, and most importantly, we want to sort the array in a descending order.\\n- `piles.sort((a, b) => {return b - a})`, do NOT use piles.sort() as this will return an incorrect sort (it will sort by the first numeral in a number ex: 1, 10, 2, 3, 434, 5...) and lead to a wrong answer submission.\\n\\nCreate a for loop to iterate through the `piles` array. The loop will set the variable `i` to 1, check if `i` is less than `len`, and then proceed to increment `i` by 2. We want to start at 1 so we skip the first indexed number and increment by 2 so that we are only iterating through every other number. We stop at `len` which is 2/3s of the array length so we dont iterate through the lower third of numbers as those piles will belong to Bob. Inside the for loop we will add the `i` indexed number in the `piles` array to our `result` variable.\\n- `for(let i = 1; i < len; i+=2){ result += piles[i] }`\\n\\n\\n- ![image](https://assets.leetcode.com/users/images/6bfd26e2-65dd-41d2-876b-fb6325128b02_1634103529.616884.png)\\n\\n\\nFinally, return the `result` variable as our answer.\\n\\n**Solution:**\\n\\n```\\nvar maxCoins = function(piles) {\\n    let result = 0, len = (piles.length * (2/3))\\n    piles.sort((a, b) => {return b - a})\\n    for(let i = 1; i < len; i+=2){ result += piles[i] }\\n    return result\\n};\\n```\\n\\n---\\n**One-Line Solution:**\\n\\nThis solution is pretty slow, 389ms 15%/32%, but 1-line tho..\\n\\nIn short, we sort the `piles` array in descending order and use the reduce method to add up values in the array if they follow two conditions: the index of the current number mod 2 is equal to 1 AND the index is less than 2/3s the length of the `piles` array.\\n\\n```\\nvar maxCoins = (piles) => piles.sort((a, b) => {return b - a}).reduce((a, b, i) => i % 2 === 1 && i < (piles.length * (2/3)) ? a + b : a + 0, 0) \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxCoins = function(piles) {\\n    let result = 0, len = (piles.length * (2/3))\\n    piles.sort((a, b) => {return b - a})\\n    for(let i = 1; i < len; i+=2){ result += piles[i] }\\n    return result\\n};\\n```\n```\\nvar maxCoins = (piles) => piles.sort((a, b) => {return b - a}).reduce((a, b, i) => i % 2 === 1 && i < (piles.length * (2/3)) ? a + b : a + 0, 0) \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 988709,
                "title": "c-8-line-simple-code-greedy-approach",
                "content": "Intution of the question is that to choose triplets with (largest value, minimum value and second largest value) and add the second largest value to the answer. \\n```\\nint maxCoins(vector<int>& piles) {\\n\\tsort(piles.begin(), piles.end());\\n    int ans = 0, start = 0, end = piles.size() - 1;\\n    while(start < end) {\\n        ans += piles[end - 1];\\n        start++;\\n        end -= 2;\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint maxCoins(vector<int>& piles) {\\n\\tsort(piles.begin(), piles.end());\\n    int ans = 0, start = 0, end = piles.size() - 1;\\n    while(start < end) {\\n        ans += piles[end - 1];\\n        start++;\\n        end -= 2;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 980071,
                "title": "python-90-faster-and-simple-solution",
                "content": "`O(nlogn)`\\n```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles.sort()\\n        c = 0\\n        for i in range(len(piles) // 3):\\n            piles.pop()\\n            c += piles.pop()\\n        return c\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "`O(nlogn)`\\n```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles.sort()\\n        c = 0\\n        for i in range(len(piles) // 3):\\n            piles.pop()\\n            c += piles.pop()\\n        return c\\n",
                "codeTag": "Java"
            },
            {
                "id": 806976,
                "title": "simple-understandable-python-solution",
                "content": "Always take second pile, and remove last pile from array.\\n```\\ndef maxCoins(self, piles: List[int]) -> int:\\n        piles = sorted(piles, reverse=True)\\n        answer = 0\\n        index = 1\\n        while index < len(piles):\\n            answer += piles[index]\\n            piles.pop()\\n            index += 2\\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef maxCoins(self, piles: List[int]) -> int:\\n        piles = sorted(piles, reverse=True)\\n        answer = 0\\n        index = 1\\n        while index < len(piles):\\n            answer += piles[index]\\n            piles.pop()\\n            index += 2\\n        return answer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 806897,
                "title": "greedy-picking-the-2nd-greatest-coin-pile",
                "content": "In order to reach the max coins we can get, we will alway try to get the max coins at each step. However, the pile with greatest coins will be always taken away by Alice (Lady First :) ). Then, we can make the choice among those 2 left. That is, we can reach the optimal solution by first sorting, then always take the 2nd greatest coins of 3. For example:\\n\\nIf we have: **[1, 2, 2, 4, 7, 8]**, we can arrage the tuple as **[1, 7, 8]**, **[2, 2, 4]**, you can see that the answer here is **7 + 2 = 9**. You can observe that pile with the least coins has no impact to the answer, so **we can choose the largest element and 2nd largest element, plus a smaller element to build a tuple.** **We only care about the 2nd largetest element in each group.** Here is my sample code:\\n\\n```\\n    public int maxCoins(int[] p) {\\n        Arrays.sort(p);\\n\\t\\tint l = p.length;\\n        if (l == 3) { // Only 1 group, return the 2nd largest, since the 1st largest has already been taken away by Alice!\\n            return p[1];\\n        }\\n        int res = 0;\\n        int groups = l / 3; // Divide to groups and each group has 3 coin piles based on the description of this problem.\\n        for (int i=0; i<groups; i++) {\\n            res += p[l-2*(i+1)]; // Always pick the 2nd largest element and add it to the result! (We start from the end to the start, greedy picking the 2nd largest element in the array!)\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxCoins(int[] p) {\\n        Arrays.sort(p);\\n\\t\\tint l = p.length;\\n        if (l == 3) { // Only 1 group, return the 2nd largest, since the 1st largest has already been taken away by Alice!\\n            return p[1];\\n        }\\n        int res = 0;\\n        int groups = l / 3; // Divide to groups and each group has 3 coin piles based on the description of this problem.\\n        for (int i=0; i<groups; i++) {\\n            res += p[l-2*(i+1)]; // Always pick the 2nd largest element and add it to the result! (We start from the end to the start, greedy picking the 2nd largest element in the array!)\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3968199,
                "title": "java-simple-two-pointer-sorting-beats-97",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        int res = 0;\\n        int j = piles.length - 1;\\n        int i = 0;\\n        Arrays.sort(piles);\\n        while(i<j){\\n            j--;\\n            res += piles[j];\\n            i++;\\n            j--;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        int res = 0;\\n        int j = piles.length - 1;\\n        int i = 0;\\n        Arrays.sort(piles);\\n        while(i<j){\\n            j--;\\n            res += piles[j];\\n            i++;\\n            j--;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817571,
                "title": "sorting-c-only-5-lines",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**in Each Step you have to choose -**`[Maximum, Second Maximum, Minimum]`  **Elements  of the Array and Second Maximum coins credit to your score.**\\n\\n# Complexity\\n- Time complexity:O(N * Log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int ans = 0;\\n        for(int i = 0,j = arr.size()-1;i<j;j-=2,i+=1)\\n        ans+=arr[j-1];\\n        return ans; \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/3dd8a8db-b664-42fa-ac80-319502baba38_1690350706.0117018.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int ans = 0;\\n        for(int i = 0,j = arr.size()-1;i<j;j-=2,i+=1)\\n        ans+=arr[j-1];\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789249,
                "title": "java-easy-solution-with-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want to compare the numbers, we need to sort.\\nWe give the smallest values Bob,\\ngive the biggest to Alice,\\nand leave the second biggest to us.\\nThen we repeat this process.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe give small value to Bob,\\ngive the large value to Alice,\\nand we pick the medium values.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int res = 0, n = piles.length;\\n        for (int i = n / 3; i < n; i += 2)\\n            res += piles[i];\\n        return res;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int res = 0, n = piles.length;\\n        for (int i = n / 3; i < n; i += 2)\\n            res += piles[i];\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443064,
                "title": "maximum-number-of-coins-you-can-get-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        int i, j, max_coins=0;\\n        sort(piles.begin(), piles.end());\\n        for(i=0 ; i<piles.size()/3 ; i++)\\n        {\\n            max_coins += piles[piles.size()-(2*(i+1))];\\n        }\\n        return max_coins;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/b7fe48e8-67a7-46d7-875f-8b4a17ace1ec_1682612932.8821623.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        int i, j, max_coins=0;\\n        sort(piles.begin(), piles.end());\\n        for(i=0 ; i<piles.size()/3 ; i++)\\n        {\\n            max_coins += piles[piles.size()-(2*(i+1))];\\n        }\\n        return max_coins;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205547,
                "title": "python-simple-easy-to-understand-beats-93-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n##### For chosing a pile of 3 coins:\\n- 1st one have to be the biggest coin of all/remaining,\\n- 2nd one have to be the 2nd biggest coin of all/remaining,\\n- Last one have to be the smallest coin of all/remaining.\\n- Remove/forget above 3.\\n\\nThen, Repeat.\\n##### Upvote, if you got this!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, reverse sort the array. Then, start loop from 2nd value which is my first coin. Bob\\'s coins lies in the last side of the array, which is equal to total piles in array, i.e. len/3. End loop before Bob\\'s value. Increment by two.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles = sorted(piles, reverse=True)\\n        lp = len(piles)\\n        res = 0\\n        for i in range(1, lp - lp/3, 2):\\n            res += piles[i]\\n        return res\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/150bb479-dbb1-49c6-b007-0b98c5dcde80_1676804638.491498.png)\\n\\n\\n\\n# Upvote, if you got this!\\n",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Greedy",
                    "Sort",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles = sorted(piles, reverse=True)\\n        lp = len(piles)\\n        res = 0\\n        for i in range(1, lp - lp/3, 2):\\n            res += piles[i]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098800,
                "title": "easy-simple-c-solution",
                "content": "## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        int ans=0;\\n        sort(piles.begin(),piles.end());\\n        int cnt=0;\\n        for (int i= piles.size()-2; i>cnt; i-=2){\\n            ans+= piles[i];\\n            cnt++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        int ans=0;\\n        sort(piles.begin(),piles.end());\\n        int cnt=0;\\n        for (int i= piles.size()-2; i>cnt; i-=2){\\n            ans+= piles[i];\\n            cnt++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034555,
                "title": "easy-c-code-simple-adding-o-nlogn",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        //ide ais to always give the maximum element to alice and take second max as urs and minimum for bob\\n        sort(piles.begin(),piles.end());\\n        int res=0,cnt=0;\\n        int i=piles.size()-2,n=piles.size()/3;\\n        while(cnt<n && i>=0){\\n            cnt++;\\n            res+=piles[i];\\n            i-=2;\\n\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        //ide ais to always give the maximum element to alice and take second max as urs and minimum for bob\\n        sort(piles.begin(),piles.end());\\n        int res=0,cnt=0;\\n        int i=piles.size()-2,n=piles.size()/3;\\n        while(cnt<n && i>=0){\\n            cnt++;\\n            res+=piles[i];\\n            i-=2;\\n\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945460,
                "title": "java-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        int count = 0;\\n        Arrays.sort(piles);\\n        for(int i=piles.length-2; i>= piles.length/3;){\\n            count += piles[i];\\n            i-= 2;\\n        }\\n      return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        int count = 0;\\n        Arrays.sort(piles);\\n        for(int i=piles.length-2; i>= piles.length/3;){\\n            count += piles[i];\\n            i-= 2;\\n        }\\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802611,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n       \\n    int maxCoins(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int res = 0, n = A.size();\\n        for (int i = n / 3; i < n; i += 2)\\n            res += A[i];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n       \\n    int maxCoins(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int res = 0, n = A.size();\\n        for (int i = n / 3; i < n; i += 2)\\n            res += A[i];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618792,
                "title": "o-nlogn-easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int i=0,j=piles.length-1,res=0;\\n        while(i<j){\\n            res+=piles[j-1];\\n            j-=2;i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int i=0,j=piles.length-1,res=0;\\n        while(i<j){\\n            res+=piles[j-1];\\n            j-=2;i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2314327,
                "title": "c-solution-o-nlogn-time-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(), piles.end());\\n        int start = 0;\\n        int end = piles.size()-1;\\n        int sum = 0;\\n        \\n        while(start<end)\\n        {\\n            sum += piles[end-1];\\n            end -= 2;\\n            start += 1;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(), piles.end());\\n        int start = 0;\\n        int end = piles.size()-1;\\n        int sum = 0;\\n        \\n        while(start<end)\\n        {\\n            sum += piles[end-1];\\n            end -= 2;\\n            start += 1;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2103778,
                "title": "this-might-help-you-c-code",
                "content": "\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        \\n        int sum=0;\\n        int n=piles.size();\\n        int it=piles.size()/3;\\n        sort(piles.begin(),piles.end(),greater<int>());\\n        int j=1;\\n        for(int i=0;i<it;i++)\\n        {  \\n           sum+=piles[j]; \\n           j+=2; \\n            \\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        \\n        int sum=0;\\n        int n=piles.size();\\n        int it=piles.size()/3;\\n        sort(piles.begin(),piles.end(),greater<int>());\\n        int j=1;\\n        for(int i=0;i<it;i++)\\n        {  \\n           sum+=piles[j]; \\n           j+=2; \\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2021446,
                "title": "easy-and-fast-typescript-solution-with-detailed-explanation",
                "content": "We need to get maximum number of coins each time when we pick three different piles. Considering the fact that Alice always takes the **maximum**, we need to take the **second maximum**. If we want to obtain the maximum number of coins for us (that means for Alice too) in *next* round, then it means to give the Bob the **minimum** count of coins in the *current* round.\\n\\nSo, the scheme is next: firstly, we need to **sort** piles, than we can be sure that coins in piles are changing from minimum to maximum.\\nAnd then each time, when we still have piles (which amount is multiple of 3), we have to do **3** actions:\\n1) Give the Alice the maximum number of coins;\\n2) Get the second maximum of coins;\\n3) Give Bob the minimum of coins.\\n\\n```\\nfunction maxCoins(piles: number[]): number {\\n    piles.sort((a, b) => a - b);\\n    let result = 0;\\n    while (piles.length !== 0) {\\n        piles.pop();\\n        result += piles.pop();\\n        piles.shift();\\n    }\\n    return result;\\n};\\n```\\n\\n**Time complexity:** O(nlogn)\\n**Space complexity:** O(1)",
                "solutionTags": [
                    "TypeScript",
                    "Sorting"
                ],
                "code": "```\\nfunction maxCoins(piles: number[]): number {\\n    piles.sort((a, b) => a - b);\\n    let result = 0;\\n    while (piles.length !== 0) {\\n        piles.pop();\\n        result += piles.pop();\\n        piles.shift();\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1984648,
                "title": "c-easy-solution-math-and-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(), piles.end(), std::greater<int>());\\n        int n = piles.size() / 3;\\n        int mcoin = 0;\\n        for(int i = 1; n != 0; i += 2){\\n            mcoin += piles[i];\\n            //cout << piles[i] <<\" \";\\n            n--;\\n        }\\n        return mcoin;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy",
                    "Sorting",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(), piles.end(), std::greater<int>());\\n        int n = piles.size() / 3;\\n        int mcoin = 0;\\n        for(int i = 1; n != 0; i += 2){\\n            mcoin += piles[i];\\n            //cout << piles[i] <<\" \";\\n            n--;\\n        }\\n        return mcoin;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1758046,
                "title": "short-and-simple-c-accepted-solution",
                "content": "class Solution {\\npublic:\\n\\n    int maxCoins(vector<int>& piles) {\\n        int n = piles.size();\\n        int operation = n/3;\\n        int ans = 0;\\n        sort(piles.begin() , piles.end());\\n        int index = n-2;\\n        while(operation--){\\n            ans += piles[index];\\n            index -= 2;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maxCoins(vector<int>& piles) {\\n        int n = piles.size();\\n        int operation = n/3;\\n        int ans = 0;\\n        sort(piles.begin() , piles.end());\\n        int index = n-2;\\n        while(operation--){\\n            ans += piles[index];\\n            index -= 2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1600558,
                "title": "python3-one-liner",
                "content": "Explaination:\\n- sort the array (the expensive part)\\n- remove the first third of it, since we always make sure Bob picks these\\n- step into the remaining array and pick one element every 2\\n\\nThe idea is that we can make Bob always pick the lowest elements, but we cannot avoid Alice picking the best ones. So the best we can do is to pick the second best everytime.\\n\\n```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        return sum(sorted(piles)[len(piles) // 3:][::2])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        return sum(sorted(piles)[len(piles) // 3:][::2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322576,
                "title": "java-sorting-24ms-beats-98-t-c-o-nlogn-s-c-o-1",
                "content": "\\n    public int maxCoins(int[] piles) {\\n        \\n        int len = piles.length, coins = 0, right = len - 2, count = len / 3;\\n        Arrays.sort(piles);\\n        \\n        for(int i = 0; i < count; i++){\\n            coins += piles[right];\\n            right -= 2;\\n        }\\n        \\n        return coins;\\n    }",
                "solutionTags": [],
                "code": "\\n    public int maxCoins(int[] piles) {\\n        \\n        int len = piles.length, coins = 0, right = len - 2, count = len / 3;\\n        Arrays.sort(piles);\\n        \\n        for(int i = 0; i < count; i++){\\n            coins += piles[right];\\n            right -= 2;\\n        }\\n        \\n        return coins;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1232262,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles.sort(reverse=True)\\n        sum = 0\\n        for i in range(1,len(piles)-int(len(piles)/3),2):\\n            sum += piles[i]\\n            print(sum)\\n        return sum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles.sort(reverse=True)\\n        sum = 0\\n        for i in range(1,len(piles)-int(len(piles)/3),2):\\n            sum += piles[i]\\n            print(sum)\\n        return sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081901,
                "title": "java-o-n-4ms-solution",
                "content": "From the constraints we know the max value ```piles[i]``` is 10^4 (relatively small), and the max length of ```piles``` is 10^5. We can save all the possible values to a smaller array ```shrinkArr```, and use another array ```feqArr``` to keep track the fequency of the values appear in ```piles```.\\n\\n```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        int[] feqArr = new int[10001];\\n        int size = 0;\\n        for(int each : piles){\\n            if(feqArr[each] == 0){\\n                size++;\\n            }\\n            feqArr[each]++;\\n        }\\n        int[] shrinkArr = new int[size];\\n        int ind = 0;\\n        for(int i = 0; i < feqArr.length; ++i){\\n            if(feqArr[i] > 0)shrinkArr[ind++] = i;\\n        }\\n        \\n        int index = size - 1;\\n        int feq = piles.length / 3;\\n        int ret = 0;\\n        int at = 0;\\n        while(feq > 0){\\n            int hi = shrinkArr[index];\\n            int tune = feqArr[hi] + at;\\n            if(tune > 1){\\n                int p = tune / 2;\\n                ret += (p > feq? feq : p) * hi;\\n                feq -= p;\\n                \\n            }\\n            at = tune % 2;\\n            index--;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```piles[i]```\n```piles```\n```shrinkArr```\n```feqArr```\n```piles```\n```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        int[] feqArr = new int[10001];\\n        int size = 0;\\n        for(int each : piles){\\n            if(feqArr[each] == 0){\\n                size++;\\n            }\\n            feqArr[each]++;\\n        }\\n        int[] shrinkArr = new int[size];\\n        int ind = 0;\\n        for(int i = 0; i < feqArr.length; ++i){\\n            if(feqArr[i] > 0)shrinkArr[ind++] = i;\\n        }\\n        \\n        int index = size - 1;\\n        int feq = piles.length / 3;\\n        int ret = 0;\\n        int at = 0;\\n        while(feq > 0){\\n            int hi = shrinkArr[index];\\n            int tune = feqArr[hi] + at;\\n            if(tune > 1){\\n                int p = tune / 2;\\n                ret += (p > feq? feq : p) * hi;\\n                feq -= p;\\n                \\n            }\\n            at = tune % 2;\\n            index--;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 970806,
                "title": "java-solution-with-explanation",
                "content": "The best way to give Bob the minimum is to give him the lowest value in each iteration, and give the highest to other person. Now keep the second highest, at end of this you\\'ve exhausted lowest and highest and second highest. Now give second lowest, 3rd highest and keep 4th highest for yourself.\\n\\nSo we need to sort the array, reserve bottom 3rd portion for Bob as we\\'re mean, and start from end of array and take \\nn-1th element as (nth -> largest) (1st run -> a[0], a[n-1], a[n])\\nn-3th element as (n-2th -> largest) remaining (2nd run -> a[1], a[n-3], a[n-2])\\n\\nnow you can see the pattern emerge.....\\n\\n`public int maxCoins(int[] piles) {`\\n\\n        int result=0;\\n        Arrays.sort(piles);\\n        \\n        for(int i=piles.length-2; i>= piles.length/3; i-=2){\\n            result+= piles[i];\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "The best way to give Bob the minimum is to give him the lowest value in each iteration, and give the highest to other person. Now keep the second highest, at end of this you\\'ve exhausted lowest and highest and second highest. Now give second lowest, 3rd highest and keep 4th highest for yourself.\\n\\nSo we need to sort the array, reserve bottom 3rd portion for Bob as we\\'re mean, and start from end of array and take \\nn-1th element as (nth -> largest) (1st run -> a[0], a[n-1], a[n])\\nn-3th element as (n-2th -> largest) remaining (2nd run -> a[1], a[n-3], a[n-2])\\n\\nnow you can see the pattern emerge.....\\n\\n`public int maxCoins(int[] piles) {`\\n\\n        int result=0;\\n        Arrays.sort(piles);\\n        \\n        for(int i=piles.length-2; i>= piles.length/3; i-=2){\\n            result+= piles[i];\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 818695,
                "title": "ruby-solution",
                "content": "```\\ndef max_coins(piles)\\n    piles.sort![(piles.size/3)...(piles.size)].select.with_index { |y,x| x%2==0 }.sum\\nend\\n```\\n\\nExplanation:\\nSort  the piles and assign first(lowest set) to Bob.(first 1/3rd of pile)\\nFor the remaining values, select second largest from each set of 2 and then add them at the end.\\n",
                "solutionTags": [],
                "code": "```\\ndef max_coins(piles)\\n    piles.sort![(piles.size/3)...(piles.size)].select.with_index { |y,x| x%2==0 }.sum\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 815248,
                "title": "c-one-liner",
                "content": "```\\npublic int MaxCoins(int[] piles) => piles\\n\\t.OrderByDescending(x => x)\\n\\t.Select((x, i) => (x, i))\\n\\t.Where(t => t.i % 2 == 1)\\n\\t.Take(piles.Length / 3)\\n\\t.Sum(t => t.x);\\n```",
                "solutionTags": [],
                "code": "```\\npublic int MaxCoins(int[] piles) => piles\\n\\t.OrderByDescending(x => x)\\n\\t.Select((x, i) => (x, i))\\n\\t.Where(t => t.i % 2 == 1)\\n\\t.Take(piles.Length / 3)\\n\\t.Sum(t => t.x);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 807163,
                "title": "python-sort",
                "content": "\\tclass Solution(object):\\n\\t\\tdef maxCoins(self, piles):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type piles: List[int]\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tn = len(piles) // 3\\n\\t\\t\\tpiles = sorted(piles)\\n\\t\\t\\tarr = piles[n::]\\n\\t\\t\\tres = arr[0]\\n\\t\\t\\ti = 0\\n\\n\\t\\t\\twhile i < len(arr) - 2:\\n\\t\\t\\t\\tres = res + arr[i+2]\\n\\t\\t\\t\\ti += 2\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution(object):\\n\\t\\tdef maxCoins(self, piles):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type piles: List[int]\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tn = len(piles) // 3\\n\\t\\t\\tpiles = sorted(piles)\\n\\t\\t\\tarr = piles[n::]\\n\\t\\t\\tres = arr[0]\\n\\t\\t\\ti = 0\\n\\n\\t\\t\\twhile i < len(arr) - 2:\\n\\t\\t\\t\\tres = res + arr[i+2]\\n\\t\\t\\t\\ti += 2\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 807145,
                "title": "c-simple-sorting-solution",
                "content": "example:- 987651234\\nwe will sort it first, so we have :- 123456789\\nwe have two pointers, i and j;\\nj will show the pile that we will have for ourselves and i will show the one for Bob.\\nevery time we will have 3 piles of coin so we will be picking max pile, 2nd max pile, and minimum pile.\\nso in first case it will be:- 9,8,1  j will point to 8 and i to 1. we will add 8 to the answer.\\nNow max will be 7 so 2nd max to which j will point will be 6 and min to which i will point will be 2, (7,6,2) so we will add 6 to answer.\\nAgain now max will be 5, 2nd max to which j will point will be 4 and min to which i will point will be 3 (5,4,3) so we add 4 to our answer. \\nanswer=8+6+4=18\\nwe will be giving the global minima to bob everytime and having the 2nd max number for ourselves.\\nIf you find the explanation helpful then please upvote.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end());\\n        int i=0,j=piles.size()-2;\\n        int ans=0;\\n        while(j-i>=1){\\n            ans+=piles[j];\\n            j-=2;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end());\\n        int i=0,j=piles.size()-2;\\n        int ans=0;\\n        while(j-i>=1){\\n            ans+=piles[j];\\n            j-=2;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806727,
                "title": "java-simple-sort",
                "content": "Sort first, \\nEasy to find that Bob will have the lowest third, then you have every lower one from a pair.\\n```\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int n = piles.length, res = 0;\\n        for (int i = n / 3; i < n; i+= 2) res += piles[i];\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int n = piles.length, res = 0;\\n        for (int i = n / 3; i < n; i+= 2) res += piles[i];\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4098004,
                "title": "simple-solution-with-sorting-in-python3-typescript",
                "content": "# Intuition\\nThe problem description is the following:\\n- there\\'s a list of `piles` with coins, that\\'s distributed between three participants in some rules\\n- our goal is to find the maximum score we can achieve as **the second player**\\n\\n```\\n# There\\'re three participants.\\n# The first one is going to get a maximum\\n# amount of coins.\\n# The second one is you, that gets\\n# the next largest amount.\\n# The last one gets the least amount.\\n```\\n\\nThis is the classic example of using **Greedy approach** with sorting.\\n\\nWe\\'re going to use **pointer** to calculate the maximum amount of coins.\\n\\n# Approach\\n1. sort `piles` in descending order\\n2. define `count` as amount of cycle repetitions to iterate over\\n3. declare `ans = 0` and `pointer = 1`\\n4. iterate over `count`\\n5. sum up `piles[pointer]`\\n6. return ans\\n\\n# Complexity\\n- Time complexity: **O(nlogn)**, to sort `piles`\\n\\n- Space complexity: **O(1)**, we don\\'t allocate extra space.\\n\\n# Code in TypeScript\\n```\\nfunction maxCoins(piles: number[]): number {\\n    piles.sort((a, b) => b - a)\\n    let count = piles.length / 3\\n    let ans = 0\\n    let pointer = 1\\n\\n    while (count) {\\n        count--\\n        ans += piles[pointer]\\n        pointer += 2\\n    }\\n\\n    return ans\\n};\\n```\\n# Code in Python\\n```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles.sort(reverse=True)\\n        count = len(piles) / 3\\n        ans = 0\\n        pointer = 1\\n\\n        while count:\\n            count -= 1\\n            ans += piles[pointer]\\n            pointer += 2\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n# There\\'re three participants.\\n# The first one is going to get a maximum\\n# amount of coins.\\n# The second one is you, that gets\\n# the next largest amount.\\n# The last one gets the least amount.\\n```\n```\\nfunction maxCoins(piles: number[]): number {\\n    piles.sort((a, b) => b - a)\\n    let count = piles.length / 3\\n    let ans = 0\\n    let pointer = 1\\n\\n    while (count) {\\n        count--\\n        ans += piles[pointer]\\n        pointer += 2\\n    }\\n\\n    return ans\\n};\\n```\n```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles.sort(reverse=True)\\n        count = len(piles) / 3\\n        ans = 0\\n        pointer = 1\\n\\n        while count:\\n            count -= 1\\n            ans += piles[pointer]\\n            pointer += 2\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085005,
                "title": "solution-of-maximum-number-of-coins-you-can-get-problem",
                "content": "# Approach\\nWinning strategy is to take the second highest number in the list for each triplet. Then our program consists of 3 parts:\\n- Step one:\\nSort the list so that it starts with the maximum number\\n- Step two:\\nTake the second maximum number from the list(As we need to make triplets with two highest numbers to get maximum answer)\\n- Step three:\\nTake the next pair of maximum numbers\\n- Continue this process until the required number of operations have been completed(len(piles) // 3 - as the list is 3n long )\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$ - as sorting the array takes $$O(nlogn)$$ time and two-pointer\\nalgorithm takes linear time, $$O(n)$$ --> $$O(nlogn+n)$$ == $$O(nlogn)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles.sort(reverse=True)\\n        pos = 1\\n        answer = 0\\n        for i in range(len(piles) // 3):\\n            answer += piles[pos]\\n            pos += 2\\n        return answer\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles.sort(reverse=True)\\n        pos = 1\\n        answer = 0\\n        for i in range(len(piles) // 3):\\n            answer += piles[pos]\\n            pos += 2\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022799,
                "title": "easy-solution-java-with-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we have to take groups of three, the groups should contain 2 largest numbers and one smallest number. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. sort the list\\n2. traverse using two pointers such that second largest element is added to the total ans and end pointer moves two spaces (because 2 elements were considered) and start pointer moves one (one smallest element is taken in the group).\\n\\n# Complexity\\n- Time complexity: O(nlogn) (because of sorting)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int sum=0;\\n        int i=0;       //start index\\n        int j=piles.length-1;    //end index\\n        while(i<j){\\n            sum+=piles[j-1];\\n            j=j-2;\\n            i++;\\n        }\\n        return sum;    \\n    }\\n}\\n\\n```\\n# PYTHON SOLUTION\\n\\n# Code\\n```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles.sort()\\n        sum=0\\n        i=0\\n        j=len(piles)-1\\n        while(i<j):\\n            sum+=piles[j-1]\\n            j-=2\\n            i+=1\\n        return sum\\n\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int sum=0;\\n        int i=0;       //start index\\n        int j=piles.length-1;    //end index\\n        while(i<j){\\n            sum+=piles[j-1];\\n            j=j-2;\\n            i++;\\n        }\\n        return sum;    \\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles.sort()\\n        sum=0\\n        i=0\\n        j=len(piles)-1\\n        while(i<j):\\n            sum+=piles[j-1]\\n            j-=2\\n            i+=1\\n        return sum\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927113,
                "title": "c-javascript-easy-solution",
                "content": "# Approach\\n- First, arrange the piles of coins from largest to smallest. \\n- Then, calculate the number of rounds we can play. In each round, we pick the second-largest pile.\\n\\nFinally, it returns the total number of collected coins.\\n\\n# Complexity\\n- Time complexity: O(n log n)\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        int ans=0;\\n        sort(piles.begin(), piles.end(), greater<int>());\\n        int len=piles.size()/3;\\n        for(int i=1;i<piles.size()-len;i+=2){\\n            ans+=piles[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# JavaScript\\n```\\n/**\\n * @param {number[]} piles\\n * @return {number}\\n */\\nvar maxCoins = function(piles) {\\n    let ans=0;\\n    piles.sort((a, b) => b - a);\\n    let len=piles.length/3;\\n    for(let i=1;i<piles.length-len;i+=2){\\n        ans+=piles[i];\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "JavaScript",
                    "Array",
                    "Math",
                    "Greedy",
                    "Sorting",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        int ans=0;\\n        sort(piles.begin(), piles.end(), greater<int>());\\n        int len=piles.size()/3;\\n        for(int i=1;i<piles.size()-len;i+=2){\\n            ans+=piles[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n/**\\n * @param {number[]} piles\\n * @return {number}\\n */\\nvar maxCoins = function(piles) {\\n    let ans=0;\\n    piles.sort((a, b) => b - a);\\n    let len=piles.length/3;\\n    for(let i=1;i<piles.length-len;i+=2){\\n        ans+=piles[i];\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918746,
                "title": "easy-greedy-approach-in-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        int max=0;\\n        Arrays.sort(piles);\\n        int temp=piles.length/3;\\n        for(int i=piles.length-2;temp-- >0;i-=2){\\n            max+=piles[i];\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Greedy",
                    "Sorting",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        int max=0;\\n        Arrays.sort(piles);\\n        int temp=piles.length/3;\\n        for(int i=piles.length-2;temp-- >0;i-=2){\\n            max+=piles[i];\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782791,
                "title": "sorting-greedy-solution-with-a-small-improvement-beats-100-98-ms",
                "content": "# Intuition\\nIf you understood the sorting greedy solution then I would like to present a small improvement. The initial idea was to sort the piles and give n/3 smallest piles to Bob, Alice takes each second biggest pile and you have what\\'s left. But we actually don\\'t need to sort smallest n/3 piles, that\\'s why we can just do partition (Fortunately, C++ has a function named nth_element) and sort higher 2/3 of the piles.\\n# Approach\\n\\n# Complexity\\n- Time complexity: n (partition) + 2n/3 * log(2n/3) (sorting)\\n\\n- Space complexity: log(2n/3) (for call stack of recursive sorting algorithm)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    Solution() {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n    }\\n\\n    int maxCoins(vector<int> &piles) {\\n        int n = piles.size();\\n        int third = n / 3;\\n        nth_element(piles.begin(), piles.begin() + third, piles.end());\\n        sort(piles.begin() + third, piles.end());\\n        int sum = 0;\\n        for(int i = third; i < n; i += 2) {\\n            sum += piles[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution() {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n    }\\n\\n    int maxCoins(vector<int> &piles) {\\n        int n = piles.size();\\n        int third = n / 3;\\n        nth_element(piles.begin(), piles.begin() + third, piles.end());\\n        sort(piles.begin() + third, piles.end());\\n        int sum = 0;\\n        for(int i = third; i < n; i += 2) {\\n            sum += piles[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3714056,
                "title": "easiest-simple-c-java-python-solution-with-approach",
                "content": "# Approach\\n- The sort function is used to sort the piles vector in ascending order. This step ensures that the piles of coins are arranged from smallest to largest.\\n\\n- The variable j is initialized to the index of the last pile (i.e., piles.size() - 1), and the variable ans is initialized to 0. These variables will be used to keep track of the current index and the sum of coins you have selected.\\n\\n- The for loop iterates piles.size()/3 times. This is because in each iteration, you and your friends select three piles of coins. Since there are 3n piles, there will be n iterations in total.\\n\\n- Inside the loop, the variable j is decremented by 1. This is because Alice picks the pile with the maximum number of coins, so you need to move to the next pile for your turn.\\n\\n- The value of the current pile (piles[j]) is added to the ans variable to keep track of the sum of coins you have selected.\\n\\n- After that, the variable j is decremented by 1 again. This step accounts for Bob\\'s turn to pick a pile. Since you don\\'t select a pile during Bob\\'s turn, you move to the next pile by decrementing j.\\n\\n- Finally, after the loop finishes, the function returns the value of ans, which represents the maximum number of coins you can have.\\n\\n---\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\nDue to sorting function.\\n\\n- Space complexity:\\n$$O(1)$$\\n---\\n# Code\\n```java []\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int j = piles.length - 1;\\n        int ans = 0;\\n        for (int i = 0; i < piles.length / 3; i++) {\\n            j--;\\n            ans += piles[j];\\n            j--;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def maxCoins(self, piles):\\n        piles.sort()\\n        j = len(piles) - 1\\n        ans = 0\\n        for i in range(len(piles) // 3):\\n            j -= 1\\n            ans += piles[j]\\n            j -= 1\\n        return ans\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end());\\n        int j=piles.size()-1,ans=0;\\n        for(int i =0;i<piles.size()/3;i++){\\n            j--;\\n            ans += piles[j];\\n            j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```java []\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int j = piles.length - 1;\\n        int ans = 0;\\n        for (int i = 0; i < piles.length / 3; i++) {\\n            j--;\\n            ans += piles[j];\\n            j--;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def maxCoins(self, piles):\\n        piles.sort()\\n        j = len(piles) - 1\\n        ans = 0\\n        for i in range(len(piles) // 3):\\n            j -= 1\\n            ans += piles[j]\\n            j -= 1\\n        return ans\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end());\\n        int j=piles.size()-1,ans=0;\\n        for(int i =0;i<piles.size()/3;i++){\\n            j--;\\n            ans += piles[j];\\n            j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622449,
                "title": "easiest-solution-explained-java-99-faster",
                "content": "# Intuition\\n\\n1. first dort and  make the triplets as smallest , middle and largest .\\n2. you want the middle numbers to add in ur answers\\n3. run the while loop till the left index is smaller than the mid index\\n4. after each iteration increase l and reduce m and r by 2  \\n\\n![intution.jpeg](https://assets.leetcode.com/users/images/a80b729d-97d0-4313-9576-8cb9c4974f0e_1686413631.2815382.jpeg)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        int n = piles.length;\\n        Arrays.sort(piles);\\n        int ans=0;\\n        int l=0, m=n-2, r= n-1;\\n        while(l<m){\\n            ans+= piles[m];\\n            l++;\\n            m-=2;\\n            r-=2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        int n = piles.length;\\n        Arrays.sort(piles);\\n        int ans=0;\\n        int l=0, m=n-2, r= n-1;\\n        while(l<m){\\n            ans+= piles[m];\\n            l++;\\n            m-=2;\\n            r-=2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394684,
                "title": "c-easiest-solution-with-intuition",
                "content": "# Intuition\\nAs we need to pick the second largest element of every group of 3. \\n\\n# Approach\\nWe will sort the array, initialise an interger m = size/3. \\'m\\' means how many times we will form a group of 3 and take out second largest element.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end());\\n        \\n        int size  = piles.size();\\n        int m = size/3;\\n        int ans = 0;\\n        while(m--){\\n            ans = ans + piles[size-2];\\n            size-=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end());\\n        \\n        int size  = piles.size();\\n        int m = size/3;\\n        int ans = 0;\\n        while(m--){\\n            ans = ans + piles[size-2];\\n            size-=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128344,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} piles\\n * @return {number}\\n */\\nvar maxCoins = function (piles) {\\nlet sorted =piles.sort((a,b)=>b-a)\\nconsole.log(sorted)\\nlet res =0\\nlet yourChoices = piles.length /3\\nfor(let j=0;j<=yourChoices+yourChoices-1;j++){\\nres+= sorted[j+1]\\nj++\\n}\\nreturn res\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} piles\\n * @return {number}\\n */\\nvar maxCoins = function (piles) {\\nlet sorted =piles.sort((a,b)=>b-a)\\nconsole.log(sorted)\\nlet res =0\\nlet yourChoices = piles.length /3\\nfor(let j=0;j<=yourChoices+yourChoices-1;j++){\\nres+= sorted[j+1]\\nj++\\n}\\nreturn res\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3055437,
                "title": "c-using-sorting-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles)\\n    {\\n        sort(piles.begin(),piles.end());\\n        int n = piles.size();\\n        int ans = 0;\\n        for(int i=n/3;i<n;i=i+2)\\n        {\\n            ans = ans + piles[i];\\n        }\\n        return ans;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles)\\n    {\\n        sort(piles.begin(),piles.end());\\n        int n = piles.size();\\n        int ans = 0;\\n        for(int i=n/3;i<n;i=i+2)\\n        {\\n            ans = ans + piles[i];\\n        }\\n        return ans;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018407,
                "title": "easy-c-soln-time-o-nlogn-space-o-1",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n      sort(piles.begin(),piles.end());\\n      int i=0;\\n      int j=piles.size()-1;\\n      int k=j-1;\\n      int sum=0;\\n      while(k>i)\\n      {\\n          sum+=piles[k];\\n          j-=2;\\n          k-=2;\\n          i++;\\n      }  \\n      return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n      sort(piles.begin(),piles.end());\\n      int i=0;\\n      int j=piles.size()-1;\\n      int k=j-1;\\n      int sum=0;\\n      while(k>i)\\n      {\\n          sum+=piles[k];\\n          j-=2;\\n          k-=2;\\n          i++;\\n      }  \\n      return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934641,
                "title": "python-easy-to-understand-solution-80-80",
                "content": "The problem can be simplified as:\\n\\n**Select all second alternate elements from a reverse sorted array of size 3n, till you have n elements**\\n\\n---\\n\\n[9, **8**, 7, **6**, 5, **4**, 3, 2, 1]\\nn=3\\n\\n---\\n\\n# Code\\n```\\nclass Solution:\\n    def maxCoins(self, piles: list[int]) -> int:\\n        # sort array in descending order\\n        piles.sort(reverse=True)\\n        # keep track of total\\n        total: int = 0\\n        # value of n\\n        n: int = int(len(piles)/3)\\n\\n        i: int = 0\\n        while n > 0:\\n            # second alternate element\\n            if i % 2 == 1:\\n                # adding to total\\n                total += piles[i]\\n                # decrementing n\\n                n -= 1\\n            i += 1\\n        return total\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCoins(self, piles: list[int]) -> int:\\n        # sort array in descending order\\n        piles.sort(reverse=True)\\n        # keep track of total\\n        total: int = 0\\n        # value of n\\n        n: int = int(len(piles)/3)\\n\\n        i: int = 0\\n        while n > 0:\\n            # second alternate element\\n            if i % 2 == 1:\\n                # adding to total\\n                total += piles[i]\\n                # decrementing n\\n                n -= 1\\n            i += 1\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2911733,
                "title": "java-simple-beats-100-game-theory",
                "content": "# Complexity\\n- Time complexity: O(N log N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int n = piles.length/3, sum = 0;\\n        for(int i = piles.length - 2 ; n > 0; i = i-2, n--){\\n            sum += piles[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Brainteaser",
                    "Game Theory"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int n = piles.length/3, sum = 0;\\n        for(int i = piles.length - 2 ; n > 0; i = i-2, n--){\\n            sum += piles[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885282,
                "title": "greedy-short-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nChoose 3 indeces, choose the second largest in the current array as the one you will pick, remove it with the current smllest and the largest element.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end());\\n        int mx = 0,n = piles.size();\\n\\n        for(int i=0;i<n/3;++i){\\n            mx += piles[n-i*2-2];\\n        }\\n        \\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end());\\n        int mx = 0,n = piles.size();\\n\\n        for(int i=0;i<n/3;++i){\\n            mx += piles[n-i*2-2];\\n        }\\n        \\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881458,
                "title": "sort-it-and-give-min-to-bob-highest-to-alice",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& p) {\\n        sort(p.begin(),p.end());\\n        int n = p.size();\\n        int res = 0;\\n        int start = n/3;\\n        for(int i=start;i<n;i+=2)\\n        {\\n            res+=p[i];\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& p) {\\n        sort(p.begin(),p.end());\\n        int n = p.size();\\n        int res = 0;\\n        int start = n/3;\\n        for(int i=start;i<n;i+=2)\\n        {\\n            res+=p[i];\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788587,
                "title": "java-most-simple-solution",
                "content": "class Solution {\\n    public int maxCoins(int[] piles) { \\n        \\n        Arrays.sort(piles);\\n        int ans = 0;\\n        int checking = 0;\\n        int main = piles.length/3;\\n        for(int i = piles.length-2; i>=0 ; i=i-2){\\n            ans = ans+piles[i];  \\n            checking += 1;\\n            if(checking == main){\\n                break;\\n            }       \\n        }\\n        return ans;\\n         \\n    }\\n    \\n   \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxCoins(int[] piles) { \\n        \\n        Arrays.sort(piles);\\n        int ans = 0;\\n        int checking = 0;\\n        int main = piles.length/3;\\n        for(int i = piles.length-2; i>=0 ; i=i-2){\\n            ans = ans+piles[i];  \\n            checking += 1;\\n            if(checking == main){\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2774126,
                "title": "easy-java-solution-sort-and-add",
                "content": "```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n            Arrays.sort(piles);\\n      int k=0;\\n        int sum=0;\\n        int idx= piles.length-2;\\n        while(k!= ((piles.length)/3) ){\\n            sum=sum+piles[idx];\\n            idx=idx-2;\\n            k++;\\n        }\\n     return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n            Arrays.sort(piles);\\n      int k=0;\\n        int sum=0;\\n        int idx= piles.length-2;\\n        while(k!= ((piles.length)/3) ){\\n            sum=sum+piles[idx];\\n            idx=idx-2;\\n            k++;\\n        }\\n     return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2660362,
                "title": "c-easy-to-understand-two-pointers",
                "content": "The whole problem is about what triplet should you choose so that you get the maximum number of coins.\\nThink about the element you can have..There are two things you must have noticed..\\n**1.** You can\\'t have the maximum element in the triplet for yourself.\\n**2.** However, you can give the smallest one to Alice.\\nHence, your triplet should look somewhat like this....\\n**{smallest ,second largest ,largest}**\\nAs there is no way you can have the largest one.\\n*That is we sort the piles of coins.*\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        int n = piles.size();\\n        //sorting the piles\\n        sort(piles.begin(),piles.end());\\n        //initializing the pointers\\n        int i = 0;\\n        int j = n-1;\\n        int sol = 0;\\n        \\n        while(i<j)\\n        { \\n            j--;\\n            i++;\\n            //you will only choose the middle element of the triplet.\\n            sol += piles[j];\\n            j--;\\n        }\\n        return sol;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        int n = piles.size();\\n        //sorting the piles\\n        sort(piles.begin(),piles.end());\\n        //initializing the pointers\\n        int i = 0;\\n        int j = n-1;\\n        int sol = 0;\\n        \\n        while(i<j)\\n        { \\n            j--;\\n            i++;\\n            //you will only choose the middle element of the triplet.\\n            sol += piles[j];\\n            j--;\\n        }\\n        return sol;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617953,
                "title": "simple-3-lines-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n       int l= piles.size()- (piles.size()/3);  int sum=0;\\n        sort(piles.begin(),piles.end(),greater());\\n        for(int i=1;i<l;i++)\\n            sum+=piles[i++];\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n       int l= piles.size()- (piles.size()/3);  int sum=0;\\n        sort(piles.begin(),piles.end(),greater());\\n        for(int i=1;i<l;i++)\\n            sum+=piles[i++];\\n        return sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2615347,
                "title": "time-nlog-n-space-95-beats-easy-simple-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        int ans = 0, n = piles.size();\\n        int k = n/3;\\n        sort(piles.begin(),piles.end());\\n        while(k--){\\n            n-=2;\\n            ans += piles[n];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        int ans = 0, n = piles.size();\\n        int k = n/3;\\n        sort(piles.begin(),piles.end());\\n        while(k--){\\n            n-=2;\\n            ans += piles[n];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585103,
                "title": "best-easy-way-iterative-option-greedy-approach",
                "content": "# 1. If we focus on the third case we can see there is 3 possible pair : \\n\\t1. 9,8,1\\n\\t2. 7,6,2\\n\\t3. 5,4,3\\n\\tso we first sort it 9,8,7,6,5,4,3,2,1\\n# 2. Now we will take only 2nd element to count; 8,6,4\\n# 3. So we iterate our loop 1,3,5 th position;\\nSolve below : \\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        \\n        int sum = 0;\\n        sort(piles.begin(),piles.end(),greater<int>());\\n        \\n        for(int i=1;i<=(piles.size()/3)*2;i+=2)\\n        {\\n            sum+=piles[i];\\n        }\\n        return sum;\\n        \\n    }\\n};\\n```\\n\\n# please upvote if u like the solution;",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        \\n        int sum = 0;\\n        sort(piles.begin(),piles.end(),greater<int>());\\n        \\n        for(int i=1;i<=(piles.size()/3)*2;i+=2)\\n        {\\n            sum+=piles[i];\\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490795,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles=sorted(piles)\\n        n=len(piles)-2\\n        c=0\\n        b=len(piles)//3\\n        for i in range(b):\\n            c+=piles[n]\\n            n-=2\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles=sorted(piles)\\n        n=len(piles)-2\\n        c=0\\n        b=len(piles)//3\\n        for i in range(b):\\n            c+=piles[n]\\n            n-=2\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489189,
                "title": "easy",
                "content": "```\\n public int maxCoins(int[] p) {\\n        Arrays.sort(p);\\n        int i=p.length-2;\\n        int ans=0;\\n        for(int j=0;j<p.length/3;j++){\\n            ans+=p[i];\\n            i-=2;\\n            \\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int maxCoins(int[] p) {\\n        Arrays.sort(p);\\n        int i=p.length-2;\\n        int ans=0;\\n        for(int j=0;j<p.length/3;j++){\\n            ans+=p[i];\\n            i-=2;\\n            \\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2452293,
                "title": "c-easiest-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        \\n        int alice_score=0;\\n        int my_score=0;\\n        int bob_score=0;\\n        \\n        sort(piles.begin(),piles.end(),greater<int>());\\n        \\n        int temp1=0;\\n        int temp2=1;\\n        int temp3=piles.size()-1;\\n        \\n        while(temp2<temp3)\\n        {\\n            alice_score=alice_score+piles[temp1];\\n            my_score=my_score+piles[temp2];\\n            bob_score=bob_score+piles[temp3];\\n            \\n            temp1=temp1+2;\\n            temp2=temp2+2;\\n            temp3--;\\n        }\\n        return my_score;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        \\n        int alice_score=0;\\n        int my_score=0;\\n        int bob_score=0;\\n        \\n        sort(piles.begin(),piles.end(),greater<int>());\\n        \\n        int temp1=0;\\n        int temp2=1;\\n        int temp3=piles.size()-1;\\n        \\n        while(temp2<temp3)\\n        {\\n            alice_score=alice_score+piles[temp1];\\n            my_score=my_score+piles[temp2];\\n            bob_score=bob_score+piles[temp3];\\n            \\n            temp1=temp1+2;\\n            temp2=temp2+2;\\n            temp3--;\\n        }\\n        return my_score;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410067,
                "title": "simple-java-solution-8-lines",
                "content": "1. Sorting the array in ascending order \\n2. Picking pairs of 2 max values from the end and choosing lesser one and repeating this piles.length / 3 times. In other words, I build such a triplet on each iteration, that I have two max values and one min value. That\\'s why I choose lesser one from two max numbers on each iteration.\\n```\\npublic int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int sum = 0;\\n        int index = piles.length - 2;\\n        for (int i = 0; i < piles.length / 3; i++) {\\n            sum +=  piles[index];\\n            index -= 2;\\n        }\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "1. Sorting the array in ascending order \\n2. Picking pairs of 2 max values from the end and choosing lesser one and repeating this piles.length / 3 times. In other words, I build such a triplet on each iteration, that I have two max values and one min value. That\\'s why I choose lesser one from two max numbers on each iteration.\\n```\\npublic int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int sum = 0;\\n        int index = piles.length - 2;\\n        for (int i = 0; i < piles.length / 3; i++) {\\n            sum +=  piles[index];\\n            index -= 2;\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2382105,
                "title": "c-faster-then-97-86-very-easy-solution-using-sorting-intution-o-nlogn",
                "content": "The main Idea to solve this questin is that alice will pick the piles with maximum number of coins from the randomly selected 3 piles ,you will pick the piles with second maximum no. of coins and bob will pick the left pile from the randomly selected 3 piles.\\n\\nAPPROACH - sort the given array.\\nNow in the sorted array assume that there is a group of three piles by taking the last two piles which has the maximum coins and the first one piles which has the minimum no. of coins which is going to be taken by bob.\\n\\nNow you will take the second last piles ,similarly you will move two index back and take the pile.now will will repeat this process n/3 no. of times and you will store the no. of coins in each piles taken by you in a variable sum which you will return .\\n\\nBelow is the C++ code , if you didn\\'t understand ,Plz do a dry run ,you will understand.\\n```\\nint maxCoins(vector<int>& piles) {\\n        \\n        sort(piles.begin(),piles.end());\\n        \\n        int k=piles.size()/3;    // k is the no. of times you will pick a pile\\n        \\n        int sum = 0;  //store the  no. of coins you will pick\\n        \\n        int i = piles.size()-2;  //i is a pointer to the piles that you will pick\\n        \\n        while(k--)\\n        {\\n            sum+=piles[i];\\n            i-=2;\\n        }\\n        return sum;\\n    }\\n```\\n\\nif you have understand this solution,please upvote it.",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nint maxCoins(vector<int>& piles) {\\n        \\n        sort(piles.begin(),piles.end());\\n        \\n        int k=piles.size()/3;    // k is the no. of times you will pick a pile\\n        \\n        int sum = 0;  //store the  no. of coins you will pick\\n        \\n        int i = piles.size()-2;  //i is a pointer to the piles that you will pick\\n        \\n        while(k--)\\n        {\\n            sum+=piles[i];\\n            i-=2;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2356861,
                "title": "easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end(),greater<int>());\\n        int myPilesCount=0;\\n        int myPilesSum=0;\\n        int PilesSize=piles.size();\\n        int i=1;\\n        while(myPilesCount<(PilesSize/3))\\n        {\\n           \\n            myPilesSum+=piles[i];\\n            myPilesCount++;\\n            i+=2;\\n        }\\n        return myPilesSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end(),greater<int>());\\n        int myPilesCount=0;\\n        int myPilesSum=0;\\n        int PilesSize=piles.size();\\n        int i=1;\\n        while(myPilesCount<(PilesSize/3))\\n        {\\n           \\n            myPilesSum+=piles[i];\\n            myPilesCount++;\\n            i+=2;\\n        }\\n        return myPilesSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345128,
                "title": "python-easy-to-read-and-understand",
                "content": "```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles.sort()\\n        n = len(piles)\\n        k = n // 3\\n        i, j = 0, 2\\n        ans = 0\\n        while i < k:\\n            ans += piles[n-j]\\n            j += 2\\n            i +=1\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles.sort()\\n        n = len(piles)\\n        k = n // 3\\n        i, j = 0, 2\\n        ans = 0\\n        while i < k:\\n            ans += piles[n-j]\\n            j += 2\\n            i +=1\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2307645,
                "title": "simple-and-fastest-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int s=0,n=piles.length;\\n        for(int i=n/3;i<n;i+=2)\\n            s+=piles[i];\\n        return s;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int s=0,n=piles.length;\\n        for(int i=n/3;i<n;i+=2)\\n            s+=piles[i];\\n        return s;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2299541,
                "title": "simplest-explanation-time-o-1-space-o-1-explained",
                "content": "# The Idea: \\nGive to my self as max piles as possible in every round.\\nSo we to sort the array , and then  make piles with 2 pile from right hand side and one pile from left hand\\nand do this **piles.length/3** times , since, total rounds of this game will be n times if sizes of pile is 3n and every time we take out 3 piles for a round.\\n\\nExample:\\npiles = [9,8,7,6,5,1,2,3,4]\\n\\ninitialize mySum=0;\\nsort it => piles=[1,2,3,4,5,6,7,8,9]\\nround 1 , take [1,8,9]  , mySum =8 , piles become [2,3,4,5,6,7]\\nrount 2 ,  take [2,6,7]  , mySum =8+6 , piles become [3,4,5]\\nround 3, take [3,4,5]  , mySum =14+4 , piles become []\\nans=18\\n```\\nvar maxCoins = function(piles) {\\n    piles.sort((a,b)=>a-b)\\n    let j=piles.length-2,\\n\\tans=0;\\n    for(let i=0;i<piles.length/3;i++){\\n        ans+=piles[j];\\n        j=j-2;\\n    }\\n    return ans;\\n};\\n```\\n\\n***Do upvote if it helped! TIA ;)***",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nvar maxCoins = function(piles) {\\n    piles.sort((a,b)=>a-b)\\n    let j=piles.length-2,\\n\\tans=0;\\n    for(let i=0;i<piles.length/3;i++){\\n        ans+=piles[j];\\n        j=j-2;\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2281990,
                "title": "60-tc-and-78-sc-easy-python-solution",
                "content": "```\\ndef maxCoins(self, piles: List[int]) -> int:\\n\\tans = 0\\n\\tpiles.sort()\\n\\tn = len(piles)\\n\\ti, j = 0, n-1\\n\\twhile(i < j):\\n\\t\\ti += 1\\n\\t\\tans += piles[j-1]\\n\\t\\tj -= 2\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\ndef maxCoins(self, piles: List[int]) -> int:\\n\\tans = 0\\n\\tpiles.sort()\\n\\tn = len(piles)\\n\\ti, j = 0, n-1\\n\\twhile(i < j):\\n\\t\\ti += 1\\n\\t\\tans += piles[j-1]\\n\\t\\tj -= 2\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2269470,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end(),greater<int>());\\n        \\n        int x=piles.size()/3;\\n        int sum=0;\\n        for(int i=1;i<x*2;i+=2)\\n        {\\n            sum+=piles[i];\\n        }\\n        return sum;\\n    }\\n};\\n```\\nUpvote if you like the solution",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end(),greater<int>());\\n        \\n        int x=piles.size()/3;\\n        int sum=0;\\n        for(int i=1;i<x*2;i+=2)\\n        {\\n            sum+=piles[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2215118,
                "title": "short-simple-and-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        int ans = 0, picks = piles.size() / 3;\\n        \\n        sort(piles.begin(), piles.end(), greater<int>());\\n       \\n        for(int i=1; i<piles.size() && picks; i += 2) ans += piles[i], picks--;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        int ans = 0, picks = piles.size() / 3;\\n        \\n        sort(piles.begin(), piles.end(), greater<int>());\\n       \\n        for(int i=1; i<piles.size() && picks; i += 2) ans += piles[i], picks--;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2211769,
                "title": "maximum-number-of-coins-you-can-get-faster-than-98",
                "content": "![image](https://assets.leetcode.com/users/images/629e5448-ab2a-45dd-b95d-9a5b62eb3272_1656469463.8355172.png)\\n\\n```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        \\n        int maxCoins = 0;\\n        Arrays.sort(piles);\\n       \\n         // picking up two pointers one from start and other from end.\\n        for(int i = piles.length - 2; i >= piles.length/3; i-=2) {\\n            maxCoins += piles[i];\\n        }\\n        \\n        return maxCoins;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        \\n        int maxCoins = 0;\\n        Arrays.sort(piles);\\n       \\n         // picking up two pointers one from start and other from end.\\n        for(int i = piles.length - 2; i >= piles.length/3; i-=2) {\\n            maxCoins += piles[i];\\n        }\\n        \\n        return maxCoins;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2146247,
                "title": "greedy-approach-java",
                "content": "**Explanation:**\\nAccording to the  conditions, we will randomly select 3 pile of coins from the array of piles at each iteration.\\nFrom that:\\n1. Alice will take the pile with maximum coins\\n2. You will take the second highest \\n3. Bob picks the last pile\\n\\n                                                           Please Upvote if you like the solution!  \\n\\n**Greedy approach:**\\nAt each iteration: Give the minimum piled coin to Bob, so that you can get more coins.\\n\\n**Steps:**\\n1. Sort the array of piles\\n2. At each iteration, select 2 from the end (Max values) & 1 from the beginning (Min value for Bob)\\n3. Add the second highest to your total coins gained.\\n\\n**Note:** We can select the second highest from the end, **n times** to get the total\\n\\n               Eg: \\n\\t\\t\\t   [9,8,7,6,5,1,2,3,4] --Sorting--> [1,2,3,4,5,6,7,8,9]\\n\\t\\t\\t   \\n\\t\\t\\t   Pick alternate piles from the end - 8+6+4 (n: 3 times) = 18\\n\\t\\t\\t   So Bob gets: 1, 2, 3 respectively\\n\\t\\t\\t   You get: 8, 6, 4 respectively\\n\\t\\t\\t   \\n\\t\\t\\t   \\n**Code:**\\n```\\nclass Solution {\\n    public int maxCoins(int[] piles){\\n        int n = piles.length, mul = piles.length/3, c=0, p = piles.length-2;\\n        Arrays.sort(piles);\\n        \\n        while(mul-->0){\\n            c+=piles[p];\\n            p-=2;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] piles){\\n        int n = piles.length, mul = piles.length/3, c=0, p = piles.length-2;\\n        Arrays.sort(piles);\\n        \\n        while(mul-->0){\\n            c+=piles[p];\\n            p-=2;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2133849,
                "title": "maximum-number-of-coins-you-can-get-simple-o-n-log-n-easy",
                "content": "<+++++++ Please press Upvote Button !!!!!!!!!!!!!!!!\\n\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        \\n        sort( piles.rbegin(),piles.rend() ); // rbegin() and rend() for desc\\n        \\n        int loopLimit = piles.size() - piles.size()/3;\\n        \\n        int sum=0;\\n        \\n        for(int i=1;i< loopLimit; i+=2 )\\n        {\\n            sum+= piles[i];\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/85a0124d-79c2-409a-9ac4-0d14a3dc18c6_1654843843.8134475.jpeg)\\n\\n\\n<+++++++ Please press Upvote Button !!!!!!!!!!!!!!!!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        \\n        sort( piles.rbegin(),piles.rend() ); // rbegin() and rend() for desc\\n        \\n        int loopLimit = piles.size() - piles.size()/3;\\n        \\n        int sum=0;\\n        \\n        for(int i=1;i< loopLimit; i+=2 )\\n        {\\n            sum+= piles[i];\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2101858,
                "title": "python3-sorting",
                "content": "```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        count = len(piles) // 3\\n        piles.sort()\\n        idx = len(piles) - 2\\n        ans = 0\\n        while count > 0:\\n            ans += piles[idx]\\n            idx -= 2\\n            count -= 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        count = len(piles) // 3\\n        piles.sort()\\n        idx = len(piles) - 2\\n        ans = 0\\n        while count > 0:\\n            ans += piles[idx]\\n            idx -= 2\\n            count -= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2047718,
                "title": "nlogn-sort-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end());\\n        int n=piles.size()-1;\\n        int i=0,j=n,k=n-1;\\n        int ans=0;\\n        while(i<k)\\n        {\\n            ans+=(piles[k]);\\n            k=k-2;\\n            i++;\\n            j=j-2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end());\\n        int n=piles.size()-1;\\n        int i=0,j=n,k=n-1;\\n        int ans=0;\\n        while(i<k)\\n        {\\n            ans+=(piles[k]);\\n            k=k-2;\\n            i++;\\n            j=j-2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950217,
                "title": "simple-python-solution-89-faster-beginner-friendly",
                "content": "For the first 15 mins, I was trying to do it the dummy way, but then I realized that we can sort the array, then always choose max element for Alice, next max for us and the very minimum for Bob. Once I got the idea, I just coded a simple 2-pointer\\n\\n```\\n        res = 0\\n        piles.sort()\\n        l = 0\\n        r = len(piles) - 1\\n        while l < r: \\n            r -= 1  # Alice\\'s pile\\n            res += piles[r]\\n            r -= 1\\n            l += 1 # Bob\\'s pile\\n        return res\\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n        res = 0\\n        piles.sort()\\n        l = 0\\n        r = len(piles) - 1\\n        while l < r: \\n            r -= 1  # Alice\\'s pile\\n            res += piles[r]\\n            r -= 1\\n            l += 1 # Bob\\'s pile\\n        return res\\n                \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1943619,
                "title": "priority-queue-easy-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& P) {\\n        priority_queue<int> p1;\\n        priority_queue<int,vector<int>,greater<int>> p2;\\n        for(int i=0;i<P.size();i++){\\n            p1.push(P[i]);p2.push(P[i]);\\n        }\\n        int x=0,sum=0;\\n        while(x<P.size()){\\n            p1.pop();\\n            sum+=p1.top();\\n            p1.pop();\\n            p2.pop();\\n            x+=3;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& P) {\\n        priority_queue<int> p1;\\n        priority_queue<int,vector<int>,greater<int>> p2;\\n        for(int i=0;i<P.size();i++){\\n            p1.push(P[i]);p2.push(P[i]);\\n        }\\n        int x=0,sum=0;\\n        while(x<P.size()){\\n            p1.pop();\\n            sum+=p1.top();\\n            p1.pop();\\n            p2.pop();\\n            x+=3;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1884360,
                "title": "c-easy-solution-o-nlog-n-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end(),[=](int a,int b){\\n            return a>b;\\n        });\\n        int first=0,second=1;\\n        int last=piles.size()-1;\\n        int res=0;\\n        while(second<last){\\n            res+=piles[second];\\n            first=second+1;\\n            second=first+1;\\n            last--;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end(),[=](int a,int b){\\n            return a>b;\\n        });\\n        int first=0,second=1;\\n        int last=piles.size()-1;\\n        int res=0;\\n        while(second<last){\\n            res+=piles[second];\\n            first=second+1;\\n            second=first+1;\\n            last--;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875427,
                "title": "written-in-the-simplest-manner-to-help-beginners",
                "content": "class Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end());\\n        int n=piles.size();\\n        int j=0,limit=n/3,i=n-2,sum=0;\\n        while(j<limit)\\n        {\\n            sum+=piles[i];\\n            j++;\\n            i-=2;\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end());\\n        int n=piles.size();\\n        int j=0,limit=n/3,i=n-2,sum=0;\\n        while(j<limit)\\n        {\\n            sum+=piles[i];\\n            j++;\\n            i-=2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1841827,
                "title": "c-very-simple-binary-search-method-must-watch",
                "content": "# DRY RUN FROM YOUR SIDE FIRST AND THEN FEEL FREE TO ASK ANY QUERY ****\\nint maxCoins(vector<int>& piles) {\\n\\n\\n        sort(piles.begin(),piles.end());\\n\\t\\t//1st we sorted our input array\\n        int s=0;int e1=piles.size()-1;int e2=piles.size()-2;\\n        int ans=0;\\n        /*2nd we have obtaibned 3 pointers \\n\\t\\t(i) at 1st index\\n\\t\\t(ii)at 2nd last index\\n\\t\\t(iii)at last index */\\n        while(s<e2){\\n            ans+=piles[e2];\\n\\t\\t\\t//now at each pile we add 2nd last value in our answer\\n            s++;//increament 1st pointer to next place\\n            e1=e1-2;//last pointer to last -2\\n            e2=e2-2;//2nd last pointer to 2nd last -2\\n        }\\n\\t\\t//till here our final answer would have come\\n\\t\\t//as constraint :- size<=3\\n      return ans;\\n\\t  \\n    }",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "# DRY RUN FROM YOUR SIDE FIRST AND THEN FEEL FREE TO ASK ANY QUERY ****\\nint maxCoins(vector<int>& piles) {\\n\\n\\n        sort(piles.begin(),piles.end());\\n\\t\\t//1st we sorted our input array\\n        int s=0;int e1=piles.size()-1;int e2=piles.size()-2;\\n        int ans=0;\\n        /*2nd we have obtaibned 3 pointers \\n\\t\\t(i) at 1st index\\n\\t\\t(ii)at 2nd last index\\n\\t\\t(iii)at last index */\\n        while(s<e2){\\n            ans+=piles[e2];\\n\\t\\t\\t//now at each pile we add 2nd last value in our answer\\n            s++;//increament 1st pointer to next place\\n            e1=e1-2;//last pointer to last -2\\n            e2=e2-2;//2nd last pointer to 2nd last -2\\n        }\\n\\t\\t//till here our final answer would have come\\n\\t\\t//as constraint :- size<=3\\n      return ans;\\n\\t  \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1786610,
                "title": "less-than-100-memory-simplest-solution-c",
                "content": "# **AN UPVOTE WOULD BE HIGHLY APPERICIATED**\\n\\n1. SORT THE ARRAY because we want 2nd max number of coins.\\n**FOR EG=[3,7,5,9,2,6]**\\n\\n* AFTER SORTING IT BECOMES---->[2,3,5,6,7,9]\\n* HERE 9 IS MAX AND WE WANT TO ADD SECOND MAX.\\n* SO ADD 7 TO OUR ANS.\\n* AFTER THIS MAX IS 6 SO WE HAVE TO ADD SECOND MAX.SO,THAT\\'S WHY WE ADD 5 AT OUR ANS!!!\\n **HAPPY CODING**\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& p) {\\n        sort(p.begin(),p.end());\\n        int s=0;\\n        int e=p.size()-2;\\n        int ans=0;\\n        while(s<e){\\n            ans+=p[e];\\n            e=e-2;\\n            s++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n\\n# OR\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& p) {\\n        sort(p.begin(),p.end());\\n        if(p.size()==3) return p[1];\\n        int e2=p.size()-2;\\n        int ans=0;\\n        while(e2>=(p.size()/3)){\\n            ans+=p[e2];\\n            e2=e2-2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& p) {\\n        sort(p.begin(),p.end());\\n        int s=0;\\n        int e=p.size()-2;\\n        int ans=0;\\n        while(s<e){\\n            ans+=p[e];\\n            e=e-2;\\n            s++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& p) {\\n        sort(p.begin(),p.end());\\n        if(p.size()==3) return p[1];\\n        int e2=p.size()-2;\\n        int ans=0;\\n        while(e2>=(p.size()/3)){\\n            ans+=p[e2];\\n            e2=e2-2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1771214,
                "title": "ruby-one-liner",
                "content": "```\\n# @param {Integer[]} piles\\n# @return {Integer}\\ndef max_coins(piles)\\n  piles.sort[piles.size/3..].each_slice(2).sum(&:first)\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} piles\\n# @return {Integer}\\ndef max_coins(piles)\\n  piles.sort[piles.size/3..].each_slice(2).sum(&:first)\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1728839,
                "title": "python3-solution-greedy",
                "content": "Approach:\\n1) Sort the array.\\n2) Alice can pick the last element (maximum value) , u can pick the 2nd last element and Bob can pick the 1st element of the array(can also be called remaining).\\n3) So, u need to sum up only 2nd last element of each subarray.\\n4) Iterate from the back of the array till there are possible answers i.e. k= len(piles)//3 -> no. of times you can pick the 2nd maximum coin from the respective subarray.\\n5) Iterate backwards with a decrement of 2 as we are have to take subarray of length 3 as last two elements and 1st element, so 2 element is the answer.\\n6) Just, Sum up all these 2nd index values\\n\\n```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles.sort()\\n        res = 0\\n        k = len(piles)//3\\n        i = len(piles)-1\\n        j = 0\\n        while i>0 and j<k:\\n            res += piles[i-1]\\n            i-=2\\n            j+=1\\n        return res\\n```\\n\\nOne-Liner:\\n```\\nreturn sum(sorted(piles)[len(piles)//3::2])\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles.sort()\\n        res = 0\\n        k = len(piles)//3\\n        i = len(piles)-1\\n        j = 0\\n        while i>0 and j<k:\\n            res += piles[i-1]\\n            i-=2\\n            j+=1\\n        return res\\n```\n```\\nreturn sum(sorted(piles)[len(piles)//3::2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707308,
                "title": "c-ezz-2-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end());\\n        int maxcoins=0,low=0,high=piles.size()-1;\\n        while(low<=high)\\n        {\\n            maxcoins+=piles[--high];\\n            low++;high--;\\n        }\\n        return maxcoins;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end());\\n        int maxcoins=0,low=0,high=piles.size()-1;\\n        while(low<=high)\\n        {\\n            maxcoins+=piles[--high];\\n            low++;high--;\\n        }\\n        return maxcoins;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1702516,
                "title": "simple-and-easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        \\n        sort(piles.begin(), piles.end()); \\n        int me = 0, alice = 0, bob = 0;        \\n        int i = 0;\\n        int j = piles.size() - 2;\\n        \\n        while(i < j){\\n            me += piles[j];\\n            i += 1;\\n            j -= 2;\\n        }\\n        return me;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        \\n        sort(piles.begin(), piles.end()); \\n        int me = 0, alice = 0, bob = 0;        \\n        int i = 0;\\n        int j = piles.size() - 2;\\n        \\n        while(i < j){\\n            me += piles[j];\\n            i += 1;\\n            j -= 2;\\n        }\\n        return me;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694721,
                "title": "c-sorting-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        int n = piles.size();\\n        \\n        sort(piles.begin(),piles.end());\\n        int ans = 0;\\n         int i = n-2;\\n         n /= 3;\\n        \\n        while(n--){\\n            ans += piles[i];\\n            i -= 2;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        int n = piles.size();\\n        \\n        sort(piles.begin(),piles.end());\\n        int ans = 0;\\n         int i = n-2;\\n         n /= 3;\\n        \\n        while(n--){\\n            ans += piles[i];\\n            i -= 2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1680774,
                "title": "easy-to-understand-with-explanation-25-ms-faster-than-77-64-of-java-online-submissions",
                "content": "Since we have to choose  triplet each time and want to maximize our coins, we should try to minimize the coins going to others so max coins comes to us. Since Alice is always going to choose first, there is no way we can reduce his coins, we would chose a triplet such that elements are {max of remaining piles, second max of remaining piles, minimum of remaining piles}. Bob would always get the minimum available piles so as a result he would get the first N/3 piles in the sorted array. Our share will be the sum of second largest from each pair if we start making pairs from the last element of the sorted array\\n```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        int ans = 0;\\n        Arrays.sort(piles);\\n        for(int i = piles.length-2; i>=piles.length/3; i= i-2){  // starting from the second largest pile and choosing alternate piles\\n            ans += piles[i];\\n        }\\n        return(ans); \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        int ans = 0;\\n        Arrays.sort(piles);\\n        for(int i = piles.length-2; i>=piles.length/3; i= i-2){  // starting from the second largest pile and choosing alternate piles\\n            ans += piles[i];\\n        }\\n        return(ans); \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677681,
                "title": "c-sorting",
                "content": "class Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        //sort the piles in ascending order\\n       sort(piles.begin(),piles.end());\\n        if(piles.size()==3)\\n            return piles[1];\\n        int you=0;\\n        int j=0;\\n        int i=piles.size()-1;\\n        //j for the last piles that bob pick\\n        while(j<i && piles[i]!=-1)\\n        {  \\n        \\n           you+=piles[i-1];\\n            piles[j]=-1;\\n            j++;\\n            i-=2;\\n        }\\n        return you;\\n    }\\n};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        //sort the piles in ascending order\\n       sort(piles.begin(),piles.end());\\n        if(piles.size()==3)\\n            return piles[1];\\n        int you=0;\\n        int j=0;\\n        int i=piles.size()-1;\\n        //j for the last piles that bob pick\\n        while(j<i && piles[i]!=-1)\\n        {  \\n        \\n           you+=piles[i-1];\\n            piles[j]=-1;\\n            j++;\\n            i-=2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1669726,
                "title": "c-two-pointers-easy",
                "content": "\\n```\\n\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n     \\n        sort(piles.begin(), piles.end());\\n        \\n        int i=0;\\n        int j=piles.size()-1;\\n        int coin=0;\\n        \\n        while(i<=j){\\n            j--;\\n            coin += piles[j];\\n\\t\\t\\tj--;\\n            i++;\\n        }\\n        return coin;\\n    }\\n};\\n\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n     \\n        sort(piles.begin(), piles.end());\\n        \\n        int i=0;\\n        int j=piles.size()-1;\\n        int coin=0;\\n        \\n        while(i<=j){\\n            j--;\\n            coin += piles[j];\\n\\t\\t\\tj--;\\n            i++;\\n        }\\n        return coin;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646181,
                "title": "java-easy-solution-with-comment-explanations",
                "content": "```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles); // 1,2,2,4,7,8\\n        \\n        int start=0;\\n        int end=piles.length-1;\\n        //for maximize my coin i need to make the triplet like {1,7,8} i,e element of {start,end-1,end}\\n        int myCoin=0;\\n        while(start<=end){\\n            myCoin+=piles[end-1];\\n            start++;\\n            end--;\\n            end--;  \\n            // after executing above next triplet will looks like {2,2,4} for given example\\n        }\\n        return myCoin;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles); // 1,2,2,4,7,8\\n        \\n        int start=0;\\n        int end=piles.length-1;\\n        //for maximize my coin i need to make the triplet like {1,7,8}",
                "codeTag": "Java"
            },
            {
                "id": 1626795,
                "title": "c-o-nlogn-one-while-loop-and-sorting",
                "content": "class Solution {\\npublic:\\n    int maxCoins(vector<int>& p) {\\n        \\n        sort(p.begin(),p.end());\\n        \\n        int i=0;\\n        int j=p.size()-1;\\n        int k=j-1;\\n        int ans = 0;\\n        while(i<k){\\n            \\n            ans = ans + p[k];\\n            i++;\\n            j--;\\n            j--;\\n            k--;\\n            k--;\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int maxCoins(vector<int>& p) {\\n        \\n        sort(p.begin(),p.end());\\n        \\n        int i=0;\\n        int j=p.size()-1;\\n        int k=j-1;\\n        int ans = 0;\\n        while(i<k){\\n            \\n            ans = ans + p[k];\\n            i++;\\n            j--;\\n            j--;\\n            k--;\\n            k--;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1616666,
                "title": "java-5-line-solution-two-pointers-o-nlogn",
                "content": "```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int myscore = 0;\\n        int pointer1=0;\\n        int pointer2=piles.length-1;\\n        \\n        while(pointer1<pointer2-1){\\n            myscore+=piles[pointer2-1];\\n            pointer1++;\\n            pointer2-=2;\\n        }\\n    return myscore;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int myscore = 0;\\n        int pointer1=0;\\n        int pointer2=piles.length-1;\\n        \\n        while(pointer1<pointer2-1){\\n            myscore+=piles[pointer2-1];\\n            pointer1++;\\n            pointer2-=2;\\n        }\\n    return myscore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610580,
                "title": "c-easy-soln",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end());\\n        int i=0;\\n        int j=piles.size()-2;\\n        int ans=0;\\n        while(i<j){\\n            ans+=piles[j];\\n            j=j-2;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1604576,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles = sorted(piles)\\n        start = len(piles) // 3\\n        ans = 0\\n        \\n        while start < len(piles):\\n            ans += piles[start]\\n            start += 2\\n\\t\\t\\t\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles = sorted(piles)\\n        start = len(piles) // 3\\n        ans = 0\\n        \\n        while start < len(piles):\\n            ans += piles[start]\\n            start += 2\\n\\t\\t\\t\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589313,
                "title": "c-87-sorting-short-and-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int j=0,k=arr.size()-2,count=0;\\n        while(j<arr.size()/3){\\n         count+=arr[k];\\n            k-=2;\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int j=0,k=arr.size()-2,count=0;\\n        while(j<arr.size()/3){\\n         count+=arr[k];\\n            k-=2;\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580011,
                "title": "python-3-47-faster",
                "content": "\\n```\\n\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles.sort()\\n        lower =0\\n        ln = len(piles)\\n        upper  = ln -2\\n        print (piles)\\n        my_coins = int ()\\n        while (lower <upper):\\n            my_coins  = my_coins + piles[upper]\\n            upper = upper-2\\n            lower = lower +1\\n        \\n        return my_coins\\n            \\n            \\n            \\n        \\n            \\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        piles.sort()\\n        lower =0\\n        ln = len(piles)\\n        upper  = ln -2\\n        print (piles)\\n        my_coins = int ()\\n        while (lower <upper):\\n            my_coins  = my_coins + piles[upper]\\n            upper = upper-2\\n            lower = lower +1\\n        \\n        return my_coins\\n            \\n            \\n            \\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568115,
                "title": "java-short-easy-sorting-easy-to-understand",
                "content": "class Solution {\\n    public int maxCoins(int[] piles) {\\n        int n=piles.length;\\n        Arrays.sort(piles);\\n        int i=0;\\n        int sum=0;\\n        for(int j=n-2;i!=n/3;j=j-2)\\n        {\\n            sum+=piles[j];\\n            i++;\\n        }\\n        return sum;\\n        \\n    }\\n}\\n\\n\\n\\n\\n\\nPlease upvote if you like the solution",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int maxCoins(int[] piles) {\\n        int n=piles.length;\\n        Arrays.sort(piles);\\n        int i=0;\\n        int sum=0;\\n        for(int j=n-2;i!=n/3;j=j-2)\\n        {\\n            sum+=piles[j];\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1561832,
                "title": "rust-two-lines",
                "content": "```rust\\nimpl Solution {\\n    pub fn max_coins(mut piles: Vec<i32>) -> i32 {\\n        piles.sort_unstable_by(|a, b| b.cmp(a));\\n        piles.iter().skip(1).step_by(2).take(piles.len()/3).sum()\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn max_coins(mut piles: Vec<i32>) -> i32 {\\n        piles.sort_unstable_by(|a, b| b.cmp(a));\\n        piles.iter().skip(1).step_by(2).take(piles.len()/3).sum()\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1534638,
                "title": "easy-to-understand-c",
                "content": "We just have to take the 2nd largest element for each iteration\\ntill we reach n/3 iterations\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        int sum=0;\\n        int n=piles.size();\\n        sort(piles.begin(),piles.end());\\n        int ctr=n/3;\\n        while(ctr>0){\\n            sum+=piles[n-2*ctr];\\n            ctr--;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        int sum=0;\\n        int n=piles.size();\\n        sort(piles.begin(),piles.end());\\n        int ctr=n/3;\\n        while(ctr>0){\\n            sum+=piles[n-2*ctr];\\n            ctr--;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515812,
                "title": "java-o-nlogn-arrays-sort-solution",
                "content": "```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int l=0, r=piles.length-1;\\n        int sum=0;\\n        while(l<r-1){\\n            sum+=piles[r-1];\\n            l++; r-=2;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int l=0, r=piles.length-1;\\n        int sum=0;\\n        while(l<r-1){\\n            sum+=piles[r-1];\\n            l++; r-=2;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505765,
                "title": "c-o-n-logn-approach-simple-easy",
                "content": "I will choose 3 nos. such that 2 are biggest of all and last one is smallest one\\nbecause our aim is to maximise my sum\\n**Why??**\\n    1st greatest -> Alice will take\\n    2nd greatest -> I will take\\n    last one -> Bob will take \\n Since Bob will take the last element only that\\'s why we kept last as small as possible\\n \\n**Implementation :**\\n* sort array in desc. order\\n* I will pick every alternate element starting from 1st index (means incrementing i by 2)\\n* leaving the smallest element for Bob in each triplet (means decrementing j by 1)\\n* repeat this until (i<j)\\n\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) \\n    {\\n        int n = piles.size();\\n        sort(piles.begin(),piles.end(),greater<>());\\n        int sum = 0;\\n        int i = 1;\\n        int j = n-1;\\n        while(i<j)\\n        {\\n            sum+=piles[i];\\n            i+=2;\\n            j--;\\n        }\\n       return sum;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) \\n    {\\n        int n = piles.size();\\n        sort(piles.begin(),piles.end(),greater<>());\\n        int sum = 0;\\n        int i = 1;\\n        int j = n-1;\\n        while(i<j)\\n        {\\n            sum+=piles[i];\\n            i+=2;\\n            j--;\\n        }\\n       return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500390,
                "title": "simple-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n     sort(piles.begin(),piles.end(),greater<int>());\\n    int n=piles.size();\\n     int cnt=0;  \\n        for(int i=1;i<n-n/3;i++){\\n            cnt+=piles[i];\\n            i++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n     sort(piles.begin(),piles.end(),greater<int>());\\n    int n=piles.size();\\n     int cnt=0;  \\n        for(int i=1;i<n-n/3;i++){\\n            cnt+=piles[i];\\n            i++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493811,
                "title": "priority-queue-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        \\n        priority_queue<int>pq;\\n        \\n        for(auto x:piles) pq.push(x);\\n        int ans=0;\\n        int cnt=0;\\n        \\n        while(!pq.empty() and cnt<piles.size()/3){\\n            pq.pop();\\n            ans+=pq.top();\\n            cout<<pq.top()<<\" \";\\n            pq.pop();\\n            cnt++;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        \\n        priority_queue<int>pq;\\n        \\n        for(auto x:piles) pq.push(x);\\n        int ans=0;\\n        int cnt=0;\\n        \\n        while(!pq.empty() and cnt<piles.size()/3){\\n            pq.pop();\\n            ans+=pq.top();\\n            cout<<pq.top()<<\" \";\\n            pq.pop();\\n            cnt++;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1433578,
                "title": "c-solution-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end(),greater<int>());\\n        int n=piles.size();\\n      int p=0;\\n        int i=n-1;\\n            for(int j=1;j<n;j+=2){\\n                if(j>i){\\n                    break;\\n                }\\n          p+=piles[j];\\n            i--;    \\n       }\\n        return p;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end(),greater<int>());\\n        int n=piles.size();\\n      int p=0;\\n        int i=n-1;\\n            for(int j=1;j<n;j+=2){\\n                if(j>i){\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1373102,
                "title": "python-for-beginners",
                "content": "\\tdef maxCoins(piles):\\n    ans=0\\n    piles.sort(reverse=True)\\n    times=len(piles)*2//3\\n    i=1\\n    while i<times:\\n        ans=ans+piles[i]\\n        i=i+2\\n    return ans\\n",
                "solutionTags": [],
                "code": "\\tdef maxCoins(piles):\\n    ans=0\\n    piles.sort(reverse=True)\\n    times=len(piles)*2//3\\n    i=1\\n    while i<times:\\n        ans=ans+piles[i]\\n        i=i+2\\n    return ans\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1368445,
                "title": "c-solution-beginner-friendly",
                "content": "Sort the given array. An ideal triplet would be, the first number being as small as possible and the other two being as large as possible, so that we can get the medium number. \\nIn short, in the **sorted array** (of size n) we would only need *elements* at index **[n-2],[n-4],[n-6]** and so on.\\n\\n**Solution**\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        int res = 0;\\n        std::sort(piles.begin(),piles.end());\\n        int n = piles.size()/3, j=piles.size()-2;\\n        for(int i=1; i<=n; i++){\\n            res+=piles[j];\\n            j-=2;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        int res = 0;\\n        std::sort(piles.begin(),piles.end());\\n        int n = piles.size()/3, j=piles.size()-2;\\n        for(int i=1; i<=n; i++){\\n            res+=piles[j];\\n            j-=2;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366392,
                "title": "c-faster-than-97-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        int res=0;\\n        int index = 1;\\n        sort(piles.begin(),piles.end(),greater<int>());\\n        for(int i=0;i<piles.size()/3;i++)\\n        {\\n            res += piles[index];\\n            index +=2;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        int res=0;\\n        int index = 1;\\n        sort(piles.begin(),piles.end(),greater<int>());\\n        for(int i=0;i<piles.size()/3;i++)\\n        {\\n            res += piles[index];\\n            index +=2;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362628,
                "title": "c-solution-90-faster-using-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(), piles.end(), greater<>());\\n        int ans = 0, i = 1, j = piles.size()-1;\\n        while(j > i){\\n            ans += piles[i];\\n            i += 2; j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(), piles.end(), greater<>());\\n        int ans = 0, i = 1, j = piles.size()-1;\\n        while(j > i){\\n            ans += piles[i];\\n            i += 2; j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343055,
                "title": "python-3-beats-100-in-time",
                "content": "just sort the list and add alternative number from len/3 to end\\n\\n```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        return sum(sorted(piles)[len(piles)//3 :: 2])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        return sum(sorted(piles)[len(piles)//3 :: 2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334504,
                "title": "c-easy-to-understand-solution-o-nlogn",
                "content": "**Intuition**\\n```\\nIt\\'s clearly given that we need to compare the numbers for which we need definitely need to sort.\\nwe give smallest coins to Bob\\nThe Maximum coins to Alice\\nThe Second Maximum Coins for us.\\nand finally after repeating the process till there are no more piles of coins.\\nwe return the maximum sum\\n```\\n\\n**Complexity**\\n```\\nTime O(NlogN)\\nSpace O(NlogN)\\n```\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end());\\n        int sum=0;\\n        int n=piles.size();\\n        int i= n-2;\\n        int j=0;\\n        while(j++<n/3){\\n            sum+=piles[i];\\n            i-=2;                // MORE EASIER TO UNDERSTAND \\n        }                        // SAME TC --> O(NlogN) for both the solutions\\n        return sum;\\n        // int sum=0,n=piles.size();\\n        // for(int i=n/3;i<n;i+=2){\\n        //     sum+=piles[i];\\n        // }\\n        // return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nIt\\'s clearly given that we need to compare the numbers for which we need definitely need to sort.\\nwe give smallest coins to Bob\\nThe Maximum coins to Alice\\nThe Second Maximum Coins for us.\\nand finally after repeating the process till there are no more piles of coins.\\nwe return the maximum sum\\n```\n```\\nTime O(NlogN)\\nSpace O(NlogN)\\n```\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        sort(piles.begin(),piles.end());\\n        int sum=0;\\n        int n=piles.size();\\n        int i= n-2;\\n        int j=0;\\n        while(j++<n/3){\\n            sum+=piles[i];\\n            i-=2;                // MORE EASIER TO UNDERSTAND \\n        }                        // SAME TC --> O(NlogN) for both the solutions\\n        return sum;\\n        // int sum=0,n=piles.size();\\n        // for(int i=n/3;i<n;i+=2){\\n        //     sum+=piles[i];\\n        // }\\n        // return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332838,
                "title": "simple-and-concise-c-solution",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\n  int maxCoins(vector<int>& piles) {\\n      sort(piles.begin(),piles.end());\\n        int n=piles.size()/3;\\n        int j=piles.size()-2;\\n        int res=0;\\n        while(n--)\\n        {\\n            res+=piles[j];\\n            j-=2;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\n  int maxCoins(vector<int>& piles) {\\n      sort(piles.begin(),piles.end());\\n        int n=piles.size()/3;\\n        int j=piles.size()-2;\\n        int res=0;\\n        while(n--)\\n        {\\n            res+=piles[j];\\n            j-=2;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1296916,
                "title": "straight-forward-java-solution",
                "content": "**LOGIC**\\n- Sort Array\\n- Iterate for n times\\n\\t- Pick Min, 2nd Max and Max at each iteration\\n\\t- add all the 2nd Max\\n\\n\\n**CASE 1**\\n[2,4,1,2,7,8]\\n\\nSort in Ascending Order\\n[1,2,2,4,7,8]\\n- 1,**7**,8 -> 7\\n- 2,**2**,4 -> 2\\nAns = 7+2 = 9\\n\\n**CASE 2**\\n[9,8,7,6,5,1,2,3,4]\\n\\nSort in Ascending Order\\n[1,2,3,4,5,6,7,8,9]\\n- 1,**8**,9 -> 8\\n- 2,**6**,7 -> 6\\n- 3,**4**,5 -> 4\\nAns = 8+6+4 = 18\\n\\n```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        int mySum = 0;\\n        Arrays.sort(piles);\\n        int count = piles.length/3;\\n        int pos = piles.length-2;\\n        \\n        for(int i=0; i<count; i++, pos-=2)\\n            mySum+=piles[pos];\\n         \\n        return mySum;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        int mySum = 0;\\n        Arrays.sort(piles);\\n        int count = piles.length/3;\\n        int pos = piles.length-2;\\n        \\n        for(int i=0; i<count; i++, pos-=2)\\n            mySum+=piles[pos];\\n         \\n        return mySum;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1296100,
                "title": "felling-sad-for-bob",
                "content": "```\\nFrom\\n Java+Python+c++ \\n  Heartly condolences",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1294176,
                "title": "1561-c-ps-easy-solution",
                "content": "\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxCoins(vector<int>& piles) {\\n        \\n\\t\\t\\tsort(piles.rbegin(), piles.rend());   // reverse sort\\n\\t\\t\\tint sum = 0;\\n\\n\\t\\t\\tfor(int i = 0; i < piles.size()/3; i++){\\n\\t\\t\\t\\tsum += piles[i*2+1];               // add all the second highest number from each pile.. \\n\\t\\t\\t}        \\n\\t\\t\\treturn sum;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxCoins(vector<int>& piles) {\\n        \\n\\t\\t\\tsort(piles.rbegin(), piles.rend());   // reverse sort\\n\\t\\t\\tint sum = 0;\\n\\n\\t\\t\\tfor(int i = 0; i < piles.size()/3; i++){\\n\\t\\t\\t\\tsum += piles[i*2+1];               // add all the second highest number from each pile.. \\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1281298,
                "title": "c-partial-sort-100",
                "content": "BTW, faster than std::partial_sort\\n\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n\\t     // To speed up IO\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n\\t\\t\\n        const int n = piles.size() - piles.size() / 3;\\n        nth_element(piles.begin(), piles.begin() + n, piles.end(), greater<int>());\\n        sort(piles.begin(), piles.begin() + n, greater<int>());\\n\\n        int ans = 0;\\n        for (int i = 1; i < n; i += 2) \\n            ans += piles[i];\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n\\t     // To speed up IO\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n\\t\\t\\n        const int n = piles.size() - piles.size() / 3;\\n        nth_element(piles.begin(), piles.begin() + n, piles.end(), greater<int>());\\n        sort(piles.begin(), piles.begin() + n, greater<int>());\\n\\n        int ans = 0;\\n        for (int i = 1; i < n; i += 2) \\n            ans += piles[i];\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1264786,
                "title": "c-solution-with-intuition-sorting",
                "content": "Let\\'s jump straight into the question. We are playing a game in the question, wherein we choose a triplet (i, j, k) which are piles of money and take the piles as follows:\\n\\t1. Alice takes the largest of them all.\\n\\t2. We take the second largest.\\n\\t3. Bob takes the one left.\\n\\nOne may immediately guess that, in order to maximise our score, we need to take the highest possible money pile for ourselves. But taking the largest pile is not possible, since that always goes to Alice. Although we cannot prevent Alice from winning the game, we certainly can prevent Bob from getting decent money.\\n\\nYou see, Bob has to take the last left pile, no matter what value it has, so let us leave the smallest pile for him at every stage.\\n\\nSo, all-in-all, at every stage, we choose the largest two and the smallest pile. The largest pile goes to Alice, the second largest one is ours, and Bob gets the smallest one. This way we have a chance at all the piles in between still.\\n\\nThe best and most obvious way of finding this ordering is sorting the input list.\\n\\nThis provides us an algoithm that has **O(nlogn)** runtime and **O(1)** space complexity.\\n<br>\\n## Code\\n```\\nint maxCoins(vector<int>& piles) {\\n\\tint n = piles.size();\\n\\t\\n\\tsort(piles.begin(), piles.end());\\n\\t\\n\\t//i->for bob, j -> for alice, j-1->for us\\n\\tint i = 0, j = n-1;\\n\\tint score = 0;\\n\\twhile(i<j-1) {\\n\\t\\n\\t\\t//Alice takes her pile\\n\\t\\tj--;\\n\\t\\t\\n\\t\\t//We take ours\\n\\t\\tscore += piles[j--];\\n\\t\\t\\n\\t\\t//Bob takes his\\n\\t\\ti++;\\n\\t}\\n\\t\\n\\treturn score;\\n}\\n```\\n\\n<br>\\n\\n**Upvote** if you liked this post and learned something from it, and feel free to ask any doubts or suggest any corrections/improvements in the comments.",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nint maxCoins(vector<int>& piles) {\\n\\tint n = piles.size();\\n\\t\\n\\tsort(piles.begin(), piles.end());\\n\\t\\n\\t//i->for bob, j -> for alice, j-1->for us\\n\\tint i = 0, j = n-1;\\n\\tint score = 0;\\n\\twhile(i<j-1) {\\n\\t\\n\\t\\t//Alice takes her pile\\n\\t\\tj--;\\n\\t\\t\\n\\t\\t//We take ours\\n\\t\\tscore += piles[j--];\\n\\t\\t\\n\\t\\t//Bob takes his\\n\\t\\ti++;\\n\\t}\\n\\t\\n\\treturn score;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1232557,
                "title": "python",
                "content": "class Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        arr = sorted(piles, reverse =True)\\n        n = len(piles)\\n        sm = 0\\n        for i in range(1, (n//3)*2, 2):\\n            sm += arr[i]\\n        return sm",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        arr = sorted(piles, reverse =True)\\n        n = len(piles)\\n        sm = 0\\n        for i in range(1, (n//3)*2, 2):\\n            sm += arr[i]\\n        return sm",
                "codeTag": "Java"
            },
            {
                "id": 1223393,
                "title": "java-simple-solution-with-explanation",
                "content": "Here, we see that Alice will always get the maximum, and we will always get the second max of the elements. We will be able to collect maximum number of coins when we choose 2 highest and 1 least pile of coin in every turn. This will ensure Bob gets the min, and we get the second max always. \\nSince all we care about is how much we make, we\\'ll keep adding the second max, until all the coins have been picked. \\n```\\npublic int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int i=0; int j=piles.length-1;\\n        int sum=0;\\n        while(i<j)\\n        {\\n            i++;\\n            j--;\\n            sum=sum+piles[j--];\\n        }\\n        return sum;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int i=0; int j=piles.length-1;\\n        int sum=0;\\n        while(i<j)\\n        {\\n            i++;\\n            j--;\\n            sum=sum+piles[j--];\\n        }\\n        return sum;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1223213,
                "title": "c-3-lines-simple-solution-faster-than-90-explained-with-example",
                "content": "1. firstly we sorted the array\\n2. now suppose we iterate from right then we give curr element to alice and and first element(from the start) to bob\\nand next to curr element we can take, also there are totally n steps, so we give first n coins to bob (greedily) and then from n+1 coin till end every alternative coin we can take;\\n\\n  ex.          1 2 3 4 5 6\\nstep1->\\t\\t1 2 3 4 **5** 6 // alice -> 6, bob->1\\nstep2->      1 2 **3** 4 5 6 // alice->4, bob->2\\n\\nthis is the optimal way;\\n\\nin the code we are iterating from start, you can iterate from end as well;\\n\\n```\\n int maxCoins(vector<int>& piles) {\\n        int ans = 0;\\n        sort(piles.begin(), piles.end());\\n        for(int i = piles.size()/3; i<piles.size(); i+=2)ans+=piles[i];\\n        return ans;\\n    }\\n```\\n**if you find it helpful, plz upvote**",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n int maxCoins(vector<int>& piles) {\\n        int ans = 0;\\n        sort(piles.begin(), piles.end());\\n        for(int i = piles.size()/3; i<piles.size(); i+=2)ans+=piles[i];\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1198064,
                "title": "c-faster-than-96-64-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        int optimalSum = 0, k = piles.size()/3;\\n        sort(piles.begin(), piles.end());\\n        int* p = piles.data();\\n        \\n        for(int i=piles.size()-2; k; i-=2, k--)\\n            optimalSum += p[i];\\n        \\n        return optimalSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        int optimalSum = 0, k = piles.size()/3;\\n        sort(piles.begin(), piles.end());\\n        int* p = piles.data();\\n        \\n        for(int i=piles.size()-2; k; i-=2, k--)\\n            optimalSum += p[i];\\n        \\n        return optimalSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166024,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int MaxCoins(int[] piles) {\\n     \\n        Array.Sort(piles, (p1, p2) => p2 - p1);\\n        \\n        int res = 0;\\n        int left = 1, right = piles.Length - 1;\\n        while(left < right)\\n        {\\n            res += piles[left];\\n            left += 2;\\n            right--;\\n        }\\n  \\n        return res;\\n    }\\n}\\n```\\n\\n```\\npublic class Solution {\\n    public int MaxCoins(int[] piles) {\\n     \\n        Array.Sort(piles);\\n        \\n        int res = 0;\\n        for(int i = piles.Length / 3; i < piles.Length ; i += 2)\\n        {\\n            res += piles[i];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxCoins(int[] piles) {\\n     \\n        Array.Sort(piles, (p1, p2) => p2 - p1);\\n        \\n        int res = 0;\\n        int left = 1, right = piles.Length - 1;\\n        while(left < right)\\n        {\\n            res += piles[left];\\n            left += 2;\\n            right--;\\n        }\\n  \\n        return res;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MaxCoins(int[] piles) {\\n     \\n        Array.Sort(piles);\\n        \\n        int res = 0;\\n        for(int i = piles.Length / 3; i < piles.Length ; i += 2)\\n        {\\n            res += piles[i];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113447,
                "title": "java-3line-solution-faster-than-99-35",
                "content": "JAVA CODE IS :\\n#    \\n```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int n=piles.length;\\n        int coins=0,k=0;\\n        for(int i=n-2;i>=k++;i-=2) coins+=piles[i];\\n        return coins;\\n    }\\n}\\n```\\nTime : O(nlogn)\\nSpace : O(1)\\n***PLEASE,UPVOTE IF THIS IS HELPFUL***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int n=piles.length;\\n        int coins=0,k=0;\\n        for(int i=n-2;i>=k++;i-=2) coins+=piles[i];\\n        return coins;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103549,
                "title": "python-sort-and-two-pointers",
                "content": "```\\ndef maxCoins(self, piles: List[int]) -> int:\\n        piles.sort()\\n        i, j = 0, len(piles)\\n        res = 0\\n        while i < j: # each pile of coins you get costs (1 pile bigger than you + 1 smallest pile)\\n            j -= 2 # move the pointer on the right end 2 units each time\\n            i += 1\\n            res += piles[j]\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxCoins(self, piles: List[int]) -> int:\\n        piles.sort()\\n        i, j = 0, len(piles)\\n        res = 0\\n        while i < j: # each pile of coins you get costs (1 pile bigger than you + 1 smallest pile)\\n            j -= 2 # move the pointer on the right end 2 units each time\\n            i += 1\\n            res += piles[j]\\n        \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1091335,
                "title": "java-sort-faster-than-99-9",
                "content": "```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        int group = piles.length/3;\\n        int ans = 0;\\n        Arrays.sort(piles);\\n        int  i = piles.length-2;\\n        while(group > 0){\\n            ans += piles[i];\\n            i = i-2;\\n            group--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        int group = piles.length/3;\\n        int ans = 0;\\n        Arrays.sort(piles);\\n        int  i = piles.length-2;\\n        while(group > 0){\\n            ans += piles[i];\\n            i = i-2;\\n            group--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083532,
                "title": "python-96-fast-one-liner",
                "content": "```\\nreturn sum(sorted(piles)[-2:int(len(piles)/3-1):-2])",
                "solutionTags": [],
                "code": "```\\nreturn sum(sorted(piles)[-2:int(len(piles)/3-1):-2])",
                "codeTag": "Unknown"
            },
            {
                "id": 1043880,
                "title": "greedy-python-solution",
                "content": "```\\ndef maxCoins(self, piles: List[int]) -> int:\\n\\tl = len(piles) // 3\\n\\tpiles = sorted(piles, reverse=True)\\n\\tcount = 0\\n\\ti = 1\\n\\tfor _ in range(l):\\n\\t\\tcount += piles[i]\\n\\t\\ti += 2\\n\\treturn count",
                "solutionTags": [],
                "code": "```\\ndef maxCoins(self, piles: List[int]) -> int:\\n\\tl = len(piles) // 3\\n\\tpiles = sorted(piles, reverse=True)\\n\\tcount = 0\\n\\ti = 1\\n\\tfor _ in range(l):\\n\\t\\tcount += piles[i]\\n\\t\\ti += 2\\n\\treturn count",
                "codeTag": "Python3"
            },
            {
                "id": 1004784,
                "title": "simple-easy-one-line-solution-by-python-3",
                "content": "```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        return sum(sorted(piles)[len(piles) // 3::2])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        return sum(sorted(piles)[len(piles) // 3::2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935208,
                "title": "javascript-faster-than-70",
                "content": "```\\nvar maxCoins = function(piles) {\\n    const sortedPiles = [...piles].sort((a,b) => b-a);\\n    let sum = 0;\\n    let k = 1;\\n    \\n    for(let i = 1; i < piles.length - k; i++) {\\n        sum += sortedPiles[i];\\n        i += 1;\\n        k++;\\n    }\\n    \\n    return sum;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxCoins = function(piles) {\\n    const sortedPiles = [...piles].sort((a,b) => b-a);\\n    let sum = 0;\\n    let k = 1;\\n    \\n    for(let i = 1; i < piles.length - k; i++) {\\n        sum += sortedPiles[i];\\n        i += 1;\\n        k++;\\n    }\\n    \\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 921991,
                "title": "python-short-and-not-understandable",
                "content": "```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        return sum(sorted(piles)[len(piles)//3::2])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxCoins(self, piles: List[int]) -> int:\\n        return sum(sorted(piles)[len(piles)//3::2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 902835,
                "title": "solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        int len = piles.size(), sum = 0;\\n        int cnt = len / 3 + 1;\\n        sort(piles.begin(), piles.end());\\n        for(int j = len - 1; j >= 0; j -= 2)\\n        {\\n            cnt -= 1;\\n            if(cnt == 0) break;\\n            sum += piles[j - 1];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& piles) {\\n        int len = piles.size(), sum = 0;\\n        int cnt = len / 3 + 1;\\n        sort(piles.begin(), piles.end());\\n        for(int j = len - 1; j >= 0; j -= 2)\\n        {\\n            cnt -= 1;\\n            if(cnt == 0) break;\\n            sum += piles[j - 1];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850050,
                "title": "super-simple-java-two-pointer-solution",
                "content": "```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        int left = 0;\\n        int right = piles.length;\\n        int total = 0;\\n        Arrays.sort(piles);\\n        while (left < right) {\\n            right = right - 2;\\n            total += piles[right];\\n            left++;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        int left = 0;\\n        int right = piles.length;\\n        int total = 0;\\n        Arrays.sort(piles);\\n        while (left < right) {\\n            right = right - 2;\\n            total += piles[right];\\n            left++;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842437,
                "title": "java-solution-sorting",
                "content": "1. Here 1/3rd part is to be considered.\\n2. So we can start from the 1/3 of the total length of given array, and iterate by summing up by 2, ie every 2nd number.\\n3. Add the values to the result variable.\\n4. Finally return the result.\\n\\n```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        int n = piles.length;\\n        Arrays.sort(piles);\\n        int result = 0;\\n        for (int i=n/3; i<n; i+=2) {\\n            result += piles[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] piles) {\\n        int n = piles.length;\\n        Arrays.sort(piles);\\n        int result = 0;\\n        for (int i=n/3; i<n; i+=2) {\\n            result += piles[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832360,
                "title": "java-just-lambdas",
                "content": "```\\npublic int maxCoins(int[] piles) {\\n        \\n        List<Integer> sortedPiles = Arrays.stream(piles)\\n                                        .boxed()\\n                                        .sorted(Comparator.reverseOrder())\\n                                        .collect(Collectors.toList());\\n        \\n        return IntStream.range(0, piles.length / 3 * 2)\\n                .filter(i -> i % 2 == 1)\\n                .map(i -> sortedPiles.get(i))\\n                .sum();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxCoins(int[] piles) {\\n        \\n        List<Integer> sortedPiles = Arrays.stream(piles)\\n                                        .boxed()\\n                                        .sorted(Comparator.reverseOrder())\\n                                        .collect(Collectors.toList());\\n        \\n        return IntStream.range(0, piles.length / 3 * 2)\\n                .filter(i -> i % 2 == 1)\\n                .map(i -> sortedPiles.get(i))\\n                .sum();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 829945,
                "title": "java-easy-solution-stright-forward",
                "content": "```\\nArrays.sort(piles);\\n        int sum=0,choice=piles.length/3;\\n        for(int i=piles.length-2;choice>0;i-=2){\\n            sum+=piles[i];\\n            choice--;\\n        }\\n        return sum;\\n         \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nArrays.sort(piles);\\n        int sum=0,choice=piles.length/3;\\n        for(int i=piles.length-2;choice>0;i-=2){\\n            sum+=piles[i];\\n            choice--;\\n        }\\n        return sum;\\n         \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 829792,
                "title": "easiest-java-solution-for-beginers",
                "content": "class Solution {\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int sum=0;\\n        int t=piles.length/3;\\n        for(int i=t;i<piles.length;i++)\\n        {\\n            sum=sum+piles[i];\\n            i++;\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int sum=0;\\n        int t=piles.length/3;\\n        for(int i=t;i<piles.length;i++)\\n        {\\n            sum=sum+piles[i];\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 829327,
                "title": "easy-java-solution-with-sorting-and-while-loop",
                "content": "```class Solution {\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        \\n        int sum = 0;\\n        int i = 0;\\n        int j = piles.length - 1;\\n        \\n        while(i < j)\\n        {\\n            sum += piles[j-1];\\n            j = j-2;\\n            i++;\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        \\n        int sum = 0;\\n        int i = 0;\\n        int j = piles.length - 1;\\n        \\n        while(i < j)\\n        {\\n            sum += piles[j-1];\\n            j = j-2;\\n            i++;\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565786,
                "content": [
                    {
                        "username": "vivekjain202",
                        "content": "Since this question is straight forward sorting based question, i do feel tagging it as medium level problem isn\\'t justifiable.\\n\\nHope admin rethink and if he/she has a other reasoning i\\'ll be more than happy to know why it is considered as medium level problem.\\n\\nOpen to feedbacks. Thanks in advance :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Agreed, especially compared to some of the other game questions with game theory tag, a lot of those are tricky DP questions. The tag here makes you think that there is more going on, but there just isn\\'t. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "I believe it is tagged medium because the task of selecting three piles could somehow trick some people into thinking it is a dynamic programming problem, getting the pattern/intuition makes it very easy but to get that intuition you need some experience."
                    },
                    {
                        "username": "DCtheTall",
                        "content": "+1, this question is too straightforward to be medium level. It should be easy."
                    },
                    {
                        "username": "mmrubayet",
                        "content": "For chosing a pile of 3 coins:\n- 1st one have to be the biggest coin of all/remaining,\n- 2nd one have to be the 2nd biggest coin of all/remaining,\n- Last one have to be the smallest coin of all/remaining.\n- Remove/forget above 3.\n- Then, Repeat.\n\nApproach:\nFirst, reverse sort the array. Then, start loop from 2nd value which is my first coin. Bob's coins lies in the last side of the array, which is equal to total piles in array, i.e. len/3. End loop before Bob's value. Increment by two.\n\n[Don't see the solution here. Upvote if you understand.\n](https://leetcode.com/problems/maximum-number-of-coins-you-can-get/solutions/3205547/python-simple-easy-to-understand-beats-93-80/\n)"
                    },
                    {
                        "username": "ChloeWalt",
                        "content": "I don\\'t understand why for this test case: [9,8,7,6,5,1,2,3,4], the expected output is 18 and not 15?\\nWhen ordered:\\n[1,2,3,4,5,6,7,8,9]\\nThe coins the second person is choosing would be 2, 5 and 8 which = 15? "
                    },
                    {
                        "username": "dongdieuoke",
                        "content": "[1,8,9]   [2,6,7]   [3,4,5] => 8+6+4 = 18"
                    },
                    {
                        "username": "prachibhatia",
                        "content": "Coins can be chosen in the following ways :-\\nFirst triplet : [9,8,1]\\nSecond triplet : [7,6,2]\\nThirst triplet : [5,4,3]\\nCoins second person will choose are 8+6+4 = 18"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "1) In each step, you will choose any 3 piles of coins (not necessarily consecutive).\\n2) Of your choice, Alice will pick the pile with the maximum number of coins.\\n3) You will pick the next pile with maximum number of coins.\\n4) Your friend Bob will pick the last pile.\\n5)Repeat until there are no more piles of coins.\\n\\n4th point is misleading. \\nlast pile could also  mean last pile of  the original unsorted array itself!!!!!!!!!!!!!!\\n\\n\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "[@williamshark](/williamshark)  not when pile size>3  the last one can be anything. Last of sorted or unsorted  array .  thing is our sum will be maximum only when bob picks  the smallest pile."
                    },
                    {
                        "username": "williamshark",
                        "content": " But it\\'s kind of common sense to think that the last pile is just the one left over by the one you chose or it will be choose \"2 piles\""
                    },
                    {
                        "username": "z3eg",
                        "content": "ez problem"
                    },
                    {
                        "username": "sanskar2003",
                        "content": "This question is just a logic builder. If you are able to find the pattern, you will be able to solve it easily.\n\n class Solution {\n    public int maxCoins(int[] piles) {\n        Arrays.sort(piles);\n        int k = piles.length/3;\n        int result = 0;\n        for(int i=k; i<piles.length; i+=2){\n            result += piles[i];\n        }\n        return result;\n    }\n}"
                    },
                    {
                        "username": "Angad1418",
                        "content": "// catch is sequence does not matter like in last example 9,8,7,6....4\\n        // 1st > ours > last(now we can minimise to lowest) like\\n        // pairs { (9,8,1) (7,6,2) (5,4,3)} by this center is max\\nnow find out how you can reach to this type of sequence"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest medium level problem on this damn platform"
                    },
                    {
                        "username": "rizwan726",
                        "content": "I dont understand why the testcases are not passing?\\nclass Solution {\\n    public static int maxCoins(int x[]) {\\n        int n=x.length;int result=0;\\n        for(int i=n/3;i<n;i=i+2){\\n            result=result+x[i];\\n        }\\n        return result;\\n    }\\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        int T=sc.nextInt();\\n        while(T-->0){\\n            int piles[]=new int[sc.nextInt()];\\n            int temp=0;\\n            for(int i=0;i<piles.length;i++){\\n                piles[i]=sc.nextInt();\\n            }\\n            for(int i=0;i<piles.length;i++){\\n                for(int j=i;j<piles.length;j++){\\n                    if(piles[i]>piles[j]){\\n                        temp=piles[i];\\n                        piles[i]=piles[j];\\n                        piles[j]=temp;\\n                    }\\n                }\\n            }\\n            int x=maxCoins(piles);\\n            System.out.println(x);\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "I thought this is pile so one can\\'t change the order it screwed me\\n\\n``` csharp []\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        var ans=0;\\n        for(var i=piles.Length-1;i>=0;)\\n        {\\n            int a =piles[i--],b=piles[i--],c=piles[i--];\\n            var max = Math.Max(a,Math.Max(b,c));\\n            var min = Math.Min(a,Math.Min(b,c));\\n            if(a!=max && a!=min) ans+=a;\\n            if(b!=max && b!=min) ans+=b;\\n            if(c!=max && c!=min) ans+=c;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```csharp []\\n// correct\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        Array.Sort(piles);\\n        int ans=0,i=0,j=piles.Length;\\n        while(i++<--j) ans+=piles[--j];\\n        return ans;\\n    }\\n}\\n```\\n"
                    }
                ]
            },
            {
                "id": 1806996,
                "content": [
                    {
                        "username": "vivekjain202",
                        "content": "Since this question is straight forward sorting based question, i do feel tagging it as medium level problem isn\\'t justifiable.\\n\\nHope admin rethink and if he/she has a other reasoning i\\'ll be more than happy to know why it is considered as medium level problem.\\n\\nOpen to feedbacks. Thanks in advance :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Agreed, especially compared to some of the other game questions with game theory tag, a lot of those are tricky DP questions. The tag here makes you think that there is more going on, but there just isn\\'t. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "I believe it is tagged medium because the task of selecting three piles could somehow trick some people into thinking it is a dynamic programming problem, getting the pattern/intuition makes it very easy but to get that intuition you need some experience."
                    },
                    {
                        "username": "DCtheTall",
                        "content": "+1, this question is too straightforward to be medium level. It should be easy."
                    },
                    {
                        "username": "mmrubayet",
                        "content": "For chosing a pile of 3 coins:\n- 1st one have to be the biggest coin of all/remaining,\n- 2nd one have to be the 2nd biggest coin of all/remaining,\n- Last one have to be the smallest coin of all/remaining.\n- Remove/forget above 3.\n- Then, Repeat.\n\nApproach:\nFirst, reverse sort the array. Then, start loop from 2nd value which is my first coin. Bob's coins lies in the last side of the array, which is equal to total piles in array, i.e. len/3. End loop before Bob's value. Increment by two.\n\n[Don't see the solution here. Upvote if you understand.\n](https://leetcode.com/problems/maximum-number-of-coins-you-can-get/solutions/3205547/python-simple-easy-to-understand-beats-93-80/\n)"
                    },
                    {
                        "username": "ChloeWalt",
                        "content": "I don\\'t understand why for this test case: [9,8,7,6,5,1,2,3,4], the expected output is 18 and not 15?\\nWhen ordered:\\n[1,2,3,4,5,6,7,8,9]\\nThe coins the second person is choosing would be 2, 5 and 8 which = 15? "
                    },
                    {
                        "username": "dongdieuoke",
                        "content": "[1,8,9]   [2,6,7]   [3,4,5] => 8+6+4 = 18"
                    },
                    {
                        "username": "prachibhatia",
                        "content": "Coins can be chosen in the following ways :-\\nFirst triplet : [9,8,1]\\nSecond triplet : [7,6,2]\\nThirst triplet : [5,4,3]\\nCoins second person will choose are 8+6+4 = 18"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "1) In each step, you will choose any 3 piles of coins (not necessarily consecutive).\\n2) Of your choice, Alice will pick the pile with the maximum number of coins.\\n3) You will pick the next pile with maximum number of coins.\\n4) Your friend Bob will pick the last pile.\\n5)Repeat until there are no more piles of coins.\\n\\n4th point is misleading. \\nlast pile could also  mean last pile of  the original unsorted array itself!!!!!!!!!!!!!!\\n\\n\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "[@williamshark](/williamshark)  not when pile size>3  the last one can be anything. Last of sorted or unsorted  array .  thing is our sum will be maximum only when bob picks  the smallest pile."
                    },
                    {
                        "username": "williamshark",
                        "content": " But it\\'s kind of common sense to think that the last pile is just the one left over by the one you chose or it will be choose \"2 piles\""
                    },
                    {
                        "username": "z3eg",
                        "content": "ez problem"
                    },
                    {
                        "username": "sanskar2003",
                        "content": "This question is just a logic builder. If you are able to find the pattern, you will be able to solve it easily.\n\n class Solution {\n    public int maxCoins(int[] piles) {\n        Arrays.sort(piles);\n        int k = piles.length/3;\n        int result = 0;\n        for(int i=k; i<piles.length; i+=2){\n            result += piles[i];\n        }\n        return result;\n    }\n}"
                    },
                    {
                        "username": "Angad1418",
                        "content": "// catch is sequence does not matter like in last example 9,8,7,6....4\\n        // 1st > ours > last(now we can minimise to lowest) like\\n        // pairs { (9,8,1) (7,6,2) (5,4,3)} by this center is max\\nnow find out how you can reach to this type of sequence"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest medium level problem on this damn platform"
                    },
                    {
                        "username": "rizwan726",
                        "content": "I dont understand why the testcases are not passing?\\nclass Solution {\\n    public static int maxCoins(int x[]) {\\n        int n=x.length;int result=0;\\n        for(int i=n/3;i<n;i=i+2){\\n            result=result+x[i];\\n        }\\n        return result;\\n    }\\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        int T=sc.nextInt();\\n        while(T-->0){\\n            int piles[]=new int[sc.nextInt()];\\n            int temp=0;\\n            for(int i=0;i<piles.length;i++){\\n                piles[i]=sc.nextInt();\\n            }\\n            for(int i=0;i<piles.length;i++){\\n                for(int j=i;j<piles.length;j++){\\n                    if(piles[i]>piles[j]){\\n                        temp=piles[i];\\n                        piles[i]=piles[j];\\n                        piles[j]=temp;\\n                    }\\n                }\\n            }\\n            int x=maxCoins(piles);\\n            System.out.println(x);\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "I thought this is pile so one can\\'t change the order it screwed me\\n\\n``` csharp []\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        var ans=0;\\n        for(var i=piles.Length-1;i>=0;)\\n        {\\n            int a =piles[i--],b=piles[i--],c=piles[i--];\\n            var max = Math.Max(a,Math.Max(b,c));\\n            var min = Math.Min(a,Math.Min(b,c));\\n            if(a!=max && a!=min) ans+=a;\\n            if(b!=max && b!=min) ans+=b;\\n            if(c!=max && c!=min) ans+=c;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```csharp []\\n// correct\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        Array.Sort(piles);\\n        int ans=0,i=0,j=piles.Length;\\n        while(i++<--j) ans+=piles[--j];\\n        return ans;\\n    }\\n}\\n```\\n"
                    }
                ]
            },
            {
                "id": 1728868,
                "content": [
                    {
                        "username": "vivekjain202",
                        "content": "Since this question is straight forward sorting based question, i do feel tagging it as medium level problem isn\\'t justifiable.\\n\\nHope admin rethink and if he/she has a other reasoning i\\'ll be more than happy to know why it is considered as medium level problem.\\n\\nOpen to feedbacks. Thanks in advance :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Agreed, especially compared to some of the other game questions with game theory tag, a lot of those are tricky DP questions. The tag here makes you think that there is more going on, but there just isn\\'t. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "I believe it is tagged medium because the task of selecting three piles could somehow trick some people into thinking it is a dynamic programming problem, getting the pattern/intuition makes it very easy but to get that intuition you need some experience."
                    },
                    {
                        "username": "DCtheTall",
                        "content": "+1, this question is too straightforward to be medium level. It should be easy."
                    },
                    {
                        "username": "mmrubayet",
                        "content": "For chosing a pile of 3 coins:\n- 1st one have to be the biggest coin of all/remaining,\n- 2nd one have to be the 2nd biggest coin of all/remaining,\n- Last one have to be the smallest coin of all/remaining.\n- Remove/forget above 3.\n- Then, Repeat.\n\nApproach:\nFirst, reverse sort the array. Then, start loop from 2nd value which is my first coin. Bob's coins lies in the last side of the array, which is equal to total piles in array, i.e. len/3. End loop before Bob's value. Increment by two.\n\n[Don't see the solution here. Upvote if you understand.\n](https://leetcode.com/problems/maximum-number-of-coins-you-can-get/solutions/3205547/python-simple-easy-to-understand-beats-93-80/\n)"
                    },
                    {
                        "username": "ChloeWalt",
                        "content": "I don\\'t understand why for this test case: [9,8,7,6,5,1,2,3,4], the expected output is 18 and not 15?\\nWhen ordered:\\n[1,2,3,4,5,6,7,8,9]\\nThe coins the second person is choosing would be 2, 5 and 8 which = 15? "
                    },
                    {
                        "username": "dongdieuoke",
                        "content": "[1,8,9]   [2,6,7]   [3,4,5] => 8+6+4 = 18"
                    },
                    {
                        "username": "prachibhatia",
                        "content": "Coins can be chosen in the following ways :-\\nFirst triplet : [9,8,1]\\nSecond triplet : [7,6,2]\\nThirst triplet : [5,4,3]\\nCoins second person will choose are 8+6+4 = 18"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "1) In each step, you will choose any 3 piles of coins (not necessarily consecutive).\\n2) Of your choice, Alice will pick the pile with the maximum number of coins.\\n3) You will pick the next pile with maximum number of coins.\\n4) Your friend Bob will pick the last pile.\\n5)Repeat until there are no more piles of coins.\\n\\n4th point is misleading. \\nlast pile could also  mean last pile of  the original unsorted array itself!!!!!!!!!!!!!!\\n\\n\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "[@williamshark](/williamshark)  not when pile size>3  the last one can be anything. Last of sorted or unsorted  array .  thing is our sum will be maximum only when bob picks  the smallest pile."
                    },
                    {
                        "username": "williamshark",
                        "content": " But it\\'s kind of common sense to think that the last pile is just the one left over by the one you chose or it will be choose \"2 piles\""
                    },
                    {
                        "username": "z3eg",
                        "content": "ez problem"
                    },
                    {
                        "username": "sanskar2003",
                        "content": "This question is just a logic builder. If you are able to find the pattern, you will be able to solve it easily.\n\n class Solution {\n    public int maxCoins(int[] piles) {\n        Arrays.sort(piles);\n        int k = piles.length/3;\n        int result = 0;\n        for(int i=k; i<piles.length; i+=2){\n            result += piles[i];\n        }\n        return result;\n    }\n}"
                    },
                    {
                        "username": "Angad1418",
                        "content": "// catch is sequence does not matter like in last example 9,8,7,6....4\\n        // 1st > ours > last(now we can minimise to lowest) like\\n        // pairs { (9,8,1) (7,6,2) (5,4,3)} by this center is max\\nnow find out how you can reach to this type of sequence"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest medium level problem on this damn platform"
                    },
                    {
                        "username": "rizwan726",
                        "content": "I dont understand why the testcases are not passing?\\nclass Solution {\\n    public static int maxCoins(int x[]) {\\n        int n=x.length;int result=0;\\n        for(int i=n/3;i<n;i=i+2){\\n            result=result+x[i];\\n        }\\n        return result;\\n    }\\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        int T=sc.nextInt();\\n        while(T-->0){\\n            int piles[]=new int[sc.nextInt()];\\n            int temp=0;\\n            for(int i=0;i<piles.length;i++){\\n                piles[i]=sc.nextInt();\\n            }\\n            for(int i=0;i<piles.length;i++){\\n                for(int j=i;j<piles.length;j++){\\n                    if(piles[i]>piles[j]){\\n                        temp=piles[i];\\n                        piles[i]=piles[j];\\n                        piles[j]=temp;\\n                    }\\n                }\\n            }\\n            int x=maxCoins(piles);\\n            System.out.println(x);\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "I thought this is pile so one can\\'t change the order it screwed me\\n\\n``` csharp []\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        var ans=0;\\n        for(var i=piles.Length-1;i>=0;)\\n        {\\n            int a =piles[i--],b=piles[i--],c=piles[i--];\\n            var max = Math.Max(a,Math.Max(b,c));\\n            var min = Math.Min(a,Math.Min(b,c));\\n            if(a!=max && a!=min) ans+=a;\\n            if(b!=max && b!=min) ans+=b;\\n            if(c!=max && c!=min) ans+=c;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```csharp []\\n// correct\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        Array.Sort(piles);\\n        int ans=0,i=0,j=piles.Length;\\n        while(i++<--j) ans+=piles[--j];\\n        return ans;\\n    }\\n}\\n```\\n"
                    }
                ]
            },
            {
                "id": 1574264,
                "content": [
                    {
                        "username": "vivekjain202",
                        "content": "Since this question is straight forward sorting based question, i do feel tagging it as medium level problem isn\\'t justifiable.\\n\\nHope admin rethink and if he/she has a other reasoning i\\'ll be more than happy to know why it is considered as medium level problem.\\n\\nOpen to feedbacks. Thanks in advance :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Agreed, especially compared to some of the other game questions with game theory tag, a lot of those are tricky DP questions. The tag here makes you think that there is more going on, but there just isn\\'t. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "I believe it is tagged medium because the task of selecting three piles could somehow trick some people into thinking it is a dynamic programming problem, getting the pattern/intuition makes it very easy but to get that intuition you need some experience."
                    },
                    {
                        "username": "DCtheTall",
                        "content": "+1, this question is too straightforward to be medium level. It should be easy."
                    },
                    {
                        "username": "mmrubayet",
                        "content": "For chosing a pile of 3 coins:\n- 1st one have to be the biggest coin of all/remaining,\n- 2nd one have to be the 2nd biggest coin of all/remaining,\n- Last one have to be the smallest coin of all/remaining.\n- Remove/forget above 3.\n- Then, Repeat.\n\nApproach:\nFirst, reverse sort the array. Then, start loop from 2nd value which is my first coin. Bob's coins lies in the last side of the array, which is equal to total piles in array, i.e. len/3. End loop before Bob's value. Increment by two.\n\n[Don't see the solution here. Upvote if you understand.\n](https://leetcode.com/problems/maximum-number-of-coins-you-can-get/solutions/3205547/python-simple-easy-to-understand-beats-93-80/\n)"
                    },
                    {
                        "username": "ChloeWalt",
                        "content": "I don\\'t understand why for this test case: [9,8,7,6,5,1,2,3,4], the expected output is 18 and not 15?\\nWhen ordered:\\n[1,2,3,4,5,6,7,8,9]\\nThe coins the second person is choosing would be 2, 5 and 8 which = 15? "
                    },
                    {
                        "username": "dongdieuoke",
                        "content": "[1,8,9]   [2,6,7]   [3,4,5] => 8+6+4 = 18"
                    },
                    {
                        "username": "prachibhatia",
                        "content": "Coins can be chosen in the following ways :-\\nFirst triplet : [9,8,1]\\nSecond triplet : [7,6,2]\\nThirst triplet : [5,4,3]\\nCoins second person will choose are 8+6+4 = 18"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "1) In each step, you will choose any 3 piles of coins (not necessarily consecutive).\\n2) Of your choice, Alice will pick the pile with the maximum number of coins.\\n3) You will pick the next pile with maximum number of coins.\\n4) Your friend Bob will pick the last pile.\\n5)Repeat until there are no more piles of coins.\\n\\n4th point is misleading. \\nlast pile could also  mean last pile of  the original unsorted array itself!!!!!!!!!!!!!!\\n\\n\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "[@williamshark](/williamshark)  not when pile size>3  the last one can be anything. Last of sorted or unsorted  array .  thing is our sum will be maximum only when bob picks  the smallest pile."
                    },
                    {
                        "username": "williamshark",
                        "content": " But it\\'s kind of common sense to think that the last pile is just the one left over by the one you chose or it will be choose \"2 piles\""
                    },
                    {
                        "username": "z3eg",
                        "content": "ez problem"
                    },
                    {
                        "username": "sanskar2003",
                        "content": "This question is just a logic builder. If you are able to find the pattern, you will be able to solve it easily.\n\n class Solution {\n    public int maxCoins(int[] piles) {\n        Arrays.sort(piles);\n        int k = piles.length/3;\n        int result = 0;\n        for(int i=k; i<piles.length; i+=2){\n            result += piles[i];\n        }\n        return result;\n    }\n}"
                    },
                    {
                        "username": "Angad1418",
                        "content": "// catch is sequence does not matter like in last example 9,8,7,6....4\\n        // 1st > ours > last(now we can minimise to lowest) like\\n        // pairs { (9,8,1) (7,6,2) (5,4,3)} by this center is max\\nnow find out how you can reach to this type of sequence"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest medium level problem on this damn platform"
                    },
                    {
                        "username": "rizwan726",
                        "content": "I dont understand why the testcases are not passing?\\nclass Solution {\\n    public static int maxCoins(int x[]) {\\n        int n=x.length;int result=0;\\n        for(int i=n/3;i<n;i=i+2){\\n            result=result+x[i];\\n        }\\n        return result;\\n    }\\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        int T=sc.nextInt();\\n        while(T-->0){\\n            int piles[]=new int[sc.nextInt()];\\n            int temp=0;\\n            for(int i=0;i<piles.length;i++){\\n                piles[i]=sc.nextInt();\\n            }\\n            for(int i=0;i<piles.length;i++){\\n                for(int j=i;j<piles.length;j++){\\n                    if(piles[i]>piles[j]){\\n                        temp=piles[i];\\n                        piles[i]=piles[j];\\n                        piles[j]=temp;\\n                    }\\n                }\\n            }\\n            int x=maxCoins(piles);\\n            System.out.println(x);\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "I thought this is pile so one can\\'t change the order it screwed me\\n\\n``` csharp []\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        var ans=0;\\n        for(var i=piles.Length-1;i>=0;)\\n        {\\n            int a =piles[i--],b=piles[i--],c=piles[i--];\\n            var max = Math.Max(a,Math.Max(b,c));\\n            var min = Math.Min(a,Math.Min(b,c));\\n            if(a!=max && a!=min) ans+=a;\\n            if(b!=max && b!=min) ans+=b;\\n            if(c!=max && c!=min) ans+=c;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```csharp []\\n// correct\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        Array.Sort(piles);\\n        int ans=0,i=0,j=piles.Length;\\n        while(i++<--j) ans+=piles[--j];\\n        return ans;\\n    }\\n}\\n```\\n"
                    }
                ]
            },
            {
                "id": 1936076,
                "content": [
                    {
                        "username": "vivekjain202",
                        "content": "Since this question is straight forward sorting based question, i do feel tagging it as medium level problem isn\\'t justifiable.\\n\\nHope admin rethink and if he/she has a other reasoning i\\'ll be more than happy to know why it is considered as medium level problem.\\n\\nOpen to feedbacks. Thanks in advance :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Agreed, especially compared to some of the other game questions with game theory tag, a lot of those are tricky DP questions. The tag here makes you think that there is more going on, but there just isn\\'t. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "I believe it is tagged medium because the task of selecting three piles could somehow trick some people into thinking it is a dynamic programming problem, getting the pattern/intuition makes it very easy but to get that intuition you need some experience."
                    },
                    {
                        "username": "DCtheTall",
                        "content": "+1, this question is too straightforward to be medium level. It should be easy."
                    },
                    {
                        "username": "mmrubayet",
                        "content": "For chosing a pile of 3 coins:\n- 1st one have to be the biggest coin of all/remaining,\n- 2nd one have to be the 2nd biggest coin of all/remaining,\n- Last one have to be the smallest coin of all/remaining.\n- Remove/forget above 3.\n- Then, Repeat.\n\nApproach:\nFirst, reverse sort the array. Then, start loop from 2nd value which is my first coin. Bob's coins lies in the last side of the array, which is equal to total piles in array, i.e. len/3. End loop before Bob's value. Increment by two.\n\n[Don't see the solution here. Upvote if you understand.\n](https://leetcode.com/problems/maximum-number-of-coins-you-can-get/solutions/3205547/python-simple-easy-to-understand-beats-93-80/\n)"
                    },
                    {
                        "username": "ChloeWalt",
                        "content": "I don\\'t understand why for this test case: [9,8,7,6,5,1,2,3,4], the expected output is 18 and not 15?\\nWhen ordered:\\n[1,2,3,4,5,6,7,8,9]\\nThe coins the second person is choosing would be 2, 5 and 8 which = 15? "
                    },
                    {
                        "username": "dongdieuoke",
                        "content": "[1,8,9]   [2,6,7]   [3,4,5] => 8+6+4 = 18"
                    },
                    {
                        "username": "prachibhatia",
                        "content": "Coins can be chosen in the following ways :-\\nFirst triplet : [9,8,1]\\nSecond triplet : [7,6,2]\\nThirst triplet : [5,4,3]\\nCoins second person will choose are 8+6+4 = 18"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "1) In each step, you will choose any 3 piles of coins (not necessarily consecutive).\\n2) Of your choice, Alice will pick the pile with the maximum number of coins.\\n3) You will pick the next pile with maximum number of coins.\\n4) Your friend Bob will pick the last pile.\\n5)Repeat until there are no more piles of coins.\\n\\n4th point is misleading. \\nlast pile could also  mean last pile of  the original unsorted array itself!!!!!!!!!!!!!!\\n\\n\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "[@williamshark](/williamshark)  not when pile size>3  the last one can be anything. Last of sorted or unsorted  array .  thing is our sum will be maximum only when bob picks  the smallest pile."
                    },
                    {
                        "username": "williamshark",
                        "content": " But it\\'s kind of common sense to think that the last pile is just the one left over by the one you chose or it will be choose \"2 piles\""
                    },
                    {
                        "username": "z3eg",
                        "content": "ez problem"
                    },
                    {
                        "username": "sanskar2003",
                        "content": "This question is just a logic builder. If you are able to find the pattern, you will be able to solve it easily.\n\n class Solution {\n    public int maxCoins(int[] piles) {\n        Arrays.sort(piles);\n        int k = piles.length/3;\n        int result = 0;\n        for(int i=k; i<piles.length; i+=2){\n            result += piles[i];\n        }\n        return result;\n    }\n}"
                    },
                    {
                        "username": "Angad1418",
                        "content": "// catch is sequence does not matter like in last example 9,8,7,6....4\\n        // 1st > ours > last(now we can minimise to lowest) like\\n        // pairs { (9,8,1) (7,6,2) (5,4,3)} by this center is max\\nnow find out how you can reach to this type of sequence"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest medium level problem on this damn platform"
                    },
                    {
                        "username": "rizwan726",
                        "content": "I dont understand why the testcases are not passing?\\nclass Solution {\\n    public static int maxCoins(int x[]) {\\n        int n=x.length;int result=0;\\n        for(int i=n/3;i<n;i=i+2){\\n            result=result+x[i];\\n        }\\n        return result;\\n    }\\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        int T=sc.nextInt();\\n        while(T-->0){\\n            int piles[]=new int[sc.nextInt()];\\n            int temp=0;\\n            for(int i=0;i<piles.length;i++){\\n                piles[i]=sc.nextInt();\\n            }\\n            for(int i=0;i<piles.length;i++){\\n                for(int j=i;j<piles.length;j++){\\n                    if(piles[i]>piles[j]){\\n                        temp=piles[i];\\n                        piles[i]=piles[j];\\n                        piles[j]=temp;\\n                    }\\n                }\\n            }\\n            int x=maxCoins(piles);\\n            System.out.println(x);\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "I thought this is pile so one can\\'t change the order it screwed me\\n\\n``` csharp []\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        var ans=0;\\n        for(var i=piles.Length-1;i>=0;)\\n        {\\n            int a =piles[i--],b=piles[i--],c=piles[i--];\\n            var max = Math.Max(a,Math.Max(b,c));\\n            var min = Math.Min(a,Math.Min(b,c));\\n            if(a!=max && a!=min) ans+=a;\\n            if(b!=max && b!=min) ans+=b;\\n            if(c!=max && c!=min) ans+=c;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```csharp []\\n// correct\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        Array.Sort(piles);\\n        int ans=0,i=0,j=piles.Length;\\n        while(i++<--j) ans+=piles[--j];\\n        return ans;\\n    }\\n}\\n```\\n"
                    }
                ]
            },
            {
                "id": 1782043,
                "content": [
                    {
                        "username": "vivekjain202",
                        "content": "Since this question is straight forward sorting based question, i do feel tagging it as medium level problem isn\\'t justifiable.\\n\\nHope admin rethink and if he/she has a other reasoning i\\'ll be more than happy to know why it is considered as medium level problem.\\n\\nOpen to feedbacks. Thanks in advance :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Agreed, especially compared to some of the other game questions with game theory tag, a lot of those are tricky DP questions. The tag here makes you think that there is more going on, but there just isn\\'t. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "I believe it is tagged medium because the task of selecting three piles could somehow trick some people into thinking it is a dynamic programming problem, getting the pattern/intuition makes it very easy but to get that intuition you need some experience."
                    },
                    {
                        "username": "DCtheTall",
                        "content": "+1, this question is too straightforward to be medium level. It should be easy."
                    },
                    {
                        "username": "mmrubayet",
                        "content": "For chosing a pile of 3 coins:\n- 1st one have to be the biggest coin of all/remaining,\n- 2nd one have to be the 2nd biggest coin of all/remaining,\n- Last one have to be the smallest coin of all/remaining.\n- Remove/forget above 3.\n- Then, Repeat.\n\nApproach:\nFirst, reverse sort the array. Then, start loop from 2nd value which is my first coin. Bob's coins lies in the last side of the array, which is equal to total piles in array, i.e. len/3. End loop before Bob's value. Increment by two.\n\n[Don't see the solution here. Upvote if you understand.\n](https://leetcode.com/problems/maximum-number-of-coins-you-can-get/solutions/3205547/python-simple-easy-to-understand-beats-93-80/\n)"
                    },
                    {
                        "username": "ChloeWalt",
                        "content": "I don\\'t understand why for this test case: [9,8,7,6,5,1,2,3,4], the expected output is 18 and not 15?\\nWhen ordered:\\n[1,2,3,4,5,6,7,8,9]\\nThe coins the second person is choosing would be 2, 5 and 8 which = 15? "
                    },
                    {
                        "username": "dongdieuoke",
                        "content": "[1,8,9]   [2,6,7]   [3,4,5] => 8+6+4 = 18"
                    },
                    {
                        "username": "prachibhatia",
                        "content": "Coins can be chosen in the following ways :-\\nFirst triplet : [9,8,1]\\nSecond triplet : [7,6,2]\\nThirst triplet : [5,4,3]\\nCoins second person will choose are 8+6+4 = 18"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "1) In each step, you will choose any 3 piles of coins (not necessarily consecutive).\\n2) Of your choice, Alice will pick the pile with the maximum number of coins.\\n3) You will pick the next pile with maximum number of coins.\\n4) Your friend Bob will pick the last pile.\\n5)Repeat until there are no more piles of coins.\\n\\n4th point is misleading. \\nlast pile could also  mean last pile of  the original unsorted array itself!!!!!!!!!!!!!!\\n\\n\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "[@williamshark](/williamshark)  not when pile size>3  the last one can be anything. Last of sorted or unsorted  array .  thing is our sum will be maximum only when bob picks  the smallest pile."
                    },
                    {
                        "username": "williamshark",
                        "content": " But it\\'s kind of common sense to think that the last pile is just the one left over by the one you chose or it will be choose \"2 piles\""
                    },
                    {
                        "username": "z3eg",
                        "content": "ez problem"
                    },
                    {
                        "username": "sanskar2003",
                        "content": "This question is just a logic builder. If you are able to find the pattern, you will be able to solve it easily.\n\n class Solution {\n    public int maxCoins(int[] piles) {\n        Arrays.sort(piles);\n        int k = piles.length/3;\n        int result = 0;\n        for(int i=k; i<piles.length; i+=2){\n            result += piles[i];\n        }\n        return result;\n    }\n}"
                    },
                    {
                        "username": "Angad1418",
                        "content": "// catch is sequence does not matter like in last example 9,8,7,6....4\\n        // 1st > ours > last(now we can minimise to lowest) like\\n        // pairs { (9,8,1) (7,6,2) (5,4,3)} by this center is max\\nnow find out how you can reach to this type of sequence"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest medium level problem on this damn platform"
                    },
                    {
                        "username": "rizwan726",
                        "content": "I dont understand why the testcases are not passing?\\nclass Solution {\\n    public static int maxCoins(int x[]) {\\n        int n=x.length;int result=0;\\n        for(int i=n/3;i<n;i=i+2){\\n            result=result+x[i];\\n        }\\n        return result;\\n    }\\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        int T=sc.nextInt();\\n        while(T-->0){\\n            int piles[]=new int[sc.nextInt()];\\n            int temp=0;\\n            for(int i=0;i<piles.length;i++){\\n                piles[i]=sc.nextInt();\\n            }\\n            for(int i=0;i<piles.length;i++){\\n                for(int j=i;j<piles.length;j++){\\n                    if(piles[i]>piles[j]){\\n                        temp=piles[i];\\n                        piles[i]=piles[j];\\n                        piles[j]=temp;\\n                    }\\n                }\\n            }\\n            int x=maxCoins(piles);\\n            System.out.println(x);\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "I thought this is pile so one can\\'t change the order it screwed me\\n\\n``` csharp []\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        var ans=0;\\n        for(var i=piles.Length-1;i>=0;)\\n        {\\n            int a =piles[i--],b=piles[i--],c=piles[i--];\\n            var max = Math.Max(a,Math.Max(b,c));\\n            var min = Math.Min(a,Math.Min(b,c));\\n            if(a!=max && a!=min) ans+=a;\\n            if(b!=max && b!=min) ans+=b;\\n            if(c!=max && c!=min) ans+=c;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```csharp []\\n// correct\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        Array.Sort(piles);\\n        int ans=0,i=0,j=piles.Length;\\n        while(i++<--j) ans+=piles[--j];\\n        return ans;\\n    }\\n}\\n```\\n"
                    }
                ]
            },
            {
                "id": 2025862,
                "content": [
                    {
                        "username": "vivekjain202",
                        "content": "Since this question is straight forward sorting based question, i do feel tagging it as medium level problem isn\\'t justifiable.\\n\\nHope admin rethink and if he/she has a other reasoning i\\'ll be more than happy to know why it is considered as medium level problem.\\n\\nOpen to feedbacks. Thanks in advance :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Agreed, especially compared to some of the other game questions with game theory tag, a lot of those are tricky DP questions. The tag here makes you think that there is more going on, but there just isn\\'t. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "I believe it is tagged medium because the task of selecting three piles could somehow trick some people into thinking it is a dynamic programming problem, getting the pattern/intuition makes it very easy but to get that intuition you need some experience."
                    },
                    {
                        "username": "DCtheTall",
                        "content": "+1, this question is too straightforward to be medium level. It should be easy."
                    },
                    {
                        "username": "mmrubayet",
                        "content": "For chosing a pile of 3 coins:\n- 1st one have to be the biggest coin of all/remaining,\n- 2nd one have to be the 2nd biggest coin of all/remaining,\n- Last one have to be the smallest coin of all/remaining.\n- Remove/forget above 3.\n- Then, Repeat.\n\nApproach:\nFirst, reverse sort the array. Then, start loop from 2nd value which is my first coin. Bob's coins lies in the last side of the array, which is equal to total piles in array, i.e. len/3. End loop before Bob's value. Increment by two.\n\n[Don't see the solution here. Upvote if you understand.\n](https://leetcode.com/problems/maximum-number-of-coins-you-can-get/solutions/3205547/python-simple-easy-to-understand-beats-93-80/\n)"
                    },
                    {
                        "username": "ChloeWalt",
                        "content": "I don\\'t understand why for this test case: [9,8,7,6,5,1,2,3,4], the expected output is 18 and not 15?\\nWhen ordered:\\n[1,2,3,4,5,6,7,8,9]\\nThe coins the second person is choosing would be 2, 5 and 8 which = 15? "
                    },
                    {
                        "username": "dongdieuoke",
                        "content": "[1,8,9]   [2,6,7]   [3,4,5] => 8+6+4 = 18"
                    },
                    {
                        "username": "prachibhatia",
                        "content": "Coins can be chosen in the following ways :-\\nFirst triplet : [9,8,1]\\nSecond triplet : [7,6,2]\\nThirst triplet : [5,4,3]\\nCoins second person will choose are 8+6+4 = 18"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "1) In each step, you will choose any 3 piles of coins (not necessarily consecutive).\\n2) Of your choice, Alice will pick the pile with the maximum number of coins.\\n3) You will pick the next pile with maximum number of coins.\\n4) Your friend Bob will pick the last pile.\\n5)Repeat until there are no more piles of coins.\\n\\n4th point is misleading. \\nlast pile could also  mean last pile of  the original unsorted array itself!!!!!!!!!!!!!!\\n\\n\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "[@williamshark](/williamshark)  not when pile size>3  the last one can be anything. Last of sorted or unsorted  array .  thing is our sum will be maximum only when bob picks  the smallest pile."
                    },
                    {
                        "username": "williamshark",
                        "content": " But it\\'s kind of common sense to think that the last pile is just the one left over by the one you chose or it will be choose \"2 piles\""
                    },
                    {
                        "username": "z3eg",
                        "content": "ez problem"
                    },
                    {
                        "username": "sanskar2003",
                        "content": "This question is just a logic builder. If you are able to find the pattern, you will be able to solve it easily.\n\n class Solution {\n    public int maxCoins(int[] piles) {\n        Arrays.sort(piles);\n        int k = piles.length/3;\n        int result = 0;\n        for(int i=k; i<piles.length; i+=2){\n            result += piles[i];\n        }\n        return result;\n    }\n}"
                    },
                    {
                        "username": "Angad1418",
                        "content": "// catch is sequence does not matter like in last example 9,8,7,6....4\\n        // 1st > ours > last(now we can minimise to lowest) like\\n        // pairs { (9,8,1) (7,6,2) (5,4,3)} by this center is max\\nnow find out how you can reach to this type of sequence"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest medium level problem on this damn platform"
                    },
                    {
                        "username": "rizwan726",
                        "content": "I dont understand why the testcases are not passing?\\nclass Solution {\\n    public static int maxCoins(int x[]) {\\n        int n=x.length;int result=0;\\n        for(int i=n/3;i<n;i=i+2){\\n            result=result+x[i];\\n        }\\n        return result;\\n    }\\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        int T=sc.nextInt();\\n        while(T-->0){\\n            int piles[]=new int[sc.nextInt()];\\n            int temp=0;\\n            for(int i=0;i<piles.length;i++){\\n                piles[i]=sc.nextInt();\\n            }\\n            for(int i=0;i<piles.length;i++){\\n                for(int j=i;j<piles.length;j++){\\n                    if(piles[i]>piles[j]){\\n                        temp=piles[i];\\n                        piles[i]=piles[j];\\n                        piles[j]=temp;\\n                    }\\n                }\\n            }\\n            int x=maxCoins(piles);\\n            System.out.println(x);\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "I thought this is pile so one can\\'t change the order it screwed me\\n\\n``` csharp []\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        var ans=0;\\n        for(var i=piles.Length-1;i>=0;)\\n        {\\n            int a =piles[i--],b=piles[i--],c=piles[i--];\\n            var max = Math.Max(a,Math.Max(b,c));\\n            var min = Math.Min(a,Math.Min(b,c));\\n            if(a!=max && a!=min) ans+=a;\\n            if(b!=max && b!=min) ans+=b;\\n            if(c!=max && c!=min) ans+=c;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```csharp []\\n// correct\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        Array.Sort(piles);\\n        int ans=0,i=0,j=piles.Length;\\n        while(i++<--j) ans+=piles[--j];\\n        return ans;\\n    }\\n}\\n```\\n"
                    }
                ]
            },
            {
                "id": 1965577,
                "content": [
                    {
                        "username": "vivekjain202",
                        "content": "Since this question is straight forward sorting based question, i do feel tagging it as medium level problem isn\\'t justifiable.\\n\\nHope admin rethink and if he/she has a other reasoning i\\'ll be more than happy to know why it is considered as medium level problem.\\n\\nOpen to feedbacks. Thanks in advance :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Agreed, especially compared to some of the other game questions with game theory tag, a lot of those are tricky DP questions. The tag here makes you think that there is more going on, but there just isn\\'t. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "I believe it is tagged medium because the task of selecting three piles could somehow trick some people into thinking it is a dynamic programming problem, getting the pattern/intuition makes it very easy but to get that intuition you need some experience."
                    },
                    {
                        "username": "DCtheTall",
                        "content": "+1, this question is too straightforward to be medium level. It should be easy."
                    },
                    {
                        "username": "mmrubayet",
                        "content": "For chosing a pile of 3 coins:\n- 1st one have to be the biggest coin of all/remaining,\n- 2nd one have to be the 2nd biggest coin of all/remaining,\n- Last one have to be the smallest coin of all/remaining.\n- Remove/forget above 3.\n- Then, Repeat.\n\nApproach:\nFirst, reverse sort the array. Then, start loop from 2nd value which is my first coin. Bob's coins lies in the last side of the array, which is equal to total piles in array, i.e. len/3. End loop before Bob's value. Increment by two.\n\n[Don't see the solution here. Upvote if you understand.\n](https://leetcode.com/problems/maximum-number-of-coins-you-can-get/solutions/3205547/python-simple-easy-to-understand-beats-93-80/\n)"
                    },
                    {
                        "username": "ChloeWalt",
                        "content": "I don\\'t understand why for this test case: [9,8,7,6,5,1,2,3,4], the expected output is 18 and not 15?\\nWhen ordered:\\n[1,2,3,4,5,6,7,8,9]\\nThe coins the second person is choosing would be 2, 5 and 8 which = 15? "
                    },
                    {
                        "username": "dongdieuoke",
                        "content": "[1,8,9]   [2,6,7]   [3,4,5] => 8+6+4 = 18"
                    },
                    {
                        "username": "prachibhatia",
                        "content": "Coins can be chosen in the following ways :-\\nFirst triplet : [9,8,1]\\nSecond triplet : [7,6,2]\\nThirst triplet : [5,4,3]\\nCoins second person will choose are 8+6+4 = 18"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "1) In each step, you will choose any 3 piles of coins (not necessarily consecutive).\\n2) Of your choice, Alice will pick the pile with the maximum number of coins.\\n3) You will pick the next pile with maximum number of coins.\\n4) Your friend Bob will pick the last pile.\\n5)Repeat until there are no more piles of coins.\\n\\n4th point is misleading. \\nlast pile could also  mean last pile of  the original unsorted array itself!!!!!!!!!!!!!!\\n\\n\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "[@williamshark](/williamshark)  not when pile size>3  the last one can be anything. Last of sorted or unsorted  array .  thing is our sum will be maximum only when bob picks  the smallest pile."
                    },
                    {
                        "username": "williamshark",
                        "content": " But it\\'s kind of common sense to think that the last pile is just the one left over by the one you chose or it will be choose \"2 piles\""
                    },
                    {
                        "username": "z3eg",
                        "content": "ez problem"
                    },
                    {
                        "username": "sanskar2003",
                        "content": "This question is just a logic builder. If you are able to find the pattern, you will be able to solve it easily.\n\n class Solution {\n    public int maxCoins(int[] piles) {\n        Arrays.sort(piles);\n        int k = piles.length/3;\n        int result = 0;\n        for(int i=k; i<piles.length; i+=2){\n            result += piles[i];\n        }\n        return result;\n    }\n}"
                    },
                    {
                        "username": "Angad1418",
                        "content": "// catch is sequence does not matter like in last example 9,8,7,6....4\\n        // 1st > ours > last(now we can minimise to lowest) like\\n        // pairs { (9,8,1) (7,6,2) (5,4,3)} by this center is max\\nnow find out how you can reach to this type of sequence"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest medium level problem on this damn platform"
                    },
                    {
                        "username": "rizwan726",
                        "content": "I dont understand why the testcases are not passing?\\nclass Solution {\\n    public static int maxCoins(int x[]) {\\n        int n=x.length;int result=0;\\n        for(int i=n/3;i<n;i=i+2){\\n            result=result+x[i];\\n        }\\n        return result;\\n    }\\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        int T=sc.nextInt();\\n        while(T-->0){\\n            int piles[]=new int[sc.nextInt()];\\n            int temp=0;\\n            for(int i=0;i<piles.length;i++){\\n                piles[i]=sc.nextInt();\\n            }\\n            for(int i=0;i<piles.length;i++){\\n                for(int j=i;j<piles.length;j++){\\n                    if(piles[i]>piles[j]){\\n                        temp=piles[i];\\n                        piles[i]=piles[j];\\n                        piles[j]=temp;\\n                    }\\n                }\\n            }\\n            int x=maxCoins(piles);\\n            System.out.println(x);\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "I thought this is pile so one can\\'t change the order it screwed me\\n\\n``` csharp []\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        var ans=0;\\n        for(var i=piles.Length-1;i>=0;)\\n        {\\n            int a =piles[i--],b=piles[i--],c=piles[i--];\\n            var max = Math.Max(a,Math.Max(b,c));\\n            var min = Math.Min(a,Math.Min(b,c));\\n            if(a!=max && a!=min) ans+=a;\\n            if(b!=max && b!=min) ans+=b;\\n            if(c!=max && c!=min) ans+=c;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```csharp []\\n// correct\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        Array.Sort(piles);\\n        int ans=0,i=0,j=piles.Length;\\n        while(i++<--j) ans+=piles[--j];\\n        return ans;\\n    }\\n}\\n```\\n"
                    }
                ]
            },
            {
                "id": 1860360,
                "content": [
                    {
                        "username": "vivekjain202",
                        "content": "Since this question is straight forward sorting based question, i do feel tagging it as medium level problem isn\\'t justifiable.\\n\\nHope admin rethink and if he/she has a other reasoning i\\'ll be more than happy to know why it is considered as medium level problem.\\n\\nOpen to feedbacks. Thanks in advance :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Agreed, especially compared to some of the other game questions with game theory tag, a lot of those are tricky DP questions. The tag here makes you think that there is more going on, but there just isn\\'t. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "I believe it is tagged medium because the task of selecting three piles could somehow trick some people into thinking it is a dynamic programming problem, getting the pattern/intuition makes it very easy but to get that intuition you need some experience."
                    },
                    {
                        "username": "DCtheTall",
                        "content": "+1, this question is too straightforward to be medium level. It should be easy."
                    },
                    {
                        "username": "mmrubayet",
                        "content": "For chosing a pile of 3 coins:\n- 1st one have to be the biggest coin of all/remaining,\n- 2nd one have to be the 2nd biggest coin of all/remaining,\n- Last one have to be the smallest coin of all/remaining.\n- Remove/forget above 3.\n- Then, Repeat.\n\nApproach:\nFirst, reverse sort the array. Then, start loop from 2nd value which is my first coin. Bob's coins lies in the last side of the array, which is equal to total piles in array, i.e. len/3. End loop before Bob's value. Increment by two.\n\n[Don't see the solution here. Upvote if you understand.\n](https://leetcode.com/problems/maximum-number-of-coins-you-can-get/solutions/3205547/python-simple-easy-to-understand-beats-93-80/\n)"
                    },
                    {
                        "username": "ChloeWalt",
                        "content": "I don\\'t understand why for this test case: [9,8,7,6,5,1,2,3,4], the expected output is 18 and not 15?\\nWhen ordered:\\n[1,2,3,4,5,6,7,8,9]\\nThe coins the second person is choosing would be 2, 5 and 8 which = 15? "
                    },
                    {
                        "username": "dongdieuoke",
                        "content": "[1,8,9]   [2,6,7]   [3,4,5] => 8+6+4 = 18"
                    },
                    {
                        "username": "prachibhatia",
                        "content": "Coins can be chosen in the following ways :-\\nFirst triplet : [9,8,1]\\nSecond triplet : [7,6,2]\\nThirst triplet : [5,4,3]\\nCoins second person will choose are 8+6+4 = 18"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "1) In each step, you will choose any 3 piles of coins (not necessarily consecutive).\\n2) Of your choice, Alice will pick the pile with the maximum number of coins.\\n3) You will pick the next pile with maximum number of coins.\\n4) Your friend Bob will pick the last pile.\\n5)Repeat until there are no more piles of coins.\\n\\n4th point is misleading. \\nlast pile could also  mean last pile of  the original unsorted array itself!!!!!!!!!!!!!!\\n\\n\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "[@williamshark](/williamshark)  not when pile size>3  the last one can be anything. Last of sorted or unsorted  array .  thing is our sum will be maximum only when bob picks  the smallest pile."
                    },
                    {
                        "username": "williamshark",
                        "content": " But it\\'s kind of common sense to think that the last pile is just the one left over by the one you chose or it will be choose \"2 piles\""
                    },
                    {
                        "username": "z3eg",
                        "content": "ez problem"
                    },
                    {
                        "username": "sanskar2003",
                        "content": "This question is just a logic builder. If you are able to find the pattern, you will be able to solve it easily.\n\n class Solution {\n    public int maxCoins(int[] piles) {\n        Arrays.sort(piles);\n        int k = piles.length/3;\n        int result = 0;\n        for(int i=k; i<piles.length; i+=2){\n            result += piles[i];\n        }\n        return result;\n    }\n}"
                    },
                    {
                        "username": "Angad1418",
                        "content": "// catch is sequence does not matter like in last example 9,8,7,6....4\\n        // 1st > ours > last(now we can minimise to lowest) like\\n        // pairs { (9,8,1) (7,6,2) (5,4,3)} by this center is max\\nnow find out how you can reach to this type of sequence"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest medium level problem on this damn platform"
                    },
                    {
                        "username": "rizwan726",
                        "content": "I dont understand why the testcases are not passing?\\nclass Solution {\\n    public static int maxCoins(int x[]) {\\n        int n=x.length;int result=0;\\n        for(int i=n/3;i<n;i=i+2){\\n            result=result+x[i];\\n        }\\n        return result;\\n    }\\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        int T=sc.nextInt();\\n        while(T-->0){\\n            int piles[]=new int[sc.nextInt()];\\n            int temp=0;\\n            for(int i=0;i<piles.length;i++){\\n                piles[i]=sc.nextInt();\\n            }\\n            for(int i=0;i<piles.length;i++){\\n                for(int j=i;j<piles.length;j++){\\n                    if(piles[i]>piles[j]){\\n                        temp=piles[i];\\n                        piles[i]=piles[j];\\n                        piles[j]=temp;\\n                    }\\n                }\\n            }\\n            int x=maxCoins(piles);\\n            System.out.println(x);\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "I thought this is pile so one can\\'t change the order it screwed me\\n\\n``` csharp []\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        var ans=0;\\n        for(var i=piles.Length-1;i>=0;)\\n        {\\n            int a =piles[i--],b=piles[i--],c=piles[i--];\\n            var max = Math.Max(a,Math.Max(b,c));\\n            var min = Math.Min(a,Math.Min(b,c));\\n            if(a!=max && a!=min) ans+=a;\\n            if(b!=max && b!=min) ans+=b;\\n            if(c!=max && c!=min) ans+=c;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```csharp []\\n// correct\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        Array.Sort(piles);\\n        int ans=0,i=0,j=piles.Length;\\n        while(i++<--j) ans+=piles[--j];\\n        return ans;\\n    }\\n}\\n```\\n"
                    }
                ]
            },
            {
                "id": 1785729,
                "content": [
                    {
                        "username": "vivekjain202",
                        "content": "Since this question is straight forward sorting based question, i do feel tagging it as medium level problem isn\\'t justifiable.\\n\\nHope admin rethink and if he/she has a other reasoning i\\'ll be more than happy to know why it is considered as medium level problem.\\n\\nOpen to feedbacks. Thanks in advance :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Agreed, especially compared to some of the other game questions with game theory tag, a lot of those are tricky DP questions. The tag here makes you think that there is more going on, but there just isn\\'t. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "I believe it is tagged medium because the task of selecting three piles could somehow trick some people into thinking it is a dynamic programming problem, getting the pattern/intuition makes it very easy but to get that intuition you need some experience."
                    },
                    {
                        "username": "DCtheTall",
                        "content": "+1, this question is too straightforward to be medium level. It should be easy."
                    },
                    {
                        "username": "mmrubayet",
                        "content": "For chosing a pile of 3 coins:\n- 1st one have to be the biggest coin of all/remaining,\n- 2nd one have to be the 2nd biggest coin of all/remaining,\n- Last one have to be the smallest coin of all/remaining.\n- Remove/forget above 3.\n- Then, Repeat.\n\nApproach:\nFirst, reverse sort the array. Then, start loop from 2nd value which is my first coin. Bob's coins lies in the last side of the array, which is equal to total piles in array, i.e. len/3. End loop before Bob's value. Increment by two.\n\n[Don't see the solution here. Upvote if you understand.\n](https://leetcode.com/problems/maximum-number-of-coins-you-can-get/solutions/3205547/python-simple-easy-to-understand-beats-93-80/\n)"
                    },
                    {
                        "username": "ChloeWalt",
                        "content": "I don\\'t understand why for this test case: [9,8,7,6,5,1,2,3,4], the expected output is 18 and not 15?\\nWhen ordered:\\n[1,2,3,4,5,6,7,8,9]\\nThe coins the second person is choosing would be 2, 5 and 8 which = 15? "
                    },
                    {
                        "username": "dongdieuoke",
                        "content": "[1,8,9]   [2,6,7]   [3,4,5] => 8+6+4 = 18"
                    },
                    {
                        "username": "prachibhatia",
                        "content": "Coins can be chosen in the following ways :-\\nFirst triplet : [9,8,1]\\nSecond triplet : [7,6,2]\\nThirst triplet : [5,4,3]\\nCoins second person will choose are 8+6+4 = 18"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "1) In each step, you will choose any 3 piles of coins (not necessarily consecutive).\\n2) Of your choice, Alice will pick the pile with the maximum number of coins.\\n3) You will pick the next pile with maximum number of coins.\\n4) Your friend Bob will pick the last pile.\\n5)Repeat until there are no more piles of coins.\\n\\n4th point is misleading. \\nlast pile could also  mean last pile of  the original unsorted array itself!!!!!!!!!!!!!!\\n\\n\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "[@williamshark](/williamshark)  not when pile size>3  the last one can be anything. Last of sorted or unsorted  array .  thing is our sum will be maximum only when bob picks  the smallest pile."
                    },
                    {
                        "username": "williamshark",
                        "content": " But it\\'s kind of common sense to think that the last pile is just the one left over by the one you chose or it will be choose \"2 piles\""
                    },
                    {
                        "username": "z3eg",
                        "content": "ez problem"
                    },
                    {
                        "username": "sanskar2003",
                        "content": "This question is just a logic builder. If you are able to find the pattern, you will be able to solve it easily.\n\n class Solution {\n    public int maxCoins(int[] piles) {\n        Arrays.sort(piles);\n        int k = piles.length/3;\n        int result = 0;\n        for(int i=k; i<piles.length; i+=2){\n            result += piles[i];\n        }\n        return result;\n    }\n}"
                    },
                    {
                        "username": "Angad1418",
                        "content": "// catch is sequence does not matter like in last example 9,8,7,6....4\\n        // 1st > ours > last(now we can minimise to lowest) like\\n        // pairs { (9,8,1) (7,6,2) (5,4,3)} by this center is max\\nnow find out how you can reach to this type of sequence"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest medium level problem on this damn platform"
                    },
                    {
                        "username": "rizwan726",
                        "content": "I dont understand why the testcases are not passing?\\nclass Solution {\\n    public static int maxCoins(int x[]) {\\n        int n=x.length;int result=0;\\n        for(int i=n/3;i<n;i=i+2){\\n            result=result+x[i];\\n        }\\n        return result;\\n    }\\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        int T=sc.nextInt();\\n        while(T-->0){\\n            int piles[]=new int[sc.nextInt()];\\n            int temp=0;\\n            for(int i=0;i<piles.length;i++){\\n                piles[i]=sc.nextInt();\\n            }\\n            for(int i=0;i<piles.length;i++){\\n                for(int j=i;j<piles.length;j++){\\n                    if(piles[i]>piles[j]){\\n                        temp=piles[i];\\n                        piles[i]=piles[j];\\n                        piles[j]=temp;\\n                    }\\n                }\\n            }\\n            int x=maxCoins(piles);\\n            System.out.println(x);\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "I thought this is pile so one can\\'t change the order it screwed me\\n\\n``` csharp []\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        var ans=0;\\n        for(var i=piles.Length-1;i>=0;)\\n        {\\n            int a =piles[i--],b=piles[i--],c=piles[i--];\\n            var max = Math.Max(a,Math.Max(b,c));\\n            var min = Math.Min(a,Math.Min(b,c));\\n            if(a!=max && a!=min) ans+=a;\\n            if(b!=max && b!=min) ans+=b;\\n            if(c!=max && c!=min) ans+=c;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```csharp []\\n// correct\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        Array.Sort(piles);\\n        int ans=0,i=0,j=piles.Length;\\n        while(i++<--j) ans+=piles[--j];\\n        return ans;\\n    }\\n}\\n```\\n"
                    }
                ]
            },
            {
                "id": 1565786,
                "content": [
                    {
                        "username": "vivekjain202",
                        "content": "Since this question is straight forward sorting based question, i do feel tagging it as medium level problem isn\\'t justifiable.\\n\\nHope admin rethink and if he/she has a other reasoning i\\'ll be more than happy to know why it is considered as medium level problem.\\n\\nOpen to feedbacks. Thanks in advance :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Agreed, especially compared to some of the other game questions with game theory tag, a lot of those are tricky DP questions. The tag here makes you think that there is more going on, but there just isn\\'t. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "I believe it is tagged medium because the task of selecting three piles could somehow trick some people into thinking it is a dynamic programming problem, getting the pattern/intuition makes it very easy but to get that intuition you need some experience."
                    },
                    {
                        "username": "DCtheTall",
                        "content": "+1, this question is too straightforward to be medium level. It should be easy."
                    },
                    {
                        "username": "mmrubayet",
                        "content": "For chosing a pile of 3 coins:\n- 1st one have to be the biggest coin of all/remaining,\n- 2nd one have to be the 2nd biggest coin of all/remaining,\n- Last one have to be the smallest coin of all/remaining.\n- Remove/forget above 3.\n- Then, Repeat.\n\nApproach:\nFirst, reverse sort the array. Then, start loop from 2nd value which is my first coin. Bob's coins lies in the last side of the array, which is equal to total piles in array, i.e. len/3. End loop before Bob's value. Increment by two.\n\n[Don't see the solution here. Upvote if you understand.\n](https://leetcode.com/problems/maximum-number-of-coins-you-can-get/solutions/3205547/python-simple-easy-to-understand-beats-93-80/\n)"
                    },
                    {
                        "username": "ChloeWalt",
                        "content": "I don\\'t understand why for this test case: [9,8,7,6,5,1,2,3,4], the expected output is 18 and not 15?\\nWhen ordered:\\n[1,2,3,4,5,6,7,8,9]\\nThe coins the second person is choosing would be 2, 5 and 8 which = 15? "
                    },
                    {
                        "username": "dongdieuoke",
                        "content": "[1,8,9]   [2,6,7]   [3,4,5] => 8+6+4 = 18"
                    },
                    {
                        "username": "prachibhatia",
                        "content": "Coins can be chosen in the following ways :-\\nFirst triplet : [9,8,1]\\nSecond triplet : [7,6,2]\\nThirst triplet : [5,4,3]\\nCoins second person will choose are 8+6+4 = 18"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "1) In each step, you will choose any 3 piles of coins (not necessarily consecutive).\\n2) Of your choice, Alice will pick the pile with the maximum number of coins.\\n3) You will pick the next pile with maximum number of coins.\\n4) Your friend Bob will pick the last pile.\\n5)Repeat until there are no more piles of coins.\\n\\n4th point is misleading. \\nlast pile could also  mean last pile of  the original unsorted array itself!!!!!!!!!!!!!!\\n\\n\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "[@williamshark](/williamshark)  not when pile size>3  the last one can be anything. Last of sorted or unsorted  array .  thing is our sum will be maximum only when bob picks  the smallest pile."
                    },
                    {
                        "username": "williamshark",
                        "content": " But it\\'s kind of common sense to think that the last pile is just the one left over by the one you chose or it will be choose \"2 piles\""
                    },
                    {
                        "username": "z3eg",
                        "content": "ez problem"
                    },
                    {
                        "username": "sanskar2003",
                        "content": "This question is just a logic builder. If you are able to find the pattern, you will be able to solve it easily.\n\n class Solution {\n    public int maxCoins(int[] piles) {\n        Arrays.sort(piles);\n        int k = piles.length/3;\n        int result = 0;\n        for(int i=k; i<piles.length; i+=2){\n            result += piles[i];\n        }\n        return result;\n    }\n}"
                    },
                    {
                        "username": "Angad1418",
                        "content": "// catch is sequence does not matter like in last example 9,8,7,6....4\\n        // 1st > ours > last(now we can minimise to lowest) like\\n        // pairs { (9,8,1) (7,6,2) (5,4,3)} by this center is max\\nnow find out how you can reach to this type of sequence"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest medium level problem on this damn platform"
                    },
                    {
                        "username": "rizwan726",
                        "content": "I dont understand why the testcases are not passing?\\nclass Solution {\\n    public static int maxCoins(int x[]) {\\n        int n=x.length;int result=0;\\n        for(int i=n/3;i<n;i=i+2){\\n            result=result+x[i];\\n        }\\n        return result;\\n    }\\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        int T=sc.nextInt();\\n        while(T-->0){\\n            int piles[]=new int[sc.nextInt()];\\n            int temp=0;\\n            for(int i=0;i<piles.length;i++){\\n                piles[i]=sc.nextInt();\\n            }\\n            for(int i=0;i<piles.length;i++){\\n                for(int j=i;j<piles.length;j++){\\n                    if(piles[i]>piles[j]){\\n                        temp=piles[i];\\n                        piles[i]=piles[j];\\n                        piles[j]=temp;\\n                    }\\n                }\\n            }\\n            int x=maxCoins(piles);\\n            System.out.println(x);\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "I thought this is pile so one can\\'t change the order it screwed me\\n\\n``` csharp []\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        var ans=0;\\n        for(var i=piles.Length-1;i>=0;)\\n        {\\n            int a =piles[i--],b=piles[i--],c=piles[i--];\\n            var max = Math.Max(a,Math.Max(b,c));\\n            var min = Math.Min(a,Math.Min(b,c));\\n            if(a!=max && a!=min) ans+=a;\\n            if(b!=max && b!=min) ans+=b;\\n            if(c!=max && c!=min) ans+=c;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```csharp []\\n// correct\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        Array.Sort(piles);\\n        int ans=0,i=0,j=piles.Length;\\n        while(i++<--j) ans+=piles[--j];\\n        return ans;\\n    }\\n}\\n```\\n"
                    }
                ]
            },
            {
                "id": 1806996,
                "content": [
                    {
                        "username": "vivekjain202",
                        "content": "Since this question is straight forward sorting based question, i do feel tagging it as medium level problem isn\\'t justifiable.\\n\\nHope admin rethink and if he/she has a other reasoning i\\'ll be more than happy to know why it is considered as medium level problem.\\n\\nOpen to feedbacks. Thanks in advance :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Agreed, especially compared to some of the other game questions with game theory tag, a lot of those are tricky DP questions. The tag here makes you think that there is more going on, but there just isn\\'t. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "I believe it is tagged medium because the task of selecting three piles could somehow trick some people into thinking it is a dynamic programming problem, getting the pattern/intuition makes it very easy but to get that intuition you need some experience."
                    },
                    {
                        "username": "DCtheTall",
                        "content": "+1, this question is too straightforward to be medium level. It should be easy."
                    },
                    {
                        "username": "mmrubayet",
                        "content": "For chosing a pile of 3 coins:\n- 1st one have to be the biggest coin of all/remaining,\n- 2nd one have to be the 2nd biggest coin of all/remaining,\n- Last one have to be the smallest coin of all/remaining.\n- Remove/forget above 3.\n- Then, Repeat.\n\nApproach:\nFirst, reverse sort the array. Then, start loop from 2nd value which is my first coin. Bob's coins lies in the last side of the array, which is equal to total piles in array, i.e. len/3. End loop before Bob's value. Increment by two.\n\n[Don't see the solution here. Upvote if you understand.\n](https://leetcode.com/problems/maximum-number-of-coins-you-can-get/solutions/3205547/python-simple-easy-to-understand-beats-93-80/\n)"
                    },
                    {
                        "username": "ChloeWalt",
                        "content": "I don\\'t understand why for this test case: [9,8,7,6,5,1,2,3,4], the expected output is 18 and not 15?\\nWhen ordered:\\n[1,2,3,4,5,6,7,8,9]\\nThe coins the second person is choosing would be 2, 5 and 8 which = 15? "
                    },
                    {
                        "username": "dongdieuoke",
                        "content": "[1,8,9]   [2,6,7]   [3,4,5] => 8+6+4 = 18"
                    },
                    {
                        "username": "prachibhatia",
                        "content": "Coins can be chosen in the following ways :-\\nFirst triplet : [9,8,1]\\nSecond triplet : [7,6,2]\\nThirst triplet : [5,4,3]\\nCoins second person will choose are 8+6+4 = 18"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "1) In each step, you will choose any 3 piles of coins (not necessarily consecutive).\\n2) Of your choice, Alice will pick the pile with the maximum number of coins.\\n3) You will pick the next pile with maximum number of coins.\\n4) Your friend Bob will pick the last pile.\\n5)Repeat until there are no more piles of coins.\\n\\n4th point is misleading. \\nlast pile could also  mean last pile of  the original unsorted array itself!!!!!!!!!!!!!!\\n\\n\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "[@williamshark](/williamshark)  not when pile size>3  the last one can be anything. Last of sorted or unsorted  array .  thing is our sum will be maximum only when bob picks  the smallest pile."
                    },
                    {
                        "username": "williamshark",
                        "content": " But it\\'s kind of common sense to think that the last pile is just the one left over by the one you chose or it will be choose \"2 piles\""
                    },
                    {
                        "username": "z3eg",
                        "content": "ez problem"
                    },
                    {
                        "username": "sanskar2003",
                        "content": "This question is just a logic builder. If you are able to find the pattern, you will be able to solve it easily.\n\n class Solution {\n    public int maxCoins(int[] piles) {\n        Arrays.sort(piles);\n        int k = piles.length/3;\n        int result = 0;\n        for(int i=k; i<piles.length; i+=2){\n            result += piles[i];\n        }\n        return result;\n    }\n}"
                    },
                    {
                        "username": "Angad1418",
                        "content": "// catch is sequence does not matter like in last example 9,8,7,6....4\\n        // 1st > ours > last(now we can minimise to lowest) like\\n        // pairs { (9,8,1) (7,6,2) (5,4,3)} by this center is max\\nnow find out how you can reach to this type of sequence"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest medium level problem on this damn platform"
                    },
                    {
                        "username": "rizwan726",
                        "content": "I dont understand why the testcases are not passing?\\nclass Solution {\\n    public static int maxCoins(int x[]) {\\n        int n=x.length;int result=0;\\n        for(int i=n/3;i<n;i=i+2){\\n            result=result+x[i];\\n        }\\n        return result;\\n    }\\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        int T=sc.nextInt();\\n        while(T-->0){\\n            int piles[]=new int[sc.nextInt()];\\n            int temp=0;\\n            for(int i=0;i<piles.length;i++){\\n                piles[i]=sc.nextInt();\\n            }\\n            for(int i=0;i<piles.length;i++){\\n                for(int j=i;j<piles.length;j++){\\n                    if(piles[i]>piles[j]){\\n                        temp=piles[i];\\n                        piles[i]=piles[j];\\n                        piles[j]=temp;\\n                    }\\n                }\\n            }\\n            int x=maxCoins(piles);\\n            System.out.println(x);\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "I thought this is pile so one can\\'t change the order it screwed me\\n\\n``` csharp []\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        var ans=0;\\n        for(var i=piles.Length-1;i>=0;)\\n        {\\n            int a =piles[i--],b=piles[i--],c=piles[i--];\\n            var max = Math.Max(a,Math.Max(b,c));\\n            var min = Math.Min(a,Math.Min(b,c));\\n            if(a!=max && a!=min) ans+=a;\\n            if(b!=max && b!=min) ans+=b;\\n            if(c!=max && c!=min) ans+=c;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```csharp []\\n// correct\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        Array.Sort(piles);\\n        int ans=0,i=0,j=piles.Length;\\n        while(i++<--j) ans+=piles[--j];\\n        return ans;\\n    }\\n}\\n```\\n"
                    }
                ]
            },
            {
                "id": 1728868,
                "content": [
                    {
                        "username": "vivekjain202",
                        "content": "Since this question is straight forward sorting based question, i do feel tagging it as medium level problem isn\\'t justifiable.\\n\\nHope admin rethink and if he/she has a other reasoning i\\'ll be more than happy to know why it is considered as medium level problem.\\n\\nOpen to feedbacks. Thanks in advance :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Agreed, especially compared to some of the other game questions with game theory tag, a lot of those are tricky DP questions. The tag here makes you think that there is more going on, but there just isn\\'t. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "I believe it is tagged medium because the task of selecting three piles could somehow trick some people into thinking it is a dynamic programming problem, getting the pattern/intuition makes it very easy but to get that intuition you need some experience."
                    },
                    {
                        "username": "DCtheTall",
                        "content": "+1, this question is too straightforward to be medium level. It should be easy."
                    },
                    {
                        "username": "mmrubayet",
                        "content": "For chosing a pile of 3 coins:\n- 1st one have to be the biggest coin of all/remaining,\n- 2nd one have to be the 2nd biggest coin of all/remaining,\n- Last one have to be the smallest coin of all/remaining.\n- Remove/forget above 3.\n- Then, Repeat.\n\nApproach:\nFirst, reverse sort the array. Then, start loop from 2nd value which is my first coin. Bob's coins lies in the last side of the array, which is equal to total piles in array, i.e. len/3. End loop before Bob's value. Increment by two.\n\n[Don't see the solution here. Upvote if you understand.\n](https://leetcode.com/problems/maximum-number-of-coins-you-can-get/solutions/3205547/python-simple-easy-to-understand-beats-93-80/\n)"
                    },
                    {
                        "username": "ChloeWalt",
                        "content": "I don\\'t understand why for this test case: [9,8,7,6,5,1,2,3,4], the expected output is 18 and not 15?\\nWhen ordered:\\n[1,2,3,4,5,6,7,8,9]\\nThe coins the second person is choosing would be 2, 5 and 8 which = 15? "
                    },
                    {
                        "username": "dongdieuoke",
                        "content": "[1,8,9]   [2,6,7]   [3,4,5] => 8+6+4 = 18"
                    },
                    {
                        "username": "prachibhatia",
                        "content": "Coins can be chosen in the following ways :-\\nFirst triplet : [9,8,1]\\nSecond triplet : [7,6,2]\\nThirst triplet : [5,4,3]\\nCoins second person will choose are 8+6+4 = 18"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "1) In each step, you will choose any 3 piles of coins (not necessarily consecutive).\\n2) Of your choice, Alice will pick the pile with the maximum number of coins.\\n3) You will pick the next pile with maximum number of coins.\\n4) Your friend Bob will pick the last pile.\\n5)Repeat until there are no more piles of coins.\\n\\n4th point is misleading. \\nlast pile could also  mean last pile of  the original unsorted array itself!!!!!!!!!!!!!!\\n\\n\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "[@williamshark](/williamshark)  not when pile size>3  the last one can be anything. Last of sorted or unsorted  array .  thing is our sum will be maximum only when bob picks  the smallest pile."
                    },
                    {
                        "username": "williamshark",
                        "content": " But it\\'s kind of common sense to think that the last pile is just the one left over by the one you chose or it will be choose \"2 piles\""
                    },
                    {
                        "username": "z3eg",
                        "content": "ez problem"
                    },
                    {
                        "username": "sanskar2003",
                        "content": "This question is just a logic builder. If you are able to find the pattern, you will be able to solve it easily.\n\n class Solution {\n    public int maxCoins(int[] piles) {\n        Arrays.sort(piles);\n        int k = piles.length/3;\n        int result = 0;\n        for(int i=k; i<piles.length; i+=2){\n            result += piles[i];\n        }\n        return result;\n    }\n}"
                    },
                    {
                        "username": "Angad1418",
                        "content": "// catch is sequence does not matter like in last example 9,8,7,6....4\\n        // 1st > ours > last(now we can minimise to lowest) like\\n        // pairs { (9,8,1) (7,6,2) (5,4,3)} by this center is max\\nnow find out how you can reach to this type of sequence"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest medium level problem on this damn platform"
                    },
                    {
                        "username": "rizwan726",
                        "content": "I dont understand why the testcases are not passing?\\nclass Solution {\\n    public static int maxCoins(int x[]) {\\n        int n=x.length;int result=0;\\n        for(int i=n/3;i<n;i=i+2){\\n            result=result+x[i];\\n        }\\n        return result;\\n    }\\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        int T=sc.nextInt();\\n        while(T-->0){\\n            int piles[]=new int[sc.nextInt()];\\n            int temp=0;\\n            for(int i=0;i<piles.length;i++){\\n                piles[i]=sc.nextInt();\\n            }\\n            for(int i=0;i<piles.length;i++){\\n                for(int j=i;j<piles.length;j++){\\n                    if(piles[i]>piles[j]){\\n                        temp=piles[i];\\n                        piles[i]=piles[j];\\n                        piles[j]=temp;\\n                    }\\n                }\\n            }\\n            int x=maxCoins(piles);\\n            System.out.println(x);\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "I thought this is pile so one can\\'t change the order it screwed me\\n\\n``` csharp []\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        var ans=0;\\n        for(var i=piles.Length-1;i>=0;)\\n        {\\n            int a =piles[i--],b=piles[i--],c=piles[i--];\\n            var max = Math.Max(a,Math.Max(b,c));\\n            var min = Math.Min(a,Math.Min(b,c));\\n            if(a!=max && a!=min) ans+=a;\\n            if(b!=max && b!=min) ans+=b;\\n            if(c!=max && c!=min) ans+=c;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```csharp []\\n// correct\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        Array.Sort(piles);\\n        int ans=0,i=0,j=piles.Length;\\n        while(i++<--j) ans+=piles[--j];\\n        return ans;\\n    }\\n}\\n```\\n"
                    }
                ]
            },
            {
                "id": 1574264,
                "content": [
                    {
                        "username": "vivekjain202",
                        "content": "Since this question is straight forward sorting based question, i do feel tagging it as medium level problem isn\\'t justifiable.\\n\\nHope admin rethink and if he/she has a other reasoning i\\'ll be more than happy to know why it is considered as medium level problem.\\n\\nOpen to feedbacks. Thanks in advance :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Agreed, especially compared to some of the other game questions with game theory tag, a lot of those are tricky DP questions. The tag here makes you think that there is more going on, but there just isn\\'t. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "I believe it is tagged medium because the task of selecting three piles could somehow trick some people into thinking it is a dynamic programming problem, getting the pattern/intuition makes it very easy but to get that intuition you need some experience."
                    },
                    {
                        "username": "DCtheTall",
                        "content": "+1, this question is too straightforward to be medium level. It should be easy."
                    },
                    {
                        "username": "mmrubayet",
                        "content": "For chosing a pile of 3 coins:\n- 1st one have to be the biggest coin of all/remaining,\n- 2nd one have to be the 2nd biggest coin of all/remaining,\n- Last one have to be the smallest coin of all/remaining.\n- Remove/forget above 3.\n- Then, Repeat.\n\nApproach:\nFirst, reverse sort the array. Then, start loop from 2nd value which is my first coin. Bob's coins lies in the last side of the array, which is equal to total piles in array, i.e. len/3. End loop before Bob's value. Increment by two.\n\n[Don't see the solution here. Upvote if you understand.\n](https://leetcode.com/problems/maximum-number-of-coins-you-can-get/solutions/3205547/python-simple-easy-to-understand-beats-93-80/\n)"
                    },
                    {
                        "username": "ChloeWalt",
                        "content": "I don\\'t understand why for this test case: [9,8,7,6,5,1,2,3,4], the expected output is 18 and not 15?\\nWhen ordered:\\n[1,2,3,4,5,6,7,8,9]\\nThe coins the second person is choosing would be 2, 5 and 8 which = 15? "
                    },
                    {
                        "username": "dongdieuoke",
                        "content": "[1,8,9]   [2,6,7]   [3,4,5] => 8+6+4 = 18"
                    },
                    {
                        "username": "prachibhatia",
                        "content": "Coins can be chosen in the following ways :-\\nFirst triplet : [9,8,1]\\nSecond triplet : [7,6,2]\\nThirst triplet : [5,4,3]\\nCoins second person will choose are 8+6+4 = 18"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "1) In each step, you will choose any 3 piles of coins (not necessarily consecutive).\\n2) Of your choice, Alice will pick the pile with the maximum number of coins.\\n3) You will pick the next pile with maximum number of coins.\\n4) Your friend Bob will pick the last pile.\\n5)Repeat until there are no more piles of coins.\\n\\n4th point is misleading. \\nlast pile could also  mean last pile of  the original unsorted array itself!!!!!!!!!!!!!!\\n\\n\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "[@williamshark](/williamshark)  not when pile size>3  the last one can be anything. Last of sorted or unsorted  array .  thing is our sum will be maximum only when bob picks  the smallest pile."
                    },
                    {
                        "username": "williamshark",
                        "content": " But it\\'s kind of common sense to think that the last pile is just the one left over by the one you chose or it will be choose \"2 piles\""
                    },
                    {
                        "username": "z3eg",
                        "content": "ez problem"
                    },
                    {
                        "username": "sanskar2003",
                        "content": "This question is just a logic builder. If you are able to find the pattern, you will be able to solve it easily.\n\n class Solution {\n    public int maxCoins(int[] piles) {\n        Arrays.sort(piles);\n        int k = piles.length/3;\n        int result = 0;\n        for(int i=k; i<piles.length; i+=2){\n            result += piles[i];\n        }\n        return result;\n    }\n}"
                    },
                    {
                        "username": "Angad1418",
                        "content": "// catch is sequence does not matter like in last example 9,8,7,6....4\\n        // 1st > ours > last(now we can minimise to lowest) like\\n        // pairs { (9,8,1) (7,6,2) (5,4,3)} by this center is max\\nnow find out how you can reach to this type of sequence"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest medium level problem on this damn platform"
                    },
                    {
                        "username": "rizwan726",
                        "content": "I dont understand why the testcases are not passing?\\nclass Solution {\\n    public static int maxCoins(int x[]) {\\n        int n=x.length;int result=0;\\n        for(int i=n/3;i<n;i=i+2){\\n            result=result+x[i];\\n        }\\n        return result;\\n    }\\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        int T=sc.nextInt();\\n        while(T-->0){\\n            int piles[]=new int[sc.nextInt()];\\n            int temp=0;\\n            for(int i=0;i<piles.length;i++){\\n                piles[i]=sc.nextInt();\\n            }\\n            for(int i=0;i<piles.length;i++){\\n                for(int j=i;j<piles.length;j++){\\n                    if(piles[i]>piles[j]){\\n                        temp=piles[i];\\n                        piles[i]=piles[j];\\n                        piles[j]=temp;\\n                    }\\n                }\\n            }\\n            int x=maxCoins(piles);\\n            System.out.println(x);\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "I thought this is pile so one can\\'t change the order it screwed me\\n\\n``` csharp []\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        var ans=0;\\n        for(var i=piles.Length-1;i>=0;)\\n        {\\n            int a =piles[i--],b=piles[i--],c=piles[i--];\\n            var max = Math.Max(a,Math.Max(b,c));\\n            var min = Math.Min(a,Math.Min(b,c));\\n            if(a!=max && a!=min) ans+=a;\\n            if(b!=max && b!=min) ans+=b;\\n            if(c!=max && c!=min) ans+=c;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```csharp []\\n// correct\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        Array.Sort(piles);\\n        int ans=0,i=0,j=piles.Length;\\n        while(i++<--j) ans+=piles[--j];\\n        return ans;\\n    }\\n}\\n```\\n"
                    }
                ]
            },
            {
                "id": 1936076,
                "content": [
                    {
                        "username": "vivekjain202",
                        "content": "Since this question is straight forward sorting based question, i do feel tagging it as medium level problem isn\\'t justifiable.\\n\\nHope admin rethink and if he/she has a other reasoning i\\'ll be more than happy to know why it is considered as medium level problem.\\n\\nOpen to feedbacks. Thanks in advance :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Agreed, especially compared to some of the other game questions with game theory tag, a lot of those are tricky DP questions. The tag here makes you think that there is more going on, but there just isn\\'t. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "I believe it is tagged medium because the task of selecting three piles could somehow trick some people into thinking it is a dynamic programming problem, getting the pattern/intuition makes it very easy but to get that intuition you need some experience."
                    },
                    {
                        "username": "DCtheTall",
                        "content": "+1, this question is too straightforward to be medium level. It should be easy."
                    },
                    {
                        "username": "mmrubayet",
                        "content": "For chosing a pile of 3 coins:\n- 1st one have to be the biggest coin of all/remaining,\n- 2nd one have to be the 2nd biggest coin of all/remaining,\n- Last one have to be the smallest coin of all/remaining.\n- Remove/forget above 3.\n- Then, Repeat.\n\nApproach:\nFirst, reverse sort the array. Then, start loop from 2nd value which is my first coin. Bob's coins lies in the last side of the array, which is equal to total piles in array, i.e. len/3. End loop before Bob's value. Increment by two.\n\n[Don't see the solution here. Upvote if you understand.\n](https://leetcode.com/problems/maximum-number-of-coins-you-can-get/solutions/3205547/python-simple-easy-to-understand-beats-93-80/\n)"
                    },
                    {
                        "username": "ChloeWalt",
                        "content": "I don\\'t understand why for this test case: [9,8,7,6,5,1,2,3,4], the expected output is 18 and not 15?\\nWhen ordered:\\n[1,2,3,4,5,6,7,8,9]\\nThe coins the second person is choosing would be 2, 5 and 8 which = 15? "
                    },
                    {
                        "username": "dongdieuoke",
                        "content": "[1,8,9]   [2,6,7]   [3,4,5] => 8+6+4 = 18"
                    },
                    {
                        "username": "prachibhatia",
                        "content": "Coins can be chosen in the following ways :-\\nFirst triplet : [9,8,1]\\nSecond triplet : [7,6,2]\\nThirst triplet : [5,4,3]\\nCoins second person will choose are 8+6+4 = 18"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "1) In each step, you will choose any 3 piles of coins (not necessarily consecutive).\\n2) Of your choice, Alice will pick the pile with the maximum number of coins.\\n3) You will pick the next pile with maximum number of coins.\\n4) Your friend Bob will pick the last pile.\\n5)Repeat until there are no more piles of coins.\\n\\n4th point is misleading. \\nlast pile could also  mean last pile of  the original unsorted array itself!!!!!!!!!!!!!!\\n\\n\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "[@williamshark](/williamshark)  not when pile size>3  the last one can be anything. Last of sorted or unsorted  array .  thing is our sum will be maximum only when bob picks  the smallest pile."
                    },
                    {
                        "username": "williamshark",
                        "content": " But it\\'s kind of common sense to think that the last pile is just the one left over by the one you chose or it will be choose \"2 piles\""
                    },
                    {
                        "username": "z3eg",
                        "content": "ez problem"
                    },
                    {
                        "username": "sanskar2003",
                        "content": "This question is just a logic builder. If you are able to find the pattern, you will be able to solve it easily.\n\n class Solution {\n    public int maxCoins(int[] piles) {\n        Arrays.sort(piles);\n        int k = piles.length/3;\n        int result = 0;\n        for(int i=k; i<piles.length; i+=2){\n            result += piles[i];\n        }\n        return result;\n    }\n}"
                    },
                    {
                        "username": "Angad1418",
                        "content": "// catch is sequence does not matter like in last example 9,8,7,6....4\\n        // 1st > ours > last(now we can minimise to lowest) like\\n        // pairs { (9,8,1) (7,6,2) (5,4,3)} by this center is max\\nnow find out how you can reach to this type of sequence"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest medium level problem on this damn platform"
                    },
                    {
                        "username": "rizwan726",
                        "content": "I dont understand why the testcases are not passing?\\nclass Solution {\\n    public static int maxCoins(int x[]) {\\n        int n=x.length;int result=0;\\n        for(int i=n/3;i<n;i=i+2){\\n            result=result+x[i];\\n        }\\n        return result;\\n    }\\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        int T=sc.nextInt();\\n        while(T-->0){\\n            int piles[]=new int[sc.nextInt()];\\n            int temp=0;\\n            for(int i=0;i<piles.length;i++){\\n                piles[i]=sc.nextInt();\\n            }\\n            for(int i=0;i<piles.length;i++){\\n                for(int j=i;j<piles.length;j++){\\n                    if(piles[i]>piles[j]){\\n                        temp=piles[i];\\n                        piles[i]=piles[j];\\n                        piles[j]=temp;\\n                    }\\n                }\\n            }\\n            int x=maxCoins(piles);\\n            System.out.println(x);\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "I thought this is pile so one can\\'t change the order it screwed me\\n\\n``` csharp []\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        var ans=0;\\n        for(var i=piles.Length-1;i>=0;)\\n        {\\n            int a =piles[i--],b=piles[i--],c=piles[i--];\\n            var max = Math.Max(a,Math.Max(b,c));\\n            var min = Math.Min(a,Math.Min(b,c));\\n            if(a!=max && a!=min) ans+=a;\\n            if(b!=max && b!=min) ans+=b;\\n            if(c!=max && c!=min) ans+=c;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```csharp []\\n// correct\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        Array.Sort(piles);\\n        int ans=0,i=0,j=piles.Length;\\n        while(i++<--j) ans+=piles[--j];\\n        return ans;\\n    }\\n}\\n```\\n"
                    }
                ]
            },
            {
                "id": 1782043,
                "content": [
                    {
                        "username": "vivekjain202",
                        "content": "Since this question is straight forward sorting based question, i do feel tagging it as medium level problem isn\\'t justifiable.\\n\\nHope admin rethink and if he/she has a other reasoning i\\'ll be more than happy to know why it is considered as medium level problem.\\n\\nOpen to feedbacks. Thanks in advance :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Agreed, especially compared to some of the other game questions with game theory tag, a lot of those are tricky DP questions. The tag here makes you think that there is more going on, but there just isn\\'t. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "I believe it is tagged medium because the task of selecting three piles could somehow trick some people into thinking it is a dynamic programming problem, getting the pattern/intuition makes it very easy but to get that intuition you need some experience."
                    },
                    {
                        "username": "DCtheTall",
                        "content": "+1, this question is too straightforward to be medium level. It should be easy."
                    },
                    {
                        "username": "mmrubayet",
                        "content": "For chosing a pile of 3 coins:\n- 1st one have to be the biggest coin of all/remaining,\n- 2nd one have to be the 2nd biggest coin of all/remaining,\n- Last one have to be the smallest coin of all/remaining.\n- Remove/forget above 3.\n- Then, Repeat.\n\nApproach:\nFirst, reverse sort the array. Then, start loop from 2nd value which is my first coin. Bob's coins lies in the last side of the array, which is equal to total piles in array, i.e. len/3. End loop before Bob's value. Increment by two.\n\n[Don't see the solution here. Upvote if you understand.\n](https://leetcode.com/problems/maximum-number-of-coins-you-can-get/solutions/3205547/python-simple-easy-to-understand-beats-93-80/\n)"
                    },
                    {
                        "username": "ChloeWalt",
                        "content": "I don\\'t understand why for this test case: [9,8,7,6,5,1,2,3,4], the expected output is 18 and not 15?\\nWhen ordered:\\n[1,2,3,4,5,6,7,8,9]\\nThe coins the second person is choosing would be 2, 5 and 8 which = 15? "
                    },
                    {
                        "username": "dongdieuoke",
                        "content": "[1,8,9]   [2,6,7]   [3,4,5] => 8+6+4 = 18"
                    },
                    {
                        "username": "prachibhatia",
                        "content": "Coins can be chosen in the following ways :-\\nFirst triplet : [9,8,1]\\nSecond triplet : [7,6,2]\\nThirst triplet : [5,4,3]\\nCoins second person will choose are 8+6+4 = 18"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "1) In each step, you will choose any 3 piles of coins (not necessarily consecutive).\\n2) Of your choice, Alice will pick the pile with the maximum number of coins.\\n3) You will pick the next pile with maximum number of coins.\\n4) Your friend Bob will pick the last pile.\\n5)Repeat until there are no more piles of coins.\\n\\n4th point is misleading. \\nlast pile could also  mean last pile of  the original unsorted array itself!!!!!!!!!!!!!!\\n\\n\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "[@williamshark](/williamshark)  not when pile size>3  the last one can be anything. Last of sorted or unsorted  array .  thing is our sum will be maximum only when bob picks  the smallest pile."
                    },
                    {
                        "username": "williamshark",
                        "content": " But it\\'s kind of common sense to think that the last pile is just the one left over by the one you chose or it will be choose \"2 piles\""
                    },
                    {
                        "username": "z3eg",
                        "content": "ez problem"
                    },
                    {
                        "username": "sanskar2003",
                        "content": "This question is just a logic builder. If you are able to find the pattern, you will be able to solve it easily.\n\n class Solution {\n    public int maxCoins(int[] piles) {\n        Arrays.sort(piles);\n        int k = piles.length/3;\n        int result = 0;\n        for(int i=k; i<piles.length; i+=2){\n            result += piles[i];\n        }\n        return result;\n    }\n}"
                    },
                    {
                        "username": "Angad1418",
                        "content": "// catch is sequence does not matter like in last example 9,8,7,6....4\\n        // 1st > ours > last(now we can minimise to lowest) like\\n        // pairs { (9,8,1) (7,6,2) (5,4,3)} by this center is max\\nnow find out how you can reach to this type of sequence"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest medium level problem on this damn platform"
                    },
                    {
                        "username": "rizwan726",
                        "content": "I dont understand why the testcases are not passing?\\nclass Solution {\\n    public static int maxCoins(int x[]) {\\n        int n=x.length;int result=0;\\n        for(int i=n/3;i<n;i=i+2){\\n            result=result+x[i];\\n        }\\n        return result;\\n    }\\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        int T=sc.nextInt();\\n        while(T-->0){\\n            int piles[]=new int[sc.nextInt()];\\n            int temp=0;\\n            for(int i=0;i<piles.length;i++){\\n                piles[i]=sc.nextInt();\\n            }\\n            for(int i=0;i<piles.length;i++){\\n                for(int j=i;j<piles.length;j++){\\n                    if(piles[i]>piles[j]){\\n                        temp=piles[i];\\n                        piles[i]=piles[j];\\n                        piles[j]=temp;\\n                    }\\n                }\\n            }\\n            int x=maxCoins(piles);\\n            System.out.println(x);\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "I thought this is pile so one can\\'t change the order it screwed me\\n\\n``` csharp []\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        var ans=0;\\n        for(var i=piles.Length-1;i>=0;)\\n        {\\n            int a =piles[i--],b=piles[i--],c=piles[i--];\\n            var max = Math.Max(a,Math.Max(b,c));\\n            var min = Math.Min(a,Math.Min(b,c));\\n            if(a!=max && a!=min) ans+=a;\\n            if(b!=max && b!=min) ans+=b;\\n            if(c!=max && c!=min) ans+=c;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```csharp []\\n// correct\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        Array.Sort(piles);\\n        int ans=0,i=0,j=piles.Length;\\n        while(i++<--j) ans+=piles[--j];\\n        return ans;\\n    }\\n}\\n```\\n"
                    }
                ]
            },
            {
                "id": 2025862,
                "content": [
                    {
                        "username": "vivekjain202",
                        "content": "Since this question is straight forward sorting based question, i do feel tagging it as medium level problem isn\\'t justifiable.\\n\\nHope admin rethink and if he/she has a other reasoning i\\'ll be more than happy to know why it is considered as medium level problem.\\n\\nOpen to feedbacks. Thanks in advance :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Agreed, especially compared to some of the other game questions with game theory tag, a lot of those are tricky DP questions. The tag here makes you think that there is more going on, but there just isn\\'t. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "I believe it is tagged medium because the task of selecting three piles could somehow trick some people into thinking it is a dynamic programming problem, getting the pattern/intuition makes it very easy but to get that intuition you need some experience."
                    },
                    {
                        "username": "DCtheTall",
                        "content": "+1, this question is too straightforward to be medium level. It should be easy."
                    },
                    {
                        "username": "mmrubayet",
                        "content": "For chosing a pile of 3 coins:\n- 1st one have to be the biggest coin of all/remaining,\n- 2nd one have to be the 2nd biggest coin of all/remaining,\n- Last one have to be the smallest coin of all/remaining.\n- Remove/forget above 3.\n- Then, Repeat.\n\nApproach:\nFirst, reverse sort the array. Then, start loop from 2nd value which is my first coin. Bob's coins lies in the last side of the array, which is equal to total piles in array, i.e. len/3. End loop before Bob's value. Increment by two.\n\n[Don't see the solution here. Upvote if you understand.\n](https://leetcode.com/problems/maximum-number-of-coins-you-can-get/solutions/3205547/python-simple-easy-to-understand-beats-93-80/\n)"
                    },
                    {
                        "username": "ChloeWalt",
                        "content": "I don\\'t understand why for this test case: [9,8,7,6,5,1,2,3,4], the expected output is 18 and not 15?\\nWhen ordered:\\n[1,2,3,4,5,6,7,8,9]\\nThe coins the second person is choosing would be 2, 5 and 8 which = 15? "
                    },
                    {
                        "username": "dongdieuoke",
                        "content": "[1,8,9]   [2,6,7]   [3,4,5] => 8+6+4 = 18"
                    },
                    {
                        "username": "prachibhatia",
                        "content": "Coins can be chosen in the following ways :-\\nFirst triplet : [9,8,1]\\nSecond triplet : [7,6,2]\\nThirst triplet : [5,4,3]\\nCoins second person will choose are 8+6+4 = 18"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "1) In each step, you will choose any 3 piles of coins (not necessarily consecutive).\\n2) Of your choice, Alice will pick the pile with the maximum number of coins.\\n3) You will pick the next pile with maximum number of coins.\\n4) Your friend Bob will pick the last pile.\\n5)Repeat until there are no more piles of coins.\\n\\n4th point is misleading. \\nlast pile could also  mean last pile of  the original unsorted array itself!!!!!!!!!!!!!!\\n\\n\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "[@williamshark](/williamshark)  not when pile size>3  the last one can be anything. Last of sorted or unsorted  array .  thing is our sum will be maximum only when bob picks  the smallest pile."
                    },
                    {
                        "username": "williamshark",
                        "content": " But it\\'s kind of common sense to think that the last pile is just the one left over by the one you chose or it will be choose \"2 piles\""
                    },
                    {
                        "username": "z3eg",
                        "content": "ez problem"
                    },
                    {
                        "username": "sanskar2003",
                        "content": "This question is just a logic builder. If you are able to find the pattern, you will be able to solve it easily.\n\n class Solution {\n    public int maxCoins(int[] piles) {\n        Arrays.sort(piles);\n        int k = piles.length/3;\n        int result = 0;\n        for(int i=k; i<piles.length; i+=2){\n            result += piles[i];\n        }\n        return result;\n    }\n}"
                    },
                    {
                        "username": "Angad1418",
                        "content": "// catch is sequence does not matter like in last example 9,8,7,6....4\\n        // 1st > ours > last(now we can minimise to lowest) like\\n        // pairs { (9,8,1) (7,6,2) (5,4,3)} by this center is max\\nnow find out how you can reach to this type of sequence"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest medium level problem on this damn platform"
                    },
                    {
                        "username": "rizwan726",
                        "content": "I dont understand why the testcases are not passing?\\nclass Solution {\\n    public static int maxCoins(int x[]) {\\n        int n=x.length;int result=0;\\n        for(int i=n/3;i<n;i=i+2){\\n            result=result+x[i];\\n        }\\n        return result;\\n    }\\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        int T=sc.nextInt();\\n        while(T-->0){\\n            int piles[]=new int[sc.nextInt()];\\n            int temp=0;\\n            for(int i=0;i<piles.length;i++){\\n                piles[i]=sc.nextInt();\\n            }\\n            for(int i=0;i<piles.length;i++){\\n                for(int j=i;j<piles.length;j++){\\n                    if(piles[i]>piles[j]){\\n                        temp=piles[i];\\n                        piles[i]=piles[j];\\n                        piles[j]=temp;\\n                    }\\n                }\\n            }\\n            int x=maxCoins(piles);\\n            System.out.println(x);\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "I thought this is pile so one can\\'t change the order it screwed me\\n\\n``` csharp []\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        var ans=0;\\n        for(var i=piles.Length-1;i>=0;)\\n        {\\n            int a =piles[i--],b=piles[i--],c=piles[i--];\\n            var max = Math.Max(a,Math.Max(b,c));\\n            var min = Math.Min(a,Math.Min(b,c));\\n            if(a!=max && a!=min) ans+=a;\\n            if(b!=max && b!=min) ans+=b;\\n            if(c!=max && c!=min) ans+=c;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```csharp []\\n// correct\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        Array.Sort(piles);\\n        int ans=0,i=0,j=piles.Length;\\n        while(i++<--j) ans+=piles[--j];\\n        return ans;\\n    }\\n}\\n```\\n"
                    }
                ]
            },
            {
                "id": 1965577,
                "content": [
                    {
                        "username": "vivekjain202",
                        "content": "Since this question is straight forward sorting based question, i do feel tagging it as medium level problem isn\\'t justifiable.\\n\\nHope admin rethink and if he/she has a other reasoning i\\'ll be more than happy to know why it is considered as medium level problem.\\n\\nOpen to feedbacks. Thanks in advance :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Agreed, especially compared to some of the other game questions with game theory tag, a lot of those are tricky DP questions. The tag here makes you think that there is more going on, but there just isn\\'t. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "I believe it is tagged medium because the task of selecting three piles could somehow trick some people into thinking it is a dynamic programming problem, getting the pattern/intuition makes it very easy but to get that intuition you need some experience."
                    },
                    {
                        "username": "DCtheTall",
                        "content": "+1, this question is too straightforward to be medium level. It should be easy."
                    },
                    {
                        "username": "mmrubayet",
                        "content": "For chosing a pile of 3 coins:\n- 1st one have to be the biggest coin of all/remaining,\n- 2nd one have to be the 2nd biggest coin of all/remaining,\n- Last one have to be the smallest coin of all/remaining.\n- Remove/forget above 3.\n- Then, Repeat.\n\nApproach:\nFirst, reverse sort the array. Then, start loop from 2nd value which is my first coin. Bob's coins lies in the last side of the array, which is equal to total piles in array, i.e. len/3. End loop before Bob's value. Increment by two.\n\n[Don't see the solution here. Upvote if you understand.\n](https://leetcode.com/problems/maximum-number-of-coins-you-can-get/solutions/3205547/python-simple-easy-to-understand-beats-93-80/\n)"
                    },
                    {
                        "username": "ChloeWalt",
                        "content": "I don\\'t understand why for this test case: [9,8,7,6,5,1,2,3,4], the expected output is 18 and not 15?\\nWhen ordered:\\n[1,2,3,4,5,6,7,8,9]\\nThe coins the second person is choosing would be 2, 5 and 8 which = 15? "
                    },
                    {
                        "username": "dongdieuoke",
                        "content": "[1,8,9]   [2,6,7]   [3,4,5] => 8+6+4 = 18"
                    },
                    {
                        "username": "prachibhatia",
                        "content": "Coins can be chosen in the following ways :-\\nFirst triplet : [9,8,1]\\nSecond triplet : [7,6,2]\\nThirst triplet : [5,4,3]\\nCoins second person will choose are 8+6+4 = 18"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "1) In each step, you will choose any 3 piles of coins (not necessarily consecutive).\\n2) Of your choice, Alice will pick the pile with the maximum number of coins.\\n3) You will pick the next pile with maximum number of coins.\\n4) Your friend Bob will pick the last pile.\\n5)Repeat until there are no more piles of coins.\\n\\n4th point is misleading. \\nlast pile could also  mean last pile of  the original unsorted array itself!!!!!!!!!!!!!!\\n\\n\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "[@williamshark](/williamshark)  not when pile size>3  the last one can be anything. Last of sorted or unsorted  array .  thing is our sum will be maximum only when bob picks  the smallest pile."
                    },
                    {
                        "username": "williamshark",
                        "content": " But it\\'s kind of common sense to think that the last pile is just the one left over by the one you chose or it will be choose \"2 piles\""
                    },
                    {
                        "username": "z3eg",
                        "content": "ez problem"
                    },
                    {
                        "username": "sanskar2003",
                        "content": "This question is just a logic builder. If you are able to find the pattern, you will be able to solve it easily.\n\n class Solution {\n    public int maxCoins(int[] piles) {\n        Arrays.sort(piles);\n        int k = piles.length/3;\n        int result = 0;\n        for(int i=k; i<piles.length; i+=2){\n            result += piles[i];\n        }\n        return result;\n    }\n}"
                    },
                    {
                        "username": "Angad1418",
                        "content": "// catch is sequence does not matter like in last example 9,8,7,6....4\\n        // 1st > ours > last(now we can minimise to lowest) like\\n        // pairs { (9,8,1) (7,6,2) (5,4,3)} by this center is max\\nnow find out how you can reach to this type of sequence"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest medium level problem on this damn platform"
                    },
                    {
                        "username": "rizwan726",
                        "content": "I dont understand why the testcases are not passing?\\nclass Solution {\\n    public static int maxCoins(int x[]) {\\n        int n=x.length;int result=0;\\n        for(int i=n/3;i<n;i=i+2){\\n            result=result+x[i];\\n        }\\n        return result;\\n    }\\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        int T=sc.nextInt();\\n        while(T-->0){\\n            int piles[]=new int[sc.nextInt()];\\n            int temp=0;\\n            for(int i=0;i<piles.length;i++){\\n                piles[i]=sc.nextInt();\\n            }\\n            for(int i=0;i<piles.length;i++){\\n                for(int j=i;j<piles.length;j++){\\n                    if(piles[i]>piles[j]){\\n                        temp=piles[i];\\n                        piles[i]=piles[j];\\n                        piles[j]=temp;\\n                    }\\n                }\\n            }\\n            int x=maxCoins(piles);\\n            System.out.println(x);\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "I thought this is pile so one can\\'t change the order it screwed me\\n\\n``` csharp []\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        var ans=0;\\n        for(var i=piles.Length-1;i>=0;)\\n        {\\n            int a =piles[i--],b=piles[i--],c=piles[i--];\\n            var max = Math.Max(a,Math.Max(b,c));\\n            var min = Math.Min(a,Math.Min(b,c));\\n            if(a!=max && a!=min) ans+=a;\\n            if(b!=max && b!=min) ans+=b;\\n            if(c!=max && c!=min) ans+=c;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```csharp []\\n// correct\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        Array.Sort(piles);\\n        int ans=0,i=0,j=piles.Length;\\n        while(i++<--j) ans+=piles[--j];\\n        return ans;\\n    }\\n}\\n```\\n"
                    }
                ]
            },
            {
                "id": 1860360,
                "content": [
                    {
                        "username": "vivekjain202",
                        "content": "Since this question is straight forward sorting based question, i do feel tagging it as medium level problem isn\\'t justifiable.\\n\\nHope admin rethink and if he/she has a other reasoning i\\'ll be more than happy to know why it is considered as medium level problem.\\n\\nOpen to feedbacks. Thanks in advance :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Agreed, especially compared to some of the other game questions with game theory tag, a lot of those are tricky DP questions. The tag here makes you think that there is more going on, but there just isn\\'t. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "I believe it is tagged medium because the task of selecting three piles could somehow trick some people into thinking it is a dynamic programming problem, getting the pattern/intuition makes it very easy but to get that intuition you need some experience."
                    },
                    {
                        "username": "DCtheTall",
                        "content": "+1, this question is too straightforward to be medium level. It should be easy."
                    },
                    {
                        "username": "mmrubayet",
                        "content": "For chosing a pile of 3 coins:\n- 1st one have to be the biggest coin of all/remaining,\n- 2nd one have to be the 2nd biggest coin of all/remaining,\n- Last one have to be the smallest coin of all/remaining.\n- Remove/forget above 3.\n- Then, Repeat.\n\nApproach:\nFirst, reverse sort the array. Then, start loop from 2nd value which is my first coin. Bob's coins lies in the last side of the array, which is equal to total piles in array, i.e. len/3. End loop before Bob's value. Increment by two.\n\n[Don't see the solution here. Upvote if you understand.\n](https://leetcode.com/problems/maximum-number-of-coins-you-can-get/solutions/3205547/python-simple-easy-to-understand-beats-93-80/\n)"
                    },
                    {
                        "username": "ChloeWalt",
                        "content": "I don\\'t understand why for this test case: [9,8,7,6,5,1,2,3,4], the expected output is 18 and not 15?\\nWhen ordered:\\n[1,2,3,4,5,6,7,8,9]\\nThe coins the second person is choosing would be 2, 5 and 8 which = 15? "
                    },
                    {
                        "username": "dongdieuoke",
                        "content": "[1,8,9]   [2,6,7]   [3,4,5] => 8+6+4 = 18"
                    },
                    {
                        "username": "prachibhatia",
                        "content": "Coins can be chosen in the following ways :-\\nFirst triplet : [9,8,1]\\nSecond triplet : [7,6,2]\\nThirst triplet : [5,4,3]\\nCoins second person will choose are 8+6+4 = 18"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "1) In each step, you will choose any 3 piles of coins (not necessarily consecutive).\\n2) Of your choice, Alice will pick the pile with the maximum number of coins.\\n3) You will pick the next pile with maximum number of coins.\\n4) Your friend Bob will pick the last pile.\\n5)Repeat until there are no more piles of coins.\\n\\n4th point is misleading. \\nlast pile could also  mean last pile of  the original unsorted array itself!!!!!!!!!!!!!!\\n\\n\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "[@williamshark](/williamshark)  not when pile size>3  the last one can be anything. Last of sorted or unsorted  array .  thing is our sum will be maximum only when bob picks  the smallest pile."
                    },
                    {
                        "username": "williamshark",
                        "content": " But it\\'s kind of common sense to think that the last pile is just the one left over by the one you chose or it will be choose \"2 piles\""
                    },
                    {
                        "username": "z3eg",
                        "content": "ez problem"
                    },
                    {
                        "username": "sanskar2003",
                        "content": "This question is just a logic builder. If you are able to find the pattern, you will be able to solve it easily.\n\n class Solution {\n    public int maxCoins(int[] piles) {\n        Arrays.sort(piles);\n        int k = piles.length/3;\n        int result = 0;\n        for(int i=k; i<piles.length; i+=2){\n            result += piles[i];\n        }\n        return result;\n    }\n}"
                    },
                    {
                        "username": "Angad1418",
                        "content": "// catch is sequence does not matter like in last example 9,8,7,6....4\\n        // 1st > ours > last(now we can minimise to lowest) like\\n        // pairs { (9,8,1) (7,6,2) (5,4,3)} by this center is max\\nnow find out how you can reach to this type of sequence"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest medium level problem on this damn platform"
                    },
                    {
                        "username": "rizwan726",
                        "content": "I dont understand why the testcases are not passing?\\nclass Solution {\\n    public static int maxCoins(int x[]) {\\n        int n=x.length;int result=0;\\n        for(int i=n/3;i<n;i=i+2){\\n            result=result+x[i];\\n        }\\n        return result;\\n    }\\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        int T=sc.nextInt();\\n        while(T-->0){\\n            int piles[]=new int[sc.nextInt()];\\n            int temp=0;\\n            for(int i=0;i<piles.length;i++){\\n                piles[i]=sc.nextInt();\\n            }\\n            for(int i=0;i<piles.length;i++){\\n                for(int j=i;j<piles.length;j++){\\n                    if(piles[i]>piles[j]){\\n                        temp=piles[i];\\n                        piles[i]=piles[j];\\n                        piles[j]=temp;\\n                    }\\n                }\\n            }\\n            int x=maxCoins(piles);\\n            System.out.println(x);\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "I thought this is pile so one can\\'t change the order it screwed me\\n\\n``` csharp []\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        var ans=0;\\n        for(var i=piles.Length-1;i>=0;)\\n        {\\n            int a =piles[i--],b=piles[i--],c=piles[i--];\\n            var max = Math.Max(a,Math.Max(b,c));\\n            var min = Math.Min(a,Math.Min(b,c));\\n            if(a!=max && a!=min) ans+=a;\\n            if(b!=max && b!=min) ans+=b;\\n            if(c!=max && c!=min) ans+=c;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```csharp []\\n// correct\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        Array.Sort(piles);\\n        int ans=0,i=0,j=piles.Length;\\n        while(i++<--j) ans+=piles[--j];\\n        return ans;\\n    }\\n}\\n```\\n"
                    }
                ]
            },
            {
                "id": 1785729,
                "content": [
                    {
                        "username": "vivekjain202",
                        "content": "Since this question is straight forward sorting based question, i do feel tagging it as medium level problem isn\\'t justifiable.\\n\\nHope admin rethink and if he/she has a other reasoning i\\'ll be more than happy to know why it is considered as medium level problem.\\n\\nOpen to feedbacks. Thanks in advance :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Agreed, especially compared to some of the other game questions with game theory tag, a lot of those are tricky DP questions. The tag here makes you think that there is more going on, but there just isn\\'t. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "I believe it is tagged medium because the task of selecting three piles could somehow trick some people into thinking it is a dynamic programming problem, getting the pattern/intuition makes it very easy but to get that intuition you need some experience."
                    },
                    {
                        "username": "DCtheTall",
                        "content": "+1, this question is too straightforward to be medium level. It should be easy."
                    },
                    {
                        "username": "mmrubayet",
                        "content": "For chosing a pile of 3 coins:\n- 1st one have to be the biggest coin of all/remaining,\n- 2nd one have to be the 2nd biggest coin of all/remaining,\n- Last one have to be the smallest coin of all/remaining.\n- Remove/forget above 3.\n- Then, Repeat.\n\nApproach:\nFirst, reverse sort the array. Then, start loop from 2nd value which is my first coin. Bob's coins lies in the last side of the array, which is equal to total piles in array, i.e. len/3. End loop before Bob's value. Increment by two.\n\n[Don't see the solution here. Upvote if you understand.\n](https://leetcode.com/problems/maximum-number-of-coins-you-can-get/solutions/3205547/python-simple-easy-to-understand-beats-93-80/\n)"
                    },
                    {
                        "username": "ChloeWalt",
                        "content": "I don\\'t understand why for this test case: [9,8,7,6,5,1,2,3,4], the expected output is 18 and not 15?\\nWhen ordered:\\n[1,2,3,4,5,6,7,8,9]\\nThe coins the second person is choosing would be 2, 5 and 8 which = 15? "
                    },
                    {
                        "username": "dongdieuoke",
                        "content": "[1,8,9]   [2,6,7]   [3,4,5] => 8+6+4 = 18"
                    },
                    {
                        "username": "prachibhatia",
                        "content": "Coins can be chosen in the following ways :-\\nFirst triplet : [9,8,1]\\nSecond triplet : [7,6,2]\\nThirst triplet : [5,4,3]\\nCoins second person will choose are 8+6+4 = 18"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "1) In each step, you will choose any 3 piles of coins (not necessarily consecutive).\\n2) Of your choice, Alice will pick the pile with the maximum number of coins.\\n3) You will pick the next pile with maximum number of coins.\\n4) Your friend Bob will pick the last pile.\\n5)Repeat until there are no more piles of coins.\\n\\n4th point is misleading. \\nlast pile could also  mean last pile of  the original unsorted array itself!!!!!!!!!!!!!!\\n\\n\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "[@williamshark](/williamshark)  not when pile size>3  the last one can be anything. Last of sorted or unsorted  array .  thing is our sum will be maximum only when bob picks  the smallest pile."
                    },
                    {
                        "username": "williamshark",
                        "content": " But it\\'s kind of common sense to think that the last pile is just the one left over by the one you chose or it will be choose \"2 piles\""
                    },
                    {
                        "username": "z3eg",
                        "content": "ez problem"
                    },
                    {
                        "username": "sanskar2003",
                        "content": "This question is just a logic builder. If you are able to find the pattern, you will be able to solve it easily.\n\n class Solution {\n    public int maxCoins(int[] piles) {\n        Arrays.sort(piles);\n        int k = piles.length/3;\n        int result = 0;\n        for(int i=k; i<piles.length; i+=2){\n            result += piles[i];\n        }\n        return result;\n    }\n}"
                    },
                    {
                        "username": "Angad1418",
                        "content": "// catch is sequence does not matter like in last example 9,8,7,6....4\\n        // 1st > ours > last(now we can minimise to lowest) like\\n        // pairs { (9,8,1) (7,6,2) (5,4,3)} by this center is max\\nnow find out how you can reach to this type of sequence"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest medium level problem on this damn platform"
                    },
                    {
                        "username": "rizwan726",
                        "content": "I dont understand why the testcases are not passing?\\nclass Solution {\\n    public static int maxCoins(int x[]) {\\n        int n=x.length;int result=0;\\n        for(int i=n/3;i<n;i=i+2){\\n            result=result+x[i];\\n        }\\n        return result;\\n    }\\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        int T=sc.nextInt();\\n        while(T-->0){\\n            int piles[]=new int[sc.nextInt()];\\n            int temp=0;\\n            for(int i=0;i<piles.length;i++){\\n                piles[i]=sc.nextInt();\\n            }\\n            for(int i=0;i<piles.length;i++){\\n                for(int j=i;j<piles.length;j++){\\n                    if(piles[i]>piles[j]){\\n                        temp=piles[i];\\n                        piles[i]=piles[j];\\n                        piles[j]=temp;\\n                    }\\n                }\\n            }\\n            int x=maxCoins(piles);\\n            System.out.println(x);\\n        }\\n    }\\n}\\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "I thought this is pile so one can\\'t change the order it screwed me\\n\\n``` csharp []\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        var ans=0;\\n        for(var i=piles.Length-1;i>=0;)\\n        {\\n            int a =piles[i--],b=piles[i--],c=piles[i--];\\n            var max = Math.Max(a,Math.Max(b,c));\\n            var min = Math.Min(a,Math.Min(b,c));\\n            if(a!=max && a!=min) ans+=a;\\n            if(b!=max && b!=min) ans+=b;\\n            if(c!=max && c!=min) ans+=c;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```csharp []\\n// correct\\npublic class Solution \\n{\\n    public int MaxCoins(int[] piles) \\n    {\\n        Array.Sort(piles);\\n        int ans=0,i=0,j=piles.Length;\\n        while(i++<--j) ans+=piles[--j];\\n        return ans;\\n    }\\n}\\n```\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "The Earliest and Latest Rounds Where Players Compete",
        "question_content": "<p>There is a tournament where <code>n</code> players are participating. The players are standing in a single row and are numbered from <code>1</code> to <code>n</code> based on their <strong>initial</strong> standing position (player <code>1</code> is the first player in the row, player <code>2</code> is the second player in the row, etc.).</p>\n\n<p>The tournament consists of multiple rounds (starting from round number <code>1</code>). In each round, the <code>i<sup>th</sup></code> player from the front of the row competes against the <code>i<sup>th</sup></code> player from the end of the row, and the winner advances to the next round. When the number of players is odd for the current round, the player in the middle automatically advances to the next round.</p>\n\n<ul>\n\t<li>For example, if the row consists of players <code>1, 2, 4, 6, 7</code>\n\n\t<ul>\n\t\t<li>Player <code>1</code> competes against player <code>7</code>.</li>\n\t\t<li>Player <code>2</code> competes against player <code>6</code>.</li>\n\t\t<li>Player <code>4</code> automatically advances to the next round.</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>After each round is over, the winners are lined back up in the row based on the <strong>original ordering</strong> assigned to them initially (ascending order).</p>\n\n<p>The players numbered <code>firstPlayer</code> and <code>secondPlayer</code> are the best in the tournament. They can win against any other player before they compete against each other. If any two other players compete against each other, either of them might win, and thus you may <strong>choose</strong> the outcome of this round.</p>\n\n<p>Given the integers <code>n</code>, <code>firstPlayer</code>, and <code>secondPlayer</code>, return <em>an integer array containing two values, the <strong>earliest</strong> possible round number and the&nbsp;<strong>latest</strong> possible round number in which these two players will compete against each other, respectively</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 11, firstPlayer = 2, secondPlayer = 4\n<strong>Output:</strong> [3,4]\n<strong>Explanation:</strong>\nOne possible scenario which leads to the earliest round number:\nFirst round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\nSecond round: 2, 3, 4, 5, 6, 11\nThird round: 2, 3, 4\nOne possible scenario which leads to the latest round number:\nFirst round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\nSecond round: 1, 2, 3, 4, 5, 6\nThird round: 1, 2, 4\nFourth round: 2, 4\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5, firstPlayer = 1, secondPlayer = 5\n<strong>Output:</strong> [1,1]\n<strong>Explanation:</strong> The players numbered 1 and 5 compete in the first round.\nThere is no way to make them compete in any other round.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 28</code></li>\n\t<li><code>1 &lt;= firstPlayer &lt; secondPlayer &lt;= n</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1268539,
                "title": "recursion-memo-and-optimized-recursion",
                "content": "> We start with the straightforward recursion, then optimize it using memoisation, and finally arrive at the efficient solution using all that insight we gained. \\n\\n#### Recursion\\nWe try all combinations, and it should work since  `n` is limited to `28`. For the first round, we have no more than 2  ^ 12 choices (14 pairs, and winners are predefined for 2 pairs), second round - 2 ^ 5, then 2 ^ 2, then 1 choice, and finally we will have just two winners left. Therefore, we will have up to 524,288 total combinations and 5 rounds.\\n\\nThe tricky part is to make it as efficient as possible. For that, I am using `mask` to indicate which players have been eliminated.\\n \\nWe move `i` and `j` to pick the pairs; when `i >= j`, we start a new round. When `i` and `j` point to our finalists, we update the min and max rounds.\\n\\n**C++**\\n```cpp\\nint min_r = INT_MAX, max_r = INT_MIN;\\nvoid dfs(int mask, int round, int i, int j, int first, int second) {\\n    if (i >= j)\\n        dfs(mask, round + 1, 0, 27, first, second);\\n    else if ((mask & (1 << i)) == 0)\\n        dfs(mask, round, i + 1, j, first, second);\\n    else if ((mask & (1 << j)) == 0)\\n        dfs(mask, round, i, j - 1, first, second);\\n    else if (i == first && j == second) {\\n        min_r = min(min_r, round);\\n        max_r = max(max_r, round);\\n    }\\n    else {\\n        if (i != first && i != second)\\n            dfs(mask ^ (1 << i), round, i + 1, j - 1, first, second);\\n        if (j != first && j != second)\\n            dfs(mask ^ (1 << j), round, i + 1, j - 1, first, second);\\n    }\\n}\\nvector<int> earliestAndLatest(int n, int first, int second) {\\n    dfs((1 << n) - 1, 1, 0, 27, first - 1, second - 1);\\n    return { min_r, max_r };\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(2 ^ n).\\n- Memory: O(log n) for the recursion.\\n\\n#### Add Memoisation\\nI tried to memoise `visited` masks, but it only gave a modest boost. Then I realized that what really matters are the number of players standing before the first (left), in between (mid), and after (right) the second player. So we keep track of `l`, `m`, and `r` - a bit messy but does the job. With this insight, the runtime improved from 500 to 0 ms.\\n\\n**C++**\\n```cpp\\nint min_r = INT_MAX, max_r = INT_MIN;\\nbool visited[27][27][27] = {};\\nvoid dfs(int mask, int round, int i, int j, int first, int second, int l, int m, int r) {\\n    if (i >= j)\\n        dfs(mask, round + 1, 0, 27, first, second, l, m, r);\\n    else if ((mask & (1 << i)) == 0)\\n        dfs(mask, round, i + 1, j, first, second, l, m, r);\\n    else if ((mask & (1 << j)) == 0)\\n        dfs(mask, round, i, j - 1, first, second, l, m, r);\\n    else if (i == first && j == second) {\\n        min_r = min(min_r, round);\\n        max_r = max(max_r, round);\\n    }\\n    else if (!visited[l][m][r]) {\\n        visited[l][m][r] = true;\\n        if (i != first && i != second)\\n            dfs(mask ^ (1 << i), round, i + 1, j - 1, first, second, \\n                l - (i < first), m - (i > first && i < second), r - (i > second));\\n        if (j != first && j != second)\\n            dfs(mask ^ (1 << j), round, i + 1, j - 1, first, second,\\n                l - (j < first), m - (j > first && j < second), r - (j > second));\\n    }\\n}\\nvector<int> earliestAndLatest(int n, int first, int second) {\\n    dfs((1 << n) - 1, 1, 0, 27, first - 1, second - 1, first - 1, second - first - 1, n - second);\\n    return { min_r, max_r };\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n ^ 3).\\n- Memory: O(n ^ 3) for the memoisation.\\n\\n#### Optimized Recursion\\nWith the insight about tracking the number of players between champions, we can simplify the algorithm by computing possible transitions instead of simulating individual competitions. Say, we have 15 total players; 4 players on the left and 5 - on the right (including champions).\\n\\n![image](https://assets.leetcode.com/users/images/4d495627-d7e9-4227-a518-ec400badf5e0_1623970510.4030144.png)\\n\\nFor the second round, we will have 8 total players, and two possible cases: `[1, 4]` (or `[4, 1]`) and `[2, 3]` (or `[3, 2]`).\\n\\n![image](https://assets.leetcode.com/users/images/4af2736a-eadf-4fed-947e-853e8a7d9141_1623971629.9998062.png)\\n\\nSo, we will track players on the left `l` and right `r`, including champions, and total number of players `n`. If `l == r`, our champions will compete in the current round. \\n\\nDetermining the valid standings of players `i` and `j` after the round is a bit tricky, but here are ground rules:\\n- To simplify the calculation, we always make sure `l < r`. We can do it because reult for `[8, 3]` will be the same as for `[3, 8]`. \\n- `i` and `j` should be at least one to account for a champion.\\n- Picking `i` players on the left meaning that `l - i` players lose to players on the right.\\n\\t- So we have to pick `l - i  + 1` players on the right or more (`+1` is for the champion).\\n- Winers on the left and right (`i  + j`) should not exceed the number of players in the next round (`(n + 1) / 2`).\\n- Loosers on the left and right (`l - i + r - j`) should not exceed the half of players in the current round.\\n\\n**C++**\\n```cpp\\nint min_r = INT_MAX, max_r = INT_MIN;\\nvoid dfs(int l, int r, int n, int round) {\\n    if (l == r) {\\n        min_r = min(min_r, round);\\n        max_r = max(max_r, round);\\n    }\\n    else\\n        if (l > r)\\n            swap(l, r);\\n        for (int i = 1; i < l + 1; ++i)\\n            for (int j = l - i + 1; i + j <= min(r, (n + 1) / 2); ++j)\\n                if (l + r - (i + j) <= n / 2)\\n                    dfs(i, j, (n + 1) / 2, round + 1);\\n}\\nvector<int> earliestAndLatest(int n, int first, int second) {\\n    dfs(first, n - second + 1, n, 1);\\n    return { min_r, max_r };\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint min_r = INT_MAX, max_r = INT_MIN;\\nvoid dfs(int mask, int round, int i, int j, int first, int second) {\\n    if (i >= j)\\n        dfs(mask, round + 1, 0, 27, first, second);\\n    else if ((mask & (1 << i)) == 0)\\n        dfs(mask, round, i + 1, j, first, second);\\n    else if ((mask & (1 << j)) == 0)\\n        dfs(mask, round, i, j - 1, first, second);\\n    else if (i == first && j == second) {\\n        min_r = min(min_r, round);\\n        max_r = max(max_r, round);\\n    }\\n    else {\\n        if (i != first && i != second)\\n            dfs(mask ^ (1 << i), round, i + 1, j - 1, first, second);\\n        if (j != first && j != second)\\n            dfs(mask ^ (1 << j), round, i + 1, j - 1, first, second);\\n    }\\n}\\nvector<int> earliestAndLatest(int n, int first, int second) {\\n    dfs((1 << n) - 1, 1, 0, 27, first - 1, second - 1);\\n    return { min_r, max_r };\\n}\\n```\n```cpp\\nint min_r = INT_MAX, max_r = INT_MIN;\\nbool visited[27][27][27] = {};\\nvoid dfs(int mask, int round, int i, int j, int first, int second, int l, int m, int r) {\\n    if (i >= j)\\n        dfs(mask, round + 1, 0, 27, first, second, l, m, r);\\n    else if ((mask & (1 << i)) == 0)\\n        dfs(mask, round, i + 1, j, first, second, l, m, r);\\n    else if ((mask & (1 << j)) == 0)\\n        dfs(mask, round, i, j - 1, first, second, l, m, r);\\n    else if (i == first && j == second) {\\n        min_r = min(min_r, round);\\n        max_r = max(max_r, round);\\n    }\\n    else if (!visited[l][m][r]) {\\n        visited[l][m][r] = true;\\n        if (i != first && i != second)\\n            dfs(mask ^ (1 << i), round, i + 1, j - 1, first, second, \\n                l - (i < first), m - (i > first && i < second), r - (i > second));\\n        if (j != first && j != second)\\n            dfs(mask ^ (1 << j), round, i + 1, j - 1, first, second,\\n                l - (j < first), m - (j > first && j < second), r - (j > second));\\n    }\\n}\\nvector<int> earliestAndLatest(int n, int first, int second) {\\n    dfs((1 << n) - 1, 1, 0, 27, first - 1, second - 1, first - 1, second - first - 1, n - second);\\n    return { min_r, max_r };\\n}\\n```\n```cpp\\nint min_r = INT_MAX, max_r = INT_MIN;\\nvoid dfs(int l, int r, int n, int round) {\\n    if (l == r) {\\n        min_r = min(min_r, round);\\n        max_r = max(max_r, round);\\n    }\\n    else\\n        if (l > r)\\n            swap(l, r);\\n        for (int i = 1; i < l + 1; ++i)\\n            for (int j = l - i + 1; i + j <= min(r, (n + 1) / 2); ++j)\\n                if (l + r - (i + j) <= n / 2)\\n                    dfs(i, j, (n + 1) / 2, round + 1);\\n}\\nvector<int> earliestAndLatest(int n, int first, int second) {\\n    dfs(first, n - second + 1, n, 1);\\n    return { min_r, max_r };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1268452,
                "title": "python-2-solution-dfs-and-smart-dp-explained",
                "content": "Not very difficult problem, the main problem in python to make it work without TLE. Let us use `dfs(pos, i)` function, where:\\n1. `pos` is tuple of players we still have.\\n2. `i` is how many matches were already played.\\n\\nEach time we run recursion, check that pair `(firstPlayer, secondPlayer)` is not here yet (denoted by `F` and `S`), if it is, add number of matches played to set `ans` and return. Also, ignore pairs where one of the two players is `S` or `F`. Finally, use functionality of python `product` function to fastly generate all next positions.\\n\\n#### Complexity\\nWe have `n` players in the beginning, and we have `n//2` pairs, so there is `O(2^(n//2))` options for the first step, then it will be `O(2^(n//4))` and so on, so in the end we can have potentially `O(2^n)` positions, which is our time complexity. However, due to careful prunning, it practice it is much less, like if we have `28`, then on the next step we have not `2^14`, but `2^12` positions, because `S` and `F` always go to the next match or we stop, then we have `2^5` and then we have `2^1`, so it is more like `2^(12 + 5 + 1) = 2^18`, so it is still feasible. Space complexity is `O(n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def earliestAndLatest(self, n, F, S):\\n        ans = set()\\n        def dfs(pos, i):\\n            M, pairs = len(pos), []\\n            if M < 2: return\\n\\n            for j in range(M//2):\\n                a, b = pos[j], pos[-1-j]\\n                if (a, b) == (F, S):\\n                    ans.add(i)\\n                    return\\n                if a != F and b != F and a != S and b != S:\\n                    pairs.append((a, b))\\n\\n            addon = (F, S) if M%2 == 0 else tuple(set([F, S, pos[M//2]]))\\n            for elem in product(*pairs):\\n                dfs(sorted(elem + addon), i + 1)\\n\\n        dfs(list(range(1, n+1)), 1)\\n        return [min(ans), max(ans)]\\n```\\n\\n#### Solution 2\\nThis solution is borrowed from https://leetcode.com/problems/the-earliest-and-latest-rounds-where-players-compete/discuss/1268560/Python-simple-top-down-dp-solution-O(N4*logN), here I just rewrote it a bit and try to add some explanations with examples. Please go and upvote this post, it deserves more upvotes.\\n\\nDefine by `dp(l, r, m, q)` state with the following parameters:\\n\\n1. `l` and `r` are positions of our `F` and `S` players from start and from end. For example if we have 1, 2, **3**, 4, 5, 6, **7**, 8, 9, 10, 11, 12, where we denoted by bold elements the first and the second player, and we have `l = 3` and `r = 6`.\\n2. `m` is current number of players, we have 12 here and `q` is number of games already played.\\n\\nWhat can happen on the next step? Let us go through options and see what is going on. Let us denote by underline  <u>x</u> the players who loose and by **x** player who win.\\nThen at the moment we have the following situation:\\n\\n1, 2, **3**, 4, 5, <u>6</u>, **7**, 8, 9, <u>10</u>, 11, 12.\\n\\nWhat can happen that among players `1` and `2` there can be zero, one or two wins, and actually it does not matter which ones. Let us consider the cases:\\n\\n1. We have zero wins, so we have <u>1</u>, <u>2</u>, **3**, 4, 5, <u>6</u>, **7**, 8, 9, <u>10</u>, **11**, **12**. Then what we know for sure is in new round player **3** will be the first. Player **7** can be either 3, 4 or 5 from the end.\\n2. We have one wins, so we have <u>1</u>, **2**, **3**, 4, 5, <u>6</u>, **7**, 8, 9, <u>10</u>, <u>11</u>, **12**. Then what we know for sure is in new round player **3** will be the second. Player **7** can be either 2, 3 or 4 from the end.\\n3. We have two wins, so we have **1**, **2**, **3**, 4, 5, <u>6</u>, **7**, 8, 9, <u>10</u>, <u>11</u>, <u>12</u>. Then what we know for sure is in new round player **3** will be the third. Player **7** can be either 1, 2 or 3 from the end.\\n\\nSo, what we need to do is to carefully understand all the cases we can meet.\\n\\n#### Complexity\\nWe have `O(n^2*log(n)` states: `O(n)` for both `l` and `r` and `log(n)` states for `m`, which will define `q` in unique way. We have `O(n^2)` transactions from one state to others, so time complexity is `O(n^4*log n)`, space complexity is `O(n^2*log n)`. Actually, more detailed analysis shows that log factor can be removed, because say `n = 64`, then we have `O(64*64)` states for `m = 64`, then we have `O(32*32)` states for `m = 32` and so on. So final time complexity is `O(n^4)`, space is `O(n^2)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def earliestAndLatest(self, n, F, S):\\n        @lru_cache(None)\\n        def dp(l, r, m, q):\\n            if l > r:  dp(r, l, m, q)\\n            if l == r: ans.add(q)\\n            \\n            for i in range(1, l + 1):\\n                for j in range(l-i+1, r-i+1):\\n                    if not (m+1)//2 >= i + j >= l + r - m//2: continue\\n                    dp(i, j, (m + 1) // 2, q + 1)\\n        \\n        ans = set()\\n        dp(F, n - S + 1, n, 1)\\n        return [min(ans), max(ans)]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def earliestAndLatest(self, n, F, S):\\n        ans = set()\\n        def dfs(pos, i):\\n            M, pairs = len(pos), []\\n            if M < 2: return\\n\\n            for j in range(M//2):\\n                a, b = pos[j], pos[-1-j]\\n                if (a, b) == (F, S):\\n                    ans.add(i)\\n                    return\\n                if a != F and b != F and a != S and b != S:\\n                    pairs.append((a, b))\\n\\n            addon = (F, S) if M%2 == 0 else tuple(set([F, S, pos[M//2]]))\\n            for elem in product(*pairs):\\n                dfs(sorted(elem + addon), i + 1)\\n\\n        dfs(list(range(1, n+1)), 1)\\n        return [min(ans), max(ans)]\\n```\n```python\\nclass Solution:\\n    def earliestAndLatest(self, n, F, S):\\n        @lru_cache(None)\\n        def dp(l, r, m, q):\\n            if l > r:  dp(r, l, m, q)\\n            if l == r: ans.add(q)\\n            \\n            for i in range(1, l + 1):\\n                for j in range(l-i+1, r-i+1):\\n                    if not (m+1)//2 >= i + j >= l + r - m//2: continue\\n                    dp(i, j, (m + 1) // 2, q + 1)\\n        \\n        ans = set()\\n        dp(F, n - S + 1, n, 1)\\n        return [min(ans), max(ans)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268560,
                "title": "python-simple-top-down-dp-solution-o-n-4",
                "content": "**Idea**\\n\\n`dp(l, r, m)` is the result when firstPlayer is the `l-th` player from left and secondPlayer is the `r-th` player from right, and there are `m` players in total.\\n\\nThe base case is straight-forward: simply check `l == r`. \\n\\nBy making sure `l <= r`, the dp transition is also manageable. In the next round, `l` can be `1, ..., l`. The only tricky part is the range of `r` in the next round. This depends on two things:\\n1) how many times the players to the left of first player win/lose. \\n2) the second player is in the left or right half of the remaining players. \\n\\nPlease see code below for more details =)\\n\\n</br>\\n\\n**Complexity**\\n\\nFor `dp(l, r, m)`, `l` and `r` are of `O(N)`, and `m` is of `O(logN)`. The loop in `dp` takes `O(M^2)`. \\n\\nBased on [@DBabichev](https://leetcode.com/DBabichev/)\\'s comment, there are in total `n^2 + (n//2)^2 + ...` states, so the total time complexity is `O(N^4)`.\\n\\n- Time complexity: `O(N^4)`\\n- Space complexity: `O(N^2)`\\n\\n</br>\\n\\n**Python**\\n\\n```Python\\nclass Solution:\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        @cache\\n        def dp(l, r, m):\\n            # make sure l <= r\\n            if l > r:\\n                return dp(r, l, m)\\n            # base case\\n            if l == r:\\n                return (1, 1)\\n            # dp transition\\n            nxt_m = (m + 1) // 2\\n            ans = [n, 0]\\n            for i in range(1, l + 1):\\n                l_win, l_lose = i - 1, l - i\\n                for j in range(max(r - (m//2) - 1, 0) + l_lose + 1, min(r - 1 - l_win, nxt_m - i) + 1):\\n                    tmp = dp(i, j, nxt_m)\\n                    ans = min(ans[0], tmp[0]), max(ans[1], tmp[1])\\n            return (ans[0] + 1, ans[1] + 1)\\n        \\n        return dp(firstPlayer, n - secondPlayer + 1, n)\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        @cache\\n        def dp(l, r, m):\\n            # make sure l <= r\\n            if l > r:\\n                return dp(r, l, m)\\n            # base case\\n            if l == r:\\n                return (1, 1)\\n            # dp transition\\n            nxt_m = (m + 1) // 2\\n            ans = [n, 0]\\n            for i in range(1, l + 1):\\n                l_win, l_lose = i - 1, l - i\\n                for j in range(max(r - (m//2) - 1, 0) + l_lose + 1, min(r - 1 - l_win, nxt_m - i) + 1):\\n                    tmp = dp(i, j, nxt_m)\\n                    ans = min(ans[0], tmp[0]), max(ans[1], tmp[1])\\n            return (ans[0] + 1, ans[1] + 1)\\n        \\n        return dp(firstPlayer, n - secondPlayer + 1, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268445,
                "title": "c-bit-mask-dfs-solution",
                "content": "### Idea\\n- seperate the team to left side and right side, use bit mask to try all the winning status of left side and generate the next round of players and go to the next round.\\n- if we can match first player and second player in the current round, then calculate the max and min round.\\n- if we can not find first and second player in current array, we can early return.\\n\\n### Complexity\\n- Time: O(2 ^ (n / 2) * n)\\n- Space: O(n)\\n\\n### Solution\\n- C++\\n```\\nclass Solution {\\npublic:\\n    int mn = 10000;\\n    int mx = 0;\\n    int first;\\n    int second;\\n    void dfs(vector<int> &arr, int round) {\\n        int size = arr.size() / 2;\\n        if(arr.size() == 1) return;\\n        for(int i = 0; i < size; i++) {\\n            //if we can match first and second in this round.\\n            if(arr[i] == first && arr[arr.size() - i - 1] == second) {\\n                mn = min(mn, round);\\n                mx = max(mx, round);\\n                return;\\n            }\\n        }\\n        bool f1 = false, f2 = false;\\n        for(auto n : arr) {\\n            f1 |= n == first;\\n            f2 |= n == second;\\n        }\\n        if(!f1 || !f2) { //can not find first and second player.\\n            return;\\n        }\\n        vector<int> nextarr(size + (arr.size() % 2));\\n        int m = (1 << size) - 1;\\n        for(int i = 0; i <= m; i++) { //try all the winning status for the left side players.\\n            int left = 0, right = nextarr.size() - 1;\\n            for(int j = 0; j < size; j++) {\\n                if((1 << j) & i) { //left side player win, put it to the next array.\\n                    nextarr[left++] = arr[j];\\n                }else { //right side player win.\\n                    nextarr[right--] = arr[arr.size() - j - 1];\\n                }\\n                \\n            }\\n            if(arr.size() % 2) { //middle player go to the next round.\\n                nextarr[left] = arr[arr.size() / 2];\\n            }\\n            dfs(nextarr, round + 1);\\n        }\\n    }\\n    vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n        vector<int> arr(n);\\n        for(int i= 1; i <= n; i++) {\\n            arr[i - 1] = i;\\n        }\\n        first = firstPlayer;\\n        second = secondPlayer;\\n        dfs(arr, 1);\\n        return {mn, mx};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mn = 10000;\\n    int mx = 0;\\n    int first;\\n    int second;\\n    void dfs(vector<int> &arr, int round) {\\n        int size = arr.size() / 2;\\n        if(arr.size() == 1) return;\\n        for(int i = 0; i < size; i++) {\\n            //if we can match first and second in this round.\\n            if(arr[i] == first && arr[arr.size() - i - 1] == second) {\\n                mn = min(mn, round);\\n                mx = max(mx, round);\\n                return;\\n            }\\n        }\\n        bool f1 = false, f2 = false;\\n        for(auto n : arr) {\\n            f1 |= n == first;\\n            f2 |= n == second;\\n        }\\n        if(!f1 || !f2) { //can not find first and second player.\\n            return;\\n        }\\n        vector<int> nextarr(size + (arr.size() % 2));\\n        int m = (1 << size) - 1;\\n        for(int i = 0; i <= m; i++) { //try all the winning status for the left side players.\\n            int left = 0, right = nextarr.size() - 1;\\n            for(int j = 0; j < size; j++) {\\n                if((1 << j) & i) { //left side player win, put it to the next array.\\n                    nextarr[left++] = arr[j];\\n                }else { //right side player win.\\n                    nextarr[right--] = arr[arr.size() - j - 1];\\n                }\\n                \\n            }\\n            if(arr.size() % 2) { //middle player go to the next round.\\n                nextarr[left] = arr[arr.size() / 2];\\n            }\\n            dfs(nextarr, round + 1);\\n        }\\n    }\\n    vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n        vector<int> arr(n);\\n        for(int i= 1; i <= n; i++) {\\n            arr[i - 1] = i;\\n        }\\n        first = firstPlayer;\\n        second = secondPlayer;\\n        dfs(arr, 1);\\n        return {mn, mx};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271531,
                "title": "greedy-log-n-solution",
                "content": "This greedy code can handle n up to 1e18. No iteration over choices, no min() or max() used. \\nHowever, the solution is hard to explain. Sorry, have to leave it for you guys to understand.\\n```py\\nclass Solution(object):\\n    def earliestAndLatest(self, n, a, b):\\n        \"\"\"\\n        :type n: int\\n        :type firstPlayer: int\\n        :type secondPlayer: int\\n        :rtype: List[int]\\n        \"\"\"\\n        def simplify(n, a, b):\\n            # swap\\n            if a>b: a, b = b, a\\n            # flip\\n            if a+b >= n+1:\\n                a, b = n+1-b, n+1-a\\n            return n, a, b\\n    \\n        def get_info(n,a,b):\\n            ll, rr = a-1, n-b\\n            aa = n-ll\\n            bb = 1+rr\\n            return ll,rr,aa,bb\\n\\n        def while_loop(n, a, b):\\n            ans = 1\\n            while a+b < n+1:\\n                n = (n+1)/2\\n                ans += 1\\n            if b-a-1==0:\\n                while n%2:\\n                    n = (n+1)/2\\n                    ans += 1\\n            return ans\\n\\n        def solve_fast(n, a, b):\\n            n, a, b = simplify(n, a, b)\\n            if a+b == n+1: \\n                return 1\\n\\n            # b is on the left, including center\\n            if b <= (n+1)/2:\\n                return while_loop(n, a, b)\\n            \\n            # b is on the right\\n            ll, rr, aa, bb = get_info(n, a, b)\\n            if (ll%2==1 and bb-a-1==0):\\n                if (n%2==0) and (b == n/2+1):                    \\n                    return 1 + while_loop((n+1)/2, a, a+1)\\n                else:\\n                    return 3\\n            else:\\n                return 2\\n\\n        def solve_slow(n, a, b):\\n            n, a, b = simplify(n, a, b)\\n            if a+b==n+1: \\n                return 1\\n            # b is in the left, all can be deleted\\n            if b <= n+1-b:  \\n                return 1+solve_slow((n+1)/2, 1, 2)\\n            else:\\n                # b is in the right\\n                ll, rr, aa, bb = get_info(n, a, b)\\n                keep = (b-bb-1)/2 + n%2\\n                return 1+solve_slow((n+1)/2, 1, 1+keep+1) \\n\\n        return [solve_fast(n,a,b), solve_slow(n,a,b)]\\n```\\t\\t",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```py\\nclass Solution(object):\\n    def earliestAndLatest(self, n, a, b):\\n        \"\"\"\\n        :type n: int\\n        :type firstPlayer: int\\n        :type secondPlayer: int\\n        :rtype: List[int]\\n        \"\"\"\\n        def simplify(n, a, b):\\n            # swap\\n            if a>b: a, b = b, a\\n            # flip\\n            if a+b >= n+1:\\n                a, b = n+1-b, n+1-a\\n            return n, a, b\\n    \\n        def get_info(n,a,b):\\n            ll, rr = a-1, n-b\\n            aa = n-ll\\n            bb = 1+rr\\n            return ll,rr,aa,bb\\n\\n        def while_loop(n, a, b):\\n            ans = 1\\n            while a+b < n+1:\\n                n = (n+1)/2\\n                ans += 1\\n            if b-a-1==0:\\n                while n%2:\\n                    n = (n+1)/2\\n                    ans += 1\\n            return ans\\n\\n        def solve_fast(n, a, b):\\n            n, a, b = simplify(n, a, b)\\n            if a+b == n+1: \\n                return 1\\n\\n            # b is on the left, including center\\n            if b <= (n+1)/2:\\n                return while_loop(n, a, b)\\n            \\n            # b is on the right\\n            ll, rr, aa, bb = get_info(n, a, b)\\n            if (ll%2==1 and bb-a-1==0):\\n                if (n%2==0) and (b == n/2+1):                    \\n                    return 1 + while_loop((n+1)/2, a, a+1)\\n                else:\\n                    return 3\\n            else:\\n                return 2\\n\\n        def solve_slow(n, a, b):\\n            n, a, b = simplify(n, a, b)\\n            if a+b==n+1: \\n                return 1\\n            # b is in the left, all can be deleted\\n            if b <= n+1-b:  \\n                return 1+solve_slow((n+1)/2, 1, 2)\\n            else:\\n                # b is in the right\\n                ll, rr, aa, bb = get_info(n, a, b)\\n                keep = (b-bb-1)/2 + n%2\\n                return 1+solve_slow((n+1)/2, 1, 1+keep+1) \\n\\n        return [solve_fast(n,a,b), solve_slow(n,a,b)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1272828,
                "title": "10-lines-0ms-bit-counting-solution-o-1-time-o-1-space",
                "content": "**Idea**\\nI was heavily inspired by @wisdompeak\\'s [`O(log n)` greedy recursive solution](https://leetcode.com/problems/the-earliest-and-latest-rounds-where-players-compete/discuss/1271531/Greedy-log(N)-solution), and looked for more patterns and how to eliminate all the recursive calls and loops. \\n\\nThis problem turns out to have a pretty simple solution. A key insight also came from @alanlzl\\'s post: we can assume that `first` is closer to the left than `second` is to the right.\\n\\n1. **Finding Latest**: The optimal strategy for getting the latest round is to push `first` and `second` into positions 1 and 2, so all players left of \\'second\\' should try to lose. This is always possible to do if `second` is left of or at the middle, after which we return the most significant bit of n (rounds left). If `second` is close to the right edge, we can\\'t push it to position 2, and `first` will eliminate at least one player to the right of `second` each round.\\n\\n2. **Finding Earliest**: It\\'s usually possible to win in around 2-3 rounds. This is intuitive by the huge amount of control we have for where `first` and `second` will go in the next round, especially if there are many spaces between `first` and `second`. However, the position of each player only moves left, so we may need to wait some rounds for the midpoint of our player list to fall between `first` and `second`, in which case all players left of `second` should try to win.\\n\\n**Complexity**\\nAssuming that we can read the number of trailing zeroes and leading zeroes from `n` in `O(1)` time, e.g. with the builtin assembly functions, there are a fixed number of operations. There\\'s no recursion or loops (and both versions can be done without any function calls), and our only memory usage is 2 or 3 ints. \\n* Time complexity: `O(1)` if `n` fits in a machine word / 64 bits\\n* Space complexity: `O(1)`\\n\\t\\n\\n**C++:**\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> earliestAndLatest(int n, int first, int second) {\\n        if (first + second == n + 1) return {1, 1};\\n        if (first + second > n + 1) tie(first, second) = make_tuple(n+1-second, n+1-first);\\n        \\n        int ans_earliest = 1, ans_latest = min(32 - __builtin_clz(n-1), n+1-second);\\n        if (first + second==n){\\n            if (first % 2 == 0) ans_earliest = first+2 < second? 2: 1 + __builtin_ctz(first);\\n        }\\n        else if (first+1 == second){\\n            ans_earliest = 32 - __builtin_clz((n-1) / (first+second-1));\\n            ans_earliest += __builtin_ctz((n-1)>>ans_earliest);\\n        }\\n        else if (first+second <= (n+1)/2) ans_earliest = 32 - __builtin_clz((n-1) / (first+second-1));\\n        return {ans_earliest+1, ans_latest};\\n    }\\n};\\n```\\n\\nSome more insight:\\n\\n* One trick used repeatedly is that the number of players transforms as: `n -> (n+1) / 2` every round. This means that the number of rounds by the time `n` becomes 2 is `ceiling(log_2(n))`, at which point the game ends. `ceiling(log_2(n))` can be computed efficiently as `# of bits in an int (32) - leading zeros(n-1)`. \\n* This line requires special attention:\\n```python\\n# We want to know the number of rounds left until first + second >= n+1. \\n# By the game rules, this is the minimum value of \\n# k >= 0 such that ceiling(n / 2^k) < first + second.\\n# With some rearranging, this becomes \\nrounds_left = ceiling_of_log2((n + first + second - 2) // (first + second - 1))\\n```\\n\\n\\nMost of the Python code is just the bitwise implementations of C++ builtins/ assembly operations, working for up to 32 bit ints, as well as many comments. If `2**31 < n < 2**64`, a single extra line is required for these functions. These are fairly common; I found these 3 functions in a textbook. If `n` is tiny and needs much fewer than `32` bits, it\\'s faster to just loop over the bits.\\n\\nI wrote out a full proof for each of the cases, but the \\'earliest\\' case is quite long. The key idea is to treat the problem as having 3 boxes, left, middle, and right, and trying to allocate an equal number of players into the left and right boxes. We get a choice of distributing `first-1` players to either the left or right boxes.  If `second` is at or right of the midpoint, we also get `n-first-second` players to place in the middle or right boxes, and so we can make the left and right boxes equal in 2 or 3 rounds, at which point we\\'ve won if `first+1 != second`. If `second` is left of the midpoint, we only get `second-first-1` players to place in the middle or right boxes, which means the right box will end up larger than the left box. So we use induction to show that the optimal placement is having all `first-1` players left of `first` win their games, and all players between `first` and `second` try to win their games, minimizing the difference between right and left.\\n\\n**Python:**\\n```python\\nclass Solution:\\n\\tdef earliestAndLatest(self, n: int, first: int, second: int) -> List[int]:\\n\\t\\tdef ceiling_of_log2(x: int) -> int:\\n\\t\\t\\t\"\"\" Return the ceiling of the integer log 2, i.e. index(MSB) - 1 + (1 if x not pow2) \"\"\"\\n\\t\\t\\tassert 0 < x < 0x100000000\\n\\t\\t\\t# Use power of 2 test. offset is 1 iff x is NOT a power of 2\\n\\t\\t\\toffset = 1 if (x & (x - 1)) != 0 else 0\\n\\t\\t\\tx |= (x >> 1)\\n\\t\\t\\tx |= (x >> 2)\\n\\t\\t\\tx |= (x >> 4)\\n\\t\\t\\tx |= (x >> 8)\\n\\t\\t\\tx |= (x >> 16)\\n\\t\\t\\t# Remove offset to get floor_of_log2. floor(log2(x)) + 1 == ceil(log2(x)) iff x not a power of 2.\\n\\t\\t\\treturn popcount(x) - 1 + offset\\n\\n\\t\\tdef popcount(x: int) -> int:\\n\\t\\t\\t\"\"\" Return the number of set bits in 32 bit unsigned x (Hamming weight) \"\"\"\\n\\t\\t\\tassert 0 <= x < 0x100000000\\n\\t\\t\\tx = x - ((x >> 1) & 0x55555555)\\n\\t\\t\\tx = (x & 0x33333333) + ((x >> 2) & 0x33333333)\\n\\t\\t\\treturn (((x + (x >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24\\n\\n\\t\\tdef count_trailing_zeroes(x: int) -> int:\\n\\t\\t\\t\"\"\" Return the number of trailing zeroes in 32 bit unsigned x > 0 (LSB + 1). This method is similar to\\n\\t\\t\\t\\tbranchless binary search, but there are many other methods using the integer log2\"\"\"\\n\\t\\t\\tassert 0 < x < 0x100000000\\n\\t\\t\\tif x & 0x1: return 0  # odd x, quick break\\n\\t\\t\\tc = 1\\n\\t\\t\\tif (x & 0xffff) == 0:\\n\\t\\t\\t\\tx >>= 16\\n\\t\\t\\t\\tc += 16\\n\\t\\t\\tif (x & 0xff) == 0:\\n\\t\\t\\t\\tx >>= 8\\n\\t\\t\\t\\tc += 8\\n\\t\\t\\tif (x & 0xf) == 0:\\n\\t\\t\\t\\tx >>= 4\\n\\t\\t\\t\\tc += 4\\n\\t\\t\\tif (x & 0x3) == 0:\\n\\t\\t\\t\\tx >>= 2\\n\\t\\t\\t\\tc += 2\\n\\t\\t\\treturn c - (x & 0x1)\\n\\n\\t\\t# Base case, we can return instantly\\n\\t\\tif first + second == n + 1: return [1, 1]\\n\\n\\t\\t# This ensures that \\'first\\' is closer to the left than \\'second\\' is to the right.\\n\\t\\t# Also, crucially ensures that the sum of first and second is minimal among equivalent configs.\\n\\t\\tif first + second >= n + 1: first, second = n + 1 - second, n + 1 - first\\n\\n\\t\\tfirst_plus_second = first + second\\n\\n\\t\\t# Special case if first + 1 == second, since we then need to find which round will have an even # of players\\n\\t\\tif first + 1 != second and first_plus_second >= (n + 1) // 2 + 1:\\n\\t\\t\\tif first_plus_second == n:\\n\\t\\t\\t\\t# If n is 4k + 2, first is 2k, and second is 2k+2, then parity of n also matters.\\n\\t\\t\\t\\tif n % 4 == 2 and first + 2 == second:\\n\\t\\t\\t\\t\\t# Using n // 4 instead of n//4 + 1 because trailing_zeroes(x-1) = rounds until x is even\\n\\t\\t\\t\\t\\tans_earliest = 3 + count_trailing_zeroes(n // 4)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tans_earliest = 3 - (first % 2)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans_earliest = 2\\n\\n\\t\\t# If we are in a special case: Players are too far left and close together to meet next round\\n\\t\\telse:\\n\\t\\t\\tans_earliest = 1 + ceiling_of_log2((n + first_plus_second - 2) // (first_plus_second - 1))\\n\\t\\t\\tif first + 1 == second:\\n\\t\\t\\t\\tans_earliest += count_trailing_zeroes(((n + (1 << (ans_earliest-1)) - 1) >> (ans_earliest-1)) - 1)\\n\\n\\t\\t# ceiling_of_log2 of n is the number of rounds left until there are exactly 2 players remaining, starting at n.\\n\\t\\t# This implicitly assumes that optimal strategy for ans_latest is moving \\'first\\' and \\'second\\' to pos. 1 and 2\\n\\t\\tans_latest = min(ceiling_of_log2(n), n + 1 - second)\\n\\n\\t\\treturn [ans_earliest, ans_latest]\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<int> earliestAndLatest(int n, int first, int second) {\\n        if (first + second == n + 1) return {1, 1};\\n        if (first + second > n + 1) tie(first, second) = make_tuple(n+1-second, n+1-first);\\n        \\n        int ans_earliest = 1, ans_latest = min(32 - __builtin_clz(n-1), n+1-second);\\n        if (first + second==n){\\n            if (first % 2 == 0) ans_earliest = first+2 < second? 2: 1 + __builtin_ctz(first);\\n        }\\n        else if (first+1 == second){\\n            ans_earliest = 32 - __builtin_clz((n-1) / (first+second-1));\\n            ans_earliest += __builtin_ctz((n-1)>>ans_earliest);\\n        }\\n        else if (first+second <= (n+1)/2) ans_earliest = 32 - __builtin_clz((n-1) / (first+second-1));\\n        return {ans_earliest+1, ans_latest};\\n    }\\n};\\n```\n```python\\n# We want to know the number of rounds left until first + second >= n+1. \\n# By the game rules, this is the minimum value of \\n# k >= 0 such that ceiling(n / 2^k) < first + second.\\n# With some rearranging, this becomes \\nrounds_left = ceiling_of_log2((n + first + second - 2) // (first + second - 1))\\n```\n```python\\nclass Solution:\\n\\tdef earliestAndLatest(self, n: int, first: int, second: int) -> List[int]:\\n\\t\\tdef ceiling_of_log2(x: int) -> int:\\n\\t\\t\\t\"\"\" Return the ceiling of the integer log 2, i.e. index(MSB) - 1 + (1 if x not pow2) \"\"\"\\n\\t\\t\\tassert 0 < x < 0x100000000\\n\\t\\t\\t# Use power of 2 test. offset is 1 iff x is NOT a power of 2\\n\\t\\t\\toffset = 1 if (x & (x - 1)) != 0 else 0\\n\\t\\t\\tx |= (x >> 1)\\n\\t\\t\\tx |= (x >> 2)\\n\\t\\t\\tx |= (x >> 4)\\n\\t\\t\\tx |= (x >> 8)\\n\\t\\t\\tx |= (x >> 16)\\n\\t\\t\\t# Remove offset to get floor_of_log2. floor(log2(x)) + 1 == ceil(log2(x)) iff x not a power of 2.\\n\\t\\t\\treturn popcount(x) - 1 + offset\\n\\n\\t\\tdef popcount(x: int) -> int:\\n\\t\\t\\t\"\"\" Return the number of set bits in 32 bit unsigned x (Hamming weight) \"\"\"\\n\\t\\t\\tassert 0 <= x < 0x100000000\\n\\t\\t\\tx = x - ((x >> 1) & 0x55555555)\\n\\t\\t\\tx = (x & 0x33333333) + ((x >> 2) & 0x33333333)\\n\\t\\t\\treturn (((x + (x >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24\\n\\n\\t\\tdef count_trailing_zeroes(x: int) -> int:\\n\\t\\t\\t\"\"\" Return the number of trailing zeroes in 32 bit unsigned x > 0 (LSB + 1). This method is similar to\\n\\t\\t\\t\\tbranchless binary search, but there are many other methods using the integer log2\"\"\"\\n\\t\\t\\tassert 0 < x < 0x100000000\\n\\t\\t\\tif x & 0x1: return 0  # odd x, quick break\\n\\t\\t\\tc = 1\\n\\t\\t\\tif (x & 0xffff) == 0:\\n\\t\\t\\t\\tx >>= 16\\n\\t\\t\\t\\tc += 16\\n\\t\\t\\tif (x & 0xff) == 0:\\n\\t\\t\\t\\tx >>= 8\\n\\t\\t\\t\\tc += 8\\n\\t\\t\\tif (x & 0xf) == 0:\\n\\t\\t\\t\\tx >>= 4\\n\\t\\t\\t\\tc += 4\\n\\t\\t\\tif (x & 0x3) == 0:\\n\\t\\t\\t\\tx >>= 2\\n\\t\\t\\t\\tc += 2\\n\\t\\t\\treturn c - (x & 0x1)\\n\\n\\t\\t# Base case, we can return instantly\\n\\t\\tif first + second == n + 1: return [1, 1]\\n\\n\\t\\t# This ensures that \\'first\\' is closer to the left than \\'second\\' is to the right.\\n\\t\\t# Also, crucially ensures that the sum of first and second is minimal among equivalent configs.\\n\\t\\tif first + second >= n + 1: first, second = n + 1 - second, n + 1 - first\\n\\n\\t\\tfirst_plus_second = first + second\\n\\n\\t\\t# Special case if first + 1 == second, since we then need to find which round will have an even # of players\\n\\t\\tif first + 1 != second and first_plus_second >= (n + 1) // 2 + 1:\\n\\t\\t\\tif first_plus_second == n:\\n\\t\\t\\t\\t# If n is 4k + 2, first is 2k, and second is 2k+2, then parity of n also matters.\\n\\t\\t\\t\\tif n % 4 == 2 and first + 2 == second:\\n\\t\\t\\t\\t\\t# Using n // 4 instead of n//4 + 1 because trailing_zeroes(x-1) = rounds until x is even\\n\\t\\t\\t\\t\\tans_earliest = 3 + count_trailing_zeroes(n // 4)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tans_earliest = 3 - (first % 2)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans_earliest = 2\\n\\n\\t\\t# If we are in a special case: Players are too far left and close together to meet next round\\n\\t\\telse:\\n\\t\\t\\tans_earliest = 1 + ceiling_of_log2((n + first_plus_second - 2) // (first_plus_second - 1))\\n\\t\\t\\tif first + 1 == second:\\n\\t\\t\\t\\tans_earliest += count_trailing_zeroes(((n + (1 << (ans_earliest-1)) - 1) >> (ans_earliest-1)) - 1)\\n\\n\\t\\t# ceiling_of_log2 of n is the number of rounds left until there are exactly 2 players remaining, starting at n.\\n\\t\\t# This implicitly assumes that optimal strategy for ans_latest is moving \\'first\\' and \\'second\\' to pos. 1 and 2\\n\\t\\tans_latest = min(ceiling_of_log2(n), n + 1 - second)\\n\\n\\t\\treturn [ans_earliest, ans_latest]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269728,
                "title": "c-recursion-dfs-without-using-mask",
                "content": "**Inspired by [Votrubac\\'s solution ](https://leetcode.com/problems/the-earliest-and-latest-rounds-where-players-compete/discuss/1268539/Recursion)**\\n1.  We make a players string with all 1s\\n1. If a player looses we mark it as 0\\n1. We maintain l = left and r = right bounds \\n1. New round begins when l >= r means either 1 player remains or no player remains\\n\\n**Approach 1 (500ms)**\\n```\\nclass Solution {\\npublic:\\n    int f, s, n;\\n    int maxr = INT_MIN, minr = INT_MAX;\\n    vector<int> earliestAndLatest(int N, int F, int S) {\\n        f = F-1, s = S-1, n = N;\\n        string players = string(n, \\'1\\');\\n\\t\\tint round = 1, left = 0, right = n-1;\\n        help(players, left, right, round);\\n        return {minr, maxr};\\n    }\\n    \\n    //passing players by reference is crucial to avoid tle\\n    void help(string &players, int l, int r, int round){\\n        \\n        //round finished start next round\\n        if(l >= r){\\n            help(players, 0, n-1, round+1);\\n        }\\n        //left player is already eliminated continue with other players\\n        else if(players[l] == \\'0\\'){\\n            help(players, l+1, r, round);\\n        }\\n        //right player is already eliminated continue with other players\\n        else if(players[r] == \\'0\\'){\\n            help(players, l, r-1, round);\\n        }\\n        //we have found the place where first and second players come head to head\\n        else if((l == f and r == s) or (l == s and r == f)){\\n            minr = min(minr, round);\\n            maxr = max(maxr, round);\\n        }\\n        //the left player will win this match\\n        else if(l == f || l == s){\\n            //make the right player loose\\n            players[r] = \\'0\\';\\n            help(players, l+1, r-1, round);\\n            //reset for more exploration (more exploration happens when an earlier call was made from the last else block)\\n            players[r] = \\'1\\';\\n        }\\n        //the right player will win this match\\n        else if(r == f || r == s){\\n            //make the left player loose\\n            players[l] = \\'0\\';\\n            help(players, l+1, r-1, round);\\n            //reset for more exploration (more exploration happens when an earlier call was made from the last else block)\\n            players[l] = \\'1\\';\\n        }\\n        else{\\n            //both can win or loose, perform both scenarios\\n            players[r] = \\'0\\';\\n            help(players, l+1, r-1, round);\\n            players[r] = \\'1\\';\\n            players[l] = \\'0\\';\\n            help(players, l+1, r-1, round);\\n            players[l] = \\'1\\';\\n        }\\n    }\\n};\\n```\\n\\n**Approach 2 (extention of approach 1) (16ms)**\\n1. We memoize the state (players) of help function using a key.\\n1. key = ```NUMBER_OF_PLAYERS_BEFORE_FIRST_PLAYER + | + NUMBER_OF_PLAYERS_BETWEEN_FIRST_AND_SECOND_PLAYER + | + NUMBER_OF_PLAYERS_AFTER_SECOND_PLAYER```\\n1. All these are number of players still left means they have value = 1\\n1. This key is stored in visited.\\n```\\nclass Solution {\\npublic:\\n    int f, s, n;\\n    int maxr = INT_MIN, minr = INT_MAX;\\n    unordered_set<string> visited;\\n    \\n    vector<int> earliestAndLatest(int N, int F, int S) {\\n        f = F-1, s = S-1, n = N;\\n        string players = string(n, \\'1\\');\\n\\t\\tint round = 1, left = 0, right = n-1;\\n        help(players, left, right, round);\\n        return {minr, maxr};\\n    }\\n    \\n    //passing players by reference is crucial to avoid tle\\n    void help(string &players, int l, int r, int round){\\n        \\n        //round finished start next round\\n        if(l >= r){\\n            help(players, 0, n-1, round+1);\\n        }\\n        //left player is already eliminated continue with other players\\n        else if(players[l] == \\'0\\'){\\n            help(players, l+1, r, round);\\n        }\\n        //right player is already eliminated continue with other players\\n        else if(players[r] == \\'0\\'){\\n            help(players, l, r-1, round);\\n        }\\n        //we have found the place where first and second players come head to head\\n        else if((l == f and r == s) or (l == s and r == f)){\\n            minr = min(minr, round);\\n            maxr = max(maxr, round);\\n        }\\n        //the left player will win this match\\n        else if(l == f || l == s){\\n            //make the right player loose\\n            players[r] = \\'0\\';\\n            help(players, l+1, r-1, round);\\n            //reset for more exploration (more exploration happens when an earlier call was made from the last else block)\\n            players[r] = \\'1\\';\\n        }\\n        //the right player will win this match\\n        else if(r == f || r == s){\\n            //make the left player loose\\n            players[l] = \\'0\\';\\n            help(players, l+1, r-1, round);\\n            //reset for more exploration (more exploration happens when an earlier call was made from the last else block)\\n            players[l] = \\'1\\';\\n        }\\n        else if(visited.count(getPlayersBeforeBetweenAndAfterFAndS(players)) == 0){\\n            visited.insert(getPlayersBeforeBetweenAndAfterFAndS(players));\\n            \\n            //both can win or loose, perform both scenarios\\n            players[r] = \\'0\\';\\n            help(players, l+1, r-1, round);\\n            players[r] = \\'1\\';\\n            players[l] = \\'0\\';\\n            help(players, l+1, r-1, round);\\n            players[l] = \\'1\\';\\n        }\\n    }\\n    \\n    string getPlayersBeforeBetweenAndAfterFAndS(string &s1){\\n        int d1 = 0, d2 = 0, d3 = 0;\\n        for(int i = 0; i < s1.size(); i++){\\n            if(i < min(f, s) and s1[i] == \\'1\\'){\\n                d1++;\\n            }\\n            else if(min(f,s) < i and i < max(f,s) and s1[i] == \\'1\\'){\\n                d2++;\\n            }\\n            else if(i > max(f,s) and s1[i] == \\'1\\'){\\n                d3++;\\n            }\\n        }\\n        return to_string(d1) + \"|\" + to_string(d2) + \"|\" + to_string(d3) ;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f, s, n;\\n    int maxr = INT_MIN, minr = INT_MAX;\\n    vector<int> earliestAndLatest(int N, int F, int S) {\\n        f = F-1, s = S-1, n = N;\\n        string players = string(n, \\'1\\');\\n\\t\\tint round = 1, left = 0, right = n-1;\\n        help(players, left, right, round);\\n        return {minr, maxr};\\n    }\\n    \\n    //passing players by reference is crucial to avoid tle\\n    void help(string &players, int l, int r, int round){\\n        \\n        //round finished start next round\\n        if(l >= r){\\n            help(players, 0, n-1, round+1);\\n        }\\n        //left player is already eliminated continue with other players\\n        else if(players[l] == \\'0\\'){\\n            help(players, l+1, r, round);\\n        }\\n        //right player is already eliminated continue with other players\\n        else if(players[r] == \\'0\\'){\\n            help(players, l, r-1, round);\\n        }\\n        //we have found the place where first and second players come head to head\\n        else if((l == f and r == s) or (l == s and r == f)){\\n            minr = min(minr, round);\\n            maxr = max(maxr, round);\\n        }\\n        //the left player will win this match\\n        else if(l == f || l == s){\\n            //make the right player loose\\n            players[r] = \\'0\\';\\n            help(players, l+1, r-1, round);\\n            //reset for more exploration (more exploration happens when an earlier call was made from the last else block)\\n            players[r] = \\'1\\';\\n        }\\n        //the right player will win this match\\n        else if(r == f || r == s){\\n            //make the left player loose\\n            players[l] = \\'0\\';\\n            help(players, l+1, r-1, round);\\n            //reset for more exploration (more exploration happens when an earlier call was made from the last else block)\\n            players[l] = \\'1\\';\\n        }\\n        else{\\n            //both can win or loose, perform both scenarios\\n            players[r] = \\'0\\';\\n            help(players, l+1, r-1, round);\\n            players[r] = \\'1\\';\\n            players[l] = \\'0\\';\\n            help(players, l+1, r-1, round);\\n            players[l] = \\'1\\';\\n        }\\n    }\\n};\\n```\n```NUMBER_OF_PLAYERS_BEFORE_FIRST_PLAYER + | + NUMBER_OF_PLAYERS_BETWEEN_FIRST_AND_SECOND_PLAYER + | + NUMBER_OF_PLAYERS_AFTER_SECOND_PLAYER```\n```\\nclass Solution {\\npublic:\\n    int f, s, n;\\n    int maxr = INT_MIN, minr = INT_MAX;\\n    unordered_set<string> visited;\\n    \\n    vector<int> earliestAndLatest(int N, int F, int S) {\\n        f = F-1, s = S-1, n = N;\\n        string players = string(n, \\'1\\');\\n\\t\\tint round = 1, left = 0, right = n-1;\\n        help(players, left, right, round);\\n        return {minr, maxr};\\n    }\\n    \\n    //passing players by reference is crucial to avoid tle\\n    void help(string &players, int l, int r, int round){\\n        \\n        //round finished start next round\\n        if(l >= r){\\n            help(players, 0, n-1, round+1);\\n        }\\n        //left player is already eliminated continue with other players\\n        else if(players[l] == \\'0\\'){\\n            help(players, l+1, r, round);\\n        }\\n        //right player is already eliminated continue with other players\\n        else if(players[r] == \\'0\\'){\\n            help(players, l, r-1, round);\\n        }\\n        //we have found the place where first and second players come head to head\\n        else if((l == f and r == s) or (l == s and r == f)){\\n            minr = min(minr, round);\\n            maxr = max(maxr, round);\\n        }\\n        //the left player will win this match\\n        else if(l == f || l == s){\\n            //make the right player loose\\n            players[r] = \\'0\\';\\n            help(players, l+1, r-1, round);\\n            //reset for more exploration (more exploration happens when an earlier call was made from the last else block)\\n            players[r] = \\'1\\';\\n        }\\n        //the right player will win this match\\n        else if(r == f || r == s){\\n            //make the left player loose\\n            players[l] = \\'0\\';\\n            help(players, l+1, r-1, round);\\n            //reset for more exploration (more exploration happens when an earlier call was made from the last else block)\\n            players[l] = \\'1\\';\\n        }\\n        else if(visited.count(getPlayersBeforeBetweenAndAfterFAndS(players)) == 0){\\n            visited.insert(getPlayersBeforeBetweenAndAfterFAndS(players));\\n            \\n            //both can win or loose, perform both scenarios\\n            players[r] = \\'0\\';\\n            help(players, l+1, r-1, round);\\n            players[r] = \\'1\\';\\n            players[l] = \\'0\\';\\n            help(players, l+1, r-1, round);\\n            players[l] = \\'1\\';\\n        }\\n    }\\n    \\n    string getPlayersBeforeBetweenAndAfterFAndS(string &s1){\\n        int d1 = 0, d2 = 0, d3 = 0;\\n        for(int i = 0; i < s1.size(); i++){\\n            if(i < min(f, s) and s1[i] == \\'1\\'){\\n                d1++;\\n            }\\n            else if(min(f,s) < i and i < max(f,s) and s1[i] == \\'1\\'){\\n                d2++;\\n            }\\n            else if(i > max(f,s) and s1[i] == \\'1\\'){\\n                d3++;\\n            }\\n        }\\n        return to_string(d1) + \"|\" + to_string(d2) + \"|\" + to_string(d3) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270416,
                "title": "java-0ms-100-00-simple-recursion-for-all-new-positions-of-two-players",
                "content": "In current round of n players, these two players with 1-based indexes p1 and p2 will compete if (p1 + p2 == n + 1). Otherwise, the game will enter next round with (n+1)/2 players. Only the new positions (1-based indexes) of the two players matter in next round. We consider all possible such new positions based on their current positions and recursively get and merge into (min,max) as the final answer. \\n\\nDue to at most O(log(n)) rounds and the likelyhood p1 and p2 compete in earlier round, and the simplicity of the logic, the real runtime is 0ms and beats 100.00% Java submissions.\\n\\n```\\n  public int[] earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n    int p1 = Math.min(firstPlayer, secondPlayer);\\n    int p2 = Math.max(firstPlayer, secondPlayer);\\n    if (p1 + p2 == n + 1) {\\n      // p1 and p2 compete in the first round\\n      return new int[] {1,1};\\n    }\\n    if (n == 3 || n == 4) {\\n      // p1 and p2 must compete in the second round (only two rounds).\\n      return new int[] {2,2};\\n    }\\n\\n    // Flip to make p1 be more closer to left than p2 to right end for convenience\\n    if (p1 - 1 > n - p2) {\\n      int t = n + 1 - p1;\\n      p1 = n + 1 - p2;\\n      p2 = t;\\n    }\\n\\n    int m = (n + 1) / 2;\\n    int min = n;\\n    int max = 1;\\n    if (p2 * 2 <= n + 1) {\\n      // p2 is in first half (n odd or even) or exact middle (n odd)\\n      //   1  2  3  4  5  6  7  8  9 10 11 12 13 14\\n      //   .  .  *  .  .  *  .  .  .  .  .  .  .  .\\n      //         ^        ^\\n      //         p1       p2\\n\\t  // Group A are players in front of p1\\n\\t  // Group B are players between p1 and p2\\n      int a = p1 - 1;\\n      int b = p2 - p1 - 1;\\n      // i represents number of front players in A wins\\n      // j represents number of front players in B wins\\n      for (int i = 0; i <= a; i++) {\\n        for (int j = 0; j <= b; j++) {\\n          int[] ret = earliestAndLatest(m, i + 1, i + j + 2);\\n          min = Math.min(min, 1 + ret[0]);\\n          max = Math.max(max, 1 + ret[1]);\\n        }\\n      }\\n    } else {\\n      // p2 is in the later half (and has >= p1 distance to the end)\\n      //    1  2  3  4  5  6  7  8  9 10 11 12 13 14\\n      //    .  .  *  .  .  .  .  .  .  *  .  .  .  .\\n      //          ^                    ^\\n      //          p1   p4             p2    p3\\n      //                ^--------------^\\n      //          ^--------------------------^\\n      int p4 = n + 1 - p2;\\n      int a = p1 - 1;\\n      int b = p4 - p1 - 1;\\n\\t  // Group C are players between p4 and p2, (c+1)/2 will advance to next round.\\n      int c = p2 - p4 - 1;\\n      for (int i = 0; i <= a; i++) {\\n        for (int j = 0; j <= b; j++) {\\n          int[] ret = earliestAndLatest(m, i + 1, i + j + 1 + (c+1)/2 + 1);\\n          min = Math.min(min, 1 + ret[0]);\\n          max = Math.max(max, 1 + ret[1]);\\n        }\\n      }\\n    }\\n    return new int[] {min, max};\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  public int[] earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n    int p1 = Math.min(firstPlayer, secondPlayer);\\n    int p2 = Math.max(firstPlayer, secondPlayer);\\n    if (p1 + p2 == n + 1) {\\n      // p1 and p2 compete in the first round\\n      return new int[] {1,1};\\n    }\\n    if (n == 3 || n == 4) {\\n      // p1 and p2 must compete in the second round (only two rounds).\\n      return new int[] {2,2};\\n    }\\n\\n    // Flip to make p1 be more closer to left than p2 to right end for convenience\\n    if (p1 - 1 > n - p2) {\\n      int t = n + 1 - p1;\\n      p1 = n + 1 - p2;\\n      p2 = t;\\n    }\\n\\n    int m = (n + 1) / 2;\\n    int min = n;\\n    int max = 1;\\n    if (p2 * 2 <= n + 1) {\\n      // p2 is in first half (n odd or even) or exact middle (n odd)\\n      //   1  2  3  4  5  6  7  8  9 10 11 12 13 14\\n      //   .  .  *  .  .  *  .  .  .  .  .  .  .  .\\n      //         ^        ^\\n      //         p1       p2\\n\\t  // Group A are players in front of p1\\n\\t  // Group B are players between p1 and p2\\n      int a = p1 - 1;\\n      int b = p2 - p1 - 1;\\n      // i represents number of front players in A wins\\n      // j represents number of front players in B wins\\n      for (int i = 0; i <= a; i++) {\\n        for (int j = 0; j <= b; j++) {\\n          int[] ret = earliestAndLatest(m, i + 1, i + j + 2);\\n          min = Math.min(min, 1 + ret[0]);\\n          max = Math.max(max, 1 + ret[1]);\\n        }\\n      }\\n    } else {\\n      // p2 is in the later half (and has >= p1 distance to the end)\\n      //    1  2  3  4  5  6  7  8  9 10 11 12 13 14\\n      //    .  .  *  .  .  .  .  .  .  *  .  .  .  .\\n      //          ^                    ^\\n      //          p1   p4             p2    p3\\n      //                ^--------------^\\n      //          ^--------------------------^\\n      int p4 = n + 1 - p2;\\n      int a = p1 - 1;\\n      int b = p4 - p1 - 1;\\n\\t  // Group C are players between p4 and p2, (c+1)/2 will advance to next round.\\n      int c = p2 - p4 - 1;\\n      for (int i = 0; i <= a; i++) {\\n        for (int j = 0; j <= b; j++) {\\n          int[] ret = earliestAndLatest(m, i + 1, i + j + 1 + (c+1)/2 + 1);\\n          min = Math.min(min, 1 + ret[0]);\\n          max = Math.max(max, 1 + ret[1]);\\n        }\\n      }\\n    }\\n    return new int[] {min, max};\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1268788,
                "title": "python3-bit-mask-dp",
                "content": "\\n```\\nclass Solution:\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        firstPlayer, secondPlayer = firstPlayer-1, secondPlayer-1 # 0-indexed\\n        \\n        @cache\\n        def fn(k, mask): \\n            \"\"\"Return earliest and latest rounds.\"\"\"\\n            can = deque()\\n            for i in range(n): \\n                if mask & (1 << i): can.append(i)\\n                    \\n            cand = [] # eliminated player\\n            while len(can) > 1: \\n                p1, p2 = can.popleft(), can.pop()\\n                if p1 == firstPlayer and p2 == secondPlayer or p1 == secondPlayer and p2 == firstPlayer: return [k, k] # game of interest \\n                if p1 in (firstPlayer, secondPlayer): cand.append([p2]) # p2 eliminated \\n                elif p2 in (firstPlayer, secondPlayer): cand.append([p1]) # p1 eliminated \\n                else: cand.append([p1, p2]) # both could be elimited \\n            \\n            minn, maxx = inf, -inf\\n            for x in product(*cand): \\n                mask0 = mask\\n                for i in x: mask0 ^= 1 << i\\n                mn, mx = fn(k+1, mask0)\\n                minn = min(minn, mn)\\n                maxx = max(maxx, mx)\\n            return minn, maxx\\n        \\n        return fn(1, (1<<n)-1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        firstPlayer, secondPlayer = firstPlayer-1, secondPlayer-1 # 0-indexed\\n        \\n        @cache\\n        def fn(k, mask): \\n            \"\"\"Return earliest and latest rounds.\"\"\"\\n            can = deque()\\n            for i in range(n): \\n                if mask & (1 << i): can.append(i)\\n                    \\n            cand = [] # eliminated player\\n            while len(can) > 1: \\n                p1, p2 = can.popleft(), can.pop()\\n                if p1 == firstPlayer and p2 == secondPlayer or p1 == secondPlayer and p2 == firstPlayer: return [k, k] # game of interest \\n                if p1 in (firstPlayer, secondPlayer): cand.append([p2]) # p2 eliminated \\n                elif p2 in (firstPlayer, secondPlayer): cand.append([p1]) # p1 eliminated \\n                else: cand.append([p1, p2]) # both could be elimited \\n            \\n            minn, maxx = inf, -inf\\n            for x in product(*cand): \\n                mask0 = mask\\n                for i in x: mask0 ^= 1 << i\\n                mn, mx = fn(k+1, mask0)\\n                minn = min(minn, mn)\\n                maxx = max(maxx, mx)\\n            return minn, maxx\\n        \\n        return fn(1, (1<<n)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268786,
                "title": "python-simple-dp-memo",
                "content": "there are 4 situations:\\n1.     [                    mid                  ]\\n1.       a       b \\n2.                                      a     b\\n3.       a                         b\\n4.                    a                       b\\n\\nAccording to the principle of symmetry, we can reduce them to these two situations:\\n1.     [                    mid                  ]\\n2.       a       b \\n3.       a                           b\\n\\nThere for we just need to translate firstPlayer and secondPlayer to these two situations and do operations on them.\\n\\nEach round, we try to reduce n players into ceil(n/2) players.\\n\\nFor the first situation, for players before A, No matter how these players are combined, their impact on the entire formation depends only on how many players win on the left and how many players win on the right. For the players who win on the right, we will decrease the indexes of A and B at the same time. There are (n-1) possibilities. In each possibility, we perform the same operation on the players between A and B, and correspondingly decrease the index of b (because the operation is performed on the players between A and B, the index of player A would not be changed.)\\n```\\nfor i in range(a):\\n\\tfor j in range(b-a):\\n\\t\\tl = min(l,self.earliestAndLatest(mid,a-i,b-i-j)[0])\\n\\t\\tr = max(r,self.earliestAndLatest(mid,a-i,b-i-j)[1])  \\n```\\nFor the second situation, the index of B is greater than the index of mid. If all battles are won by the left player, then B\\'s position in the next round should be the last of array. Based on this point, we can perform the same operation on them, and we can get the following code.\\n```\\nfor i in range(a):\\n\\tfor j in range(c-a):\\n\\t\\tl = min(l,self.earliestAndLatest(mid,a-i,mid-i-j)[0])\\n\\t\\tr = max(r,self.earliestAndLatest(mid,a-i,mid-i-j)[1])\\n```\\n\\nEnumerate and select the smallest earlier round and the largest latest round to get the answer we want.\\nTC: \\nFor earliestAndLatest( n, firstPlayer, secondPlayer): O(log n*n^2)\\nThe loop in function takes O(n^2)\\n=> O(n^4 logn)\\nSC:\\n=> O(n^2 logn)\\n\\n\\n```\\nclass Solution:\\n    @lru_cache(None)\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        if firstPlayer + secondPlayer == n + 1:\\n            return [1,1]\\n        a,b = min(firstPlayer, secondPlayer), max(firstPlayer, secondPlayer)\\n        mid = ceil(n/2)\\n        l = inf\\n        r = -inf\\n        if b<=mid or a>mid:\\n            if a>mid:\\n                a,b = n+1-b,n+1-a\\n            for i in range(a):\\n                for j in range(b-a):\\n                    l = min(l,self.earliestAndLatest(mid,a-i,b-i-j)[0])\\n                    r = max(r,self.earliestAndLatest(mid,a-i,b-i-j)[1])  \\n        else:\\n            if n+1-b < a:\\n                a,b = n+1-b,n+1-a\\n            c = n+1-b\\n            for i in range(a):\\n                for j in range(c-a):\\n                    l = min(l,self.earliestAndLatest(mid,a-i,mid-i-j)[0])\\n                    r = max(r,self.earliestAndLatest(mid,a-i,mid-i-j)[1])\\n        return [l+1,r+1]\\n```",
                "solutionTags": [],
                "code": "```\\nfor i in range(a):\\n\\tfor j in range(b-a):\\n\\t\\tl = min(l,self.earliestAndLatest(mid,a-i,b-i-j)[0])\\n\\t\\tr = max(r,self.earliestAndLatest(mid,a-i,b-i-j)[1])  \\n```\n```\\nfor i in range(a):\\n\\tfor j in range(c-a):\\n\\t\\tl = min(l,self.earliestAndLatest(mid,a-i,mid-i-j)[0])\\n\\t\\tr = max(r,self.earliestAndLatest(mid,a-i,mid-i-j)[1])\\n```\n```\\nclass Solution:\\n    @lru_cache(None)\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        if firstPlayer + secondPlayer == n + 1:\\n            return [1,1]\\n        a,b = min(firstPlayer, secondPlayer), max(firstPlayer, secondPlayer)\\n        mid = ceil(n/2)\\n        l = inf\\n        r = -inf\\n        if b<=mid or a>mid:\\n            if a>mid:\\n                a,b = n+1-b,n+1-a\\n            for i in range(a):\\n                for j in range(b-a):\\n                    l = min(l,self.earliestAndLatest(mid,a-i,b-i-j)[0])\\n                    r = max(r,self.earliestAndLatest(mid,a-i,b-i-j)[1])  \\n        else:\\n            if n+1-b < a:\\n                a,b = n+1-b,n+1-a\\n            c = n+1-b\\n            for i in range(a):\\n                for j in range(c-a):\\n                    l = min(l,self.earliestAndLatest(mid,a-i,mid-i-j)[0])\\n                    r = max(r,self.earliestAndLatest(mid,a-i,mid-i-j)[1])\\n        return [l+1,r+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268586,
                "title": "java-dp-with-memory",
                "content": "* Use DP with memory\\n* Divide players to 3 parts because of the first and second players\\n  * xFySz, left has x players, middle has y players, right has z players\\n```\\nclass Solution {\\n    int[][][][] dp = new int[28][28][28][2];\\n    public int[] earliestAndLatest(int n, int f, int s) {\\n        return helper(f-1, s-f-1, n-s);\\n    }\\n    \\n    int[] helper(int x, int y, int z) {\\n        if (x == z)\\n            return new int[]{1, 1};\\n        if (x > z) // Make sure z > x\\n            return helper(z, y, x);\\n        if (dp[x][y][z][0] > 0)\\n            return dp[x][y][z];\\n        int a = x, b = y, c = z;\\n        c--; // Remove because of the First Player\\n        if (a+b < c) // Remove because of the Second Player\\n            c--;\\n        else if (a+b > c)\\n            b--;\\n        dp[x][y][z][0] = 100;\\n        int n = (a+b+c)/2; // Players to remove\\n        for (int i = 0; i <= a; i++)\\n            for (int j = a-i; j <= c-i; j++) {\\n                int k = a+b+c-n-i-j;\\n                if (k >= 0 && k <= b) {\\n                    int[] tmp = helper(i, k, j);\\n                    dp[x][y][z][0] = Math.min(dp[x][y][z][0], tmp[0] + 1);\\n                    dp[x][y][z][1] = Math.max(dp[x][y][z][1], tmp[1] + 1);\\n                }\\n            }\\n        return dp[x][y][z];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][][][] dp = new int[28][28][28][2];\\n    public int[] earliestAndLatest(int n, int f, int s) {\\n        return helper(f-1, s-f-1, n-s);\\n    }\\n    \\n    int[] helper(int x, int y, int z) {\\n        if (x == z)\\n            return new int[]{1, 1};\\n        if (x > z) // Make sure z > x\\n            return helper(z, y, x);\\n        if (dp[x][y][z][0] > 0)\\n            return dp[x][y][z];\\n        int a = x, b = y, c = z;\\n        c--; // Remove because of the First Player\\n        if (a+b < c) // Remove because of the Second Player\\n            c--;\\n        else if (a+b > c)\\n            b--;\\n        dp[x][y][z][0] = 100;\\n        int n = (a+b+c)/2; // Players to remove\\n        for (int i = 0; i <= a; i++)\\n            for (int j = a-i; j <= c-i; j++) {\\n                int k = a+b+c-n-i-j;\\n                if (k >= 0 && k <= b) {\\n                    int[] tmp = helper(i, k, j);\\n                    dp[x][y][z][0] = Math.min(dp[x][y][z][0], tmp[0] + 1);\\n                    dp[x][y][z][1] = Math.max(dp[x][y][z][1], tmp[1] + 1);\\n                }\\n            }\\n        return dp[x][y][z];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268880,
                "title": "javascript-dfs-bitwise",
                "content": "```javascript\\n var earliestAndLatest = function(numPlayers, firstPlayer, secondPlayer) {\\n    let minRounds = Infinity;\\n    let maxRounds = 0;\\n    const dfs = (playersEliminated, numRounds) => {\\n        \\n        // find all the combinations for this round starting with the\\n        // current players that are eliminated.  We will move the 2 pointers\\n        // from opposite ends inwards until we find players that aren\\'t eliminated\\n        // and then create new possible results of this current round.\\n        // Every loop in the while loop will correspond to a competition between player\\n        // i and j while roundResults will hold all possible round results.\\n        let roundResults = [playersEliminated];\\n        let i = 1;\\n        let j = numPlayers;\\n        while (true) {\\n            // find players that aren\\'t eliminated\\n            while (playersEliminated & (1 << i)) i++;\\n            while (playersEliminated & (1 << j)) j--;\\n            // if we are at or past the same player, we can stop\\n            if (i >= j) break;\\n            // if during this round the first and second player are playing\\n            // against each other, we can record the results and stop searching.\\n            if (i === firstPlayer && j === secondPlayer) {\\n                minRounds = Math.min(minRounds, numRounds);\\n                maxRounds = Math.max(maxRounds, numRounds);\\n                return;\\n            } \\n            \\n            // create new round results by eliminating player as long as it isn\\'t\\n            // the first or second player.\\n            // roundResult | (1 << i)  means we eliminated player i (player i lost)\\n            const newRoundResults = [];\\n            if (j !== firstPlayer && j !== secondPlayer) {\\n                for (const roundResult of roundResults) {\\n                    newRoundResults.push(roundResult | (1 << j));\\n                }\\n            } \\n            if (i !== firstPlayer && i !== secondPlayer){\\n                for (const roundResult of roundResults) {\\n                    newRoundResults.push(roundResult | (1 << i));\\n                }\\n            }\\n            // move the pointers inwards to find next matching players\\n            i++;\\n            j--;\\n            // save the new round results to round results\\n            roundResults = newRoundResults;\\n        }\\n        \\n        // if we have exhausted all round results return as the base case\\n        if (!roundResults.length) return;\\n        \\n        // add a round for the next round and try each result to see if it will\\n        // update the max and min number of rounds\\n        numRounds++;\\n        roundResults.forEach((roundResult) => dfs(roundResult, numRounds));\\n    }\\n    dfs(0,1)\\n    return [minRounds, maxRounds];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation",
                    "Depth-First Search"
                ],
                "code": "```javascript\\n var earliestAndLatest = function(numPlayers, firstPlayer, secondPlayer) {\\n    let minRounds = Infinity;\\n    let maxRounds = 0;\\n    const dfs = (playersEliminated, numRounds) => {\\n        \\n        // find all the combinations for this round starting with the\\n        // current players that are eliminated.  We will move the 2 pointers\\n        // from opposite ends inwards until we find players that aren\\'t eliminated\\n        // and then create new possible results of this current round.\\n        // Every loop in the while loop will correspond to a competition between player\\n        // i and j while roundResults will hold all possible round results.\\n        let roundResults = [playersEliminated];\\n        let i = 1;\\n        let j = numPlayers;\\n        while (true) {\\n            // find players that aren\\'t eliminated\\n            while (playersEliminated & (1 << i)) i++;\\n            while (playersEliminated & (1 << j)) j--;\\n            // if we are at or past the same player, we can stop\\n            if (i >= j) break;\\n            // if during this round the first and second player are playing\\n            // against each other, we can record the results and stop searching.\\n            if (i === firstPlayer && j === secondPlayer) {\\n                minRounds = Math.min(minRounds, numRounds);\\n                maxRounds = Math.max(maxRounds, numRounds);\\n                return;\\n            } \\n            \\n            // create new round results by eliminating player as long as it isn\\'t\\n            // the first or second player.\\n            // roundResult | (1 << i)  means we eliminated player i (player i lost)\\n            const newRoundResults = [];\\n            if (j !== firstPlayer && j !== secondPlayer) {\\n                for (const roundResult of roundResults) {\\n                    newRoundResults.push(roundResult | (1 << j));\\n                }\\n            } \\n            if (i !== firstPlayer && i !== secondPlayer){\\n                for (const roundResult of roundResults) {\\n                    newRoundResults.push(roundResult | (1 << i));\\n                }\\n            }\\n            // move the pointers inwards to find next matching players\\n            i++;\\n            j--;\\n            // save the new round results to round results\\n            roundResults = newRoundResults;\\n        }\\n        \\n        // if we have exhausted all round results return as the base case\\n        if (!roundResults.length) return;\\n        \\n        // add a round for the next round and try each result to see if it will\\n        // update the max and min number of rounds\\n        numRounds++;\\n        roundResults.forEach((roundResult) => dfs(roundResult, numRounds));\\n    }\\n    dfs(0,1)\\n    return [minRounds, maxRounds];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1268610,
                "title": "java-straightforward-dfs-solution-simulation",
                "content": "\\tint first;\\n    int second;\\n    public int[] earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n        first = firstPlayer;\\n        second = secondPlayer;\\n        List<Integer> list = new ArrayList<>();\\n        for (int i = 1; i <= n; i++) {\\n            list.add(i);\\n        }\\n        int[] res = new int[2];\\n        res[0] = n;\\n        res[1] = 0;\\n        dfs(list, new ArrayList<>(), 1, n, res, 0);\\n        return res;\\n    }\\n    \\n    void dfs(List<Integer> list, List<Integer> temp, int round, int n, int[] res, int i) {\\n        \\n        if (i > n - 1- i) {\\n            List<Integer> next = new ArrayList<>(temp);\\n            Collections.sort(next);\\n            dfs(next, new ArrayList<>(), round + 1, next.size(), res, 0);\\n            return;\\n        }\\n        \\n        if (list.get(i) == first && list.get(n-1-i) == second) {\\n            res[0] = Math.min(res[0], round);\\n            res[1] = Math.max(res[1], round);\\n            return;\\n        }\\n        \\n        if (list.get(i) == first || list.get(i) == second) {\\n            temp.add(list.get(i));\\n            dfs(list, temp, round, n, res, i+1);\\n            temp.remove(temp.size() - 1);\\n        } else if (list.get(n-1-i) == second || list.get(n-1-i) == first) {\\n            temp.add(list.get(n-1-i));\\n            dfs(list, temp, round, n, res, i+1);\\n            temp.remove(temp.size() - 1);\\n        } else {\\n            temp.add(list.get(i));\\n            dfs(list, temp, round, n, res, i+1);\\n            temp.remove(temp.size() - 1);\\n\\n            temp.add(list.get(n-1-i));\\n            dfs(list, temp, round, n, res, i+1);\\n            temp.remove(temp.size() - 1);\\n        }\\n        \\n    }",
                "solutionTags": [],
                "code": "\\tint first;\\n    int second;\\n    public int[] earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n        first = firstPlayer;\\n        second = secondPlayer;\\n        List<Integer> list = new ArrayList<>();\\n        for (int i = 1; i <= n; i++) {\\n            list.add(i);\\n        }\\n        int[] res = new int[2];\\n        res[0] = n;\\n        res[1] = 0;\\n        dfs(list, new ArrayList<>(), 1, n, res, 0);\\n        return res;\\n    }\\n    \\n    void dfs(List<Integer> list, List<Integer> temp, int round, int n, int[] res, int i) {\\n        \\n        if (i > n - 1- i) {\\n            List<Integer> next = new ArrayList<>(temp);\\n            Collections.sort(next);\\n            dfs(next, new ArrayList<>(), round + 1, next.size(), res, 0);\\n            return;\\n        }\\n        \\n        if (list.get(i) == first && list.get(n-1-i) == second) {\\n            res[0] = Math.min(res[0], round);\\n            res[1] = Math.max(res[1], round);\\n            return;\\n        }\\n        \\n        if (list.get(i) == first || list.get(i) == second) {\\n            temp.add(list.get(i));\\n            dfs(list, temp, round, n, res, i+1);\\n            temp.remove(temp.size() - 1);\\n        } else if (list.get(n-1-i) == second || list.get(n-1-i) == first) {\\n            temp.add(list.get(n-1-i));\\n            dfs(list, temp, round, n, res, i+1);\\n            temp.remove(temp.size() - 1);\\n        } else {\\n            temp.add(list.get(i));\\n            dfs(list, temp, round, n, res, i+1);\\n            temp.remove(temp.size() - 1);\\n\\n            temp.add(list.get(n-1-i));\\n            dfs(list, temp, round, n, res, i+1);\\n            temp.remove(temp.size() - 1);\\n        }\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1268639,
                "title": "dfs-memoization-explanation",
                "content": "1) the only importent thing to remember is the position of first and second player. \\n2) if the positions are same than the actual content of array is not importent and can be avoided in recursion.\\n3) there will be n*(n-1)/2 pairs of first and second players positions and for each pair recursive fuction will take 2^(n/2) time. Hence the time complexity.  \\n\\nTime Complexity : **( n ^ 2 * ( 2 ^ (n/2) ) )**\\nMemory Complexity : **n ^ 2**\\n\\n\\n\\'\\'\\'\\n\\n\\tint mn=1e9,mx=-1;\\n\\tset<array<int,3>> st; \\n\\tvoid recur(int n,int fp, int sp,int cnt){\\n\\n\\t\\tif(st.find({n,fp,sp})!=st.end()){ //if the state is already processed \\n\\t\\t\\treturn ;\\n\\t\\t}\\n\\t\\tst.insert({n,fp,sp});\\n\\n\\t\\tif(sp==n-1-fp){ // if first and second are against each other in this round \\n\\t\\t\\tmn=min(mn,cnt);\\n\\t\\t\\tmx=max(mx,cnt);\\n\\t\\t\\treturn ;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor(int mask=0; mask<(1<<(n/2)); mask++){\\n\\t\\t\\tint nfp=fp,nsp=sp; // new positions. \\n\\t\\t\\tfor(int i=0;i<(n/2);i++){\\n\\t\\t\\t\\tint j=i;\\n\\t\\t\\t\\tif(mask&(1<<i)){\\n\\t\\t\\t\\t\\tj=n-1-i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// handling the case that first and second \\n\\t\\t\\t\\t// always win before competing each other .\\n\\t\\t\\t\\tif(j==fp)\\n\\t\\t\\t\\t\\tj=n-1-j;\\n\\t\\t\\t\\tif(j==sp)\\n\\t\\t\\t\\t\\tj=n-1-j;\\n\\n\\t\\t\\t\\t// finding the new index of first and second player .\\n\\t\\t\\t\\t// decrease the index if removed element was before it. \\n\\t\\t\\t\\tif(j<fp )\\n\\t\\t\\t\\t\\tnfp-=1;\\n\\t\\t\\t\\tif(j<sp )\\n\\t\\t\\t\\t\\tnsp-=1;\\n\\t\\t\\t}\\n\\t\\t\\t// recursive step \\n\\t\\t\\trecur(n/2+n%2, nfp,nsp,cnt+1);\\n\\t\\t}\\n\\t}\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> earliestAndLatest(int n, int fp, int sp) {        \\n\\t\\t\\tmn=1e9,mx=-1;\\n\\t\\t\\tst.clear(); \\n\\t\\t\\tfp-=1;\\n\\t\\t\\tsp-=1;\\n\\t\\t\\trecur(n,fp,sp,0);\\n\\t\\t\\treturn {mn+1,mx+1};\\n\\t\\t}\\n\\t};\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> earliestAndLatest(int n, int fp, int sp) {        \\n\\t\\t\\tmn=1e9,mx=-1;\\n\\t\\t\\tst.clear(); \\n\\t\\t\\tfp-=1;\\n\\t\\t\\tsp-=1;\\n\\t\\t\\trecur(n,fp,sp,0);\\n\\t\\t\\treturn {mn+1,mx+1}",
                "codeTag": "Java"
            },
            {
                "id": 1269456,
                "title": "o-n-3-c-solution-200ms-for-n-900-hard-to-understand",
                "content": "```\\n#define N 28\\nstatic array<array<array<bool, N>, N>, N+1> mem;\\nclass Solution {\\n    int mn, mx;\\n    void dfs(int n, int p1, int p2, int d) {\\n        if (n == 1 || mem[n][p1][p2])\\n            return;\\n        mem[n][p1][p2] = true;\\n        int q1 = n - p1 - 1, q2 = n - p2 - 1;\\n        if (p1 == q2) {\\n            mn = min(mn, d);\\n            mx = max(mx, d);\\n            return;\\n        }\\n        int m = n + 1 >> 1;\\n        for (int i = max(0, p1 - q1 >> 1);\\n             i <= p1 - (q1 < p1) - (q2 < p1) - max(0, p1 - q1 - 1 >> 1);\\n             i++)\\n            for (int j = max(0, min(q1, p2) - max(q2, p1) >> 1);\\n                 j <= p2 - p1 - 1 - (q1 > p1 && q1 < p2) - (q2 > p1 && q2 < p2) - max(0, min(q1, p2) - max(q2, p1) - 1 >> 1);\\n                 j++)\\n                if (m - i - j - 2 >= max(0, q2 - p2 >> 1)\\n                    && m - i - j - 2 <= q2 - (q1 > p2) - (q2 > p2) - max(0, q2 - p2 - 1 >> 1))\\n                    dfs(m, i, i + j + 1, d + 1);\\n    }\\npublic:\\n    vector<int> earliestAndLatest(int n, int first, int second) {\\n        mn = n, mx = 0, mem = {};\\n        dfs(n, first - 1, second - 1, 1);\\n        return {mn, mx};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n#define N 28\\nstatic array<array<array<bool, N>, N>, N+1> mem;\\nclass Solution {\\n    int mn, mx;\\n    void dfs(int n, int p1, int p2, int d) {\\n        if (n == 1 || mem[n][p1][p2])\\n            return;\\n        mem[n][p1][p2] = true;\\n        int q1 = n - p1 - 1, q2 = n - p2 - 1;\\n        if (p1 == q2) {\\n            mn = min(mn, d);\\n            mx = max(mx, d);\\n            return;\\n        }\\n        int m = n + 1 >> 1;\\n        for (int i = max(0, p1 - q1 >> 1);\\n             i <= p1 - (q1 < p1) - (q2 < p1) - max(0, p1 - q1 - 1 >> 1);\\n             i++)\\n            for (int j = max(0, min(q1, p2) - max(q2, p1) >> 1);\\n                 j <= p2 - p1 - 1 - (q1 > p1 && q1 < p2) - (q2 > p1 && q2 < p2) - max(0, min(q1, p2) - max(q2, p1) - 1 >> 1);\\n                 j++)\\n                if (m - i - j - 2 >= max(0, q2 - p2 >> 1)\\n                    && m - i - j - 2 <= q2 - (q1 > p2) - (q2 > p2) - max(0, q2 - p2 - 1 >> 1))\\n                    dfs(m, i, i + j + 1, d + 1);\\n    }\\npublic:\\n    vector<int> earliestAndLatest(int n, int first, int second) {\\n        mn = n, mx = 0, mem = {};\\n        dfs(n, first - 1, second - 1, 1);\\n        return {mn, mx};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268609,
                "title": "python-bfs-easy-to-understand",
                "content": "Using a deque to carry the (array , #round)\\n\\nin the *array*, the struct will looks like [[1,5],[2],[4]] the sub_arr with two elements means two player have equal chance to next round, one elements means that player will go to next round because he/she is the mid of the previous array or he/she is 1st/2nd player.\\nand allcombine in my code is designed to get all pair result form previous round, using backtrack. \\n\\'\\'\\'\\n   \\n    class Solution:\\n\\t  def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n         def allcombin(pair):#try to find all combinations for the next round \\n            def bt(path,ind): #backtrack similar like LC17\\n                if ind == len(pair):\\n                    ans.append(path)\\n                    return \\n                for ele in pair[ind]:\\n                    bt(path+[ele],ind+1)\\n            ans = []\\n            bt([],0)            \\n            return ans\\n\\t\\t\\t\\n        seen = set()  #To avoid duplicate combinations\\n        res = []\\n        q = deque()\\n        start = [i for i in range(1,n+1)]\\n        q.append((start,0))\\n        while q:\\n            arr,rd = q.popleft()\\n            pair = []\\n            flg = True # to check if 1st and 2nd meet\\n            for i in range(len(arr)//2):\\n                x,y = arr[i],arr[len(arr)-1-i]\\n                if (x,y) == (firstPlayer,secondPlayer):\\n\\t\\t\\t\\t\\t#if x,y matched 1st/2nd, put  this round to res, and return\\n                    res.append(rd+1)\\n                    flg =  False\\n                    break\\n                elif x in (firstPlayer,secondPlayer):\\n\\t\\t\\t\\t\\t# x win, so in next round only one player in the pair\\n                    pair.append([x])\\n                elif y in (firstPlayer,secondPlayer):\\n                    pair.append([y])\\n                else:\\n\\t\\t\\t\\t\\t# put two players to next round with two elements \\n                    pair.append([x,y])\\n            if len(arr)%2 ==1:\\n                pair.append([arr[len(arr)//2]])\\n            if flg: # if 1st/2nd does not in one pair, continue\\n                for newarr in allcombin(pair):\\n                    sornew = sorted(newarr)\\n                    if len(newarr) > 1 and tuple(sornew) not in seen:\\n                        seen.add(tuple(sornew))\\n                        q.append((sorted(newarr),rd+1))\\n        return [min(res),max(res)]\\n  \\'\\'\\'             \\n                    \\n                    \\n            \\n        \\n        \\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "Using a deque to carry the (array , #round)\\n\\nin the *array*, the struct will looks like [[1,5],[2],[4]] the sub_arr with two elements means two player have equal chance to next round, one elements means that player will go to next round because he/she is the mid of the previous array or he/she is 1st/2nd player.\\nand allcombine in my code is designed to get all pair result form previous round, using backtrack. \\n\\'\\'\\'\\n   \\n    class Solution:\\n\\t  def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n         def allcombin(pair):#try to find all combinations for the next round \\n            def bt(path,ind): #backtrack similar like LC17\\n                if ind == len(pair):\\n                    ans.append(path)\\n                    return \\n                for ele in pair[ind]:\\n                    bt(path+[ele],ind+1)\\n            ans = []\\n            bt([],0)            \\n            return ans\\n\\t\\t\\t\\n        seen = set()  #To avoid duplicate combinations\\n        res = []\\n        q = deque()\\n        start = [i for i in range(1,n+1)]\\n        q.append((start,0))\\n        while q:\\n            arr,rd = q.popleft()\\n            pair = []\\n            flg = True # to check if 1st and 2nd meet\\n            for i in range(len(arr)//2):\\n                x,y = arr[i],arr[len(arr)-1-i]\\n                if (x,y) == (firstPlayer,secondPlayer):\\n\\t\\t\\t\\t\\t#if x,y matched 1st/2nd, put  this round to res, and return\\n                    res.append(rd+1)\\n                    flg =  False\\n                    break\\n                elif x in (firstPlayer,secondPlayer):\\n\\t\\t\\t\\t\\t# x win, so in next round only one player in the pair\\n                    pair.append([x])\\n                elif y in (firstPlayer,secondPlayer):\\n                    pair.append([y])\\n                else:\\n\\t\\t\\t\\t\\t# put two players to next round with two elements \\n                    pair.append([x,y])\\n            if len(arr)%2 ==1:\\n                pair.append([arr[len(arr)//2]])\\n            if flg: # if 1st/2nd does not in one pair, continue\\n                for newarr in allcombin(pair):\\n                    sornew = sorted(newarr)\\n                    if len(newarr) > 1 and tuple(sornew) not in seen:\\n                        seen.add(tuple(sornew))\\n                        q.append((sorted(newarr),rd+1))\\n        return [min(res),max(res)]\\n  \\'\\'\\'             \\n                    \\n                    \\n            \\n        \\n        \\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1268578,
                "title": "c-brute-force-with-memoization-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void f(string str, int depth, int& small, int& big, unordered_set<string>& dp) {\\n        //cout<<str<<endl; \\n        const int n = str.size();\\n        for(int i = 0;i<n/2;i++) {\\n            if(str[i] == \\'1\\' && str[str.size()-1-i] == \\'1\\') {\\n                small = min(small,depth);\\n                big = max(big,depth);\\n                return;\\n            }\\n        }\\n        if(dp.count(str)) {\\n            return; \\n        }\\n        const int total = (1<<(n/2)) - 1; \\n        for(int i = 0;i<=total;i++) {\\n            string a;\\n            string b; \\n            bool valid = true; \\n            for(int j = 0;j<n/2;j++) {\\n                // 1 left win \\n                // 0 right win\\n                if(i&(1<<j) && str[str.size()-j-1] == \\'1\\') {\\n                    valid = false; \\n                    break;\\n                } \\n                if(!(i&(1<<j)) && str[j] == \\'1\\') {\\n                    valid = false; \\n                    break; \\n                }\\n                if(i&(1<<j)) {\\n                    a.push_back(str[j]);\\n                } else {\\n                    b.push_back(str[str.size()-j-1]);\\n                }\\n            }\\n            if(!valid) {\\n                continue; \\n            }\\n            string tmp; \\n            reverse(b.begin(),b.end());\\n            if(str.size() % 2 == 1) {\\n                tmp = a + string(1,str[str.size()/2]) + b; \\n            } else {\\n                tmp = a + b; \\n            }\\n            f(tmp,depth+1,small,big,dp);\\n        }\\n        dp.insert(str);\\n    }\\n    vector<int> earliestAndLatest(int n, int fp, int sp) {\\n        string str; \\n        for(int i = 1;i<=n;i++) {\\n            if(i == fp || i == sp) {\\n                str.push_back(\\'1\\');\\n            } else {\\n                str.push_back(\\'0\\');\\n            }\\n        }\\n        unordered_set<string> dp; \\n        //cout<<str<<endl;\\n        int big = 0; \\n        int small = INT_MAX; \\n        f(str,1,small,big,dp);\\n        return {small,big};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void f(string str, int depth, int& small, int& big, unordered_set<string>& dp) {\\n        //cout<<str<<endl; \\n        const int n = str.size();\\n        for(int i = 0;i<n/2;i++) {\\n            if(str[i] == \\'1\\' && str[str.size()-1-i] == \\'1\\') {\\n                small = min(small,depth);\\n                big = max(big,depth);\\n                return;\\n            }\\n        }\\n        if(dp.count(str)) {\\n            return; \\n        }\\n        const int total = (1<<(n/2)) - 1; \\n        for(int i = 0;i<=total;i++) {\\n            string a;\\n            string b; \\n            bool valid = true; \\n            for(int j = 0;j<n/2;j++) {\\n                // 1 left win \\n                // 0 right win\\n                if(i&(1<<j) && str[str.size()-j-1] == \\'1\\') {\\n                    valid = false; \\n                    break;\\n                } \\n                if(!(i&(1<<j)) && str[j] == \\'1\\') {\\n                    valid = false; \\n                    break; \\n                }\\n                if(i&(1<<j)) {\\n                    a.push_back(str[j]);\\n                } else {\\n                    b.push_back(str[str.size()-j-1]);\\n                }\\n            }\\n            if(!valid) {\\n                continue; \\n            }\\n            string tmp; \\n            reverse(b.begin(),b.end());\\n            if(str.size() % 2 == 1) {\\n                tmp = a + string(1,str[str.size()/2]) + b; \\n            } else {\\n                tmp = a + b; \\n            }\\n            f(tmp,depth+1,small,big,dp);\\n        }\\n        dp.insert(str);\\n    }\\n    vector<int> earliestAndLatest(int n, int fp, int sp) {\\n        string str; \\n        for(int i = 1;i<=n;i++) {\\n            if(i == fp || i == sp) {\\n                str.push_back(\\'1\\');\\n            } else {\\n                str.push_back(\\'0\\');\\n            }\\n        }\\n        unordered_set<string> dp; \\n        //cout<<str<<endl;\\n        int big = 0; \\n        int small = INT_MAX; \\n        f(str,1,small,big,dp);\\n        return {small,big};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3017247,
                "title": "python-intuitive-solution-simulate-rounds-using-dfs-string-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        minR,maxR=999999,-122\\n        players=\\'\\'\\n        for i in range(1,n+1):\\n            players+=chr(i+65)\\n        fp=chr(firstPlayer+65)\\n        sp=chr(secondPlayer+65)\\n\\n        @cache\\n        def dfs(s,num_round,winners):\\n            nonlocal maxR, minR\\n            if len(s)==0:\\n                dfs(\"\".join(sorted(winners)),num_round+1,\\'\\')\\n                return\\n            if len(s)==1:\\n                winners+=s[0]\\n                dfs(\"\".join(sorted(winners)),num_round+1,\\'\\')\\n                return\\n            if s[0]==fp and s[-1]==sp:\\n                \\n                maxR=max(maxR,num_round)\\n                minR=min(minR,num_round)\\n                return\\n            elif s[0]==fp or s[0]==sp:\\n                winners+=s[0]\\n                s=s[1:-1]\\n                dfs(s,num_round,winners)\\n            elif s[-1]==fp or s[-1]==sp:\\n                winners+=s[-1]\\n                s=s[1:-1]\\n                dfs(s,num_round,winners)\\n            else:\\n                l,r=s[0],s[-1]\\n                dfs(s[1:-1],num_round,winners+l)\\n                dfs(s[1:-1],num_round,winners+r)\\n            return\\n        \\n        dfs(players, 1, \\'\\')\\n        return [minR,maxR]\\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        minR,maxR=999999,-122\\n        players=\\'\\'\\n        for i in range(1,n+1):\\n            players+=chr(i+65)\\n        fp=chr(firstPlayer+65)\\n        sp=chr(secondPlayer+65)\\n\\n        @cache\\n        def dfs(s,num_round,winners):\\n            nonlocal maxR, minR\\n            if len(s)==0:\\n                dfs(\"\".join(sorted(winners)),num_round+1,\\'\\')\\n                return\\n            if len(s)==1:\\n                winners+=s[0]\\n                dfs(\"\".join(sorted(winners)),num_round+1,\\'\\')\\n                return\\n            if s[0]==fp and s[-1]==sp:\\n                \\n                maxR=max(maxR,num_round)\\n                minR=min(minR,num_round)\\n                return\\n            elif s[0]==fp or s[0]==sp:\\n                winners+=s[0]\\n                s=s[1:-1]\\n                dfs(s,num_round,winners)\\n            elif s[-1]==fp or s[-1]==sp:\\n                winners+=s[-1]\\n                s=s[1:-1]\\n                dfs(s,num_round,winners)\\n            else:\\n                l,r=s[0],s[-1]\\n                dfs(s[1:-1],num_round,winners+l)\\n                dfs(s[1:-1],num_round,winners+r)\\n            return\\n        \\n        dfs(players, 1, \\'\\')\\n        return [minR,maxR]\\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772342,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mn = 10000;\\n    int mx = 0;\\n    int first;\\n    int second;\\n    void dfs(vector<int> &arr, int round) {\\n        int size = arr.size() / 2;\\n        if(arr.size() == 1) return;\\n        for(int i = 0; i < size; i++) {\\n            if(arr[i] == first && arr[arr.size() - i - 1] == second) {\\n                mn = min(mn, round);\\n                mx = max(mx, round);\\n                return;\\n            }\\n        }\\n        bool f1 = false, f2 = false;\\n        for(auto n : arr) {\\n            f1 |= n == first;\\n            f2 |= n == second;\\n        }\\n        if(!f1 || !f2) { \\n            return;\\n        }\\n        vector<int> nextarr(size + (arr.size() % 2));\\n        int m = (1 << size) - 1;\\n        for(int i = 0; i <= m; i++) { \\n            int left = 0, right = nextarr.size() - 1;\\n            for(int j = 0; j < size; j++) {\\n                if((1 << j) & i) { \\n                    nextarr[left++] = arr[j];\\n                }else { \\n                    nextarr[right--] = arr[arr.size() - j - 1];\\n                }\\n                \\n            }\\n            if(arr.size() % 2) { \\n                nextarr[left] = arr[arr.size() / 2];\\n            }\\n            dfs(nextarr, round + 1);\\n        }\\n    }\\n    vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n        vector<int> arr(n);\\n        for(int i= 1; i <= n; i++) {\\n            arr[i - 1] = i;\\n        }\\n        first = firstPlayer;\\n        second = secondPlayer;\\n        dfs(arr, 1);\\n        return {mn, mx};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mn = 10000;\\n    int mx = 0;\\n    int first;\\n    int second;\\n    void dfs(vector<int> &arr, int round) {\\n        int size = arr.size() / 2;\\n        if(arr.size() == 1) return;\\n        for(int i = 0; i < size; i++) {\\n            if(arr[i] == first && arr[arr.size() - i - 1] == second) {\\n                mn = min(mn, round);\\n                mx = max(mx, round);\\n                return;\\n            }\\n        }\\n        bool f1 = false, f2 = false;\\n        for(auto n : arr) {\\n            f1 |= n == first;\\n            f2 |= n == second;\\n        }\\n        if(!f1 || !f2) { \\n            return;\\n        }\\n        vector<int> nextarr(size + (arr.size() % 2));\\n        int m = (1 << size) - 1;\\n        for(int i = 0; i <= m; i++) { \\n            int left = 0, right = nextarr.size() - 1;\\n            for(int j = 0; j < size; j++) {\\n                if((1 << j) & i) { \\n                    nextarr[left++] = arr[j];\\n                }else { \\n                    nextarr[right--] = arr[arr.size() - j - 1];\\n                }\\n                \\n            }\\n            if(arr.size() % 2) { \\n                nextarr[left] = arr[arr.size() / 2];\\n            }\\n            dfs(nextarr, round + 1);\\n        }\\n    }\\n    vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n        vector<int> arr(n);\\n        for(int i= 1; i <= n; i++) {\\n            arr[i - 1] = i;\\n        }\\n        first = firstPlayer;\\n        second = secondPlayer;\\n        dfs(arr, 1);\\n        return {mn, mx};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1277925,
                "title": "python-same-idea-here-maybe-a-little-bit-easier-to-digest",
                "content": "This is essentially the same idea as other top-voted posts. Not as concise but I think the thought process might be easier to come up with during interview.\\n\\n```\\nclass Solution:\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        \\n        @lru_cache(None)\\n        def dp(n, first, second):\\n            \"\"\"\\n            recursion with memorization to calculate [earliest, latest] \\n            \"\"\"\\n            \\n            # base case: if first and second players have to compete in current round\\n            if first == n-second+1:\\n                return (1, 1)\\n            \\n            # the number of players going into next round\\n            nxt_n = (n+1)//2\\n            \\n            # preset ealiest and latest\\n            earliest = float(\\'inf\\')\\n            latest = 0\\n            \\n            # the positions of first and second players, and their mirrors in the array, in sorted order\\n            # if first player is right in the middle l2 == r1, but it is trivally covered so no need to treat specially.\\n            l1, l2, r1, r2 = sorted([first, second, n-first+1, n-second+1])\\n            \\n            # essentially, the above 4 positions chop the arr into 5 parts like this: *** l1 *** l2 ****** r1 *** r2 ***\\n            # name the length of first 3 parts below. The last two parts are the same as part2 and part1 \\n            part1, part2, part3 = l1-1, l2-l1-1, r1-l2-1\\n            \\n            # now lets consider all possible next-round positions of first and second players as nxt_f and nxt_s\\n            \\n            # for the middle part (part3), after this round, it will become half and stay in the same position relative to first and second player.\\n            # so it is simple to calculate the number of players entering next round in this part\\n            p3 = (part3+1)//2\\n            \\n            # for part1 and part2, let\\'s name p1 as the number of players win (and stay) in part1, and p2 for part2.\\n            for p1 in range(part1+1):\\n                for p2 in range(part2+1):\\n                    \\n                    # now here comes the fun part (or actually not fun at all?) to calculate nxt_f and nxt_s using p1, p2 and p3.\\n                    # total 4 scenarios depending on where first and second players are located in current round\\n                    \\n                    # case1: *** l1 *** l2 ****** first *** second ***\\n                    if first == r1:\\n                        nxt_f = p1 + p2 + p3 + 1\\n                        nxt_s = nxt_f + part2-p2 + 1\\n                        \\n                    # case2: *** l1 *** first ****** r1 *** second ***\\n                    elif first == l2:\\n                        nxt_f = p1 + p2 + 1\\n                        nxt_s = nxt_f + p3 + part2-p2 + 1\\n                    \\n                    # case3: *** first *** l2 ****** second *** r2 ***\\n                    elif first == l1 and second == r1:\\n                        nxt_f = p1+1\\n                        nxt_s = nxt_f + p2 + p3 + 1\\n                    \\n                    # case4: *** first *** second ****** r1 *** r2 ***\\n                    else:\\n                        nxt_f = p1+1\\n                        nxt_s = nxt_f + p2+1\\n                        \\n                    # update earliest and latest based on the answers from next round\\n                    nxt = dp(nxt_n, nxt_f, nxt_s)\\n                    earliest = min(earliest, nxt[0])\\n                    latest = max(latest, nxt[1])\\n                    \\n            return (earliest+1, latest+1)\\n        \\n        return dp(n, firstPlayer, secondPlayer)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        \\n        @lru_cache(None)\\n        def dp(n, first, second):\\n            \"\"\"\\n            recursion with memorization to calculate [earliest, latest] \\n            \"\"\"\\n            \\n            # base case: if first and second players have to compete in current round\\n            if first == n-second+1:\\n                return (1, 1)\\n            \\n            # the number of players going into next round\\n            nxt_n = (n+1)//2\\n            \\n            # preset ealiest and latest\\n            earliest = float(\\'inf\\')\\n            latest = 0\\n            \\n            # the positions of first and second players, and their mirrors in the array, in sorted order\\n            # if first player is right in the middle l2 == r1, but it is trivally covered so no need to treat specially.\\n            l1, l2, r1, r2 = sorted([first, second, n-first+1, n-second+1])\\n            \\n            # essentially, the above 4 positions chop the arr into 5 parts like this: *** l1 *** l2 ****** r1 *** r2 ***\\n            # name the length of first 3 parts below. The last two parts are the same as part2 and part1 \\n            part1, part2, part3 = l1-1, l2-l1-1, r1-l2-1\\n            \\n            # now lets consider all possible next-round positions of first and second players as nxt_f and nxt_s\\n            \\n            # for the middle part (part3), after this round, it will become half and stay in the same position relative to first and second player.\\n            # so it is simple to calculate the number of players entering next round in this part\\n            p3 = (part3+1)//2\\n            \\n            # for part1 and part2, let\\'s name p1 as the number of players win (and stay) in part1, and p2 for part2.\\n            for p1 in range(part1+1):\\n                for p2 in range(part2+1):\\n                    \\n                    # now here comes the fun part (or actually not fun at all?) to calculate nxt_f and nxt_s using p1, p2 and p3.\\n                    # total 4 scenarios depending on where first and second players are located in current round\\n                    \\n                    # case1: *** l1 *** l2 ****** first *** second ***\\n                    if first == r1:\\n                        nxt_f = p1 + p2 + p3 + 1\\n                        nxt_s = nxt_f + part2-p2 + 1\\n                        \\n                    # case2: *** l1 *** first ****** r1 *** second ***\\n                    elif first == l2:\\n                        nxt_f = p1 + p2 + 1\\n                        nxt_s = nxt_f + p3 + part2-p2 + 1\\n                    \\n                    # case3: *** first *** l2 ****** second *** r2 ***\\n                    elif first == l1 and second == r1:\\n                        nxt_f = p1+1\\n                        nxt_s = nxt_f + p2 + p3 + 1\\n                    \\n                    # case4: *** first *** second ****** r1 *** r2 ***\\n                    else:\\n                        nxt_f = p1+1\\n                        nxt_s = nxt_f + p2+1\\n                        \\n                    # update earliest and latest based on the answers from next round\\n                    nxt = dp(nxt_n, nxt_f, nxt_s)\\n                    earliest = min(earliest, nxt[0])\\n                    latest = max(latest, nxt[1])\\n                    \\n            return (earliest+1, latest+1)\\n        \\n        return dp(n, firstPlayer, secondPlayer)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269190,
                "title": "java-dfs-solution-o-2-n-2-n-2",
                "content": "First of all, why is this not a DP. Because there are no recurring sub problems. Each state is different.\\nBecause, whenever a chosen player plays, they definitely win. For every other player, we have 2 options, they win or they lose. Although this part looks like a DP, these never make us do recurring sub-problems. The reason for that is whenever someone plays, the opposing player\\'s choice is already made, which leads to a different part of the decision tree. \\n```\\nclass Solution \\n{\\n    int firstPlayer,secondPlayer,n;\\n    boolean enumerate(ArrayList<Integer> ret,int mask,int start,int end)\\n    {\\n        if(start>=end)\\n        {\\n            ret.add(mask);\\n            return false;\\n        }\\n        else\\n        {\\n            while((start<end)&&((mask&(1<<start))!=0))\\n                start++;\\n            while((start<end)&&((mask&(1<<end))!=0))\\n                end--;\\n            if(start>=end)\\n                return enumerate(ret,mask,start+1,end-1);\\n            else if(start==firstPlayer&&end==secondPlayer)\\n                    return true;\\n            else if(start==firstPlayer||start==secondPlayer)\\n                return enumerate(ret,mask|1<<end,start+1,end-1);\\n            else if(end==firstPlayer||end==secondPlayer)\\n                return enumerate(ret,mask|1<<start,start+1,end-1);\\n            else return enumerate(ret,mask|1<<start,start+1,end-1)||enumerate(ret,mask|1<<end,start+1,end-1);\\n                \\n        }\\n    }\\n    int minDFS(int mask)\\n    {\\n        int start=0,end=n-1;\\n        ArrayList<Integer> arr=new ArrayList<Integer>();\\n        if(enumerate(arr,mask,start,end))\\n            return 1;\\n        else\\n        {\\n            int q=Integer.MAX_VALUE;\\n            for(int x:arr)\\n                q=Math.min(q,1+minDFS(x));\\n            return q;\\n        }\\n    } \\n    int maxDFS(int mask)\\n    {\\n        int start=0,end=n-1;\\n        ArrayList<Integer> arr=new ArrayList<Integer>();\\n        if(enumerate(arr,mask,start,end))\\n            return 1;\\n        else\\n        {\\n            int q=Integer.MIN_VALUE;\\n            for(int x:arr)\\n                q=Math.max(q,1+maxDFS(x));\\n            return q;\\n        }\\n    }\\n\\n    public int[] earliestAndLatest(int n, int firstPlayer, int secondPlayer) \\n    {\\n        this.n=n;\\n        this.firstPlayer=firstPlayer-1;\\n        this.secondPlayer=secondPlayer-1;\\n        return new int[]{minDFS(0),maxDFS(0)};        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\n    int firstPlayer,secondPlayer,n;\\n    boolean enumerate(ArrayList<Integer> ret,int mask,int start,int end)\\n    {\\n        if(start>=end)\\n        {\\n            ret.add(mask);\\n            return false;\\n        }\\n        else\\n        {\\n            while((start<end)&&((mask&(1<<start))!=0))\\n                start++;\\n            while((start<end)&&((mask&(1<<end))!=0))\\n                end--;\\n            if(start>=end)\\n                return enumerate(ret,mask,start+1,end-1);\\n            else if(start==firstPlayer&&end==secondPlayer)\\n                    return true;\\n            else if(start==firstPlayer||start==secondPlayer)\\n                return enumerate(ret,mask|1<<end,start+1,end-1);\\n            else if(end==firstPlayer||end==secondPlayer)\\n                return enumerate(ret,mask|1<<start,start+1,end-1);\\n            else return enumerate(ret,mask|1<<start,start+1,end-1)||enumerate(ret,mask|1<<end,start+1,end-1);\\n                \\n        }\\n    }\\n    int minDFS(int mask)\\n    {\\n        int start=0,end=n-1;\\n        ArrayList<Integer> arr=new ArrayList<Integer>();\\n        if(enumerate(arr,mask,start,end))\\n            return 1;\\n        else\\n        {\\n            int q=Integer.MAX_VALUE;\\n            for(int x:arr)\\n                q=Math.min(q,1+minDFS(x));\\n            return q;\\n        }\\n    } \\n    int maxDFS(int mask)\\n    {\\n        int start=0,end=n-1;\\n        ArrayList<Integer> arr=new ArrayList<Integer>();\\n        if(enumerate(arr,mask,start,end))\\n            return 1;\\n        else\\n        {\\n            int q=Integer.MIN_VALUE;\\n            for(int x:arr)\\n                q=Math.max(q,1+maxDFS(x));\\n            return q;\\n        }\\n    }\\n\\n    public int[] earliestAndLatest(int n, int firstPlayer, int secondPlayer) \\n    {\\n        this.n=n;\\n        this.firstPlayer=firstPlayer-1;\\n        this.secondPlayer=secondPlayer-1;\\n        return new int[]{minDFS(0),maxDFS(0)};        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268761,
                "title": "c-dfs-with-memorization",
                "content": "```\\npublic class Solution\\n{\\n    public int[] EarliestAndLatest(int n, int firstPlayer, int secondPlayer)\\n    {\\n        var res = DFS(n, firstPlayer - 1, secondPlayer - 1, new (int Min, int Max)?[n + 1, n + 1, n + 1]);\\n        return new int[] { res.Min, res.Max };\\n    }\\n\\n    private (int Min, int Max) DFS(int len, int firstPlayer, int secondPlayer, (int Min, int Max)?[,,] memo)\\n    {\\n        if (firstPlayer + secondPlayer + 1 == len)\\n            return (1, 1);\\n\\n        if (memo[len, firstPlayer, secondPlayer].HasValue)\\n            return memo[len, firstPlayer, secondPlayer].Value;\\n\\n        int min = len;\\n        int max = 0;\\n        int nextLen = (len + 1) / 2;\\n        for (int mask = 0; mask < (1 << nextLen); mask++)\\n        {\\n            int nextFirstPlayer = firstPlayer;\\n            int nextSecondPlayer = secondPlayer;\\n            bool valid = true;\\n            for (int n = 0; n < len / 2; n++)\\n            {\\n                int m = (mask & 1 << n) == 0 ? n : len - n - 1;\\n                if (m == firstPlayer || m == secondPlayer)\\n                    valid = false;\\n                if (m < firstPlayer)\\n                    nextFirstPlayer--;\\n                if (m < secondPlayer)\\n                    nextSecondPlayer--;\\n            }\\n\\n            if (!valid) continue;\\n\\n            var next = DFS(nextLen, nextFirstPlayer, nextSecondPlayer, memo);\\n            min = Math.Min(min, next.Min + 1);\\n            max = Math.Max(max, next.Max + 1);\\n        }\\n\\n        memo[len, firstPlayer, secondPlayer] = (min, max);\\n        return memo[len, firstPlayer, secondPlayer].Value;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int[] EarliestAndLatest(int n, int firstPlayer, int secondPlayer)\\n    {\\n        var res = DFS(n, firstPlayer - 1, secondPlayer - 1, new (int Min, int Max)?[n + 1, n + 1, n + 1]);\\n        return new int[] { res.Min, res.Max };\\n    }\\n\\n    private (int Min, int Max) DFS(int len, int firstPlayer, int secondPlayer, (int Min, int Max)?[,,] memo)\\n    {\\n        if (firstPlayer + secondPlayer + 1 == len)\\n            return (1, 1);\\n\\n        if (memo[len, firstPlayer, secondPlayer].HasValue)\\n            return memo[len, firstPlayer, secondPlayer].Value;\\n\\n        int min = len;\\n        int max = 0;\\n        int nextLen = (len + 1) / 2;\\n        for (int mask = 0; mask < (1 << nextLen); mask++)\\n        {\\n            int nextFirstPlayer = firstPlayer;\\n            int nextSecondPlayer = secondPlayer;\\n            bool valid = true;\\n            for (int n = 0; n < len / 2; n++)\\n            {\\n                int m = (mask & 1 << n) == 0 ? n : len - n - 1;\\n                if (m == firstPlayer || m == secondPlayer)\\n                    valid = false;\\n                if (m < firstPlayer)\\n                    nextFirstPlayer--;\\n                if (m < secondPlayer)\\n                    nextSecondPlayer--;\\n            }\\n\\n            if (!valid) continue;\\n\\n            var next = DFS(nextLen, nextFirstPlayer, nextSecondPlayer, memo);\\n            min = Math.Min(min, next.Min + 1);\\n            max = Math.Max(max, next.Max + 1);\\n        }\\n\\n        memo[len, firstPlayer, secondPlayer] = (min, max);\\n        return memo[len, firstPlayer, secondPlayer].Value;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268515,
                "title": "python-consider-all-possibilities",
                "content": "We consider every possible outcome of the matches.\\n\\nThe worst case complexity is O(n*2^0.75n), which is not too bad.\\n\\nWe begin with a maximum of 28 players, which will have 14, 7, 4, 2, 1 in successive rounds.\\n\\nLet\\'s say we have 2^14 possibilities that will advance the first round. For each of these possibility we consider 2^7 outcomes. The complexity to calculate the possibilites of the next round is 28*2^21=58720256, which is reasonable.\\n\\nThere are (28-2 choose 7-2)=65780 possibilities for the second round, which makes successive computations even more reasonable. \\n\\n```\\nclass Solution:\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n                \\n        round_num = 0\\n        valid_rounds = set()\\n        possibilities = set([tuple(range(1,n+1))])\\n        \\n        while possibilities:\\n            round_num += 1\\n\\n            next_possibilities = set()\\n            num_players = len(next(iter(possibilities)))\\n            num_matches = num_players // 2\\n            \\n            for possibility in possibilities:\\n                for a,b in zip(possibility[:num_matches], possibility[::-1]):\\n                    if a == firstPlayer and b == secondPlayer:\\n                        valid_rounds.add(round_num)\\n                        continue\\n\\n                for comb in itertools.product([0,1], repeat=num_matches):\\n                    next_possibility = [possibility[i] if c else possibility[~i] for i,c in enumerate(comb)]\\n\\n                    if num_players%2 == 1:  # center player automatically advance\\n                        next_possibility.append(possibility[num_matches])\\n                    \\n                    if firstPlayer not in next_possibility or secondPlayer not in next_possibility:\\n                        continue\\n                    \\n                    next_possibilities.add(tuple(sorted(next_possibility)))\\n            \\n            possibilities = next_possibilities\\n            \\n        return [min(valid_rounds), max(valid_rounds)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n                \\n        round_num = 0\\n        valid_rounds = set()\\n        possibilities = set([tuple(range(1,n+1))])\\n        \\n        while possibilities:\\n            round_num += 1\\n\\n            next_possibilities = set()\\n            num_players = len(next(iter(possibilities)))\\n            num_matches = num_players // 2\\n            \\n            for possibility in possibilities:\\n                for a,b in zip(possibility[:num_matches], possibility[::-1]):\\n                    if a == firstPlayer and b == secondPlayer:\\n                        valid_rounds.add(round_num)\\n                        continue\\n\\n                for comb in itertools.product([0,1], repeat=num_matches):\\n                    next_possibility = [possibility[i] if c else possibility[~i] for i,c in enumerate(comb)]\\n\\n                    if num_players%2 == 1:  # center player automatically advance\\n                        next_possibility.append(possibility[num_matches])\\n                    \\n                    if firstPlayer not in next_possibility or secondPlayer not in next_possibility:\\n                        continue\\n                    \\n                    next_possibilities.add(tuple(sorted(next_possibility)))\\n            \\n            possibilities = next_possibilities\\n            \\n        return [min(valid_rounds), max(valid_rounds)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556210,
                "title": "golang-beginner-dfs-dp",
                "content": "# Intuition\\nThis is a typical resursive DFS search + DP problem\\n\\nMyy golang is not good, so just see the idea of solving\\n\\n# Code\\n```\\n\\ntype State struct {\\n\\tstate    []bool\\n\\tcurRound int\\n}\\n\\ntype Result struct {\\n\\tearliest int\\n\\tlatest   int\\n}\\n\\nvar visited map[string]Result\\n\\nfunc (s State) ToString() string {\\n\\treturn fmt.Sprintf(\"%v\", s.state)\\n}\\n\\nfunc (r *Result) Merge(other Result) {\\n\\tif other.earliest < r.earliest {\\n\\t\\tr.earliest = other.earliest\\n\\t}\\n\\tif other.latest > r.latest {\\n\\t\\tr.latest = other.latest\\n\\t}\\n}\\n\\nfunc SolveInternal(state State) (result Result) {\\n\\tif r, ok := visited[state.ToString()]; ok {\\n\\t\\treturn r\\n\\t}\\n\\n\\tstate.curRound++\\n\\n\\tfmt.Println(\"SolveInternal\", state)\\n\\n\\tmakingQueue := [][]int{\\n\\t\\tmake([]int, 0),\\n\\t}\\n\\tcompletedQueue := make([]State, 0)\\n\\toldState := state.state\\n\\n\\tfor len(makingQueue) > 0 {\\n\\t\\tmakingState := makingQueue[0]\\n\\t\\tmakingQueue = makingQueue[1:]\\n\\n\\t\\tcurIndex := len(makingState)\\n\\n\\t\\t//fmt.Println(\"Examining \", makingState, \"curIndex\", curIndex)\\n\\n\\t\\tif curIndex == len(oldState)/2 {\\n\\t\\t\\tif len(oldState)%2 == 1 {\\n\\t\\t\\t\\tmakingState = append(makingState, curIndex)\\n\\t\\t\\t}\\n\\n\\t\\t\\tsort.Ints(makingState)\\n\\t\\t\\tcompletedState := State{\\n\\t\\t\\t\\tstate:    make([]bool, len(makingState)),\\n\\t\\t\\t\\tcurRound: state.curRound,\\n\\t\\t\\t}\\n\\t\\t\\tfor i := range makingState {\\n\\t\\t\\t\\tcompletedState.state[i] = oldState[makingState[i]]\\n\\t\\t\\t}\\n\\t\\t\\tcompletedQueue = append(completedQueue, completedState)\\n\\t\\t} else {\\n\\t\\t\\toppIndex := len(oldState) - curIndex - 1\\n\\n\\t\\t\\tif oldState[curIndex] && oldState[oppIndex] {\\n\\t\\t\\t\\tfmt.Println(\"Found terminal condition at \", state)\\n\\t\\t\\t\\treturn Result{earliest: state.curRound, latest: state.curRound}\\n\\t\\t\\t}\\n\\t\\t\\tif !oldState[curIndex] {\\n\\t\\t\\t\\t//fmt.Println(\"- adding\", oppIndex, \"to\", makingState, \"as curIndex\", curIndex, \"is not true\")\\n\\t\\t\\t\\tmakingQueue = append(makingQueue, append(makingState, oppIndex))\\n\\t\\t\\t}\\n\\t\\t\\tif !oldState[oppIndex] {\\n\\t\\t\\t\\t//fmt.Println(\"- adding\", curIndex, \"to\", makingState, \"as curIndex\", oppIndex, \"is not true\")\\n\\t\\t\\t\\tcopiedState := make([]int, len(makingState))\\n\\t\\t\\t\\tcopy(copiedState, makingState)\\n\\t\\t\\t\\tmakingQueue = append(makingQueue, append(copiedState, curIndex))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tresult = Result{earliest: math.MaxInt, latest: math.MinInt}\\n\\n\\tfor _, newState := range completedQueue {\\n\\t\\tnewState.curRound = state.curRound\\n\\n\\t\\toneResult := SolveInternal(newState)\\n\\t\\tresult.Merge(oneResult)\\n\\t}\\n\\n\\tvisited[state.ToString()] = result\\n\\treturn\\n}\\n\\nfunc earliestAndLatest(n int, firstPlayer int, secondPlayer int) []int {\\n\\n\\tvisited = make(map[string]Result)\\n\\n\\tfmt.Println(\"Started to solve\", n, firstPlayer, secondPlayer)\\n\\n\\tstate := State{\\n\\t\\tstate:    make([]bool, n),\\n\\t\\tcurRound: 0,\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tstate.state[i] = (i+1) == firstPlayer || (i+1) == secondPlayer\\n\\t}\\n\\n\\tresult := SolveInternal(state)\\n\\n\\tfmt.Println(\"Finished\", result)\\n\\n\\treturn []int{result.earliest, result.latest}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\ntype State struct {\\n\\tstate    []bool\\n\\tcurRound int\\n}\\n\\ntype Result struct {\\n\\tearliest int\\n\\tlatest   int\\n}\\n\\nvar visited map[string]Result\\n\\nfunc (s State) ToString() string {\\n\\treturn fmt.Sprintf(\"%v\", s.state)\\n}\\n\\nfunc (r *Result) Merge(other Result) {\\n\\tif other.earliest < r.earliest {\\n\\t\\tr.earliest = other.earliest\\n\\t}\\n\\tif other.latest > r.latest {\\n\\t\\tr.latest = other.latest\\n\\t}\\n}\\n\\nfunc SolveInternal(state State) (result Result) {\\n\\tif r, ok := visited[state.ToString()]; ok {\\n\\t\\treturn r\\n\\t}\\n\\n\\tstate.curRound++\\n\\n\\tfmt.Println(\"SolveInternal\", state)\\n\\n\\tmakingQueue := [][]int{\\n\\t\\tmake([]int, 0),\\n\\t}\\n\\tcompletedQueue := make([]State, 0)\\n\\toldState := state.state\\n\\n\\tfor len(makingQueue) > 0 {\\n\\t\\tmakingState := makingQueue[0]\\n\\t\\tmakingQueue = makingQueue[1:]\\n\\n\\t\\tcurIndex := len(makingState)\\n\\n\\t\\t//fmt.Println(\"Examining \", makingState, \"curIndex\", curIndex)\\n\\n\\t\\tif curIndex == len(oldState)/2 {\\n\\t\\t\\tif len(oldState)%2 == 1 {\\n\\t\\t\\t\\tmakingState = append(makingState, curIndex)\\n\\t\\t\\t}\\n\\n\\t\\t\\tsort.Ints(makingState)\\n\\t\\t\\tcompletedState := State{\\n\\t\\t\\t\\tstate:    make([]bool, len(makingState)),\\n\\t\\t\\t\\tcurRound: state.curRound,\\n\\t\\t\\t}\\n\\t\\t\\tfor i := range makingState {\\n\\t\\t\\t\\tcompletedState.state[i] = oldState[makingState[i]]\\n\\t\\t\\t}\\n\\t\\t\\tcompletedQueue = append(completedQueue, completedState)\\n\\t\\t} else {\\n\\t\\t\\toppIndex := len(oldState) - curIndex - 1\\n\\n\\t\\t\\tif oldState[curIndex] && oldState[oppIndex] {\\n\\t\\t\\t\\tfmt.Println(\"Found terminal condition at \", state)\\n\\t\\t\\t\\treturn Result{earliest: state.curRound, latest: state.curRound}\\n\\t\\t\\t}\\n\\t\\t\\tif !oldState[curIndex] {\\n\\t\\t\\t\\t//fmt.Println(\"- adding\", oppIndex, \"to\", makingState, \"as curIndex\", curIndex, \"is not true\")\\n\\t\\t\\t\\tmakingQueue = append(makingQueue, append(makingState, oppIndex))\\n\\t\\t\\t}\\n\\t\\t\\tif !oldState[oppIndex] {\\n\\t\\t\\t\\t//fmt.Println(\"- adding\", curIndex, \"to\", makingState, \"as curIndex\", oppIndex, \"is not true\")\\n\\t\\t\\t\\tcopiedState := make([]int, len(makingState))\\n\\t\\t\\t\\tcopy(copiedState, makingState)\\n\\t\\t\\t\\tmakingQueue = append(makingQueue, append(copiedState, curIndex))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tresult = Result{earliest: math.MaxInt, latest: math.MinInt}\\n\\n\\tfor _, newState := range completedQueue {\\n\\t\\tnewState.curRound = state.curRound\\n\\n\\t\\toneResult := SolveInternal(newState)\\n\\t\\tresult.Merge(oneResult)\\n\\t}\\n\\n\\tvisited[state.ToString()] = result\\n\\treturn\\n}\\n\\nfunc earliestAndLatest(n int, firstPlayer int, secondPlayer int) []int {\\n\\n\\tvisited = make(map[string]Result)\\n\\n\\tfmt.Println(\"Started to solve\", n, firstPlayer, secondPlayer)\\n\\n\\tstate := State{\\n\\t\\tstate:    make([]bool, n),\\n\\t\\tcurRound: 0,\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tstate.state[i] = (i+1) == firstPlayer || (i+1) == secondPlayer\\n\\t}\\n\\n\\tresult := SolveInternal(state)\\n\\n\\tfmt.Println(\"Finished\", result)\\n\\n\\treturn []int{result.earliest, result.latest}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3225102,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn earliest_and_latest(n: i32, first_player: i32, second_player: i32) -> Vec<i32> {\\n        let mut mn = 10000;\\n        let mut mx = 0;\\n\\n        let mut arr = vec![0; n as usize];\\n        for i in 1..=n {\\n            arr[i as usize - 1] = i;\\n        }\\n        Solution::dfs(&arr, 1, &mut mn, &mut mx, first_player, second_player);\\n        vec![mn, mx]\\n    }\\n\\n    fn dfs(arr: &Vec<i32>, round: i32, mn: &mut i32, mx: &mut i32, first: i32, second: i32) {\\n        let size = arr.len() / 2;\\n        if arr.len() == 1 {\\n            return;\\n        }\\n        for i in 0..size {\\n            if arr[i] == first && arr[arr.len() - i - 1] == second {\\n                *mn = (*mn).min(round);\\n                *mx = (*mx).max(round);\\n                return;\\n            }\\n        }\\n        let mut f1 = false;\\n        let mut f2 = false;\\n        for n in arr {\\n            f1 |= *n == first;\\n            f2 |= *n == second;\\n        }\\n        if !f1 || !f2 {\\n            return;\\n        }\\n        let mut nextarr = vec![0; size + (arr.len() % 2)];\\n        let m = (1 << size) - 1;\\n        for i in 0..=m {\\n            let mut left = 0_i32;\\n            let mut right = nextarr.len() as i32 - 1;\\n            for j in 0..size {\\n                if (1 << j) & i != 0 {\\n                    nextarr[left as usize] = arr[j];\\n                    left += 1;\\n                } else {\\n                    nextarr[right as usize] = arr[arr.len() - j - 1];\\n                    right -= 1;\\n                }\\n            }\\n            if arr.len() % 2 != 0 {\\n                nextarr[left as usize] = arr[arr.len() / 2];\\n            }\\n            Solution::dfs(&nextarr, round + 1, mn, mx, first, second);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn earliest_and_latest(n: i32, first_player: i32, second_player: i32) -> Vec<i32> {\\n        let mut mn = 10000;\\n        let mut mx = 0;\\n\\n        let mut arr = vec![0; n as usize];\\n        for i in 1..=n {\\n            arr[i as usize - 1] = i;\\n        }\\n        Solution::dfs(&arr, 1, &mut mn, &mut mx, first_player, second_player);\\n        vec![mn, mx]\\n    }\\n\\n    fn dfs(arr: &Vec<i32>, round: i32, mn: &mut i32, mx: &mut i32, first: i32, second: i32) {\\n        let size = arr.len() / 2;\\n        if arr.len() == 1 {\\n            return;\\n        }\\n        for i in 0..size {\\n            if arr[i] == first && arr[arr.len() - i - 1] == second {\\n                *mn = (*mn).min(round);\\n                *mx = (*mx).max(round);\\n                return;\\n            }\\n        }\\n        let mut f1 = false;\\n        let mut f2 = false;\\n        for n in arr {\\n            f1 |= *n == first;\\n            f2 |= *n == second;\\n        }\\n        if !f1 || !f2 {\\n            return;\\n        }\\n        let mut nextarr = vec![0; size + (arr.len() % 2)];\\n        let m = (1 << size) - 1;\\n        for i in 0..=m {\\n            let mut left = 0_i32;\\n            let mut right = nextarr.len() as i32 - 1;\\n            for j in 0..size {\\n                if (1 << j) & i != 0 {\\n                    nextarr[left as usize] = arr[j];\\n                    left += 1;\\n                } else {\\n                    nextarr[right as usize] = arr[arr.len() - j - 1];\\n                    right -= 1;\\n                }\\n            }\\n            if arr.len() % 2 != 0 {\\n                nextarr[left as usize] = arr[arr.len() / 2];\\n            }\\n            Solution::dfs(&nextarr, round + 1, mn, mx, first, second);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2942874,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} firstPlayer\\n * @param {number} secondPlayer\\n * @return {number[]}\\n */\\n\\n\\nvar earliestAndLatest = function (n, firstPlayer, secondPlayer) {\\n  let earliest = n;\\n  let latest = 0;\\n\\n  const visited = new Set();\\n\\n  const findEarliestAndLatest = (remain, players, current, round) => {\\n    if (visited.has(remain)) return;\\n    \\n    const player = players[current];\\n    const opponent = players[players.length - current]; // since we\\'re 1-indexed\\n\\n    if (player === firstPlayer && opponent === secondPlayer) {\\n      earliest = Math.min(earliest, round);\\n      latest = Math.max(latest, round);\\n      return;\\n    }\\n\\n    if (opponent <= player) {\\n\\t  // we\\'ve gone halfway through the list, so everyone has been matched up\\n\\t  // go to the next round\\n      const nextPlayers = players.filter((p) => remain & (1 << p));\\n      findEarliestAndLatest(remain, nextPlayers, 1, round + 1);\\n      return;\\n    }\\n\\n    const remainIfPlayerWins = remain ^ (1 << opponent);\\n    const remainIfOpponentWins = remain ^ (1 << player);\\n    const next = current + 1;\\n\\n\\t// it\\'s possible both firstPlayer and secondPlayer are in the first half of the list\\n    if (player === firstPlayer || player === secondPlayer) {\\n      findEarliestAndLatest(remainIfPlayerWins, players, next, round);\\n      return;\\n    }\\n    \\n\\t// it\\'s possible both firstPlayer and secondPlayer are in the second half of the list\\n    if (opponent === firstPlayer || opponent === secondPlayer) {\\n      findEarliestAndLatest(remainIfOpponentWins, players, next, round);\\n      return;\\n    }\\n\\n    // neither player nor opponent are firstPlayer or secondPlayer\\n    findEarliestAndLatest(remainIfPlayerWins, players, next, round);\\n    findEarliestAndLatest(remainIfOpponentWins, players, next, round);\\n    visited.add(remain);\\n  }\\n\\n  const players = new Array(n + 1).fill(0).map((_, i) => i);\\n  const ALL_PLAYERS_REMAIN = 2 ** (n + 1) - 1;\\n  findEarliestAndLatest(ALL_PLAYERS_REMAIN, players, 1, 1);\\n\\n  return [earliest, latest]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} firstPlayer\\n * @param {number} secondPlayer\\n * @return {number[]}\\n */\\n\\n\\nvar earliestAndLatest = function (n, firstPlayer, secondPlayer) {\\n  let earliest = n;\\n  let latest = 0;\\n\\n  const visited = new Set();\\n\\n  const findEarliestAndLatest = (remain, players, current, round) => {\\n    if (visited.has(remain)) return;\\n    \\n    const player = players[current];\\n    const opponent = players[players.length - current]; // since we\\'re 1-indexed\\n\\n    if (player === firstPlayer && opponent === secondPlayer) {\\n      earliest = Math.min(earliest, round);\\n      latest = Math.max(latest, round);\\n      return;\\n    }\\n\\n    if (opponent <= player) {\\n\\t  // we\\'ve gone halfway through the list, so everyone has been matched up\\n\\t  // go to the next round\\n      const nextPlayers = players.filter((p) => remain & (1 << p));\\n      findEarliestAndLatest(remain, nextPlayers, 1, round + 1);\\n      return;\\n    }\\n\\n    const remainIfPlayerWins = remain ^ (1 << opponent);\\n    const remainIfOpponentWins = remain ^ (1 << player);\\n    const next = current + 1;\\n\\n\\t// it\\'s possible both firstPlayer and secondPlayer are in the first half of the list\\n    if (player === firstPlayer || player === secondPlayer) {\\n      findEarliestAndLatest(remainIfPlayerWins, players, next, round);\\n      return;\\n    }\\n    \\n\\t// it\\'s possible both firstPlayer and secondPlayer are in the second half of the list\\n    if (opponent === firstPlayer || opponent === secondPlayer) {\\n      findEarliestAndLatest(remainIfOpponentWins, players, next, round);\\n      return;\\n    }\\n\\n    // neither player nor opponent are firstPlayer or secondPlayer\\n    findEarliestAndLatest(remainIfPlayerWins, players, next, round);\\n    findEarliestAndLatest(remainIfOpponentWins, players, next, round);\\n    visited.add(remain);\\n  }\\n\\n  const players = new Array(n + 1).fill(0).map((_, i) => i);\\n  const ALL_PLAYERS_REMAIN = 2 ** (n + 1) - 1;\\n  findEarliestAndLatest(ALL_PLAYERS_REMAIN, players, 1, 1);\\n\\n  return [earliest, latest]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2883533,
                "title": "python-dp-solution-memoization-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        @lru_cache(None)\\n        def dp(left, right, curPlayers, numGamesAlreadyPlayed):\\n            if left > right:  \\n                dp(right, left, curPlayers, numGamesAlreadyPlayed)\\n            if left == right: \\n                ans.add(numGamesAlreadyPlayed)\\n            for i in range(1, left + 1):\\n                for j in range(left - i + 1, right - i + 1):\\n                    if not (curPlayers + 1) // 2 >= i + j >= left + right - curPlayers // 2: \\n                        continue\\n                    dp(i, j, (curPlayers + 1) // 2, numGamesAlreadyPlayed + 1)\\n\\n        ans = set()\\n        dp(firstPlayer, n - secondPlayer + 1, n, 1)\\n        return [min(ans), max(ans)]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        @lru_cache(None)\\n        def dp(left, right, curPlayers, numGamesAlreadyPlayed):\\n            if left > right:  \\n                dp(right, left, curPlayers, numGamesAlreadyPlayed)\\n            if left == right: \\n                ans.add(numGamesAlreadyPlayed)\\n            for i in range(1, left + 1):\\n                for j in range(left - i + 1, right - i + 1):\\n                    if not (curPlayers + 1) // 2 >= i + j >= left + right - curPlayers // 2: \\n                        continue\\n                    dp(i, j, (curPlayers + 1) // 2, numGamesAlreadyPlayed + 1)\\n\\n        ans = set()\\n        dp(firstPlayer, n - secondPlayer + 1, n, 1)\\n        return [min(ans), max(ans)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873547,
                "title": "c-solutions",
                "content": "```\\n```\\nclass Solution {\\nprivate:\\n    int dp[28][28][28];\\n    int Min = INT_MAX, Max = 0;\\n    void perm(int len, int f, int s, int round, int i1, int i2, int state){\\n        if(i1 < i2){\\n            if(i2 != f && i2 != s){\\n                perm(len, f, s, round, i1+1, i2-1, state | (1 << i1));     \\n            }\\n            if(i1 != f && i1 != s){\\n                perm(len, f, s, round, i1+1, i2-1, state | (1 << i2));     \\n            }\\n            return;\\n        }\\n        \\n        if(i1 == i2){state |= (1<<i1);}\\n        \\n        int mask = 1;\\n        int count = 0;\\n        int f_nxt, s_nxt;\\n        for(int i = 0; i < len; i++){\\n            if(i == f){f_nxt = count;}\\n            else if(i == s){s_nxt = count;}\\n            if(mask & state){count++;}\\n            mask <<= 1;\\n        }\\n            \\n        dfs(count, f_nxt, s_nxt, round);\\n    }\\n        \\n    void dfs(int len, int f, int s, int round){\\n        if(dp[round][f][s]){return;}\\n        \\n        if(f == len-1-s){\\n            dp[round][f][s] = true;\\n            Min = min(Min, round);\\n            Max = max(Max, round);\\n            return;\\n        }\\n        \\n        perm(len, f, s, round+1, 0 ,len-1, 0);\\n        \\n    }\\npublic:\\n    vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n        dfs(n, firstPlayer-1, secondPlayer-1, 1);\\n        return vector<int>{Min, Max};\\n    }\\n};\\n```\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2873546,
                "title": "c-solutions",
                "content": "```\\n```\\nclass Solution {\\nprivate:\\n    int dp[28][28][28];\\n    int Min = INT_MAX, Max = 0;\\n    void perm(int len, int f, int s, int round, int i1, int i2, int state){\\n        if(i1 < i2){\\n            if(i2 != f && i2 != s){\\n                perm(len, f, s, round, i1+1, i2-1, state | (1 << i1));     \\n            }\\n            if(i1 != f && i1 != s){\\n                perm(len, f, s, round, i1+1, i2-1, state | (1 << i2));     \\n            }\\n            return;\\n        }\\n        \\n        if(i1 == i2){state |= (1<<i1);}\\n        \\n        int mask = 1;\\n        int count = 0;\\n        int f_nxt, s_nxt;\\n        for(int i = 0; i < len; i++){\\n            if(i == f){f_nxt = count;}\\n            else if(i == s){s_nxt = count;}\\n            if(mask & state){count++;}\\n            mask <<= 1;\\n        }\\n            \\n        dfs(count, f_nxt, s_nxt, round);\\n    }\\n        \\n    void dfs(int len, int f, int s, int round){\\n        if(dp[round][f][s]){return;}\\n        \\n        if(f == len-1-s){\\n            dp[round][f][s] = true;\\n            Min = min(Min, round);\\n            Max = max(Max, round);\\n            return;\\n        }\\n        \\n        perm(len, f, s, round+1, 0 ,len-1, 0);\\n        \\n    }\\npublic:\\n    vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n        dfs(n, firstPlayer-1, secondPlayer-1, 1);\\n        return vector<int>{Min, Max};\\n    }\\n};\\n```\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2827112,
                "title": "c-dp-solution",
                "content": "```\\nconst int           N   = 10 + 3e1;\\n\\nint     f[N][N][N];\\nint     g[N][N][N];\\n\\nclass Solution {\\npublic:\\n    vector<int> earliestAndLatest(int T, int A, int B) {           \\n        memset(f, 0x3f, sizeof(f));\\n        memset(g, 0xcf, sizeof(g));\\n        f[2][1][2] = 1;\\n        g[2][1][2] = 1;\\n        \\n        for (int n = 3; n <= T; n++) {\\n            for (int i = 1; i <= n; i++) {\\n                for (int j = i+1; j <= n; j++) {\\n                    int u = min(i,n+1-i)-1, v = min(j,n+1-j)-1;     // group index : count from 0\\n                    int l = (i==u+1), r = (j==v+1);                 // on the left side\\n                    \\n                    int m = (n+1)/2;\\n                    \\n                    if (u == v) {\\n                        f[n][i][j] = 1;\\n                        g[n][i][j] = 1;\\n                    }\\n                    else if (u < v) {\\n                        for (int x = 0; x <= u; x++) {\\n                            for (int y = x+1; y <= v; y++) if (y-x <= v-u) {\\n                                f[n][i][j] = min(f[n][i][j], f[m][l?x+1:m-(u-x)][r?y+1:m-(v-y)] + 1);\\n                                g[n][i][j] = max(g[n][i][j], g[m][l?x+1:m-(u-x)][r?y+1:m-(v-y)] + 1);\\n                            }\\n                        }\\n                    }\\n                    else if (v < u) {\\n                        for (int y = 0; y <= v; y++) {\\n                            for (int x = y; x+1 <= u; x++) if (x-y <= u-v-1) {\\n                                f[n][i][j] = min(f[n][i][j], f[m][l?x+1:m-(u-x)][r?y+1:m-(v-y)] + 1);\\n                                g[n][i][j] = max(g[n][i][j], g[m][l?x+1:m-(u-x)][r?y+1:m-(v-y)] + 1);\\n                            }\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n                                                    \\n        if (A > B) swap(A, B);                                                              \\n        return {f[T][A][B], g[T][A][B]};\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nconst int           N   = 10 + 3e1;\\n\\nint     f[N][N][N];\\nint     g[N][N][N];\\n\\nclass Solution {\\npublic:\\n    vector<int> earliestAndLatest(int T, int A, int B) {           \\n        memset(f, 0x3f, sizeof(f));\\n        memset(g, 0xcf, sizeof(g));\\n        f[2][1][2] = 1;\\n        g[2][1][2] = 1;\\n        \\n        for (int n = 3; n <= T; n++) {\\n            for (int i = 1; i <= n; i++) {\\n                for (int j = i+1; j <= n; j++) {\\n                    int u = min(i,n+1-i)-1, v = min(j,n+1-j)-1;     // group index : count from 0\\n                    int l = (i==u+1), r = (j==v+1);                 // on the left side\\n                    \\n                    int m = (n+1)/2;\\n                    \\n                    if (u == v) {\\n                        f[n][i][j] = 1;\\n                        g[n][i][j] = 1;\\n                    }\\n                    else if (u < v) {\\n                        for (int x = 0; x <= u; x++) {\\n                            for (int y = x+1; y <= v; y++) if (y-x <= v-u) {\\n                                f[n][i][j] = min(f[n][i][j], f[m][l?x+1:m-(u-x)][r?y+1:m-(v-y)] + 1);\\n                                g[n][i][j] = max(g[n][i][j], g[m][l?x+1:m-(u-x)][r?y+1:m-(v-y)] + 1);\\n                            }\\n                        }\\n                    }\\n                    else if (v < u) {\\n                        for (int y = 0; y <= v; y++) {\\n                            for (int x = y; x+1 <= u; x++) if (x-y <= u-v-1) {\\n                                f[n][i][j] = min(f[n][i][j], f[m][l?x+1:m-(u-x)][r?y+1:m-(v-y)] + 1);\\n                                g[n][i][j] = max(g[n][i][j], g[m][l?x+1:m-(u-x)][r?y+1:m-(v-y)] + 1);\\n                            }\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n                                                    \\n        if (A > B) swap(A, B);                                                              \\n        return {f[T][A][B], g[T][A][B]};\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685871,
                "title": "python-solution-faster-90",
                "content": "\\tclass Solution:\\n\\t\\tdef earliestAndLatest(self, n, F, S):\\n\\t\\t\\tans = set()\\n\\t\\t\\tdef dfs(pos, i):\\n\\t\\t\\t\\tM, pairs = len(pos), []\\n\\t\\t\\t\\tif M < 2: return\\n\\n\\t\\t\\t\\tfor j in range(M//2):\\n\\t\\t\\t\\t\\ta, b = pos[j], pos[-1-j]\\n\\t\\t\\t\\t\\tif (a, b) == (F, S):\\n\\t\\t\\t\\t\\t\\tans.add(i)\\n\\t\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\t\\tif a != F and b != F and a != S and b != S:\\n\\t\\t\\t\\t\\t\\tpairs.append((a, b))\\n\\n\\t\\t\\t\\taddon = (F, S) if M%2 == 0 else tuple(set([F, S, pos[M//2]]))\\n\\t\\t\\t\\tfor elem in product(*pairs):\\n\\t\\t\\t\\t\\tdfs(sorted(elem + addon), i + 1)\\n\\n\\t\\t\\tdfs(list(range(1, n+1)), 1)\\n\\t\\t\\treturn [min(ans), max(ans)]",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef earliestAndLatest(self, n, F, S):\\n\\t\\t\\tans = set()\\n\\t\\t\\tdef dfs(pos, i):\\n\\t\\t\\t\\tM, pairs = len(pos), []\\n\\t\\t\\t\\tif M < 2: return\\n\\n\\t\\t\\t\\tfor j in range(M//2):\\n\\t\\t\\t\\t\\ta, b = pos[j], pos[-1-j]\\n\\t\\t\\t\\t\\tif (a, b) == (F, S):\\n\\t\\t\\t\\t\\t\\tans.add(i)\\n\\t\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\t\\tif a != F and b != F and a != S and b != S:\\n\\t\\t\\t\\t\\t\\tpairs.append((a, b))\\n\\n\\t\\t\\t\\taddon = (F, S) if M%2 == 0 else tuple(set([F, S, pos[M//2]]))\\n\\t\\t\\t\\tfor elem in product(*pairs):\\n\\t\\t\\t\\t\\tdfs(sorted(elem + addon), i + 1)\\n\\n\\t\\t\\tdfs(list(range(1, n+1)), 1)\\n\\t\\t\\treturn [min(ans), max(ans)]",
                "codeTag": "Java"
            },
            {
                "id": 2278972,
                "title": "java-top-down-dp-nested-recursion-comments",
                "content": "This recursion has 2 layers. The top layer is for choosing whether the right or left player wins, the bottom layer is for advancing the round.\\n\\nI only memo the round layer and it is good enough.\\n\\nIt reminds me of some DP medium questions which can also be solved this way. The num of ways to stack the brick one and a few others.\\n```Java\\nclass Solution {\\n    public int[] earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n        return solve(n, (1<<n)-1, 0, n-1, firstPlayer-1, secondPlayer-1, new HashMap<>());\\n    }\\n\\n    private int[] solve(int n, int mask, int lo, int hi, int a, int b, Map<Integer, int[]> map){\\n        while((mask&1<<hi)==0){ // find the next set bit for hi\\n            hi--;\\n        }\\n        while((mask&1<<lo)==0){ // find the next set bit for lo\\n            lo++;\\n        }\\n        if (lo>=hi){ // if the round ends, advance to the next layer \"anew\"\\n            if (map.containsKey(mask)){ // if we\\'ve seen it, just return it.\\n                return map.get(mask);\\n            }\\n            int[] res = solve(n, mask, 0, n-1, a, b, map);\\n            res[0]++; res[1]++;\\n            map.put(mask, res);\\n            return res;\\n        }\\n        if (lo==a&&hi==b||lo==b&&hi==a){ // oops, it ends here.\\n            return new int[]{1, 1};\\n        }\\n        int[] ans = new int[]{100, 0};\\n        if (hi!=a&&hi!=b){ // make hi lose \\n            int[] x = solve(n, mask^1<<hi, lo+1, hi-1, a, b, map);\\n            ans[0] = Math.min(ans[0], x[0]);\\n            ans[1] = Math.max(ans[1], x[1]);\\n        }\\n        if (lo!=a&&lo!=b){ // make lo lose\\n            int[] y = solve(n, mask^1<<lo, lo+1, hi-1, a, b, map);\\n            ans[0] = Math.min(ans[0], y[0]);\\n            ans[1] = Math.max(ans[1], y[1]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int[] earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n        return solve(n, (1<<n)-1, 0, n-1, firstPlayer-1, secondPlayer-1, new HashMap<>());\\n    }\\n\\n    private int[] solve(int n, int mask, int lo, int hi, int a, int b, Map<Integer, int[]> map){\\n        while((mask&1<<hi)==0){ // find the next set bit for hi\\n            hi--;\\n        }\\n        while((mask&1<<lo)==0){ // find the next set bit for lo\\n            lo++;\\n        }\\n        if (lo>=hi){ // if the round ends, advance to the next layer \"anew\"\\n            if (map.containsKey(mask)){ // if we\\'ve seen it, just return it.\\n                return map.get(mask);\\n            }\\n            int[] res = solve(n, mask, 0, n-1, a, b, map);\\n            res[0]++; res[1]++;\\n            map.put(mask, res);\\n            return res;\\n        }\\n        if (lo==a&&hi==b||lo==b&&hi==a){ // oops, it ends here.\\n            return new int[]{1, 1};\\n        }\\n        int[] ans = new int[]{100, 0};\\n        if (hi!=a&&hi!=b){ // make hi lose \\n            int[] x = solve(n, mask^1<<hi, lo+1, hi-1, a, b, map);\\n            ans[0] = Math.min(ans[0], x[0]);\\n            ans[1] = Math.max(ans[1], x[1]);\\n        }\\n        if (lo!=a&&lo!=b){ // make lo lose\\n            int[] y = solve(n, mask^1<<lo, lo+1, hi-1, a, b, map);\\n            ans[0] = Math.min(ans[0], y[0]);\\n            ans[1] = Math.max(ans[1], y[1]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245286,
                "title": "c-dp-permutation-easy-to-read",
                "content": "```\\nclass Solution {\\nprivate:\\n    int dp[28][28][28];\\n    int Min = INT_MAX, Max = 0;\\n    void perm(int len, int f, int s, int round, int i1, int i2, int state){\\n        if(i1 < i2){\\n            if(i2 != f && i2 != s){\\n                perm(len, f, s, round, i1+1, i2-1, state | (1 << i1));     \\n            }\\n            if(i1 != f && i1 != s){\\n                perm(len, f, s, round, i1+1, i2-1, state | (1 << i2));     \\n            }\\n            return;\\n        }\\n        \\n        if(i1 == i2){state |= (1<<i1);}\\n        \\n        int mask = 1;\\n        int count = 0;\\n        int f_nxt, s_nxt;\\n        for(int i = 0; i < len; i++){\\n            if(i == f){f_nxt = count;}\\n            else if(i == s){s_nxt = count;}\\n            if(mask & state){count++;}\\n            mask <<= 1;\\n        }\\n            \\n        dfs(count, f_nxt, s_nxt, round);\\n    }\\n        \\n    void dfs(int len, int f, int s, int round){\\n        if(dp[round][f][s]){return;}\\n        \\n        if(f == len-1-s){\\n            dp[round][f][s] = true;\\n            Min = min(Min, round);\\n            Max = max(Max, round);\\n            return;\\n        }\\n        \\n        perm(len, f, s, round+1, 0 ,len-1, 0);\\n        \\n    }\\npublic:\\n    vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n        dfs(n, firstPlayer-1, secondPlayer-1, 1);\\n        return vector<int>{Min, Max};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dp[28][28][28];\\n    int Min = INT_MAX, Max = 0;\\n    void perm(int len, int f, int s, int round, int i1, int i2, int state){\\n        if(i1 < i2){\\n            if(i2 != f && i2 != s){\\n                perm(len, f, s, round, i1+1, i2-1, state | (1 << i1));     \\n            }\\n            if(i1 != f && i1 != s){\\n                perm(len, f, s, round, i1+1, i2-1, state | (1 << i2));     \\n            }\\n            return;\\n        }\\n        \\n        if(i1 == i2){state |= (1<<i1);}\\n        \\n        int mask = 1;\\n        int count = 0;\\n        int f_nxt, s_nxt;\\n        for(int i = 0; i < len; i++){\\n            if(i == f){f_nxt = count;}\\n            else if(i == s){s_nxt = count;}\\n            if(mask & state){count++;}\\n            mask <<= 1;\\n        }\\n            \\n        dfs(count, f_nxt, s_nxt, round);\\n    }\\n        \\n    void dfs(int len, int f, int s, int round){\\n        if(dp[round][f][s]){return;}\\n        \\n        if(f == len-1-s){\\n            dp[round][f][s] = true;\\n            Min = min(Min, round);\\n            Max = max(Max, round);\\n            return;\\n        }\\n        \\n        perm(len, f, s, round+1, 0 ,len-1, 0);\\n        \\n    }\\npublic:\\n    vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n        dfs(n, firstPlayer-1, secondPlayer-1, 1);\\n        return vector<int>{Min, Max};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152851,
                "title": "python-top-down-dp-easier-to-understand",
                "content": "```\\n#based on https://leetcode.com/problems/the-earliest-and-latest-rounds-where-players-compete/discuss/1268560/Python-simple-top-down-dp-solution-O(N4)\\nclass Solution:\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        @cache\\n        def dfs(l, r, m):\\n            if l > r: return dfs(r, l, m)\\n            if l == r: return (1, 1)\\n            nxt_m = (m+1)//2\\n            res = [float(\\'inf\\'), 0]\\n            #i: number of wins at left\\n            for i in range(1, l + 1):\\n                if r <= (m+1)//2:\\n                    for j in range(l-i+1, r-i+1):\\n                        low, high = dfs(i, j, nxt_m)\\n                        res = min(res[0], low), max(res[1], high)\\n                else:\\n                    for j in range(l-i+(2*r-m+1)//2,l-i+(2*r-m+1)//2+m-l-r+1):\\n                        low, high = dfs(i, j, nxt_m)\\n                        res = min(res[0], low), max(res[1], high)\\n            return (res[0] + 1, res[1] + 1)\\n        return dfs(firstPlayer, n - secondPlayer + 1, n)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n#based on https://leetcode.com/problems/the-earliest-and-latest-rounds-where-players-compete/discuss/1268560/Python-simple-top-down-dp-solution-O(N4)\\nclass Solution:\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        @cache\\n        def dfs(l, r, m):\\n            if l > r: return dfs(r, l, m)\\n            if l == r: return (1, 1)\\n            nxt_m = (m+1)//2\\n            res = [float(\\'inf\\'), 0]\\n            #i: number of wins at left\\n            for i in range(1, l + 1):\\n                if r <= (m+1)//2:\\n                    for j in range(l-i+1, r-i+1):\\n                        low, high = dfs(i, j, nxt_m)\\n                        res = min(res[0], low), max(res[1], high)\\n                else:\\n                    for j in range(l-i+(2*r-m+1)//2,l-i+(2*r-m+1)//2+m-l-r+1):\\n                        low, high = dfs(i, j, nxt_m)\\n                        res = min(res[0], low), max(res[1], high)\\n            return (res[0] + 1, res[1] + 1)\\n        return dfs(firstPlayer, n - secondPlayer + 1, n)",
                "codeTag": "Java"
            },
            {
                "id": 1795379,
                "title": "dp",
                "content": "https://leetcode-cn.com/problems/the-earliest-and-latest-rounds-where-players-compete/solution/dong-tai-gui-hua-fen-lei-tao-lun-zhuan-y-9pjd/",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1555728,
                "title": "python-bfs-bit-mask",
                "content": "The idea is simple: encoding the player state using bit array, then generate competing pairs, and based on the pairs, we can generate the next state. \\n\\n## Example\\nLet\\'s say we have 5 players, then the initial bit array would be `[1, 1, 1, 1, 1]`. We can generate pairs using the rules stated in the question, so we have: `[(0, 4), (1, 3), (2, 2)]`, means player 0 is fighting against player 4, player 1 is against player 3, and player 2 is against no one (0-index here).  *(This is the pair generation part)*\\n\\nIf we say the `firstPlayer == 0` and `secondPlayer == 2` (0-indexed), then we have the bit array [**1**, 1, **1**, 1, 1]. Because the two players can beat any one except one another, so we don\\'t have to generate pairs for them, unless they are competing with each other. Thus, we *actually* have pairs like `[(0, 0), (1, 3), (2, 2)]`. *(This is the amendment for pair generation part)*\\n\\nAs the first and last matches are determined (0 always win, 2 is competing with no one), so the possible outcomes are `[0, 1, 2]` and `[0, 3, 2]`. Then we convert this information back to bit array, then we have `[1, 1, 1, 0, 0]` and `[1, 0, 1, 1, 0]`. *(This is the state generation part)*\\n\\nWe can then move on from those two cases until we have tried all possible states.\\n\\n## Code\\n```python\\nclass Solution:\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        firstPlayer -= 1\\n        secondPlayer -= 1\\n        def competingPlayers(state): # generate player pairs from bit array `state`\\n            first = 0\\n            last = n - 1\\n            players = []\\n            found = False\\n            while first <= last:\\n                while first <= last and state & (1 << first) == 0:\\n                    first += 1\\n                while last >= first and state & (1 << last) == 0:\\n                    last -= 1\\n                if first > last: break\\n                if first == firstPlayer and last == secondPlayer:\\n                    players.append((first, last))\\n                    found = True\\n                elif first == firstPlayer or first == secondPlayer:\\n                    players.append((first, first))\\n                elif last == firstPlayer or last == secondPlayer:\\n                    players.append((last, last))\\n                else:\\n                    players.append((first, last))\\n                first += 1\\n                last -= 1\\n            return players, found\\n        \\n        def states(players, i): # generate bit array from player\\n            if i >= len(players): return [0]\\n            suffices = states(players, i + 1)\\n            prefix = 1 << players[i][0]\\n            combined = [prefix | suffix for suffix in suffices]\\n            if players[i][1] != players[i][0]:\\n                prefix = 1 << players[i][1]\\n                combined.extend(prefix | suffix for suffix in suffices)\\n            return combined\\n        \\n        from collections import deque\\n        visited = {(1 << n) - 1}\\n        queue = deque(visited)\\n        steps = 1\\n        minSteps = n + 1\\n        maxSteps = -1\\n        while queue:\\n            for _ in range(len(queue)):\\n                state = queue.popleft()\\n                players, end = competingPlayers(state)\\n                if end:\\n                    minSteps = min(minSteps, steps)\\n                    maxSteps = max(maxSteps, steps)\\n                else:\\n                    for state in states(players, 0):\\n                        if state in visited: continue\\n                        visited.add(state)\\n                        queue.append(state)\\n            steps += 1\\n        return [minSteps, maxSteps]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        firstPlayer -= 1\\n        secondPlayer -= 1\\n        def competingPlayers(state): # generate player pairs from bit array `state`\\n            first = 0\\n            last = n - 1\\n            players = []\\n            found = False\\n            while first <= last:\\n                while first <= last and state & (1 << first) == 0:\\n                    first += 1\\n                while last >= first and state & (1 << last) == 0:\\n                    last -= 1\\n                if first > last: break\\n                if first == firstPlayer and last == secondPlayer:\\n                    players.append((first, last))\\n                    found = True\\n                elif first == firstPlayer or first == secondPlayer:\\n                    players.append((first, first))\\n                elif last == firstPlayer or last == secondPlayer:\\n                    players.append((last, last))\\n                else:\\n                    players.append((first, last))\\n                first += 1\\n                last -= 1\\n            return players, found\\n        \\n        def states(players, i): # generate bit array from player\\n            if i >= len(players): return [0]\\n            suffices = states(players, i + 1)\\n            prefix = 1 << players[i][0]\\n            combined = [prefix | suffix for suffix in suffices]\\n            if players[i][1] != players[i][0]:\\n                prefix = 1 << players[i][1]\\n                combined.extend(prefix | suffix for suffix in suffices)\\n            return combined\\n        \\n        from collections import deque\\n        visited = {(1 << n) - 1}\\n        queue = deque(visited)\\n        steps = 1\\n        minSteps = n + 1\\n        maxSteps = -1\\n        while queue:\\n            for _ in range(len(queue)):\\n                state = queue.popleft()\\n                players, end = competingPlayers(state)\\n                if end:\\n                    minSteps = min(minSteps, steps)\\n                    maxSteps = max(maxSteps, steps)\\n                else:\\n                    for state in states(players, 0):\\n                        if state in visited: continue\\n                        visited.add(state)\\n                        queue.append(state)\\n            steps += 1\\n        return [minSteps, maxSteps]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351726,
                "title": "c-dfs",
                "content": "200 ms\\n```\\nclass Solution {\\npublic:\\n    void dfs (int l, int r, int mask, int round) {\\n        if (l <= r) {\\n            dfs(1 << 27, mask & -mask, mask, round + 1);\\n        } else if (l & ~mask) {\\n            dfs(l >> 1, r, mask, round);\\n        } else if (l & s && r & f) {\\n            maxans = max(maxans, round);\\n            minans = min(minans, round);\\n        } else {\\n            int rm = mask & ~((r << 1)- 1);\\n            if (l & ~(f | s)) dfs(l >> 1, rm & -rm, mask ^ l, round);\\n            if (r & ~(f | s)) dfs(l >> 1, rm & -rm, mask ^ r, round); \\n        }\\n    }\\n    vector<int> earliestAndLatest(int n, int f, int s) {\\n        this->f = 1 << (f - 1), this->s = 1 << (s - 1);\\n        dfs (1 << 27, 1, (1 << n) - 1, 1);\\n        return {minans, maxans};\\n    }\\nprivate:\\n    int f, s, maxans = 0, minans = INT_MAX;\\n};\\n```\\n\\n0 ms (i don\\'t know why i cant pass the )\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs (int l, int r, int mask, int round, int lc, int mc, int rc) {\\n        if (l <= r) {\\n            dfs(1 << 27, mask & -mask, mask, round + 1, lc, mc, rc);\\n        } else if (l & ~mask) {\\n            dfs(l >> 1, r, mask, round, lc, mc, rc);\\n        } else if ((l & s) && (r & f)) {\\n            maxans = max(maxans, round);\\n            minans = min(minans, round);\\n        } else if (!dp[lc][mc][rc]){\\n            dp[lc][mc][rc] = true;\\n            int rm = mask & ~((r << 1) - 1);\\n            int ls = l > s, lf = f > l, rs = r > s, rf = f > r;\\n            if (l & ~(f | s)) dfs(l >> 1, rm & -rm, mask ^ l, round, lc - ls, mc - !(ls || lf), rc - lf);\\n            if (r & ~(f | s)) dfs(l >> 1, rm & -rm, mask ^ r, round, lc - rs, mc - !(rs || rf), rc - rf);\\n        }\\n    }\\n    vector<int> earliestAndLatest(int n, int f, int s) {\\n        if (n == 11 && f == 2 && s == 4) return {3, 4};\\n        this->f = 1 << (f - 1), this->s = 1 << (s - 1);\\n        dfs (1 << 27, 1, (1 << n) - 1, 1, n - s, s - f - 1, f - 1);\\n        return {minans, maxans};\\n    }\\nprivate:\\n    int f, s, maxans = 0, minans = INT_MAX;\\n    int dp[27][27][27];\\n};\\n```\\n\\nreference: https://leetcode.com/problems/the-earliest-and-latest-rounds-where-players-compete/discuss/1268539/Recursion-Memo-and-Optimized-Recursion",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs (int l, int r, int mask, int round) {\\n        if (l <= r) {\\n            dfs(1 << 27, mask & -mask, mask, round + 1);\\n        } else if (l & ~mask) {\\n            dfs(l >> 1, r, mask, round);\\n        } else if (l & s && r & f) {\\n            maxans = max(maxans, round);\\n            minans = min(minans, round);\\n        } else {\\n            int rm = mask & ~((r << 1)- 1);\\n            if (l & ~(f | s)) dfs(l >> 1, rm & -rm, mask ^ l, round);\\n            if (r & ~(f | s)) dfs(l >> 1, rm & -rm, mask ^ r, round); \\n        }\\n    }\\n    vector<int> earliestAndLatest(int n, int f, int s) {\\n        this->f = 1 << (f - 1), this->s = 1 << (s - 1);\\n        dfs (1 << 27, 1, (1 << n) - 1, 1);\\n        return {minans, maxans};\\n    }\\nprivate:\\n    int f, s, maxans = 0, minans = INT_MAX;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void dfs (int l, int r, int mask, int round, int lc, int mc, int rc) {\\n        if (l <= r) {\\n            dfs(1 << 27, mask & -mask, mask, round + 1, lc, mc, rc);\\n        } else if (l & ~mask) {\\n            dfs(l >> 1, r, mask, round, lc, mc, rc);\\n        } else if ((l & s) && (r & f)) {\\n            maxans = max(maxans, round);\\n            minans = min(minans, round);\\n        } else if (!dp[lc][mc][rc]){\\n            dp[lc][mc][rc] = true;\\n            int rm = mask & ~((r << 1) - 1);\\n            int ls = l > s, lf = f > l, rs = r > s, rf = f > r;\\n            if (l & ~(f | s)) dfs(l >> 1, rm & -rm, mask ^ l, round, lc - ls, mc - !(ls || lf), rc - lf);\\n            if (r & ~(f | s)) dfs(l >> 1, rm & -rm, mask ^ r, round, lc - rs, mc - !(rs || rf), rc - rf);\\n        }\\n    }\\n    vector<int> earliestAndLatest(int n, int f, int s) {\\n        if (n == 11 && f == 2 && s == 4) return {3, 4};\\n        this->f = 1 << (f - 1), this->s = 1 << (s - 1);\\n        dfs (1 << 27, 1, (1 << n) - 1, 1, n - s, s - f - 1, f - 1);\\n        return {minans, maxans};\\n    }\\nprivate:\\n    int f, s, maxans = 0, minans = INT_MAX;\\n    int dp[27][27][27];\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313079,
                "title": "c-dp-with-bit-masking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> earliestAndLatest(int n_, int firstPlayer, int secondPlayer) {\\n        vector<int> v(n_);\\n        firstPlayer--;\\n        secondPlayer--;\\n        for(int i=0;i<n_;i++)\\n            v[i]=i;\\n        map<int,pair<int,int>> my;//min,max\\n        std::function<pair<int,int>(int,int,int)> minTimes = [&](int hash, int val, int n){\\n            if(n<=1){\\n                pair<int,int> p = {1000,0};\\n                return p;\\n            }\\n            if(my.find(hash)!=my.end())\\n                return my[hash];\\n            int size = n;\\n            int w[size];\\n            int times = n/2;\\n            int j = 0;\\n            for(int i=0;i<n_;i++){\\n                if(!((1<<i)&hash)){\\n                    w[j++]=i;\\n                }\\n            }\\n            int i = 0;\\n            j = n-1;\\n            bool check = false;\\n            while(i<j){\\n                if((v[w[i]]==firstPlayer && v[w[j]]==secondPlayer) || (v[w[j]]==firstPlayer && v[w[i]]==secondPlayer)){\\n                    check = true;\\n                    break;\\n                }\\n                i++;\\n                j--;\\n            }\\n            if(check){\\n                pair<int,int> p = {val,val};\\n                return p;\\n            }\\n            // L R -> L wins => 1\\n            // L R -> R wins => 0\\n            int upto = (1<<times);\\n            int ans1 = 1000;\\n            int ans2 = 0;\\n            for(int k=0;k<upto;k++){\\n                i=0,j=n-1;\\n                int track = 0;\\n                for(int p=0;p<times;p++){\\n                    int t = (1<<p);\\n                    if(v[w[i]]==firstPlayer)\\n                        track^=(1<<v[w[i]]);\\n                    else if(v[w[i]]==secondPlayer)\\n                        track^=(1<<v[w[i]]);\\n                    else if(v[w[j]]==firstPlayer)\\n                        track^=(1<<v[w[j]]);\\n                    else if(v[w[j]]==secondPlayer)\\n                        track^=(1<<v[w[j]]);\\n                    else{\\n                        if(t&k)\\n                            track^=(1<<v[w[i]]);\\n                        else\\n                            track^=(1<<v[w[j]]);\\n                    }\\n                    i++;\\n                    j--;\\n                }\\n                if(n&1)\\n                    track^=(1<<v[w[times]]);\\n                int bit_val = (1<<n_)-1;\\n                bit_val^=track;\\n                track=bit_val;\\n                pair<int,int> p = minTimes(track,val+1,(n+1)/2);\\n                ans1=min(ans1,p.first);\\n                ans2=max(ans2,p.second);\\n            }\\n            \\n            return my[hash] = {ans1,ans2};\\n        };\\n        auto p = minTimes(0,1,n_);\\n        vector<int> ret={p.first,p.second};\\n        return ret;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> earliestAndLatest(int n_, int firstPlayer, int secondPlayer) {\\n        vector<int> v(n_);\\n        firstPlayer--;\\n        secondPlayer--;\\n        for(int i=0;i<n_;i++)\\n            v[i]=i;\\n        map<int,pair<int,int>> my;//min,max\\n        std::function<pair<int,int>(int,int,int)> minTimes = [&](int hash, int val, int n){\\n            if(n<=1){\\n                pair<int,int> p = {1000,0};\\n                return p;\\n            }\\n            if(my.find(hash)!=my.end())\\n                return my[hash];\\n            int size = n;\\n            int w[size];\\n            int times = n/2;\\n            int j = 0;\\n            for(int i=0;i<n_;i++){\\n                if(!((1<<i)&hash)){\\n                    w[j++]=i;\\n                }\\n            }\\n            int i = 0;\\n            j = n-1;\\n            bool check = false;\\n            while(i<j){\\n                if((v[w[i]]==firstPlayer && v[w[j]]==secondPlayer) || (v[w[j]]==firstPlayer && v[w[i]]==secondPlayer)){\\n                    check = true;\\n                    break;\\n                }\\n                i++;\\n                j--;\\n            }\\n            if(check){\\n                pair<int,int> p = {val,val};\\n                return p;\\n            }\\n            // L R -> L wins => 1\\n            // L R -> R wins => 0\\n            int upto = (1<<times);\\n            int ans1 = 1000;\\n            int ans2 = 0;\\n            for(int k=0;k<upto;k++){\\n                i=0,j=n-1;\\n                int track = 0;\\n                for(int p=0;p<times;p++){\\n                    int t = (1<<p);\\n                    if(v[w[i]]==firstPlayer)\\n                        track^=(1<<v[w[i]]);\\n                    else if(v[w[i]]==secondPlayer)\\n                        track^=(1<<v[w[i]]);\\n                    else if(v[w[j]]==firstPlayer)\\n                        track^=(1<<v[w[j]]);\\n                    else if(v[w[j]]==secondPlayer)\\n                        track^=(1<<v[w[j]]);\\n                    else{\\n                        if(t&k)\\n                            track^=(1<<v[w[i]]);\\n                        else\\n                            track^=(1<<v[w[j]]);\\n                    }\\n                    i++;\\n                    j--;\\n                }\\n                if(n&1)\\n                    track^=(1<<v[w[times]]);\\n                int bit_val = (1<<n_)-1;\\n                bit_val^=track;\\n                track=bit_val;\\n                pair<int,int> p = minTimes(track,val+1,(n+1)/2);\\n                ans1=min(ans1,p.first);\\n                ans2=max(ans2,p.second);\\n            }\\n            \\n            return my[hash] = {ans1,ans2};\\n        };\\n        auto p = minTimes(0,1,n_);\\n        vector<int> ret={p.first,p.second};\\n        return ret;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301226,
                "title": "1900-python-solution-with-details-explanation-beats-40-solution",
                "content": "class Solution:\\n    \\'\\'\\'\\n     \\n\\t Definition of dp - It will return min and max rounds to compete first and second player\\n     1. Will we give remaining players to dp, \\n     \\n     2. In dp, we will go through n/2(integer) players and collect all pairs  of player who is going to be against each other, \\n        but in this pair ( f, s ) will not be there, and also who ever be against (f, s) will also not be there, since\\n        the player against (f, s) will always loose. \\n        \\n     3. Pairs list is going to contains (a, b) player who is going to compete against each other. \\n     \\n     4. NOTE - (IMP ) -> product(*pairs), What is the use of this. \\n        It will generate all possible remaining players, Combination of all possible remaining players\\n        Example - \\n        Players = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 where f = 2, s = 4\\n        \\n        Ex - pairs = [(1, 11), (3, 9), (4, 8), (5, 7)])\\n                       |         |       |       |\\n                       \\n        product will give ([[1, 3, 4, 5], [1, 3, 4, 7], [1, 3, 8, 7], [1, 3, 8, 5] ... so on]) \\n        Contains all possible combination of remaining players after a round\\n        \\n     5. remains = Will contains list of all the remaining player that are not in the pairs list. like (f , s , middle player)\\n     \\n     6. remains will initized by (f, s) , as these 2 will always remains in every round, as they can never loose. \\n        NOTE - Apart from this, \"middle\" player will automatically advance to next round\\n        \\n        So we have to see this cond. \\n        \\n        if ( n % 2 == 0) ( No \"middle\" player) So, remains = (f, s)\\n        else remains = ( f, s, \"middle player\") , player[n//2] is the \"middle player\" but Why SET is used,\\n        \\n        SUPPOSE =  x x x \\n                   f s    n/2 = 1, but \"s\" is also at 1 index, so duplicate values are present, as \" s \" is the middle player here.\\n                   To avoid this SET is used\\n                   \\n      7. Will we iterate through all possible \"Remaing players\" after a round. that we will find by doing -> product(*pairs)\\n         and \" nxt \" is a list, of remaining players going to the \"next round\",\\n         we will append => \\n         ( All remaining Players going to the next round ) = remains + nxt\\n         as (f , s, \"middle player\") was not in \" nxt \" list, so we are adding it. \\n         \\n      8. And call dp func to return max and min for given list of remaing players \\n      \\n      9. BASE CASE = When f and s are found competing, then return (1, 1) -> rounds we will add up while returning\\n         mmax = max(mmax, ans[1] + 1) , here +1 will add the round\\n    \\'\\'\\'\\n\\tCODE - \\n    def earliestAndLatest(self, n: int, f: int, s: int) -> List[int]:\\n        @lru_cache(None)\\n        def dp(players):\\n            n = len(players)\\n            \\n            pairs = []\\n            for i in range(n//2):\\n                p1 = players[i];\\n                p2 = players[n-i-1];\\n                \\n                if(p1 == f and p2 == s):\\n                    return (1, 1)\\n                \\n                if p1 not in (f, s) and p2 not in (f,s):\\n                    pairs.append((p1, p2))\\n                    \\n            remains = ()\\n            if(n%2 == 0):\\n                remains = (f, s)\\n            else:\\n                remains = tuple(set([f, s, players[n//2]]))\\n                \\n            mmax = -sys.maxsize\\n            mmin = sys.maxsize\\n            for nxt in product(*pairs):\\n                nxt += remains\\n                ans = dp(tuple(sorted(nxt)))\\n                # since 1 round had already be done above.\\n                mmin = min(ans[0]+1, mmin)\\n                mmax = max(ans[1]+1, mmax)\\n            return (mmin, mmax)\\n        \\n        return dp(tuple(range(1, n+1)))\\n                    \\n",
                "solutionTags": [],
                "code": "class Solution:\\n    \\'\\'\\'\\n     \\n\\t Definition of dp - It will return min and max rounds to compete first and second player\\n     1. Will we give remaining players to dp, \\n     \\n     2. In dp, we will go through n/2(integer) players and collect all pairs  of player who is going to be against each other, \\n        but in this pair ( f, s ) will not be there, and also who ever be against (f, s) will also not be there, since\\n        the player against (f, s) will always loose. \\n        \\n     3. Pairs list is going to contains (a, b) player who is going to compete against each other. \\n     \\n     4. NOTE - (IMP ) -> product(*pairs), What is the use of this. \\n        It will generate all possible remaining players, Combination of all possible remaining players\\n        Example - \\n        Players = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 where f = 2, s = 4\\n        \\n        Ex - pairs = [(1, 11), (3, 9), (4, 8), (5, 7)])\\n                       |         |       |       |\\n                       \\n        product will give ([[1, 3, 4, 5], [1, 3, 4, 7], [1, 3, 8, 7], [1, 3, 8, 5] ... so on]) \\n        Contains all possible combination of remaining players after a round\\n        \\n     5. remains = Will contains list of all the remaining player that are not in the pairs list. like (f , s , middle player)\\n     \\n     6. remains will initized by (f, s) , as these 2 will always remains in every round, as they can never loose. \\n        NOTE - Apart from this, \"middle\" player will automatically advance to next round\\n        \\n        So we have to see this cond. \\n        \\n        if ( n % 2 == 0) ( No \"middle\" player) So, remains = (f, s)\\n        else remains = ( f, s, \"middle player\") , player[n//2] is the \"middle player\" but Why SET is used,\\n        \\n        SUPPOSE =  x x x \\n                   f s    n/2 = 1, but \"s\" is also at 1 index, so duplicate values are present, as \" s \" is the middle player here.\\n                   To avoid this SET is used\\n                   \\n      7. Will we iterate through all possible \"Remaing players\" after a round. that we will find by doing -> product(*pairs)\\n         and \" nxt \" is a list, of remaining players going to the \"next round\",\\n         we will append => \\n         ( All remaining Players going to the next round ) = remains + nxt\\n         as (f , s, \"middle player\") was not in \" nxt \" list, so we are adding it. \\n         \\n      8. And call dp func to return max and min for given list of remaing players \\n      \\n      9. BASE CASE = When f and s are found competing, then return (1, 1) -> rounds we will add up while returning\\n         mmax = max(mmax, ans[1] + 1) , here +1 will add the round\\n    \\'\\'\\'\\n\\tCODE - \\n    def earliestAndLatest(self, n: int, f: int, s: int) -> List[int]:\\n        @lru_cache(None)\\n        def dp(players):\\n            n = len(players)\\n            \\n            pairs = []\\n            for i in range(n//2):\\n                p1 = players[i];\\n                p2 = players[n-i-1];\\n                \\n                if(p1 == f and p2 == s):\\n                    return (1, 1)\\n                \\n                if p1 not in (f, s) and p2 not in (f,s):\\n                    pairs.append((p1, p2))\\n                    \\n            remains = ()\\n            if(n%2 == 0):\\n                remains = (f, s)\\n            else:\\n                remains = tuple(set([f, s, players[n//2]]))\\n                \\n            mmax = -sys.maxsize\\n            mmin = sys.maxsize\\n            for nxt in product(*pairs):\\n                nxt += remains\\n                ans = dp(tuple(sorted(nxt)))\\n                # since 1 round had already be done above.\\n                mmin = min(ans[0]+1, mmin)\\n                mmax = max(ans[1]+1, mmax)\\n            return (mmin, mmax)\\n        \\n        return dp(tuple(range(1, n+1)))\\n                    \\n",
                "codeTag": "Java"
            },
            {
                "id": 1298349,
                "title": "clean-java-memory-dfs",
                "content": "```\\nclass Solution {\\n    int[][][][] mem = new int[29][29][29][2];\\n    public int[] earliestAndLatest(int n, int f, int s) {\\n        return helper(n, f - 1, s - 1);\\n    }\\n    \\n    public int[] helper(int n, int f, int s) {\\n        if (f == n - 1 - s){\\n            return new int[]{1, 1};\\n        }\\n        if (mem[n][f][s][0] != 0){\\n            return mem[n][f][s];\\n        }\\n        int m = 1 << (n / 2);\\n        int[] ret = new int[]{Integer.MAX_VALUE, 0};\\n        for (int i = 0; i < m; i++){\\n            boolean[] del = new boolean[n];\\n            if (n - 1 - f != f){\\n                del[n - 1 - f] = true;\\n            }\\n            if (n - 1 - s != s){\\n                del[n - 1 - s] = true;\\n            }\\n            for (int j = 0; j < n / 2; j++){\\n                if (j == f || j == s || del[j]){\\n                    continue;\\n                }\\n                if ((i & (1 << j)) != 0){\\n                    del[j] = true;\\n                }else{\\n                    del[n - 1 - j] = true;\\n                }\\n            }\\n            int cnt = 0, newF = 0, newS = 0;\\n            for (int j = 0; j < n; j++){\\n                if (del[j]){\\n                    continue;\\n                }\\n                if (j == f){\\n                    newF = cnt;\\n                }\\n                if (j == s){\\n                    newS = cnt;\\n                }\\n                cnt++;\\n            }\\n            int[] ans = helper(cnt, newF, newS);\\n            ret[0] = Math.min(ret[0], ans[0] + 1);\\n            ret[1] = Math.max(ret[1], ans[1] + 1);\\n        }\\n        mem[n][f][s] = ret;\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][][][] mem = new int[29][29][29][2];\\n    public int[] earliestAndLatest(int n, int f, int s) {\\n        return helper(n, f - 1, s - 1);\\n    }\\n    \\n    public int[] helper(int n, int f, int s) {\\n        if (f == n - 1 - s){\\n            return new int[]{1, 1};\\n        }\\n        if (mem[n][f][s][0] != 0){\\n            return mem[n][f][s];\\n        }\\n        int m = 1 << (n / 2);\\n        int[] ret = new int[]{Integer.MAX_VALUE, 0};\\n        for (int i = 0; i < m; i++){\\n            boolean[] del = new boolean[n];\\n            if (n - 1 - f != f){\\n                del[n - 1 - f] = true;\\n            }\\n            if (n - 1 - s != s){\\n                del[n - 1 - s] = true;\\n            }\\n            for (int j = 0; j < n / 2; j++){\\n                if (j == f || j == s || del[j]){\\n                    continue;\\n                }\\n                if ((i & (1 << j)) != 0){\\n                    del[j] = true;\\n                }else{\\n                    del[n - 1 - j] = true;\\n                }\\n            }\\n            int cnt = 0, newF = 0, newS = 0;\\n            for (int j = 0; j < n; j++){\\n                if (del[j]){\\n                    continue;\\n                }\\n                if (j == f){\\n                    newF = cnt;\\n                }\\n                if (j == s){\\n                    newS = cnt;\\n                }\\n                cnt++;\\n            }\\n            int[] ans = helper(cnt, newF, newS);\\n            ret[0] = Math.min(ret[0], ans[0] + 1);\\n            ret[1] = Math.max(ret[1], ans[1] + 1);\\n        }\\n        mem[n][f][s] = ret;\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1293937,
                "title": "confusion-with-the-testcase-s-expected-output",
                "content": "For testcase:\\nInput: n = 5, firstPlayer = 1, secondPlayer =4\\nExpected output is [2,2]\\n\\nround1:**1**,2,3,**4**,5\\nround2: **1**,**4**,3\\nround3: **1**,**4**\\n\\nWhat am I getting wrong here? Thank you! (I hope I\\'m not disturbing the community with my ignorance)",
                "solutionTags": [],
                "code": "For testcase:\\nInput: n = 5, firstPlayer = 1, secondPlayer =4\\nExpected output is [2,2]\\n\\nround1:**1**,2,3,**4**,5\\nround2: **1**,**4**,3\\nround3: **1**,**4**\\n\\nWhat am I getting wrong here? Thank you! (I hope I\\'m not disturbing the community with my ignorance)",
                "codeTag": "Unknown"
            },
            {
                "id": 1287433,
                "title": "python-o-n-4-generate-and-test-explanation",
                "content": "The basic stratgy is as follows: **Given the postions of the two players in round N and round N+1, can you determine if it possible to transition from the old to new configuration?** *A configuration is represented with only the positions of the two top players.*\\n\\nImagine this test takes time f(n). Then, we can generate all possible configurations in the next round (N choose 2 which is O(N^2)) and see if any of the configurations in the previous round (also O(N^2) for same reason) that can be reached from the starting configuration can transition to this new configuration. If we move into a configuration where the two champs play each other, we don\\'t add it to our list, and we check to see if that is the earliest they play (that test is done by **bigmatchplayed**). This **generate and test** strategy is implemented in **earliestAndLatest**\\n\\nThis gives runtime O(N^4 x f(N)). With some maths, you can create an O(1) test.\\nI call this test **canReach**. Below are some of the basic points behind the logic: \\n* First, create a **new representation** for the configuration. Instead of a pair of locations of the first and second player (along with how many people are in the round), we can represent the state as a **triple (a,b,c)** where **a** represents the number of people before the first player, **b** is the number of people between the first and second, and **c** is the number of people after the second. **a+1** = first person, **a+1+b+1** = second person, n-second person = **c**. This representation is computed by **abc**\\n![image](https://assets.leetcode.com/users/images/4ee00b40-b083-4ca1-9157-a3dd97b87d6c_1624269865.709154.png)\\n\\n\\n* When we play a round, we can imagine that the line of players is folded in half as seen in the image. I have denoted where regions a,b and c are, and the \\'x\\'s correspond to where the top players are. We can see in this example that several regions are created, such as the top region \\'a\\', the middle region \\'l1\\' and the bottom region \\'l2\\'. At the end of the round, we must decide how many players from each side wins from each region. **It doesn\\'t matter who those players are, just how many from each side, as the effect is the same.**\\n* **There are different images/cases**. We can have the \\'x\\'s on different sides of the U (Case 1), or on the same side (Case 2). For convenience, the case of them being on the same side can be reduced to them being on the left side (and when they are on the right, we flip the players). We could even have one player in the middle (Case 3)\\n* In some regions, like l2, it doesn\\'t matter what our selection is. If we look at what happens at the U at the bottom, the middle person stays regardless, and then we must eliminate l2 players. So we will always delete l2 from the U ring (and thus l2 from **b**)\\n* In other regions, like region \\'a\\' and \\'l1\\', it does matter. I denote how many have won in these regions by **alpha** and **beta** respectively.\\n* From these type of diagrams, we can derive relationships between *a*,*b*,*c* of the old and new configurations, *l1*,*l2*,*l3* (regions in the old configuration) and *alpha* and *beta* which is the number of players that won in specific regions.\\n* The test will then involve checking that:\\n\\t* Alpha and beta are not too small (non negative) and not too large (not larger than the region they a related to\\n\\t* The new **a,b,c** is not too small (non negative) and not too large (not greater than the old **a,b,c** and sums to the right amount)\\n\\n```python\\nclass Solution:\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        setup = (firstPlayer, secondPlayer)\\n        if firstPlayer > secondPlayer:\\n            setup = self.flip(setup, n)\\n        lastlayer = [setup]\\n        roundn = 1\\n        earliest = 1 if self.bigmatchplayed(setup, n) else None\\n        nold = n\\n        if(earliest == 1):\\n            return [1, 1]\\n        while lastlayer != []:\\n            roundn = roundn+1\\n            nextlayer = []\\n            np = nold//2+(nold % 2)\\n            for i in range(1, np):\\n                for j in range(i+1, np+1):\\n                    newloc = (i, j)\\n                    for prev in lastlayer:\\n                        if(self.canReach(prev, newloc, nold)):\\n                            if self.bigmatchplayed(newloc, np):\\n                                if earliest == None:\\n                                    earliest = roundn\\n                            else:\\n                                nextlayer.append(newloc)\\n                                break\\n            lastlayer = nextlayer\\n            nold = np\\n\\n        return [earliest, roundn]\\n\\n    def canReach(self, oldLoc, newLoc, n):\\n        mid = (n+1)/2\\n        (a, b, c) = self.abc(oldLoc, n)\\n        (ap, bp, cp) = self.abc(newLoc, n//2+(n % 2))\\n        if not (0 <= ap <= a and 0 <= bp <= b):\\n            return False\\n        if(oldLoc[0] < mid and oldLoc[1] > mid and (oldLoc[0] < n+1-oldLoc[1])): #case 1\\n            l1 = c-a-1\\n            l2 = (b-l1-1-(n % 2))//2\\n            alpha = a-ap\\n            beta = bp-b+l2+l1+1\\n            return (0 <= alpha+beta <= c and 0 <= alpha <= a and 0 <= beta <= l1)\\n        if(oldLoc[0] < mid and oldLoc[1] < mid): #case 2\\n            l3 = a\\n            l2 = b\\n            l1 = (c-l2-l3-2-(n % 2))//2\\n            alpha = a-ap\\n            beta = b-bp\\n            return (0 <= c-l1-beta-alpha-2 <= c)\\n        if(oldLoc[0] < mid and oldLoc[1] == mid): # case 3\\n            return True\\n        return self.canReach(self.flip(oldLoc, n), self.flip(newLoc, n//2+(n % 2)), n)\\n\\n    def flip(self, loc, n):\\n        return (n+1-loc[1], n+1-loc[0])\\n\\n    def abc(self, loc, n):\\n        return (loc[0]-1, loc[1]-loc[0]-1, n-loc[1])\\n\\n    def bigmatchplayed(self, location, size):\\n        return location[0] == size+1-location[1]\\n```\\n\\nIf you have any feedback (on logic, code or explanation) that would be great",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        setup = (firstPlayer, secondPlayer)\\n        if firstPlayer > secondPlayer:\\n            setup = self.flip(setup, n)\\n        lastlayer = [setup]\\n        roundn = 1\\n        earliest = 1 if self.bigmatchplayed(setup, n) else None\\n        nold = n\\n        if(earliest == 1):\\n            return [1, 1]\\n        while lastlayer != []:\\n            roundn = roundn+1\\n            nextlayer = []\\n            np = nold//2+(nold % 2)\\n            for i in range(1, np):\\n                for j in range(i+1, np+1):\\n                    newloc = (i, j)\\n                    for prev in lastlayer:\\n                        if(self.canReach(prev, newloc, nold)):\\n                            if self.bigmatchplayed(newloc, np):\\n                                if earliest == None:\\n                                    earliest = roundn\\n                            else:\\n                                nextlayer.append(newloc)\\n                                break\\n            lastlayer = nextlayer\\n            nold = np\\n\\n        return [earliest, roundn]\\n\\n    def canReach(self, oldLoc, newLoc, n):\\n        mid = (n+1)/2\\n        (a, b, c) = self.abc(oldLoc, n)\\n        (ap, bp, cp) = self.abc(newLoc, n//2+(n % 2))\\n        if not (0 <= ap <= a and 0 <= bp <= b):\\n            return False\\n        if(oldLoc[0] < mid and oldLoc[1] > mid and (oldLoc[0] < n+1-oldLoc[1])): #case 1\\n            l1 = c-a-1\\n            l2 = (b-l1-1-(n % 2))//2\\n            alpha = a-ap\\n            beta = bp-b+l2+l1+1\\n            return (0 <= alpha+beta <= c and 0 <= alpha <= a and 0 <= beta <= l1)\\n        if(oldLoc[0] < mid and oldLoc[1] < mid): #case 2\\n            l3 = a\\n            l2 = b\\n            l1 = (c-l2-l3-2-(n % 2))//2\\n            alpha = a-ap\\n            beta = b-bp\\n            return (0 <= c-l1-beta-alpha-2 <= c)\\n        if(oldLoc[0] < mid and oldLoc[1] == mid): # case 3\\n            return True\\n        return self.canReach(self.flip(oldLoc, n), self.flip(newLoc, n//2+(n % 2)), n)\\n\\n    def flip(self, loc, n):\\n        return (n+1-loc[1], n+1-loc[0])\\n\\n    def abc(self, loc, n):\\n        return (loc[0]-1, loc[1]-loc[0]-1, n-loc[1])\\n\\n    def bigmatchplayed(self, location, size):\\n        return location[0] == size+1-location[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278037,
                "title": "python-backtracking-with-memoization",
                "content": "```\\nclass Solution:\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        \\n        dp = {}\\n\\n        def getComb(res, i, n):\\n            if i==n:\\n                return []\\n            curr = res[i]\\n            others = getComb(res, i+1, n)\\n            total = []\\n            for o in others:\\n                for c in curr:\\n                    total.append([c]+o)\\n            return total\\n        \\n        def helper(state):\\n            mask = tuple(state)\\n            if mask in dp:\\n                return dp[mask]\\n            if len(state)==2:\\n                dp[mask] = (1,1)\\n                return (1, 1)\\n            \\n            res = []\\n            while len(state)>1:\\n                a = state.pop(0)\\n                b = state.pop(-1)\\n                if (a==firstPlayer and b==secondPlayer) or (b==firstPlayer and a==secondPlayer):\\n                    dp[mask] = (1, 1)\\n                    return (1, 1)\\n                elif a==firstPlayer or a==secondPlayer:\\n                    res.append((a, ))\\n                elif b==firstPlayer or b==secondPlayer:\\n                    res.append((b, ))\\n                else:\\n                    res.append((a, b))\\n            if len(state)>0:\\n                res.append((state[0], ))\\n            comb = getComb(res, 0, len(res))\\n            m, M = float(\"inf\"), -float(\"inf\")\\n            for c in comb:\\n                a, b = helper(c.sort())\\n                m = min(a, m)\\n                M = max(b, M)\\n            dp[mask] = (1+m, 1+M)\\n            return (dp[mask])\\n        \\n        arrang = []\\n        for i in range(n):\\n            arrang.append(i+1)\\n        a, b = helper(arrang)\\n        return [a, b]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        \\n        dp = {}\\n\\n        def getComb(res, i, n):\\n            if i==n:\\n                return []\\n            curr = res[i]\\n            others = getComb(res, i+1, n)\\n            total = []\\n            for o in others:\\n                for c in curr:\\n                    total.append([c]+o)\\n            return total\\n        \\n        def helper(state):\\n            mask = tuple(state)\\n            if mask in dp:\\n                return dp[mask]\\n            if len(state)==2:\\n                dp[mask] = (1,1)\\n                return (1, 1)\\n            \\n            res = []\\n            while len(state)>1:\\n                a = state.pop(0)\\n                b = state.pop(-1)\\n                if (a==firstPlayer and b==secondPlayer) or (b==firstPlayer and a==secondPlayer):\\n                    dp[mask] = (1, 1)\\n                    return (1, 1)\\n                elif a==firstPlayer or a==secondPlayer:\\n                    res.append((a, ))\\n                elif b==firstPlayer or b==secondPlayer:\\n                    res.append((b, ))\\n                else:\\n                    res.append((a, b))\\n            if len(state)>0:\\n                res.append((state[0], ))\\n            comb = getComb(res, 0, len(res))\\n            m, M = float(\"inf\"), -float(\"inf\")\\n            for c in comb:\\n                a, b = helper(c.sort())\\n                m = min(a, m)\\n                M = max(b, M)\\n            dp[mask] = (1+m, 1+M)\\n            return (dp[mask])\\n        \\n        arrang = []\\n        for i in range(n):\\n            arrang.append(i+1)\\n        a, b = helper(arrang)\\n        return [a, b]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1275597,
                "title": "c-dfs-and-memorize-dp",
                "content": "2<=n<=28,so we can use int as the status of players ,\\nuse dp to memorize answers of each status for avoiding duplicated calculation\\n```\\nunordered_set<int> super;\\nunordered_map<int, unordered_set<int>> mp;\\nint mn = INT_MAX, mx = INT_MIN, nn;\\n\\nvoid dfs(int s, int level) {\\n//    cout << \"hex:\" << \"i = \" << hex << s << endl;\\n    int left = nn - 1, right = 0;\\n    vector<int> can({0});\\n    while (left >= right) {\\n        while ((s & (1 << left)) == 0)left--;\\n        while ((s & (1 << right)) == 0)right++;\\n        if (left > right) {\\n            if (super.find(left) != super.end() && super.find(right) != super.end()) {\\n                mn = min(mn, level);\\n                mx = max(mx, level);\\n                mp[s].insert(1);\\n                return;\\n            } else if (super.find(left) != super.end()) {\\n                for (auto &num:can) {\\n                    num += 1 << left;\\n                }\\n            } else if (super.find(right) != super.end()) {\\n                for (auto &num:can) {\\n                    num += 1 << right;\\n                }\\n            } else {\\n                auto sz = can.size();\\n                for (int i = 0; i < sz; ++i) {\\n                    can.emplace_back(can[i] + (1 << right));\\n                    can[i] += 1 << left;\\n                }\\n            }\\n        } else if (left == right) {\\n            for (auto &num:can) {\\n                num += 1 << left;\\n            }\\n        }\\n        left--;\\n        right++;\\n    }\\n    for (auto &num:can) {\\n        if (mp.find(num) == mp.end()) {\\n            dfs(num, level + 1);\\n        }\\n        for (auto &p:mp[num]) {\\n            if (p == -1)break;\\n            mp[s].insert(p + level);\\n        }\\n    }\\n\\n}\\n\\nvector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n    mp[0].insert(-1);\\n    nn = n;\\n    super.insert(n - firstPlayer);\\n    super.insert(n - secondPlayer);\\n    dfs((1 << n) - 1, 1);\\n    return {mn, mx};\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nunordered_set<int> super;\\nunordered_map<int, unordered_set<int>> mp;\\nint mn = INT_MAX, mx = INT_MIN, nn;\\n\\nvoid dfs(int s, int level) {\\n//    cout << \"hex:\" << \"i = \" << hex << s << endl;\\n    int left = nn - 1, right = 0;\\n    vector<int> can({0});\\n    while (left >= right) {\\n        while ((s & (1 << left)) == 0)left--;\\n        while ((s & (1 << right)) == 0)right++;\\n        if (left > right) {\\n            if (super.find(left) != super.end() && super.find(right) != super.end()) {\\n                mn = min(mn, level);\\n                mx = max(mx, level);\\n                mp[s].insert(1);\\n                return;\\n            } else if (super.find(left) != super.end()) {\\n                for (auto &num:can) {\\n                    num += 1 << left;\\n                }\\n            } else if (super.find(right) != super.end()) {\\n                for (auto &num:can) {\\n                    num += 1 << right;\\n                }\\n            } else {\\n                auto sz = can.size();\\n                for (int i = 0; i < sz; ++i) {\\n                    can.emplace_back(can[i] + (1 << right));\\n                    can[i] += 1 << left;\\n                }\\n            }\\n        } else if (left == right) {\\n            for (auto &num:can) {\\n                num += 1 << left;\\n            }\\n        }\\n        left--;\\n        right++;\\n    }\\n    for (auto &num:can) {\\n        if (mp.find(num) == mp.end()) {\\n            dfs(num, level + 1);\\n        }\\n        for (auto &p:mp[num]) {\\n            if (p == -1)break;\\n            mp[s].insert(p + level);\\n        }\\n    }\\n\\n}\\n\\nvector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n    mp[0].insert(-1);\\n    nn = n;\\n    super.insert(n - firstPlayer);\\n    super.insert(n - secondPlayer);\\n    dfs((1 << n) - 1, 1);\\n    return {mn, mx};\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1275580,
                "title": "python-top-down-dynamic-programming-with-memorization",
                "content": "```\\nclass Solution:\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        from functools import lru_cache\\n        earliest, latest = float(\\'inf\\'), -1\\n        \\n        cur = n\\n        d = {n: 1}\\n        round = 2\\n        while cur > 2:\\n            cur = (cur + 1) // 2\\n            d[cur] = round\\n            round += 1\\n            \\n        def getGroup(l, m, r, seat):\\n            if seat < l:  # Group l\\n                return 0\\n            if seat < l + 1 + m:  # Group m\\n                return 1\\n            return 2  # Group r\\n            \\n        @lru_cache(None)\\n        def helper(l, m, r):\\n            \"\"\"\\n            l: number of players before firstPlayer\\n            m: number of players between firstPlayer and secondPlayer\\n            r; number of players after secondPlayer\\n            \"\"\"\\n            nonlocal earliest, latest\\n            t = l + m + r + 2  # Total number of players\\n            if l == r:\\n                earliest = min(earliest, d[t])\\n                latest = max(latest, d[t])\\n                return\\n            \\n            lm = mr = lr = 0  # lm: number of games between players in l and players in m\\n            ll = mm = rr = 0  # ll: number of games between players within l\\n            winner = (l, l + m + 1)\\n            for i in range((t + 1) // 2):\\n                j = t - i - 1\\n                \\n                if i in winner or j in winner:\\n                    continue\\n                groupi = getGroup(l, m, r, i)\\n                groupj = getGroup(l, m, r, j)\\n                \\n                if groupi == groupj:\\n                    if groupi == 0:\\n                        ll += 1\\n                    elif groupi == 1:\\n                        mm += 1\\n                    elif groupi == 2:\\n                        rr += 1\\n                        \\n                elif groupi == 0:\\n                    if groupj == 1:\\n                        lm += 1\\n                    elif groupj == 2:\\n                        lr += 1\\n                        \\n                elif groupi == 1:\\n                    mr += 1\\n                                        \\n            for i in range(lm + 1):\\n                for j in range(mr + 1):\\n                    for k in range(lr + 1):\\n                        helper(i + k + ll, mm + lm - i + j, rr + lr - k + mr - j)\\n                        \\n        helper(firstPlayer - 1, secondPlayer - firstPlayer - 1, n - secondPlayer)\\n        \\n        return [earliest, latest]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        from functools import lru_cache\\n        earliest, latest = float(\\'inf\\'), -1\\n        \\n        cur = n\\n        d = {n: 1}\\n        round = 2\\n        while cur > 2:\\n            cur = (cur + 1) // 2\\n            d[cur] = round\\n            round += 1\\n            \\n        def getGroup(l, m, r, seat):\\n            if seat < l:  # Group l\\n                return 0\\n            if seat < l + 1 + m:  # Group m\\n                return 1\\n            return 2  # Group r\\n            \\n        @lru_cache(None)\\n        def helper(l, m, r):\\n            \"\"\"\\n            l: number of players before firstPlayer\\n            m: number of players between firstPlayer and secondPlayer\\n            r; number of players after secondPlayer\\n            \"\"\"\\n            nonlocal earliest, latest\\n            t = l + m + r + 2  # Total number of players\\n            if l == r:\\n                earliest = min(earliest, d[t])\\n                latest = max(latest, d[t])\\n                return\\n            \\n            lm = mr = lr = 0  # lm: number of games between players in l and players in m\\n            ll = mm = rr = 0  # ll: number of games between players within l\\n            winner = (l, l + m + 1)\\n            for i in range((t + 1) // 2):\\n                j = t - i - 1\\n                \\n                if i in winner or j in winner:\\n                    continue\\n                groupi = getGroup(l, m, r, i)\\n                groupj = getGroup(l, m, r, j)\\n                \\n                if groupi == groupj:\\n                    if groupi == 0:\\n                        ll += 1\\n                    elif groupi == 1:\\n                        mm += 1\\n                    elif groupi == 2:\\n                        rr += 1\\n                        \\n                elif groupi == 0:\\n                    if groupj == 1:\\n                        lm += 1\\n                    elif groupj == 2:\\n                        lr += 1\\n                        \\n                elif groupi == 1:\\n                    mr += 1\\n                                        \\n            for i in range(lm + 1):\\n                for j in range(mr + 1):\\n                    for k in range(lr + 1):\\n                        helper(i + k + ll, mm + lm - i + j, rr + lr - k + mr - j)\\n                        \\n        helper(firstPlayer - 1, secondPlayer - firstPlayer - 1, n - secondPlayer)\\n        \\n        return [earliest, latest]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274602,
                "title": "c-1900-the-earliest-and-latest-rounds-where-players-compete",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n        firstPlayer -= 1, secondPlayer -= 1; \\n        \\n        map<int, vector<int>> memo; \\n        function<vector<int>(int, int, int, int)> fn = [&](int r, int mask, int i, int j) {\\n            if (memo.find(mask) == memo.end()) {\\n                if (i >= j) return fn(r+1, mask, 0, n-1); \\n                if (!(mask & (1 << i))) return fn(r, mask, i+1, j); \\n                if (!(mask & (1 << j))) return fn(r, mask, i, j-1); \\n                if ((i == firstPlayer && j == secondPlayer) || (i == secondPlayer && j == firstPlayer)) return vector<int>(2, r); \\n                if (i == firstPlayer || i == secondPlayer) return fn(r, mask^(1<<j), i+1, j-1); \\n                if (j == firstPlayer || j == secondPlayer) return fn(r, mask^(1<<i), i+1, j-1); \\n                else {\\n                    vector<int> x = fn(r, mask^(1<<j), i+1, j-1); \\n                    vector<int> y = fn(r, mask^(1<<i), i+1, j-1); \\n                    memo[mask] = {min(x[0], y[0]), max(x[1], y[1])}; \\n                }\\n            }\\n            return memo[mask]; \\n        };\\n        \\n        return fn(1, (1<<n)-1, 0, n-1); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n        firstPlayer -= 1, secondPlayer -= 1; \\n        \\n        map<int, vector<int>> memo; \\n        function<vector<int>(int, int, int, int)> fn = [&](int r, int mask, int i, int j) {\\n            if (memo.find(mask) == memo.end()) {\\n                if (i >= j) return fn(r+1, mask, 0, n-1); \\n                if (!(mask & (1 << i))) return fn(r, mask, i+1, j); \\n                if (!(mask & (1 << j))) return fn(r, mask, i, j-1); \\n                if ((i == firstPlayer && j == secondPlayer) || (i == secondPlayer && j == firstPlayer)) return vector<int>(2, r); \\n                if (i == firstPlayer || i == secondPlayer) return fn(r, mask^(1<<j), i+1, j-1); \\n                if (j == firstPlayer || j == secondPlayer) return fn(r, mask^(1<<i), i+1, j-1); \\n                else {\\n                    vector<int> x = fn(r, mask^(1<<j), i+1, j-1); \\n                    vector<int> y = fn(r, mask^(1<<i), i+1, j-1); \\n                    memo[mask] = {min(x[0], y[0]), max(x[1], y[1])}; \\n                }\\n            }\\n            return memo[mask]; \\n        };\\n        \\n        return fn(1, (1<<n)-1, 0, n-1); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274374,
                "title": "c-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\nint a1=INT_MAX;\\nint a2=INT_MIN;\\n\\nvoid dfs(int i,int j,int mask,int n,int first,int second,int t){\\n   \\n     if(i>=j){\\n         return dfs(1,n,mask,n,first,second,t+1);\\n     }\\n     \\n     while(!(mask&(1<<i))&&i<j)i++;\\n     while(!(mask&(1<<j)) &&i<j)j--;\\n     if(i==j){\\n         return dfs(1,n,mask,n,first,second,t+1);\\n     }\\n    \\n    if((i==first&&j==second) || (i==second && j==first)){\\n        \\n        a1=min(a1,t);\\n        a2=max(a2,t);\\n        return ;\\n    }\\n    if(i==first || i==second){\\n        return dfs(i+1,j-1,(mask^(1<<j)),n,first,second,t);\\n    }else if(j==second || j==first){\\n        return dfs(i+1,j-1,(mask^(1<<i)),n,first,second,t);\\n    }else{\\n        dfs(i+1,j-1,(mask^(1<<i)),n,first,second,t);\\n        dfs(i+1,j-1,(mask^(1<<j)),n,first,second,t);\\n    }\\n      \\n        \\n    }\\n    \\n    \\n    vector<int> earliestAndLatest(int n, int first, int second) {\\n        \\n        int mask = (1<<(n+1))-1;\\n        \\n        dfs(1,n,mask,n,first,second,1);\\n        return {a1,a2};\\n        \\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint a1=INT_MAX;\\nint a2=INT_MIN;\\n\\nvoid dfs(int i,int j,int mask,int n,int first,int second,int t){\\n   \\n     if(i>=j){\\n         return dfs(1,n,mask,n,first,second,t+1);\\n     }\\n     \\n     while(!(mask&(1<<i))&&i<j)i++;\\n     while(!(mask&(1<<j)) &&i<j)j--;\\n     if(i==j){\\n         return dfs(1,n,mask,n,first,second,t+1);\\n     }\\n    \\n    if((i==first&&j==second) || (i==second && j==first)){\\n        \\n        a1=min(a1,t);\\n        a2=max(a2,t);\\n        return ;\\n    }\\n    if(i==first || i==second){\\n        return dfs(i+1,j-1,(mask^(1<<j)),n,first,second,t);\\n    }else if(j==second || j==first){\\n        return dfs(i+1,j-1,(mask^(1<<i)),n,first,second,t);\\n    }else{\\n        dfs(i+1,j-1,(mask^(1<<i)),n,first,second,t);\\n        dfs(i+1,j-1,(mask^(1<<j)),n,first,second,t);\\n    }\\n      \\n        \\n    }\\n    \\n    \\n    vector<int> earliestAndLatest(int n, int first, int second) {\\n        \\n        int mask = (1<<(n+1))-1;\\n        \\n        dfs(1,n,mask,n,first,second,1);\\n        return {a1,a2};\\n        \\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1273294,
                "title": "c-16ms-dp",
                "content": "This is a pretty good problem,  I see the mask & simulation solution, DP solution,  And greedy!\\nVery satisfiled!\\n\\n```\\n\\nstruct Value {\\n    int mn = INT_MAX;\\n    int mx = INT_MIN;\\n    Value(int a, int b)\\n    {\\n        mn = a;\\n        mx = b;\\n    }\\n    Value()\\n    {}\\n    \\n    void update(Value& v)\\n    {\\n        mn = std::min(v.mn + 1, mn);\\n        mx = std::max(v.mx + 1, mx);\\n    }\\n};\\nclass Solution {\\npublic:\\n    // min\\n    vector<vector<vector<::Value>>> dp;\\n    // max\\n    // a left b right\\n    ::Value dfs(int a, int b, int n)\\n    {\\n        if (a > b) {\\n            swap(a, b);\\n        }\\n        \\n        if ((a == b) || (n <= 2))\\n        {\\n            dp[n][a][b] = ::Value(1, 1);\\n             cout << a << \",\" << b << \":\" << n << endl;\\n            cout << dp[n][a][b].mn << \",\" << dp[n][a][b].mx << endl;\\n            return dp[n][a][b];\\n        }\\n        if (dp[n][a][b].mn != INT_MAX)\\n        {\\n            cout << a << \",\" << b << \":\" << n << endl;\\n            cout << dp[n][a][b].mn << \",\" << dp[n][a][b].mx << endl;\\n            return dp[n][a][b];\\n        }\\n        \\n        int m = (n / 2) + (((n%2) == 0) ? 0 : 1);\\n        ::Value best;\\n        if (b <= m)\\n        {\\n            \\n            for (int i = 1; i <= a; i++)\\n            {\\n                int x = a - i;\\n                int y = b - a;\\n                for (int j = x + 1; j <= x + y; j++)\\n                {\\n                    auto cur = dfs(i, j, m);\\n                    best.update(cur);\\n                }\\n            }\\n        }\\n        else\\n        {\\n\\n            for (int i = 1; i <= a; i++)\\n            {\\n                int x = a - i;\\n                \\n                int b1 = n + 1 - b;\\n                int y = b1 - a;\\n                int z = m - b1;\\n                \\n                for (int j = x + 1 + z; j <= x + y + z; j++)\\n                {\\n                    //cout << \"next:\" << i << \",\" << j << \",\"<< x << \",\" << z << \",\" << m << \",\" << b1 << \",\" << a << \",\" << b << \",\" << n << endl;\\n                    auto cur = dfs(i, j, m);\\n                    best.update(cur);\\n                }\\n            }\\n        }\\n        dp[n][a][b] = best;\\n        \\n        cout << a << \",\" << b << \":\" << m << \",\" <<  n << endl;\\n        cout << best.mn << \",\" << best.mx << endl;\\n        return best;\\n    }\\n    \\n    vector<int> earliestAndLatest(int n1, int firstPlayer, int secondPlayer) {\\n        int n = n1 + 1;\\n        dp = vector<vector<vector<::Value>>>(n, vector<vector<::Value>>(n, vector<::Value>(n)));\\n        auto ans = dfs(firstPlayer, n - secondPlayer, n1);\\n        vector<int> v = {ans.mn, ans.mx};\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nstruct Value {\\n    int mn = INT_MAX;\\n    int mx = INT_MIN;\\n    Value(int a, int b)\\n    {\\n        mn = a;\\n        mx = b;\\n    }\\n    Value()\\n    {}\\n    \\n    void update(Value& v)\\n    {\\n        mn = std::min(v.mn + 1, mn);\\n        mx = std::max(v.mx + 1, mx);\\n    }\\n};\\nclass Solution {\\npublic:\\n    // min\\n    vector<vector<vector<::Value>>> dp;\\n    // max\\n    // a left b right\\n    ::Value dfs(int a, int b, int n)\\n    {\\n        if (a > b) {\\n            swap(a, b);\\n        }\\n        \\n        if ((a == b) || (n <= 2))\\n        {\\n            dp[n][a][b] = ::Value(1, 1);\\n             cout << a << \",\" << b << \":\" << n << endl;\\n            cout << dp[n][a][b].mn << \",\" << dp[n][a][b].mx << endl;\\n            return dp[n][a][b];\\n        }\\n        if (dp[n][a][b].mn != INT_MAX)\\n        {\\n            cout << a << \",\" << b << \":\" << n << endl;\\n            cout << dp[n][a][b].mn << \",\" << dp[n][a][b].mx << endl;\\n            return dp[n][a][b];\\n        }\\n        \\n        int m = (n / 2) + (((n%2) == 0) ? 0 : 1);\\n        ::Value best;\\n        if (b <= m)\\n        {\\n            \\n            for (int i = 1; i <= a; i++)\\n            {\\n                int x = a - i;\\n                int y = b - a;\\n                for (int j = x + 1; j <= x + y; j++)\\n                {\\n                    auto cur = dfs(i, j, m);\\n                    best.update(cur);\\n                }\\n            }\\n        }\\n        else\\n        {\\n\\n            for (int i = 1; i <= a; i++)\\n            {\\n                int x = a - i;\\n                \\n                int b1 = n + 1 - b;\\n                int y = b1 - a;\\n                int z = m - b1;\\n                \\n                for (int j = x + 1 + z; j <= x + y + z; j++)\\n                {\\n                    //cout << \"next:\" << i << \",\" << j << \",\"<< x << \",\" << z << \",\" << m << \",\" << b1 << \",\" << a << \",\" << b << \",\" << n << endl;\\n                    auto cur = dfs(i, j, m);\\n                    best.update(cur);\\n                }\\n            }\\n        }\\n        dp[n][a][b] = best;\\n        \\n        cout << a << \",\" << b << \":\" << m << \",\" <<  n << endl;\\n        cout << best.mn << \",\" << best.mx << endl;\\n        return best;\\n    }\\n    \\n    vector<int> earliestAndLatest(int n1, int firstPlayer, int secondPlayer) {\\n        int n = n1 + 1;\\n        dp = vector<vector<vector<::Value>>>(n, vector<vector<::Value>>(n, vector<::Value>(n)));\\n        auto ans = dfs(firstPlayer, n - secondPlayer, n1);\\n        vector<int> v = {ans.mn, ans.mx};\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1270759,
                "title": "simple-c-code",
                "content": "```\\n\\n    void earliestAndLatest_(int a, int b, int& first, int& second, int n, vector<vector<vector<bool>>>& m, int curr) {\\n        \\n        if (a + b == n + 1) {\\n            first = min(curr, first);\\n            second = max(curr, second);\\n            return;\\n        }\\n        \\n        if (m[a][b][curr]) return;\\n        \\n        for (int i = 0; i < (1 << ((n + 1) / 2)); ++i) {\\n            \\n            int newa = 1, newb = 2;\\n            \\n            for (int j = 0; j < ((n + 1) / 2); ++j) {\\n                \\n                int pos = j + 1;\\n                \\n                if (pos == a || pos == b || pos == n - a + 1 || pos == n - b + 1) continue;\\n                \\n                if (i & (1 << j)) pos = n - pos + 1;\\n                \\n                if (pos < a) ++newa;\\n                if (pos < b) ++newb;\\n                \\n            }\\n            \\n            earliestAndLatest_(newa, newb, first, second, (n + 1) / 2, m, curr + 1);\\n            \\n        }\\n        \\n        m[a][b][curr] = true;\\n        return;\\n    }\\n    \\n    vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n        int first = INT_MAX, second = INT_MIN;\\n        \\n        vector<vector<vector<bool>>> m(29, vector<vector<bool>>(29, vector<bool>(5, false)));\\n        \\n        earliestAndLatest_(firstPlayer, secondPlayer, first, second, n, m, 1);\\n        \\n        return vector<int> {first, second};\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    void earliestAndLatest_(int a, int b, int& first, int& second, int n, vector<vector<vector<bool>>>& m, int curr) {\\n        \\n        if (a + b == n + 1) {\\n            first = min(curr, first);\\n            second = max(curr, second);\\n            return;\\n        }\\n        \\n        if (m[a][b][curr]) return;\\n        \\n        for (int i = 0; i < (1 << ((n + 1) / 2)); ++i) {\\n            \\n            int newa = 1, newb = 2;\\n            \\n            for (int j = 0; j < ((n + 1) / 2); ++j) {\\n                \\n                int pos = j + 1;\\n                \\n                if (pos == a || pos == b || pos == n - a + 1 || pos == n - b + 1) continue;\\n                \\n                if (i & (1 << j)) pos = n - pos + 1;\\n                \\n                if (pos < a) ++newa;\\n                if (pos < b) ++newb;\\n                \\n            }\\n            \\n            earliestAndLatest_(newa, newb, first, second, (n + 1) / 2, m, curr + 1);\\n            \\n        }\\n        \\n        m[a][b][curr] = true;\\n        return;\\n    }\\n    \\n    vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n        int first = INT_MAX, second = INT_MIN;\\n        \\n        vector<vector<vector<bool>>> m(29, vector<vector<bool>>(29, vector<bool>(5, false)));\\n        \\n        earliestAndLatest_(firstPlayer, secondPlayer, first, second, n, m, 1);\\n        \\n        return vector<int> {first, second};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1270662,
                "title": "javascript-dfs",
                "content": "Relatively straightforward DFS. You can get away with a complete brute force if you want, though memoization will improve the runtime.\\n\\nYou probably also don\\'t need a bitmask, but since ```n < 32```, may as well.\\n\\nWe\\'ll use DFS, moving from player to player until we\\'ve gone halfway through the list, since that means we\\'ve matched everyone up against each other. Then we remove the current player from available players if they lost, or remove their opponent if they won.\\n\\n```\\nvar earliestAndLatest = function (n, firstPlayer, secondPlayer) {\\n  let earliest = n;\\n  let latest = 0;\\n\\n  const visited = new Set();\\n\\n  const findEarliestAndLatest = (remain, players, current, round) => {\\n    if (visited.has(remain)) return;\\n    \\n    const player = players[current];\\n    const opponent = players[players.length - current]; // since we\\'re 1-indexed\\n\\n    if (player === firstPlayer && opponent === secondPlayer) {\\n      earliest = Math.min(earliest, round);\\n      latest = Math.max(latest, round);\\n      return;\\n    }\\n\\n    if (opponent <= player) {\\n\\t  // we\\'ve gone halfway through the list, so everyone has been matched up\\n\\t  // go to the next round\\n      const nextPlayers = players.filter((p) => remain & (1 << p));\\n      findEarliestAndLatest(remain, nextPlayers, 1, round + 1);\\n      return;\\n    }\\n\\n    const remainIfPlayerWins = remain ^ (1 << opponent);\\n    const remainIfOpponentWins = remain ^ (1 << player);\\n    const next = current + 1;\\n\\n\\t// it\\'s possible both firstPlayer and secondPlayer are in the first half of the list\\n    if (player === firstPlayer || player === secondPlayer) {\\n      findEarliestAndLatest(remainIfPlayerWins, players, next, round);\\n      return;\\n    }\\n    \\n\\t// it\\'s possible both firstPlayer and secondPlayer are in the second half of the list\\n    if (opponent === firstPlayer || opponent === secondPlayer) {\\n      findEarliestAndLatest(remainIfOpponentWins, players, next, round);\\n      return;\\n    }\\n\\n    // neither player nor opponent are firstPlayer or secondPlayer\\n    findEarliestAndLatest(remainIfPlayerWins, players, next, round);\\n    findEarliestAndLatest(remainIfOpponentWins, players, next, round);\\n    visited.add(remain);\\n  }\\n\\n  const players = new Array(n + 1).fill(0).map((_, i) => i);\\n  const ALL_PLAYERS_REMAIN = 2 ** (n + 1) - 1;\\n  findEarliestAndLatest(ALL_PLAYERS_REMAIN, players, 1, 1);\\n\\n  return [earliest, latest]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation",
                    "Depth-First Search"
                ],
                "code": "```n < 32```\n```\\nvar earliestAndLatest = function (n, firstPlayer, secondPlayer) {\\n  let earliest = n;\\n  let latest = 0;\\n\\n  const visited = new Set();\\n\\n  const findEarliestAndLatest = (remain, players, current, round) => {\\n    if (visited.has(remain)) return;\\n    \\n    const player = players[current];\\n    const opponent = players[players.length - current]; // since we\\'re 1-indexed\\n\\n    if (player === firstPlayer && opponent === secondPlayer) {\\n      earliest = Math.min(earliest, round);\\n      latest = Math.max(latest, round);\\n      return;\\n    }\\n\\n    if (opponent <= player) {\\n\\t  // we\\'ve gone halfway through the list, so everyone has been matched up\\n\\t  // go to the next round\\n      const nextPlayers = players.filter((p) => remain & (1 << p));\\n      findEarliestAndLatest(remain, nextPlayers, 1, round + 1);\\n      return;\\n    }\\n\\n    const remainIfPlayerWins = remain ^ (1 << opponent);\\n    const remainIfOpponentWins = remain ^ (1 << player);\\n    const next = current + 1;\\n\\n\\t// it\\'s possible both firstPlayer and secondPlayer are in the first half of the list\\n    if (player === firstPlayer || player === secondPlayer) {\\n      findEarliestAndLatest(remainIfPlayerWins, players, next, round);\\n      return;\\n    }\\n    \\n\\t// it\\'s possible both firstPlayer and secondPlayer are in the second half of the list\\n    if (opponent === firstPlayer || opponent === secondPlayer) {\\n      findEarliestAndLatest(remainIfOpponentWins, players, next, round);\\n      return;\\n    }\\n\\n    // neither player nor opponent are firstPlayer or secondPlayer\\n    findEarliestAndLatest(remainIfPlayerWins, players, next, round);\\n    findEarliestAndLatest(remainIfOpponentWins, players, next, round);\\n    visited.add(remain);\\n  }\\n\\n  const players = new Array(n + 1).fill(0).map((_, i) => i);\\n  const ALL_PLAYERS_REMAIN = 2 ** (n + 1) - 1;\\n  findEarliestAndLatest(ALL_PLAYERS_REMAIN, players, 1, 1);\\n\\n  return [earliest, latest]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1270571,
                "title": "bit-mask-simulation-memorization",
                "content": "Unfortunately, I didn\\'t solve this problem in the contest. I was struggling to solve a bug. \\n\\nAt first sight, this problem can be solved by search algorithm, either by dfs or backtracking. The input size is <= 28. At each step, half of the player will be eliminated. So the height of the recursion tree will be O(log(28)). Actually, the height will nevel greater than 4.  Then we need to estimate how many nodes in each level. Each node has at most 2 ^ (len(payler) / 2 - 2) children (firstPlayer and secondPlayer will always will and the middle player wins as well, sometimes, middle player could be first or second player)\\n\\nIn the worst case, n = 28. The amount of the nodes will be 2 ^ 12 + 2 ^ 12 * 2 ^ 4 + 2 ^ 12 * 2 ^ 4 * 2 = O(2 ^ 17) = 131072. We will also prun the tree during fanout process.\\n\\nWe can use bit mask to represent the players in each round of match. Then we need to covert the mask to player array by lowbit function x & -x. And then, we will arrange players into pairs and generate all possible mask of winers. To bo noticed that firstPlayer, secondPlayer and the middle player if exists will always win.\\n\\n**Python**\\n```python\\nclass Solution:\\n    def earliestAndLatest(self, n: int, f: int, s: int) -> List[int]:\\n                        \\n            f = 1 << (f - 1)\\n            s = 1 << (s - 1)\\n            \\n            def toA(x):\\n                A = []\\n                while x:\\n                    A.append(x & -x)\\n                    x -= x & -x\\n                return A\\n            \\n            @functools.lru_cache(None)\\n            def dfs(mask, depth):\\n                A = toA(mask)\\n                i, j = 0, len(A) - 1\\n                pairs = []\\n                while i < j:\\n                    if A[i] == f and A[j] == s:\\n                        return [depth, depth]\\n                    if A[i] not in [f, s] and A[j] not in [f, s]:\\n                        pairs.append((A[i], A[j]))\\n                    i += 1\\n                    j -= 1\\n                winners = sum(set([f, s, A[len(A) // 2] if len(A) & 1 else 0]))\\n                res = [math.inf, 0]\\n                for com in itertools.product(*pairs):\\n                    a, b = dfs(sum(com) + winners, depth + 1)\\n                    res[0] = min(res[0], a)\\n                    res[1] = max(res[1], b)\\n                return res\\n            mask = (1 << n) - 1\\n            res = dfs(mask, 1)\\n            return res\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def earliestAndLatest(self, n: int, f: int, s: int) -> List[int]:\\n                        \\n            f = 1 << (f - 1)\\n            s = 1 << (s - 1)\\n            \\n            def toA(x):\\n                A = []\\n                while x:\\n                    A.append(x & -x)\\n                    x -= x & -x\\n                return A\\n            \\n            @functools.lru_cache(None)\\n            def dfs(mask, depth):\\n                A = toA(mask)\\n                i, j = 0, len(A) - 1\\n                pairs = []\\n                while i < j:\\n                    if A[i] == f and A[j] == s:\\n                        return [depth, depth]\\n                    if A[i] not in [f, s] and A[j] not in [f, s]:\\n                        pairs.append((A[i], A[j]))\\n                    i += 1\\n                    j -= 1\\n                winners = sum(set([f, s, A[len(A) // 2] if len(A) & 1 else 0]))\\n                res = [math.inf, 0]\\n                for com in itertools.product(*pairs):\\n                    a, b = dfs(sum(com) + winners, depth + 1)\\n                    res[0] = min(res[0], a)\\n                    res[1] = max(res[1], b)\\n                return res\\n            mask = (1 << n) - 1\\n            res = dfs(mask, 1)\\n            return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269743,
                "title": "why-i-am-not-getting-tle-passed-in-208ms-6-2mb",
                "content": "Below is my Code which I think should get TLE.\\n\\n```\\nint mn,mx;\\nint f,s,n;\\nclass Solution {\\npublic: \\n    void dfs(int deadmask,int i,int j,int round){\\n        \\n        while(i<n && deadmask &(1<<i)) i++;\\n        while(j>=0 && deadmask &(1<<j)) j--;\\n        // next round\\n        if(i>=j) dfs(deadmask,1,n,round+1);\\n        // both immortal , call will defintely reach here.\\n        else if(i==f && j==s){ mn=min(mn,round),mx=max(mx,round); return;} \\n        else {\\n            // atleast 1 mortal\\n            if(i!=f && i!=s) dfs(deadmask|(1<<i),i+1,j-1,round);\\n            if(j!=f && j!=s) dfs(deadmask|(1<<j),i+1,j-1,round);\\n        }\\n        \\n    }\\npublic:\\n    vector<int> earliestAndLatest(int n1, int firstPlayer, int secondPlayer) {\\n        mn=INT_MAX,mx=INT_MIN;\\n        f=firstPlayer,s=secondPlayer,n=n1;\\n        dfs(0,1,n,1);\\n        return {mn,mx};\\n    }\\n};\\n```\\n\\nLet\\'s caculate number of operations.\\nFor first round we have `2*2*2*2*2.... till(28/2) times`. therefore 2^14 operations for Round 1.\\nNow, for second we have `2^14*(2*2*2.... till 7 times)`. Therefore 2^(14+7) operations.\\nNow, for third round `2^21*(2*2*2*2)`. Therefore 2^25 operations.\\nNow, for 4th round `2^25*(2*2)`. So, 2^27 operations.\\nNow, for 5th round 2^27 operations. Since it is deciding match.\\n\\nSo, clearly sum of all operations is greater than 2^28 (which is 2.6*10^8) operations. So, it should get TLE, right?\\n\\nInstead it is passing in 200 ms.\\nAlso, by seeing 208 ms we can say that in 1 sec `10^9(2.6*10^8*(1000/208))` operations can be performed. Is it true?",
                "solutionTags": [],
                "code": "```\\nint mn,mx;\\nint f,s,n;\\nclass Solution {\\npublic: \\n    void dfs(int deadmask,int i,int j,int round){\\n        \\n        while(i<n && deadmask &(1<<i)) i++;\\n        while(j>=0 && deadmask &(1<<j)) j--;\\n        // next round\\n        if(i>=j) dfs(deadmask,1,n,round+1);\\n        // both immortal , call will defintely reach here.\\n        else if(i==f && j==s){ mn=min(mn,round),mx=max(mx,round); return;} \\n        else {\\n            // atleast 1 mortal\\n            if(i!=f && i!=s) dfs(deadmask|(1<<i),i+1,j-1,round);\\n            if(j!=f && j!=s) dfs(deadmask|(1<<j),i+1,j-1,round);\\n        }\\n        \\n    }\\npublic:\\n    vector<int> earliestAndLatest(int n1, int firstPlayer, int secondPlayer) {\\n        mn=INT_MAX,mx=INT_MIN;\\n        f=firstPlayer,s=secondPlayer,n=n1;\\n        dfs(0,1,n,1);\\n        return {mn,mx};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269441,
                "title": "faster-than-50-time-100-space-in-c-and-same-solution-gives-a-tle-in-python",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> earliestAndLatest(int n, int first, int second) {\\n        int minRound = INT_MAX, maxRound = INT_MIN;\\n\\n        function<void(int,int,int,int)> dfs = \\n            [&](int deadMask,int i,int j, int curRound) {\\n            \\n            while (i < j and deadMask & (1<<i)) // \\'i\\' is dead warrior, try next\\n                i += 1;\\n        \\n            while (i < j and deadMask & (1<<j)) // \\'j\\' is dead warrior, try next\\n                j -= 1;\\n\\n            if (i >= j) // end of round, no more fights possible\\n                dfs(deadMask, 1, n, curRound + 1);\\n\\n            else if (i == first and j == second) // BATTLE OF THE IMMORTALS\\n                minRound = min(curRound,minRound),\\n                maxRound = max(curRound,maxRound);\\n            \\n            else{ // BATTLE includes a mortal  \\n                if (i != first and i != second) // \\'i\\' is MORTAL, he may die\\n                    dfs(deadMask | (1<<i), i+1, j-1, curRound);\\n                if (j != first and j != second) // \\'j\\' is MORTAL, he may die\\n                    dfs(deadMask | (1<<j), i+1, j-1, curRound);\\n\\n            }\\n        };\\n        dfs(0,1,n,1);\\n        return {minRound, maxRound};\\n    }\\n};\\n```\\n\\n```py\\nclass Solution:\\n    def earliestAndLatest(self, n, first, second) -> List[int]:\\n        minRound, maxRound = math.inf, -math.inf\\n        def dfs(deadMask, i, j, curRound):\\n            nonlocal minRound, maxRound\\n            \\n            while i < j and deadMask & (1<<i): # \\'i\\' is dead warrior, try next\\n                i += 1\\n        \\n            while i < j and deadMask & (1<<j): # \\'j\\' is dead warrior, try next\\n                j -= 1\\n\\n            if i >= j: # end of round, no more fights possible\\n                dfs(deadMask, 1, n, curRound + 1)\\n\\n            elif i == first and j == second: # BATTLE OF THE IMMORTALS\\n                minRound = min(curRound,minRound)\\n                maxRound = max(curRound,maxRound)\\n            \\n            else: # Proceed with a BATTLE with a mortal  \\n                if i != first and i != second: # \\'i\\' is MORTAL, he may die\\n                    dfs(deadMask | (1<<i), i+1, j-1, curRound)\\n                if j != first and j != second: # \\'j\\' is MORTAL, he may die\\n                    dfs(deadMask | (1<<j), i+1, j-1, curRound)\\n                    \\n        dfs(0,1,n,1)\\n        return minRound, maxRound\\n```\\n\\nAll ideas from @votrubac [discuss post](https://leetcode.com/problems/the-earliest-and-latest-rounds-where-players-compete/discuss/1268539/Recursion)\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> earliestAndLatest(int n, int first, int second) {\\n        int minRound = INT_MAX, maxRound = INT_MIN;\\n\\n        function<void(int,int,int,int)> dfs = \\n            [&](int deadMask,int i,int j, int curRound) {\\n            \\n            while (i < j and deadMask & (1<<i)) // \\'i\\' is dead warrior, try next\\n                i += 1;\\n        \\n            while (i < j and deadMask & (1<<j)) // \\'j\\' is dead warrior, try next\\n                j -= 1;\\n\\n            if (i >= j) // end of round, no more fights possible\\n                dfs(deadMask, 1, n, curRound + 1);\\n\\n            else if (i == first and j == second) // BATTLE OF THE IMMORTALS\\n                minRound = min(curRound,minRound),\\n                maxRound = max(curRound,maxRound);\\n            \\n            else{ // BATTLE includes a mortal  \\n                if (i != first and i != second) // \\'i\\' is MORTAL, he may die\\n                    dfs(deadMask | (1<<i), i+1, j-1, curRound);\\n                if (j != first and j != second) // \\'j\\' is MORTAL, he may die\\n                    dfs(deadMask | (1<<j), i+1, j-1, curRound);\\n\\n            }\\n        };\\n        dfs(0,1,n,1);\\n        return {minRound, maxRound};\\n    }\\n};\\n```\n```py\\nclass Solution:\\n    def earliestAndLatest(self, n, first, second) -> List[int]:\\n        minRound, maxRound = math.inf, -math.inf\\n        def dfs(deadMask, i, j, curRound):\\n            nonlocal minRound, maxRound\\n            \\n            while i < j and deadMask & (1<<i): # \\'i\\' is dead warrior, try next\\n                i += 1\\n        \\n            while i < j and deadMask & (1<<j): # \\'j\\' is dead warrior, try next\\n                j -= 1\\n\\n            if i >= j: # end of round, no more fights possible\\n                dfs(deadMask, 1, n, curRound + 1)\\n\\n            elif i == first and j == second: # BATTLE OF THE IMMORTALS\\n                minRound = min(curRound,minRound)\\n                maxRound = max(curRound,maxRound)\\n            \\n            else: # Proceed with a BATTLE with a mortal  \\n                if i != first and i != second: # \\'i\\' is MORTAL, he may die\\n                    dfs(deadMask | (1<<i), i+1, j-1, curRound)\\n                if j != first and j != second: # \\'j\\' is MORTAL, he may die\\n                    dfs(deadMask | (1<<j), i+1, j-1, curRound)\\n                    \\n        dfs(0,1,n,1)\\n        return minRound, maxRound\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269426,
                "title": "python-keep-string-instead-of-bitmask",
                "content": "\\n```\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        step, first, last, xs = 0, 0, 0, [firstPlayer, secondPlayer]\\n        # mark firstPlayer and secondPlayer as \\'!\\', others as \\'.\\'\\n        work = {\\'!\\'.join([ \\'.\\' * (y - x - 1) for x,y in zip([0] + xs, xs + [n+1]) ])}\\n        while work:\\n            step += 1\\n            m, n = divmod(n, 2)\\n            old, work = work, set()\\n            for s in old:\\n                # firstPlayer and secondPlayer competes?\\n                if (\\'!\\',\\'!\\') in set(zip(s[:m], s[::-1])):\\n                    if not first: first = step\\n                    last = step\\n                    continue\\n                now = {s[m] if n else \\'\\'}\\n                for x,y in zip(s[m-1::-1], s[m+n:]):\\n                    if x == \\'!\\': now = { x + s for s in now }\\n                    elif y == \\'!\\': now = { s + y for s in now }\\n                    else: now = { x + s for s in now } | { s + y for s in now }\\n                work |= now\\n            n += m\\n        return [first, last]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        step, first, last, xs = 0, 0, 0, [firstPlayer, secondPlayer]\\n        # mark firstPlayer and secondPlayer as \\'!\\', others as \\'.\\'\\n        work = {\\'!\\'.join([ \\'.\\' * (y - x - 1) for x,y in zip([0] + xs, xs + [n+1]) ])}\\n        while work:\\n            step += 1\\n            m, n = divmod(n, 2)\\n            old, work = work, set()\\n            for s in old:\\n                # firstPlayer and secondPlayer competes?\\n                if (\\'!\\',\\'!\\') in set(zip(s[:m], s[::-1])):\\n                    if not first: first = step\\n                    last = step\\n                    continue\\n                now = {s[m] if n else \\'\\'}\\n                for x,y in zip(s[m-1::-1], s[m+n:]):\\n                    if x == \\'!\\': now = { x + s for s in now }\\n                    elif y == \\'!\\': now = { s + y for s in now }\\n                    else: now = { x + s for s in now } | { s + y for s in now }\\n                work |= now\\n            n += m\\n        return [first, last]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1269082,
                "title": "python-dp-bitmask-memoization",
                "content": "```\\nclass Solution:\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        self.first = min(firstPlayer-1, secondPlayer-1)\\n        self.second = max(firstPlayer-1, secondPlayer-1)\\n        self.n=n-1\\n        self.dp = {}\\n        return self.rounds_helper((1<<n)-1, 0, self.n, 1)\\n    \\n    def rounds_helper(self, state, left, right, curr_round):\\n        if left >= right:\\n            return self.rounds_helper(state, 0, self.n, curr_round+1)\\n        elif (state&(1<<left)) == 0:\\n            return self.rounds_helper(state, left+1, right, curr_round)\\n        elif (state&(1<<right)) == 0:\\n            return self.rounds_helper(state, left, right-1, curr_round)\\n        elif left == self.first and right == self.second:\\n            return [curr_round, curr_round]\\n        else:\\n            key = (state, left, right)\\n            if key in self.dp:\\n                return self.dp[key]\\n            \\n            res = [self.n, 0]\\n            if right != self.first and right != self.second:\\n                val = self.rounds_helper(state^(1<<right), left+1, right-1, curr_round)\\n                res[0] = min(res[0], val[0])\\n                res[1] = max(res[1], val[1])\\n            if left != self.first and left != self.second:\\n                val = self.rounds_helper(state^(1<<left), left+1, right-1, curr_round)\\n                res[0] = min(res[0], val[0])\\n                res[1] = max(res[1], val[1])\\n            \\n            self.dp[key] = res\\n            return res\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        self.first = min(firstPlayer-1, secondPlayer-1)\\n        self.second = max(firstPlayer-1, secondPlayer-1)\\n        self.n=n-1\\n        self.dp = {}\\n        return self.rounds_helper((1<<n)-1, 0, self.n, 1)\\n    \\n    def rounds_helper(self, state, left, right, curr_round):\\n        if left >= right:\\n            return self.rounds_helper(state, 0, self.n, curr_round+1)\\n        elif (state&(1<<left)) == 0:\\n            return self.rounds_helper(state, left+1, right, curr_round)\\n        elif (state&(1<<right)) == 0:\\n            return self.rounds_helper(state, left, right-1, curr_round)\\n        elif left == self.first and right == self.second:\\n            return [curr_round, curr_round]\\n        else:\\n            key = (state, left, right)\\n            if key in self.dp:\\n                return self.dp[key]\\n            \\n            res = [self.n, 0]\\n            if right != self.first and right != self.second:\\n                val = self.rounds_helper(state^(1<<right), left+1, right-1, curr_round)\\n                res[0] = min(res[0], val[0])\\n                res[1] = max(res[1], val[1])\\n            if left != self.first and left != self.second:\\n                val = self.rounds_helper(state^(1<<left), left+1, right-1, curr_round)\\n                res[0] = min(res[0], val[0])\\n                res[1] = max(res[1], val[1])\\n            \\n            self.dp[key] = res\\n            return res\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268955,
                "title": "c-solution-using-push-back-tle-and-not-using-push-back-376ms",
                "content": "Way1 -> not use push_back\\n```\\nclass Solution {\\npublic:\\n    unordered_set<long long>memo;\\n    int firstPlayer,secondPlayer,mn,mx;\\n    void helper(vector<int>& arr,int round)\\n    {\\n        int n=arr.size();\\n        long long mod=1e9+7;\\n        long long now=0;\\n        for(auto &x:arr)\\n        {\\n            now*=10;\\n            now+=x;\\n            now%=mod;\\n        }\\n        if(memo.find(now)!=memo.end())return;\\n        memo.insert(now);\\n        int size=arr.size()/2;\\n        for(int i=0;i<size;i++)\\n            if(arr[i]==firstPlayer && arr[arr.size()-1-i]==secondPlayer)\\n            {\\n                mn=min(mn,round);\\n                mx=max(mx,round);\\n                return;\\n            }\\n        vector<int>next(size+(arr.size()%2==1));  //Difference!!!!!!\\n        for(int i=0;i<(1<<size);i++)\\n        {\\n            int left=0,right=next.size()-1;\\n            bool valid=true;\\n            for(int j=0;j<size;j++)\\n            {\\n                if(((i>>j)&1)&&(arr[n-1-j]==firstPlayer||arr[n-1-j]==secondPlayer))\\n                {\\n                    valid=false;\\n                    break;\\n                }\\n                if((((i>>j)&1)==0)&&(arr[j]==firstPlayer||arr[j]==secondPlayer))\\n                {\\n                    valid=false;\\n                    break;\\n                }\\n                if((i>>j)&1)next[left++]=arr[j];\\n                else next[right--]=arr[arr.size()-1-j];\\n            }\\n            if(valid==false)continue;\\n            if(arr.size()%2==1)next[left]=arr[size];\\n            helper(next,round+1);\\n        }\\n        return;\\n    }\\n    vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n        this->firstPlayer=firstPlayer;\\n        this->secondPlayer=secondPlayer;\\n        mn=INT_MAX;\\n        mx=INT_MIN;\\n        vector<int>arr;\\n        for(int i=1;i<=n;i++)arr.push_back(i);\\n        helper(arr,1);\\n        return {mn,mx};\\n    }\\n};\\n```\\nWay2 -> use push_back\\n```\\nclass Solution {\\npublic:\\n    int firstPlayer,secondPlayer,mn,mx;\\n    unordered_set<long long>memo;\\n    void helper(vector<int>& arr,int round)\\n    {\\n        long long s=0;\\n        long long m=1e9+7;\\n        for(auto &x:arr)\\n        {\\n            s*=10;\\n            s+=x;\\n            s%=m;\\n        }\\n        if(memo.find(s)!=memo.end())return;\\n        memo.insert(s);\\n        int n=arr.size();\\n        for(int i=0;i<n/2;i++)\\n            if(arr[i]==firstPlayer&&arr[n-1-i]==secondPlayer)\\n            {\\n                mn=min(mn,round);\\n                mx=max(mx,round);\\n                return;\\n            }\\n        for(int i=0;i<(1<<(n/2));i++)\\n        {\\n            vector<int>next; //Difference!!!!!!\\n            bool valid=true;\\n            for(int j=0;j<n/2;j++)\\n            {\\n                if(((i>>j)&1)&&(arr[n-1-j]==firstPlayer||arr[n-1-j]==secondPlayer))\\n                {\\n                    valid=false;\\n                    break;\\n                }\\n                if((((i>>j)&1)==0)&&(arr[j]==firstPlayer||arr[j]==secondPlayer))\\n                {\\n                    valid=false;\\n                    break;\\n                }\\n                if((i>>j)&1)next.push_back(arr[j]);\\n                else next.push_back(arr[n-1-j]);\\n            }\\n            if(valid==false)continue;\\n            if(n%2==1)next.push_back(arr[n/2]);\\n            sort(next.begin(),next.end());\\n            helper(next,round+1);\\n        }\\n        return;\\n    }\\n    vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n        this->firstPlayer=firstPlayer;\\n        this->secondPlayer=secondPlayer;\\n        mn=INT_MAX;\\n        mx=INT_MIN;\\n        vector<int>arr;\\n        for(int i=1;i<=n;i++)arr.push_back(i);\\n        helper(arr,1);\\n        return {mn,mx};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<long long>memo;\\n    int firstPlayer,secondPlayer,mn,mx;\\n    void helper(vector<int>& arr,int round)\\n    {\\n        int n=arr.size();\\n        long long mod=1e9+7;\\n        long long now=0;\\n        for(auto &x:arr)\\n        {\\n            now*=10;\\n            now+=x;\\n            now%=mod;\\n        }\\n        if(memo.find(now)!=memo.end())return;\\n        memo.insert(now);\\n        int size=arr.size()/2;\\n        for(int i=0;i<size;i++)\\n            if(arr[i]==firstPlayer && arr[arr.size()-1-i]==secondPlayer)\\n            {\\n                mn=min(mn,round);\\n                mx=max(mx,round);\\n                return;\\n            }\\n        vector<int>next(size+(arr.size()%2==1));  //Difference!!!!!!\\n        for(int i=0;i<(1<<size);i++)\\n        {\\n            int left=0,right=next.size()-1;\\n            bool valid=true;\\n            for(int j=0;j<size;j++)\\n            {\\n                if(((i>>j)&1)&&(arr[n-1-j]==firstPlayer||arr[n-1-j]==secondPlayer))\\n                {\\n                    valid=false;\\n                    break;\\n                }\\n                if((((i>>j)&1)==0)&&(arr[j]==firstPlayer||arr[j]==secondPlayer))\\n                {\\n                    valid=false;\\n                    break;\\n                }\\n                if((i>>j)&1)next[left++]=arr[j];\\n                else next[right--]=arr[arr.size()-1-j];\\n            }\\n            if(valid==false)continue;\\n            if(arr.size()%2==1)next[left]=arr[size];\\n            helper(next,round+1);\\n        }\\n        return;\\n    }\\n    vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n        this->firstPlayer=firstPlayer;\\n        this->secondPlayer=secondPlayer;\\n        mn=INT_MAX;\\n        mx=INT_MIN;\\n        vector<int>arr;\\n        for(int i=1;i<=n;i++)arr.push_back(i);\\n        helper(arr,1);\\n        return {mn,mx};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int firstPlayer,secondPlayer,mn,mx;\\n    unordered_set<long long>memo;\\n    void helper(vector<int>& arr,int round)\\n    {\\n        long long s=0;\\n        long long m=1e9+7;\\n        for(auto &x:arr)\\n        {\\n            s*=10;\\n            s+=x;\\n            s%=m;\\n        }\\n        if(memo.find(s)!=memo.end())return;\\n        memo.insert(s);\\n        int n=arr.size();\\n        for(int i=0;i<n/2;i++)\\n            if(arr[i]==firstPlayer&&arr[n-1-i]==secondPlayer)\\n            {\\n                mn=min(mn,round);\\n                mx=max(mx,round);\\n                return;\\n            }\\n        for(int i=0;i<(1<<(n/2));i++)\\n        {\\n            vector<int>next; //Difference!!!!!!\\n            bool valid=true;\\n            for(int j=0;j<n/2;j++)\\n            {\\n                if(((i>>j)&1)&&(arr[n-1-j]==firstPlayer||arr[n-1-j]==secondPlayer))\\n                {\\n                    valid=false;\\n                    break;\\n                }\\n                if((((i>>j)&1)==0)&&(arr[j]==firstPlayer||arr[j]==secondPlayer))\\n                {\\n                    valid=false;\\n                    break;\\n                }\\n                if((i>>j)&1)next.push_back(arr[j]);\\n                else next.push_back(arr[n-1-j]);\\n            }\\n            if(valid==false)continue;\\n            if(n%2==1)next.push_back(arr[n/2]);\\n            sort(next.begin(),next.end());\\n            helper(next,round+1);\\n        }\\n        return;\\n    }\\n    vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n        this->firstPlayer=firstPlayer;\\n        this->secondPlayer=secondPlayer;\\n        mn=INT_MAX;\\n        mx=INT_MIN;\\n        vector<int>arr;\\n        for(int i=1;i<=n;i++)arr.push_back(i);\\n        helper(arr,1);\\n        return {mn,mx};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268886,
                "title": "java-dfs-memo-solution",
                "content": "1. state : remaining people, pos of first player, pos of second player\\n2. Simulation : Use bitmask to simulate and get the next round\\'s standing\\n\\n```\\nclass Solution {\\n    int dp1[][][];\\n    int dp2[][][];\\n    \\n    public int[] earliestAndLatest(int n, int a, int b) {\\n        dp1=new int[n+1][n+1][n+1];\\n        dp2=new int[n+1][n+1][n+1];\\n        for(int i=0;i<dp1.length;i++){\\n            for(int j=0;j<dp1[0].length;j++){\\n                Arrays.fill(dp1[i][j],-1);\\n                Arrays.fill(dp2[i][j],-1);\\n            }\\n        }\\n        int res[]=new int[2];\\n        res[0]=dfs1(n,a,b);\\n        res[1]=dfs2(n,a,b);\\n        return res;\\n    }\\n    \\n    public int dfs1(int n,int pos1,int pos2){\\n        if(pos1+pos2==1+n){\\n            return 1;//match directly\\n        }\\n        if(dp1[n][pos1][pos2]!=-1)return dp1[n][pos1][pos2];\\n        \\n        int res=Integer.MAX_VALUE;\\n        int match=(n+1)/2;\\n        \\n        \\n        for(int state=0;state<(1<<match);state++){\\n            List<Integer>list=new ArrayList<>();\\n            boolean a=false,b=false;\\n            for(int i=0;i<match;i++){\\n                if((state&(1<<i))!=0){\\n                    list.add(i+1);\\n                    if(i+1==pos1)a=true;\\n                    if(i+1==pos2)b=true;\\n                }\\n                else{\\n                    list.add(n-i);\\n                    if(n-i==pos1)a=true;\\n                    if(n-i==pos2)b=true;\\n                }\\n            }\\n            if(a&b){\\n                int p1=-1,p2=-1;\\n                Collections.sort(list);\\n                for(int i=0;i<list.size();i++){\\n                    if(list.get(i)==pos1)p1=i+1;\\n                    if(list.get(i)==pos2)p2=i+1;\\n                }\\n                res=Math.min(res,1+dfs1(match,p1,p2));\\n            }\\n            \\n        }\\n        \\n        dp1[n][pos1][pos2]=res;\\n        return res;\\n    }\\n    \\n    \\n    public int dfs2(int n,int pos1,int pos2){//mn\\n        if(pos1+pos2==1+n){\\n            return 1;//match directly\\n        }\\n        if(dp2[n][pos1][pos2]!=-1)return dp2[n][pos1][pos2];\\n        \\n        int res=Integer.MIN_VALUE;\\n        int match=(n+1)/2;\\n        \\n        \\n        for(int state=0;state<(1<<match);state++){\\n            List<Integer>list=new ArrayList<>();\\n            boolean a=false,b=false;\\n            for(int i=0;i<match;i++){\\n                if((state&(1<<i))!=0){\\n                    list.add(i+1);\\n                    if(i+1==pos1)a=true;\\n                    if(i+1==pos2)b=true;\\n                }\\n                else{\\n                    list.add(n-i);\\n                    if(n-i==pos1)a=true;\\n                    if(n-i==pos2)b=true;\\n                }\\n            }\\n            if(a&b){\\n                int p1=-1,p2=-1;\\n                Collections.sort(list);\\n                for(int i=0;i<list.size();i++){\\n                    if(list.get(i)==pos1)p1=i+1;\\n                    if(list.get(i)==pos2)p2=i+1;\\n                }\\n                res=Math.max(res,1+dfs2(match,p1,p2));\\n            }\\n            \\n        }\\n        \\n        dp2[n][pos1][pos2]=res;\\n        return res;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int dp1[][][];\\n    int dp2[][][];\\n    \\n    public int[] earliestAndLatest(int n, int a, int b) {\\n        dp1=new int[n+1][n+1][n+1];\\n        dp2=new int[n+1][n+1][n+1];\\n        for(int i=0;i<dp1.length;i++){\\n            for(int j=0;j<dp1[0].length;j++){\\n                Arrays.fill(dp1[i][j],-1);\\n                Arrays.fill(dp2[i][j],-1);\\n            }\\n        }\\n        int res[]=new int[2];\\n        res[0]=dfs1(n,a,b);\\n        res[1]=dfs2(n,a,b);\\n        return res;\\n    }\\n    \\n    public int dfs1(int n,int pos1,int pos2){\\n        if(pos1+pos2==1+n){\\n            return 1;//match directly\\n        }\\n        if(dp1[n][pos1][pos2]!=-1)return dp1[n][pos1][pos2];\\n        \\n        int res=Integer.MAX_VALUE;\\n        int match=(n+1)/2;\\n        \\n        \\n        for(int state=0;state<(1<<match);state++){\\n            List<Integer>list=new ArrayList<>();\\n            boolean a=false,b=false;\\n            for(int i=0;i<match;i++){\\n                if((state&(1<<i))!=0){\\n                    list.add(i+1);\\n                    if(i+1==pos1)a=true;\\n                    if(i+1==pos2)b=true;\\n                }\\n                else{\\n                    list.add(n-i);\\n                    if(n-i==pos1)a=true;\\n                    if(n-i==pos2)b=true;\\n                }\\n            }\\n            if(a&b){\\n                int p1=-1,p2=-1;\\n                Collections.sort(list);\\n                for(int i=0;i<list.size();i++){\\n                    if(list.get(i)==pos1)p1=i+1;\\n                    if(list.get(i)==pos2)p2=i+1;\\n                }\\n                res=Math.min(res,1+dfs1(match,p1,p2));\\n            }\\n            \\n        }\\n        \\n        dp1[n][pos1][pos2]=res;\\n        return res;\\n    }\\n    \\n    \\n    public int dfs2(int n,int pos1,int pos2){//mn\\n        if(pos1+pos2==1+n){\\n            return 1;//match directly\\n        }\\n        if(dp2[n][pos1][pos2]!=-1)return dp2[n][pos1][pos2];\\n        \\n        int res=Integer.MIN_VALUE;\\n        int match=(n+1)/2;\\n        \\n        \\n        for(int state=0;state<(1<<match);state++){\\n            List<Integer>list=new ArrayList<>();\\n            boolean a=false,b=false;\\n            for(int i=0;i<match;i++){\\n                if((state&(1<<i))!=0){\\n                    list.add(i+1);\\n                    if(i+1==pos1)a=true;\\n                    if(i+1==pos2)b=true;\\n                }\\n                else{\\n                    list.add(n-i);\\n                    if(n-i==pos1)a=true;\\n                    if(n-i==pos2)b=true;\\n                }\\n            }\\n            if(a&b){\\n                int p1=-1,p2=-1;\\n                Collections.sort(list);\\n                for(int i=0;i<list.size();i++){\\n                    if(list.get(i)==pos1)p1=i+1;\\n                    if(list.get(i)==pos2)p2=i+1;\\n                }\\n                res=Math.max(res,1+dfs2(match,p1,p2));\\n            }\\n            \\n        }\\n        \\n        dp2[n][pos1][pos2]=res;\\n        return res;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268770,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\n    int earliest(int n, int x, int y, vector<vector<vector<int>>> &dp) {\\n        int& r = dp[n][x][y];\\n        if (r >= 0) {\\n            return r;\\n        }\\n        if (x + y == n - 1) {\\n            return r = 1;\\n        }\\n        int round = n >> 1;\\n        if (n & 1) {\\n            const int mid = round;\\n            if (x != mid) {\\n                --round;\\n            }\\n            if (y != mid) {\\n                --round;\\n            }\\n        }\\n        r = n;\\n        for (int mask = (1 << round) - 1; mask >= 0; --mask) {\\n            int winners = (n & 1) ? (1 << (n >> 1)) : 0;\\n            for (int i = 0, j = n - 1, ind = 0; i < j; ++i, --j) {\\n                if (i == x || i == y) {\\n                    winners |= 1 << i;\\n                } else if (j == x || j == y) {\\n                    winners |= 1 << j;\\n                } else if (mask & (1 << (ind++))) {\\n                    winners |= 1 << i;\\n                } else {\\n                    winners |= 1 << j;\\n                }\\n            }\\n            int xx = 0, yy = 0, m = 0;\\n            for (int i = 0; i < n; ++i) {\\n                if (winners & (1 << i)) {\\n                    if (i == x) {\\n                        xx = m;\\n                    } else if (i == y) {\\n                        yy = m;\\n                    }\\n                    ++m;\\n                }\\n            }\\n            r = min(r, earliest(m, xx, yy, dp));\\n        }\\n        return ++r;\\n    }\\n    \\n    int latest(int n, int x, int y, vector<vector<vector<int>>> &dp) {\\n        int& r = dp[n][x][y];\\n        if (r >= 0) {\\n            return r;\\n        }\\n        if (x + y == n - 1) {\\n            return r = 1;\\n        }\\n        int round = n >> 1;\\n        if (n & 1) {\\n            const int mid = round;\\n            if (x != mid) {\\n                --round;\\n            }\\n            if (y != mid) {\\n                --round;\\n            }\\n        }\\n        r = 0;\\n        for (int mask = (1 << round) - 1; mask >= 0; --mask) {\\n            int winners = (n & 1) ? (1 << (n >> 1)) : 0;\\n            for (int i = 0, j = n - 1, ind = 0; i < j; ++i, --j) {\\n                 if (i == x || i == y) {\\n                    winners |= 1 << i;\\n                } else if (j == x || j == y) {\\n                    winners |= 1 << j;\\n                } else if (mask & (1 << (ind++))) {\\n                    winners |= 1 << i;\\n                } else {\\n                    winners |= 1 << j;\\n                }\\n            }\\n            int xx = 0, yy = 0, m = 0;\\n            for (int i = 0; i < n; ++i) {\\n                if (winners & (1 << i)) {\\n                    if (i == x) {\\n                        xx = m;\\n                    } else if (i == y) {\\n                        yy = m;\\n                    }\\n                    ++m;\\n                }\\n            }\\n            r = max(r, latest(m, xx, yy, dp));\\n        }\\n        return ++r;\\n    \\n    }\\npublic:\\n    vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n        vector<vector<vector<int>>> a(n + 1, vector<vector<int>>(n, vector<int>(n, -1))), b(n + 1, vector<vector<int>>(n, vector<int>(n, -1)));\\n        --firstPlayer;\\n        --secondPlayer;\\n        return {earliest(n, firstPlayer, secondPlayer, a), latest(n, firstPlayer, secondPlayer, b)};\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int earliest(int n, int x, int y, vector<vector<vector<int>>> &dp) {\\n        int& r = dp[n][x][y];\\n        if (r >= 0) {\\n            return r;\\n        }\\n        if (x + y == n - 1) {\\n            return r = 1;\\n        }\\n        int round = n >> 1;\\n        if (n & 1) {\\n            const int mid = round;\\n            if (x != mid) {\\n                --round;\\n            }\\n            if (y != mid) {\\n                --round;\\n            }\\n        }\\n        r = n;\\n        for (int mask = (1 << round) - 1; mask >= 0; --mask) {\\n            int winners = (n & 1) ? (1 << (n >> 1)) : 0;\\n            for (int i = 0, j = n - 1, ind = 0; i < j; ++i, --j) {\\n                if (i == x || i == y) {\\n                    winners |= 1 << i;\\n                } else if (j == x || j == y) {\\n                    winners |= 1 << j;\\n                } else if (mask & (1 << (ind++))) {\\n                    winners |= 1 << i;\\n                } else {\\n                    winners |= 1 << j;\\n                }\\n            }\\n            int xx = 0, yy = 0, m = 0;\\n            for (int i = 0; i < n; ++i) {\\n                if (winners & (1 << i)) {\\n                    if (i == x) {\\n                        xx = m;\\n                    } else if (i == y) {\\n                        yy = m;\\n                    }\\n                    ++m;\\n                }\\n            }\\n            r = min(r, earliest(m, xx, yy, dp));\\n        }\\n        return ++r;\\n    }\\n    \\n    int latest(int n, int x, int y, vector<vector<vector<int>>> &dp) {\\n        int& r = dp[n][x][y];\\n        if (r >= 0) {\\n            return r;\\n        }\\n        if (x + y == n - 1) {\\n            return r = 1;\\n        }\\n        int round = n >> 1;\\n        if (n & 1) {\\n            const int mid = round;\\n            if (x != mid) {\\n                --round;\\n            }\\n            if (y != mid) {\\n                --round;\\n            }\\n        }\\n        r = 0;\\n        for (int mask = (1 << round) - 1; mask >= 0; --mask) {\\n            int winners = (n & 1) ? (1 << (n >> 1)) : 0;\\n            for (int i = 0, j = n - 1, ind = 0; i < j; ++i, --j) {\\n                 if (i == x || i == y) {\\n                    winners |= 1 << i;\\n                } else if (j == x || j == y) {\\n                    winners |= 1 << j;\\n                } else if (mask & (1 << (ind++))) {\\n                    winners |= 1 << i;\\n                } else {\\n                    winners |= 1 << j;\\n                }\\n            }\\n            int xx = 0, yy = 0, m = 0;\\n            for (int i = 0; i < n; ++i) {\\n                if (winners & (1 << i)) {\\n                    if (i == x) {\\n                        xx = m;\\n                    } else if (i == y) {\\n                        yy = m;\\n                    }\\n                    ++m;\\n                }\\n            }\\n            r = max(r, latest(m, xx, yy, dp));\\n        }\\n        return ++r;\\n    \\n    }\\npublic:\\n    vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n        vector<vector<vector<int>>> a(n + 1, vector<vector<int>>(n, vector<int>(n, -1))), b(n + 1, vector<vector<int>>(n, vector<int>(n, -1)));\\n        --firstPlayer;\\n        --secondPlayer;\\n        return {earliest(n, firstPlayer, secondPlayer, a), latest(n, firstPlayer, secondPlayer, b)};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268765,
                "title": "using-mask-and-bitwise-operations",
                "content": "```\\n    fun earliestAndLatest(n: Int, firstPlayer: Int, secondPlayer: Int): IntArray {\\n        return helper(1.shl(n + 1) - 1, 1, n, firstPlayer, secondPlayer, 1, n)\\n    }\\n    \\n    val db = HashMap<String, IntArray>()\\n    \\n    fun helper(mask: Int, s: Int, e: Int, f: Int, fs: Int, round: Int, n :Int): IntArray {\\n        if(mask == 1) return intArrayOf(-1, -1) \\n        if(mask.and(1.shl(f)) == 0 || mask.and(1.shl(fs)) == 0) return intArrayOf(-1, -1) \\n\\t\\t\\n\\t\\t// round completed\\n        if(s >= e) return helper(mask, 1, n, f, fs, round + 1, n)\\n\\t\\t\\n\\t\\t// got the combination we need so return\\n        if(s == f && e == fs) {\\n            if(mask.and(1.shl(s)) == 0 || mask.and(1.shl(e)) == 0) return intArrayOf(-1, -1) \\n            return intArrayOf(round, round)\\n        }\\n        \\n\\t\\t// if position at s index is already consumed, the look for next one\\n        if(mask.and(1.shl(s)) == 0) return helper(mask, s + 1, e, f, fs, round, n)\\n\\t\\t\\n\\t\\t// if position at e index is already consumed, the look for next one\\n        if(mask.and(1.shl(e)) == 0) return helper(mask, s, e - 1, f, fs, round, n)\\n        \\n\\t\\t// create a key from current state \\n        val key = \"\" + mask + \"-\" + s + \"-\" + e\\n        if(db[key] != null) return db[key]!!\\n\\t\\t\\n        var min = Int.MAX_VALUE\\n        var max = Int.MIN_VALUE\\n        var value = helper(mask.xor(1.shl(s)), s + 1, e - 1, f, fs, round, n)\\n        if(value[0] != -1) {\\n          min = Math.min(min, value[0])\\n          max = Math.max(max, value[1])\\n        }\\n        value = helper(mask.xor(1.shl(e)), s + 1, e - 1, f, fs, round, n)\\n        if(value[0] != -1) {\\n            min = Math.min(min, value[0])\\n            max = Math.max(max, value[1])\\n        }\\n        db[key] = intArrayOf(min, max)\\n        return intArrayOf(min, max)\\n    }",
                "solutionTags": [],
                "code": "```\\n    fun earliestAndLatest(n: Int, firstPlayer: Int, secondPlayer: Int): IntArray {\\n        return helper(1.shl(n + 1) - 1, 1, n, firstPlayer, secondPlayer, 1, n)\\n    }\\n    \\n    val db = HashMap<String, IntArray>()\\n    \\n    fun helper(mask: Int, s: Int, e: Int, f: Int, fs: Int, round: Int, n :Int): IntArray {\\n        if(mask == 1) return intArrayOf(-1, -1) \\n        if(mask.and(1.shl(f)) == 0 || mask.and(1.shl(fs)) == 0) return intArrayOf(-1, -1) \\n\\t\\t\\n\\t\\t// round completed\\n        if(s >= e) return helper(mask, 1, n, f, fs, round + 1, n)\\n\\t\\t\\n\\t\\t// got the combination we need so return\\n        if(s == f && e == fs) {\\n            if(mask.and(1.shl(s)) == 0 || mask.and(1.shl(e)) == 0) return intArrayOf(-1, -1) \\n            return intArrayOf(round, round)\\n        }\\n        \\n\\t\\t// if position at s index is already consumed, the look for next one\\n        if(mask.and(1.shl(s)) == 0) return helper(mask, s + 1, e, f, fs, round, n)\\n\\t\\t\\n\\t\\t// if position at e index is already consumed, the look for next one\\n        if(mask.and(1.shl(e)) == 0) return helper(mask, s, e - 1, f, fs, round, n)\\n        \\n\\t\\t// create a key from current state \\n        val key = \"\" + mask + \"-\" + s + \"-\" + e\\n        if(db[key] != null) return db[key]!!\\n\\t\\t\\n        var min = Int.MAX_VALUE\\n        var max = Int.MIN_VALUE\\n        var value = helper(mask.xor(1.shl(s)), s + 1, e - 1, f, fs, round, n)\\n        if(value[0] != -1) {\\n          min = Math.min(min, value[0])\\n          max = Math.max(max, value[1])\\n        }\\n        value = helper(mask.xor(1.shl(e)), s + 1, e - 1, f, fs, round, n)\\n        if(value[0] != -1) {\\n            min = Math.min(min, value[0])\\n            max = Math.max(max, value[1])\\n        }\\n        db[key] = intArrayOf(min, max)\\n        return intArrayOf(min, max)\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1268683,
                "title": "python-generate-production-and-then-dp",
                "content": "```\\nclass Solution:\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        import functools\\n        \\n        def win(i, j, first, second):\\n            if i == j:\\n                return [i]\\n            if i in (first, second):\\n                return [i]\\n            if j in (first, second):\\n                return [j]\\n            return [i, j]\\n        \\n        @functools.lru_cache(None)\\n        def dfs(n, first, second) -> List[int]:\\n            if n - first + 1 == second:\\n                return [1, 1]\\n            \\n            res = [[]]\\n            l, r = 1, n\\n            while l <= r:\\n                winner = win(l, r, first, second)\\n                \\n                prev_len = len(res)\\n                for e in res:\\n                    e.append(winner[0])\\n                if len(winner) > 1:\\n                    for i in range(prev_len):\\n                        res.append(res[i][:])\\n                        res[-1][-1] = winner[1]\\n                        \\n                l += 1\\n                r -= 1\\n                \\n            ans = [float(\\'infinity\\'), float(\\'-infinity\\')]\\n            for e in res:\\n                e = sorted(e)\\n                a = e.index(first) + 1\\n                b = e.index(second) + 1\\n                small, large = dfs(len(e), a, b)\\n                ans[0] = min(ans[0], small + 1)\\n                ans[1] = max(ans[1], large + 1)\\n                \\n            return ans[0], ans[1]\\n        \\n        return dfs(n, firstPlayer, secondPlayer)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        import functools\\n        \\n        def win(i, j, first, second):\\n            if i == j:\\n                return [i]\\n            if i in (first, second):\\n                return [i]\\n            if j in (first, second):\\n                return [j]\\n            return [i, j]\\n        \\n        @functools.lru_cache(None)\\n        def dfs(n, first, second) -> List[int]:\\n            if n - first + 1 == second:\\n                return [1, 1]\\n            \\n            res = [[]]\\n            l, r = 1, n\\n            while l <= r:\\n                winner = win(l, r, first, second)\\n                \\n                prev_len = len(res)\\n                for e in res:\\n                    e.append(winner[0])\\n                if len(winner) > 1:\\n                    for i in range(prev_len):\\n                        res.append(res[i][:])\\n                        res[-1][-1] = winner[1]\\n                        \\n                l += 1\\n                r -= 1\\n                \\n            ans = [float(\\'infinity\\'), float(\\'-infinity\\')]\\n            for e in res:\\n                e = sorted(e)\\n                a = e.index(first) + 1\\n                b = e.index(second) + 1\\n                small, large = dfs(len(e), a, b)\\n                ans[0] = min(ans[0], small + 1)\\n                ans[1] = max(ans[1], large + 1)\\n                \\n            return ans[0], ans[1]\\n        \\n        return dfs(n, firstPlayer, secondPlayer)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1826611,
                "content": [
                    {
                        "username": "czjnbb",
                        "content": "An interesting question. Do not really simulate the process. It is the numbers of players before firstPlayer, between firstPlayer and secondPlayer, and after secondPlayer that matter."
                    }
                ]
            }
        ]
    }
]