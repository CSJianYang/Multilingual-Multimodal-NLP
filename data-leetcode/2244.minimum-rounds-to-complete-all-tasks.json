[
    {
        "title": "Cells in a Range on an Excel Sheet",
        "question_content": "A cell (r, c) of an excel sheet is represented as a string \"<col><row>\" where:\n\n\t<col> denotes the column number c of the cell. It is represented by alphabetical letters.\n\t\n\t\tFor example, the 1st column is denoted by 'A', the 2nd by 'B', the 3rd by 'C', and so on.\n\t\n\t\n\t<row> is the row number r of the cell. The rth row is represented by the integer r.\n\nYou are given a string s&nbsp;in&nbsp;the format \"<col1><row1>:<col2><row2>\", where <col1> represents the column c1, <row1> represents the row r1, <col2> represents the column c2, and <row2> represents the row r2, such that r1 <= r2 and c1 <= c2.\nReturn the list of cells (x, y) such that r1 <= x <= r2 and c1 <= y <= c2. The cells should be represented as&nbsp;strings in the format mentioned above and be sorted in non-decreasing order first by columns and then by rows.\n&nbsp;\nExample 1:\n\nInput: s = \"K1:L2\"\nOutput: [\"K1\",\"K2\",\"L1\",\"L2\"]\nExplanation:\nThe above diagram shows the cells which should be present in the list.\nThe red arrows denote the order in which the cells should be presented.\n\nExample 2:\n\nInput: s = \"A1:F1\"\nOutput: [\"A1\",\"B1\",\"C1\",\"D1\",\"E1\",\"F1\"]\nExplanation:\nThe above diagram shows the cells which should be present in the list.\nThe red arrow denotes the order in which the cells should be presented.\n\n&nbsp;\nConstraints:\n\n\ts.length == 5\n\t'A' <= s[0] <= s[3] <= 'Z'\n\t'1' <= s[1] <= s[4] <= '9'\n\ts consists of uppercase English letters, digits and ':'.",
        "solutions": [
            {
                "id": 1823744,
                "title": "two-loops",
                "content": "**Python**\\n```python\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(c) + chr(r) for c in range(ord(s[0]), ord(s[3]) + 1) for r in range(ord(s[1]), ord(s[4]) + 1)]\\n```\\n**C++**\\n```cpp\\nvector<string> cellsInRange(string s) {\\n    vector<string> res;\\n    for (char c = s[0]; c <= s[3]; ++c)\\n        for (char r = s[1]; r <= s[4]; ++r)\\n            res.push_back({c, r});\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(c) + chr(r) for c in range(ord(s[0]), ord(s[3]) + 1) for r in range(ord(s[1]), ord(s[4]) + 1)]\\n```\n```cpp\\nvector<string> cellsInRange(string s) {\\n    vector<string> res;\\n    for (char c = s[0]; c <= s[3]; ++c)\\n        for (char r = s[1]; r <= s[4]; ++r)\\n            res.push_back({c, r});\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823819,
                "title": "java-python-3-simple-code-w-analysis",
                "content": "\\n\\n```java\\n    public List<String> cellsInRange(String s) {\\n        char c1 = s.charAt(0), c2 = s.charAt(3);\\n        char r1 = s.charAt(1), r2 = s.charAt(4);\\n        List<String> cells = new ArrayList<>();\\n        for (char c = c1; c <= c2; ++c) {\\n            for (char r = r1; r <= r2; ++r) {\\n                cells.add(\"\" + c + r);\\n            }\\n        }\\n        return cells;\\n    }\\n```\\n```python\\n    def cellsInRange(self, s: str) -> List[str]:\\n        c1, c2 = ord(s[0]), ord(s[3])\\n        r1, r2 = int(s[1]), int(s[4])\\n        return [chr(c) + str(r) for c in range(c1, c2 + 1) for r in range(r1, r2 + 1)]\\n```\\nPython 3 Two liner: credit to **@stefan4trivia**:\\n```python\\ndef cellsInRange(self, s: str) -> List[str]:\\n    c1, r1, _, c2, r2 = map(ord, s)\\n    return [chr(c) + chr(r) for c in range(c1, c2 + 1) for r in range(r1, r2 + 1)]\\n```\\n**Analysis:**\\n\\nTime: `O((c2 - c1 + 1) * (r2 - r1 + 1))`, space: `O(1)` - excluding return space.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public List<String> cellsInRange(String s) {\\n        char c1 = s.charAt(0), c2 = s.charAt(3);\\n        char r1 = s.charAt(1), r2 = s.charAt(4);\\n        List<String> cells = new ArrayList<>();\\n        for (char c = c1; c <= c2; ++c) {\\n            for (char r = r1; r <= r2; ++r) {\\n                cells.add(\"\" + c + r);\\n            }\\n        }\\n        return cells;\\n    }\\n```\n```python\\n    def cellsInRange(self, s: str) -> List[str]:\\n        c1, c2 = ord(s[0]), ord(s[3])\\n        r1, r2 = int(s[1]), int(s[4])\\n        return [chr(c) + str(r) for c in range(c1, c2 + 1) for r in range(r1, r2 + 1)]\\n```\n```python\\ndef cellsInRange(self, s: str) -> List[str]:\\n    c1, r1, _, c2, r2 = map(ord, s)\\n    return [chr(c) + chr(r) for c in range(c1, c2 + 1) for r in range(r1, r2 + 1)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1824082,
                "title": "c-brute-force-clean-and-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        \\n        vector<string>ans;\\n        \\n        for(char ch=s[0];ch<=s[3];ch++)\\n        {\\n            for(int i=s[1]-\\'0\\';i<=s[4]-\\'0\\';i++)\\n            {\\n                string res=\"\";\\n                res+=ch;\\n                res+=to_string(i);\\n                ans.push_back(res);\\n               \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        \\n        vector<string>ans;\\n        \\n        for(char ch=s[0];ch<=s[3];ch++)\\n        {\\n            for(int i=s[1]-\\'0\\';i<=s[4]-\\'0\\';i++)\\n            {\\n                string res=\"\";\\n                res+=ch;\\n                res+=to_string(i);\\n                ans.push_back(res);\\n               \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833319,
                "title": "javascript-easy-to-understand-double-loop",
                "content": "The strategy for this problem is straightforward:\\n- we traverse from start letter to end letter\\n- for each letter, we traverse from start number to end number\\n\\nI can\\'t find tricks for this problem, if you find some please comment, thanks.\\n\\nHere\\'s the code I submitted during the contest:\\n\\n```js\\nconst cellsInRange = (s) => {\\n  const [fromLetter, fromNum, , toLetter, toNum] = s;\\n  const ret = [];\\n  for (let l1 = fromLetter.charCodeAt(0), l2 = toLetter.charCodeAt(0); l1 <= l2; ++l1) {\\n    for (let n1 = +fromNum, n2 = +toNum; n1 <= n2; ++n1) {\\n      ret.push(String.fromCharCode(l1) + n1);\\n    }\\n  }\\n  return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst cellsInRange = (s) => {\\n  const [fromLetter, fromNum, , toLetter, toNum] = s;\\n  const ret = [];\\n  for (let l1 = fromLetter.charCodeAt(0), l2 = toLetter.charCodeAt(0); l1 <= l2; ++l1) {\\n    for (let n1 = +fromNum, n2 = +toNum; n1 <= n2; ++n1) {\\n      ret.push(String.fromCharCode(l1) + n1);\\n    }\\n  }\\n  return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3165250,
                "title": "java-simple-solution-runtime-beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n**cs= column Start**\\n**ce= column End**\\n**rs= row Start**\\n**re= row End**\\n\\n**c= Column**\\n**r= Row**\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n\\n    // runtime 1 ms\\n\\n    //cs= Column Start //ce= Column End\\n    //rs= Row Start   //re= Row End\\n    char cs=s.charAt(0),ce=s.charAt(3);\\n    char rs=s.charAt(1),re=s.charAt(4);\\n\\n    List<String> ls=new ArrayList<>();\\n    //c - cell\\n    for(char c=cs;c<=ce;c++){\\n        // r - row\\n        for(char r=rs;r<=re;r++){\\n            ls.add(new String(new char[]{c,r} ));\\n        }\\n    }\\n\\n    return ls;\\n\\n\\n  \\n    }\\n}\\n```\\n![478xve.jpg](https://assets.leetcode.com/users/images/49543455-2edd-4e6e-9e2b-5a6749aae7fd_1676026442.6162713.jpeg)\\n\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n\\n    // runtime 1 ms\\n\\n    //cs= Column Start //ce= Column End\\n    //rs= Row Start   //re= Row End\\n    char cs=s.charAt(0),ce=s.charAt(3);\\n    char rs=s.charAt(1),re=s.charAt(4);\\n\\n    List<String> ls=new ArrayList<>();\\n    //c - cell\\n    for(char c=cs;c<=ce;c++){\\n        // r - row\\n        for(char r=rs;r<=re;r++){\\n            ls.add(new String(new char[]{c,r} ));\\n        }\\n    }\\n\\n    return ls;\\n\\n\\n  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823695,
                "title": "easy-solution-in-java-6-lines-of-code",
                "content": "```\\nclass Solution {\\n    public List<String> cellsInRange(String str) {\\n        char[] s = str.toCharArray();\\n        List<String> result = new ArrayList<>();\\n        for (char c1 = s[0]; c1 <= s[3]; c1++) {\\n            for (char c2 = s[1]; c2 <= s[4]; c2++) {\\n                result.add(\"\" + c1 + c2);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String str) {\\n        char[] s = str.toCharArray();\\n        List<String> result = new ArrayList<>();\\n        for (char c1 = s[0]; c1 <= s[3]; c1++) {\\n            for (char c2 = s[1]; c2 <= s[4]; c2++) {\\n                result.add(\"\" + c1 + c2);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824001,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        result=[]\\n        for i in range(ord(s[0]),ord(s[3])+1):\\n            rs=\"\"\\n            for j in range(int(s[1]),int(s[4])+1):\\n                rs=chr(i)+str(j)\\n                result.append(rs)\\n        return result\\n\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        result=[]\\n        for i in range(ord(s[0]),ord(s[3])+1):\\n            rs=\"\"\\n            for j in range(int(s[1]),int(s[4])+1):\\n                rs=chr(i)+str(j)\\n                result.append(rs)\\n        return result\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 1823607,
                "title": "python3-1-line",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/bb5647e856ff11b072f9c51a140e0f243c100171) for solutions of weekly 283.\\n\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(c)+str(r) for c in range(ord(s[0]), ord(s[3])+1) for r in range(int(s[1]), int(s[4])+1)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(c)+str(r) for c in range(ord(s[0]), ord(s[3])+1) for r in range(int(s[1]), int(s[4])+1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823901,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) \\n    {\\n        char ch1 = s[0], ch2 = s[3];              // stroing 0th and 3rd char [A1:B2] , 0th=A , 3rd=B\\n        int in1= s[1]-\\'0\\', in2=s[4]-\\'0\\';          // stroing 1st and 4th int [A1:B2] ,  1st=1 , 4th=2\\n        vector<string> ans;\\n        \\n        for(int i=ch1-\\'A\\'; i<=ch2-\\'A\\'; i++)\\n        {\\n            for(int j=in1; j<=in2; j++)\\n            {\\n                string s= ch1+to_string(j);\\n                ans.push_back(s);\\n            }\\n            ch1 = ch1+1;\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) \\n    {\\n        char ch1 = s[0], ch2 = s[3];              // stroing 0th and 3rd char [A1:B2] , 0th=A , 3rd=B\\n        int in1= s[1]-\\'0\\', in2=s[4]-\\'0\\';          // stroing 1st and 4th int [A1:B2] ,  1st=1 , 4th=2\\n        vector<string> ans;\\n        \\n        for(int i=ch1-\\'A\\'; i<=ch2-\\'A\\'; i++)\\n        {\\n            for(int j=in1; j<=in2; j++)\\n            {\\n                string s= ch1+to_string(j);\\n                ans.push_back(s);\\n            }\\n            ch1 = ch1+1;\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515289,
                "title": "my-cellsinrange",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nfunction parser(s) {\\n\\tlet result = [];\\n\\tlet index = s.indexOf(\\':\\');\\n\\tresult.push(s[0]);\\n\\tresult.push(+s.slice(1, index));\\n\\tresult.push(s[index + 1]);\\n\\tresult.push(+s.slice(index + 2));\\n\\treturn result;\\n}\\n\\nvar cellsInRange = function (s) {\\n\\tlet parserResult = parser(s);\\n\\tlet firstLetter = parserResult[0];\\n\\tlet firstNum = parserResult[1];\\n\\tlet secondLetter = parserResult[2];\\n\\tlet secondNum = parserResult[3];\\n\\tlet alphabet = \\'abcdefghijklmnopqrstuvwxyz\\'.toUpperCase();\\n\\tlet letters = alphabet.slice(alphabet.indexOf(firstLetter), alphabet.indexOf(secondLetter) + 1).split(\\'\\');\\n\\tlet result = [];\\n\\tletters.forEach(letter => {\\n\\t\\tfor (let num = firstNum; num < secondNum + 1; num++) {\\n\\t\\t\\tresult.push(letter + num);\\n\\t\\t}\\n\\t});\\n\\treturn result;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nfunction parser(s) {\\n\\tlet result = [];\\n\\tlet index = s.indexOf(\\':\\');\\n\\tresult.push(s[0]);\\n\\tresult.push(+s.slice(1, index));\\n\\tresult.push(s[index + 1]);\\n\\tresult.push(+s.slice(index + 2));\\n\\treturn result;\\n}\\n\\nvar cellsInRange = function (s) {\\n\\tlet parserResult = parser(s);\\n\\tlet firstLetter = parserResult[0];\\n\\tlet firstNum = parserResult[1];\\n\\tlet secondLetter = parserResult[2];\\n\\tlet secondNum = parserResult[3];\\n\\tlet alphabet = \\'abcdefghijklmnopqrstuvwxyz\\'.toUpperCase();\\n\\tlet letters = alphabet.slice(alphabet.indexOf(firstLetter), alphabet.indexOf(secondLetter) + 1).split(\\'\\');\\n\\tlet result = [];\\n\\tletters.forEach(letter => {\\n\\t\\tfor (let num = firstNum; num < secondNum + 1; num++) {\\n\\t\\t\\tresult.push(letter + num);\\n\\t\\t}\\n\\t});\\n\\treturn result;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1953186,
                "title": "python-solution-with-explanation-of-ascii-ord-chr",
                "content": "**`ord(character)`** gives ascii value of that character\\n**`chr(ascii)`** converts ascii value back to character\\n\\nexample: \\nord(\"a\")=97\\nchr(97)= a\\n\\nord(\"A\")=65\\nchr(65)=A\\n\\n**`fun fact:`** ```Difference between ascii values of lowercase character and its uppercase is 32```\\n\\n```\\n    def cellsInRange(self, s: str) -> List[str]:\\n        \\n        fr=int(s[1])\\n        sr=int(s[4])+1\\n        l=[]\\n        \\n       \\n        for ch in range(ord(s[0]), ord(s[3])+1):\\n            for i in range(fr, sr):\\n                l.append(chr(ch)+str(i))\\n        return l\\n```\\n\\nThis question is quite simple so i am not explaining much. Let me know if you have any doubt.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```Difference between ascii values of lowercase character and its uppercase is 32```\n```\\n    def cellsInRange(self, s: str) -> List[str]:\\n        \\n        fr=int(s[1])\\n        sr=int(s[4])+1\\n        l=[]\\n        \\n       \\n        for ch in range(ord(s[0]), ord(s[3])+1):\\n            for i in range(fr, sr):\\n                l.append(chr(ch)+str(i))\\n        return l\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1888602,
                "title": "1ms-java-solution-no-concatenation",
                "content": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        char sc = s.charAt(0), ec = s.charAt(3);\\n        char sr = s.charAt(1), er = s.charAt(4);\\n        List<String> res = new ArrayList<>();\\n        \\n        for (char i = sc; i <= ec; ++i){\\n            for (char j = sr; j <= er; ++j){\\n                res.add(new String(new char[]{i, j}));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        char sc = s.charAt(0), ec = s.charAt(3);\\n        char sr = s.charAt(1), er = s.charAt(4);\\n        List<String> res = new ArrayList<>();\\n        \\n        for (char i = sc; i <= ec; ++i){\\n            for (char j = sr; j <= er; ++j){\\n                res.add(new String(new char[]{i, j}));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824129,
                "title": "javascript-pretty",
                "content": "```\\nconst toCharCode = (char) => char.charCodeAt()\\n\\nvar cellsInRange = function(s) {\\n    const result = []\\n    for(let i = toCharCode(s[0]) ; i <= toCharCode(s[3]) ; i++){\\n        for(let j = s[1] ; j <= s[4] ; j++){\\n            result.push(String.fromCharCode(i) +j)\\n        }\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst toCharCode = (char) => char.charCodeAt()\\n\\nvar cellsInRange = function(s) {\\n    const result = []\\n    for(let i = toCharCode(s[0]) ; i <= toCharCode(s[3]) ; i++){\\n        for(let j = s[1] ; j <= s[4] ; j++){\\n            result.push(String.fromCharCode(i) +j)\\n        }\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2704256,
                "title": "python-simple-solution-faster-than-97-44",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        c1,r1,c2,r2 = s[:1], s[1:2], s[3:4], s[4:]\\n        a=[]\\n        for i in range(ord(c1),ord(c2)+1):\\n            x=chr(i)\\n            for j in range(int(r1),int(r2)+1):\\n                y=x+str(j)\\n                a.append(y)\\n        return a\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        c1,r1,c2,r2 = s[:1], s[1:2], s[3:4], s[4:]\\n        a=[]\\n        for i in range(ord(c1),ord(c2)+1):\\n            x=chr(i)\\n            for j in range(int(r1),int(r2)+1):\\n                y=x+str(j)\\n                a.append(y)\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591833,
                "title": "c-100-easy-understanding-0m",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string>ans;\\n        char leftChar = s[0];\\n        char rightChar = s[3];\\n        \\n        while (leftChar <= rightChar){\\n            int low = s[1] - \\'0\\', high = s[4] - \\'0\\';\\n            while (low <= high){\\n                ans.push_back(leftChar + to_string(low));\\n                low++;\\n            }\\n            leftChar++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string>ans;\\n        char leftChar = s[0];\\n        char rightChar = s[3];\\n        \\n        while (leftChar <= rightChar){\\n            int low = s[1] - \\'0\\', high = s[4] - \\'0\\';\\n            while (low <= high){\\n                ans.push_back(leftChar + to_string(low));\\n                low++;\\n            }\\n            leftChar++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826374,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn cells_in_range(s: String) -> Vec<String> {\\n        let sb = s.as_bytes();\\n        (sb[0]..=sb[3])\\n            .flat_map(|col| (sb[1]..=sb[4]).map(move |row| format!(\"{}{}\", col as char, row as char)))\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn cells_in_range(s: String) -> Vec<String> {\\n        let sb = s.as_bytes();\\n        (sb[0]..=sb[3])\\n            .flat_map(|col| (sb[1]..=sb[4]).map(move |row| format!(\"{}{}\", col as char, row as char)))\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1823693,
                "title": "easy-simulation-with-comments",
                "content": "**Alogorithm**:\\nWe have to iterate from `col1 to col2` **letters** and for every letter we just have to traverse from `row1 to row2` **number.**\\nIn this way we will get our answer in **sorted order** automatically.\\n\\n**C++**\\n    \\n\\tvector<string> cellsInRange(string s){\\n        //result answer\\n        vector<string> res;\\n        \\n        //extract columns and rows\\n        int col1= s[0]-\\'A\\' , col2= s[3]-\\'A\\';\\n        int row1= s[1]-\\'0\\' , row2= s[4]-\\'0\\';\\n        \\n        //keep incrementing the character from c1->c2\\n        for(;col1<=col2;col1++){\\n           char letter= col1+\\'A\\'; \\n           //for every charcter traverse from r1->r2 \\n           for(int i=row1;i<=row2;i++){\\n               string p=\"\";\\n               char r= i+\\'0\\';     //get corresponding column in terms of character\\n               p+=letter;         //append current column-> letter\\n               p+=r;              //append current row\\n               res.push_back(p);  //put string in res vector\\n           } \\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "**Alogorithm**:\\nWe have to iterate from `col1 to col2` **letters** and for every letter we just have to traverse from `row1 to row2` **number.**\\nIn this way we will get our answer in **sorted order** automatically.\\n\\n**C++**\\n    \\n\\tvector<string> cellsInRange(string s){\\n        //result answer\\n        vector<string> res;\\n        \\n        //extract columns and rows\\n        int col1= s[0]-\\'A\\' , col2= s[3]-\\'A\\';\\n        int row1= s[1]-\\'0\\' , row2= s[4]-\\'0\\';\\n        \\n        //keep incrementing the character from c1->c2\\n        for(;col1<=col2;col1++){\\n           char letter= col1+\\'A\\'; \\n           //for every charcter traverse from r1->r2 \\n           for(int i=row1;i<=row2;i++){\\n               string p=\"\";\\n               char r= i+\\'0\\';     //get corresponding column in terms of character\\n               p+=letter;         //append current column-> letter\\n               p+=r;              //append current row\\n               res.push_back(p);  //put string in res vector\\n           } \\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1823666,
                "title": "java-straightforward",
                "content": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> ans = new ArrayList<String>();\\n        for(char i = \\'A\\' ; i <= \\'Z\\'; ++i) {\\n            for(char j = \\'1\\'; j <= \\'9\\'; ++j) {\\n                if(i >= s.charAt(0) && i <= s.charAt(3) && j >= s.charAt(1) && j <= s.charAt(4)){\\n                    ans.add(Character.toString(i) + Character.toString(j));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> ans = new ArrayList<String>();\\n        for(char i = \\'A\\' ; i <= \\'Z\\'; ++i) {\\n            for(char j = \\'1\\'; j <= \\'9\\'; ++j) {\\n                if(i >= s.charAt(0) && i <= s.charAt(3) && j >= s.charAt(1) && j <= s.charAt(4)){\\n                    ans.add(Character.toString(i) + Character.toString(j));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779607,
                "title": "python-3-two-loops-1-line-bonus-beats-97",
                "content": "```python3 []\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        res = []\\n        for ch in range(ord(s[0]), ord(s[3])+1):\\n            for i in range(int(s[1]), int(s[4])+1):\\n                res.append(f\\'{chr(ch)}{i}\\')\\n        return res\\n```\\n```python3 []\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [f\\'{chr(ch)}{i}\\' for ch in range(ord(s[0]), ord(s[3])+1) for i in range(int(s[1]), int(s[4])+1)]\\n```\\n![Screenshot 2023-07-17 at 22.02.52.png](https://assets.leetcode.com/users/images/417eaef4-6451-4ffa-9cbe-d39867ab6f5c_1689620605.0786376.png)\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        res = []\\n        for ch in range(ord(s[0]), ord(s[3])+1):\\n            for i in range(int(s[1]), int(s[4])+1):\\n                res.append(f\\'{chr(ch)}{i}\\')\\n        return res\\n```\n```python3 []\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [f\\'{chr(ch)}{i}\\' for ch in range(ord(s[0]), ord(s[3])+1) for i in range(int(s[1]), int(s[4])+1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394861,
                "title": "c-and-c-very-easy-solution",
                "content": "\\n```C# []\\npublic class Solution {\\n    public IList<string> CellsInRange(string s) {\\n        List<string> res=new List<string>();\\n    for (char c = s[0]; c <= s[3]; ++c)\\n        for (char r = s[1]; r <= s[4]; ++r)\\n            res.Add($\"{c}{r}\");\\n    return res;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n    vector<string> res;\\n    for (char c = s[0]; c <= s[3]; ++c)\\n        for (char r = s[1]; r <= s[4]; ++r)\\n            res.push_back({c, r});\\n    return res;\\n    }     \\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C#",
                    "String"
                ],
                "code": "```C# []\\npublic class Solution {\\n    public IList<string> CellsInRange(string s) {\\n        List<string> res=new List<string>();\\n    for (char c = s[0]; c <= s[3]; ++c)\\n        for (char r = s[1]; r <= s[4]; ++r)\\n            res.Add($\"{c}{r}\");\\n    return res;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n    vector<string> res;\\n    for (char c = s[0]; c <= s[3]; ++c)\\n        for (char r = s[1]; r <= s[4]; ++r)\\n            res.push_back({c, r});\\n    return res;\\n    }     \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1946295,
                "title": "easy-python-for-loop",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        a,b=map(str,s.split(\":\"))\\n        m=[]\\n        r=range(ord(a[0]),ord(b[0])+1)\\n        for i in r:\\n            for j in range(int(a[-1]),int(b[-1])+1):\\n                m.append(chr(i)+str(j))\\n        return m\\n            \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        a,b=map(str,s.split(\":\"))\\n        m=[]\\n        r=range(ord(a[0]),ord(b[0])+1)\\n        for i in r:\\n            for j in range(int(a[-1]),int(b[-1])+1):\\n                m.append(chr(i)+str(j))\\n        return m\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 3764784,
                "title": "easiest-c-solution-o-n-2-time-complexity-beats-90",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string>ans; \\n        for(char ch = s[0]; ch <= s[3]; ch++){\\n            for(int i = s[1]-\\'0\\'; i <= s[4]-\\'0\\'; i++){\\n                ans.push_back(ch + to_string(i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string>ans; \\n        for(char ch = s[0]; ch <= s[3]; ch++){\\n            for(int i = s[1]-\\'0\\'; i <= s[4]-\\'0\\'; i++){\\n                ans.push_back(ch + to_string(i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758952,
                "title": "beats-100-simple-easy-to-understand-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        ArrayList<String> ans = new ArrayList<>();\\n        \\n        char c1 = s.charAt(0);\\n        char r1 = s.charAt(1);\\n        char c2 = s.charAt(3);\\n        char r2 = s.charAt(4);\\n\\n        for(char i = c1; i<=c2; i++){\\n            for(char j = r1; j<= r2; j++){\\n                StringBuilder str = new StringBuilder();\\n                str.append(i).append(j);\\n                ans.add(str.toString());\\n            }\\n\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        ArrayList<String> ans = new ArrayList<>();\\n        \\n        char c1 = s.charAt(0);\\n        char r1 = s.charAt(1);\\n        char c2 = s.charAt(3);\\n        char r2 = s.charAt(4);\\n\\n        for(char i = c1; i<=c2; i++){\\n            for(char j = r1; j<= r2; j++){\\n                StringBuilder str = new StringBuilder();\\n                str.append(i).append(j);\\n                ans.add(str.toString());\\n            }\\n\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442027,
                "title": "cells-in-a-range-on-an-excel-sheet-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        int i, j;\\n        vector<string> ans;\\n        string temp = \"\";\\n        string temp2 = \"\";\\n        \\n        for(i=s[0] ; i<=s[3] ; i++)\\n        {\\n            temp += (char)(i);\\n            for(j=s[1] ; j<=s[4] ; j++)\\n            {\\n                temp2 += temp;\\n                temp2 += (char)(j);\\n                ans.push_back(temp2);\\n                temp2.clear();\\n            }\\n            temp.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/5d773661-3c5c-46c6-9c6a-9b1c9f42b2d0_1682613052.7181225.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        int i, j;\\n        vector<string> ans;\\n        string temp = \"\";\\n        string temp2 = \"\";\\n        \\n        for(i=s[0] ; i<=s[3] ; i++)\\n        {\\n            temp += (char)(i);\\n            for(j=s[1] ; j<=s[4] ; j++)\\n            {\\n                temp2 += temp;\\n                temp2 += (char)(j);\\n                ans.push_back(temp2);\\n                temp2.clear();\\n            }\\n            temp.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2863323,
                "title": "java-char-array-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> answerList = new ArrayList<>();\\n        int startLetter, startNumber, endLetter, endNumber;\\n        char[] charArray = s.toCharArray();\\n        startLetter = charArray[0];\\n        startNumber = Character.getNumericValue(charArray[1]);\\n        endLetter = charArray[3];\\n        endNumber = Character.getNumericValue(charArray[4]);\\n        for(int i = startLetter; i <= endLetter; i++) {\\n            String letter = String.valueOf((char) i);\\n            for (int j = startNumber; j <= endNumber; j++) {\\n                answerList.add(letter + j);\\n            }\\n        }\\n        return answerList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> answerList = new ArrayList<>();\\n        int startLetter, startNumber, endLetter, endNumber;\\n        char[] charArray = s.toCharArray();\\n        startLetter = charArray[0];\\n        startNumber = Character.getNumericValue(charArray[1]);\\n        endLetter = charArray[3];\\n        endNumber = Character.getNumericValue(charArray[4]);\\n        for(int i = startLetter; i <= endLetter; i++) {\\n            String letter = String.valueOf((char) i);\\n            for (int j = startNumber; j <= endNumber; j++) {\\n                answerList.add(letter + j);\\n            }\\n        }\\n        return answerList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823458,
                "title": "simplest-detailed-approach-in-python3",
                "content": "# Code\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        alpha = \\'ABCDEFGHIJKLMNOPQRSTUVWXYZ\\'\\n\\n        # Rows\\n        r1 = int(s[1])\\n        r2 = int(s[-1])\\n\\n        # Columns\\n        c1 = s[0]\\n        c2 = s[-2]\\n\\n        op = []\\n        for col in range(alpha.index(c1), alpha.index(c2)+1):\\n            for row in range(r1, r2+1):\\n                op.append(alpha[col] + str(row))\\n        return op\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        alpha = \\'ABCDEFGHIJKLMNOPQRSTUVWXYZ\\'\\n\\n        # Rows\\n        r1 = int(s[1])\\n        r2 = int(s[-1])\\n\\n        # Columns\\n        c1 = s[0]\\n        c2 = s[-2]\\n\\n        op = []\\n        for col in range(alpha.index(c1), alpha.index(c2)+1):\\n            for row in range(r1, r2+1):\\n                op.append(alpha[col] + str(row))\\n        return op\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368874,
                "title": "95-ms-faster-than-65-68-of-javascript",
                "content": "```\\nvar cellsInRange = function (s) {\\n    let arr = s.split(\":\");\\n    let textStart = arr[0];\\n    let charstart = textStart.charCodeAt(0);\\n    let textEnd = arr[arr.length - 1];\\n    let charend = textEnd.charCodeAt(0);\\n    let RowLen = arr[arr.length - 1][1];\\n    let res = [];\\n    for (let i = charstart; i <= charend; i++) {\\n        let letter = String.fromCharCode(i);\\n        for (let j = arr[0][1]; j <= RowLen; j++) {\\n            res.push(letter + j);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cellsInRange = function (s) {\\n    let arr = s.split(\":\");\\n    let textStart = arr[0];\\n    let charstart = textStart.charCodeAt(0);\\n    let textEnd = arr[arr.length - 1];\\n    let charend = textEnd.charCodeAt(0);\\n    let RowLen = arr[arr.length - 1][1];\\n    let res = [];\\n    for (let i = charstart; i <= charend; i++) {\\n        let letter = String.fromCharCode(i);\\n        for (let j = arr[0][1]; j <= RowLen; j++) {\\n            res.push(letter + j);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1823707,
                "title": "easy-c-o-n-2-solution",
                "content": "\\n        char a=s[0];\\n        char b=s[3];\\n        char c=s[1];\\n        char d=s[4];\\n        vector<string>res;\\n        for(char i=a; i<=b; i++){\\n            for(char x=c; x<=d; x++){\\n                string temp;\\n                temp+=i;\\n                temp+=x;\\n                res.push_back(temp);\\n            }\\n        }\\n        return res;",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n        char a=s[0];\\n        char b=s[3];\\n        char c=s[1];\\n        char d=s[4];\\n        vector<string>res;\\n        for(char i=a; i<=b; i++){\\n            for(char x=c; x<=d; x++){\\n                string temp;\\n                temp+=i;\\n                temp+=x;\\n                res.push_back(temp);\\n            }\\n        }\\n        return res;",
                "codeTag": "Unknown"
            },
            {
                "id": 3653355,
                "title": "100-beats-simple-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n          int initialCol = s.charAt(0);\\n        int finalCol = s.charAt(3);\\n        \\n        int initialRow = s.charAt(1);\\n        int finalRow = s.charAt(4);\\n\\n        List<String> cells = new ArrayList<>();\\n        char[] ch = new char[2];\\n\\n        for(int c = initialCol; c <= finalCol; c++){            \\n            for(int r = initialRow; r <= finalRow; r++){\\n                 ch[0] = (char)c;\\n                 ch[1] = (char)r;\\n                 cells.add(String.valueOf(ch));\\n            }\\n        }\\n\\n        return cells;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n          int initialCol = s.charAt(0);\\n        int finalCol = s.charAt(3);\\n        \\n        int initialRow = s.charAt(1);\\n        int finalRow = s.charAt(4);\\n\\n        List<String> cells = new ArrayList<>();\\n        char[] ch = new char[2];\\n\\n        for(int c = initialCol; c <= finalCol; c++){            \\n            for(int r = initialRow; r <= finalRow; r++){\\n                 ch[0] = (char)c;\\n                 ch[1] = (char)r;\\n                 cells.add(String.valueOf(ch));\\n            }\\n        }\\n\\n        return cells;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422487,
                "title": "c-code",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need to move from the number in first part of the colon to the number in the second part of the colon, meanwhile covering all the alphabets between that in first colon to the one in second colon. For an example :\\nK1 : M4\\nIndicates, in each column from K to M ie K,L,M,\\nWe need to go down the column by 4 spaces hence the answer will be,\\nK1,K2,K3,K4,L1,L2,L3,L4,M1,M2,M3,M4\\nBelow code is the Implementation of the same.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) \\n    {   \\n        int startch = s[0];\\n        int endch = s[3];\\n        int startIn = int(s[1])-48;\\n        int endIn = int(s[4])-48;\\n        vector<string>result;\\n       for(char c = startch; c<= endch; c++)\\n       {\\n           for(int i = startIn; i<= endIn; i++)\\n           { \\n               string str = \"\";\\n               str+=c;\\n               str+=to_string(i);\\n               result.push_back(str);\\n           }\\n       } \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) \\n    {   \\n        int startch = s[0];\\n        int endch = s[3];\\n        int startIn = int(s[1])-48;\\n        int endIn = int(s[4])-48;\\n        vector<string>result;\\n       for(char c = startch; c<= endch; c++)\\n       {\\n           for(int i = startIn; i<= endIn; i++)\\n           { \\n               string str = \"\";\\n               str+=c;\\n               str+=to_string(i);\\n               result.push_back(str);\\n           }\\n       } \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334434,
                "title": "most-easy-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        char startCol=s.charAt(0);\\n        int startRow=s.charAt(1)-\\'0\\';\\n        char endCol=s.charAt(3);\\n        int endRow=s.charAt(4)-\\'0\\';\\n        List<String> ans=new ArrayList<>();\\n        for(char c=startCol;c<=endCol;){\\n            for(int i=startRow;i<=endRow;i++){\\n                ans.add(c+\"\"+i);\\n        }\\n        c=(char)(c+1);\\n    }\\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        char startCol=s.charAt(0);\\n        int startRow=s.charAt(1)-\\'0\\';\\n        char endCol=s.charAt(3);\\n        int endRow=s.charAt(4)-\\'0\\';\\n        List<String> ans=new ArrayList<>();\\n        for(char c=startCol;c<=endCol;){\\n            for(int i=startRow;i<=endRow;i++){\\n                ans.add(c+\"\"+i);\\n        }\\n        c=(char)(c+1);\\n    }\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221188,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        char[] sc = s.toCharArray();\\n        List<String> ar = new ArrayList<>();\\n        for(char c1=sc[0];c1<=sc[3];c1++){\\n            for(char n1=sc[1];n1<=sc[4];n1++){\\n                ar.add(\"\"+c1+n1);\\n            }\\n        }\\n        return ar;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        char[] sc = s.toCharArray();\\n        List<String> ar = new ArrayList<>();\\n        for(char c1=sc[0];c1<=sc[3];c1++){\\n            for(char n1=sc[1];n1<=sc[4];n1++){\\n                ar.add(\"\"+c1+n1);\\n            }\\n        }\\n        return ar;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210384,
                "title": "c-solution-simple-approach-using-2-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        \\n    char start_col = s[0];\\n    char start_row = s[1];\\n    char end_col = s[3];\\n    char end_row = s[4];\\n\\n    vector<string> ans;\\n    for (char i = start_col; i <= end_col; i++)\\n    {\\n        for (char j = start_row; j <= end_row; j++)\\n        {\\n            string cell = \"\";\\n            cell = cell + i + j;\\n            ans.push_back(cell);\\n        }\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        \\n    char start_col = s[0];\\n    char start_row = s[1];\\n    char end_col = s[3];\\n    char end_row = s[4];\\n\\n    vector<string> ans;\\n    for (char i = start_col; i <= end_col; i++)\\n    {\\n        for (char j = start_row; j <= end_row; j++)\\n        {\\n            string cell = \"\";\\n            cell = cell + i + j;\\n            ans.push_back(cell);\\n        }\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206879,
                "title": "java-1ms-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> l = new ArrayList<>();\\n        for(char i = s.charAt(0); i <= s.charAt(3); i++){\\n            for(char j = s.charAt(1); j <= s.charAt(4); j++){\\n                l.add(new String(new char[]{i,j}));\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> l = new ArrayList<>();\\n        for(char i = s.charAt(0); i <= s.charAt(3); i++){\\n            for(char j = s.charAt(1); j <= s.charAt(4); j++){\\n                l.add(new String(new char[]{i,j}));\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798345,
                "title": "simple-c-solution-100beats-at-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> result;\\n        char startCol = s[0];\\n        char endCol = s[3];\\n        int startIndex = s[1];\\n        int endIndex = s[4];\\n\\n        for(char i = startCol; i<= endCol; i++)\\n            for(char j = startIndex ; j <= endIndex; j++)\\n                result.push_back(string(1,i)+j);\\n            \\n\\n       return result; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> result;\\n        char startCol = s[0];\\n        char endCol = s[3];\\n        int startIndex = s[1];\\n        int endIndex = s[4];\\n\\n        for(char i = startCol; i<= endCol; i++)\\n            for(char j = startIndex ; j <= endIndex; j++)\\n                result.push_back(string(1,i)+j);\\n            \\n\\n       return result; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752059,
                "title": "java-94-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> selectedCells=new ArrayList<>();\\n        StringBuilder builder = new StringBuilder();\\n        char s1 = s.charAt(0);\\n        char s2 = s.charAt(3);\\n        int s3 = s.charAt(1)-48;\\n        int s4 = s.charAt(4)-48;\\n        for(char i=s1; i<=s2;i++){\\n            builder.append(i);\\n            for(int j=s3; j<=s4;j++){\\n                builder.append(j);\\n                selectedCells.add(builder.toString());\\n                builder.deleteCharAt(1);\\n            }\\n            builder.deleteCharAt(0);\\n        }\\n        return selectedCells;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> selectedCells=new ArrayList<>();\\n        StringBuilder builder = new StringBuilder();\\n        char s1 = s.charAt(0);\\n        char s2 = s.charAt(3);\\n        int s3 = s.charAt(1)-48;\\n        int s4 = s.charAt(4)-48;\\n        for(char i=s1; i<=s2;i++){\\n            builder.append(i);\\n            for(int j=s3; j<=s4;j++){\\n                builder.append(j);\\n                selectedCells.add(builder.toString());\\n                builder.deleteCharAt(1);\\n            }\\n            builder.deleteCharAt(0);\\n        }\\n        return selectedCells;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663177,
                "title": "python-chr-ord-simple",
                "content": "```\\nclass Solution(object):\\n    def cellsInRange(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        rList = []\\n      \\n        for i in range(ord(s[0]), ord(s[3])+1):\\n            for j in range(int(s[1]), int(s[4])+1):\\n                rList.append(chr(i) + str(j))\\n        return rList\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def cellsInRange(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        rList = []\\n      \\n        for i in range(ord(s[0]), ord(s[3])+1):\\n            for j in range(int(s[1]), int(s[4])+1):\\n                rList.append(chr(i) + str(j))\\n        return rList\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646149,
                "title": "simple-java-solution-using-for-loop",
                "content": "class Solution {\\n    public List<String> cellsInRange(String s) {\\n        String a=s.substring(1,2);\\n        String b=s.substring(s.length()-1,s.length());\\n        \\n        List<String> list=new ArrayList<>();\\n        char c=s.charAt(0);\\n        char d=s.charAt(3);\\n        \\n        if(a.equals(b)){\\n           for(char m=c;m<=d;m++){\\n            // System.out.println(m);\\n            list.add(m+a);\\n        }\\n        }\\n        else{\\n        int x=Integer.parseInt(a);\\n        int y=Integer.parseInt(b);\\n        for(int z=x;z<=y;z++){\\n        for(char m=c;m<=d;m++){\\n            String last=Integer.toString(z);\\n            list.add(m+last);\\n        }\\n        }\\n        }\\n        Collections.sort(list);\\n        return list;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<String> cellsInRange(String s) {\\n        String a=s.substring(1,2);\\n        String b=s.substring(s.length()-1,s.length());\\n        \\n        List<String> list=new ArrayList<>();\\n        char c=s.charAt(0);\\n        char d=s.charAt(3);\\n        \\n        if(a.equals(b)){\\n           for(char m=c;m<=d;m++){\\n            // System.out.println(m);\\n            list.add(m+a);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2491489,
                "title": "0-n-2-java-simple-code",
                "content": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> list=new ArrayList<>();\\n        int startc=s.charAt(0)-\\'A\\';\\n        int endc=s.charAt(3)-\\'A\\';\\n        int starti=s.charAt(1)-\\'0\\';\\n        int endi=s.charAt(4)-\\'0\\';\\n        String temp=\"\";\\n        while(startc<=endc){\\n            char c=(char)(65+startc);\\n            for(int i=starti;i<=endi;i++){\\n                temp=c+\"\";\\n                char n=(char)(48+i);\\n                temp+=n+\"\";\\n                list.add(temp);\\n            }\\n            startc++;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> list=new ArrayList<>();\\n        int startc=s.charAt(0)-\\'A\\';\\n        int endc=s.charAt(3)-\\'A\\';\\n        int starti=s.charAt(1)-\\'0\\';\\n        int endi=s.charAt(4)-\\'0\\';\\n        String temp=\"\";\\n        while(startc<=endc){\\n            char c=(char)(65+startc);\\n            for(int i=starti;i<=endi;i++){\\n                temp=c+\"\";\\n                char n=(char)(48+i);\\n                temp+=n+\"\";\\n                list.add(temp);\\n            }\\n            startc++;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2445324,
                "title": "100-fast-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        char col1 = s[0];   char row1 = s[1];\\n        char col2 = s[3];   char row2 = s[4];\\n        \\n        vector<string> cells;\\n        \\n        for(int i=col1; i<=col2; i++){\\n            for(int j=row1; j<=row2; j++){\\n                string currentCell = \"  \";\\n                currentCell[0] = i;\\n                currentCell[1] = j;\\n                cells.push_back(currentCell);\\n            }\\n        }\\n        return cells;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        char col1 = s[0];   char row1 = s[1];\\n        char col2 = s[3];   char row2 = s[4];\\n        \\n        vector<string> cells;\\n        \\n        for(int i=col1; i<=col2; i++){\\n            for(int j=row1; j<=row2; j++){\\n                string currentCell = \"  \";\\n                currentCell[0] = i;\\n                currentCell[1] = j;\\n                cells.push_back(currentCell);\\n            }\\n        }\\n        return cells;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396515,
                "title": "go-simple-solutions-0ms-3mb",
                "content": "```go\\nfunc cellsInRange(s string) []string {\\n    // pre allocate result\\n    res := make([]string, (s[3]-s[0]+1)*(s[4]-s[1]+1))\\n    var i int\\n    for c := s[0]; c <= s[3]; c++ {\\n        for r := s[1]; r <= s[4]; r++ {\\n            res[i] = string([]byte{c, r})\\n            i++\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc cellsInRange(s string) []string {\\n    // pre allocate result\\n    res := make([]string, (s[3]-s[0]+1)*(s[4]-s[1]+1))\\n    var i int\\n    for c := s[0]; c <= s[3]; c++ {\\n        for r := s[1]; r <= s[4]; r++ {\\n            res[i] = string([]byte{c, r})\\n            i++\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2369701,
                "title": "simple-python3-no-ord-no-chr",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        start, end = s.split(\\':\\')\\n        start_letter, start_num = start[0], int(start[-1])\\n        end_letter, end_num = end[0], int(end[1])\\n        alphabet = list(\\'ABCDEFGHIJKLMNOPQRSTUVWXYZ\\')\\n        alphabet_slice = \\\\\\n            alphabet[alphabet.index(start_letter):alphabet.index(end_letter) + 1]\\n        res = list()\\n        for el in alphabet_slice:\\n            res += [el + str(num) for num in range(start_num, end_num + 1)]\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        start, end = s.split(\\':\\')\\n        start_letter, start_num = start[0], int(start[-1])\\n        end_letter, end_num = end[0], int(end[1])\\n        alphabet = list(\\'ABCDEFGHIJKLMNOPQRSTUVWXYZ\\')\\n        alphabet_slice = \\\\\\n            alphabet[alphabet.index(start_letter):alphabet.index(end_letter) + 1]\\n        res = list()\\n        for el in alphabet_slice:\\n            res += [el + str(num) for num in range(start_num, end_num + 1)]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245978,
                "title": "java-solution",
                "content": "```class Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> s1= new ArrayList<>();\\n        for(char i=s.charAt(0);i<=s.charAt(3);i++)\\n        {\\n            for(int j=s.charAt(1);j<=s.charAt(4);j++)\\n            {\\n                String ans=i+\"\"+(j-\\'0\\');\\n                s1.add(ans);\\n            }\\n        }\\n        return s1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```class Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> s1= new ArrayList<>();\\n        for(char i=s.charAt(0);i<=s.charAt(3);i++)\\n        {\\n            for(int j=s.charAt(1);j<=s.charAt(4);j++)\\n            {\\n                String ans=i+\"\"+(j-\\'0\\');\\n                s1.add(ans);\\n            }\\n        }\\n        return s1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227093,
                "title": "c-100-faster",
                "content": "```\\n\\t    vector<string> v;\\n        string str = \"\";\\n        int a = (s[3]-s[0])+1;\\n        int b = (s[4]-s[1])+1;\\n        for (int i = 0; i < a; i++)\\n        {\\n            for (int j = 0; j < b; j++)\\n            {\\n                str=\"\";\\n                str.push_back(char(s[0] + i));\\n                str.push_back(char(s[1] + j));\\n                v.push_back(str);\\n            }    \\n        }\\n        return v;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\t    vector<string> v;\\n        string str = \"\";\\n        int a = (s[3]-s[0])+1;\\n        int b = (s[4]-s[1])+1;\\n        for (int i = 0; i < a; i++)\\n        {\\n            for (int j = 0; j < b; j++)\\n            {\\n                str=\"\";\\n                str.push_back(char(s[0] + i));\\n                str.push_back(char(s[1] + j));\\n                v.push_back(str);\\n            }    \\n        }\\n        return v;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1966259,
                "title": "javascript-begineer-solution-for-loop-faster-than-79-29",
                "content": "```\\nlet s = \"K1:L2\";\\nlet result = []\\n\\nconst [word1, word1Len, , word2, word2Len] = s;\\n\\nfor(let i= word1.charCodeAt(0) ; i<=  word2.charCodeAt(0) ;i++){\\n    let aa = (String.fromCharCode(i))\\n    for(j = word1Len ; j <=word2Len ; j++){\\n        result.push(aa+j)\\n    }\\n}\\nconsole.log(result)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet s = \"K1:L2\";\\nlet result = []\\n\\nconst [word1, word1Len, , word2, word2Len] = s;\\n\\nfor(let i= word1.charCodeAt(0) ; i<=  word2.charCodeAt(0) ;i++){\\n    let aa = (String.fromCharCode(i))\\n    for(j = word1Len ; j <=word2Len ; j++){\\n        result.push(aa+j)\\n    }\\n}\\nconsole.log(result)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1947562,
                "title": "javascript-solution-using-nested-loops",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nconst cellsInRange = s => {\\n    let startLetter = s.charCodeAt(0) - 64;\\n    let endLetter = s.charCodeAt(3) - 64;\\n    let startNumber = parseInt(s[1])\\n    let endNumber = parseInt(s[4])\\n    let result = [];\\n\\n    for (let i = startLetter; i <= endLetter; i++) {\\n        let char = String.fromCharCode(i + 64);\\n        for (let j = startNumber; j <= endNumber; j++) {\\n            result.push(char + `${j}`);\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst cellsInRange = s => {\\n    let startLetter = s.charCodeAt(0) - 64;\\n    let endLetter = s.charCodeAt(3) - 64;\\n    let startNumber = parseInt(s[1])\\n    let endNumber = parseInt(s[4])\\n    let result = [];\\n\\n    for (let i = startLetter; i <= endLetter; i++) {\\n        let char = String.fromCharCode(i + 64);\\n        for (let j = startNumber; j <= endNumber; j++) {\\n            result.push(char + `${j}`);\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1826356,
                "title": "c-solution",
                "content": "**Note**\\nIn C#, ```char``` is value type and has a numerical value, but it doesn\\'t have a custom ```+``` operator. When we do ```+``` operation on chars, they will be implicitly converted to integers, so the result will be integer. \\n\\n**Complexity**\\n- Time: O((s[3] - s[0]) + 1 * (s[4] - s[2] + 1))\\n- Space: O((s[3] - s[0]) + 1 * (s[4] - s[2] + 1)) due to the output\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public IList<string> CellsInRange(string s) {\\n        \\n        if(string.IsNullOrEmpty(s))\\n            throw new ArgumentException(\"Invalid Input.\");\\n        \\n        char col1 = s[0], col2 = s[3];\\n        char row1 = s[1], row2 = s[4];\\n    \\n        List<string> res = new List<string>();\\n        for(char c = col1; c <= col2; c++)\\n        {\\n            for(char r = row1; r <= row2; r++)\\n            {\\n                res.Add(c.ToString() + r.ToString());\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```char```\n```+```\n```+```\n```\\npublic class Solution {\\n    public IList<string> CellsInRange(string s) {\\n        \\n        if(string.IsNullOrEmpty(s))\\n            throw new ArgumentException(\"Invalid Input.\");\\n        \\n        char col1 = s[0], col2 = s[3];\\n        char row1 = s[1], row2 = s[4];\\n    \\n        List<string> res = new List<string>();\\n        for(char c = col1; c <= col2; c++)\\n        {\\n            for(char r = row1; r <= row2; r++)\\n            {\\n                res.Add(c.ToString() + r.ToString());\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825249,
                "title": "c-4-variables-and-2-loops-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        char startCol = s[0];\\n        char endCol = s[3];\\n        char startRow = s[1];\\n        char endRow = s[4];\\n        vector<string>ans;\\n        \\n        for(char a = startCol; a<=endCol; a++){\\n            for(char b = startRow; b<=endRow; b++){\\n                string sans = \"\";\\n                sans.push_back(a);\\n                sans.push_back(b);\\n                ans.push_back(sans);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        char startCol = s[0];\\n        char endCol = s[3];\\n        char startRow = s[1];\\n        char endRow = s[4];\\n        vector<string>ans;\\n        \\n        for(char a = startCol; a<=endCol; a++){\\n            for(char b = startRow; b<=endRow; b++){\\n                string sans = \"\";\\n                sans.push_back(a);\\n                sans.push_back(b);\\n                ans.push_back(sans);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824868,
                "title": "c-code-single-loop",
                "content": "```\\n\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** cellsInRange(char * s, int* returnSize){\\n    //Get the values needed from the input\\n    int row_start = (s[1]-\\'0\\');\\n    int row_end = (s[4]-\\'0\\');\\n    int rows = (row_end - row_start) + 1;\\n    int cols = ((s[3] % 65) - (s[0] % 65)) + 1;\\n    int size = (rows * cols);\\n    //printf(\"row_start = %d | row_end = %d | rows = %d | cols = %d | size = %d\\\\n\", row_start, row_end, rows, cols, size);\\n    \\n    //Declare the resultant array and allocate memory\\n    char **result = (char**)malloc(sizeof(char*) * size);\\n    for(int i = 0; i < size; i++){\\n        result[i] = (char*)malloc(sizeof(char) * 3);\\n    }\\n    \\n    \\n    //Add elements to the resultant array\\n    char ch = s[0];\\n    int i = 0;\\n    while(i < size){\\n        for(int j = row_start; j <= row_end; j++){\\n            result[i][0] = ch;\\n            result[i][1] = \\'0\\' + j;\\n            result[i][2] = \\'\\\\0\\';\\n            //printf(\"result[%d][0] = %c | result[%d][1] = %c\\\\n\", i, result[i][0], i, result[i][1]);\\n            \\n            i++;\\n        }\\n        ch = ((ch % 65) + 1) + 65;\\n    }\\n    \\n    *returnSize = size;\\n    return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** cellsInRange(char * s, int* returnSize){\\n    //Get the values needed from the input\\n    int row_start = (s[1]-\\'0\\');\\n    int row_end = (s[4]-\\'0\\');\\n    int rows = (row_end - row_start) + 1;\\n    int cols = ((s[3] % 65) - (s[0] % 65)) + 1;\\n    int size = (rows * cols);\\n    //printf(\"row_start = %d | row_end = %d | rows = %d | cols = %d | size = %d\\\\n\", row_start, row_end, rows, cols, size);\\n    \\n    //Declare the resultant array and allocate memory\\n    char **result = (char**)malloc(sizeof(char*) * size);\\n    for(int i = 0; i < size; i++){\\n        result[i] = (char*)malloc(sizeof(char) * 3);\\n    }\\n    \\n    \\n    //Add elements to the resultant array\\n    char ch = s[0];\\n    int i = 0;\\n    while(i < size){\\n        for(int j = row_start; j <= row_end; j++){\\n            result[i][0] = ch;\\n            result[i][1] = \\'0\\' + j;\\n            result[i][2] = \\'\\\\0\\';\\n            //printf(\"result[%d][0] = %c | result[%d][1] = %c\\\\n\", i, result[i][0], i, result[i][1]);\\n            \\n            i++;\\n        }\\n        ch = ((ch % 65) + 1) + 65;\\n    }\\n    \\n    *returnSize = size;\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1823952,
                "title": "simple-easy-solution-c",
                "content": "\\tonly problem i am able to solve :(\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<string> cellsInRange(string s) {\\n\\t\\t\\tint r1 = s[1] -\\'0\\';\\n\\t\\t\\tint r2 = s[4] - \\'0\\';\\n\\n\\t\\t\\tint c1 = (s[0] - \\'A\\');\\n\\t\\t\\tint c2 = (s[3] - \\'A\\');\\n\\t\\t\\tvector<string> ans;\\n\\t\\t\\tfor(int j = c1;j<=c2;j++){\\n\\t\\t\\tfor(int i = r1;i<=r2;i++){\\n\\n\\t\\t\\t\\t\\tchar ch =  j + \\'A\\';\\n\\n\\t\\t\\t\\t\\tans.push_back(ch + to_string(i));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<string> cellsInRange(string s) {\\n\\t\\t\\tint r1 = s[1] -\\'0\\';\\n\\t\\t\\tint r2 = s[4] - \\'0\\';\\n\\n\\t\\t\\tint c1 = (s[0] - \\'A\\');\\n\\t\\t\\tint c2 = (s[3] - \\'A\\');\\n\\t\\t\\tvector<string> ans;\\n\\t\\t\\tfor(int j = c1;j<=c2;j++){\\n\\t\\t\\tfor(int i = r1;i<=r2;i++){\\n\\n\\t\\t\\t\\t\\tchar ch =  j + \\'A\\';\\n\\n\\t\\t\\t\\t\\tans.push_back(ch + to_string(i));\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1823940,
                "title": "java-stringbuilder-100-optimal-faster-solution",
                "content": "```\\nclass Solution {\\n    public List < String > cellsInRange(String s) {\\n\\n        String[] str = s.split(\":\");\\n\\n        List < String > res = new ArrayList < > ();\\n        int a = Character.getNumericValue(str[0].charAt(1));\\n        int b = Character.getNumericValue(str[1].charAt(1));\\n        int c1 = str[0].charAt(0) - \\'A\\';\\n        int c2 = str[1].charAt(0) - \\'A\\';\\n\\n        for (int i = c1; i <= c2; i++) {\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(Character.toString(i + 65));\\n            for (int j = a; j <= b; j++) {\\n                sb.append(j);\\n\\n                res.add(sb.toString());\\n\\n                sb = sb.deleteCharAt(sb.length() - 1);\\n            }\\n        }\\n\\n        return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List < String > cellsInRange(String s) {\\n\\n        String[] str = s.split(\":\");\\n\\n        List < String > res = new ArrayList < > ();\\n        int a = Character.getNumericValue(str[0].charAt(1));\\n        int b = Character.getNumericValue(str[1].charAt(1));\\n        int c1 = str[0].charAt(0) - \\'A\\';\\n        int c2 = str[1].charAt(0) - \\'A\\';\\n\\n        for (int i = c1; i <= c2; i++) {\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(Character.toString(i + 65));\\n            for (int j = a; j <= b; j++) {\\n                sb.append(j);\\n\\n                res.add(sb.toString());\\n\\n                sb = sb.deleteCharAt(sb.length() - 1);\\n            }\\n        }\\n\\n        return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823641,
                "title": "c-clean-excel-cell-name-and-cell-number-easy",
                "content": "\\nSimilar question: [Excel sheet column title](https://leetcode.com/problems/excel-sheet-column-title/), [Excel Sheet Column Number](https://leetcode.com/problems/excel-sheet-column-number/)\\n\\nThis question was basically the combination of above two questions with some string processing\\n**Code**\\n\\n```\\nclass Solution {\\npublic:\\n    // calculate excel sheet column num from name\\n    int calNum(string s, int &p){\\n        int n = 1;\\n        while(p<s.size() && (s[p] >= \\'A\\') && (s[p] <=\\'Z\\')){\\n            n = (n-1)*26 + s[p] - \\'A\\' + 1;\\n            p++;\\n        }\\n        return n;\\n    }\\n    \\n    // calculate excel sheet row num from name\\n    int calNum2(string s, int &p){\\n        int n = 0;\\n        while(p<s.size() && (s[p] >= \\'0\\') && (s[p] <=\\'9\\')){\\n            n = n*10 + int(s[p] - \\'0\\');\\n            p++;\\n        }\\n        return n;\\n    }\\n    \\n    // calculate excel sheet cellName from column num and row num\\n    string calName(int i, int j){\\n        string s;\\n        while(i){\\n            s.push_back( (i-1)%26 + \\'A\\' );\\n            i = (i-1) / 26;\\n        }\\n        reverse(s.begin(), s.end());\\n        s += (to_string(j));\\n        return s;\\n    }\\n    \\n    vector<string> cellsInRange(string s) {\\n        \\n        int p = 0;                  // current position till where string is iterated\\n        int sx = calNum(s, p);      // starting cell column num\\n        int sy = calNum2(s, p);     // starting cell row num\\n         \\n        p++;                        // skipping \":\"\\n            \\n        int ex = calNum(s, p);      // ending cell column num\\n        int ey = calNum2(s, p);     // ending cell row num\\n        \\n        vector<string> ans;\\n        \\n        // iterate all cell and calculate it\\'s name\\n        for(int i=sx; i<=ex; i++)\\n            for(int j=sy; j<=ey; j++)\\n                ans.push_back(calName(i, j));\\n\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // calculate excel sheet column num from name\\n    int calNum(string s, int &p){\\n        int n = 1;\\n        while(p<s.size() && (s[p] >= \\'A\\') && (s[p] <=\\'Z\\')){\\n            n = (n-1)*26 + s[p] - \\'A\\' + 1;\\n            p++;\\n        }\\n        return n;\\n    }\\n    \\n    // calculate excel sheet row num from name\\n    int calNum2(string s, int &p){\\n        int n = 0;\\n        while(p<s.size() && (s[p] >= \\'0\\') && (s[p] <=\\'9\\')){\\n            n = n*10 + int(s[p] - \\'0\\');\\n            p++;\\n        }\\n        return n;\\n    }\\n    \\n    // calculate excel sheet cellName from column num and row num\\n    string calName(int i, int j){\\n        string s;\\n        while(i){\\n            s.push_back( (i-1)%26 + \\'A\\' );\\n            i = (i-1) / 26;\\n        }\\n        reverse(s.begin(), s.end());\\n        s += (to_string(j));\\n        return s;\\n    }\\n    \\n    vector<string> cellsInRange(string s) {\\n        \\n        int p = 0;                  // current position till where string is iterated\\n        int sx = calNum(s, p);      // starting cell column num\\n        int sy = calNum2(s, p);     // starting cell row num\\n         \\n        p++;                        // skipping \":\"\\n            \\n        int ex = calNum(s, p);      // ending cell column num\\n        int ey = calNum2(s, p);     // ending cell row num\\n        \\n        vector<string> ans;\\n        \\n        // iterate all cell and calculate it\\'s name\\n        for(int i=sx; i<=ex; i++)\\n            for(int j=sy; j<=ey; j++)\\n                ans.push_back(calName(i, j));\\n\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823610,
                "title": "beginner-friendly-python-solution",
                "content": "**Code:**\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        row1 = int(s[1])\\n        row2 = int(s[4])\\n        col1 = ord(s[0]) # To get their Unicode values\\n        col2 = ord(s[3]) # To get their Unicode values\\n        res = []\\n        # Since we are asked to sort the answer list first column and then row wise.\\n        for i in range(col1, col2+1):  \\n            for j in range(row1, row2+1):\\n                res.append(f\"{chr(i)}{j}\") # First column then row\\n        return res\\n```\\n**Code cramped into one line:**\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [f\"{chr(i)}{j}\" for i in range(ord(s[0]), ord(s[3])+1) for j in range(int(s[1]), int(s[4])+1)]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        row1 = int(s[1])\\n        row2 = int(s[4])\\n        col1 = ord(s[0]) # To get their Unicode values\\n        col2 = ord(s[3]) # To get their Unicode values\\n        res = []\\n        # Since we are asked to sort the answer list first column and then row wise.\\n        for i in range(col1, col2+1):  \\n            for j in range(row1, row2+1):\\n                res.append(f\"{chr(i)}{j}\") # First column then row\\n        return res\\n```\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [f\"{chr(i)}{j}\" for i in range(ord(s[0]), ord(s[3])+1) for j in range(int(s[1]), int(s[4])+1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870861,
                "title": "the-finest-and-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        k,k1,l=int(s[1]),int(s[4]),[]\\n        for i in range(ord(s[0]),ord(s[3])+1):\\n            for j in range(int(s[1]),int(s[4])+1):\\n                l1=\\'\\'\\n                l1+=chr(i)\\n                l1+=str(j)\\n                l.append(l1)\\n        return l\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        k,k1,l=int(s[1]),int(s[4]),[]\\n        for i in range(ord(s[0]),ord(s[3])+1):\\n            for j in range(int(s[1]),int(s[4])+1):\\n                l1=\\'\\'\\n                l1+=chr(i)\\n                l1+=str(j)\\n                l.append(l1)\\n        return l\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866788,
                "title": "java-solution-o-row-x-col-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple loop traversal\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore the initial and final row and column values in char variables.\\nLoop through each row using the ASCII value.\\nFor each row, loop through the columns and add as string to the list.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(row x col)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(row x col)\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> ans = new ArrayList<>();\\n        \\n        char startRow = s.charAt(0);\\n        char startCol = s.charAt(1);\\n        char endRow = s.charAt(3);\\n        char endCol = s.charAt(4); \\n\\n        while(startRow <= endRow) {\\n            while(startCol <= endCol) {\\n                ans.add(startRow + \"\" + startCol);\\n                startCol++;\\n            }\\n            startCol = s.charAt(1);\\n            startRow++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> ans = new ArrayList<>();\\n        \\n        char startRow = s.charAt(0);\\n        char startCol = s.charAt(1);\\n        char endRow = s.charAt(3);\\n        char endCol = s.charAt(4); \\n\\n        while(startRow <= endRow) {\\n            while(startCol <= endCol) {\\n                ans.add(startRow + \"\" + startCol);\\n                startCol++;\\n            }\\n            startCol = s.charAt(1);\\n            startRow++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518660,
                "title": "simple-java-solution-for-beginners-1ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> AL = new ArrayList();\\n        StringBuilder SB = new StringBuilder();\\n        char arr[] = s.toCharArray();\\n        for(char ch = arr[0]; ch <= arr[3]; ch = (char)(ch + 1)) {\\n            SB.append(ch);\\n            for(char num = arr[1]; num <= arr[4]; num++) {\\n                SB.append(num);\\n                AL.add(SB.toString());\\n                SB.deleteCharAt(1);\\n            }\\n            SB.deleteCharAt(0);\\n        }\\n        return AL;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> AL = new ArrayList();\\n        StringBuilder SB = new StringBuilder();\\n        char arr[] = s.toCharArray();\\n        for(char ch = arr[0]; ch <= arr[3]; ch = (char)(ch + 1)) {\\n            SB.append(ch);\\n            for(char num = arr[1]; num <= arr[4]; num++) {\\n                SB.append(num);\\n                AL.add(SB.toString());\\n                SB.deleteCharAt(1);\\n            }\\n            SB.deleteCharAt(0);\\n        }\\n        return AL;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518625,
                "title": "simple-java-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        char first = s.charAt(0);\\n        int begin = s.charAt(1) - \\'0\\';\\n        char last = s.charAt(3);\\n        int end = s.charAt(4) - \\'0\\';\\n        List<String> AL = new ArrayList();\\n        for(char c = first; c <= last;) {\\n            for(int i = begin; i <= end; i++) {\\n                AL.add(c+\"\"+i);\\n            }\\n            c = (char)(c + 1);\\n        }\\n        return AL;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        char first = s.charAt(0);\\n        int begin = s.charAt(1) - \\'0\\';\\n        char last = s.charAt(3);\\n        int end = s.charAt(4) - \\'0\\';\\n        List<String> AL = new ArrayList();\\n        for(char c = first; c <= last;) {\\n            for(int i = begin; i <= end; i++) {\\n                AL.add(c+\"\"+i);\\n            }\\n            c = (char)(c + 1);\\n        }\\n        return AL;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404209,
                "title": "simple-kotlin-solution-for-beginners",
                "content": "```\\nclass Solution {\\n    fun cellsInRange(s: String): List<String> {\\n        val arr = ArrayList<String>()\\n        for (row in s[0]..s[3]) {\\n            for (col in s[1]..s[4]) arr.add(\"$row$col\")\\n        }\\n        return arr\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun cellsInRange(s: String): List<String> {\\n        val arr = ArrayList<String>()\\n        for (row in s[0]..s[3]) {\\n            for (col in s[1]..s[4]) arr.add(\"$row$col\")\\n        }\\n        return arr\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130153,
                "title": "simple-and-easy-to-understand-solution-in-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) Created a result vector to store and return the result.\\n2) Since numbers are present at the 1st and 4th index of the string, stored the numbers into another variables known as no1 and no2.\\n3) Stored the both characters into variables called a and b.\\n4) Created two variables max_n and min_n to store maximum and minimum of both the numbers in respective variables.\\n5) Iterated from a to b in external loop and iterated from min_n to max_n in the internal loop.\\n6) Kept concatenating and adding the string into result vector.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> result;\\n        int no1 = s[1]-\\'0\\', no2 = s[4]-\\'0\\', max_n, min_n;\\n        char a = s[0], b = s[3];\\n\\n        max_n = max(no1,no2);\\n        min_n = min(no1,no2);\\n\\n        char j = a;\\n        while(j <= b){\\n            int i = min_n;\\n            while(i <= max_n){\\n                result.push_back(j+to_string(i));\\n                i++;\\n            }\\n            j++;\\n        }\\n        \\n\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> result;\\n        int no1 = s[1]-\\'0\\', no2 = s[4]-\\'0\\', max_n, min_n;\\n        char a = s[0], b = s[3];\\n\\n        max_n = max(no1,no2);\\n        min_n = min(no1,no2);\\n\\n        char j = a;\\n        while(j <= b){\\n            int i = min_n;\\n            while(i <= max_n){\\n                result.push_back(j+to_string(i));\\n                i++;\\n            }\\n            j++;\\n        }\\n        \\n\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953730,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** cellsInRange(char * s, int* returnSize){\\n    *returnSize = ((s[3]-s[0])+1) * ((s[4]-s[1])+1);\\n    char** ret = (char*)calloc(*returnSize , sizeof(char*)); // create array of strings\\n    int i , index = 0 , j ;\\n    for(i = s[0] ; i <= s[3] ; i++)\\n    {\\n        for(j = s[1] ; j <= s[4] ; j++)\\n        {\\n            ret[index] =(char*)calloc(3 , sizeof(char));\\n            ret[index][0] = i;\\n            ret[index][1] = j;\\n            ret[index][2] = \\'\\\\0\\';\\n            index++;\\n        }\\n    }\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** cellsInRange(char * s, int* returnSize){\\n    *returnSize = ((s[3]-s[0])+1) * ((s[4]-s[1])+1);\\n    char** ret = (char*)calloc(*returnSize , sizeof(char*)); // create array of strings\\n    int i , index = 0 , j ;\\n    for(i = s[0] ; i <= s[3] ; i++)\\n    {\\n        for(j = s[1] ; j <= s[4] ; j++)\\n        {\\n            ret[index] =(char*)calloc(3 , sizeof(char));\\n            ret[index][0] = i;\\n            ret[index][1] = j;\\n            ret[index][2] = \\'\\\\0\\';\\n            index++;\\n        }\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2922922,
                "title": "java-time-o-col1-col2-row1-row2-space-o-col1-col2-row1-row2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt\\'s an easy problem just need patience.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nExtract the range of column and row, then start adding it to list storing the cells.\\n\\n# Complexity\\n- Time complexity: O( |col1-col2| * |row1-row2| )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O( |col1-col2| * |row1-row2| )\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> cells = new ArrayList<>();\\n        char col1 = s.charAt(0);\\n        char col2 = s.charAt(3);\\n        int row1 = Integer.valueOf(String.valueOf(s.charAt(1)));\\n        int row2 = Integer.valueOf(String.valueOf(s.charAt(4)));\\n        for(int i=(int)col1;i<=(int)col2;i++){\\n            for(int j=row1;j<=row2;j++){\\n                cells.add(String.valueOf((char)i) + String.valueOf(j));\\n            }\\n        }\\n        return cells;\\n    }\\n    // Time Complexity : O(|col1-col2| * |row1-row2|)\\n    // Space Complexity : O(|col1-col2| * |row1-row2|)\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> cells = new ArrayList<>();\\n        char col1 = s.charAt(0);\\n        char col2 = s.charAt(3);\\n        int row1 = Integer.valueOf(String.valueOf(s.charAt(1)));\\n        int row2 = Integer.valueOf(String.valueOf(s.charAt(4)));\\n        for(int i=(int)col1;i<=(int)col2;i++){\\n            for(int j=row1;j<=row2;j++){\\n                cells.add(String.valueOf((char)i) + String.valueOf(j));\\n            }\\n        }\\n        return cells;\\n    }\\n    // Time Complexity : O(|col1-col2| * |row1-row2|)\\n    // Space Complexity : O(|col1-col2| * |row1-row2|)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859321,
                "title": "2-line-code-simple-and-naive-approach",
                "content": "# Intuition\\n2 line Code\\n# Approach\\nSimple and Naive Approach\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nwe used list as its already said to use\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n   List<String> list=new ArrayList<String>();  \\n   for(char i=s.charAt(0);i<=s.charAt(3);i++) \\n   {  \\n       for(char j=s.charAt(1);j<=s.charAt(4);j++)\\n      {   \\n          list.add(\"\"+i+j);\\n }}\\n   return list;  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n   List<String> list=new ArrayList<String>();  \\n   for(char i=s.charAt(0);i<=s.charAt(3);i++) \\n   {  \\n       for(char j=s.charAt(1);j<=s.charAt(4);j++)\\n      {   \\n          list.add(\"\"+i+j);\\n }}\\n   return list;  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851693,
                "title": "javascript-easy-to-understand-solution-beats-97",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nconst cellsInRange = function(s) {\\n   let parts = s.split(\":\");///get the rows and columns\\n   let cols = [];\\n   let rows = [];\\n   let answer = [];\\n\\n    for (let i = 0; i < parts.length; i++) {//turn strings to ascii numbers\\n        cols.push(parts[i][0].charCodeAt(0));\\n        rows.push(parts[i][1].charCodeAt(0));\\n    }\\n\\n    ///set two loops for the range of rows and columns according to ascii codes\\n    for (let i = Math.min(...cols); i <= Math.max(...cols) ; i++) {\\n        for (let j = Math.min(...rows); j <= Math.max(...rows); j++) {\\n            let element = \"\";\\n            element += (String.fromCharCode(i));///add column\\n            element += (String.fromCharCode(j));///add row\\n            answer.push(element);\\n        }\\n    }\\n\\n    return answer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nconst cellsInRange = function(s) {\\n   let parts = s.split(\":\");///get the rows and columns\\n   let cols = [];\\n   let rows = [];\\n   let answer = [];\\n\\n    for (let i = 0; i < parts.length; i++) {//turn strings to ascii numbers\\n        cols.push(parts[i][0].charCodeAt(0));\\n        rows.push(parts[i][1].charCodeAt(0));\\n    }\\n\\n    ///set two loops for the range of rows and columns according to ascii codes\\n    for (let i = Math.min(...cols); i <= Math.max(...cols) ; i++) {\\n        for (let j = Math.min(...rows); j <= Math.max(...rows); j++) {\\n            let element = \"\";\\n            element += (String.fromCharCode(i));///add column\\n            element += (String.fromCharCode(j));///add row\\n            answer.push(element);\\n        }\\n    }\\n\\n    return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2762746,
                "title": "typescript-clean-solution",
                "content": "```\\nfunction cellsInRange(s: string): string[] {\\n  const colStart = s[0].charCodeAt(0);\\n  const rowStart = +s[1];\\n  const colEnd = s[3].charCodeAt(0);\\n  const rowEnd = +s[4];\\n\\n  const cells: string[] = [];\\n  for (let col = colStart; col <= colEnd; col++) {\\n    for (let row = rowStart; row <= rowEnd; row++) {\\n      cells.push(String.fromCharCode(col) + row);\\n    }\\n  }\\n  return cells;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction cellsInRange(s: string): string[] {\\n  const colStart = s[0].charCodeAt(0);\\n  const rowStart = +s[1];\\n  const colEnd = s[3].charCodeAt(0);\\n  const rowEnd = +s[4];\\n\\n  const cells: string[] = [];\\n  for (let col = colStart; col <= colEnd; col++) {\\n    for (let row = rowStart; row <= rowEnd; row++) {\\n      cells.push(String.fromCharCode(col) + row);\\n    }\\n  }\\n  return cells;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2737276,
                "title": "simple-c-solution-using-nested-for-loops",
                "content": "# Intuition\\nThe idea here is that C# allows you to manipulate char like a numeric value so you can use a `for` loop to allow you to iterate between a known start and end.\\n\\nThe problem space defines itself that the range will always be `lower:higher`. As a result we can make several assumptions\\n\\n# Approach\\nBasically we are always given a string that is `start:stop`. Splitting on the semi-colon will give us an array where we have start and finish.\\n\\n\\nThis code example starts with the columns and walks the columns first, then determines the appropriate rows afterwards. Remember, we are guaranteed that the row counts will not decrease.\\n\\nSo we can walk the columns like so:\\n\\n```\\nfor (var cStart = start[0]; cStart <= end[0]; cStart++)\\n```\\n\\nLet\\'s define an arbitrary example where the input string is `A1:B2`.\\nIn that case `cStart` will begin with `A` and the `for` loop will walk it to `B` inclusive.\\n\\nThen we can walk the rows fairly easily using a virtually identical setup:\\n```\\nfor (var rStart = start[1]; rStart <= end[1]; rStart++)\\n```\\n`rStart` will be `1` and the for loop will increment us to `2` before halting. Again, this is due to how chars are treated in C#. We can manipulate them as if they were numbers without any problems.\\n\\n\\n# Code\\n```\\npublic class Solution\\n{\\n\\tpublic IList<string> CellsInRange(string s)\\n\\t{\\n\\t\\tvar list = new List<string>();\\n\\t\\tvar range = s.Split(\\':\\');\\n\\t\\tvar start = range[0];\\n\\t\\tvar end = range[1];\\n\\t\\tfor (var cStart = start[0]; cStart <= end[0]; cStart++)\\n\\t\\t{\\n\\t\\t\\tfor (var rStart = start[1]; rStart <= end[1]; rStart++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlist.Add($\"{cStart}{rStart}\");\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn list;\\n\\t}\\n}\\n```\\n\\nThere\\'s probably more efficient solutions for this one but this one felt the most straight-forward and simple to implement.",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nfor (var cStart = start[0]; cStart <= end[0]; cStart++)\\n```\n```\\nfor (var rStart = start[1]; rStart <= end[1]; rStart++)\\n```\n```\\npublic class Solution\\n{\\n\\tpublic IList<string> CellsInRange(string s)\\n\\t{\\n\\t\\tvar list = new List<string>();\\n\\t\\tvar range = s.Split(\\':\\');\\n\\t\\tvar start = range[0];\\n\\t\\tvar end = range[1];\\n\\t\\tfor (var cStart = start[0]; cStart <= end[0]; cStart++)\\n\\t\\t{\\n\\t\\t\\tfor (var rStart = start[1]; rStart <= end[1]; rStart++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlist.Add($\"{cStart}{rStart}\");\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn list;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563404,
                "title": "javascript-solution",
                "content": "function cellsInRange(s: string): string[] {\\n\\n  //s //K1:L2\\n\\n  const result = [];\\n  const d = []\\n  const alphabets = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\");\\n  let idx = 0;\\n\\n\\n  //[a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t]\\n\\n  // check if they are adjacent \\n  // check if the frequency is more then one\\n  // then run the loop of the largest char frequency\\n\\n  let charOneIndex = alphabets.indexOf(s.charAt(0))\\n  let charTwoIndex = alphabets.indexOf(s.charAt(3))\\n  let largest = Number(s.charAt(4))\\n\\n  if (Number(s.charAt(1)) > 1) {\\n    idx = Number(s.charAt(4)) - Number(s.charAt(1));\\n  }\\n\\n  while (charOneIndex <= charTwoIndex) {\\n    result.push(`${alphabets[charOneIndex]}`)\\n    charOneIndex++\\n  }\\n\\n\\n\\n  if (Number(s.charAt(4)) === 1 && Number(s.charAt(1)) === 1) {\\n    for (let i = idx; i < result.length; i++) {\\n      result[i] = result[i] + \"1\"\\n    }\\n  } else {\\n     for (let i = 0; i < result.length; i++) {\\n       for (let y = Number(s.charAt(1)); y <= largest; y++) {\\n         d.push(`${result[i]}${y}`)\\n       }\\n     \\n     } \\n\\n  }\\n\\n  if (Number(s.charAt(4)) === 1) {\\n    return result\\n  } else {\\n    return d\\n  }\\n\\n\\n\\n};",
                "solutionTags": [],
                "code": "function cellsInRange(s: string): string[] {\\n\\n  //s //K1:L2\\n\\n  const result = [];\\n  const d = []\\n  const alphabets = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\");\\n  let idx = 0;\\n\\n\\n  //[a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t]\\n\\n  // check if they are adjacent \\n  // check if the frequency is more then one\\n  // then run the loop of the largest char frequency\\n\\n  let charOneIndex = alphabets.indexOf(s.charAt(0))\\n  let charTwoIndex = alphabets.indexOf(s.charAt(3))\\n  let largest = Number(s.charAt(4))\\n\\n  if (Number(s.charAt(1)) > 1) {\\n    idx = Number(s.charAt(4)) - Number(s.charAt(1));\\n  }\\n\\n  while (charOneIndex <= charTwoIndex) {\\n    result.push(`${alphabets[charOneIndex]}`)\\n    charOneIndex++\\n  }\\n\\n\\n\\n  if (Number(s.charAt(4)) === 1 && Number(s.charAt(1)) === 1) {\\n    for (let i = idx; i < result.length; i++) {\\n      result[i] = result[i] + \"1\"\\n    }\\n  } else {\\n     for (let i = 0; i < result.length; i++) {\\n       for (let y = Number(s.charAt(1)); y <= largest; y++) {\\n         d.push(`${result[i]}${y}`)\\n       }\\n     \\n     } \\n\\n  }\\n\\n  if (Number(s.charAt(4)) === 1) {\\n    return result\\n  } else {\\n    return d\\n  }\\n\\n\\n\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2492026,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> res = new ArrayList<>();\\n        char[] cs = s.toCharArray();\\n        for (char i = cs[0]; i <= cs[3]; i++) {\\n            for (char j = cs[1]; j <= cs[4]; j++) {\\n                res.add(new String(new char[]{i, j}));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> res = new ArrayList<>();\\n        char[] cs = s.toCharArray();\\n        for (char i = cs[0]; i <= cs[3]; i++) {\\n            for (char j = cs[1]; j <= cs[4]; j++) {\\n                res.add(new String(new char[]{i, j}));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490314,
                "title": "samir-easy-two-loops-with-explanation",
                "content": "# Please Upvote\\n<hr>\\n\\n* The startIndex is for the row of the cell as K1 (1 -> startIndex)\\n* similarly endIndex is for the last row till which we will iterate L2 (2 -> endIndex)\\n* startChar is for the column of the cell like K1 (K -> startChar)\\n* endChar is for the column till which we\\'ll be iterating like L2 (L -> endChar)\\n\\n<hr> \\n\\n## Code :- \\n\\n```\\n\\t\\tint startIndex = Integer.parseInt(Character.toString(s.charAt(1)));\\n        int endIndex = Integer.parseInt(Character.toString(s.charAt(4)));\\n        int startChar = (int)s.charAt(0);\\n        int endChar = (int)s.charAt(3);\\n        List<String> ans = new ArrayList<>();\\n        for(int i = startChar; i <= endChar; i++){\\n            for(int j = startIndex; j <= endIndex; j++){\\n                String ss = Character.toString((char)i);\\n                ss += Integer.toString(j);\\n                ans.add(ss);\\n            }\\n        }\\n        return ans;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\tint startIndex = Integer.parseInt(Character.toString(s.charAt(1)));\\n        int endIndex = Integer.parseInt(Character.toString(s.charAt(4)));\\n        int startChar = (int)s.charAt(0);\\n        int endChar = (int)s.charAt(3);\\n        List<String> ans = new ArrayList<>();\\n        for(int i = startChar; i <= endChar; i++){\\n            for(int j = startIndex; j <= endIndex; j++){\\n                String ss = Character.toString((char)i);\\n                ss += Integer.toString(j);\\n                ans.add(ss);\\n            }\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2469317,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:                \\n        ans = []\\n        for i in range(ord(s[0]), ord(s[3])+1):\\n                \\n                for j in range(int(s[1]),int(s[4])+1):\\n                    ans.append(\"{}{}\".format(chr(i),j))\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:                \\n        ans = []\\n        for i in range(ord(s[0]), ord(s[3])+1):\\n                \\n                for j in range(int(s[1]),int(s[4])+1):\\n                    ans.append(\"{}{}\".format(chr(i),j))\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461740,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> list = new ArrayList<>();\\n\\n        int f = Character.getNumericValue(s.charAt(1)),\\n                l = Character.getNumericValue(s.charAt(s.length() - 1));\\n        char c_f = s.charAt(0), c_s = s.charAt(s.length() - 2);\\n        for (char c = c_f; c <= c_s; c++) {\\n            for (int i = f; i <= l; i++) {\\n                list.add(String.valueOf(c) + i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> list = new ArrayList<>();\\n\\n        int f = Character.getNumericValue(s.charAt(1)),\\n                l = Character.getNumericValue(s.charAt(s.length() - 1));\\n        char c_f = s.charAt(0), c_s = s.charAt(s.length() - 2);\\n        for (char c = c_f; c <= c_s; c++) {\\n            for (int i = f; i <= l; i++) {\\n                list.add(String.valueOf(c) + i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451019,
                "title": "0ms-straightforward",
                "content": "```\\nimpl Solution {\\n    pub fn cells_in_range(s: String) -> Vec<String> {\\n        let c = s.as_bytes();\\n        let mut ans: Vec<String> = Vec::with_capacity(10);\\n        for col in c[0]..=c[3] {\\n            for row in c[1]..=c[4] {\\n                ans.push(format!(\"{}{}\",col as char, row as char));\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn cells_in_range(s: String) -> Vec<String> {\\n        let c = s.as_bytes();\\n        let mut ans: Vec<String> = Vec::with_capacity(10);\\n        for col in c[0]..=c[3] {\\n            for row in c[1]..=c[4] {\\n                ans.push(format!(\"{}{}\",col as char, row as char));\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2348383,
                "title": "python-easy-and-clean",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(i)+str(j) for i in range(ord(s[0]), ord(s[3])+1) for j in range(int(s[1]), int(s[4])+1)]\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(i)+str(j) for i in range(ord(s[0]), ord(s[3])+1) for j in range(int(s[1]), int(s[4])+1)]\\n",
                "codeTag": "Java"
            },
            {
                "id": 2334942,
                "title": "simple-python-solution-in-one-line-with-explanation",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        res=\\'\\'\\n        li=[]\\n        str1=\"\"\\n\\t\\t#initialization of variables\\n        s1=\\'\\'\\n        s2=\\'\\'\\n        a=0\\n        b=0\\n        s1=ord(s[0]) #1st char ascii value\\n        a=int(s[1]) #2nd char int value\\n        s2=ord(s[3])\\n        b=int(s[4])\\n        #print(s1,a,s2,b)\\n        return [chr(i)+ str(j) for i in range(s1,s2+1) for j in range(a,b+1)]\\n\\t\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        res=\\'\\'\\n        li=[]\\n        str1=\"\"\\n\\t\\t#initialization of variables\\n        s1=\\'\\'\\n        s2=\\'\\'\\n        a=0\\n        b=0\\n        s1=ord(s[0]) #1st char ascii value\\n        a=int(s[1]) #2nd char int value\\n        s2=ord(s[3])\\n        b=int(s[4])\\n        #print(s1,a,s2,b)\\n        return [chr(i)+ str(j) for i in range(s1,s2+1) for j in range(a,b+1)]\\n\\t\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2331632,
                "title": "java-easy-4-line-code",
                "content": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> result = new ArrayList<>();\\n        for (char letter=s.charAt(0);letter<=s.charAt(3);letter++){\\n            for (char digit=s.charAt(1);digit<=s.charAt(4);digit++){\\n                result.add(letter+\"\"+digit);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\nfor any queries comment down and if you like this solution then upvote",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> result = new ArrayList<>();\\n        for (char letter=s.charAt(0);letter<=s.charAt(3);letter++){\\n            for (char digit=s.charAt(1);digit<=s.charAt(4);digit++){\\n                result.add(letter+\"\"+digit);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329490,
                "title": "using-flatmap-in-kotlin",
                "content": "```kotlin\\nclass Solution {\\n    fun cellsInRange(s: String): List<String> =\\n        s.split(\":\").flatMap { it.toList() }\\n            .let { (startCol, startRow, endCol, endRow) ->\\n                (startCol..endCol).flatMap { col ->\\n                    (startRow..endRow).map { row -> \"$col$row\" }\\n                }\\n            }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kotlin\\nclass Solution {\\n    fun cellsInRange(s: String): List<String> =\\n        s.split(\":\").flatMap { it.toList() }\\n            .let { (startCol, startRow, endCol, endRow) ->\\n                (startCol..endCol).flatMap { col ->\\n                    (startRow..endRow).map { row -> \"$col$row\" }\\n                }\\n            }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295630,
                "title": "python3-one-liner-solution",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(j)+str(i) for j in range(ord(s[0]), ord(s[3])+1) for i in range(int(s[1]), int(s[4])+1) ]\\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(j)+str(i) for j in range(ord(s[0]), ord(s[3])+1) for i in range(int(s[1]), int(s[4])+1) ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291419,
                "title": "java-solution-faster-than-100-00-and-runtime-1-ms",
                "content": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {        \\n        List<String> list = new ArrayList<>();\\n        \\n        int col1 = s.charAt(0); // A\\n        int row1 = s.charAt(1); // 1\\n        \\n        int col2 = s.charAt(3); // F\\n        int row2 = s.charAt(4); // 1\\n        \\n        for(int j = col1; j <= col2; j++) {\\n            for(int i = row1; i <= row2; i++) {\\n                StringBuffer sb = new StringBuffer();\\n                \\n                sb.append((char)j); // A\\n                sb.append((char)i); // 1\\n                \\n                list.add(sb.toString()); // A1\\n            }\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {        \\n        List<String> list = new ArrayList<>();\\n        \\n        int col1 = s.charAt(0); // A\\n        int row1 = s.charAt(1); // 1\\n        \\n        int col2 = s.charAt(3); // F\\n        int row2 = s.charAt(4); // 1\\n        \\n        for(int j = col1; j <= col2; j++) {\\n            for(int i = row1; i <= row2; i++) {\\n                StringBuffer sb = new StringBuffer();\\n                \\n                sb.append((char)j); // A\\n                sb.append((char)i); // 1\\n                \\n                list.add(sb.toString()); // A1\\n            }\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2286524,
                "title": "ruby-ascii-loop-solution",
                "content": "\\n```ruby\\ndef cells_in_range(s)\\n    chars = s.split(\"\")\\n\\n    result = []\\n    (chars[0].sum..chars[3].sum).each do |item|\\n        (chars[1].to_i..chars.last.to_i).each do |i|\\n            result << \"#{item.chr}#{i}\"\\n        end\\n    end\\n\\n    result\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef cells_in_range(s)\\n    chars = s.split(\"\")\\n\\n    result = []\\n    (chars[0].sum..chars[3].sum).each do |item|\\n        (chars[1].to_i..chars.last.to_i).each do |i|\\n            result << \"#{item.chr}#{i}\"\\n        end\\n    end\\n\\n    result\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2225711,
                "title": "easy-to-understand-solution",
                "content": "**Problem**: \\nWe have to return a vector containing cells from range x to y. For this, we would need to iterate from column col1 to col2 and for each iteration, iterate over rows from row1 to row2 (all inclusive).\\n\\n**Approach**:\\nWe know that the string given to us in the format: [col1][row1]:[col2][row2]\\nso, s[0] will contain the value col1, s[1] will contain row1, s[2] would be a colon(:), s[3] will contain col2, and s[4] will contain row2.\\nSo, we need to run an iteration from s[0] till s[3]. And for each iteration, iterate from s[1] to s[4], and hence, add values in the format: [column][row] to a string and insert the string to the vector.\\n\\n**Solution**:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> ans; //vector in which we would store our result\\n        for(char column=s[0];column<=s[3];column++) //iterating over columns from col1 to col2\\n        {\\n            for(int row=s[1]-\\'0\\';row<=s[4]-\\'0\\';row++) //iterating over rows from row1 to row2\\n            {\\n                string current=\"\"; // we take an empty string for the cell\\n                current+=column; // add the column to the string\\n                current+=to_string(row); // add the row number in form of string to the string\\n                ans.push_back(current); // push the string to the vector\\n            }\\n        }\\n        return ans; // return the vector\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> ans; //vector in which we would store our result\\n        for(char column=s[0];column<=s[3];column++) //iterating over columns from col1 to col2\\n        {\\n            for(int row=s[1]-\\'0\\';row<=s[4]-\\'0\\';row++) //iterating over rows from row1 to row2\\n            {\\n                string current=\"\"; // we take an empty string for the cell\\n                current+=column; // add the column to the string\\n                current+=to_string(row); // add the row number in form of string to the string\\n                ans.push_back(current); // push the string to the vector\\n            }\\n        }\\n        return ans; // return the vector\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2160205,
                "title": "java-simple",
                "content": ">**T/S:** O(mn)/O(1), where m = number of rows, n = number of columns. Actually it\\'ll be O(1)\\n```\\npublic List<String> cellsInRange(String s) {\\n\\tvar cells = new ArrayList<String>();\\n\\t\\n\\tfor (var i = s.charAt(0); i <= s.charAt(3); i++)\\n\\t\\tfor (var j = s.charAt(1); j <= s.charAt(4); j++)\\n\\t\\t\\tcells.add(i + \"\" + j);\\n\\treturn cells;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<String> cellsInRange(String s) {\\n\\tvar cells = new ArrayList<String>();\\n\\t\\n\\tfor (var i = s.charAt(0); i <= s.charAt(3); i++)\\n\\t\\tfor (var j = s.charAt(1); j <= s.charAt(4); j++)\\n\\t\\t\\tcells.add(i + \"\" + j);\\n\\treturn cells;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2090950,
                "title": "swift-ascii-play",
                "content": "```\\nimport Foundation\\nclass Solution {\\n    func cellsInRange(_ s: String) -> [String] {\\n\\n        let arr = Array(s)\\n        let s0 = arr[0].unicodeScalars.first!.value\\n        let s3 = arr[3].unicodeScalars.first!.value\\n        \\n        let s1 = Int(\"\\\\(arr[1])\")!\\n        let s4 = Int(\"\\\\(arr[4])\")!\\n        \\n        var op: [String] = []\\n        for i in s0...s3 {\\n            for j in s1...s4 {\\n                op.append(\"\\\\(Character(UnicodeScalar(i)!))\\\\(j)\")\\n            }\\n        }\\n        \\n        return op\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nimport Foundation\\nclass Solution {\\n    func cellsInRange(_ s: String) -> [String] {\\n\\n        let arr = Array(s)\\n        let s0 = arr[0].unicodeScalars.first!.value\\n        let s3 = arr[3].unicodeScalars.first!.value\\n        \\n        let s1 = Int(\"\\\\(arr[1])\")!\\n        let s4 = Int(\"\\\\(arr[4])\")!\\n        \\n        var op: [String] = []\\n        for i in s0...s3 {\\n            for j in s1...s4 {\\n                op.append(\"\\\\(Character(UnicodeScalar(i)!))\\\\(j)\")\\n            }\\n        }\\n        \\n        return op\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2073029,
                "title": "88-or-100-solution-in-java-easy-understand",
                "content": "class Solution {\\n    public List<String> cellsInRange(String s) {\\n     //     88 % m/s solution\\n        char [] c=s.toCharArray();\\n       List<String> str= new ArrayList<>();\\n        \\n        \\n        for(char i=c[0];i<=c[3];i++){\\n             for(char j=c[1];j<=c[4];j++){\\n             str.add(new String(new char[]{i, j}));\\n            \\n        }\\n            \\n        }\\n         return str;  \\n        \\n        // second solution 100%\\n        \\n//            char sc = s.charAt(0), ec = s.charAt(3);\\n//         char sr = s.charAt(1), er = s.charAt(4);\\n//         List<String> res = new ArrayList<>();\\n        \\n//         for (char i = sc; i <= ec; ++i){\\n//             for (char j = sr; j <= er; ++j){\\n//                 res.add(new String(new char[]{i, j}));\\n//             }\\n//         }\\n        \\n//         return res;\\n    }\\n}\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<String> cellsInRange(String s) {\\n     //     88 % m/s solution\\n        char [] c=s.toCharArray();\\n       List<String> str= new ArrayList<>();\\n        \\n        \\n        for(char i=c[0];i<=c[3];i++){\\n             for(char j=c[1];j<=c[4];j++){\\n             str.add(new String(new char[]{i, j}",
                "codeTag": "Java"
            },
            {
                "id": 2010653,
                "title": "cells-in-a-range-on-an-excel-sheet-python3-easy",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        excel_row_start , excel_row_end = int(s[1]) , int(s[4])\\n        excel_column_start , excel_column_end = s[0], s[3]\\n        result = list()\\n        for col in range(ord(excel_column_start), ord(excel_column_end)+1):\\n            for row in range(excel_row_start , excel_row_end+1):\\n                result.append(chr(col)+str(row))\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        excel_row_start , excel_row_end = int(s[1]) , int(s[4])\\n        excel_column_start , excel_column_end = s[0], s[3]\\n        result = list()\\n        for col in range(ord(excel_column_start), ord(excel_column_end)+1):\\n            for row in range(excel_row_start , excel_row_end+1):\\n                result.append(chr(col)+str(row))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1972939,
                "title": "c-solution-0ms-faster-than-100",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Cells in a Range on an Excel Sheet.\\nMemory Usage: 7.9 MB, less than 19.65% of C++ online submissions for Cells in a Range on an Excel Sheet.\\n\\n```\\nclass Solution \\n{\\npublic:\\n    vector<string> cellsInRange(const string& s) \\n    {\\n        std::vector<std::string> res;\\n        for (char col = s[0]; col <= s[3]; col++)\\n        {\\n            for (char row = s[1]; row <= s[4]; row++)\\n            {\\n                std::string temp;\\n                temp += col;\\n                temp += row;\\n                res.push_back(temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<string> cellsInRange(const string& s) \\n    {\\n        std::vector<std::string> res;\\n        for (char col = s[0]; col <= s[3]; col++)\\n        {\\n            for (char row = s[1]; row <= s[4]; row++)\\n            {\\n                std::string temp;\\n                temp += col;\\n                temp += row;\\n                res.push_back(temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967286,
                "title": "kotlin",
                "content": "```\\nfun cellsInRange(s: String) = mutableListOf<String>().apply {\\n    (s.first()..s[3]).forEach {\\n        for (i in Character.getNumericValue(s[1])..Character.getNumericValue(s.last())) {\\n            add(\"$it$i\")\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun cellsInRange(s: String) = mutableListOf<String>().apply {\\n    (s.first()..s[3]).forEach {\\n        for (i in Character.getNumericValue(s[1])..Character.getNumericValue(s.last())) {\\n            add(\"$it$i\")\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1965664,
                "title": "c-straightforward-solution",
                "content": "```\\npublic class Solution {\\n    public IList<string> CellsInRange(string s) {\\n        List<string> res = new();\\n        char c1 = s.Split(\\':\\')[0][0];\\n        char c2 = s.Split(\\':\\')[1][0];\\n        int n1 = Convert.ToInt32(s.Split(\\':\\')[0][1])-\\'0\\';\\n        int n2 = Convert.ToInt32(s.Split(\\':\\')[1][1])-\\'0\\';\\n        for(int i=c1-\\'A\\'; i<=c2-\\'A\\'; i++)\\n        {\\n            for(int j=n1; j<=n2; j++)\\n            {\\n                res.Add(Convert.ToChar(\\'A\\'+i)+j.ToString());\\n            }\\n        }        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> CellsInRange(string s) {\\n        List<string> res = new();\\n        char c1 = s.Split(\\':\\')[0][0];\\n        char c2 = s.Split(\\':\\')[1][0];\\n        int n1 = Convert.ToInt32(s.Split(\\':\\')[0][1])-\\'0\\';\\n        int n2 = Convert.ToInt32(s.Split(\\':\\')[1][1])-\\'0\\';\\n        for(int i=c1-\\'A\\'; i<=c2-\\'A\\'; i++)\\n        {\\n            for(int j=n1; j<=n2; j++)\\n            {\\n                res.Add(Convert.ToChar(\\'A\\'+i)+j.ToString());\\n            }\\n        }        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944120,
                "title": "python-olution",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        v = []\\n        for i in range(ord(s[0]),ord(s[3])+1):\\n            for j in range(int(s[1]),int(s[4])+1):\\n                v.append(chr(i)+str(j))\\n        return v\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        v = []\\n        for i in range(ord(s[0]),ord(s[3])+1):\\n            for j in range(int(s[1]),int(s[4])+1):\\n                v.append(chr(i)+str(j))\\n        return v\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938601,
                "title": "ruby-one-liner",
                "content": "```\\n# @param {String} s\\n# @return {String[]}\\ndef cells_in_range(s)\\n  (s[0]..s[3]).to_a.product((s[1]..s[4]).to_a).map(&:join)  \\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {String} s\\n# @return {String[]}\\ndef cells_in_range(s)\\n  (s[0]..s[3]).to_a.product((s[1]..s[4]).to_a).map(&:join)  \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1937740,
                "title": "python-using-for-loops-faster-than-94",
                "content": "![image](https://assets.leetcode.com/users/images/fbf77fdd-8049-4de9-84dc-9ec5962516d9_1649721022.8458278.png)\\n\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        \\n        res = []\\n        for letter in range(ord(s[0]), ord(s[3]) + 1, 1):\\n            for i in range(int(s[1]), int(s[-1]) + 1):\\n                res.append(chr(letter) + str(i))\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        \\n        res = []\\n        for letter in range(ord(s[0]), ord(s[3]) + 1, 1):\\n            for i in range(int(s[1]), int(s[-1]) + 1):\\n                res.append(chr(letter) + str(i))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935658,
                "title": "easy-and-simple-solution-using-for-statement",
                "content": "```\\npublic class Solution {\\n    public IList<string> CellsInRange(string s) {\\n            IList<string> cells = new List<string>();\\n            int cs = Convert.ToInt32(s[1].ToString());\\n            int ce = Convert.ToInt32(s[4].ToString());\\n            char rs = s[0];\\n            char re = s[3];\\n               \\n            for(char j = rs; j <= re; j++) for(int i = cs; i <= ce; i++) cells.Add(j.ToString()+i.ToString());\\n            return cells;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> CellsInRange(string s) {\\n            IList<string> cells = new List<string>();\\n            int cs = Convert.ToInt32(s[1].ToString());\\n            int ce = Convert.ToInt32(s[4].ToString());\\n            char rs = s[0];\\n            char re = s[3];\\n               \\n            for(char j = rs; j <= re; j++) for(int i = cs; i <= ce; i++) cells.Add(j.ToString()+i.ToString());\\n            return cells;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918719,
                "title": "simple-python3-solution",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        c1, r1, c2, r2 = s[0], s[1], s[3], s[4]\\n        result = []\\n        for col in range(ord(c1), ord(c2) + 1):\\n            for row in range(ord(r1), ord(r2) + 1):\\n                result.append(f\"{chr(col)}{chr(row)}\")\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        c1, r1, c2, r2 = s[0], s[1], s[3], s[4]\\n        result = []\\n        for col in range(ord(c1), ord(c2) + 1):\\n            for row in range(ord(r1), ord(r2) + 1):\\n                result.append(f\"{chr(col)}{chr(row)}\")\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905642,
                "title": "easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> res;\\n        for (char i = s[0]; i <= s[3]; i++)\\n        {\\n            for (char j = s[1]; j <= s[4]; j++)\\n            {\\n                res.push_back({i,j});\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> res;\\n        for (char i = s[0]; i <= s[3]; i++)\\n        {\\n            for (char j = s[1]; j <= s[4]; j++)\\n            {\\n                res.push_back({i,j});\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885193,
                "title": "rust-simple-two-loops",
                "content": "```\\nimpl Solution {\\n    pub fn cells_in_range(s: String) -> Vec<String> {\\n        let mut ans = Vec::new();\\n        let s: Vec<char> = s.chars().collect();\\n        for i in s[0]..=s[3] {\\n            for j in s[1]..=s[4] {\\n                ans.push(format!(\"{}{}\", i, j));\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn cells_in_range(s: String) -> Vec<String> {\\n        let mut ans = Vec::new();\\n        let s: Vec<char> = s.chars().collect();\\n        for i in s[0]..=s[3] {\\n            for j in s[1]..=s[4] {\\n                ans.push(format!(\"{}{}\", i, j));\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1868457,
                "title": "javascript-solution",
                "content": "```\\nconst cellsInRange = (s) => {\\n  let letters = [s.charCodeAt(0), s.charCodeAt(3)]; // To get letter ASCII codes as columns\\n  let numbers = [Number(s[1]), Number(s[4])]; // For rows\\n  let res = [];\\n\\n  for (let i = letters[0]; i <= letters[1]; i++) {\\n    for (let j = numbers[0]; j <= numbers[1]; j++) {\\n      let cell = String.fromCharCode(i) + j;\\n      res.push(cell);\\n    }\\n  }\\n\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst cellsInRange = (s) => {\\n  let letters = [s.charCodeAt(0), s.charCodeAt(3)]; // To get letter ASCII codes as columns\\n  let numbers = [Number(s[1]), Number(s[4])]; // For rows\\n  let res = [];\\n\\n  for (let i = letters[0]; i <= letters[1]; i++) {\\n    for (let j = numbers[0]; j <= numbers[1]; j++) {\\n      let cell = String.fromCharCode(i) + j;\\n      res.push(cell);\\n    }\\n  }\\n\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1868179,
                "title": "python3-simple-two-loops-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        alphabet = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \\n                    \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \\n                    \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]\\n        \\n        res = []\\n        start = alphabet.index(s[0])\\n        \\n        for i in range(start, len(alphabet)):\\n            j1 = int(s[1])\\n            j2 = int(s[4])\\n            for j in range(j1, j2+1):\\n                res.append(\"\" + alphabet[i] + str(j))\\n            if alphabet[i] == s[3]:\\n                break\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        alphabet = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \\n                    \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \\n                    \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]\\n        \\n        res = []\\n        start = alphabet.index(s[0])\\n        \\n        for i in range(start, len(alphabet)):\\n            j1 = int(s[1])\\n            j2 = int(s[4])\\n            for j in range(j1, j2+1):\\n                res.append(\"\" + alphabet[i] + str(j))\\n            if alphabet[i] == s[3]:\\n                break\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856136,
                "title": "1-line-python-solution-80-faster-memory-less-than-25",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(i)+str(j) for i in range(ord(s[0]),ord(s[3])+1) for j in range(int(s[1]),int(s[4])+1)]\\n```\\n-------------------\\n***----- Taha Choura -----***\\n*taha.choura@outlook.com*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(i)+str(j) for i in range(ord(s[0]),ord(s[3])+1) for j in range(int(s[1]),int(s[4])+1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1854887,
                "title": "java-straight-forward-11ms-for",
                "content": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        String alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n        String number = \"0123456789\";\\n        ArrayList<String> list = new ArrayList<>();\\n        String str = new String();\\n        int colIndexStart = alpha.indexOf(Character.toString(s.charAt(0)));\\n        int colIndexEnd = alpha.indexOf(Character.toString(s.charAt(3)));\\n        int rowIndexStart = Integer.valueOf(s.charAt(1)-48);\\n        int rowIndexEnd = Integer.valueOf(s.charAt(4)-48);\\n        for(int i=colIndexStart; i<=colIndexEnd; i++){\\n            for(int j=rowIndexStart; j<=rowIndexEnd; j++){\\n                str += alpha.charAt(i);\\n                str += number.charAt(j);\\n                list.add(str);\\n                str = \"\";\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        String alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n        String number = \"0123456789\";\\n        ArrayList<String> list = new ArrayList<>();\\n        String str = new String();\\n        int colIndexStart = alpha.indexOf(Character.toString(s.charAt(0)));\\n        int colIndexEnd = alpha.indexOf(Character.toString(s.charAt(3)));\\n        int rowIndexStart = Integer.valueOf(s.charAt(1)-48);\\n        int rowIndexEnd = Integer.valueOf(s.charAt(4)-48);\\n        for(int i=colIndexStart; i<=colIndexEnd; i++){\\n            for(int j=rowIndexStart; j<=rowIndexEnd; j++){\\n                str += alpha.charAt(i);\\n                str += number.charAt(j);\\n                list.add(str);\\n                str = \"\";\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848280,
                "title": "c-cpp-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        int sc = s[0] - \\'A\\',ec = s[3] - \\'A\\', sr = s[1] - \\'1\\',er = s[4] - \\'1\\';\\n        vector<string> ans;\\n        for(int i = sc; i <= ec;i++){\\n            for(int j = sr ; j <= er;j++){\\n                ans.emplace_back(char(i + \\'A\\') + to_string(j + 1));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/a0b2b76f-d776-425e-8fa5-7bf4e6a5497d_1647246926.234795.png)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        int sc = s[0] - \\'A\\',ec = s[3] - \\'A\\', sr = s[1] - \\'1\\',er = s[4] - \\'1\\';\\n        vector<string> ans;\\n        for(int i = sc; i <= ec;i++){\\n            for(int j = sr ; j <= er;j++){\\n                ans.emplace_back(char(i + \\'A\\') + to_string(j + 1));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841324,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> ans;\\n        for(char c = s[0]; c <= s[3]; c++) {\\n            for(int i = s[1]-\\'0\\'; i <= s[4]-\\'0\\'; i++) {\\n                ans.push_back(string{c}+to_string(i));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> ans;\\n        for(char c = s[0]; c <= s[3]; c++) {\\n            for(int i = s[1]-\\'0\\'; i <= s[4]-\\'0\\'; i++) {\\n                ans.push_back(string{c}+to_string(i));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839756,
                "title": "very-easy-c-solution-with-detailed-explanation",
                "content": "Explanation\\n-\\n\\n- The cells in given range X1N1 : X2N2 will range from X1 to X1 and N1 to N2\\n- For example if we have A3:C5, the first value will range from A to C and second one from 3 to 5.\\n- So we use a nested loop to enter the cells inside the vector.\\n\\n**Please UPVOTE if you understood!!**\\n```\\n    vector<string> cellsInRange(string s) {\\n        vector<string> res;\\n        for(char a=s[0]; a<=s[3]; a++)\\n            for(char b=s[1]; b<=s[4]; b++)\\n                res.push_back({a, b});\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    vector<string> cellsInRange(string s) {\\n        vector<string> res;\\n        for(char a=s[0]; a<=s[3]; a++)\\n            for(char b=s[1]; b<=s[4]; b++)\\n                res.push_back({a, b});\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1833559,
                "title": "java-solution-time-space-o-n",
                "content": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> result = new ArrayList<>();\\n        String[] split = s.split(\":\");\\n        char fs = split[0].charAt(0);\\n        char ss = split[1].charAt(0);\\n        int li = split[0].charAt(0);\\n        int fi = (int) Character.getNumericValue(split[0].charAt(1));\\n        int si = (int)Character.getNumericValue(split[1].charAt(1));\\n        int temp = fi;\\n\\n        while(li <= split[1].charAt(0)) {\\n            result.add((char)li+String.valueOf(temp));\\n            if(temp == si) {\\n                li++;\\n                temp = fi;\\n            } else \\n                temp++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> result = new ArrayList<>();\\n        String[] split = s.split(\":\");\\n        char fs = split[0].charAt(0);\\n        char ss = split[1].charAt(0);\\n        int li = split[0].charAt(0);\\n        int fi = (int) Character.getNumericValue(split[0].charAt(1));\\n        int si = (int)Character.getNumericValue(split[1].charAt(1));\\n        int temp = fi;\\n\\n        while(li <= split[1].charAt(0)) {\\n            result.add((char)li+String.valueOf(temp));\\n            if(temp == si) {\\n                li++;\\n                temp = fi;\\n            } else \\n                temp++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829597,
                "title": "beginner-friendly-javascript-solution",
                "content": "**Time Complexity : O(n*m)**\\nwhere n = number of rows; m = number of columns\\n```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar cellsInRange = function(s) {\\n    var list = [];\\n    let c1 = s.charCodeAt(0), c2 = s.charCodeAt(3), r1 = s[1], r2 = s[4];\\n    for(let c=c1; c<=c2; c++){\\n      for(let r=r1; r<=r2; r++){\\n          list.push(String.fromCharCode(c) + r);\\n      }\\n    }\\n    return list;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar cellsInRange = function(s) {\\n    var list = [];\\n    let c1 = s.charCodeAt(0), c2 = s.charCodeAt(3), r1 = s[1], r2 = s[4];\\n    for(let c=c1; c<=c2; c++){\\n      for(let r=r1; r<=r2; r++){\\n          list.push(String.fromCharCode(c) + r);\\n      }\\n    }\\n    return list;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1829577,
                "title": "beginner-friendly-java-solution",
                "content": "**Time Complexity : O(n*m)**\\nwhere n = number of rows; m = number of columns\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> list = new ArrayList<>();\\n        char c1 = s.charAt(0), c2 = s.charAt(3);\\n        char r1 = s.charAt(1), r2 = s.charAt(4);\\n        for(char c=c1; c<=c2; c++){\\n            for(char r=r1; r<=r2; r++){\\n                list.add(\"\" + c + r);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> list = new ArrayList<>();\\n        char c1 = s.charAt(0), c2 = s.charAt(3);\\n        char r1 = s.charAt(1), r2 = s.charAt(4);\\n        for(char c=c1; c<=c2; c++){\\n            for(char r=r1; r<=r2; r++){\\n                list.add(\"\" + c + r);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829425,
                "title": "java-2ms-98-explanations",
                "content": "```\\nclass Solution {\\n    /** Algorithm\\n        1. Loop from the starting letter to ending letter\\n        2. Inside this loop, loop again from starting number to ending number\\n        3. Use a char[2] to store the chars and add it to the list of cells.\\n        4. Return the answer/cells.\\n    */\\n    public List<String> cellsInRange(String s) {\\n        List<String> cells = new ArrayList<>();\\n        char[] cell = new char[2];\\n        for (char l = s.charAt(0); l <= s.charAt(3); l++) {\\n            cell[0] = l;\\n            for (char n = s.charAt(1); n <= s.charAt(4); n++) {\\n                cell[1] = n;\\n                cells.add(new String(cell));\\n            }\\n        }\\n        return cells;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    /** Algorithm\\n        1. Loop from the starting letter to ending letter\\n        2. Inside this loop, loop again from starting number to ending number\\n        3. Use a char[2] to store the chars and add it to the list of cells.\\n        4. Return the answer/cells.\\n    */\\n    public List<String> cellsInRange(String s) {\\n        List<String> cells = new ArrayList<>();\\n        char[] cell = new char[2];\\n        for (char l = s.charAt(0); l <= s.charAt(3); l++) {\\n            cell[0] = l;\\n            for (char n = s.charAt(1); n <= s.charAt(4); n++) {\\n                cell[1] = n;\\n                cells.add(new String(cell));\\n            }\\n        }\\n        return cells;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828768,
                "title": "c-reserve-capacity-reuse-string-and-emplace-rather-than-push",
                "content": "The problem is trivial but we do a few things right beyond the bare minimum to solve it:\\n\\n1. We reserve the exact required capacity in our output vector.\\n2. We keep one string around and reuse it in our inner loop.\\n3. We transfer the string contents into our output vector with `emplace_back()` rather than `push_back()`\\n\\nWe also take a `string_view` rather than letting a string be passed in by value. \\n\\n## C++ Code\\n\\n```c++\\n    static vector<string> cellsInRange(const string_view s)\\n    {\\n        // The ends of the column and row ranges:\\n        const auto cend = s[3];\\n        const auto rend = s[4];\\n        \\n        // Let\\'s preallocate the exact heap space we need for our result vector:\\n        // If we didn\\'t do this we\\'d grow it exponentially and end up with unused\\n        // slop at the end of the final allocation most of the time.\\n        vector<string> res;\\n        res.reserve((cend - s[0]) * (rend-s[1]));\\n        \\n        // Let\\'s have a single string that we reuse in the inner loop:\\n        string str;\\n        str.resize(2);\\n        \\n        for(auto col = s[0]; col <= cend; ++col)\\n        {\\n            for(auto row = s[1]; row <= rend; ++row)\\n            {\\n                str[0] = col;\\n                str[1] = row;\\n                // Let\\'s emplace_back rather than push back:\\n                // I.e., we run the string copy constructor on\\n                // the raw memory at the back of the vector. \\n                res.emplace_back(str);\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n# Emplace Empty String Variant\\n\\nInstead of copy constructing at the end of the result vector, we can default construct there and then resize and write the two desired characters into the correct locations within the result vector\\'s single heap allocation, relying on the small string optimisation to make the resize a trivial, non-allocating operation.\\n\\n## C++ Code\\n\\n```c++\\n    static vector<string> cellsInRange(const string_view s)\\n    {\\n        // The ends of the column and row ranges:\\n        const auto cend = s[3];\\n        const auto rend = s[4];\\n        \\n        // Let\\'s preallocate the exact heap space we need for our result vector:\\n        // If we didn\\'t do this we\\'d grow it exponentially and end up with unused\\n        // slop at the end of the final allocation most of the time.\\n        vector<string> res;\\n        res.reserve((cend - s[0]) * (rend-s[1]));\\n                \\n        for(auto col = s[0]; col <= cend; ++col)\\n        {\\n            for(auto row = s[1]; row <= rend; ++row)\\n            {\\n                // Let\\'s emplace_back rather than push back:\\n                // I.e., we run the string default constructor on\\n                // the raw memory at the back of the vector.\\n                // We then write row and colum directly into the string\\n                // at the back of the result vector:\\n                res.emplace_back();\\n                string& str = res.back();\\n                str.resize(2);\\n                str[0] = col;\\n                str[1] = row;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n# Notes\\n\\n* Although we make an effort to avoid allocating too much memory in these implementations, having power of two allocations might have upsides in some uses. For instance, if the results are only kept around temporarily as a step in some larger algorithm and then freed, the standard allocation sizes of the usual growth pattern might be quicker to allocate and free to memory pools. Customised allocations of minimal length, however, might fall back to a slower, general purpose allocation strategy, with the freeing step walking a list of free blocks looking for neighbours to coalesce with rather than simply adding the block to a fixed-size pool.",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\n    static vector<string> cellsInRange(const string_view s)\\n    {\\n        // The ends of the column and row ranges:\\n        const auto cend = s[3];\\n        const auto rend = s[4];\\n        \\n        // Let\\'s preallocate the exact heap space we need for our result vector:\\n        // If we didn\\'t do this we\\'d grow it exponentially and end up with unused\\n        // slop at the end of the final allocation most of the time.\\n        vector<string> res;\\n        res.reserve((cend - s[0]) * (rend-s[1]));\\n        \\n        // Let\\'s have a single string that we reuse in the inner loop:\\n        string str;\\n        str.resize(2);\\n        \\n        for(auto col = s[0]; col <= cend; ++col)\\n        {\\n            for(auto row = s[1]; row <= rend; ++row)\\n            {\\n                str[0] = col;\\n                str[1] = row;\\n                // Let\\'s emplace_back rather than push back:\\n                // I.e., we run the string copy constructor on\\n                // the raw memory at the back of the vector. \\n                res.emplace_back(str);\\n            }\\n        }\\n        return res;\\n    }\\n```\n```c++\\n    static vector<string> cellsInRange(const string_view s)\\n    {\\n        // The ends of the column and row ranges:\\n        const auto cend = s[3];\\n        const auto rend = s[4];\\n        \\n        // Let\\'s preallocate the exact heap space we need for our result vector:\\n        // If we didn\\'t do this we\\'d grow it exponentially and end up with unused\\n        // slop at the end of the final allocation most of the time.\\n        vector<string> res;\\n        res.reserve((cend - s[0]) * (rend-s[1]));\\n                \\n        for(auto col = s[0]; col <= cend; ++col)\\n        {\\n            for(auto row = s[1]; row <= rend; ++row)\\n            {\\n                // Let\\'s emplace_back rather than push back:\\n                // I.e., we run the string default constructor on\\n                // the raw memory at the back of the vector.\\n                // We then write row and colum directly into the string\\n                // at the back of the result vector:\\n                res.emplace_back();\\n                string& str = res.back();\\n                str.resize(2);\\n                str[0] = col;\\n                str[1] = row;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1827593,
                "title": "c-simple-and-straightforward",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> result;\\n        \\n        for(int i = s[0] - \\'A\\'; i <= s[3] - \\'A\\'; i++){\\n            for(int j = s[1] - \\'0\\'; j <= s[4] - \\'0\\'; j++){\\n                result.push_back(string(1, char(i + 65)) + string(1, char(j + 48)));\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n**Please upvote if you love the solution**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> result;\\n        \\n        for(int i = s[0] - \\'A\\'; i <= s[3] - \\'A\\'; i++){\\n            for(int j = s[1] - \\'0\\'; j <= s[4] - \\'0\\'; j++){\\n                result.push_back(string(1, char(i + 65)) + string(1, char(j + 48)));\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825571,
                "title": "c-simple-implementation",
                "content": "```\\nclass Solution\\n{\\n  public:\\n    vector<string> cellsInRange(string s)\\n    {\\n        vector<string> result;\\n        string temp = \"\";\\n        for (char i = s[0]; i <= s[3]; i++)\\n        {\\n            temp = \"\";\\n            temp += i;\\n            for (char j = s[1]; j <= s[4]; j++)\\n            {\\n                temp += j;\\n                result.push_back(temp);\\n                temp.pop_back();\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n  public:\\n    vector<string> cellsInRange(string s)\\n    {\\n        vector<string> result;\\n        string temp = \"\";\\n        for (char i = s[0]; i <= s[3]; i++)\\n        {\\n            temp = \"\";\\n            temp += i;\\n            for (char j = s[1]; j <= s[4]; j++)\\n            {\\n                temp += j;\\n                result.push_back(temp);\\n                temp.pop_back();\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825539,
                "title": "easy-understanding",
                "content": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> ans=new ArrayList<>();\\n        \\n        String[]arr=s.split(\":\");\\n        char sc=arr[0].charAt(0);\\n        int sr=Integer.parseInt(arr[0].substring(1));\\n        \\n        char ec=arr[1].charAt(0);\\n        int er=Integer.parseInt(arr[1].substring(1));\\n        \\n        for(int i=sc;i<=ec;i++){\\n            getAll(sr,i,er,ec,ans);\\n        }\\n        return ans;\\n    }\\n    \\n    public void getAll(int sr, int sc, int er, int ec,List<String> ans){\\n        while(sr<=er){\\n            ans.add((char)sc+\"\"+sr);\\n            sr++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> ans=new ArrayList<>();\\n        \\n        String[]arr=s.split(\":\");\\n        char sc=arr[0].charAt(0);\\n        int sr=Integer.parseInt(arr[0].substring(1));\\n        \\n        char ec=arr[1].charAt(0);\\n        int er=Integer.parseInt(arr[1].substring(1));\\n        \\n        for(int i=sc;i<=ec;i++){\\n            getAll(sr,i,er,ec,ans);\\n        }\\n        return ans;\\n    }\\n    \\n    public void getAll(int sr, int sc, int er, int ec,List<String> ans){\\n        while(sr<=er){\\n            ans.add((char)sc+\"\"+sr);\\n            sr++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825495,
                "title": "python-one-line-use-ord-and-chr",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(c)+str(r) for c in range(ord(s[0]),ord(s[3])+1) for r in range(int(s[1]),int(s[4])+1)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(c)+str(r) for c in range(ord(s[0]),ord(s[3])+1) for r in range(int(s[1]),int(s[4])+1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825244,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        char c1 = s[0];\\n        char r1 = s[1];\\n        char c2 = s[3];\\n        char r2 = s[4];\\n        vector<string> ans;\\n        for(int i=0;i+c1<=c2;i++)\\n        {\\n            for(int j=0;j+r1<=r2;j++)\\n            {\\n                string res;\\n                // s = \"K1:L2\"\\n                // here c1 = k,c2 = L,r1 = 1,r2 = 2 ,i=j=0.;\\n                // after 1st execution of for loop for j res = k+0+1+0 = k1\\n                // after 2nd execution of for loop for j res = k+0+1+1 = k2\\n                // after execution of for loop for i res = k+1+1+0 = L1\\n                res+=(c1+i);\\n                res+=(r1+j);\\n                ans.push_back(res);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        char c1 = s[0];\\n        char r1 = s[1];\\n        char c2 = s[3];\\n        char r2 = s[4];\\n        vector<string> ans;\\n        for(int i=0;i+c1<=c2;i++)\\n        {\\n            for(int j=0;j+r1<=r2;j++)\\n            {\\n                string res;\\n                // s = \"K1:L2\"\\n                // here c1 = k,c2 = L,r1 = 1,r2 = 2 ,i=j=0.;\\n                // after 1st execution of for loop for j res = k+0+1+0 = k1\\n                // after 2nd execution of for loop for j res = k+0+1+1 = k2\\n                // after execution of for loop for i res = k+1+1+0 = L1\\n                res+=(c1+i);\\n                res+=(r1+j);\\n                ans.push_back(res);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825193,
                "title": "simple-c-100-0ms-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<string> cellsInRange(string s) {\\n\\t\\t\\tstring ans=\"\";\\n\\t\\t\\tvector<string> v1;\\n\\t\\t\\tint a=int(s[0]),b=s[1]-\\'0\\',c=int(s[3]),d=s[4]-\\'0\\';\\n\\t\\t\\tint n=abs(a-c);\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<=n;i++)\\n\\t\\t\\t  {\\n\\t\\t\\t\\t  for(int j=b;j<=d;j++)\\n              {\\n\\t\\t\\t\\tans+=char(a+i);    \\n\\t\\t\\t\\tans+=to_string(j);\\n\\t\\t\\t\\tv1.push_back(ans);\\n\\t\\t\\t\\tans=\"\";\\n          }\\n        }\\n\\t\\t\\treturn v1;\\n\\t\\t\\t}\\n\\t  };",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<string> cellsInRange(string s) {\\n\\t\\t\\tstring ans=\"\";\\n\\t\\t\\tvector<string> v1;\\n\\t\\t\\tint a=int(s[0]),b=s[1]-\\'0\\',c=int(s[3]),d=s[4]-\\'0\\';\\n\\t\\t\\tint n=abs(a-c);\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<=n;i++)\\n\\t\\t\\t  {\\n\\t\\t\\t\\t  for(int j=b;j<=d;j++)\\n              {\\n\\t\\t\\t\\tans+=char(a+i);    \\n\\t\\t\\t\\tans+=to_string(j);\\n\\t\\t\\t\\tv1.push_back(ans);\\n\\t\\t\\t\\tans=\"\";\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 1824768,
                "title": "faster-c-solution",
                "content": "vector<string> ans;\\n        for(char col = \\'A\\'; col <= \\'Z\\'; col++) {\\n            for(char row = \\'1\\'; row <= \\'9\\'; row++) {\\n                if(row >= s[1] && row <= s[4] && col >= s[0] && col <= s[3])\\n                    ans.push_back(string(1, col) + string(1, row));\\n            }\\n        }\\n        return ans;\\n\\t\\t\\n\\t\\t\\n\\tif(helps){\\n\\tupvotes++;\\n\\t}\\n\\telse ignore;",
                "solutionTags": [
                    "C"
                ],
                "code": "vector<string> ans;\\n        for(char col = \\'A\\'; col <= \\'Z\\'; col++) {\\n            for(char row = \\'1\\'; row <= \\'9\\'; row++) {\\n                if(row >= s[1] && row <= s[4] && col >= s[0] && col <= s[3])\\n                    ans.push_back(string(1, col) + string(1, row));\\n            }\\n        }\\n        return ans;\\n\\t\\t\\n\\t\\t\\n\\tif(helps){\\n\\tupvotes++;\\n\\t}\\n\\telse ignore;",
                "codeTag": "Unknown"
            },
            {
                "id": 1824368,
                "title": "c-nested-loop-easiest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        char col1 = s[0];\\n        char col2 = s[3];\\n        char row1 = s[1];\\n        char row2 = s[4];\\n        \\n        vector<string> res;\\n        \\n        for(char ch=col1;ch<=col2;ch++){\\n            for(char rw=row1;rw<=row2;rw++){\\n                string temp = \"\";\\n                temp += ch;\\n                temp += rw;\\n                res.push_back(temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        char col1 = s[0];\\n        char col2 = s[3];\\n        char row1 = s[1];\\n        char row2 = s[4];\\n        \\n        vector<string> res;\\n        \\n        for(char ch=col1;ch<=col2;ch++){\\n            for(char rw=row1;rw<=row2;rw++){\\n                string temp = \"\";\\n                temp += ch;\\n                temp += rw;\\n                res.push_back(temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824255,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        string start=s.substr(0,2);\\n        string end=s.substr(3,2);\\n        vector<string> res;\\n        for(char i=start[0];i<=end[0];i++)\\n            for(char j=start[1];j<=end[1];j++){\\n                    stringstream ss;\\n                    ss<<i<<j;\\n                    res.push_back(ss.str());\\n                }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        string start=s.substr(0,2);\\n        string end=s.substr(3,2);\\n        vector<string> res;\\n        for(char i=start[0];i<=end[0];i++)\\n            for(char j=start[1];j<=end[1];j++){\\n                    stringstream ss;\\n                    ss<<i<<j;\\n                    res.push_back(ss.str());\\n                }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823890,
                "title": "easy-java-solution",
                "content": "List<String> res = new ArrayList<>();\\n        \\n        for (char c = s.charAt(0); c <= s.charAt(3); c++) {\\n            for (int i = s.charAt(1)-\\'0\\'; i <= s.charAt(4)-\\'0\\'; i++) {\\n                res.add(c + \"\" + i);                \\n            }\\n        }\\n        return res;",
                "solutionTags": [],
                "code": "List<String> res = new ArrayList<>();\\n        \\n        for (char c = s.charAt(0); c <= s.charAt(3); c++) {\\n            for (int i = s.charAt(1)-\\'0\\'; i <= s.charAt(4)-\\'0\\'; i++) {\\n                res.add(c + \"\" + i);                \\n            }\\n        }\\n        return res;",
                "codeTag": "Unknown"
            },
            {
                "id": 1823807,
                "title": "java-easy-solution-approach-explained",
                "content": "As result has to be first column sorted, then row sorted.\\nSo, loop through `c1 to c2` & add cells from `r1 to r2 for each column.`\\n\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        char c1 = s.charAt(0);\\n        char r1 = s.charAt(1);\\n        \\n        char c2 = s.charAt(3);\\n        char r2 = s.charAt(4);\\n        \\n        List<String> res = new ArrayList<>();\\n        while (c1 <= c2) {\\n            char temp = r1;\\n            while (temp <= r2) {\\n                res.add(c1 + \"\" + temp);\\n                ++temp;\\n            }\\n            ++c1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        char c1 = s.charAt(0);\\n        char r1 = s.charAt(1);\\n        \\n        char c2 = s.charAt(3);\\n        char r2 = s.charAt(4);\\n        \\n        List<String> res = new ArrayList<>();\\n        while (c1 <= c2) {\\n            char temp = r1;\\n            while (temp <= r2) {\\n                res.add(c1 + \"\" + temp);\\n                ++temp;\\n            }\\n            ++c1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823718,
                "title": "easy-c-bruteforce",
                "content": "\\t char a=s[0];\\n        char b=s[3];\\n        char c=s[1];\\n        char d=s[4];\\n        vector<string>res;\\n        for(char i=a;i<=b;i++){\\n           \\n            for(char x=c;x<=d;x++ ){\\n                string temp;\\n                temp+=i;\\n                temp+=x;\\n                res.push_back(temp);\\n            }\\n        }\\n        return res;",
                "solutionTags": [],
                "code": "\\t char a=s[0];\\n        char b=s[3];\\n        char c=s[1];\\n        char d=s[4];\\n        vector<string>res;\\n        for(char i=a;i<=b;i++){\\n           \\n            for(char x=c;x<=d;x++ ){\\n                string temp;\\n                temp+=i;\\n                temp+=x;\\n                res.push_back(temp);\\n            }\\n        }\\n        return res;",
                "codeTag": "Unknown"
            },
            {
                "id": 1823685,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> ans;\\n        char c1 = s[0];\\n        char r1 = s[1];\\n        char c2 = s[3];\\n        char r2 = s[4];\\n        \\n        char rmin = min(r1,r2);\\n        char rmax = max(r1,r2);\\n        char cmin = min(c1,c2);\\n        char cmax = max(c1,c2);\\n        \\n        while(cmin <= cmax){\\n            char l = rmin; \\n            char r = rmax;\\n            while(l <= r){\\n                string str;\\n                str.push_back(cmin);\\n                str.push_back(l);\\n                ans.push_back(str);\\n                l++;\\n            }\\n            cmin++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> ans;\\n        char c1 = s[0];\\n        char r1 = s[1];\\n        char c2 = s[3];\\n        char r2 = s[4];\\n        \\n        char rmin = min(r1,r2);\\n        char rmax = max(r1,r2);\\n        char cmin = min(c1,c2);\\n        char cmax = max(c1,c2);\\n        \\n        while(cmin <= cmax){\\n            char l = rmin; \\n            char r = rmax;\\n            while(l <= r){\\n                string str;\\n                str.push_back(cmin);\\n                str.push_back(l);\\n                ans.push_back(str);\\n                l++;\\n            }\\n            cmin++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823667,
                "title": "java-simple-loop-explanation",
                "content": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        String [] sp = s.split(\":\");\\n        int l = sp[0].charAt(1) -\\'0\\'; //col left\\n        int r = sp[1].charAt(1) -\\'0\\'; //col right\\n        int lc = sp[0].charAt(0); // row left\\n        int rc = sp[1].charAt(0); // row right\\n        List<String> out = new ArrayList<>();\\n        for(int i=lc;i<=rc;i++){\\n            for(int j=l;j<=r;j++){\\n                out.add(((char) i) + String.valueOf(j));\\n            }\\n        }\\n        return out;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<String> cellsInRange(String s) {\\n        String [] sp = s.split(\":\");\\n        int l = sp[0].charAt(1) -\\'0\\'; //col left\\n        int r = sp[1].charAt(1) -\\'0\\'; //col right\\n        int lc = sp[0].charAt(0); // row left\\n        int rc = sp[1].charAt(0); // row right\\n        List<String> out = new ArrayList<>();\\n        for(int i=lc;i<=rc;i++){\\n            for(int j=l;j<=r;j++){\\n                out.add(((char) i) + String.valueOf(j));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1823631,
                "title": "c-straightforward",
                "content": "\\n\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-283/problems/cells-in-a-range-on-an-excel-sheet/\\n// Author: github.com/lzl124631x\\n// Time: O(1) since there are at most 26 * 9 cells.\\n// Space: O(1) extra space\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> ans;\\n        char a = s[0], b = s[3], x = s[1], y = s[4];\\n        for (; a <= b; ++a) {\\n            for (char i = x; i <= y; ++i) {\\n                ans.push_back(string(1, a) + string(1, i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-283/problems/cells-in-a-range-on-an-excel-sheet/\\n// Author: github.com/lzl124631x\\n// Time: O(1) since there are at most 26 * 9 cells.\\n// Space: O(1) extra space\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> ans;\\n        char a = s[0], b = s[3], x = s[1], y = s[4];\\n        for (; a <= b; ++a) {\\n            for (char i = x; i <= y; ++i) {\\n                ans.push_back(string(1, a) + string(1, i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092928,
                "title": "python3-solution",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n      s=s.split(\\':\\')\\n      l1,l2=s[0][0],s[1][0]\\n      n1,n2=int(s[0][1]),int(s[1][1])\\n      L=[]\\n      ans=\\'\\'\\n      for i in range(ord(l1),ord(l2)+1):\\n          for j in range(n1,n2+1):\\n                ans=chr(i)+str(j)\\n                L.append(ans)\\n      return L\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n      s=s.split(\\':\\')\\n      l1,l2=s[0][0],s[1][0]\\n      n1,n2=int(s[0][1]),int(s[1][1])\\n      L=[]\\n      ans=\\'\\'\\n      for i in range(ord(l1),ord(l2)+1):\\n          for j in range(n1,n2+1):\\n                ans=chr(i)+str(j)\\n                L.append(ans)\\n      return L\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091141,
                "title": "simples-c-solution-no-overengineering-keep-it-simple",
                "content": "Simple and intutive solution!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n      vector<string> ans;\\n      int fromCIndex = s[0]-0, toCIndex = s[3]-0, fromIndex = s[1]-48, toIndex = s[4]-48;\\n      for(int i=fromCIndex;i<=toCIndex;i++) {\\n        for(int j=fromIndex; j<=toIndex;j++) {\\n          string x=(char)i + to_string(j);\\n          ans.push_back(x);\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n      vector<string> ans;\\n      int fromCIndex = s[0]-0, toCIndex = s[3]-0, fromIndex = s[1]-48, toIndex = s[4]-48;\\n      for(int i=fromCIndex;i<=toCIndex;i++) {\\n        for(int j=fromIndex; j<=toIndex;j++) {\\n          string x=(char)i + to_string(j);\\n          ans.push_back(x);\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087499,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        int startCol = s[0] - \\'A\\';\\n        int endCol = s[3] - \\'A\\';\\n        int startRow = s[1] - \\'0\\';\\n        int endRow = s[4] - \\'0\\';\\n        vector<string> res;\\n        for (int col = startCol; col <= endCol; col++)\\n        {\\n            for (int row = startRow; row <= endRow; row++)\\n            {\\n                char tmp[3];\\n                tmp[0] = \\'A\\' + col;\\n                tmp[1] = \\'0\\' + row;\\n                tmp[2] = 0;\\n                res.push_back(string(tmp));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        int startCol = s[0] - \\'A\\';\\n        int endCol = s[3] - \\'A\\';\\n        int startRow = s[1] - \\'0\\';\\n        int endRow = s[4] - \\'0\\';\\n        vector<string> res;\\n        for (int col = startCol; col <= endCol; col++)\\n        {\\n            for (int row = startRow; row <= endRow; row++)\\n            {\\n                char tmp[3];\\n                tmp[0] = \\'A\\' + col;\\n                tmp[1] = \\'0\\' + row;\\n                tmp[2] = 0;\\n                res.push_back(string(tmp));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081414,
                "title": "cells-in-a-range-on-an-excel-sheet",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> ans = new ArrayList<>();\\n\\n        char startRow = s.charAt(0);\\n        char startCol = s.charAt(1);\\n        char endRow = s.charAt(3);\\n        char endCol = s.charAt(4);\\n\\n        while(startRow<=endRow)\\n        {\\n            while(startCol <= endCol)\\n            {\\n                ans.add(startRow+\"\"+startCol);\\n                startCol++;\\n            }\\n            startCol = s.charAt(1);\\n            startRow++;\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> ans = new ArrayList<>();\\n\\n        char startRow = s.charAt(0);\\n        char startCol = s.charAt(1);\\n        char endRow = s.charAt(3);\\n        char endCol = s.charAt(4);\\n\\n        while(startRow<=endRow)\\n        {\\n            while(startCol <= endCol)\\n            {\\n                ans.add(startRow+\"\"+startCol);\\n                startCol++;\\n            }\\n            startCol = s.charAt(1);\\n            startRow++;\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079983,
                "title": "simple-and-easy-java-solution-100-beats-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Please Upvote.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        // List to store the ans.\\n        List<String> list = new ArrayList<>();\\n        // StringBuilder to make the each String.\\n        StringBuilder sb = new StringBuilder();\\n        // Variables to store values \\n        char c = s.charAt(0);\\n        int n = s.charAt(3) - c;\\n        int c1 = s.charAt(1)-\\'0\\';\\n        int m = (s.charAt(4)-\\'0\\')-c1;\\n        // It will iterate through all the columns.\\n        for(int i =0;i<=n;i++){\\n            // It will iterate through all the rows.\\n            for(int j=0;j<=m;j++){\\n                //First add column to the string then add row.\\n                sb.append((char)(c+i));\\n                sb.append(c1+j);\\n                // add the answer to the list.\\n                list.add(sb.toString());\\n                // It will make the StringBuilder empty.\\n                sb.setLength(0);\\n            }\\n        }\\n        // Finaly Return the answer.\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        // List to store the ans.\\n        List<String> list = new ArrayList<>();\\n        // StringBuilder to make the each String.\\n        StringBuilder sb = new StringBuilder();\\n        // Variables to store values \\n        char c = s.charAt(0);\\n        int n = s.charAt(3) - c;\\n        int c1 = s.charAt(1)-\\'0\\';\\n        int m = (s.charAt(4)-\\'0\\')-c1;\\n        // It will iterate through all the columns.\\n        for(int i =0;i<=n;i++){\\n            // It will iterate through all the rows.\\n            for(int j=0;j<=m;j++){\\n                //First add column to the string then add row.\\n                sb.append((char)(c+i));\\n                sb.append(c1+j);\\n                // add the answer to the list.\\n                list.add(sb.toString());\\n                // It will make the StringBuilder empty.\\n                sb.setLength(0);\\n            }\\n        }\\n        // Finaly Return the answer.\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076733,
                "title": "this-method-uses-chr-and-ord",
                "content": "# Intuition\\nUse indexing to get what we need, throw them into variables then somehow turn that integers using ord() and make a loop.\\n\\n# Approach\\njust a normal pattern loop idk how to verbalize it.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nno idea lol but consumes 15.89 mb\\n\\n# Code\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        res = []\\n        rfinal = int(s[4])\\n        rstart = int(s[1])\\n        cfinal = ord(s[3])\\n        cstart = ord(s[0])\\n\\n        while cstart <= cfinal:\\n            x = chr(cstart)\\n            rstart = int(s[1])\\n\\n            while rstart <= rfinal:\\n                y = rstart\\n                res.append(x + str(y))\\n                rstart += 1\\n            cstart += 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        res = []\\n        rfinal = int(s[4])\\n        rstart = int(s[1])\\n        cfinal = ord(s[3])\\n        cstart = ord(s[0])\\n\\n        while cstart <= cfinal:\\n            x = chr(cstart)\\n            rstart = int(s[1])\\n\\n            while rstart <= rfinal:\\n                y = rstart\\n                res.append(x + str(y))\\n                rstart += 1\\n            cstart += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074601,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(row * col)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n      vector<string> cells;\\n      for(int i=int(s[0]);i<=int(s[3]);i++ ){\\n        for(int j=int(s[1]);j<=int(s[4]);j++){\\n          cells.push_back(string(1, char(i))+string(1,char(j)));\\n        }\\n      }\\n      return cells;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n      vector<string> cells;\\n      for(int i=int(s[0]);i<=int(s[3]);i++ ){\\n        for(int j=int(s[1]);j<=int(s[4]);j++){\\n          cells.push_back(string(1, char(i))+string(1,char(j)));\\n        }\\n      }\\n      return cells;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074026,
                "title": "java-solution-5ms-easy-implementation",
                "content": "# Approach\\n\\n1. **Initialization:**\\n\\n    - Create an ArrayList<String> named `ans` to store the generated cells.\\nHandle edge cases: If the input string `s` is null or empty, return an empty list.\\n\\n2. **Extract Column and Row Ranges:**\\n\\n    - Extract the column ranges `c1` and `c2` from the first and fourth characters of the input string s, respectively. These represent the starting and ending columns.\\n\\n    - Extract the row ranges `r1` and `r2` from the second and fifth characters of the input string s, respectively. These represent the starting and ending rows.\\n\\n3. **Generate Cells:**\\n\\n    - Use nested loops to iterate through the range of columns and rows.\\nIn the outer loop, iterate through columns from `c1` to `c2`.\\nIn the inner loop, iterate through rows from `r1` to `r2`.\\n\\n    - For each combination of column and row, generate a cell representation using `(char)(cell + \\'A\\' - 1)` to convert the column number back to the corresponding letter, and concatenate it with the row number.\\n\\n4. **Adding to List:**\\n\\n    - Add each generated cell to the list `ans`.\\n\\n5. **Return the List:**\\n\\n    - After generating all cells, return the list `ans`.\\n\\n\\n# Complexity\\n- Time complexity: O(col * row)\\n\\n- Space complexity: O(col + row)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> ans = new ArrayList<>();\\n        // Edge cases\\n        if (s == null || s.length() == 0) {\\n            return ans;\\n        }\\n        // Getting values \\n        final int c1 = s.charAt(0) - \\'A\\' + 1;\\n        final int c2 = s.charAt(3) - \\'A\\' + 1;\\n        final int r1 = Character.getNumericValue(s.charAt(1));\\n        final int r2 = Character.getNumericValue(s.charAt(4));\\n        // Fill the list\\n        for (int cell = c1; cell <= c2; cell++) {\\n            for (int row = r1; row <= r2; row++) {\\n                ans.add((char)(cell + \\'A\\' - 1) + \"\" + row);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> ans = new ArrayList<>();\\n        // Edge cases\\n        if (s == null || s.length() == 0) {\\n            return ans;\\n        }\\n        // Getting values \\n        final int c1 = s.charAt(0) - \\'A\\' + 1;\\n        final int c2 = s.charAt(3) - \\'A\\' + 1;\\n        final int r1 = Character.getNumericValue(s.charAt(1));\\n        final int r2 = Character.getNumericValue(s.charAt(4));\\n        // Fill the list\\n        for (int cell = c1; cell <= c2; cell++) {\\n            for (int row = r1; row <= r2; row++) {\\n                ans.add((char)(cell + \\'A\\' - 1) + \"\" + row);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073143,
                "title": "kotlin-solution-beats-50-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    //Using LinkedList\\nfun cellsInRange(s: String): List<String> {\\n    val linkedList = LinkedList<String>()\\n    for (row in s[0]..s[3]){\\n        for (col in s[1]..s[4]) linkedList.add(\"$row$col\")\\n    }\\n    return linkedList\\n}\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    //Using LinkedList\\nfun cellsInRange(s: String): List<String> {\\n    val linkedList = LinkedList<String>()\\n    for (row in s[0]..s[3]){\\n        for (col in s[1]..s[4]) linkedList.add(\"$row$col\")\\n    }\\n    return linkedList\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073105,
                "title": "recursion-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nfun cellsInRange(s: String): List<String> {\\n    val (firstChar, lastChar) = s.split(\\':\\')\\n\\n\\n    return recursiveCells(\\n        firstChar.first(),\\n        lastChar.first(), s[1].digitToInt(), s.last().digitToInt(), mutableListOf<String>()\\n    )\\n}\\n\\nfun recursiveCells(\\n    firstChar: Char,\\n    lastChar: Char,\\n    smallNumber: Int,\\n    largeNumber: Int,\\n    result: MutableList<String>\\n): MutableList<String> {\\n    if (firstChar > lastChar) return result\\n    for (number in smallNumber..largeNumber)\\n        result.add(\"${firstChar}${number}\")\\n\\n\\n    return recursiveCells(firstChar + 1, lastChar, smallNumber, largeNumber, result)\\n}\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\nfun cellsInRange(s: String): List<String> {\\n    val (firstChar, lastChar) = s.split(\\':\\')\\n\\n\\n    return recursiveCells(\\n        firstChar.first(),\\n        lastChar.first(), s[1].digitToInt(), s.last().digitToInt(), mutableListOf<String>()\\n    )\\n}\\n\\nfun recursiveCells(\\n    firstChar: Char,\\n    lastChar: Char,\\n    smallNumber: Int,\\n    largeNumber: Int,\\n    result: MutableList<String>\\n): MutableList<String> {\\n    if (firstChar > lastChar) return result\\n    for (number in smallNumber..largeNumber)\\n        result.add(\"${firstChar}${number}\")\\n\\n\\n    return recursiveCells(firstChar + 1, lastChar, smallNumber, largeNumber, result)\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072070,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        ans = []\\n        z = []\\n        z.append(s[0])\\n        z.append(s[3])\\n        input_str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        a1 = z[0]\\n        a2 = z[1]\\n\\n        start_index = input_str.index(a1)\\n        end_index = input_str.index(a2)\\n        result = input_str[start_index:end_index + 1]\\n\\n        x = s[len(s)-1 : len(s)]\\n        for i in result:\\n            for j in range(int(s[1]),int(x)+1):\\n                ans.append(i+str(j))\\n        return ans\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        ans = []\\n        z = []\\n        z.append(s[0])\\n        z.append(s[3])\\n        input_str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        a1 = z[0]\\n        a2 = z[1]\\n\\n        start_index = input_str.index(a1)\\n        end_index = input_str.index(a2)\\n        result = input_str[start_index:end_index + 1]\\n\\n        x = s[len(s)-1 : len(s)]\\n        for i in result:\\n            for j in range(int(s[1]),int(x)+1):\\n                ans.append(i+str(j))\\n        return ans\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071766,
                "title": "python-approach-beats-70-21ms-13-3-mb-ascii-approach",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def cellsInRange(self, s):\\n        outcome = []\\n        for col in range(ord(s[0]),ord(s[3]) + 1): # Ascii value (x, y + 1)\\n            for row in range (int(s[1]), int(s[4]) + 1):\\n                outcome.append(str(chr(col)) + str(row))\\n        return outcome\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def cellsInRange(self, s):\\n        outcome = []\\n        for col in range(ord(s[0]),ord(s[3]) + 1): # Ascii value (x, y + 1)\\n            for row in range (int(s[1]), int(s[4]) + 1):\\n                outcome.append(str(chr(col)) + str(row))\\n        return outcome\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069811,
                "title": "simplest-python-solution-ever",
                "content": "# Code\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        startChar = s[0]\\n        endChar = s[3]\\n        startNum = int(s[1])\\n        endNum = int(s[4])\\n        ans = []\\n        temp = \\'\\'\\n        for i in range(ord(startChar), ord(endChar)+1):\\n            for j in range(startNum,endNum+1):\\n                temp = chr(i)+str(j)\\n                ans.append(temp)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        startChar = s[0]\\n        endChar = s[3]\\n        startNum = int(s[1])\\n        endNum = int(s[4])\\n        ans = []\\n        temp = \\'\\'\\n        for i in range(ord(startChar), ord(endChar)+1):\\n            for j in range(startNum,endNum+1):\\n                temp = chr(i)+str(j)\\n                ans.append(temp)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065703,
                "title": "js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 61ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar cellsInRange = function(s) {\\n    \\n    const parts = s.split(\":\");\\n\\n    let startLetter = parts[0].charAt(0);\\n    let endLetter = parts[1].charAt(0);\\n    let startCell = parseInt(parts[0].charAt(1));\\n    let endCell = parseInt(parts[1].charAt(1));\\n    let result = [];\\n\\n    for (let i = startLetter.charCodeAt(0); i<= endLetter.charCodeAt(0); i++) {\\n        for (let j = startCell; j <= endCell; j++) {\\n            result.push(String.fromCharCode(i) + j);\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar cellsInRange = function(s) {\\n    \\n    const parts = s.split(\":\");\\n\\n    let startLetter = parts[0].charAt(0);\\n    let endLetter = parts[1].charAt(0);\\n    let startCell = parseInt(parts[0].charAt(1));\\n    let endCell = parseInt(parts[1].charAt(1));\\n    let result = [];\\n\\n    for (let i = startLetter.charCodeAt(0); i<= endLetter.charCodeAt(0); i++) {\\n        for (let j = startCell; j <= endCell; j++) {\\n            result.push(String.fromCharCode(i) + j);\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4053096,
                "title": "runtime-18-ms-90-memory-13-40-mb-90",
                "content": "\\n \\n# Code\\n```\\nclass Solution(object):\\n    def cellsInRange(self, s):\\n        output, l = [], string.ascii_uppercase  # l = letters \\n        for letter in l[l.index(s[0]):l.index(s[3]) + 1]: \\n            for number in range(int(s[1]), int(s[4]) + 1):\\n                output.append(letter + str(number))\\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def cellsInRange(self, s):\\n        output, l = [], string.ascii_uppercase  # l = letters \\n        for letter in l[l.index(s[0]):l.index(s[3]) + 1]: \\n            for number in range(int(s[1]), int(s[4]) + 1):\\n                output.append(letter + str(number))\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044621,
                "title": "elixir-solution",
                "content": "\\n```\\n\\ndefmodule Solution do\\n  @moduledoc \"\"\"\\n  Suggested strategy:\\n  Engineer a loop within a loop.\\n  The outer loop needs to iterate from the start letter to the\\n  end letter .\\n  Within the inner loop iterate from the start number to the end\\n  number.\\n  Once the loop is underway. Manipulate the data into the\\n  requred form. ie: [ \"K1\", \"K2\", \"L1\", \"L2\"]\\n  Some flattening may be required too.\\n\\n  \"\"\"\\n  @spec cells_in_range(s :: String.t()) :: [String.t()]\\n  def cells_in_range(s) do\\n    start_ascii_value =   String.at(s, 0) |> :binary.first\\n    end_ascii_value = String.at(s,3) |> :binary.first\\n\\n    start_number = String.at(s, 1) |> String.to_integer\\n    end_number = String.at(s, 4) |> String.to_integer\\n\\n    # loop from start_ascii_value to end_ascii_value\\n    result =\\n      for o_val <- start_ascii_value..end_ascii_value do\\n        o_letter = <<o_val::utf8>>\\n        for in_num <- start_number..end_number do\\n          exp = o_letter <> Integer.to_string(in_num)\\n        end\\n      end\\n\\n    result |> List.flatten\\n  end\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n\\ndefmodule Solution do\\n  @moduledoc \"\"\"\\n  Suggested strategy:\\n  Engineer a loop within a loop.\\n  The outer loop needs to iterate from the start letter to the\\n  end letter .\\n  Within the inner loop iterate from the start number to the end\\n  number.\\n  Once the loop is underway. Manipulate the data into the\\n  requred form. ie: [ \"K1\", \"K2\", \"L1\", \"L2\"]\\n  Some flattening may be required too.\\n\\n  \"\"\"\\n  @spec cells_in_range(s :: String.t()) :: [String.t()]\\n  def cells_in_range(s) do\\n    start_ascii_value =   String.at(s, 0) |> :binary.first\\n    end_ascii_value = String.at(s,3) |> :binary.first\\n\\n    start_number = String.at(s, 1) |> String.to_integer\\n    end_number = String.at(s, 4) |> String.to_integer\\n\\n    # loop from start_ascii_value to end_ascii_value\\n    result =\\n      for o_val <- start_ascii_value..end_ascii_value do\\n        o_letter = <<o_val::utf8>>\\n        for in_num <- start_number..end_number do\\n          exp = o_letter <> Integer.to_string(in_num)\\n        end\\n      end\\n\\n    result |> List.flatten\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4042906,
                "title": "solution-using-product-and-ord",
                "content": "\\n\\n# Code\\n```\\nfrom itertools import product\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        cols=[]\\n        nums=[]\\n        for i in range(ord(s[0]),ord(s[3])+1):\\n            cols.append(chr(i))\\n        for j in range(int(s[1]),int(s[4])+1):\\n            nums.append(j)\\n        return [a+str(b) for a,b in list(product(cols,nums))]\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import product\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        cols=[]\\n        nums=[]\\n        for i in range(ord(s[0]),ord(s[3])+1):\\n            cols.append(chr(i))\\n        for j in range(int(s[1]),int(s[4])+1):\\n            nums.append(j)\\n        return [a+str(b) for a,b in list(product(cols,nums))]\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039418,
                "title": "check-this-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> s1; \\n            \\n            int row1 =  s[1] - \\'0\\';\\n            int row2 = s[4]- \\'0\\';\\n            char strtCol = s[0]  ;\\n            char endCol = s[3] ;\\n            char k = \\'k\\';\\n            char l = \\'1\\';\\n            cout << k <<  l ;\\n            \\n            for(char j = strtCol ; j <= endCol ; j++){\\n                for( int i = row1 ; i <= row2 ; i++ ){\\n                    \\n                    string temp = \"\";\\n                    string ch = to_string(i);\\n                    temp += j;\\n                    temp += ch;\\n                    s1.push_back(temp);\\n                }\\n\\n            }\\n        return s1 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> s1; \\n            \\n            int row1 =  s[1] - \\'0\\';\\n            int row2 = s[4]- \\'0\\';\\n            char strtCol = s[0]  ;\\n            char endCol = s[3] ;\\n            char k = \\'k\\';\\n            char l = \\'1\\';\\n            cout << k <<  l ;\\n            \\n            for(char j = strtCol ; j <= endCol ; j++){\\n                for( int i = row1 ; i <= row2 ; i++ ){\\n                    \\n                    string temp = \"\";\\n                    string ch = to_string(i);\\n                    temp += j;\\n                    temp += ch;\\n                    s1.push_back(temp);\\n                }\\n\\n            }\\n        return s1 ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4037232,
                "title": "very-easy-to-understand-please-upvote-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        char c1= s[0];\\n        char c2= s[3];\\n        int r1= s[1]-\\'0\\';\\n        int r2= s[4]-\\'0\\';\\n\\n        vector<string>ans;\\n        for(char i=c1;i<=c2;i++)\\n        {\\n            for(int j=r1;j<=r2;j++)\\n            {\\n                string res=\"\";\\n                res=res+i;\\n                res=res+ to_string(j);\\n                ans.push_back(res);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        char c1= s[0];\\n        char c2= s[3];\\n        int r1= s[1]-\\'0\\';\\n        int r2= s[4]-\\'0\\';\\n\\n        vector<string>ans;\\n        for(char i=c1;i<=c2;i++)\\n        {\\n            for(int j=r1;j<=r2;j++)\\n            {\\n                string res=\"\";\\n                res=res+i;\\n                res=res+ to_string(j);\\n                ans.push_back(res);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036357,
                "title": "easy-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) \\n    {\\n        int start=stoi(s.substr(1,2));\\n        int end=stoi(s.substr(4,5));\\n        char st=s[0];\\n        char en=s[3];\\n        vector<string> ans;\\n        for(char f=st;f<=en;f++)\\n        {\\n            for(int i=start;i<=end;i++)\\n            {\\n                string y=f+to_string(i);\\n                ans.push_back(y);\\n            }\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) \\n    {\\n        int start=stoi(s.substr(1,2));\\n        int end=stoi(s.substr(4,5));\\n        char st=s[0];\\n        char en=s[3];\\n        vector<string> ans;\\n        for(char f=st;f<=en;f++)\\n        {\\n            for(int i=start;i<=end;i++)\\n            {\\n                string y=f+to_string(i);\\n                ans.push_back(y);\\n            }\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031451,
                "title": "simple-python-solution",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInitially I\\'d thought to convert the cell column titles from letters to their `int` counterparts, but after remembering that would merely be\\n```py\\n# Assuming `c` as the column title being converted.\\nord(\\'A\\') - ord(c) + 1\\n```\\nI then opted to instead used a ranged for loop over the ASCII values of each letter. This solution works since we are guaranteed that the column titles $$C$$ will follow the bounds $$\\\\forall c; c\\\\in C.\\\\ \\\\text{\\'A\\'}\\\\leq c\\\\leq\\\\text{\\'Z\\'}$$. Had this restriction not been applied, then conversion would have been neccessary.\\n\\nThis then meant that solving this problem would be as simple as using two ranged loops nested within each other.\\n\\n# Complexity\\n- Time complexity: Technically $$O(n^2)$$ or $$O(c\\\\cdot r)$$ where $$c$$ is the range of columns and $$r$$ is the range of rows. Could also be seen as $$O(n)$$ where $$n$$ is the number of rows since the columns are limited to 26--a constant value which may then be omitted.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        cells = []\\n        c1, r1, _, c2, r2 = list(s)\\n        for c in range(ord(c1), ord(c2) + 1):\\n            for r in range(int(r1), int(r2) + 1):\\n                cells.append(f\"{chr(c)}{str(r)}\")\\n        return cells\\n\\n```\\n\\n**Note: Looking back, I could have omitted** `str(r)` **for just** `r`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\n# Assuming `c` as the column title being converted.\\nord(\\'A\\') - ord(c) + 1\\n```\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        cells = []\\n        c1, r1, _, c2, r2 = list(s)\\n        for c in range(ord(c1), ord(c2) + 1):\\n            for r in range(int(r1), int(r2) + 1):\\n                cells.append(f\"{chr(c)}{str(r)}\")\\n        return cells\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030625,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public IList<string> CellsInRange(string s)\\n    {\\n      IList<string> myList = new List<string> { };\\n      for (char c = s[0]; c <= s[3]; ++c)\\n        for (char r = s[1]; r <= s[4]; ++r)\\n          myList.Add($\"{c}{r}\");\\n\\n      foreach (var i in myList) Console.WriteLine(i);\\n      return myList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<string> CellsInRange(string s)\\n    {\\n      IList<string> myList = new List<string> { };\\n      for (char c = s[0]; c <= s[3]; ++c)\\n        for (char r = s[1]; r <= s[4]; ++r)\\n          myList.Add($\"{c}{r}\");\\n\\n      foreach (var i in myList) Console.WriteLine(i);\\n      return myList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028714,
                "title": "o-n-o-n",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    // TC: O(n)\\n    // SC: O(n)\\n    public List<String> cellsInRange(String s) {\\n        List<String> li = new ArrayList<>();\\n        char leftCol = s.charAt(0);\\n        char rightCol = s.charAt(3);\\n        char leftRow = s.charAt(1);\\n        char rightRow = s.charAt(4);\\n        \\n        for(char c=leftCol;c<=rightCol;c++){\\n            for(char r=leftRow;r<=rightRow;r++){\\n                li.add(c+\"\"+r);\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // TC: O(n)\\n    // SC: O(n)\\n    public List<String> cellsInRange(String s) {\\n        List<String> li = new ArrayList<>();\\n        char leftCol = s.charAt(0);\\n        char rightCol = s.charAt(3);\\n        char leftRow = s.charAt(1);\\n        char rightRow = s.charAt(4);\\n        \\n        for(char c=leftCol;c<=rightCol;c++){\\n            for(char r=leftRow;r<=rightRow;r++){\\n                li.add(c+\"\"+r);\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023330,
                "title": "just-1-line-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(c)+str(r) for c in range(ord(s[0]),ord(s[3])+1) for r in range(int(s[1]), int(s[4])+1)]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(c)+str(r) for c in range(ord(s[0]),ord(s[3])+1) for r in range(int(s[1]), int(s[4])+1)]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019477,
                "title": "max-min-row-easy-approach-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n\\n        int rmax=Math.max(s.charAt(1)-\\'0\\',s.charAt(4)-\\'0\\');\\n        int rmin=Math.min(s.charAt(1)-\\'0\\',s.charAt(4)-\\'0\\');\\n\\n        List<String> list=new ArrayList<>();\\n\\n        for(char col=s.charAt(0);col<=s.charAt(3);col++){\\n            for(int row=rmin;row<=rmax;row++){\\n                list.add(col+\"\"+row);\\n            }\\n        }\\n\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n\\n        int rmax=Math.max(s.charAt(1)-\\'0\\',s.charAt(4)-\\'0\\');\\n        int rmin=Math.min(s.charAt(1)-\\'0\\',s.charAt(4)-\\'0\\');\\n\\n        List<String> list=new ArrayList<>();\\n\\n        for(char col=s.charAt(0);col<=s.charAt(3);col++){\\n            for(int row=rmin;row<=rmax;row++){\\n                list.add(col+\"\"+row);\\n            }\\n        }\\n\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017355,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        ArrayList<String> arr=new ArrayList<String>();\\n        char c1=s.charAt(0);\\n        char c2=s.charAt(3);\\n        int n1=s.charAt(1)-\\'0\\';\\n        int n2=s.charAt(4)-\\'0\\';\\n        for(char i=c1;i<=c2;i++){\\n            for(int j=n1;j<=n2;j++){\\n            arr.add(i+\"\"+(char)(j+\\'0\\'));\\n        }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        ArrayList<String> arr=new ArrayList<String>();\\n        char c1=s.charAt(0);\\n        char c2=s.charAt(3);\\n        int n1=s.charAt(1)-\\'0\\';\\n        int n2=s.charAt(4)-\\'0\\';\\n        for(char i=c1;i<=c2;i++){\\n            for(int j=n1;j<=n2;j++){\\n            arr.add(i+\"\"+(char)(j+\\'0\\'));\\n        }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017140,
                "title": "faster-99-02-by-using-javascript-accessible",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar cellsInRange = function(s) {\\n    var res = new Array();\\n    for(let i = s[0].charCodeAt(0); i <= s[3].charCodeAt(0); i++){\\n        for(let j = s[1].charCodeAt(0); j <= s[4].charCodeAt(0); j++){\\n            res.push(String.fromCharCode(i) + String.fromCharCode(j));\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar cellsInRange = function(s) {\\n    var res = new Array();\\n    for(let i = s[0].charCodeAt(0); i <= s[3].charCodeAt(0); i++){\\n        for(let j = s[1].charCodeAt(0); j <= s[4].charCodeAt(0); j++){\\n            res.push(String.fromCharCode(i) + String.fromCharCode(j));\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4015474,
                "title": "harshi-s-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        int l=s[1],h=s[4];\\n        int a=s[0],b=s[3];\\n        vector<string> v;\\n        for(int i=a;i<=b;i++){\\n            for(int j=l;j<=h;j++){\\n                string k=\"\";\\n                k=k+char(i);\\n                k+=j;\\n                v.push_back(k);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        int l=s[1],h=s[4];\\n        int a=s[0],b=s[3];\\n        vector<string> v;\\n        for(int i=a;i<=b;i++){\\n            for(int j=l;j<=h;j++){\\n                string k=\"\";\\n                k=k+char(i);\\n                k+=j;\\n                v.push_back(k);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014766,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        chars = [s[0],s[-2]]\\n        nums = [s[1], s[-1]]\\n\\n        res = []\\n\\n        currchar = chars[0]\\n        endchar = chars[1] \\n        \\n        while ord(currchar) != ord(endchar) + 1:\\n            for i in range(int(nums[0]), int(nums[1])+ 1):\\n                res.append(currchar + str(i))\\n            i = ord(currchar)\\n            i = i + 1\\n            currchar = chr(i)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        chars = [s[0],s[-2]]\\n        nums = [s[1], s[-1]]\\n\\n        res = []\\n\\n        currchar = chars[0]\\n        endchar = chars[1] \\n        \\n        while ord(currchar) != ord(endchar) + 1:\\n            for i in range(int(nums[0]), int(nums[1])+ 1):\\n                res.append(currchar + str(i))\\n            i = ord(currchar)\\n            i = i + 1\\n            currchar = chr(i)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007521,
                "title": "straight-forward-o-n-m-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        rows = ord(s[3]) - ord(s[0]) + 1 \\n        cols = int(s[4]) - int(s[1]) + 1\\n        \\n        res = []\\n        for i in range(rows):\\n            for j in range(cols):\\n                char = chr(ord(s[0]) + i)\\n                num = str(int(s[1]) + j)\\n                res.append(char + num)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        rows = ord(s[3]) - ord(s[0]) + 1 \\n        cols = int(s[4]) - int(s[1]) + 1\\n        \\n        res = []\\n        for i in range(rows):\\n            for j in range(cols):\\n                char = chr(ord(s[0]) + i)\\n                num = str(int(s[1]) + j)\\n                res.append(char + num)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1679654,
                "content": [
                    {
                        "username": "Bobzero",
                        "content": "honestly, it felt like you know how to solve but you don\\'t know how to write the code.. sometimes it is what it is. let\\'s keep learning"
                    },
                    {
                        "username": "JoeRogan",
                        "content": "The steps i took to solve this problem:\\n\\n-Create a list of letters starting at s[0] and ending at s[-2]\\n\\n-Loop through list\\n-Inner loop for numerical value, starting at s[1] and ending at s[-1]+1\\n-Append both letter and number to answer list \\n-return list \\n\\n:)"
                    },
                    {
                        "username": "jordwang",
                        "content": "Don\\'t you know how to read? it says no ANSWER in this discussion and yet you wrote it, does it make you feel better?... pathetic"
                    }
                ]
            },
            {
                "id": 1713985,
                "content": [
                    {
                        "username": "Bobzero",
                        "content": "honestly, it felt like you know how to solve but you don\\'t know how to write the code.. sometimes it is what it is. let\\'s keep learning"
                    },
                    {
                        "username": "JoeRogan",
                        "content": "The steps i took to solve this problem:\\n\\n-Create a list of letters starting at s[0] and ending at s[-2]\\n\\n-Loop through list\\n-Inner loop for numerical value, starting at s[1] and ending at s[-1]+1\\n-Append both letter and number to answer list \\n-return list \\n\\n:)"
                    },
                    {
                        "username": "jordwang",
                        "content": "Don\\'t you know how to read? it says no ANSWER in this discussion and yet you wrote it, does it make you feel better?... pathetic"
                    }
                ]
            }
        ]
    },
    {
        "title": "Distance to a Cycle in Undirected Graph",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1687653,
                "content": [
                    {
                        "username": "opringle",
                        "content": "I believe variable edges in example 1 is incorrect. Shouldn\\'t it be [[0, 1],[1, 2],[2,4],[1,3],[3,4],[2,5],[6,5]] ? "
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Health to Beat Game",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1644233,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1748885,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1750155,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1748119,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1749178,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1748348,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1748110,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1706120,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 2034790,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1757968,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1644233,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1748885,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1750155,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1748119,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1749178,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1748348,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1748110,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1706120,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 2034790,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1757968,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Number of Operations to Convert Time",
        "question_content": "<p>You are given two strings <code>current</code> and <code>correct</code> representing two <strong>24-hour times</strong>.</p>\n\n<p>24-hour times are formatted as <code>&quot;HH:MM&quot;</code>, where <code>HH</code> is between <code>00</code> and <code>23</code>, and <code>MM</code> is between <code>00</code> and <code>59</code>. The earliest 24-hour time is <code>00:00</code>, and the latest is <code>23:59</code>.</p>\n\n<p>In one operation you can increase the time <code>current</code> by <code>1</code>, <code>5</code>, <code>15</code>, or <code>60</code> minutes. You can perform this operation <strong>any</strong> number of times.</p>\n\n<p>Return <em>the <strong>minimum number of operations</strong> needed to convert </em><code>current</code><em> to </em><code>correct</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> current = &quot;02:30&quot;, correct = &quot;04:35&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:\n</strong>We can convert current to correct in 3 operations as follows:\n- Add 60 minutes to current. current becomes &quot;03:30&quot;.\n- Add 60 minutes to current. current becomes &quot;04:30&quot;.\n- Add 5 minutes to current. current becomes &quot;04:35&quot;.\nIt can be proven that it is not possible to convert current to correct in fewer than 3 operations.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> current = &quot;11:00&quot;, correct = &quot;11:01&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> We only have to add one minute to current, so the minimum number of operations needed is 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>current</code> and <code>correct</code> are in the format <code>&quot;HH:MM&quot;</code></li>\n\t<li><code>current &lt;= correct</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1908782,
                "title": "c-greedy",
                "content": "\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Greedy\\n\\n* Compute the time difference in seconds\\n* Greedily using `60, 15, 5, 1` operations. For each operation `op`, we use `diff / op` number of operations to turn `diff` to `diff % op`.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-287/problems/minimum-number-of-operations-to-convert-time/\\n// Author: github.com/lzl124631x\\n// Time: O(1)\\n// Space: O(1)\\nclass Solution {\\n    int getTime(string &s) {\\n        return stoi(s.substr(0, 2)) * 60 + stoi(s.substr(3));\\n    }\\npublic:\\n    int convertTime(string current, string correct) {\\n        int diff = getTime(correct) - getTime(current), ops[4] = {60,15,5,1}, ans = 0;\\n        for (int op : ops) {\\n            ans += diff / op;\\n            diff %= op;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-287/problems/minimum-number-of-operations-to-convert-time/\\n// Author: github.com/lzl124631x\\n// Time: O(1)\\n// Space: O(1)\\nclass Solution {\\n    int getTime(string &s) {\\n        return stoi(s.substr(0, 2)) * 60 + stoi(s.substr(3));\\n    }\\npublic:\\n    int convertTime(string current, string correct) {\\n        int diff = getTime(correct) - getTime(current), ops[4] = {60,15,5,1}, ans = 0;\\n        for (int op : ops) {\\n            ans += diff / op;\\n            diff %= op;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908779,
                "title": "convert-to-minutes",
                "content": "Since we can only add minutes, the greedy approach would work.\\n\\n**C++**\\n```cpp    \\nint convertTime(string current, string correct) {\\n    auto toMin = [](string &s) { \\n \\xA0 \\xA0 \\xA0 \\xA0return s[0] * 600 + s[1] * 60 + s[3] * 10 + s[4] ;\\n    };\\n    int d = toMin(correct) - toMin(current);\\n    return d / 60 + d % 60 / 15 + d % 15 / 5 + d % 5;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp    \\nint convertTime(string current, string correct) {\\n    auto toMin = [](string &s) { \\n \\xA0 \\xA0 \\xA0 \\xA0return s[0] * 600 + s[1] * 60 + s[3] * 10 + s[4] ;\\n    };\\n    int d = toMin(correct) - toMin(current);\\n    return d / 60 + d % 60 / 15 + d % 15 / 5 + d % 5;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1908786,
                "title": "easy-python-solution-convert-time-to-minutes",
                "content": "1. Convert times into minutes and then the problem becomes simpler. \\n2. To minimize the number of total operations we try to use the largest possible change from `[60,15,5,1]` till possible.\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        current_time = 60 * int(current[0:2]) + int(current[3:5]) # Current time in minutes\\n        target_time = 60 * int(correct[0:2]) + int(correct[3:5]) # Target time in minutes\\n        diff = target_time - current_time # Difference b/w current and target times in minutes\\n        count = 0 # Required number of operations\\n\\t\\t# Use GREEDY APPROACH to calculate number of operations\\n        for i in [60, 15, 5, 1]:\\n            count += diff // i # add number of operations needed with i to count\\n            diff %= i # Diff becomes modulo of diff with i\\n        return count\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        current_time = 60 * int(current[0:2]) + int(current[3:5]) # Current time in minutes\\n        target_time = 60 * int(correct[0:2]) + int(correct[3:5]) # Target time in minutes\\n        diff = target_time - current_time # Difference b/w current and target times in minutes\\n        count = 0 # Required number of operations\\n\\t\\t# Use GREEDY APPROACH to calculate number of operations\\n        for i in [60, 15, 5, 1]:\\n            count += diff // i # add number of operations needed with i to count\\n            diff %= i # Diff becomes modulo of diff with i\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908985,
                "title": "java-loop-easy-to-understand",
                "content": "**Here I am discussing my approach to this problem**\\n**Approach:**\\n1. Convert both **current time** and **correct time** into **minutes**.\\n2. **Increase** **current time** by 60min until it becomes **just less or equal to correct time**.\\n3. Similarly do the **same thing** with 15min, 5min, and 1min window.\\n4. Count the **number of iterations** performed.\\n5. Return the number of iterations.\\n\\n**Source Code:**\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        String[] curr = current.split(\":\");\\n        String[] corr = correct.split(\":\");\\n        int cur = Integer.parseInt(curr[0]) * 60 + Integer.parseInt(curr[1]);\\n        int cor = Integer.parseInt(corr[0]) * 60 + Integer.parseInt(corr[1]);\\n        int count = 0;\\n        \\n        while(cur + 60 <= cor) {\\n            ++count;\\n            cur += 60;\\n        }\\n        \\n         while(cur + 15 <= cor) {\\n            ++count;\\n            cur += 15;\\n        }\\n        \\n         while(cur + 5 <= cor) {\\n            ++count;\\n            cur += 5;\\n        }\\n        \\n         while(cur + 1 <= cor) {\\n            ++count;\\n            cur += 1;\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```\\n\\n**Complexity Analysis:**\\n```\\nTime Complexity: O(c) // c some constant value <= 100\\nSpace Complexity : O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        String[] curr = current.split(\":\");\\n        String[] corr = correct.split(\":\");\\n        int cur = Integer.parseInt(curr[0]) * 60 + Integer.parseInt(curr[1]);\\n        int cor = Integer.parseInt(corr[0]) * 60 + Integer.parseInt(corr[1]);\\n        int count = 0;\\n        \\n        while(cur + 60 <= cor) {\\n            ++count;\\n            cur += 60;\\n        }\\n        \\n         while(cur + 15 <= cor) {\\n            ++count;\\n            cur += 15;\\n        }\\n        \\n         while(cur + 5 <= cor) {\\n            ++count;\\n            cur += 5;\\n        }\\n        \\n         while(cur + 1 <= cor) {\\n            ++count;\\n            cur += 1;\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```\n```\\nTime Complexity: O(c) // c some constant value <= 100\\nSpace Complexity : O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909089,
                "title": "short-java-5-lines",
                "content": "```java\\n public int convertTime(String current, String correct){\\n        Function<String, Integer> parse = t -> Integer.parseInt(t.substring(0, 2)) * 60 + Integer.parseInt(t.substring(3));\\n        int diff = parse.apply(correct) - parse.apply(current), ops[] = {60, 15, 5, 1}, r = 0;\\n        for(int i = 0; i < ops.length && diff > 0; diff = diff % ops[i++])\\n            r += diff / ops[i];\\n        return r;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n public int convertTime(String current, String correct){\\n        Function<String, Integer> parse = t -> Integer.parseInt(t.substring(0, 2)) * 60 + Integer.parseInt(t.substring(3));\\n        int diff = parse.apply(correct) - parse.apply(current), ops[] = {60, 15, 5, 1}, r = 0;\\n        for(int i = 0; i < ops.length && diff > 0; diff = diff % ops[i++])\\n            r += diff / ops[i];\\n        return r;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1909350,
                "title": "c-solution-0ms-100-faster",
                "content": "\"\"\"\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int hour1=(current[0]-\\'0\\')*10+(current[1]-\\'0\\');\\n        int hour2=(correct[0]-\\'0\\')*10+(correct[1]-\\'0\\');\\n        int minute1=(current[3]-\\'0\\')*10+(current[4]-\\'0\\');\\n        int minute2=(correct[3]-\\'0\\')*10+(correct[4]-\\'0\\');\\n        \\n        int total=(hour2-hour1)*60+ (minute2-minute1);\\n        int res=0;\\n        if(total>=60){\\n            int temp=(total/60);\\n            total-=(temp*60);\\n            res+=temp;\\n        }\\n        if(total>=15){\\n            int temp=(total/15);\\n            total-=(temp*15);\\n            res+=temp;\\n        }\\n        if(total>=5){\\n            int temp=(total/5);\\n            total-=(temp*5);\\n            res+=temp;\\n        }\\n        res+=total;\\n        return res;\\n    }\\n};\\n\"\"\"\\n\\tPlease Upvote if you Find it Helpful \\uD83D\\uDE42.",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int hour1=(current[0]-\\'0\\')*10+(current[1]-\\'0\\');\\n        int hour2=(correct[0]-\\'0\\')*10+(correct[1]-\\'0\\');\\n        int minute1=(current[3]-\\'0\\')*10+(current[4]-\\'0\\');\\n        int minute2=(correct[3]-\\'0\\')*10+(correct[4]-\\'0\\');\\n        \\n        int total=(hour2-hour1)*60+ (minute2-minute1);\\n        int res=0;\\n        if(total>=60){\\n            int temp=(total/60);\\n            total-=(temp*60);\\n            res+=temp;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1909169,
                "title": "c-greedy-convert-to-minutes",
                "content": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string co) {\\n        \\n        string h1=\"\";\\n        string m1=\"\";\\n        string h2=\"\";\\n        string m2=\"\";\\n        \\n        h1+=current[0];\\n        h1+=current[1];\\n        \\n        m1+=current[3];\\n        m1+=current[4];\\n        \\n        h2+=co[0];\\n        h2+=co[1];\\n        \\n        m2+=co[3];\\n        m2+=co[4];\\n        \\n        \\n        int min1=stoi(h1)*60+stoi(m1);\\n        int min2=stoi(h2)*60+stoi(m2);\\n        \\n       // int x=min2-min1;\\n        int count=0;\\n        \\n        while(min2>min1){\\n            \\n            if((min2-min1)>=60){\\n                min1=min1+60;\\n                count++;\\n            }\\n            else if((min2-min1)>=15){\\n                min1=min1+15;\\n                count++;\\n            }\\n            else if((min2-min1)>=5){\\n                min1=min1+5;\\n                count++;\\n            }\\n            else {\\n                count+=(min2-min1);\\n                min1=min1+(min2-min1);\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string co) {\\n        \\n        string h1=\"\";\\n        string m1=\"\";\\n        string h2=\"\";\\n        string m2=\"\";\\n        \\n        h1+=current[0];\\n        h1+=current[1];\\n        \\n        m1+=current[3];\\n        m1+=current[4];\\n        \\n        h2+=co[0];\\n        h2+=co[1];\\n        \\n        m2+=co[3];\\n        m2+=co[4];\\n        \\n        \\n        int min1=stoi(h1)*60+stoi(m1);\\n        int min2=stoi(h2)*60+stoi(m2);\\n        \\n       // int x=min2-min1;\\n        int count=0;\\n        \\n        while(min2>min1){\\n            \\n            if((min2-min1)>=60){\\n                min1=min1+60;\\n                count++;\\n            }\\n            else if((min2-min1)>=15){\\n                min1=min1+15;\\n                count++;\\n            }\\n            else if((min2-min1)>=5){\\n                min1=min1+5;\\n                count++;\\n            }\\n            else {\\n                count+=(min2-min1);\\n                min1=min1+(min2-min1);\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908920,
                "title": "cpp-easy-greedy-explained-faster-than-100",
                "content": "```\\n1. extract the hours and minutes from both the strings\\n2. convert the strings to numbers\\n3. convert both time time to minutes.\\n4. calculate the minutes difference.\\n5. simply check minimum operations to make minutes equal to difference.\\nclass Solution {\\npublic:\\n    int convertTime(string a, string b) {\\n        int x=a[0]-\\'0\\',y=a[1]-\\'0\\',z=a[3]-\\'0\\',w=a[4]-\\'0\\';\\n        int p=b[0]-\\'0\\',q=b[1]-\\'0\\',r=b[3]-\\'0\\',s=b[4]-\\'0\\';\\n        int hr1 = (x)*10+(y);\\n        int m1 = (z)*10+(w);\\n        int hr2 = (p)*10+(q);\\n        int m2 = (r)*10+s;\\n        int num1 = hr1*60+m1;\\n        int num2 = hr2*60+m2;\\n        int diff = num2-num1;\\n        int res=0;\\n        int arr[4]={60,15,5,1};\\n        for(int i=0;i<4;i++){\\n            res+=diff/arr[i];\\n            diff = diff%arr[i];\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int convertTime(string a, string b) {\\n        int x=a[0]-\\'0\\',y=a[1]-\\'0\\',z=a[3]-\\'0\\',w=a[4]-\\'0\\';\\n        int p=b[0]-\\'0\\',q=b[1]-\\'0\\',r=b[3]-\\'0\\',s=b[4]-\\'0\\';\\n        int hr1 = (x)*10+(y);\\n        int m1 = (z)*10+(w);\\n        int hr2 = (p)*10+(q);\\n        int m2 = (r)*10+s;\\n        int num1 = hr1*60+m1;\\n        int num2 = hr2*60+m2;\\n        int diff = num2-num1;\\n        int res=0;\\n        int arr[4]={60,15,5,1}",
                "codeTag": "Java"
            },
            {
                "id": 3657266,
                "title": "python-3-convert-to-minutes-and-find-parts-using-divmod-beats-85",
                "content": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        def toMinutes(s):\\n            h, m = s.split(\\':\\')\\n            return 60 * int(h) + int(m)\\n        \\n        minutes = toMinutes(correct) - toMinutes(current)\\n        hours, minutes = divmod(minutes, 60)\\n        quaters, minutes = divmod(minutes, 15)\\n        fives, minutes = divmod(minutes, 5)\\n\\n        return hours + quaters + fives + minutes\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        def toMinutes(s):\\n            h, m = s.split(\\':\\')\\n            return 60 * int(h) + int(m)\\n        \\n        minutes = toMinutes(correct) - toMinutes(current)\\n        hours, minutes = divmod(minutes, 60)\\n        quaters, minutes = divmod(minutes, 15)\\n        fives, minutes = divmod(minutes, 5)\\n\\n        return hours + quaters + fives + minutes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1924690,
                "title": "javascript-solution",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nconst convertTime = (current, correct) => {\\n    if (current === correct) return 0\\n\\t\\n    let count = 0\\n    let currentInMins = parseInt(current.slice(3)) + parseInt(current.slice(0, 2)) * 60\\n    let correcttInMins = parseInt(correct.slice(3)) + parseInt(correct.slice(0, 2)) * 60\\n    let minuteDifference = correcttInMins - currentInMins\\n\\n    while (minuteDifference !== 0) {\\n        if (minuteDifference % 60 === 0) {\\n            minuteDifference -= 60\\n            count++\\n        }\\n        else if (minuteDifference % 15 === 0) {\\n            minuteDifference -= 15\\n            count++\\n        }\\n        else if (minuteDifference % 5 === 0) {\\n            minuteDifference -= 5\\n            count++\\n        }\\n        else{\\n            minuteDifference -= 1\\n            count++\\n        }\\n    }\\n\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst convertTime = (current, correct) => {\\n    if (current === correct) return 0\\n\\t\\n    let count = 0\\n    let currentInMins = parseInt(current.slice(3)) + parseInt(current.slice(0, 2)) * 60\\n    let correcttInMins = parseInt(correct.slice(3)) + parseInt(correct.slice(0, 2)) * 60\\n    let minuteDifference = correcttInMins - currentInMins\\n\\n    while (minuteDifference !== 0) {\\n        if (minuteDifference % 60 === 0) {\\n            minuteDifference -= 60\\n            count++\\n        }\\n        else if (minuteDifference % 15 === 0) {\\n            minuteDifference -= 15\\n            count++\\n        }\\n        else if (minuteDifference % 5 === 0) {\\n            minuteDifference -= 5\\n            count++\\n        }\\n        else{\\n            minuteDifference -= 1\\n            count++\\n        }\\n    }\\n\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1908764,
                "title": "intutive-easytounderstand-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int curr_hour = stoi(current.substr(0,2));\\n        int curr_min  = stoi(current.substr(3,2));\\n        int co_hour = stoi(correct.substr(0,2));\\n        int co_min  = stoi(correct.substr(3,2));\\n        \\n       \\n        int h_diff = co_hour - curr_hour;\\n        int min_diff = co_min - curr_min;\\n        \\n        int total = h_diff*60 + min_diff;   //Calculate The Total Minutes\\n        vector<int>time{1,5,15,60};\\n        \\n        int op = 0;                                    // Perform the Greedy Operation\\n        for(int i = time.size() -1;i>=0;i--){\\n            if(total >= time[i] && total >0){\\n                op+=total/time[i]; \\n                total = total%time[i];\\n            }\\n        }\\n       \\n        \\n        \\n        return op;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int curr_hour = stoi(current.substr(0,2));\\n        int curr_min  = stoi(current.substr(3,2));\\n        int co_hour = stoi(correct.substr(0,2));\\n        int co_min  = stoi(correct.substr(3,2));\\n        \\n       \\n        int h_diff = co_hour - curr_hour;\\n        int min_diff = co_min - curr_min;\\n        \\n        int total = h_diff*60 + min_diff;   //Calculate The Total Minutes\\n        vector<int>time{1,5,15,60}",
                "codeTag": "Java"
            },
            {
                "id": 1918848,
                "title": "python-easy",
                "content": "first compute the hour and minute difference\\n\\nif minute difference is negative then we must change the diffs\\n\\nthen greedily subtract the remainder to 15, 5, 1 from minutes.\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        h1, m1 = current.split(\\':\\')\\n        h2, m2 = correct.split(\\':\\')\\n        h = int(h2) - int(h1)\\n        m = int(m2) - int(m1)\\n        if m < 0:\\n            h -= 1\\n            m += 60\\n        \\n        a = m // 15\\n        m %= 15\\n        b = m // 5\\n        m %= 5\\n        return h + a + b + m\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        h1, m1 = current.split(\\':\\')\\n        h2, m2 = correct.split(\\':\\')\\n        h = int(h2) - int(h1)\\n        m = int(m2) - int(m1)\\n        if m < 0:\\n            h -= 1\\n            m += 60\\n        \\n        a = m // 15\\n        m %= 15\\n        b = m // 5\\n        m %= 5\\n        return h + a + b + m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910157,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn convert_time(current: String, correct: String) -> i32 {\\n        if current == correct {\\n            return 0;\\n        }\\n\\n        let to_num = |s: &str| -> i32 { s.parse().unwrap() };\\n        let (h2, m2) = (to_num(&correct[..2]), to_num(&correct[3..]));\\n        let (h1, m1) = (to_num(&current[..2]), to_num(&current[3..]));\\n\\n        let mut delta = (m2 - m1) + 60 * if h2 >= h1 { h2 - h1 } else { h2 - h1 + 24 };\\n        let mut res = 0;\\n\\n        for op in [60, 15, 5] {\\n            res += delta / op;\\n            delta %= op;\\n        }\\n\\n        res + delta\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn convert_time(current: String, correct: String) -> i32 {\\n        if current == correct {\\n            return 0;\\n        }\\n\\n        let to_num = |s: &str| -> i32 { s.parse().unwrap() };\\n        let (h2, m2) = (to_num(&correct[..2]), to_num(&correct[3..]));\\n        let (h1, m1) = (to_num(&current[..2]), to_num(&current[3..]));\\n\\n        let mut delta = (m2 - m1) + 60 * if h2 >= h1 { h2 - h1 } else { h2 - h1 + 24 };\\n        let mut res = 0;\\n\\n        for op in [60, 15, 5] {\\n            res += delta / op;\\n            delta %= op;\\n        }\\n\\n        res + delta\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909148,
                "title": "javascript-clean-o-n-solution",
                "content": "```\\nvar convertTime = function(current, correct) {\\n    // 1. Seperate current and correct into Hours and Minutes\\n    const currentHoursMins = current.split(\":\");\\n    const correctHoursMins = correct.split(\":\");\\n \\n    // 2. Calculate difference in minutes\\n    let minDifference = ((correctHoursMins[1] - currentHoursMins[1])) + ((correctHoursMins[0] - currentHoursMins[0]) * 60);\\n\\n    // 3. Greedily take the highest minutes to lowest minutes\\n    let operations = 0;\\n    const operationValues = [60, 15, 5, 1] // this format is maintainable and extensible since other values can easily be added\\n    for(const difference of operationValues){\\n        while(minDifference >= difference){\\n            minDifference -= difference;\\n            operations++;\\n        }\\n    }\\n    \\n    return operations;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nvar convertTime = function(current, correct) {\\n    // 1. Seperate current and correct into Hours and Minutes\\n    const currentHoursMins = current.split(\":\");\\n    const correctHoursMins = correct.split(\":\");\\n \\n    // 2. Calculate difference in minutes\\n    let minDifference = ((correctHoursMins[1] - currentHoursMins[1])) + ((correctHoursMins[0] - currentHoursMins[0]) * 60);\\n\\n    // 3. Greedily take the highest minutes to lowest minutes\\n    let operations = 0;\\n    const operationValues = [60, 15, 5, 1] // this format is maintainable and extensible since other values can easily be added\\n    for(const difference of operationValues){\\n        while(minDifference >= difference){\\n            minDifference -= difference;\\n            operations++;\\n        }\\n    }\\n    \\n    return operations;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1908979,
                "title": "python-convert-to-minutes",
                "content": "```\\ndef convertTime(self, current: str, correct: str) -> int:\\n\\tans = 0\\n\\th, m = list(map(int, current.split(\\':\\')))\\n\\tnewH, newM = list(map(int, correct.split(\\':\\')))\\n\\td = 60*(newH - h) + newM - m\\n\\tfor x in [60, 15, 5, 1]:\\n\\t\\tans += d//x\\n\\t\\td %= x\\n\\treturn ans \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef convertTime(self, current: str, correct: str) -> int:\\n\\tans = 0\\n\\th, m = list(map(int, current.split(\\':\\')))\\n\\tnewH, newM = list(map(int, correct.split(\\':\\')))\\n\\td = 60*(newH - h) + newM - m\\n\\tfor x in [60, 15, 5, 1]:\\n\\t\\tans += d//x\\n\\t\\td %= x\\n\\treturn ans \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1908895,
                "title": "javascript-greedy-84ms",
                "content": "Main idea: calculate minute difference, and divide 60, 15, 5, 1 respectively\\n```\\nconst convertTime = (s, t) => {\\n    let [hs, ms] = op(s), [ht, mt] = op(t);\\n    let diff = Math.abs(hs * 60 + ms - (ht * 60 + mt));\\n    let res = 0;\\n    res += parseInt(diff / 60);\\n    diff %= 60;\\n    res += parseInt(diff / 15);\\n    diff %= 15;\\n    res += parseInt(diff / 5);\\n    diff %= 5;\\n    return res + diff; // finally diff will be in range [0, 4], use all 1\\n};\\n\\nconst op = (s) => {\\n    let a = s.split(\":\").map(Number);\\n    return a;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nconst convertTime = (s, t) => {\\n    let [hs, ms] = op(s), [ht, mt] = op(t);\\n    let diff = Math.abs(hs * 60 + ms - (ht * 60 + mt));\\n    let res = 0;\\n    res += parseInt(diff / 60);\\n    diff %= 60;\\n    res += parseInt(diff / 15);\\n    diff %= 15;\\n    res += parseInt(diff / 5);\\n    diff %= 5;\\n    return res + diff; // finally diff will be in range [0, 4], use all 1\\n};\\n\\nconst op = (s) => {\\n    let a = s.split(\":\").map(Number);\\n    return a;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2832399,
                "title": "pyrhon3-simple-beats-99-30-explained",
                "content": "The following code beats 99.30 % of python3 submissions\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        diff=(int(correct[:2])*60)+int(correct[3:])-((int(current[:2])*60)+int(current[3:]))\\n        count=0\\n        while diff!=0:\\n            if diff>=60:\\n                diff-=60\\n                count+=1\\n            elif diff>=15:\\n                diff-=15\\n                count+=1\\n            elif diff>=5:\\n                diff-=5\\n                count+=1\\n            else:\\n                diff-=1\\n                count+=1\\n        return count\\n```\\nExplanation\\nFirst we convert both the \\'times\\' into minutes by slicing the first 2 characters of the string and multiplying it by 60 to get the minutes and then adding the last two characters to get the total minutes python\\nAfter doing this we subtract the two \\'times\\' two get the difference\\nNow until the difference becomes 0 we keep subtracting 60 or 15 or 5 or 1 and incrementing the count for each subtraction",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        diff=(int(correct[:2])*60)+int(correct[3:])-((int(current[:2])*60)+int(current[3:]))\\n        count=0\\n        while diff!=0:\\n            if diff>=60:\\n                diff-=60\\n                count+=1\\n            elif diff>=15:\\n                diff-=15\\n                count+=1\\n            elif diff>=5:\\n                diff-=5\\n                count+=1\\n            else:\\n                diff-=1\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651747,
                "title": "c-100-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    int getTime(string &s) {\\n        return stoi(s.substr(0, 2)) * 60 + stoi(s.substr(3));\\n    }\\npublic:\\n    int convertTime(string current, string correct) {\\n        int diff = getTime(correct) - getTime(current), ops[4] = {60,15,5,1}, ans = 0;\\n        for (int op : ops) {\\n            ans += diff / op;\\n            diff %= op;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int getTime(string &s) {\\n        return stoi(s.substr(0, 2)) * 60 + stoi(s.substr(3));\\n    }\\npublic:\\n    int convertTime(string current, string correct) {\\n        int diff = getTime(correct) - getTime(current), ops[4] = {60,15,5,1}, ans = 0;\\n        for (int op : ops) {\\n            ans += diff / op;\\n            diff %= op;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929316,
                "title": "solution-in-6-languages-o-1-time-and-o-1-space-complexity-0ms-implementation",
                "content": "**Pls upvote(\\uD83E\\uDD7A\\uD83D\\uDE48\\uD83D\\uDE0C). If you found it useful**\\n\\nJust convert time of the day to minutes and iterate over 60,15,5,1 minutes to get the number of ops.\\n\\nPlease suggest any improvements language wise or algorithmwise, im only well verse in c++,golang. I use the rest of languages on need by basis at work.\\n\\nPlease comment if u have any doubts, will be happy to reply\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    int HHMMToMinutes(string s){\\n        return stoi(s.substr(0,2))*60 + stoi(s.substr(3,2));\\n    }\\n    int convertTime(string current, string correct) {\\n        int diff = - HHMMToMinutes(current) +  HHMMToMinutes(correct);\\n        vector<int> order = {60,15,5,1};\\n        int i = 0;\\n        int ans = 0;\\n        while(i < 4){\\n            ans+=(diff/order[i]);\\n            diff%=order[i];\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\nJava\\n\\n```\\nclass Solution {\\n    public int  HHMMToMinutes(String s){\\n        return Integer.parseInt(s.substring(0,2))*60 + Integer.parseInt(s.substring(3,5)) ;\\n    }\\n    public int convertTime(String current, String correct) {\\n        int diff =  HHMMToMinutes(correct) -  HHMMToMinutes(current);\\n        int[] order = {60,15,5,1};\\n        int i = 0;\\n        int ops = 0;\\n        while(i < 4){\\n            ops+=(diff/order[i]);\\n            diff%=order[i];\\n            i++;\\n        }\\n        return ops;\\n    }\\n}\\n```\\nPython\\n```\\nclass Solution:\\n    def HHMMToMinutes(self, s: str) -> int:\\n        return int(s[0:2])*60 + int(s[3:5])\\n    def convertTime(self, current: str, correct: str) -> int:\\n        diff = self.HHMMToMinutes(correct) - self.HHMMToMinutes(current)\\n        order = [60,15,5,1]\\n        ops = 0\\n        for i in range(0,4):\\n            ops+=int(diff/order[i])\\n            diff%=order[i]\\n        return ops\\n```\\nJavascript\\n\\n```\\nvar getTime = function(time){\\n    var [hrs,mins] = time.split(\":\");\\n    return parseInt(hrs)*60 + parseInt(mins);\\n}\\n\\n\\nvar convertTime = function(current, correct) {\\n    var diff = getTime(correct) - getTime(current);\\n    var order = [60,15,5,1];\\n    var ops = 0;\\n    order.forEach(val =>{\\n        ops+=Math.floor((diff/val));\\n        diff%=val;\\n    })\\n    return ops;\\n};\\n```\\n\\nGolang\\n```\\nimport \"strconv\"\\nfunc HHMMToMinutes(s string) int{\\n    sr := strings.Split(s,\":\")\\n    hrs,_ := strconv.Atoi(sr[0])\\n    minutes,_ := strconv.Atoi(sr[1]) \\n    return  hrs*60 + minutes \\n}\\nfunc convertTime(current string, correct string) int {\\n    diff := HHMMToMinutes(correct) - HHMMToMinutes(current)\\n    order := [4]int{60,15,5,1}\\n    ops := 0\\n    for i := 0 ; i < 4 ; i++ {\\n        ops+=(diff/order[i])\\n        diff%=order[i]\\n    }\\n    return ops\\n}\\n```\\n\\nKotlin\\n```\\nclass Solution {\\n    fun HHMMToMinutes(s: String): Int{\\n        return Integer.parseInt(s.subSequence(0,2).toString())*60+Integer.parseInt(s.subSequence(3,5).toString())\\n    }\\n    fun convertTime(current: String, correct: String): Int {\\n        var diff = HHMMToMinutes(correct) - HHMMToMinutes(current)\\n        var ops = 0\\n        val order = intArrayOf(60,15,5,1)\\n        println(diff)\\n        for(i in 0..3){\\n            ops+=(diff/order[i])\\n            diff%=order[i]\\n        }\\n        return ops\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Go",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int HHMMToMinutes(string s){\\n        return stoi(s.substr(0,2))*60 + stoi(s.substr(3,2));\\n    }\\n    int convertTime(string current, string correct) {\\n        int diff = - HHMMToMinutes(current) +  HHMMToMinutes(correct);\\n        vector<int> order = {60,15,5,1};\\n        int i = 0;\\n        int ans = 0;\\n        while(i < 4){\\n            ans+=(diff/order[i]);\\n            diff%=order[i];\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int  HHMMToMinutes(String s){\\n        return Integer.parseInt(s.substring(0,2))*60 + Integer.parseInt(s.substring(3,5)) ;\\n    }\\n    public int convertTime(String current, String correct) {\\n        int diff =  HHMMToMinutes(correct) -  HHMMToMinutes(current);\\n        int[] order = {60,15,5,1};\\n        int i = 0;\\n        int ops = 0;\\n        while(i < 4){\\n            ops+=(diff/order[i]);\\n            diff%=order[i];\\n            i++;\\n        }\\n        return ops;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def HHMMToMinutes(self, s: str) -> int:\\n        return int(s[0:2])*60 + int(s[3:5])\\n    def convertTime(self, current: str, correct: str) -> int:\\n        diff = self.HHMMToMinutes(correct) - self.HHMMToMinutes(current)\\n        order = [60,15,5,1]\\n        ops = 0\\n        for i in range(0,4):\\n            ops+=int(diff/order[i])\\n            diff%=order[i]\\n        return ops\\n```\n```\\nvar getTime = function(time){\\n    var [hrs,mins] = time.split(\":\");\\n    return parseInt(hrs)*60 + parseInt(mins);\\n}\\n\\n\\nvar convertTime = function(current, correct) {\\n    var diff = getTime(correct) - getTime(current);\\n    var order = [60,15,5,1];\\n    var ops = 0;\\n    order.forEach(val =>{\\n        ops+=Math.floor((diff/val));\\n        diff%=val;\\n    })\\n    return ops;\\n};\\n```\n```\\nimport \"strconv\"\\nfunc HHMMToMinutes(s string) int{\\n    sr := strings.Split(s,\":\")\\n    hrs,_ := strconv.Atoi(sr[0])\\n    minutes,_ := strconv.Atoi(sr[1]) \\n    return  hrs*60 + minutes \\n}\\nfunc convertTime(current string, correct string) int {\\n    diff := HHMMToMinutes(correct) - HHMMToMinutes(current)\\n    order := [4]int{60,15,5,1}\\n    ops := 0\\n    for i := 0 ; i < 4 ; i++ {\\n        ops+=(diff/order[i])\\n        diff%=order[i]\\n    }\\n    return ops\\n}\\n```\n```\\nclass Solution {\\n    fun HHMMToMinutes(s: String): Int{\\n        return Integer.parseInt(s.subSequence(0,2).toString())*60+Integer.parseInt(s.subSequence(3,5).toString())\\n    }\\n    fun convertTime(current: String, correct: String): Int {\\n        var diff = HHMMToMinutes(correct) - HHMMToMinutes(current)\\n        var ops = 0\\n        val order = intArrayOf(60,15,5,1)\\n        println(diff)\\n        for(i in 0..3){\\n            ops+=(diff/order[i])\\n            diff%=order[i]\\n        }\\n        return ops\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909822,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N)***\\n* ***Space Complexity : O(1)***\\n\\n```\\nint convertTime(string current, string correct) {\\n        \\n        int hour1 = 0;\\n        \\n        hour1 = hour1 * 10 + current[0] - \\'0\\';\\n        \\n        hour1 = hour1 * 10 + current[1] - \\'0\\';\\n        \\n        int minute1 = 0;\\n        \\n        minute1 = minute1 * 10 + current[3] - \\'0\\';\\n        \\n        minute1 = minute1 * 10 + current[4] - \\'0\\';\\n        \\n        int hour2 = 0;\\n        \\n        hour2 = hour2 * 10 + correct[0] - \\'0\\';\\n        \\n        hour2 = hour2 * 10 + correct[1] - \\'0\\';\\n        \\n        int minute2 = 0;\\n        \\n        minute2 = minute2 * 10 + correct[3] - \\'0\\';\\n        \\n        minute2 = minute2 * 10 + correct[4] - \\'0\\';\\n        \\n        int time1 = hour1 * 60 + minute1;\\n        \\n        int time2 = hour2 * 60 + minute2;\\n        \\n        int count = 0;\\n        \\n        while(time1 + 60 <= time2)\\n        {\\n            count++;\\n            \\n            time1 += 60;\\n        }\\n        \\n        while(time1 + 15 <= time2)\\n        {\\n            count++;\\n            \\n            time1 += 15;\\n        }\\n        \\n        while(time1 + 5 <= time2)\\n        {\\n            count++;\\n            \\n            time1 += 5;\\n        }\\n        \\n        while(time1 + 1 <= time2)\\n        {\\n            count++;\\n            \\n            time1 += 1;\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nint convertTime(string current, string correct) {\\n        \\n        int hour1 = 0;\\n        \\n        hour1 = hour1 * 10 + current[0] - \\'0\\';\\n        \\n        hour1 = hour1 * 10 + current[1] - \\'0\\';\\n        \\n        int minute1 = 0;\\n        \\n        minute1 = minute1 * 10 + current[3] - \\'0\\';\\n        \\n        minute1 = minute1 * 10 + current[4] - \\'0\\';\\n        \\n        int hour2 = 0;\\n        \\n        hour2 = hour2 * 10 + correct[0] - \\'0\\';\\n        \\n        hour2 = hour2 * 10 + correct[1] - \\'0\\';\\n        \\n        int minute2 = 0;\\n        \\n        minute2 = minute2 * 10 + correct[3] - \\'0\\';\\n        \\n        minute2 = minute2 * 10 + correct[4] - \\'0\\';\\n        \\n        int time1 = hour1 * 60 + minute1;\\n        \\n        int time2 = hour2 * 60 + minute2;\\n        \\n        int count = 0;\\n        \\n        while(time1 + 60 <= time2)\\n        {\\n            count++;\\n            \\n            time1 += 60;\\n        }\\n        \\n        while(time1 + 15 <= time2)\\n        {\\n            count++;\\n            \\n            time1 += 15;\\n        }\\n        \\n        while(time1 + 5 <= time2)\\n        {\\n            count++;\\n            \\n            time1 += 5;\\n        }\\n        \\n        while(time1 + 1 <= time2)\\n        {\\n            count++;\\n            \\n            time1 += 1;\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909573,
                "title": "java-time-conversion-new",
                "content": "```\\nclass Solution {\\n    public static int convertTime(String current, String correct) {\\n\\t\\tint start = Integer.parseInt(current.substring(0, 2)) * 60 + Integer.parseInt(current.substring(3));\\n\\t\\tint goal = Integer.parseInt(correct.substring(0, 2)) * 60 + Integer.parseInt(correct.substring(3));\\n\\n//\\t\\tSystem.out.println(start);\\n//\\t\\tSystem.out.println(goal);\\n\\t\\tint count = 0;\\n\\t\\twhile (goal != start) {\\n\\t\\t\\tint diff = goal - start;\\n\\t\\t\\tif (diff >= 60) {\\n\\t\\t\\t\\tgoal = goal - 60;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t} else if (diff >= 15) {\\n\\t\\t\\t\\tgoal = goal - 15;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t} else if (diff >=5) {\\n\\t\\t\\t\\tgoal = goal - 5;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t} else if (diff >= 1) {\\n\\t\\t\\t\\tgoal = goal - 1;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public static int convertTime(String current, String correct) {\\n\\t\\tint start = Integer.parseInt(current.substring(0, 2)) * 60 + Integer.parseInt(current.substring(3));\\n\\t\\tint goal = Integer.parseInt(correct.substring(0, 2)) * 60 + Integer.parseInt(correct.substring(3));\\n\\n//\\t\\tSystem.out.println(start);\\n//\\t\\tSystem.out.println(goal);\\n\\t\\tint count = 0;\\n\\t\\twhile (goal != start) {\\n\\t\\t\\tint diff = goal - start;\\n\\t\\t\\tif (diff >= 60) {\\n\\t\\t\\t\\tgoal = goal - 60;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t} else if (diff >= 15) {\\n\\t\\t\\t\\tgoal = goal - 15;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t} else if (diff >=5) {\\n\\t\\t\\t\\tgoal = goal - 5;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t} else if (diff >= 1) {\\n\\t\\t\\t\\tgoal = goal - 1;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908924,
                "title": "python-o-1-time",
                "content": "```\\nclass Solution:\\n    def convertTime(self, s: str, c: str) -> int:\\n        dif=(int(c[:2])*60+int(c[3:]))-(int(s[:2])*60+int(s[3:]))\\n        count=0\\n        print(dif)\\n        arr=[60,15,5,1]\\n        for x in arr:\\n            count+=dif//x\\n            dif=dif%x\\n        return count",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, s: str, c: str) -> int:\\n        dif=(int(c[:2])*60+int(c[3:]))-(int(s[:2])*60+int(s[3:]))\\n        count=0\\n        print(dif)\\n        arr=[60,15,5,1]\\n        for x in arr:\\n            count+=dif//x\\n            dif=dif%x\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 1908893,
                "title": "simple-elegant-solution-with-explaination",
                "content": "## Idea:\\nFor simplification, we can firstly convert `current` and `correct` to minutes. In this problem, we essentially need to bridge the gap between `current` and `correct` by adding  `[1, 5, 15, 60]` minutes to `current`. To be precise, we need to add `correct - current` number of minutes to \\'current\\'. Let `diff = correct - current`.\\n\\n### Superincreasing sequence:\\nNote that the sequence `[1, 5, 15, 60]` is a **superincreasing sequence**. A sequence is called superincreasing if every element of the sequence is greater than the sum of all previous elements in the sequence. In this case:\\n```\\n5 > 1\\n15 > 1 + 5\\n60 > 1 + 5 + 15\\n```\\n\\nSince its superincreasing, we can **greedily** solve the problem by first subtracting 60 from `diff` as much as we can, then subtracting 15 as much as we can and so on until diff becomes zero. We simply count the number of times we have to subtract. We can implement this elegantly using python\\'s `divmod`.\\n\\n### Solution:\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        def get_time(t):\\n            hh, mm = t.split(\\':\\')\\n            return int(hh) * 60 + int(mm)\\n        \\n        current, correct = get_time(current), get_time(correct)\\n        operations = 0\\n        diff = correct - current\\n        \\n        for mins in [60, 15, 5, 1]:\\n            quotient, remainder = divmod(diff, mins)\\n            operations += quotient\\n            diff = remainder\\n                \\n        return operations\\n```\\n\\n\\nTime Complexity: O(1)\\nSpace Complexity: O(1)\\n\\n**Do upvote if you like the solution. Have a nice day!**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n5 > 1\\n15 > 1 + 5\\n60 > 1 + 5 + 15\\n```\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        def get_time(t):\\n            hh, mm = t.split(\\':\\')\\n            return int(hh) * 60 + int(mm)\\n        \\n        current, correct = get_time(current), get_time(correct)\\n        operations = 0\\n        diff = correct - current\\n        \\n        for mins in [60, 15, 5, 1]:\\n            quotient, remainder = divmod(diff, mins)\\n            operations += quotient\\n            diff = remainder\\n                \\n        return operations\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908744,
                "title": "python-java-easy-to-understand",
                "content": "\\tclass Solution:\\n\\t\\tdef convertTime(self, current: str, correct: str) -> int:\\n\\t\\t\\tcurrentTime = int(current[0:2]) * 60 + int(current[3:])\\n\\t\\t\\tcorrectTime = int(correct[0:2]) * 60 + int(correct[3:])\\n\\t\\t\\tdiff = correctTime - currentTime\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor time in (60, 15, 5, 1):\\n\\t\\t\\t\\tres += diff // time\\n\\t\\t\\t\\tdiff %= time\\n\\t\\t\\treturn res\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int convertTime(String current, String correct) {\\n\\t\\t\\tint currentTime = Integer.valueOf(current.substring(0, 2)) * 60 + Integer.valueOf(current.substring(3, 5));\\n\\t\\t\\tint correctTime = Integer.valueOf(correct.substring(0, 2)) * 60 + Integer.valueOf(correct.substring(3, 5));\\n\\t\\t\\tint diff = correctTime - currentTime;\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor (int time: new int[] {60, 15, 5, 1}) {\\n\\t\\t\\t\\tres += diff / time;\\n\\t\\t\\t\\tdiff %= time;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef convertTime(self, current: str, correct: str) -> int:\\n\\t\\t\\tcurrentTime = int(current[0:2]) * 60 + int(current[3:])\\n\\t\\t\\tcorrectTime = int(correct[0:2]) * 60 + int(correct[3:])\\n\\t\\t\\tdiff = correctTime - currentTime\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor time in (60, 15, 5, 1):\\n\\t\\t\\t\\tres += diff // time\\n\\t\\t\\t\\tdiff %= time\\n\\t\\t\\treturn res\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int convertTime(String current, String correct) {\\n\\t\\t\\tint currentTime = Integer.valueOf(current.substring(0, 2)) * 60 + Integer.valueOf(current.substring(3, 5));\\n\\t\\t\\tint correctTime = Integer.valueOf(correct.substring(0, 2)) * 60 + Integer.valueOf(correct.substring(3, 5));\\n\\t\\t\\tint diff = correctTime - currentTime;\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor (int time: new int[] {60, 15, 5, 1}",
                "codeTag": "Java"
            },
            {
                "id": 3387766,
                "title": "minimum-number-of-operations-to-convert-time-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int current_time=0, correct_time=0, diff, count=0;\\n        \\n        current_time = (int(current[0])*10+int(current[1]))*60+int(current[3])*10+int(current[4]);\\n        correct_time = (int(correct[0])*10+int(correct[1]))*60+int(correct[3])*10+int(correct[4]);\\n\\n        diff = correct_time-current_time;\\n        while(diff!=0)\\n        {\\n            if(diff>=60)\\n                diff -= 60;\\n            else if(diff>=15)\\n                diff -= 15;\\n            else if(diff>=5)\\n                diff -= 5;\\n            else\\n                diff -= 1;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int current_time=0, correct_time=0, diff, count=0;\\n        \\n        current_time = (int(current[0])*10+int(current[1]))*60+int(current[3])*10+int(current[4]);\\n        correct_time = (int(correct[0])*10+int(correct[1]))*60+int(correct[3])*10+int(correct[4]);\\n\\n        diff = correct_time-current_time;\\n        while(diff!=0)\\n        {\\n            if(diff>=60)\\n                diff -= 60;\\n            else if(diff>=15)\\n                diff -= 15;\\n            else if(diff>=5)\\n                diff -= 5;\\n            else\\n                diff -= 1;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289410,
                "title": "beat-99-29-22ms-python3-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        current, correct = current.replace(\\':\\',\\'\\'), correct.replace(\\':\\',\\'\\')\\n        a, count = (int(correct[:2]) * 60 + int(correct[2:])) - (int(current[:2]) * 60 + int(current[2:])), 0\\n        for i in [60, 15, 5, 1]:\\n            count += a // i\\n            a %= i\\n        return count \\n\\n        #before for loop\\n        # while a != 0:\\n        #     if a >= 60:\\n        #         count += (a // 60)\\n        #         a %= 60\\n        #     elif 15 <= a < 60:\\n        #         count += (a // 15)\\n        #         a %= 15\\n        #     elif 5 <= a < 15:\\n        #         count += (a // 5)\\n        #         a %= 5\\n        #     elif 1 <= a < 5:\\n        #         count += (a // 1)\\n        #         a %= 1\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        current, correct = current.replace(\\':\\',\\'\\'), correct.replace(\\':\\',\\'\\')\\n        a, count = (int(correct[:2]) * 60 + int(correct[2:])) - (int(current[:2]) * 60 + int(current[2:])), 0\\n        for i in [60, 15, 5, 1]:\\n            count += a // i\\n            a %= i\\n        return count \\n\\n        #before for loop\\n        # while a != 0:\\n        #     if a >= 60:\\n        #         count += (a // 60)\\n        #         a %= 60\\n        #     elif 15 <= a < 60:\\n        #         count += (a // 15)\\n        #         a %= 15\\n        #     elif 5 <= a < 15:\\n        #         count += (a // 5)\\n        #         a %= 5\\n        #     elif 1 <= a < 5:\\n        #         count += (a // 1)\\n        #         a %= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791871,
                "title": "java-optimized-from-8-ms-to-1ms",
                "content": "# Solution 3 | 8ms | 11% time | 69% memory\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int curHour = Integer.parseInt(current.charAt(0) + \"\" + current.charAt(1));\\n        int curMin = Integer.parseInt(current.charAt(3) + \"\" + current.charAt(4));\\n        int corHour = Integer.parseInt(correct.charAt(0) + \"\" + correct.charAt(1));\\n        int corMin = Integer.parseInt(correct.charAt(3) + \"\" + correct.charAt(4));\\n        int timeCur = curHour * 60 + curMin, timeCor = corHour * 60 + corMin;\\n        int count = 0;\\n        if (timeCur < timeCor) {\\n            while (timeCur != timeCor) {\\n                if (timeCur + 60 <= timeCor) {\\n                    timeCur += 60;\\n                } else if (timeCur + 15 <= timeCor) {\\n                    timeCur += 15;\\n                } else if (timeCur + 5 <= timeCor) {\\n                    timeCur += 5;\\n                } else timeCur++;\\n                count++;\\n            }\\n        } else if (timeCur > timeCor) {\\n            while (timeCur != timeCor) {\\n                if (timeCur - 60 >= timeCor) {\\n                    timeCur -= 60;\\n                } else if (timeCur - 15 >= timeCor) {\\n                    timeCur -= 15;\\n                } else if (timeCur - 5 >= timeCor) {\\n                    timeCur -= 5;\\n                } else timeCur--;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\nDecided to use StringBuilder.\\n\\n# Solution 2 | 2ms | 83% time | 87% memory\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        StringBuilder sb = new StringBuilder();\\n        int curHour = Integer.parseInt(sb.append(current.charAt(0)).append(current.charAt(1)).toString());\\n        sb.setLength(0);\\n        int curMin = Integer.parseInt(sb.append(current.charAt(3)).append(current.charAt(4)).toString());\\n        sb.setLength(0);\\n        int corHour = Integer.parseInt(sb.append(correct.charAt(0)).append(correct.charAt(1)).toString());\\n        sb.setLength(0);\\n        int corMin = Integer.parseInt(sb.append(correct.charAt(3)).append(correct.charAt(4)).toString());\\n        int timeCur = curHour * 60 + curMin, timeCor = corHour * 60 + corMin;\\n        int count = 0;\\n        if (timeCur < timeCor) {\\n            while (timeCur != timeCor) {\\n                if (timeCur + 60 <= timeCor) {\\n                    timeCur += 60;\\n                } else if (timeCur + 15 <= timeCor) {\\n                    timeCur += 15;\\n                } else if (timeCur + 5 <= timeCor) {\\n                    timeCur += 5;\\n                } else timeCur++;\\n                count++;\\n            }\\n        } else if (timeCur > timeCor) {\\n            while (timeCur != timeCor) {\\n                if (timeCur - 60 >= timeCor) {\\n                    timeCur -= 60;\\n                } else if (timeCur - 15 >= timeCor) {\\n                    timeCur -= 15;\\n                } else if (timeCur - 5 >= timeCor) {\\n                    timeCur -= 5;\\n                } else timeCur--;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n# Solution 1 | 1ms | 99% time |55% memory\\nComplexity: O(1)\\n```\\nint curHour = (current.charAt(0) - \\'0\\') * 10 + (current.charAt(1) - \\'0\\');\\n        int curMin = (current.charAt(3) - \\'0\\') * 10 + (current.charAt(4) - \\'0\\');\\n        int corHour = (correct.charAt(0) - \\'0\\') * 10 + (correct.charAt(1) - \\'0\\');\\n        int corMin = (correct.charAt(3) - \\'0\\') * 10 + (correct.charAt(4) - \\'0\\');\\n        int diff = (corHour * 60 + corMin) - (curHour * 60 + curMin);\\n        int sixty = diff / 60;\\n        diff -= sixty * 60;\\n        int fifteen = diff / 15;\\n        diff -= fifteen * 15;\\n        int five = diff / 5;\\n        diff -= five * 5;\\n        return sixty + fifteen + five + diff;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int curHour = Integer.parseInt(current.charAt(0) + \"\" + current.charAt(1));\\n        int curMin = Integer.parseInt(current.charAt(3) + \"\" + current.charAt(4));\\n        int corHour = Integer.parseInt(correct.charAt(0) + \"\" + correct.charAt(1));\\n        int corMin = Integer.parseInt(correct.charAt(3) + \"\" + correct.charAt(4));\\n        int timeCur = curHour * 60 + curMin, timeCor = corHour * 60 + corMin;\\n        int count = 0;\\n        if (timeCur < timeCor) {\\n            while (timeCur != timeCor) {\\n                if (timeCur + 60 <= timeCor) {\\n                    timeCur += 60;\\n                } else if (timeCur + 15 <= timeCor) {\\n                    timeCur += 15;\\n                } else if (timeCur + 5 <= timeCor) {\\n                    timeCur += 5;\\n                } else timeCur++;\\n                count++;\\n            }\\n        } else if (timeCur > timeCor) {\\n            while (timeCur != timeCor) {\\n                if (timeCur - 60 >= timeCor) {\\n                    timeCur -= 60;\\n                } else if (timeCur - 15 >= timeCor) {\\n                    timeCur -= 15;\\n                } else if (timeCur - 5 >= timeCor) {\\n                    timeCur -= 5;\\n                } else timeCur--;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        StringBuilder sb = new StringBuilder();\\n        int curHour = Integer.parseInt(sb.append(current.charAt(0)).append(current.charAt(1)).toString());\\n        sb.setLength(0);\\n        int curMin = Integer.parseInt(sb.append(current.charAt(3)).append(current.charAt(4)).toString());\\n        sb.setLength(0);\\n        int corHour = Integer.parseInt(sb.append(correct.charAt(0)).append(correct.charAt(1)).toString());\\n        sb.setLength(0);\\n        int corMin = Integer.parseInt(sb.append(correct.charAt(3)).append(correct.charAt(4)).toString());\\n        int timeCur = curHour * 60 + curMin, timeCor = corHour * 60 + corMin;\\n        int count = 0;\\n        if (timeCur < timeCor) {\\n            while (timeCur != timeCor) {\\n                if (timeCur + 60 <= timeCor) {\\n                    timeCur += 60;\\n                } else if (timeCur + 15 <= timeCor) {\\n                    timeCur += 15;\\n                } else if (timeCur + 5 <= timeCor) {\\n                    timeCur += 5;\\n                } else timeCur++;\\n                count++;\\n            }\\n        } else if (timeCur > timeCor) {\\n            while (timeCur != timeCor) {\\n                if (timeCur - 60 >= timeCor) {\\n                    timeCur -= 60;\\n                } else if (timeCur - 15 >= timeCor) {\\n                    timeCur -= 15;\\n                } else if (timeCur - 5 >= timeCor) {\\n                    timeCur -= 5;\\n                } else timeCur--;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nint curHour = (current.charAt(0) - \\'0\\') * 10 + (current.charAt(1) - \\'0\\');\\n        int curMin = (current.charAt(3) - \\'0\\') * 10 + (current.charAt(4) - \\'0\\');\\n        int corHour = (correct.charAt(0) - \\'0\\') * 10 + (correct.charAt(1) - \\'0\\');\\n        int corMin = (correct.charAt(3) - \\'0\\') * 10 + (correct.charAt(4) - \\'0\\');\\n        int diff = (corHour * 60 + corMin) - (curHour * 60 + curMin);\\n        int sixty = diff / 60;\\n        diff -= sixty * 60;\\n        int fifteen = diff / 15;\\n        diff -= fifteen * 15;\\n        int five = diff / 5;\\n        diff -= five * 5;\\n        return sixty + fifteen + five + diff;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614687,
                "title": "simple-java-solution-greedy",
                "content": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int currentTimeInMin = getMinutes(current);\\n        int correctTimeInMin = getMinutes(correct);\\n        \\n        int diff=correctTimeInMin-currentTimeInMin;\\n        int[] denominations={60,15,5,1};\\n        int count=0;\\n        if(diff>0){\\n            for(int denomination:denominations){\\n                if(diff%denomination==0){\\n                    count+=diff/denomination;\\n                    break;\\n                }else{\\n                   count+=diff/denomination;\\n                    diff=diff%denomination;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public int getMinutes(String time){\\n        int hours=Integer.parseInt(time.split(\":\")[0]);\\n        int minutes=Integer.parseInt(time.split(\":\")[1]);\\n        \\n        return hours*60+minutes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int currentTimeInMin = getMinutes(current);\\n        int correctTimeInMin = getMinutes(correct);\\n        \\n        int diff=correctTimeInMin-currentTimeInMin;\\n        int[] denominations={60,15,5,1};\\n        int count=0;\\n        if(diff>0){\\n            for(int denomination:denominations){\\n                if(diff%denomination==0){\\n                    count+=diff/denomination;\\n                    break;\\n                }else{\\n                   count+=diff/denomination;\\n                    diff=diff%denomination;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public int getMinutes(String time){\\n        int hours=Integer.parseInt(time.split(\":\")[0]);\\n        int minutes=Integer.parseInt(time.split(\":\")[1]);\\n        \\n        return hours*60+minutes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911834,
                "title": "rust-parse-o-n",
                "content": "parse, unwrap_or.\\n\\n```\\nimpl Solution {\\n    pub fn convert_time(current: String, correct: String) -> i32 {\\n        let h = &current[..2].parse::<i32>().map_or(0, |x|x);\\n        let m = &current[3..].parse::<i32>().unwrap_or(0);\\n        let start = h*60 + m;\\n\\n        let h = &correct[..2].parse::<i32>().map_or(0, |x|x);\\n        let m = &correct[3..].parse::<i32>().unwrap_or(0);\\n        let end = h*60 + m;\\n        let mut diff = end - start;\\n        \\n        let mut ans = diff/60;\\n        diff %= 60;\\n        ans += diff/15;\\n        diff %= 15;\\n        ans += diff/5;\\n        diff %= 5;\\n        ans += diff;\\n        \\n        // println!(\"h {}, m {}\", h, m);\\n        \\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn convert_time(current: String, correct: String) -> i32 {\\n        let h = &current[..2].parse::<i32>().map_or(0, |x|x);\\n        let m = &current[3..].parse::<i32>().unwrap_or(0);\\n        let start = h*60 + m;\\n\\n        let h = &correct[..2].parse::<i32>().map_or(0, |x|x);\\n        let m = &correct[3..].parse::<i32>().unwrap_or(0);\\n        let end = h*60 + m;\\n        let mut diff = end - start;\\n        \\n        let mut ans = diff/60;\\n        diff %= 60;\\n        ans += diff/15;\\n        diff %= 15;\\n        ans += diff/5;\\n        diff %= 5;\\n        ans += diff;\\n        \\n        // println!(\"h {}, m {}\", h, m);\\n        \\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1911669,
                "title": "c-convert-given-times-to-minutes-and-think-in-greedy-way",
                "content": "```\\nclass Solution {\\npublic:\\n    int convertToMinutes(string current){\\n        int minutes = 0;\\n        //add hrs after converting to minutes 02:35 ->02*60 = 120\\n        int i;\\n        string hrs = \"\";\\n        for(i=0; i<=1; i++){\\n             hrs += current[i];\\n        }\\n        int hrI = stoi(hrs);   //\"02\"  -> 02\\n        minutes += (hrI*60);   //02*60 -> 120\\n        \\n        string minute;\\n        for(i=3; i<=4; i++){\\n            minute += current[i];\\n        }\\n        int minuteI = stoi(minute);\\n        minutes += minuteI;\\n        \\n        return minutes;\\n    }\\n    \\n    int convertTime(string current, string correct) {\\n        int dest = convertToMinutes(current);\\n        int target = convertToMinutes(correct);\\n        \\n        int count = 0;\\n        while(dest != target){\\n            if(dest+60 <= target)\\n                dest += 60;\\n            else if(dest+15 <= target)\\n                dest += 15;\\n            else if(dest+5 <= target)\\n                dest += 5;\\n            else\\n                dest += 1;\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertToMinutes(string current){\\n        int minutes = 0;\\n        //add hrs after converting to minutes 02:35 ->02*60 = 120\\n        int i;\\n        string hrs = \"\";\\n        for(i=0; i<=1; i++){\\n             hrs += current[i];\\n        }\\n        int hrI = stoi(hrs);   //\"02\"  -> 02\\n        minutes += (hrI*60);   //02*60 -> 120\\n        \\n        string minute;\\n        for(i=3; i<=4; i++){\\n            minute += current[i];\\n        }\\n        int minuteI = stoi(minute);\\n        minutes += minuteI;\\n        \\n        return minutes;\\n    }\\n    \\n    int convertTime(string current, string correct) {\\n        int dest = convertToMinutes(current);\\n        int target = convertToMinutes(correct);\\n        \\n        int count = 0;\\n        while(dest != target){\\n            if(dest+60 <= target)\\n                dest += 60;\\n            else if(dest+15 <= target)\\n                dest += 15;\\n            else if(dest+5 <= target)\\n                dest += 5;\\n            else\\n                dest += 1;\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910136,
                "title": "java-greedy-easy-understanding",
                "content": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        // convert current time to minutes\\n        String[] current_time = current.split(\":\");\\n        int current_hour = Integer.parseInt(current_time[0]);\\n        current_hour *= 60;\\n        int current_min = Integer.parseInt(current_time[1]);\\n        current_hour += current_min;\\n        \\n        // convert correct time to minutes\\n        String[] correct_time = correct.split(\":\");\\n        int correct_hour = Integer.parseInt(correct_time[0]);\\n        correct_hour *= 60;\\n        int correct_min = Integer.parseInt(correct_time[1]);\\n        correct_hour += correct_min;\\n        \\n        // operations\\n        int count = 0;\\n        \\n        // do greedily\\n        while(correct_hour - current_hour >= 60){\\n            count++;\\n            current_hour += 60;\\n        }\\n        while(correct_hour - current_hour >= 15){\\n            count++;\\n            current_hour += 15;\\n        }\\n        while(correct_hour - current_hour >= 5){\\n            count++;\\n            current_hour += 5;\\n        }\\n        while(correct_hour - current_hour >= 1){\\n            count++;\\n            current_hour += 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        // convert current time to minutes\\n        String[] current_time = current.split(\":\");\\n        int current_hour = Integer.parseInt(current_time[0]);\\n        current_hour *= 60;\\n        int current_min = Integer.parseInt(current_time[1]);\\n        current_hour += current_min;\\n        \\n        // convert correct time to minutes\\n        String[] correct_time = correct.split(\":\");\\n        int correct_hour = Integer.parseInt(correct_time[0]);\\n        correct_hour *= 60;\\n        int correct_min = Integer.parseInt(correct_time[1]);\\n        correct_hour += correct_min;\\n        \\n        // operations\\n        int count = 0;\\n        \\n        // do greedily\\n        while(correct_hour - current_hour >= 60){\\n            count++;\\n            current_hour += 60;\\n        }\\n        while(correct_hour - current_hour >= 15){\\n            count++;\\n            current_hour += 15;\\n        }\\n        while(correct_hour - current_hour >= 5){\\n            count++;\\n            current_hour += 5;\\n        }\\n        while(correct_hour - current_hour >= 1){\\n            count++;\\n            current_hour += 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909288,
                "title": "c-easy-o-n-solution-maths",
                "content": "**Please upvote if it helps :)**\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) \\n    {\\n        int cur_hrs = stoi(current.substr(0,2)), cur_min = stoi(current.substr(3,4));\\n        int cor_hrs = stoi(correct.substr(0,2)), cor_min = stoi(correct.substr(3,4));\\n\\n        int diff_min;\\n        int oper=0;\\n        \\n        //if minute diffrence is negative then we decrease correct hrs by 1 \\n        //Eg: current- 10:45, correct- 11:34 \\n        if((cor_min-cur_min) < 0) \\n            cor_hrs -= 1;\\n        \\n        diff_min = (60 + (cor_min - cur_min)) % 60; \\n        diff_min += 60*((24 + (cor_hrs - cur_hrs)) % 24); // mutliply by 60 to convert hrs into min.\\n    \\n        \\n        while(diff_min != 0)\\n        {\\n            if(diff_min >= 60)\\n            {\\n                diff_min -= 60; oper++;\\n            }\\n            else if(diff_min >= 15)\\n            {\\n                diff_min -= 15; oper++;\\n            }\\n            else if(diff_min >= 5)\\n            {\\n                diff_min -= 5; oper++;\\n            }\\n            else\\n            {\\n                diff_min -= 1; oper++;\\n            }\\n        }\\n        \\n        \\n       return oper; \\n    }\\n};\\n```\\n**Please upvote if it helps :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) \\n    {\\n        int cur_hrs = stoi(current.substr(0,2)), cur_min = stoi(current.substr(3,4));\\n        int cor_hrs = stoi(correct.substr(0,2)), cor_min = stoi(correct.substr(3,4));\\n\\n        int diff_min;\\n        int oper=0;\\n        \\n        //if minute diffrence is negative then we decrease correct hrs by 1 \\n        //Eg: current- 10:45, correct- 11:34 \\n        if((cor_min-cur_min) < 0) \\n            cor_hrs -= 1;\\n        \\n        diff_min = (60 + (cor_min - cur_min)) % 60; \\n        diff_min += 60*((24 + (cor_hrs - cur_hrs)) % 24); // mutliply by 60 to convert hrs into min.\\n    \\n        \\n        while(diff_min != 0)\\n        {\\n            if(diff_min >= 60)\\n            {\\n                diff_min -= 60; oper++;\\n            }\\n            else if(diff_min >= 15)\\n            {\\n                diff_min -= 15; oper++;\\n            }\\n            else if(diff_min >= 5)\\n            {\\n                diff_min -= 5; oper++;\\n            }\\n            else\\n            {\\n                diff_min -= 1; oper++;\\n            }\\n        }\\n        \\n        \\n       return oper; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909233,
                "title": "go-golang-time-o-1-0-ms-100-space-o-1-1-9-mb-100",
                "content": "```\\nfunc convertTime(current string, correct string) int {\\n    currentHour, _ := strconv.Atoi(current[:2])\\n    correctHour, _ := strconv.Atoi(correct[:2])\\n    currentMinutes, _ := strconv.Atoi(current[3:])\\n    correctMinutes, _ := strconv.Atoi(correct[3:])\\n    result, minutes := 0, (correctHour - currentHour) * 60 - (currentMinutes - correctMinutes)\\n    \\n    for _, increase := range []int{60, 15, 5} {\\n        result += minutes / increase\\n        minutes %= increase\\n    }\\n\\n    return result + minutes\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Greedy"
                ],
                "code": "```\\nfunc convertTime(current string, correct string) int {\\n    currentHour, _ := strconv.Atoi(current[:2])\\n    correctHour, _ := strconv.Atoi(correct[:2])\\n    currentMinutes, _ := strconv.Atoi(current[3:])\\n    correctMinutes, _ := strconv.Atoi(correct[3:])\\n    result, minutes := 0, (correctHour - currentHour) * 60 - (currentMinutes - correctMinutes)\\n    \\n    for _, increase := range []int{60, 15, 5} {\\n        result += minutes / increase\\n        minutes %= increase\\n    }\\n\\n    return result + minutes\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1908829,
                "title": "c-string-maths",
                "content": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int hd = stoi(correct.substr(0,2)) - stoi(current.substr(0,2));\\n        int ans = 0;\\n        ans += hd;\\n        \\n        int ct = stoi(correct.substr(3,2)) - stoi(current.substr(3,2));\\n        \\n        if(ct > 0){\\n            while(ct > 0){\\n                if(ct >= 15){\\n                    ct -= 15;\\n                }else if(ct>=5){\\n                    ct-=5;\\n                }\\n                else{\\n                    ct-=1;\\n                }\\n                ans++;\\n            }\\n        }\\n        else if(ct < 0){\\n            int kk = ((hd-1)+24)%24;\\n            int td = 60+ct;\\n            while(td > 0){\\n                cout<<td<<\" \";\\n                if(td >= 15){\\n                    td -= 15;\\n                }else if(td>=5){\\n                    td-=5;\\n                }\\n                else{\\n                    td-=1;\\n                }\\n                kk++;\\n            }\\n            return kk;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int hd = stoi(correct.substr(0,2)) - stoi(current.substr(0,2));\\n        int ans = 0;\\n        ans += hd;\\n        \\n        int ct = stoi(correct.substr(3,2)) - stoi(current.substr(3,2));\\n        \\n        if(ct > 0){\\n            while(ct > 0){\\n                if(ct >= 15){\\n                    ct -= 15;\\n                }else if(ct>=5){\\n                    ct-=5;\\n                }\\n                else{\\n                    ct-=1;\\n                }\\n                ans++;\\n            }\\n        }\\n        else if(ct < 0){\\n            int kk = ((hd-1)+24)%24;\\n            int td = 60+ct;\\n            while(td > 0){\\n                cout<<td<<\" \";\\n                if(td >= 15){\\n                    td -= 15;\\n                }else if(td>=5){\\n                    td-=5;\\n                }\\n                else{\\n                    td-=1;\\n                }\\n                kk++;\\n            }\\n            return kk;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1908737,
                "title": "c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) \\n    {\\n        // extractig the minute & hours value from given strings\\n        int cur_hrs = stoi(current.substr(0,2));\\n        int cur_min = stoi(current.substr(3,4));\\n        int cor_hrs = stoi(correct.substr(0,2));\\n        int cor_min = stoi(correct.substr(3,4));\\n        \\n        // it will count the total number of minute difference\\n        int diff_min;\\n        int oper=0;\\n        \\n        // if our target is leeser than do -1\\n        if((cor_min-cur_min) < 0) \\n            cor_hrs -= 1;\\n        \\n        // counting the diff min \\n        // first for minutes and then for hours (1 hour = 60 minute)\\n        diff_min = (60 + (cor_min - cur_min)) % 60;\\n        diff_min += 60*((24 + (cor_hrs - cur_hrs)) % 24);\\n    \\n        // while our diff min is not equal to 0\\n        while(diff_min != 0)\\n        {\\n            // if our diff is bigger than or equal to 60 than substract 60 from it \\n            if(diff_min >= 60)\\n            {\\n                diff_min -= 60; \\n                oper++;\\n            }\\n            // if our diff is bigger than or equal to 15 than substract 15 from it \\n            else if(diff_min >= 15)\\n            {\\n                diff_min -= 15; \\n                oper++;\\n            }\\n            // if our diff is bigger than or equal to 5 than substract 5 from it \\n            else if(diff_min >= 5)\\n            {\\n                diff_min -= 5; \\n                oper++;\\n            }\\n            // if our diff is bigger than or equal to 1 than substract 1 from it \\n            else\\n            {\\n                diff_min -= 1; \\n                oper++;\\n            }\\n        }\\n        \\n        \\n       return oper; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) \\n    {\\n        // extractig the minute & hours value from given strings\\n        int cur_hrs = stoi(current.substr(0,2));\\n        int cur_min = stoi(current.substr(3,4));\\n        int cor_hrs = stoi(correct.substr(0,2));\\n        int cor_min = stoi(correct.substr(3,4));\\n        \\n        // it will count the total number of minute difference\\n        int diff_min;\\n        int oper=0;\\n        \\n        // if our target is leeser than do -1\\n        if((cor_min-cur_min) < 0) \\n            cor_hrs -= 1;\\n        \\n        // counting the diff min \\n        // first for minutes and then for hours (1 hour = 60 minute)\\n        diff_min = (60 + (cor_min - cur_min)) % 60;\\n        diff_min += 60*((24 + (cor_hrs - cur_hrs)) % 24);\\n    \\n        // while our diff min is not equal to 0\\n        while(diff_min != 0)\\n        {\\n            // if our diff is bigger than or equal to 60 than substract 60 from it \\n            if(diff_min >= 60)\\n            {\\n                diff_min -= 60; \\n                oper++;\\n            }\\n            // if our diff is bigger than or equal to 15 than substract 15 from it \\n            else if(diff_min >= 15)\\n            {\\n                diff_min -= 15; \\n                oper++;\\n            }\\n            // if our diff is bigger than or equal to 5 than substract 5 from it \\n            else if(diff_min >= 5)\\n            {\\n                diff_min -= 5; \\n                oper++;\\n            }\\n            // if our diff is bigger than or equal to 1 than substract 1 from it \\n            else\\n            {\\n                diff_min -= 1; \\n                oper++;\\n            }\\n        }\\n        \\n        \\n       return oper; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830171,
                "title": "fastest-solution-java",
                "content": "# Code\\n```\\nclass Solution{\\n    public int convertTime(String current, String correct){\\n        int a = Integer.parseInt(current.substring(0, 2));\\n        int b = Integer.parseInt(current.substring(3));\\n        int x = a*60+b;\\n        int c = Integer.parseInt(correct.substring(0, 2));\\n        int d = Integer.parseInt(correct.substring(3));\\n        int y = c*60+d;\\n        int k = y-x;\\n        int ans = 0;\\n        while(k>0){\\n            if(k%60==0){\\n                k -= 60;\\n                ans++;\\n            }\\n            else if(k%15==0){\\n                k -= 15;\\n                ans++;\\n            }\\n            else if(k%5==0){\\n                k -= 5;\\n                ans++;\\n            }\\n            else if(k%1==0){\\n                k -= 1;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\n    public int convertTime(String current, String correct){\\n        int a = Integer.parseInt(current.substring(0, 2));\\n        int b = Integer.parseInt(current.substring(3));\\n        int x = a*60+b;\\n        int c = Integer.parseInt(correct.substring(0, 2));\\n        int d = Integer.parseInt(correct.substring(3));\\n        int y = c*60+d;\\n        int k = y-x;\\n        int ans = 0;\\n        while(k>0){\\n            if(k%60==0){\\n                k -= 60;\\n                ans++;\\n            }\\n            else if(k%15==0){\\n                k -= 15;\\n                ans++;\\n            }\\n            else if(k%5==0){\\n                k -= 5;\\n                ans++;\\n            }\\n            else if(k%1==0){\\n                k -= 1;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668590,
                "title": "100-beat-easy-to-understand-c-solution-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string s1, string s2) {\\n        int h1 = stoi(s1.substr(0,2));\\n        int m1 = stoi(s1.substr(3,2));\\n        int h2 = stoi(s2.substr(0,2));\\n        int m2 = stoi(s2.substr(3,2));\\n        int hrDiff = h2 - h1;\\n        if(hrDiff < 0) hrDiff += 24;\\n        int minDiff = m2 - m1;\\n        int total = hrDiff*60 + minDiff;\\n        int ans = 0;\\n\\n        if(total >= 60){\\n            ans += (total/60);\\n            total = total%60;\\n        }\\n        if(total >= 15){\\n            ans += (total/15);\\n            total = total%15;\\n        }\\n        if(total >= 5){\\n            ans += (total / 5);\\n            total = total%5;\\n        }\\n        ans += total;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string s1, string s2) {\\n        int h1 = stoi(s1.substr(0,2));\\n        int m1 = stoi(s1.substr(3,2));\\n        int h2 = stoi(s2.substr(0,2));\\n        int m2 = stoi(s2.substr(3,2));\\n        int hrDiff = h2 - h1;\\n        if(hrDiff < 0) hrDiff += 24;\\n        int minDiff = m2 - m1;\\n        int total = hrDiff*60 + minDiff;\\n        int ans = 0;\\n\\n        if(total >= 60){\\n            ans += (total/60);\\n            total = total%60;\\n        }\\n        if(total >= 15){\\n            ans += (total/15);\\n            total = total%15;\\n        }\\n        if(total >= 5){\\n            ans += (total / 5);\\n            total = total%5;\\n        }\\n        ans += total;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749036,
                "title": "minimum-memory-81-faster-math-integer",
                "content": "Clean code and faster!\\n\\n\\n\\n\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int x = Integer.parseInt(current.substring(0,2));\\n        int y = Integer.parseInt(correct.substring(0,2));\\n\\n        int x1 = Integer.parseInt(current.substring(3));\\n        int x2 = Integer.parseInt(correct.substring(3));\\n\\n        int z = x2-x1;\\n        if(x2<x1){\\n            y=y-1;\\n            z = 60 - x1+x2;\\n        }\\n        int a = (z/15);\\n        int b = ((z-a*15)/5);\\n        int c = z-a*15-b*5;\\n\\n        return y-x+a+b+c;\\n    \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n    public int convertTime(String current, String correct) {\\n        int x = Integer.parseInt(current.substring(0,2));\\n        int y = Integer.parseInt(correct.substring(0,2));\\n\\n        int x1 = Integer.parseInt(current.substring(3));\\n        int x2 = Integer.parseInt(correct.substring(3));\\n\\n        int z = x2-x1;\\n        if(x2<x1){\\n            y=y-1;\\n            z = 60 - x1+x2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2703973,
                "title": "c-manual-code-100-faster",
                "content": "class Solution {\\npublic\\n\\n//we can also use substr() and stoi() functions here ,I have done that manually coz given string wasn\\'t so complex\\n\\n     int toMinute(string curr){\\n          int mi=0;  \\n        mi=mi+curr[0]-\\'0\\'; mi*=10;\\n        mi=mi+curr[1]-\\'0\\';\\n        mi*=60;\\n        int a=0;\\n        a=a+curr[3]-\\'0\\'; a*=10;\\n        a=a+curr[4]-\\'0\\';\\n        mi+=a;\\n        return mi;\\n    }\\n    int convertTime(string curr, string correct) {\\n      int a=toMinute(curr);\\n     int b=toMinute(correct);\\n        int count=0;\\n        while(a<b){\\n            if(b-a>=60){\\n                a+=60;\\n            }\\n            else  if(b-a>=15){\\n                a+=15;\\n            }\\n            else  if(b-a>=5){\\n                a+=5;\\n            }\\n            else {\\n                a+=1;\\n            }\\n           count++; \\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic\\n\\n//we can also use substr() and stoi() functions here ,I have done that manually coz given string wasn\\'t so complex\\n\\n     int toMinute(string curr){\\n          int mi=0;  \\n        mi=mi+curr[0]-\\'0\\'; mi*=10;\\n        mi=mi+curr[1]-\\'0\\';\\n        mi*=60;\\n        int a=0;\\n        a=a+curr[3]-\\'0\\'; a*=10;\\n        a=a+curr[4]-\\'0\\';\\n        mi+=a;\\n        return mi;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2636665,
                "title": "100-fast-convert-into-min",
                "content": "upvote\\n```\\n    int convertTime(string cur, string cor) {\\n        int curr = ((cur[0]-\\'0\\')*10+cur[1]-\\'0\\')*60+(cur[3]-\\'0\\')*10+cur[4]-\\'0\\';\\n        int corr = ((cor[0]-\\'0\\')*10+cor[1]-\\'0\\')*60+(cor[3]-\\'0\\')*10+cor[4]-\\'0\\';\\n        int ops =0, rem=corr-curr;\\n        while(rem>=60){\\n            rem -= 60;\\n            ops++;\\n        }\\n        while(rem>=15){\\n            rem -= 15;\\n            ops++;\\n        }\\n        while(rem>=5){\\n            rem -= 5;\\n            ops++;\\n        }\\n        while(rem>=1){\\n            rem -= 1;\\n            ops++;\\n        }\\n        \\n        return ops;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int convertTime(string cur, string cor) {\\n        int curr = ((cur[0]-\\'0\\')*10+cur[1]-\\'0\\')*60+(cur[3]-\\'0\\')*10+cur[4]-\\'0\\';\\n        int corr = ((cor[0]-\\'0\\')*10+cor[1]-\\'0\\')*60+(cor[3]-\\'0\\')*10+cor[4]-\\'0\\';\\n        int ops =0, rem=corr-curr;\\n        while(rem>=60){\\n            rem -= 60;\\n            ops++;\\n        }\\n        while(rem>=15){\\n            rem -= 15;\\n            ops++;\\n        }\\n        while(rem>=5){\\n            rem -= 5;\\n            ops++;\\n        }\\n        while(rem>=1){\\n            rem -= 1;\\n            ops++;\\n        }\\n        \\n        return ops;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2576476,
                "title": "easiest-shortest-simplest-c-solution",
                "content": "Convert the strings to int time in minutes and then find the difference. Apply simple maths!\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint convertTime(string current, string correct) {\\n\\t\\t\\tint ftime = (stoi(current.substr(0,2))) * 60 + (stoi(current.substr(3,current.size())));\\n\\t\\t\\tint ltime = (stoi(correct.substr(0,2))) * 60 + (stoi(correct.substr(3,correct.size())));\\n\\t\\t\\tint diff = ltime - ftime;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tans += diff/60;\\n\\t\\t\\tdiff = diff%60;\\n\\t\\t\\tans += diff/15;\\n\\t\\t\\tdiff = diff%15;\\n\\t\\t\\tans +=diff/5;\\n\\t\\t\\tdiff = diff%5;\\n\\t\\t\\tans += diff;\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint convertTime(string current, string correct) {\\n\\t\\t\\tint ftime = (stoi(current.substr(0,2))) * 60 + (stoi(current.substr(3,current.size())));\\n\\t\\t\\tint ltime = (stoi(correct.substr(0,2))) * 60 + (stoi(correct.substr(3,correct.size())));\\n\\t\\t\\tint diff = ltime - ftime;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tans += diff/60;\\n\\t\\t\\tdiff = diff%60;\\n\\t\\t\\tans += diff/15;\\n\\t\\t\\tdiff = diff%15;\\n\\t\\t\\tans +=diff/5;\\n\\t\\t\\tdiff = diff%5;\\n\\t\\t\\tans += diff;\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2445402,
                "title": "c-easily-understandable-brute-force-greedy",
                "content": "```\\nTime: O(Log minute)  Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int m1=10*(current[3]-\\'0\\')+(current[4]-\\'0\\'),\\n            m2=10*(correct[3]-\\'0\\')+(correct[4]-\\'0\\');\\n        int k=m2-m1;\\n        int h1=10*(current[0]-\\'0\\')+(current[1]-\\'0\\'),\\n            h2=10*(correct[0]-\\'0\\')+(correct[1]-\\'0\\');\\n        int k2=h2-h1;\\n        int tmin=k2*60+k;\\n        k=0;\\n        while(tmin){\\n            if(tmin>=60){\\n                k+=tmin/60;tmin%=60;\\n            }else if(tmin>=15)\\n                k+=tmin/15,tmin%=15;\\n            else if(tmin>=5)\\n                k+=tmin/5,tmin%=5;\\n            else\\n                k+=tmin/1,tmin%=1;\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nTime: O(Log minute)  Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int m1=10*(current[3]-\\'0\\')+(current[4]-\\'0\\'),\\n            m2=10*(correct[3]-\\'0\\')+(correct[4]-\\'0\\');\\n        int k=m2-m1;\\n        int h1=10*(current[0]-\\'0\\')+(current[1]-\\'0\\'),\\n            h2=10*(correct[0]-\\'0\\')+(correct[1]-\\'0\\');\\n        int k2=h2-h1;\\n        int tmin=k2*60+k;\\n        k=0;\\n        while(tmin){\\n            if(tmin>=60){\\n                k+=tmin/60;tmin%=60;\\n            }else if(tmin>=15)\\n                k+=tmin/15,tmin%=15;\\n            else if(tmin>=5)\\n                k+=tmin/5,tmin%=5;\\n            else\\n                k+=tmin/1,tmin%=1;\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2412947,
                "title": "100-faster-c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int hours1=stoi(current.substr(0,2));\\n        int hours2=stoi(correct.substr(0,2));\\n        int min1=stoi(current.substr(3,2));\\n        int min2=stoi(correct.substr(3,2));\\n        int mins=((60-min1)+(min2))<60?abs((hours2-hours1-1)*60)+((60-min1)+(min2)):abs((hours2-hours1)*60) + abs(min2-min1);\\n        int count=0;\\n        while(mins!=0){\\n            if(mins>=60){\\n                count++;mins-=60;\\n            }\\n            else if(mins>=15){\\n                count++;mins-=15;\\n            }\\n            else if(mins>=5){\\n                count++;mins-=5;\\n            }\\n            else if(mins>=1){\\n                count++;mins-=1;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/b615f4cb-50ff-4548-910e-aef09b4f7f28_1660251060.0716007.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int hours1=stoi(current.substr(0,2));\\n        int hours2=stoi(correct.substr(0,2));\\n        int min1=stoi(current.substr(3,2));\\n        int min2=stoi(correct.substr(3,2));\\n        int mins=((60-min1)+(min2))<60?abs((hours2-hours1-1)*60)+((60-min1)+(min2)):abs((hours2-hours1)*60) + abs(min2-min1);\\n        int count=0;\\n        while(mins!=0){\\n            if(mins>=60){\\n                count++;mins-=60;\\n            }\\n            else if(mins>=15){\\n                count++;mins-=15;\\n            }\\n            else if(mins>=5){\\n                count++;mins-=5;\\n            }\\n            else if(mins>=1){\\n                count++;mins-=1;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406772,
                "title": "c-0ms-and-java-1ms-easy-understanding",
                "content": "**C++ Solution**\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int ret=0, digit=1, cur=0, cor=0, hour=1, i;\\n        int t[] = {59,14,4,0};\\n        for(i = current.size()-1; i>-1; i--){\\n            if(58!=current[i]){\\n                cur += (current[i]-48)*digit*hour;\\n                cor += (correct[i]-48)*digit*hour;\\n                digit=10;\\n            }\\n            else {\\n                digit=1;\\n                hour=60;\\n            }\\n        }\\n        cor -= cur;\\n        i=0;\\n        while(cor>0){\\n            if(cor>t[i]){\\n                cor -= t[i]+1;\\n                ret++;\\n            }\\n            else i++;\\n        } \\n        return ret;\\n    }\\n};\\n```\\n**Java Solution**\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int ret=0, digit=1, cur=0, cor=0, hour=1, i;\\n        int[] t = {59,14,4,0};\\n        for(i = current.length()-1; i>-1; i--){\\n            if(58!=current.charAt(i)){\\n                cur += (current.charAt(i)-48)*digit*hour;\\n                cor += (correct.charAt(i)-48)*digit*hour;\\n                digit=10;\\n            }\\n            else {\\n                digit=1;\\n                hour=60;\\n            }\\n        }\\n        cor -= cur;\\n        i=0;\\n        while(cor>0){\\n            if(cor>t[i]){\\n                cor -= t[i]+1;\\n                ret++;\\n            }\\n            else i++;\\n        } \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int ret=0, digit=1, cur=0, cor=0, hour=1, i;\\n        int t[] = {59,14,4,0};\\n        for(i = current.size()-1; i>-1; i--){\\n            if(58!=current[i]){\\n                cur += (current[i]-48)*digit*hour;\\n                cor += (correct[i]-48)*digit*hour;\\n                digit=10;\\n            }\\n            else {\\n                digit=1;\\n                hour=60;\\n            }\\n        }\\n        cor -= cur;\\n        i=0;\\n        while(cor>0){\\n            if(cor>t[i]){\\n                cor -= t[i]+1;\\n                ret++;\\n            }\\n            else i++;\\n        } \\n        return ret;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int ret=0, digit=1, cur=0, cor=0, hour=1, i;\\n        int[] t = {59,14,4,0};\\n        for(i = current.length()-1; i>-1; i--){\\n            if(58!=current.charAt(i)){\\n                cur += (current.charAt(i)-48)*digit*hour;\\n                cor += (correct.charAt(i)-48)*digit*hour;\\n                digit=10;\\n            }\\n            else {\\n                digit=1;\\n                hour=60;\\n            }\\n        }\\n        cor -= cur;\\n        i=0;\\n        while(cor>0){\\n            if(cor>t[i]){\\n                cor -= t[i]+1;\\n                ret++;\\n            }\\n            else i++;\\n        } \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373684,
                "title": "easiest-java-solution-t-o-1-s-o-1",
                "content": "\\n\\n\\n```\\npublic int convertTime(String current, String correct) {\\n        String[] start = current.split(\":\");\\n        int startMins = Integer.valueOf(start[0])*60+Integer.valueOf(start[1]);\\n        \\n        String[] target = correct.split(\":\");\\n        int targetMins = Integer.valueOf(target[0])*60+Integer.valueOf(target[1]);\\n\\n        int diff = targetMins-startMins;\\n        int ops=0;\\n        \\n        ops += diff/60;    \\n        diff = diff%60;\\n\\n        ops += diff/15;\\n        diff = diff%15;\\n        \\n        ops += diff/5;\\n        diff = diff%5;\\n        \\n        return ops + diff;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int convertTime(String current, String correct) {\\n        String[] start = current.split(\":\");\\n        int startMins = Integer.valueOf(start[0])*60+Integer.valueOf(start[1]);\\n        \\n        String[] target = correct.split(\":\");\\n        int targetMins = Integer.valueOf(target[0])*60+Integer.valueOf(target[1]);\\n\\n        int diff = targetMins-startMins;\\n        int ops=0;\\n        \\n        ops += diff/60;    \\n        diff = diff%60;\\n\\n        ops += diff/15;\\n        diff = diff%15;\\n        \\n        ops += diff/5;\\n        diff = diff%5;\\n        \\n        return ops + diff;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2348431,
                "title": "greedy-100-faster-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int res=0;\\n        string ans=current.substr(0,2);\\n        string ans1=current.substr(3,5);\\n        int a1=stoi(ans)*60;\\n        int a2=stoi(ans1);\\n         string st=correct.substr(0,2);\\n        string st1=correct.substr(3,5);\\n        int b1=stoi(st)*60;\\n        int b2=stoi(st1);\\n        \\n        int ff=abs((a1+a2)-(b1+b2));\\n        int hours = ff/60;\\n        res+=hours;\\n        int minutes=ff%60;\\n        if(minutes % 15 ==0 ){\\n            res+=minutes/15;\\n            return res;\\n        }\\n        if(minutes > 15 ){\\n            res+=minutes/15;\\n            minutes = minutes%15;\\n        }\\n        \\n        if(minutes%5==0){\\n            res+=minutes/5;\\n            return res;\\n        }\\n        if(minutes > 5){\\n            res+=minutes/5;\\n            minutes=minutes%5;\\n        }\\n        res+=minutes;\\n        return res;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int res=0;\\n        string ans=current.substr(0,2);\\n        string ans1=current.substr(3,5);\\n        int a1=stoi(ans)*60;\\n        int a2=stoi(ans1);\\n         string st=correct.substr(0,2);\\n        string st1=correct.substr(3,5);\\n        int b1=stoi(st)*60;\\n        int b2=stoi(st1);\\n        \\n        int ff=abs((a1+a2)-(b1+b2));\\n        int hours = ff/60;\\n        res+=hours;\\n        int minutes=ff%60;\\n        if(minutes % 15 ==0 ){\\n            res+=minutes/15;\\n            return res;\\n        }\\n        if(minutes > 15 ){\\n            res+=minutes/15;\\n            minutes = minutes%15;\\n        }\\n        \\n        if(minutes%5==0){\\n            res+=minutes/5;\\n            return res;\\n        }\\n        if(minutes > 5){\\n            res+=minutes/5;\\n            minutes=minutes%5;\\n        }\\n        res+=minutes;\\n        return res;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2304608,
                "title": "leetcode-the-hard-way-greedy-explanation",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\nChoosing `60` 1 time is better than choosing `15` 4 times. We choose from the largest number as many times as we could, then choose the second largest and etc. Since the operation is on minute, we need to convert the input to minute format first. Then we calculate the difference and try each operation to see how many times we could apply and update the difference after each operation.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int getMinutes(string t) {\\n        int res = 0;\\n        // handle HH\\n        res += (t[0] - \\'0\\') * 10;\\n        res += (t[1] - \\'0\\');\\n        res *= 60;\\n        // handle MM\\n        res += (t[3] - \\'0\\') * 10;\\n        res += (t[4] - \\'0\\');\\n        return res;\\n    }\\n    \\n    int convertTime(string current, string correct) {\\n        // convert inputs to minute format\\n        int from = getMinutes(current), to = getMinutes(correct);\\n        // init ans & calculate the difference\\n        int ans = 0, d = to - from;\\n        // available operators - use largest one first\\n        vector<int> ops{ 60, 15, 5, 1 };\\n        // try each operation - take as many as possible\\n        // and update the difference\\n        for (auto x : ops) ans += d / x, d %= x;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int getMinutes(string t) {\\n        int res = 0;\\n        // handle HH\\n        res += (t[0] - \\'0\\') * 10;\\n        res += (t[1] - \\'0\\');\\n        res *= 60;\\n        // handle MM\\n        res += (t[3] - \\'0\\') * 10;\\n        res += (t[4] - \\'0\\');\\n        return res;\\n    }\\n    \\n    int convertTime(string current, string correct) {\\n        // convert inputs to minute format\\n        int from = getMinutes(current), to = getMinutes(correct);\\n        // init ans & calculate the difference\\n        int ans = 0, d = to - from;\\n        // available operators - use largest one first\\n        vector<int> ops{ 60, 15, 5, 1 };\\n        // try each operation - take as many as possible\\n        // and update the difference\\n        for (auto x : ops) ans += d / x, d %= x;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299755,
                "title": "java-difference-in-minutes",
                "content": "```\\npublic int convertTime(String current, String correct) {\\n        String[] currentTime = current.split(\":\");\\n        String[] correctTime = correct.split(\":\");\\n        \\n        int correctMin = Integer.parseInt(correctTime[0]) * 60 + Integer.parseInt(correctTime[1]);\\n        int currentMin = Integer.parseInt(currentTime[0]) * 60 + Integer.parseInt(currentTime[1]);\\n  \\n        int diff = correctMin - currentMin;\\n        int steps = 0;\\n        while(diff>0)\\n        {\\n            if(diff>=60)\\n            {\\n                diff -=60;\\n            }\\n            else if(diff>=15)\\n            {\\n                diff -=15;\\n            }\\n            else if (diff>=5)\\n            {\\n                diff -=5;\\n            }\\n            else if(diff>=1)\\n            {\\n                diff -=1;\\n            }\\n            steps++;\\n        }\\n\\n        return steps;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int convertTime(String current, String correct) {\\n        String[] currentTime = current.split(\":\");\\n        String[] correctTime = correct.split(\":\");\\n        \\n        int correctMin = Integer.parseInt(correctTime[0]) * 60 + Integer.parseInt(correctTime[1]);\\n        int currentMin = Integer.parseInt(currentTime[0]) * 60 + Integer.parseInt(currentTime[1]);\\n  \\n        int diff = correctMin - currentMin;\\n        int steps = 0;\\n        while(diff>0)\\n        {\\n            if(diff>=60)\\n            {\\n                diff -=60;\\n            }\\n            else if(diff>=15)\\n            {\\n                diff -=15;\\n            }\\n            else if (diff>=5)\\n            {\\n                diff -=5;\\n            }\\n            else if(diff>=1)\\n            {\\n                diff -=1;\\n            }\\n            steps++;\\n        }\\n\\n        return steps;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2250910,
                "title": "rust",
                "content": "```rust\\nimpl Solution {\\n    pub fn convert_time(current: String, correct: String) -> i32 {\\n        let current: Vec<_> = current.split(\":\").collect();\\n        let correct: Vec<_> = correct.split(\":\").collect();\\n        let start0: i32 = current[0].parse().unwrap();\\n        let start1: i32 = current[1].parse().unwrap();\\n        let end0: i32 = correct[0].parse().unwrap();\\n        let end1: i32 = correct[1].parse().unwrap();\\n\\n        let mut diff = (end0 - start0) * 60 + (end1 - start1);\\n        let mut cnt = 0;\\n        for n in vec![60, 15, 5, 1] {\\n            if diff >= n {\\n                cnt += diff / n;\\n                diff %= n\\n            }\\n        }\\n        cnt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn convert_time(current: String, correct: String) -> i32 {\\n        let current: Vec<_> = current.split(\":\").collect();\\n        let correct: Vec<_> = correct.split(\":\").collect();\\n        let start0: i32 = current[0].parse().unwrap();\\n        let start1: i32 = current[1].parse().unwrap();\\n        let end0: i32 = correct[0].parse().unwrap();\\n        let end1: i32 = correct[1].parse().unwrap();\\n\\n        let mut diff = (end0 - start0) * 60 + (end1 - start1);\\n        let mut cnt = 0;\\n        for n in vec![60, 15, 5, 1] {\\n            if diff >= n {\\n                cnt += diff / n;\\n                diff %= n\\n            }\\n        }\\n        cnt\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2203335,
                "title": "my-2ms-easy-to-understand-java-code",
                "content": "```\\nclass Solution \\n{\\n    public int convertTime(String current, String correct) \\n    {\\n        int cur_hou = Integer.parseInt(current.substring(0,2));\\n        int cur_min = Integer.parseInt(current.substring(3,5));\\n        int cur     = (cur_hou*60)+cur_min;     //150\\n        \\n        int cor_hou = Integer.parseInt(correct.substring(0,2));\\n        int cor_min = Integer.parseInt(correct.substring(3,5));\\n        int cor     = (cor_hou*60)+cor_min;     //275\\n        \\n        int differ  = cor-cur;  //125\\n        int no_of_ops=0;\\n        \\n        while(differ!=0)\\n        {\\n            if(differ>=60)\\n            {\\n                differ=differ-60;\\n                no_of_ops++;\\n            }\\n            else if(differ>=15)\\n            {\\n                differ-=15;\\n                no_of_ops++;\\n            }\\n            else if(differ>=5)\\n            {\\n                differ-=5;\\n                no_of_ops++;\\n            }\\n            else\\n            {\\n                differ-=1;\\n                no_of_ops++;\\n            }\\n        }\\n        \\n        return no_of_ops;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution \\n{\\n    public int convertTime(String current, String correct) \\n    {\\n        int cur_hou = Integer.parseInt(current.substring(0,2));\\n        int cur_min = Integer.parseInt(current.substring(3,5));\\n        int cur     = (cur_hou*60)+cur_min;     //150\\n        \\n        int cor_hou = Integer.parseInt(correct.substring(0,2));\\n        int cor_min = Integer.parseInt(correct.substring(3,5));\\n        int cor     = (cor_hou*60)+cor_min;     //275\\n        \\n        int differ  = cor-cur;  //125\\n        int no_of_ops=0;\\n        \\n        while(differ!=0)\\n        {\\n            if(differ>=60)\\n            {\\n                differ=differ-60;\\n                no_of_ops++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2109918,
                "title": "easy-python-solution",
                "content": "```\\ndef convertTime(self, current: str, correct: str) -> int:\\n        d=(int(correct[:2])*60+int(correct[3:]))-(int(current[:2])*60+int(current[3:]))\\n        return d//60+(d%60)//15+((d%60)%15)//5+((d%60)%15)%5\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef convertTime(self, current: str, correct: str) -> int:\\n        d=(int(correct[:2])*60+int(correct[3:]))-(int(current[:2])*60+int(current[3:]))\\n        return d//60+(d%60)//15+((d%60)%15)//5+((d%60)%15)%5\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2002717,
                "title": "why-greedy-works-here",
                "content": "I know there is papaer regarding cannonical sequence of numbers which can identify if a problem like this can be solved using Greedy way. https://arxiv.org/pdf/0809.0400.pdf\\nIs there any simple way to decide if we can use greedy way to solve this kind problem.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1977364,
                "title": "simple-python-solution-with-detailed-explanation-faster-than-99-easy-to-understand",
                "content": "```\\n\\n```class Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        \\n        newcu = current.split(\\':\\')      # extract hours and minutes from current and correct\\n        newco = correct.split(\\':\\')\\n        \\n        newcu = [int(x) for x in newcu]     # change string to integer\\n        newco = [int(x) for x in newco]\\n        \\n        newcu1 = newcu[0]*60 + newcu[1]     # change hours to minutes\\n        newco1 = newco[0]*60 + newco[1]\\n        \\n        diff = newco1 - newcu1      # get the difference between correct and current in minutes\\n        \\n        nums = diff//60 + diff%60//15 + diff%60%15//5 + diff%60%15%5        # divide by 60, then + remainder divide by 15, then + remainder divide by 5 then + remainder of 5\\n\\n        return nums",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1974552,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int curr=Integer.parseInt(current.substring(0,2))*60;\\n         curr+=Integer.parseInt(current.substring(3,5));\\n        \\n        int corr=Integer.parseInt(correct.substring(0,2))*60;\\n         corr+=Integer.parseInt(correct.substring(3,5));\\n\\n        corr=corr-curr;\\n        \\n        int res=0;\\n        res+=corr/60;\\n        corr=corr%60;\\n        \\n        res+=corr/15;\\n        corr=corr%15;\\n        \\n        res+=corr/5;\\n        corr=corr%5;\\n        \\n        res+=corr/1;\\n        \\n\\n        return res;\\n\\n        \\n        \\n        \\n        \\n \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int curr=Integer.parseInt(current.substring(0,2))*60;\\n         curr+=Integer.parseInt(current.substring(3,5));\\n        \\n        int corr=Integer.parseInt(correct.substring(0,2))*60;\\n         corr+=Integer.parseInt(correct.substring(3,5));\\n\\n        corr=corr-curr;\\n        \\n        int res=0;\\n        res+=corr/60;\\n        corr=corr%60;\\n        \\n        res+=corr/15;\\n        corr=corr%15;\\n        \\n        res+=corr/5;\\n        corr=corr%5;\\n        \\n        res+=corr/1;\\n        \\n\\n        return res;\\n\\n        \\n        \\n        \\n        \\n \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961744,
                "title": "python3-division-modulo",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/f2b4a5c0268eb27201b136764bb0b6ad3880c6f6) for solutions of weekly 287.\\n\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        fn = lambda x, y: 60*x + y\\n        m0 = fn(*map(int, current.split(\\':\\')))\\n        m1 = fn(*map(int, correct.split(\\':\\')))\\n        ans = 0 \\n        diff = m1 - m0 \\n        for x in 60, 15, 5, 1: \\n            ans += diff // x\\n            diff %= x\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        fn = lambda x, y: 60*x + y\\n        m0 = fn(*map(int, current.split(\\':\\')))\\n        m1 = fn(*map(int, correct.split(\\':\\')))\\n        ans = 0 \\n        diff = m1 - m0 \\n        for x in 60, 15, 5, 1: \\n            ans += diff // x\\n            diff %= x\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957609,
                "title": "python-coin-change-problem",
                "content": "\\n    def convertTime(self, current, correct):\\n        current = int(current.split(\":\")[0])*60 + int(current.split(\":\")[1])\\n        correct = int(correct.split(\":\")[0])*60 + int(correct.split(\":\")[1])\\n        \\n        amount, coins = correct - current, [1,5,15,60]\\n        \\n        dp = [float(\"inf\")]*(amount+1)\\n        \\n        dp[0] = 0\\n        \\n        for coin in coins:\\n            for i in range(coin, amount+1):\\n                dp[i] = min(dp[i], 1 + dp[i-coin])\\n                \\n        return dp[-1]",
                "solutionTags": [],
                "code": "\\n    def convertTime(self, current, correct):\\n        current = int(current.split(\":\")[0])*60 + int(current.split(\":\")[1])\\n        correct = int(correct.split(\":\")[0])*60 + int(correct.split(\":\")[1])\\n        \\n        amount, coins = correct - current, [1,5,15,60]\\n        \\n        dp = [float(\"inf\")]*(amount+1)\\n        \\n        dp[0] = 0\\n        \\n        for coin in coins:\\n            for i in range(coin, amount+1):\\n                dp[i] = min(dp[i], 1 + dp[i-coin])\\n                \\n        return dp[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 1948319,
                "title": "java-greedy-solution",
                "content": "```\\n// Greedy Solution\\n// Time complexity: O(1), O(T) where T is a constant\\n// Space complexity: O(1)\\nclass Solution {\\n    private static final int[] TIMES = {60, 15, 5, 1};\\n    \\n    public int convertTime(String current, String correct) {\\n        int t1 = Integer.parseInt(current.substring(0, 2)) * 60 + Integer.parseInt(current.substring(3));\\n        int t2 = Integer.parseInt(correct.substring(0, 2)) * 60 + Integer.parseInt(correct.substring(3));\\n        int ops = 0;\\n        for (int time : TIMES) {\\n            while (t1 + time <= t2) {\\n                t1 += time;\\n                ops++;\\n            }\\n        }\\n        return ops;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Greedy Solution\\n// Time complexity: O(1), O(T) where T is a constant\\n// Space complexity: O(1)\\nclass Solution {\\n    private static final int[] TIMES = {60, 15, 5, 1};\\n    \\n    public int convertTime(String current, String correct) {\\n        int t1 = Integer.parseInt(current.substring(0, 2)) * 60 + Integer.parseInt(current.substring(3));\\n        int t2 = Integer.parseInt(correct.substring(0, 2)) * 60 + Integer.parseInt(correct.substring(3));\\n        int ops = 0;\\n        for (int time : TIMES) {\\n            while (t1 + time <= t2) {\\n                t1 += time;\\n                ops++;\\n            }\\n        }\\n        return ops;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931298,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int sum=0;\\n        sum+=Integer.parseInt(correct.substring(0,2))-Integer.parseInt(current.substring(0,2));\\n        int min = Integer.parseInt(correct.substring(3,5))-Integer.parseInt(current.substring(3,5));\\n        if(min<0)\\n        {\\n           sum--;\\n           min+=60;\\n        }\\n        if(min>=15)\\n        {\\n            sum+=min/15;\\n            min-=15*(min/15);\\n        }\\n        if(min>=5)\\n        {\\n            sum+=min/5;\\n            min-=5*(min/5);\\n        }\\n        sum+=min;\\n         return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int convertTime(String current, String correct) {\\n        int sum=0;\\n        sum+=Integer.parseInt(correct.substring(0,2))-Integer.parseInt(current.substring(0,2));\\n        int min = Integer.parseInt(correct.substring(3,5))-Integer.parseInt(current.substring(3,5));\\n        if(min<0)\\n        {\\n           sum--;\\n           min+=60;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1930643,
                "title": "simple-javascript",
                "content": "```\\nconst convertTime = function(current, correct) {\\n    const [currentHH, currentMM] = current.split(\\':\\').map((val) => Number(val));\\n    const [correctHH, correctMM] = correct.split(\\':\\').map((val) => Number(val));\\n    \\n    let total = 0;\\n    \\n    total += correctHH - currentHH;\\n    \\n    let diff = correctMM - currentMM;\\n    \\n    // for negative where needed minutes are lower than the current minutes\\n    if (correctMM < currentMM) {\\n        total -= 1;\\n        diff += 60;\\n    }\\n\\n\\n    if (diff >= 15) {\\n        total += Math.floor(diff / 15);\\n        diff = diff % 15;\\n    }\\n\\n    if (diff >= 5) {\\n        total += Math.floor(diff / 5);\\n        diff = diff % 5;\\n    }\\n\\n    if (diff > 0) {\\n        total += diff;\\n    }\\n\\n    return total;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst convertTime = function(current, correct) {\\n    const [currentHH, currentMM] = current.split(\\':\\').map((val) => Number(val));\\n    const [correctHH, correctMM] = correct.split(\\':\\').map((val) => Number(val));\\n    \\n    let total = 0;\\n    \\n    total += correctHH - currentHH;\\n    \\n    let diff = correctMM - currentMM;\\n    \\n    // for negative where needed minutes are lower than the current minutes\\n    if (correctMM < currentMM) {\\n        total -= 1;\\n        diff += 60;\\n    }\\n\\n\\n    if (diff >= 15) {\\n        total += Math.floor(diff / 15);\\n        diff = diff % 15;\\n    }\\n\\n    if (diff >= 5) {\\n        total += Math.floor(diff / 5);\\n        diff = diff % 5;\\n    }\\n\\n    if (diff > 0) {\\n        total += diff;\\n    }\\n\\n    return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1929413,
                "title": "simple-greedy-solution-o-1-time",
                "content": "**In this problem greedy strategy worked because given values {60,15,5,1} are divisible with each other.**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int convertTime(string current, string correct)\\n    {\\n        // if current is same as correct we return 0\\n        if (current == correct)\\n            return 0;\\n\\n        // converting the string into int using stoi() function\\n        int h1, h2, m1, m2;\\n        h1 = stoi(current.substr(0, 2));\\n        h2 = stoi(correct.substr(0, 2));\\n        m1 = stoi(current.substr(3, 2));\\n        m2 = stoi(correct.substr(3, 2));\\n\\n        // storing the difference between current and correct\\n        int time = 0;\\n        time += (m2 - m1);\\n        time += (h2 - h1) * 60;\\n\\n        // using greedy method to find the minimum moves\\n        int ans = 0;\\n        ans += time / 60, time = time % 60;\\n        ans += time / 15, time = time % 15;\\n        ans += time / 5, time = time % 5;\\n        ans += time;\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n**Time Complexity: O(1)**\\n**Space Comlexity: O(1)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int convertTime(string current, string correct)\\n    {\\n        // if current is same as correct we return 0\\n        if (current == correct)\\n            return 0;\\n\\n        // converting the string into int using stoi() function\\n        int h1, h2, m1, m2;\\n        h1 = stoi(current.substr(0, 2));\\n        h2 = stoi(correct.substr(0, 2));\\n        m1 = stoi(current.substr(3, 2));\\n        m2 = stoi(correct.substr(3, 2));\\n\\n        // storing the difference between current and correct\\n        int time = 0;\\n        time += (m2 - m1);\\n        time += (h2 - h1) * 60;\\n\\n        // using greedy method to find the minimum moves\\n        int ans = 0;\\n        ans += time / 60, time = time % 60;\\n        ans += time / 15, time = time % 15;\\n        ans += time / 5, time = time % 5;\\n        ans += time;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929289,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int rem=time(correct)-time(current);\\n        int[] ops={60,15,5,1};\\n        \\n        int res=0;\\n        for(int op:ops){\\n            res+=rem/op;\\n            rem=rem%op;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int time(String time){\\n        int h=Integer.parseInt(time.split(\":\")[0]);\\n        int m=Integer.parseInt(time.split(\":\")[1]);\\n        \\n        return h*60+m;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int rem=time(correct)-time(current);\\n        int[] ops={60,15,5,1};\\n        \\n        int res=0;\\n        for(int op:ops){\\n            res+=rem/op;\\n            rem=rem%op;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int time(String time){\\n        int h=Integer.parseInt(time.split(\":\")[0]);\\n        int m=Integer.parseInt(time.split(\":\")[1]);\\n        \\n        return h*60+m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919358,
                "title": "java-o-1-simple-approach",
                "content": "```\\nclass Solution {\\n    public int convertTime(String c, String co) {\\n        String[] s1=c.split(\":\") ;\\n        String[] s2=co.split(\":\") ;\\n        int ct= Integer.parseInt(s1[0])*60 + Integer.parseInt(s1[1]);\\n        int rt= Integer.parseInt(s2[0])*60 + Integer.parseInt(s2[1]);\\n        // System.out.println(ct+\" \"+rt);\\n        int rem=rt-ct;ct=0;\\n        if(rem==0)\\n            return ct;\\n        ct+=rem/60;\\n        rem=rem%60;\\n        if(rem==0)\\n            return ct;\\n        ct+=rem/15;\\n        rem%=15;\\n        if(rem==0)\\n            return ct;\\n        ct+=rem/5;\\n        rem%=5;\\n        if(rem==0)\\n            return ct;\\n        ct+=rem/1;\\n        rem%=1;\\n        \\n        \\n        return ct;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String c, String co) {\\n        String[] s1=c.split(\":\") ;\\n        String[] s2=co.split(\":\") ;\\n        int ct= Integer.parseInt(s1[0])*60 + Integer.parseInt(s1[1]);\\n        int rt= Integer.parseInt(s2[0])*60 + Integer.parseInt(s2[1]);\\n        // System.out.println(ct+\" \"+rt);\\n        int rem=rt-ct;ct=0;\\n        if(rem==0)\\n            return ct;\\n        ct+=rem/60;\\n        rem=rem%60;\\n        if(rem==0)\\n            return ct;\\n        ct+=rem/15;\\n        rem%=15;\\n        if(rem==0)\\n            return ct;\\n        ct+=rem/5;\\n        rem%=5;\\n        if(rem==0)\\n            return ct;\\n        ct+=rem/1;\\n        rem%=1;\\n        \\n        \\n        return ct;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913661,
                "title": "python-simple-solution-easy-to-understand-begginners",
                "content": "```\\nclass Solution(object):\\n    def convertTime(self, current, correct):\\n        \"\"\"\\n        :type current: str\\n        :type correct: str\\n        :rtype: int\\n        \"\"\"\\n        l = current.split(\":\")\\n        m = correct.split(\":\")\\n        c = 0 \\n        c+=int(m[0])-int(l[0])\\n        x = int(m[1])-int(l[1])\\n        if int(m[1])<int(l[1]):\\n            c-=1\\n            x = int(m[1])\\n            x+=60-int(l[1])\\n        while x>0:\\n            if x>=15:\\n                c+=x//15 \\n                x=x%15 \\n\\n            elif x>=5:\\n                c+=x//5\\n                x = x%5\\n            else:\\n                c+=x \\n                x=0 \\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def convertTime(self, current, correct):\\n        \"\"\"\\n        :type current: str\\n        :type correct: str\\n        :rtype: int\\n        \"\"\"\\n        l = current.split(\":\")\\n        m = correct.split(\":\")\\n        c = 0 \\n        c+=int(m[0])-int(l[0])\\n        x = int(m[1])-int(l[1])\\n        if int(m[1])<int(l[1]):\\n            c-=1\\n            x = int(m[1])\\n            x+=60-int(l[1])\\n        while x>0:\\n            if x>=15:\\n                c+=x//15 \\n                x=x%15 \\n\\n            elif x>=5:\\n                c+=x//5\\n                x = x%5\\n            else:\\n                c+=x \\n                x=0 \\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913524,
                "title": "greedy-and-dp-solutions-in-python",
                "content": "\\n# \\t\\tdp \\n\\t\\t\\n\\t\\t@cache\\n        def solve(i,rem):\\n            if rem<0:\\n                return INF\\n            if i==N:\\n                if rem==0:\\n                    return 0\\n                return INF\\n            remcurrent=1+solve(i,rem-nums[i])\\n            othermove=solve(i+1,rem)\\n            return min(remcurrent,othermove)\\n        \\n        def f(value):\\n            hh,mm=[int(x) for x in value.split(\\':\\')]\\n            return hh*60+mm\\n        diff=f(correct)-f(current)\\n        nums=[60,15,5,1]\\n        INF=10**10\\n        N=4\\n        return solve(0,diff)\\n# \\t\\tgreedy\\n        \\n\\t\\t\\n        def f(value):\\n            hh,mm=[int(x) for x in value.split(\\':\\')]\\n            return hh*60+mm\\n\\t\\tdiff=f(correct)-f(current)\\n        cnt=0\\n        for i in [60,15,5,1]:\\n            cnt+=diff//i\\n            diff=diff%i\\n        return cnt\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "\\n# \\t\\tdp \\n\\t\\t\\n\\t\\t@cache\\n        def solve(i,rem):\\n            if rem<0:\\n                return INF\\n            if i==N:\\n                if rem==0:\\n                    return 0\\n                return INF\\n            remcurrent=1+solve(i,rem-nums[i])\\n            othermove=solve(i+1,rem)\\n            return min(remcurrent,othermove)\\n        \\n        def f(value):\\n            hh,mm=[int(x) for x in value.split(\\':\\')]\\n            return hh*60+mm\\n        diff=f(correct)-f(current)\\n        nums=[60,15,5,1]\\n        INF=10**10\\n        N=4\\n        return solve(0,diff)\\n# \\t\\tgreedy\\n        \\n\\t\\t\\n        def f(value):\\n            hh,mm=[int(x) for x in value.split(\\':\\')]\\n            return hh*60+mm\\n\\t\\tdiff=f(correct)-f(current)\\n        cnt=0\\n        for i in [60,15,5,1]:\\n            cnt+=diff//i\\n            diff=diff%i\\n        return cnt\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1911904,
                "title": "python-greed-towards-mins",
                "content": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        cur_hr,cur_min = map(int,current.split(\":\"))\\n        cor_hr,cor_min = map(int,correct.split(\":\"))\\n        \\n        cur_min = cur_min + cur_hr*60\\n        cor_min = cor_min + cor_hr*60\\n        \\n        req = abs(cur_min-cor_min)\\n        ans = 0\\n        \\n        for i in [60,15,5,1]:\\n            ans+= req//i\\n            req %= i\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        cur_hr,cur_min = map(int,current.split(\":\"))\\n        cor_hr,cor_min = map(int,correct.split(\":\"))\\n        \\n        cur_min = cur_min + cur_hr*60\\n        cor_min = cor_min + cor_hr*60\\n        \\n        req = abs(cur_min-cor_min)\\n        ans = 0\\n        \\n        for i in [60,15,5,1]:\\n            ans+= req//i\\n            req %= i\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911812,
                "title": "go-0-ms",
                "content": "```\\nfunc convertTime(current, correct string) (op int) {\\n    diff :=  minutesConversion(correct) - minutesConversion(current)\\n    for _, v := range []int{60, 15, 5, 1} {\\n            op += diff/v\\n            diff %= v\\n        }\\n    return\\n}\\n\\nfunc minutesConversion(s string) int {\\n    hours, _ := strconv.Atoi(s[:2])\\n    minutes, _ := strconv.Atoi(s[3:5])\\n    hours *= 60\\n    return hours+minutes\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc convertTime(current, correct string) (op int) {\\n    diff :=  minutesConversion(correct) - minutesConversion(current)\\n    for _, v := range []int{60, 15, 5, 1} {\\n            op += diff/v\\n            diff %= v\\n        }\\n    return\\n}\\n\\nfunc minutesConversion(s string) int {\\n    hours, _ := strconv.Atoi(s[:2])\\n    minutes, _ := strconv.Atoi(s[3:5])\\n    hours *= 60\\n    return hours+minutes\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1911381,
                "title": "java-beginner-friendly-greedy",
                "content": "This method involves converting the given time into mins. Then we find target = correct - correct. We run a loop to greedily make target as 0 using 60,15,5,1 subtractions. Here the order of subtractions is important as we want to get min operation count. I write a custom function toMins() which converts given time to mins of type int. I dont use split method or fancy java methods in conversion. \\nHere is the complete code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        //current<=correct -> correct-current\\n        int x = toMins(current);\\n        int y = toMins(correct);\\n        int target = y - x;\\n        int ops = 0;\\n        while(target>0) {\\n            if(target>=60)\\n                target = target - 60;\\n            else if(target>=15 && target<60)\\n                target = target - 15;\\n            else if(target>=5 && target<15)\\n                target = target - 5;\\n            else \\n                target = target - 1;\\n            ops++;\\n        }\\n        return ops;\\n        \\n    }\\n    private int toMins(String s) {\\n        int i = 0;\\n        while(s.charAt(i)!=\\':\\') {\\n            i++;\\n        }\\n        String hours = s.substring(0, i);\\n        String mins = s.substring(i+1, s.length());\\n        return Integer.valueOf(hours) * 60 + Integer.valueOf(mins);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        //current<=correct -> correct-current\\n        int x = toMins(current);\\n        int y = toMins(correct);\\n        int target = y - x;\\n        int ops = 0;\\n        while(target>0) {\\n            if(target>=60)\\n                target = target - 60;\\n            else if(target>=15 && target<60)\\n                target = target - 15;\\n            else if(target>=5 && target<15)\\n                target = target - 5;\\n            else \\n                target = target - 1;\\n            ops++;\\n        }\\n        return ops;\\n        \\n    }\\n    private int toMins(String s) {\\n        int i = 0;\\n        while(s.charAt(i)!=\\':\\') {\\n            i++;\\n        }\\n        String hours = s.substring(0, i);\\n        String mins = s.substring(i+1, s.length());\\n        return Integer.valueOf(hours) * 60 + Integer.valueOf(mins);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910984,
                "title": "pythontimeconverter-tc-o-1-sc-o-4",
                "content": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        currentTime = 60 * int(current[:2]) + int(current[3:]) # Current time in minute\\n        targetTime = 60 * int(correct[:2]) + int(correct[3:]) # Current time in minutes\\n        diff = targetTime - currentTime\\n        count = 0\\n        for i in [60, 15, 5, 1]:\\n            count += diff // i # add number of operations needed with i to count\\n            diff %= i #subtracting the i from diff after counting the steps\\n        return count\\n```\\nreference from\\n[https://leetcode.com/anCoderr/](http://)",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        currentTime = 60 * int(current[:2]) + int(current[3:]) # Current time in minute\\n        targetTime = 60 * int(correct[:2]) + int(correct[3:]) # Current time in minutes\\n        diff = targetTime - currentTime\\n        count = 0\\n        for i in [60, 15, 5, 1]:\\n            count += diff // i # add number of operations needed with i to count\\n            diff %= i #subtracting the i from diff after counting the steps\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909955,
                "title": "convert-everything-to-minutes",
                "content": "* Convert hours to minutes.\\n* Add minutes together and find difference.\\n* Calculate greedy answer.\\n\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        current = list(map(int, current.split(\\':\\')))\\n        correct = list(map(int, correct.split(\\':\\')))\\n        \\n        current = current[0] * 60 + current[1]\\n        correct = correct[0] * 60 + correct[1]\\n        \\n        diff = correct - current\\n        ans = 0\\n        for val in (60, 15, 5, 1):\\n            while diff >= val:\\n                ans += 1\\n                diff -= val\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        current = list(map(int, current.split(\\':\\')))\\n        correct = list(map(int, correct.split(\\':\\')))\\n        \\n        current = current[0] * 60 + current[1]\\n        correct = correct[0] * 60 + correct[1]\\n        \\n        diff = correct - current\\n        ans = 0\\n        for val in (60, 15, 5, 1):\\n            while diff >= val:\\n                ans += 1\\n                diff -= val\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909837,
                "title": "c-greedy",
                "content": "```\\n  \\n       int h1=(curr[1]-\\'0\\');\\n        h1=h1+ (curr[0]-\\'0\\')*10;\\n        \\n          int min1=(curr[4]-\\'0\\');\\n        min1=min1+ (curr[3]-\\'0\\')*10;\\n        \\n         int min2=(right[4]-\\'0\\');\\n        min2=min2+ (right[3]-\\'0\\')*10;\\n        \\n        int h2=(right[1]-\\'0\\');\\n        h2= h2 + (right[0]-\\'0\\')*10;\\n        \\n        int ans=0;\\n       int min;\\n        if(min2>=min1)\\n        {\\n            ans+=(h2-h1);\\n            min=min2-min1;\\n        }\\n        else\\n        {\\n            ans+=(h2-h1)-1;\\n            min=(min2-min1 + 60);\\n            \\n        }\\n        \\n        while(min!=0)\\n        {\\n           if(min>=15)\\n           {\\n               min-=15;\\n               ans++;\\n           }\\n            else\\n           {\\n              if(min<15 && min>=5)\\n              {\\n                  min-=5;\\n                  ans++;\\n              }\\n                else\\n                {\\n                    min-=1;\\n                    ans++;\\n                }\\n           }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n  \\n       int h1=(curr[1]-\\'0\\');\\n        h1=h1+ (curr[0]-\\'0\\')*10;\\n        \\n          int min1=(curr[4]-\\'0\\');\\n        min1=min1+ (curr[3]-\\'0\\')*10;\\n        \\n         int min2=(right[4]-\\'0\\');\\n        min2=min2+ (right[3]-\\'0\\')*10;\\n        \\n        int h2=(right[1]-\\'0\\');\\n        h2= h2 + (right[0]-\\'0\\')*10;\\n        \\n        int ans=0;\\n       int min;\\n        if(min2>=min1)\\n        {\\n            ans+=(h2-h1);\\n            min=min2-min1;\\n        }\\n        else\\n        {\\n            ans+=(h2-h1)-1;\\n            min=(min2-min1 + 60);\\n            \\n        }\\n        \\n        while(min!=0)\\n        {\\n           if(min>=15)\\n           {\\n               min-=15;\\n               ans++;\\n           }\\n            else\\n           {\\n              if(min<15 && min>=5)\\n              {\\n                  min-=5;\\n                  ans++;\\n              }\\n                else\\n                {\\n                    min-=1;\\n                    ans++;\\n                }\\n           }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909751,
                "title": "convert-to-minutes-short-and-clear",
                "content": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int start_min = ((current[0]-\\'0\\')*10+(current[1]-\\'0\\'))*60+(current[3]-\\'0\\')*10+(current[4]-\\'0\\');\\n        int end_min = ((correct[0]-\\'0\\')*10+(correct[1]-\\'0\\'))*60+(correct[3]-\\'0\\')*10+(correct[4]-\\'0\\');\\n        int diff = end_min-start_min, tot=0;\\n        for(auto x:{60,15,5,1})\\n        {\\n            tot+=diff/x;\\n            diff=max(0,diff-(diff/x)*x);\\n        }\\n        return tot;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int start_min = ((current[0]-\\'0\\')*10+(current[1]-\\'0\\'))*60+(current[3]-\\'0\\')*10+(current[4]-\\'0\\');\\n        int end_min = ((correct[0]-\\'0\\')*10+(correct[1]-\\'0\\'))*60+(correct[3]-\\'0\\')*10+(correct[4]-\\'0\\');\\n        int diff = end_min-start_min, tot=0;\\n        for(auto x:{60,15,5,1})\\n        {\\n            tot+=diff/x;\\n            diff=max(0,diff-(diff/x)*x);\\n        }\\n        return tot;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909748,
                "title": "c-easy-with-explanation",
                "content": "\\n    int convertTime(string current, string correct) {\\n        int ans = 0,currH=0,currM=0,finH=0,finM=0,diff_min,diff_hr;\\n        currH = stoi(current.substr(0,2)); // extracting the current hour\\n        currM = stoi(current.substr(3,2)); // extracting the current minute\\n        finH = stoi(correct.substr(0,2)); // extracting final/correct hour\\n        finM = stoi(correct.substr(3,2)); // extracting final/correct minute\\n        if(currM > finM){\\n            diff_min = 60 - abs(currM - finM);    // if curr minutes are more than calculating diff in minutes by moving 1 hour back\\n        }\\n        else{\\n            diff_min = abs(currM - finM);  // else normal diff\\n        }\\n        if(currM > finM) currH++; \\n        diff_hr = abs(currH - finH); \\n        while(diff_min){                               // calculating how much steps to make minutes correct\\n            if(diff_min >= 15) diff_min -= 15;\\n            else if(diff_min >= 5) diff_min -= 5;\\n            else diff_min -= 1;\\n            ans++;\\n        }\\n        \\n        while(diff_hr){ // calculating how much steps to make hour correct\\n            diff_hr -= 1;\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "\\n    int convertTime(string current, string correct) {\\n        int ans = 0,currH=0,currM=0,finH=0,finM=0,diff_min,diff_hr;\\n        currH = stoi(current.substr(0,2)); // extracting the current hour\\n        currM = stoi(current.substr(3,2)); // extracting the current minute\\n        finH = stoi(correct.substr(0,2)); // extracting final/correct hour\\n        finM = stoi(correct.substr(3,2)); // extracting final/correct minute\\n        if(currM > finM){\\n            diff_min = 60 - abs(currM - finM);    // if curr minutes are more than calculating diff in minutes by moving 1 hour back\\n        }\\n        else{\\n            diff_min = abs(currM - finM);  // else normal diff\\n        }\\n        if(currM > finM) currH++; \\n        diff_hr = abs(currH - finH); \\n        while(diff_min){                               // calculating how much steps to make minutes correct\\n            if(diff_min >= 15) diff_min -= 15;\\n            else if(diff_min >= 5) diff_min -= 5;\\n            else diff_min -= 1;\\n            ans++;\\n        }\\n        \\n        while(diff_hr){ // calculating how much steps to make hour correct\\n            diff_hr -= 1;\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909355,
                "title": "c-convert-to-minutes",
                "content": "```\\n* Convert to minutes and find the difference\\n* check for every minute and store in result\\n```\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tint get(string &s){\\n\\t\\t\\treturn stoi(s.substr(0,2))*60 + stoi(s.substr(3));\\n\\t\\t}\\n\\n\\t\\tint convertTime(string current, string correct) {\\n\\t\\t\\tint res = 0,diff = get(correct)-get(current);\\n\\t\\t\\tfor(auto num:{60,15,5,1}){\\n\\t\\t\\t\\tres+= diff/num;\\n\\t\\t\\t\\tdiff%=num;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "```\\n* Convert to minutes and find the difference\\n* check for every minute and store in result\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909213,
                "title": "easy-c-solution-converting-time-to-minutes",
                "content": "1. First Convert the time format to minutes\\n2. then try to minimize the no. of operations\\n\\n```\\nclass Solution {\\npublic:\\n    int removecol(string s)\\n    {\\n        if(s.size() == 4)\\n            s.replace(1,1,\"\");\\n        if(s.size() == 5)\\n            s.replace(2,1,\"\");\\n        \\n        return stoi(s);\\n    }\\n    int convertTime(string current, string correct) {\\n           \\n        int time1 = removecol(current);\\n        int time2 = removecol(correct);\\n        \\n        int min1 = (time1/100)*60 + time1%100;\\n        int min2 = (time2/100)*60 + time2%100;      \\n        \\n        int op = 0;\\n        \\n        vector<int> timarr = {60,15,5,1};\\n        int diff = min2 - min1;\\n        for(int i=0; i<timarr.size(); i++)\\n        {\\n            op += (diff) / timarr[i];\\n            diff = diff % timarr[i];\\n        }\\n        \\n        return op;\\n    }\\n};\\n```\\n\\nPLS UPVOTE ME!!!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removecol(string s)\\n    {\\n        if(s.size() == 4)\\n            s.replace(1,1,\"\");\\n        if(s.size() == 5)\\n            s.replace(2,1,\"\");\\n        \\n        return stoi(s);\\n    }\\n    int convertTime(string current, string correct) {\\n           \\n        int time1 = removecol(current);\\n        int time2 = removecol(correct);\\n        \\n        int min1 = (time1/100)*60 + time1%100;\\n        int min2 = (time2/100)*60 + time2%100;      \\n        \\n        int op = 0;\\n        \\n        vector<int> timarr = {60,15,5,1};\\n        int diff = min2 - min1;\\n        for(int i=0; i<timarr.size(); i++)\\n        {\\n            op += (diff) / timarr[i];\\n            diff = diff % timarr[i];\\n        }\\n        \\n        return op;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909194,
                "title": "2-lines-simple-solution-c-explanation",
                "content": "* No need to convert string characters to integer. Just subtract the corresponding pairs of digits\\n* Convert time into minutes\\n* Apply the operations using 60, 15, 5, 1 as described\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int n = ((correct[0]-current[0])*600) + ((correct[1]-current[1])*60) + ((correct[3]-current[3])*10) + correct[4]-current[4];\\n        return (n / 60) + (n % 60 / 15) + (n % 60 % 15 / 5) + (n % 60 % 15 % 5);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int n = ((correct[0]-current[0])*600) + ((correct[1]-current[1])*60) + ((correct[3]-current[3])*10) + correct[4]-current[4];\\n        return (n / 60) + (n % 60 / 15) + (n % 60 % 15 / 5) + (n % 60 % 15 % 5);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909126,
                "title": "python-easy-and-clear-solution",
                "content": "1. First we find difference between the hours and minutes as ```h``` and `m`\\n2. Convert the difference in hours to minutes by `h*60`, then add it with the `m`.\\n1. Use a counter variable, here taking it as `count=0` \\n1. Given we can add `60,15,5,1 `minutes in a a single step, so to find minimum no steps we check from 60 minutes then 15 then 5 and atlast 1 minute.\\n1. If the total difference in minutes is larger than 60, we add the quotient `dit//60` of to count to see how many 60 minutes we have added, and store the remainder in `dit` .\\n1. Ex: If we have 75, `75//60 =1 `, so count is increased by 1, then the remainder `15` is stored in dit.\\n1. if we have dit as 120, count would be increased by 2, since `120//60=2`.\\n1. Same happens for 15, 5 and 1 only the remaining minutes is passed through dit, thus minimizing no:of operations to convert.\\nLiked the Solution, Give a Upvote :)\\n```\\ndef convertTime(self, current: str, correct: str) -> int:\\n        if current==correct:\\n            return 0\\n        h=int(correct[:2])-int(current[:2])\\n        m=int(correct[3:])-int(current[3:])\\n        dit=h*60+m\\n        count=0\\n        if dit>=60:\\n            count+=dit//60\\n            dit=dit%60\\n        if dit>=15:\\n            count+=dit//15\\n            dit=dit%15   \\n        if dit>=5:\\n            count+=dit//5\\n            dit=dit%5    \\n        if dit>=1:\\n            count+=dit//1\\n            dit=dit%1    \\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```h```\n```\\ndef convertTime(self, current: str, correct: str) -> int:\\n        if current==correct:\\n            return 0\\n        h=int(correct[:2])-int(current[:2])\\n        m=int(correct[3:])-int(current[3:])\\n        dit=h*60+m\\n        count=0\\n        if dit>=60:\\n            count+=dit//60\\n            dit=dit%60\\n        if dit>=15:\\n            count+=dit//15\\n            dit=dit%15   \\n        if dit>=5:\\n            count+=dit//5\\n            dit=dit%5    \\n        if dit>=1:\\n            count+=dit//1\\n            dit=dit%1    \\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1909105,
                "title": "easy-python-two-lines",
                "content": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        final = (int(correct[0:2]) - int(current[0:2]))*60 + int(correct[3:]) - int(current[3:])\\n        return final//60 + (final%60)//15 + ((final%60)%15)//5 + (((final%60)%15)%5)//1\\n```\\n\\nBasically convert into minutes and count.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        final = (int(correct[0:2]) - int(current[0:2]))*60 + int(correct[3:]) - int(current[3:])\\n        return final//60 + (final%60)//15 + ((final%60)%15)//5 + (((final%60)%15)%5)//1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909032,
                "title": "easy-java-solution-by-converting-to-minutes-2ms-beats-100",
                "content": "Convert the time to minutes and then take the difference.\\nDivide difference starting with the highest increment and then take the mod of of difference by increment to find the next possible increase. \\n\\n```\\n    public static int convertTime(String current, String correct) {\\n        int currentMinute = Integer.parseInt(current.split(\":\")[0]) * 60 + Integer.parseInt(current.split(\":\")[1]);\\n        int correctMinute = Integer.parseInt(correct.split(\":\")[0]) * 60 + Integer.parseInt(correct.split(\":\")[1]);\\n        int diff = correctMinute - currentMinute;\\n        int count = 0;\\n        int[] increments = new int[]{60, 15, 5, 1};\\n\\n        for (int increment : increments){\\n            count += diff / increment;\\n            diff %= increment;\\n        }\\n        return count;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public static int convertTime(String current, String correct) {\\n        int currentMinute = Integer.parseInt(current.split(\":\")[0]) * 60 + Integer.parseInt(current.split(\":\")[1]);\\n        int correctMinute = Integer.parseInt(correct.split(\":\")[0]) * 60 + Integer.parseInt(correct.split(\":\")[1]);\\n        int diff = correctMinute - currentMinute;\\n        int count = 0;\\n        int[] increments = new int[]{60, 15, 5, 1};\\n\\n        for (int increment : increments){\\n            count += diff / increment;\\n            diff %= increment;\\n        }\\n        return count;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1908898,
                "title": "c-easy-minutes",
                "content": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int h1=(int)(current[0]*10+current[1]);\\n        int h2=(int)(correct[0]*10+correct[1]);\\n        int m1=(int)(current[3]*10+current[4]);\\n        int m2=(int)(correct[3]*10+correct[4]);\\n        \\n        int hour_diff=h2-h1-1;\\n        int min_diff=m2+(60-m1);\\n        \\n        if(min_diff>=60){\\n            hour_diff++;\\n            min_diff=min_diff-60;\\n        }\\n        \\n        if(hour_diff==0 && min_diff==0)return 0;\\n        \\n        int ans=0;\\n        if(hour_diff>0)\\n        {\\n            ans+=hour_diff; //add 60 minutes\\n        }\\n        while(min_diff!=0){\\n            if(min_diff-15>=0){\\n                ans++;\\n                min_diff-=15;\\n            }\\n            else if(min_diff-5>=0){\\n                ans++;\\n                min_diff-=5;\\n            }\\n            else if(min_diff-1>=0){\\n                ans++;\\n                min_diff-=1;\\n            }\\n        }        \\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nPlease let me know how to improve my solution.\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int h1=(int)(current[0]*10+current[1]);\\n        int h2=(int)(correct[0]*10+correct[1]);\\n        int m1=(int)(current[3]*10+current[4]);\\n        int m2=(int)(correct[3]*10+correct[4]);\\n        \\n        int hour_diff=h2-h1-1;\\n        int min_diff=m2+(60-m1);\\n        \\n        if(min_diff>=60){\\n            hour_diff++;\\n            min_diff=min_diff-60;\\n        }\\n        \\n        if(hour_diff==0 && min_diff==0)return 0;\\n        \\n        int ans=0;\\n        if(hour_diff>0)\\n        {\\n            ans+=hour_diff; //add 60 minutes\\n        }\\n        while(min_diff!=0){\\n            if(min_diff-15>=0){\\n                ans++;\\n                min_diff-=15;\\n            }\\n            else if(min_diff-5>=0){\\n                ans++;\\n                min_diff-=5;\\n            }\\n            else if(min_diff-1>=0){\\n                ans++;\\n                min_diff-=1;\\n            }\\n        }        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908869,
                "title": "convert-to-minutes-time-o-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int ch=0;\\n        int cm=0;\\n        int crh=0;\\n        int crm=0;\\n        int count=0;\\n        ch=stoi(current.substr(0,2));\\n        cm=stoi(current.substr(3,2));\\n        \\n        int csec=ch*60+cm;\\n        crh=stoi(correct.substr(0,2));\\n        crm=stoi(correct.substr(3,2));\\n        int crsec=crh*60+crm;\\n        \\n        int req=crsec-csec;\\n        if(req<0)\\n        {\\n            req+=60*24;\\n        }\\n       \\n        while(req>0)\\n        {\\n            if(req>=60)\\n            {\\n                int left=req%60;\\n                count+=req/60;\\n                req=left;\\n            }\\n            else if(req>=15)\\n            {\\n                int left=req%15;\\n                count+=req/15;\\n                req=left;\\n            }\\n            else if(req>=5)\\n            {\\n                int left=req%5;\\n                count+=req/5;\\n                req=left;\\n            }\\n            else if(req>=1)\\n            {   count+=req/1;\\n                req=0;\\n            }\\n        }\\n      return count;\\n        \\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int ch=0;\\n        int cm=0;\\n        int crh=0;\\n        int crm=0;\\n        int count=0;\\n        ch=stoi(current.substr(0,2));\\n        cm=stoi(current.substr(3,2));\\n        \\n        int csec=ch*60+cm;\\n        crh=stoi(correct.substr(0,2));\\n        crm=stoi(correct.substr(3,2));\\n        int crsec=crh*60+crm;\\n        \\n        int req=crsec-csec;\\n        if(req<0)\\n        {\\n            req+=60*24;\\n        }\\n       \\n        while(req>0)\\n        {\\n            if(req>=60)\\n            {\\n                int left=req%60;\\n                count+=req/60;\\n                req=left;\\n            }\\n            else if(req>=15)\\n            {\\n                int left=req%15;\\n                count+=req/15;\\n                req=left;\\n            }\\n            else if(req>=5)\\n            {\\n                int left=req%5;\\n                count+=req/5;\\n                req=left;\\n            }\\n            else if(req>=1)\\n            {   count+=req/1;\\n                req=0;\\n            }\\n        }\\n      return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908815,
                "title": "python-intuitive-easy-solution",
                "content": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        current = current.split(\\':\\')\\n        correct = correct.split(\\':\\')\\n        minute_diff = int(correct[1]) - int(current[1])\\n        ops = 0\\n        if minute_diff >= 0:\\n            ops += int(correct[0]) - int(current[0])\\n        else:\\n            ops += int(correct[0]) - int(current[0]) - 1\\n            minute_diff += 60\\n        ops += minute_diff // 15\\n        minute_diff = minute_diff % 15\\n        ops += minute_diff // 5\\n        minute_diff = minute_diff % 5\\n        ops += minute_diff\\n        return ops\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        current = current.split(\\':\\')\\n        correct = correct.split(\\':\\')\\n        minute_diff = int(correct[1]) - int(current[1])\\n        ops = 0\\n        if minute_diff >= 0:\\n            ops += int(correct[0]) - int(current[0])\\n        else:\\n            ops += int(correct[0]) - int(current[0]) - 1\\n            minute_diff += 60\\n        ops += minute_diff // 15\\n        minute_diff = minute_diff % 15\\n        ops += minute_diff // 5\\n        minute_diff = minute_diff % 5\\n        ops += minute_diff\\n        return ops\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908712,
                "title": "python-convert-to-minutes-and-reduce",
                "content": "```\\ndef convertTime(self, current: str, correct: str) -> int:\\n        x = int(current[:2]) * 60 + int(current[3:])\\n        y = int(correct[:2]) * 60 + int(correct[3:])\\n        res = 0\\n        diff = abs(x - y)\\n        while diff > 0:\\n            if diff >= 60:\\n                diff -= 60\\n            elif diff >= 15:\\n                diff -= 15\\n            elif diff >= 5:\\n                diff -= 5\\n            elif diff >= 1:\\n                diff -= 1\\n            res += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef convertTime(self, current: str, correct: str) -> int:\\n        x = int(current[:2]) * 60 + int(current[3:])\\n        y = int(correct[:2]) * 60 + int(correct[3:])\\n        res = 0\\n        diff = abs(x - y)\\n        while diff > 0:\\n            if diff >= 60:\\n                diff -= 60\\n            elif diff >= 15:\\n                diff -= 15\\n            elif diff >= 5:\\n                diff -= 5\\n            elif diff >= 1:\\n                diff -= 1\\n            res += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1908711,
                "title": "python-1-liner",
                "content": "Algorithm:\\n1. Split the strings at `:` and convert each element to `int()`.\\n2. If `correct` time minutes is `less` than `current` time minutes, `subtract 1` from `correct` time hours and `add 60` to `correct` time minutes.\\n3. return `difference` between the time hours `plus` the number of operation to make `correct` time minutes which can be calculated by `dividing` the difference in minutes by `15`, `5` and `1` respectively.\\n\\n```\\nclass Solution(object):\\n    def convertTime(self, cu, co):\\n        return ((lambda x : (x[2] - x[0])+ (x[3]-x[1])//15 + ((x[3]-x[1])%15)//5 + ((x[3]-x[1])%15)%5)((lambda a, b, c, d  : [a, b, c-1, d+60] if d < b else [a, b, c, d])(int(cu.split(\\':\\')[0]), int(cu.split(\\':\\')[1]),int(co.split(\\':\\')[0]), int(co.split(\\':\\')[1]))))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def convertTime(self, cu, co):\\n        return ((lambda x : (x[2] - x[0])+ (x[3]-x[1])//15 + ((x[3]-x[1])%15)//5 + ((x[3]-x[1])%15)%5)((lambda a, b, c, d  : [a, b, c-1, d+60] if d < b else [a, b, c, d])(int(cu.split(\\':\\')[0]), int(cu.split(\\':\\')[1]),int(co.split(\\':\\')[0]), int(co.split(\\':\\')[1]))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088043,
                "title": "greedy-approach-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int time=0, ans=0;\\n        int currentmins = current[3]*10 + current[4];\\n        int correctmins = correct[3]*10 + correct[4];\\n        int currenthours = current[0]*10 + current[1];\\n        int correcthours = correct[0]*10 + correct[1];\\n        int mindiff = 0, hourdiff = 0;\\n        if(correctmins < currentmins) \\n        {\\n            mindiff = (60-currentmins) + correctmins;\\n            hourdiff = abs(correcthours - currenthours-1);\\n        }\\n        else \\n        {\\n            mindiff = abs(correctmins - currentmins);\\n            hourdiff = abs(correcthours - currenthours);\\n        }\\n        time = mindiff + hourdiff*60;\\n        while(time != 0)\\n        {\\n            if(time>=60) time-=60;\\n            else if(time>=15) time-=15;\\n            else if(time>=5)  time-=5;\\n            else if(time>=1)  time-=1;\\n            ans++;\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int time=0, ans=0;\\n        int currentmins = current[3]*10 + current[4];\\n        int correctmins = correct[3]*10 + correct[4];\\n        int currenthours = current[0]*10 + current[1];\\n        int correcthours = correct[0]*10 + correct[1];\\n        int mindiff = 0, hourdiff = 0;\\n        if(correctmins < currentmins) \\n        {\\n            mindiff = (60-currentmins) + correctmins;\\n            hourdiff = abs(correcthours - currenthours-1);\\n        }\\n        else \\n        {\\n            mindiff = abs(correctmins - currentmins);\\n            hourdiff = abs(correcthours - currenthours);\\n        }\\n        time = mindiff + hourdiff*60;\\n        while(time != 0)\\n        {\\n            if(time>=60) time-=60;\\n            else if(time>=15) time-=15;\\n            else if(time>=5)  time-=5;\\n            else if(time>=1)  time-=1;\\n            ans++;\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087907,
                "title": "short-and-simple-convert-to-minutes",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nvar convertTime = function(current, correct) {\\n    const steps = [60, 15, 5, 1];\\n    const currentTimeInMinutes = convertToMinutes(current);\\n    const correctTimeInMinutes = convertToMinutes(correct);\\n    let diff = correctTimeInMinutes - currentTimeInMinutes;\\n    let operationsCount = 0;\\n\\n    for (const step of steps) {\\n        const currentStepsCount = Math.floor(diff / step);\\n        operationsCount += currentStepsCount;\\n        diff -= currentStepsCount * step;\\n        if (diff === 0) break;\\n    }\\n    return operationsCount;\\n};\\n\\nfunction convertToMinutes(time) {\\n    const [hours, minutes] = Array.from(time.split(\\':\\'), Number);\\n    return hours * 60 + minutes;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar convertTime = function(current, correct) {\\n    const steps = [60, 15, 5, 1];\\n    const currentTimeInMinutes = convertToMinutes(current);\\n    const correctTimeInMinutes = convertToMinutes(correct);\\n    let diff = correctTimeInMinutes - currentTimeInMinutes;\\n    let operationsCount = 0;\\n\\n    for (const step of steps) {\\n        const currentStepsCount = Math.floor(diff / step);\\n        operationsCount += currentStepsCount;\\n        diff -= currentStepsCount * step;\\n        if (diff === 0) break;\\n    }\\n    return operationsCount;\\n};\\n\\nfunction convertToMinutes(time) {\\n    const [hours, minutes] = Array.from(time.split(\\':\\'), Number);\\n    return hours * 60 + minutes;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4080932,
                "title": "simple-and-easy-java-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int curH = (current.charAt(0)-\\'0\\')*10 +current.charAt(1)-\\'0\\';\\n        int corH = (correct.charAt(0)-\\'0\\')*10 +correct.charAt(1)-\\'0\\';\\n        int curM = (current.charAt(3)-\\'0\\')*10 +current.charAt(4)-\\'0\\';\\n        int corM = (correct.charAt(3)-\\'0\\')*10 +correct.charAt(4)-\\'0\\';\\n\\n        int curr = curH*60 + curM;\\n        int corr = corH*60 + corM;\\n        int diff = Math.abs(curr-corr);\\n        int ans=0;\\n\\n        while( diff != 0){\\n            if(diff -60 >= 0) diff -=60;\\n            else if(diff -15 >= 0) diff -=15;\\n            else if(diff -5 >= 0) diff -=5;\\n            else diff--; \\n            ans++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int curH = (current.charAt(0)-\\'0\\')*10 +current.charAt(1)-\\'0\\';\\n        int corH = (correct.charAt(0)-\\'0\\')*10 +correct.charAt(1)-\\'0\\';\\n        int curM = (current.charAt(3)-\\'0\\')*10 +current.charAt(4)-\\'0\\';\\n        int corM = (correct.charAt(3)-\\'0\\')*10 +correct.charAt(4)-\\'0\\';\\n\\n        int curr = curH*60 + curM;\\n        int corr = corH*60 + corM;\\n        int diff = Math.abs(curr-corr);\\n        int ans=0;\\n\\n        while( diff != 0){\\n            if(diff -60 >= 0) diff -=60;\\n            else if(diff -15 >= 0) diff -=15;\\n            else if(diff -5 >= 0) diff -=5;\\n            else diff--; \\n            ans++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075160,
                "title": "2224",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        String[] c1 = current.split(\":\");\\n        String[] c2 = correct.split(\":\");\\n        int h1 = Integer.valueOf(c1[0])*60+Integer.valueOf(c1[1]);\\n        int h2 = Integer.valueOf(c2[0])*60+Integer.valueOf(c2[1]);\\n        int m = Math.abs(h1-h2);\\n        int count =0;\\n        int time;\\n        if(m>=60){\\n            time = m/60;\\n            count += time;                \\n            m %= 60;\\n        }\\n        if(m>=15){\\n            time = m/15;\\n            count += time;\\n            m %= 15;\\n        }\\n        if(m>=5){\\n            time = m/5;\\n            count += time;\\n            m %= 5;\\n        }\\n        if(m>=1){\\n            count += m;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        String[] c1 = current.split(\":\");\\n        String[] c2 = correct.split(\":\");\\n        int h1 = Integer.valueOf(c1[0])*60+Integer.valueOf(c1[1]);\\n        int h2 = Integer.valueOf(c2[0])*60+Integer.valueOf(c2[1]);\\n        int m = Math.abs(h1-h2);\\n        int count =0;\\n        int time;\\n        if(m>=60){\\n            time = m/60;\\n            count += time;                \\n            m %= 60;\\n        }\\n        if(m>=15){\\n            time = m/15;\\n            count += time;\\n            m %= 15;\\n        }\\n        if(m>=5){\\n            time = m/5;\\n            count += time;\\n            m %= 5;\\n        }\\n        if(m>=1){\\n            count += m;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074611,
                "title": "simple-greedy-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nconst increases = [60,15,5,1]\\nvar convertTime = function(current, correct) {\\n  const [h1,m1] = current.split(\":\").map(Number)\\n  const [h2,m2] = correct.split(\":\").map(Number)\\n  let dif = (h2-h1) * 60 + m2 - m1\\n  let count = 0\\n  while(dif){\\n    for(let i = 0; i < increases.length; i++){\\n      if(dif - increases[i] >= 0){\\n        dif -=  increases[i];\\n        break;\\n      }\\n    }\\n    count++\\n  }\\n  return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nconst increases = [60,15,5,1]\\nvar convertTime = function(current, correct) {\\n  const [h1,m1] = current.split(\":\").map(Number)\\n  const [h2,m2] = correct.split(\":\").map(Number)\\n  let dif = (h2-h1) * 60 + m2 - m1\\n  let count = 0\\n  while(dif){\\n    for(let i = 0; i < increases.length; i++){\\n      if(dif - increases[i] >= 0){\\n        dif -=  increases[i];\\n        break;\\n      }\\n    }\\n    count++\\n  }\\n  return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4043783,
                "title": "java-fastest-1ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int h1 = Integer.parseInt(current.substring(0, 2));\\n        int h2 = Integer.parseInt(correct.substring(0, 2));\\n        \\n        int m1 = Integer.parseInt(current.substring(3, 5));\\n        int m2 = Integer.parseInt(correct.substring(3, 5));\\n        \\n       \\n        int hm = (h2 - h1)*60;\\n        int m = m2 - m1;\\n      \\n        int c = 0;\\n        int cnt = 0;\\n\\n        if(m2 < m1){\\n            hm = hm - 60;\\n            m = m + 60;\\n        }\\n\\n        if(m >= 60 || hm >= 60){\\n            c = m/60;\\n            m = m - c*60;\\n            cnt += c;\\n\\n            c = hm/60;\\n            hm = hm - c*60;\\n            cnt+=c;\\n        }\\n        \\n        if(m >= 15){\\n            c = m/15;\\n            m = m - c*15;\\n            cnt += c;\\n        }\\n\\n        if(m >= 5){\\n            c = m/5;\\n            m = m-c*5;\\n            cnt += c;\\n        }\\n\\n        cnt += m;\\n       \\n\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int h1 = Integer.parseInt(current.substring(0, 2));\\n        int h2 = Integer.parseInt(correct.substring(0, 2));\\n        \\n        int m1 = Integer.parseInt(current.substring(3, 5));\\n        int m2 = Integer.parseInt(correct.substring(3, 5));\\n        \\n       \\n        int hm = (h2 - h1)*60;\\n        int m = m2 - m1;\\n      \\n        int c = 0;\\n        int cnt = 0;\\n\\n        if(m2 < m1){\\n            hm = hm - 60;\\n            m = m + 60;\\n        }\\n\\n        if(m >= 60 || hm >= 60){\\n            c = m/60;\\n            m = m - c*60;\\n            cnt += c;\\n\\n            c = hm/60;\\n            hm = hm - c*60;\\n            cnt+=c;\\n        }\\n        \\n        if(m >= 15){\\n            c = m/15;\\n            m = m - c*15;\\n            cnt += c;\\n        }\\n\\n        if(m >= 5){\\n            c = m/5;\\n            m = m-c*5;\\n            cnt += c;\\n        }\\n\\n        cnt += m;\\n       \\n\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040106,
                "title": "simple-solution-in-c-greedy-appraoch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst we calculate the time into only minutes so the on subtracted the time we dont get any error.Then we got difference of time(min)that we have to coverd into minimum usage of {60,15,5,1}. As we clearly see by using these we can make any number so we have to tell what minimum usage of number to attain the difference. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int h(string s){\\n        return stoi(s.substr(0,2))*60+stoi(s.substr(3,5));\\n    }\\n    int convertTime(string current, string correct) {\\n        int ans=0;\\n        int d=h(correct)-h(current);\\n        vector<int> nums={60,15,5,1};\\n        for(int i=0;i<4;i++){\\n            ans+=(d/nums[i]);\\n            d=d%nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int h(string s){\\n        return stoi(s.substr(0,2))*60+stoi(s.substr(3,5));\\n    }\\n    int convertTime(string current, string correct) {\\n        int ans=0;\\n        int d=h(correct)-h(current);\\n        vector<int> nums={60,15,5,1};\\n        for(int i=0;i<4;i++){\\n            ans+=(d/nums[i]);\\n            d=d%nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031176,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        def toMinutes(s):\\n            h,m = s.split(\":\")\\n            return 60*(int(h)) + int(m)\\n        \\n        n = toMinutes(correct) - toMinutes(current)\\n\\n        ops = 0\\n        while n > 0:\\n            if n >= 60:\\n                n -= 60\\n                ops += 1\\n            elif n >= 15:\\n                n -= 15\\n                ops += 1\\n            elif n >= 5:\\n                n -= 5\\n                ops += 1\\n            elif n >= 1:\\n                n -= 1\\n                ops += 1\\n\\n        return ops\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        def toMinutes(s):\\n            h,m = s.split(\":\")\\n            return 60*(int(h)) + int(m)\\n        \\n        n = toMinutes(correct) - toMinutes(current)\\n\\n        ops = 0\\n        while n > 0:\\n            if n >= 60:\\n                n -= 60\\n                ops += 1\\n            elif n >= 15:\\n                n -= 15\\n                ops += 1\\n            elif n >= 5:\\n                n -= 5\\n                ops += 1\\n            elif n >= 1:\\n                n -= 1\\n                ops += 1\\n\\n        return ops\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025761,
                "title": "python-two-approaches-time-logic-convert-into-minutes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute Force and Convert to Minutes\\n\\n# Approach - 1\\n<!-- Describe your approach to solving the problem. -->\\nFind the difference b/w hours and minutes if minutes difference is less than 0 then reduce the hours diff by 1.\\nno.of sixty minutes used is the hrs diff and calculate 15 mins, 5 mins, 1 mins using divide and modulo\\n\\n# Code\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        h1, m1 = current.split(\\':\\')\\n        h2, m2 = correct.split(\\':\\')\\n        h = int(h2) - int(h1)\\n        m = int(m2) - int(m1)\\n        if m < 0:\\n            h -= 1\\n            m += 60\\n        for i in [15,5,1]:\\n            h += m//i\\n            m %= i\\n        return h \\n```\\n\\n\\n# Approach - 2\\n<!-- Describe your approach to solving the problem. -->\\nConvert the given time into minutes and find the difference and count the 60 mins 15 mins 5 mins 1 mins used using divide and modulo method.\\n\\n# Code\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        h1, m1 = current.split(\\':\\')\\n        h2, m2 = correct.split(\\':\\')\\n        time_diff=((60*int(h2))+int(m2))-((60*int(h1))+int(m1))\\n        ans=0;time=[60,15,5,1]\\n        for i in time:\\n            ans += time_diff // i \\n            time_diff %= i\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        h1, m1 = current.split(\\':\\')\\n        h2, m2 = correct.split(\\':\\')\\n        h = int(h2) - int(h1)\\n        m = int(m2) - int(m1)\\n        if m < 0:\\n            h -= 1\\n            m += 60\\n        for i in [15,5,1]:\\n            h += m//i\\n            m %= i\\n        return h \\n```\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        h1, m1 = current.split(\\':\\')\\n        h2, m2 = correct.split(\\':\\')\\n        time_diff=((60*int(h2))+int(m2))-((60*int(h1))+int(m1))\\n        ans=0;time=[60,15,5,1]\\n        for i in time:\\n            ans += time_diff // i \\n            time_diff %= i\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023722,
                "title": "easy-javascript-solution-with-line-by-line-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nvar convertTime = function (current, correct) {\\n\\n    // if string current is equal to string correct then return zero\\n    if (current === correct) return 0;\\n\\n    // initialize count to zero\\n    let count = 0;\\n\\n    // find total minutes from string current time using parsInt() and slice()\\n    let currentInMins = parseInt(current.slice(3)) + parseInt(current.slice(0, 2)) * 60;\\n\\n    // find total minutes from string correct time using parsInt() and slice()\\n    let correcttInMins = parseInt(correct.slice(3)) + parseInt(correct.slice(0, 2)) * 60;\\n\\n    // find minute Difference of correcttInMins and currentInMins\\n    let minuteDifference = correcttInMins - currentInMins;\\n\\n\\n    // while minuteDifference is not equal to zero then continue the loop\\n    while (minuteDifference !== 0) {\\n\\n        // if minuteDifference divide by 60\\n        if (minuteDifference % 60 === 0) {\\n\\n            // find minuteDiffCount by dividing minuteDifference to 60\\n            let minuteDiffCount = parseInt(minuteDifference / 60);\\n\\n            // subtract minuteDifference by multiplying minuteDiffCount\\n            minuteDifference -= (minuteDiffCount * 60);\\n\\n            // add minuteDifference to count\\n            count += minuteDiffCount;\\n\\n        } // else if minuteDifference divide by 15\\n        else if (minuteDifference % 15 === 0) {\\n\\n            // subtract minuteDifference by 15\\n            minuteDifference -= 15;\\n\\n            // increment the count\\n            count++;\\n\\n        } // else if minuteDifference divide by 5\\n        else if (minuteDifference % 5 === 0) {\\n\\n            // subtract minuteDifference by 5\\n            minuteDifference -= 5;\\n\\n            // increment the count\\n            count++;\\n\\n        } // else\\n        else {\\n\\n            // subtract minuteDifference by 1\\n            minuteDifference -= 1;\\n\\n            // increment the count\\n            count++;\\n        }\\n    }\\n\\n    // return the count\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nvar convertTime = function (current, correct) {\\n\\n    // if string current is equal to string correct then return zero\\n    if (current === correct) return 0;\\n\\n    // initialize count to zero\\n    let count = 0;\\n\\n    // find total minutes from string current time using parsInt() and slice()\\n    let currentInMins = parseInt(current.slice(3)) + parseInt(current.slice(0, 2)) * 60;\\n\\n    // find total minutes from string correct time using parsInt() and slice()\\n    let correcttInMins = parseInt(correct.slice(3)) + parseInt(correct.slice(0, 2)) * 60;\\n\\n    // find minute Difference of correcttInMins and currentInMins\\n    let minuteDifference = correcttInMins - currentInMins;\\n\\n\\n    // while minuteDifference is not equal to zero then continue the loop\\n    while (minuteDifference !== 0) {\\n\\n        // if minuteDifference divide by 60\\n        if (minuteDifference % 60 === 0) {\\n\\n            // find minuteDiffCount by dividing minuteDifference to 60\\n            let minuteDiffCount = parseInt(minuteDifference / 60);\\n\\n            // subtract minuteDifference by multiplying minuteDiffCount\\n            minuteDifference -= (minuteDiffCount * 60);\\n\\n            // add minuteDifference to count\\n            count += minuteDiffCount;\\n\\n        } // else if minuteDifference divide by 15\\n        else if (minuteDifference % 15 === 0) {\\n\\n            // subtract minuteDifference by 15\\n            minuteDifference -= 15;\\n\\n            // increment the count\\n            count++;\\n\\n        } // else if minuteDifference divide by 5\\n        else if (minuteDifference % 5 === 0) {\\n\\n            // subtract minuteDifference by 5\\n            minuteDifference -= 5;\\n\\n            // increment the count\\n            count++;\\n\\n        } // else\\n        else {\\n\\n            // subtract minuteDifference by 1\\n            minuteDifference -= 1;\\n\\n            // increment the count\\n            count++;\\n        }\\n    }\\n\\n    // return the count\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4006367,
                "title": "super-simple-solution-sss",
                "content": "Thanks for reading :)\\n# Code\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        sum_cur, sum_cor, ans = 0, 0, 0\\n        time_ = [60, 15, 5, 1]\\n        cur_split = current.split(\\':\\')\\n        cor_split = correct.split(\\':\\')\\n        for i, v in enumerate(zip(cur_split, cor_split)):\\n            if i == 0:\\n                sum_cur = time_[0] * int(v[0])\\n                sum_cor = time_[0] * int(v[1])\\n            if i == 1:\\n                sum_cur += int(v[0])\\n                sum_cor += int(v[1])\\n        diff_t = sum_cor - sum_cur\\n        for i in time_:\\n            ans += diff_t // i\\n            diff_t -= i * (diff_t // i)\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        sum_cur, sum_cor, ans = 0, 0, 0\\n        time_ = [60, 15, 5, 1]\\n        cur_split = current.split(\\':\\')\\n        cor_split = correct.split(\\':\\')\\n        for i, v in enumerate(zip(cur_split, cor_split)):\\n            if i == 0:\\n                sum_cur = time_[0] * int(v[0])\\n                sum_cor = time_[0] * int(v[1])\\n            if i == 1:\\n                sum_cur += int(v[0])\\n                sum_cor += int(v[1])\\n        diff_t = sum_cor - sum_cur\\n        for i in time_:\\n            ans += diff_t // i\\n            diff_t -= i * (diff_t // i)\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996539,
                "title": "three-different-python-solutions",
                "content": "# Intuition\\n\\nNotice that this is identical to the [Coin Change](https://leetcode.com/problems/coin-change/) problem (LeetCode #322) where we need to make up `target_mins` (the time difference) from the given selection of \"coins\" (the list `[1, 5, 15, 60]`). However, note that in this case, a greedy solution will work because every item in the list is larger than the sum of all smaller items.\\n\\n# Method 1 - Greedy Solution\\n\\nFast and efficient for this problem, but not easily generalisable\\n\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        # greedy solution: correct >= current\\n        current_hrs, current_mins = map(int, current.split(\\':\\'))\\n        correct_hrs, correct_mins = map(int, correct.split(\\':\\'))\\n        target_mins = (correct_hrs - current_hrs) * 60 + (correct_mins - current_mins)\\n        return target_mins // 60 + (target_mins % 60) // 15 + (target_mins % 60 % 15) // 5 + \\\\\\n            (target_mins % 60 % 15 % 5)\\n```\\n\\nThis can be written in a more general way like this:\\n\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n\\n        import functools\\n\\n        # greedy solution: correct >= current\\n        current_hrs, current_mins = map(int, current.split(\\':\\'))\\n        correct_hrs, correct_mins = map(int, correct.split(\\':\\'))\\n        target_mins = (correct_hrs - current_hrs) * 60 + (correct_mins - current_mins)\\n\\n        choices = [60, 15, 5, 1]\\n\\n        rems = [functools.reduce(lambda a, b: a % b, [target_mins] + choices[:i]) \\\\\\n            for i in range(len(choices))]\\n\\n        return sum(rems[i] // choices[i] for i in range(len(choices)))\\n```\\n\\n# Method 2 - Recursion\\n\\nFast but less intuitive\\n\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str, memo: dict = {}) -> int:\\n        current_hrs, current_mins = map(int, current.split(\\':\\'))\\n        correct_hrs, correct_mins = map(int, correct.split(\\':\\'))\\n        target_mins = (correct_hrs - current_hrs) * 60 + (correct_mins - current_mins)\\n        choices = [1, 5, 15, 60]\\n        return self.solveRecursively(target_mins, choices)\\n    \\n    def solveRecursively(self, amount: int, choices: list, memo: dict = {}) -> int:\\n        if amount < 0: # amount cannot be made - set to negative to fail check\\n            return -1\\n        if amount == 0: # base case\\n            return 0\\n        if amount in memo:\\n            return memo[amount] \\n        \\n        min_count = float(\\'inf\\')\\n        for c in choices:\\n            if 0 <= (f := self.solveRecursively(amount - c, choices, memo)) < min_count:\\n                min_count = 1 + f\\n        memo[amount] = min_count if min_count != float(\\'inf\\') else -1\\n        return memo[amount]\\n```\\n\\n# Method 3 - Dynamic Programming\\n\\nSlowest, but most easily generalisable to harder problems.\\n\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str, memo: dict = {}) -> int:\\n        current_hrs, current_mins = map(int, current.split(\\':\\'))\\n        correct_hrs, correct_mins = map(int, correct.split(\\':\\'))\\n        target_mins = (correct_hrs - current_hrs) * 60 + (correct_mins - current_mins)\\n        choices = [1, 5, 15, 60]\\n        dp = {0: 0}  # base case\\n        for a in range(1, target_mins + 1):\\n            dp[a] = min(1 + dp.get(a - c, float(\\'inf\\')) for c in choices)\\n        \\n        return dp[target_mins] if dp[target_mins] is not float(\\'inf\\') else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        # greedy solution: correct >= current\\n        current_hrs, current_mins = map(int, current.split(\\':\\'))\\n        correct_hrs, correct_mins = map(int, correct.split(\\':\\'))\\n        target_mins = (correct_hrs - current_hrs) * 60 + (correct_mins - current_mins)\\n        return target_mins // 60 + (target_mins % 60) // 15 + (target_mins % 60 % 15) // 5 + \\\\\\n            (target_mins % 60 % 15 % 5)\\n```\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n\\n        import functools\\n\\n        # greedy solution: correct >= current\\n        current_hrs, current_mins = map(int, current.split(\\':\\'))\\n        correct_hrs, correct_mins = map(int, correct.split(\\':\\'))\\n        target_mins = (correct_hrs - current_hrs) * 60 + (correct_mins - current_mins)\\n\\n        choices = [60, 15, 5, 1]\\n\\n        rems = [functools.reduce(lambda a, b: a % b, [target_mins] + choices[:i]) \\\\\\n            for i in range(len(choices))]\\n\\n        return sum(rems[i] // choices[i] for i in range(len(choices)))\\n```\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str, memo: dict = {}) -> int:\\n        current_hrs, current_mins = map(int, current.split(\\':\\'))\\n        correct_hrs, correct_mins = map(int, correct.split(\\':\\'))\\n        target_mins = (correct_hrs - current_hrs) * 60 + (correct_mins - current_mins)\\n        choices = [1, 5, 15, 60]\\n        return self.solveRecursively(target_mins, choices)\\n    \\n    def solveRecursively(self, amount: int, choices: list, memo: dict = {}) -> int:\\n        if amount < 0: # amount cannot be made - set to negative to fail check\\n            return -1\\n        if amount == 0: # base case\\n            return 0\\n        if amount in memo:\\n            return memo[amount] \\n        \\n        min_count = float(\\'inf\\')\\n        for c in choices:\\n            if 0 <= (f := self.solveRecursively(amount - c, choices, memo)) < min_count:\\n                min_count = 1 + f\\n        memo[amount] = min_count if min_count != float(\\'inf\\') else -1\\n        return memo[amount]\\n```\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str, memo: dict = {}) -> int:\\n        current_hrs, current_mins = map(int, current.split(\\':\\'))\\n        correct_hrs, correct_mins = map(int, correct.split(\\':\\'))\\n        target_mins = (correct_hrs - current_hrs) * 60 + (correct_mins - current_mins)\\n        choices = [1, 5, 15, 60]\\n        dp = {0: 0}  # base case\\n        for a in range(1, target_mins + 1):\\n            dp[a] = min(1 + dp.get(a - c, float(\\'inf\\')) for c in choices)\\n        \\n        return dp[target_mins] if dp[target_mins] is not float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996177,
                "title": "typescript-easy-math-solution-o-1",
                "content": "# Approach\\nCount the difference in mututes between current and correct times, than use the arithmetics to count the operations.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunction convertTime(current: string, correct: string): number {\\n    let counter = 0;\\n\\n    const cur = getMinutes(current);\\n    const cor = getMinutes(correct);\\n    let rest = Math.abs(cur - cor);\\n\\n    if (Math.floor(rest / 60) > 0) {\\n        counter += Math.floor(rest / 60);\\n        rest = rest % 60;\\n    }\\n    if (Math.floor(rest / 15) > 0) {\\n        counter += Math.floor(rest / 15);\\n        rest = rest % 15;\\n    }\\n    if (Math.floor(rest / 5) > 0) {\\n        counter += Math.floor(rest / 5);\\n        rest = rest % 5;\\n    }\\n\\n    return counter + rest;\\n};\\n\\nfunction getMinutes (value: string):number {\\n    const arr = value.split(\":\");\\n    return Number(arr[0])*60 + Number(arr[1]);\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction convertTime(current: string, correct: string): number {\\n    let counter = 0;\\n\\n    const cur = getMinutes(current);\\n    const cor = getMinutes(correct);\\n    let rest = Math.abs(cur - cor);\\n\\n    if (Math.floor(rest / 60) > 0) {\\n        counter += Math.floor(rest / 60);\\n        rest = rest % 60;\\n    }\\n    if (Math.floor(rest / 15) > 0) {\\n        counter += Math.floor(rest / 15);\\n        rest = rest % 15;\\n    }\\n    if (Math.floor(rest / 5) > 0) {\\n        counter += Math.floor(rest / 5);\\n        rest = rest % 5;\\n    }\\n\\n    return counter + rest;\\n};\\n\\nfunction getMinutes (value: string):number {\\n    const arr = value.split(\":\");\\n    return Number(arr[0])*60 + Number(arr[1]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3994183,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int convertTime(string current, string correct) {\\n    const vector<int> ops{60, 15, 5, 1};\\n    int diff = getMinutes(correct) - getMinutes(current);\\n    int ans = 0;\\n\\n    for (const int op : ops) {\\n      ans += diff / op;\\n      diff %= op;\\n    }\\n\\n    return ans;\\n  }\\n\\n private:\\n  int getMinutes(const string& s) {\\n    return stoi(s.substr(0, 2)) * 60 + stoi(s.substr(3));\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int convertTime(string current, string correct) {\\n    const vector<int> ops{60, 15, 5, 1};\\n    int diff = getMinutes(correct) - getMinutes(current);\\n    int ans = 0;\\n\\n    for (const int op : ops) {\\n      ans += diff / op;\\n      diff %= op;\\n    }\\n\\n    return ans;\\n  }\\n\\n private:\\n  int getMinutes(const string& s) {\\n    return stoi(s.substr(0, 2)) * 60 + stoi(s.substr(3));\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942663,
                "title": "java-solution-0-ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int convertTime(String current, String correct) {\\n        int currentMinute = hourToMinuteConverter(current);\\n        int correctMinute = hourToMinuteConverter(correct);\\n        int difference = correctMinute - currentMinute;\\n        int count = numberOfOperations(difference);\\n        return count;\\n    }\\n\\n    private static int hourToMinuteConverter(String hour) {\\n        int first = ((int)hour.charAt(0) - 48) * 10;\\n        int second = ((int)hour.charAt(1) - 48);\\n        int hours = (first + second) * 60;\\n        int m1 = ((int)hour.charAt(3) - 48) * 10;\\n        int m2 = ((int)hour.charAt(4) - 48);\\n        int minutes = m1 + m2;\\n        return hours + minutes;\\n    }\\n\\n    private static int numberOfOperations(int difference) {\\n        int result = difference;\\n        int count = 0;\\n        while (result>0) {\\n            if(result/60 >= 1) {\\n                int i = result / 60;\\n                count += i;\\n                result -= 60*i;\\n            } else if(result/15 >= 1) {\\n                int i = result / 15;\\n                count += i;\\n                result -= 15*i;\\n            } else if(result/5 >= 1) {\\n                int i = result / 5;\\n                count += i;\\n                result -= 5*i;\\n            } else {\\n                int i = result;\\n                count += i;\\n                result -= i;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int convertTime(String current, String correct) {\\n        int currentMinute = hourToMinuteConverter(current);\\n        int correctMinute = hourToMinuteConverter(correct);\\n        int difference = correctMinute - currentMinute;\\n        int count = numberOfOperations(difference);\\n        return count;\\n    }\\n\\n    private static int hourToMinuteConverter(String hour) {\\n        int first = ((int)hour.charAt(0) - 48) * 10;\\n        int second = ((int)hour.charAt(1) - 48);\\n        int hours = (first + second) * 60;\\n        int m1 = ((int)hour.charAt(3) - 48) * 10;\\n        int m2 = ((int)hour.charAt(4) - 48);\\n        int minutes = m1 + m2;\\n        return hours + minutes;\\n    }\\n\\n    private static int numberOfOperations(int difference) {\\n        int result = difference;\\n        int count = 0;\\n        while (result>0) {\\n            if(result/60 >= 1) {\\n                int i = result / 60;\\n                count += i;\\n                result -= 60*i;\\n            } else if(result/15 >= 1) {\\n                int i = result / 15;\\n                count += i;\\n                result -= 15*i;\\n            } else if(result/5 >= 1) {\\n                int i = result / 5;\\n                count += i;\\n                result -= 5*i;\\n            } else {\\n                int i = result;\\n                count += i;\\n                result -= i;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899308,
                "title": "short-and-easy-to-understand",
                "content": "\\n\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        # get hours and minutes\\n        h1,m1 = list(map(int,(correct).split(\\':\\')))\\n        h2,m2 = list(map(int,(current).split(\\':\\')))\\n        \\n        # count hours diff deducting 1 hour in case\\n        # \\'correct\\' minutes are higher vs \\'current\\'\\n\\n        count = h1-h2 - (m2>m1)\\n        # count min diff adding 1 hour for the case then\\n        # \\'correct\\' minutes are higher vs \\'current\\'\\n\\n        diff = (m1-m2) + 60*(m2>m1)        \\n        for n in (15,5):\\n            count += diff//n\\n            diff %=n\\n        return  count + diff\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        # get hours and minutes\\n        h1,m1 = list(map(int,(correct).split(\\':\\')))\\n        h2,m2 = list(map(int,(current).split(\\':\\')))\\n        \\n        # count hours diff deducting 1 hour in case\\n        # \\'correct\\' minutes are higher vs \\'current\\'\\n\\n        count = h1-h2 - (m2>m1)\\n        # count min diff adding 1 hour for the case then\\n        # \\'correct\\' minutes are higher vs \\'current\\'\\n\\n        diff = (m1-m2) + 60*(m2>m1)        \\n        for n in (15,5):\\n            count += diff//n\\n            diff %=n\\n        return  count + diff\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884755,
                "title": "java-beats-100-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int min1 = (current.charAt(0) - \\'0\\')*10 + (current.charAt(1) - \\'0\\');\\n        int min2 = (correct.charAt(0) - \\'0\\')*10 + (correct.charAt(1) - \\'0\\');\\n\\n        int sec1 = (current.charAt(3) - \\'0\\')*10 + (current.charAt(4) - \\'0\\');\\n        int sec2 = (correct.charAt(3) - \\'0\\')*10 + (correct.charAt(4) - \\'0\\');\\n\\n        int ans = 0;\\n        int a;\\n        int b;\\n        ans += min2 - min1;\\n        if(ans < 0)\\n            ans += 24;\\n        a = sec2 - sec1;\\n        if(a < 0){\\n            ans--;\\n            a += 60;\\n        }\\n        ans += a/15;\\n        int c = a%15;\\n        ans += c/5;\\n        ans += c%5;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int min1 = (current.charAt(0) - \\'0\\')*10 + (current.charAt(1) - \\'0\\');\\n        int min2 = (correct.charAt(0) - \\'0\\')*10 + (correct.charAt(1) - \\'0\\');\\n\\n        int sec1 = (current.charAt(3) - \\'0\\')*10 + (current.charAt(4) - \\'0\\');\\n        int sec2 = (correct.charAt(3) - \\'0\\')*10 + (correct.charAt(4) - \\'0\\');\\n\\n        int ans = 0;\\n        int a;\\n        int b;\\n        ans += min2 - min1;\\n        if(ans < 0)\\n            ans += 24;\\n        a = sec2 - sec1;\\n        if(a < 0){\\n            ans--;\\n            a += 60;\\n        }\\n        ans += a/15;\\n        int c = a%15;\\n        ans += c/5;\\n        ans += c%5;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884189,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int ConvertTime(string current, string correct) {\\n        var res = 0;\\n        int hour = (correct[0] - current[0]) * 10 + (correct[1] - current[1]);\\n        int min = (correct[3] - current[3]) * 10 + (correct[4] - current[4]);\\n        if( min < 0) {\\n            hour--;\\n            min += 60;\\n        }\\n        res += hour;\\n        while(min >= 15){\\n            min -= 15;\\n            res++;\\n        }\\n        while(min >= 5){\\n            min -= 5;\\n            res++;\\n        }\\n        while(min >= 1){\\n            min -= 1;\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int ConvertTime(string current, string correct) {\\n        var res = 0;\\n        int hour = (correct[0] - current[0]) * 10 + (correct[1] - current[1]);\\n        int min = (correct[3] - current[3]) * 10 + (correct[4] - current[4]);\\n        if( min < 0) {\\n            hour--;\\n            min += 60;\\n        }\\n        res += hour;\\n        while(min >= 15){\\n            min -= 15;\\n            res++;\\n        }\\n        while(min >= 5){\\n            min -= 5;\\n            res++;\\n        }\\n        while(min >= 1){\\n            min -= 1;\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878497,
                "title": "very-basic-java-soln-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        if(current.equals(correct))\\n            return 0;\\n        int t1=((current.charAt(0)-\\'0\\')*10+(current.charAt(1)-\\'0\\'))*60;\\n        t1+=(current.charAt(3)-\\'0\\')*10+current.charAt(4)-\\'0\\';\\n        int t2=((correct.charAt(0)-\\'0\\')*10+(correct.charAt(1)-\\'0\\'))*60;\\n        t2+=(correct.charAt(3)-\\'0\\')*10+correct.charAt(4)-\\'0\\';\\n        int t=t2-t1;\\n        if(t<0)\\n            t+=1440;\\n        int c=0;\\n        while(t!=0){\\n            if(t>=60)\\n                t-=60;\\n            else if(t>=15)\\n                t-=15;\\n            else if(t>=5)\\n                t-=5;\\n            else\\n                t--;\\n            c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        if(current.equals(correct))\\n            return 0;\\n        int t1=((current.charAt(0)-\\'0\\')*10+(current.charAt(1)-\\'0\\'))*60;\\n        t1+=(current.charAt(3)-\\'0\\')*10+current.charAt(4)-\\'0\\';\\n        int t2=((correct.charAt(0)-\\'0\\')*10+(correct.charAt(1)-\\'0\\'))*60;\\n        t2+=(correct.charAt(3)-\\'0\\')*10+correct.charAt(4)-\\'0\\';\\n        int t=t2-t1;\\n        if(t<0)\\n            t+=1440;\\n        int c=0;\\n        while(t!=0){\\n            if(t>=60)\\n                t-=60;\\n            else if(t>=15)\\n                t-=15;\\n            else if(t>=5)\\n                t-=5;\\n            else\\n                t--;\\n            c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870093,
                "title": "c-easy-solution-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int cnt=0;\\n        int target=(stoi(correct.substr(0, 2))-stoi(current.substr(0, 2)))*60+(stoi(correct.substr(3, 2))-stoi(current.substr(3, 2)));\\n        while(target>=60){\\n            target-=60;\\n            cnt++;\\n        }\\n        while(target>=15){\\n            target-=15;\\n            cnt++;\\n        }\\n        while(target>=5){\\n            target-=5;\\n            cnt++;\\n        }\\n        while(target>=1){\\n            target-=1;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int cnt=0;\\n        int target=(stoi(correct.substr(0, 2))-stoi(current.substr(0, 2)))*60+(stoi(correct.substr(3, 2))-stoi(current.substr(3, 2)));\\n        while(target>=60){\\n            target-=60;\\n            cnt++;\\n        }\\n        while(target>=15){\\n            target-=15;\\n            cnt++;\\n        }\\n        while(target>=5){\\n            target-=5;\\n            cnt++;\\n        }\\n        while(target>=1){\\n            target-=1;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870083,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int start_hour = stoi(current.substr(0, 2));\\n        int end_hour = stoi(correct.substr(0, 2));\\n        int start_min = stoi(current.substr(3, 2));\\n        int end_min = stoi(correct.substr(3, 2));\\n        if(start_min>end_min){\\n            end_hour--;\\n            end_min+=60;\\n        }\\n        int target=(end_hour-start_hour)*60+(end_min-start_min);\\n        int cnt=0;\\n        while(target>=60){\\n            target-=60;\\n            cnt++;\\n        }\\n        while(target>=15){\\n            target-=15;\\n            cnt++;\\n        }\\n        while(target>=5){\\n            target-=5;\\n            cnt++;\\n        }\\n        while(target>=1){\\n            target-=1;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int start_hour = stoi(current.substr(0, 2));\\n        int end_hour = stoi(correct.substr(0, 2));\\n        int start_min = stoi(current.substr(3, 2));\\n        int end_min = stoi(correct.substr(3, 2));\\n        if(start_min>end_min){\\n            end_hour--;\\n            end_min+=60;\\n        }\\n        int target=(end_hour-start_hour)*60+(end_min-start_min);\\n        int cnt=0;\\n        while(target>=60){\\n            target-=60;\\n            cnt++;\\n        }\\n        while(target>=15){\\n            target-=15;\\n            cnt++;\\n        }\\n        while(target>=5){\\n            target-=5;\\n            cnt++;\\n        }\\n        while(target>=1){\\n            target-=1;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865209,
                "title": "easy-cpp-solution-beginner-friendly-by-calculating-difference",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        // cuh = current hours into minutes\\n        int cuh = stoi(current.substr(0,2)) * 60;\\n        // ch = correct hours into minutes\\n        int ch = stoi(correct.substr(0,2)) * 60;\\n        cuh += stoi(current.substr(3,2));\\n        ch += stoi(correct.substr(3,2));\\n        // Getting difference of both in minutes\\n        int diff = ch - cuh;\\n        int steps = 0;\\n        while(diff){\\n            if(diff >= 60)\\n                diff -= 60;\\n            else if(diff >= 15)\\n                diff -= 15;\\n            else if(diff >= 5)\\n                diff -= 5;\\n            else\\n                diff -= 1;\\n            steps++;\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        // cuh = current hours into minutes\\n        int cuh = stoi(current.substr(0,2)) * 60;\\n        // ch = correct hours into minutes\\n        int ch = stoi(correct.substr(0,2)) * 60;\\n        cuh += stoi(current.substr(3,2));\\n        ch += stoi(correct.substr(3,2));\\n        // Getting difference of both in minutes\\n        int diff = ch - cuh;\\n        int steps = 0;\\n        while(diff){\\n            if(diff >= 60)\\n                diff -= 60;\\n            else if(diff >= 15)\\n                diff -= 15;\\n            else if(diff >= 5)\\n                diff -= 5;\\n            else\\n                diff -= 1;\\n            steps++;\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862500,
                "title": "straightforward-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int hoursCurrent = Integer.valueOf(current.substring(0, 2));\\n        int minsCurrent = Integer.valueOf(current.substring(3, 5));\\n\\n        int hoursCorrect = Integer.valueOf(correct.substring(0, 2));\\n        int minsCorrect = Integer.valueOf(correct.substring(3, 5));\\n\\n        int hoursDiff = hoursCorrect - hoursCurrent;\\n        int minsDiff = minsCorrect - minsCurrent;\\n\\n        if (minsDiff < 0) {\\n            if (hoursDiff > 0) {\\n                hoursDiff -= 1;\\n            }\\n            minsDiff = 60 + minsDiff;\\n        }\\n\\n        int ops = 0;\\n        while (minsDiff > 0) {\\n            if (minsDiff - 15 >= 0) {\\n                minsDiff -= 15;\\n            } else if (minsDiff - 5 >= 0) {\\n                minsDiff -= 5;\\n            } else if (minsDiff - 1 >= 0) {\\n                minsDiff -= 1;\\n            }\\n            ops++;\\n        }\\n\\n        ops += hoursDiff;\\n\\n        return ops;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int hoursCurrent = Integer.valueOf(current.substring(0, 2));\\n        int minsCurrent = Integer.valueOf(current.substring(3, 5));\\n\\n        int hoursCorrect = Integer.valueOf(correct.substring(0, 2));\\n        int minsCorrect = Integer.valueOf(correct.substring(3, 5));\\n\\n        int hoursDiff = hoursCorrect - hoursCurrent;\\n        int minsDiff = minsCorrect - minsCurrent;\\n\\n        if (minsDiff < 0) {\\n            if (hoursDiff > 0) {\\n                hoursDiff -= 1;\\n            }\\n            minsDiff = 60 + minsDiff;\\n        }\\n\\n        int ops = 0;\\n        while (minsDiff > 0) {\\n            if (minsDiff - 15 >= 0) {\\n                minsDiff -= 15;\\n            } else if (minsDiff - 5 >= 0) {\\n                minsDiff -= 5;\\n            } else if (minsDiff - 1 >= 0) {\\n                minsDiff -= 1;\\n            }\\n            ops++;\\n        }\\n\\n        ops += hoursDiff;\\n\\n        return ops;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854561,
                "title": "converttime-by-mat-j-soukup",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConvert strings and do difference between correct and current\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n20 minutes\\n\\n# Code\\n```\\npublic class Solution {\\n      public int ConvertTime(string current, string correct)\\n        {\\n\\n            int int_current = int.Parse(current.Split(\\':\\')[0]) * 60;\\n            int_current += int.Parse(current.Split(\\':\\')[1]);\\n\\n            int int_correct = int.Parse(correct.Split(\\':\\')[0]) * 60;\\n            int_correct += int.Parse(correct.Split(\\':\\')[1]);\\n\\n\\n            int diff = int_correct - int_current;\\n\\n            int i = 0;\\n\\n            while (diff > 0)\\n            {\\n                if (diff >= 60)\\n                {\\n                    diff -= 60;\\n                    i++;\\n\\n                }else if(diff >= 15)\\n                {\\n                    diff -= 15;\\n                    i++;\\n\\n                }else if (diff >= 5)\\n                {\\n                    diff -= 5;\\n                    i++;\\n\\n                }\\n                else\\n                {\\n                    diff--;\\n                    i++;\\n\\n                }\\n            }\\n\\n            return i;\\n        }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n      public int ConvertTime(string current, string correct)\\n        {\\n\\n            int int_current = int.Parse(current.Split(\\':\\')[0]) * 60;\\n            int_current += int.Parse(current.Split(\\':\\')[1]);\\n\\n            int int_correct = int.Parse(correct.Split(\\':\\')[0]) * 60;\\n            int_correct += int.Parse(correct.Split(\\':\\')[1]);\\n\\n\\n            int diff = int_correct - int_current;\\n\\n            int i = 0;\\n\\n            while (diff > 0)\\n            {\\n                if (diff >= 60)\\n                {\\n                    diff -= 60;\\n                    i++;\\n\\n                }else if(diff >= 15)\\n                {\\n                    diff -= 15;\\n                    i++;\\n\\n                }else if (diff >= 5)\\n                {\\n                    diff -= 5;\\n                    i++;\\n\\n                }\\n                else\\n                {\\n                    diff--;\\n                    i++;\\n\\n                }\\n            }\\n\\n            return i;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850312,
                "title": "clean-ts-solution-with-o-n-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction convertTime(current: string, correct: string): number {\\n    const [h1, m1] = current.split(\":\").map(r => parseInt(r));\\n    const [h2, m2] = correct.split(\":\").map(r => parseInt(r));\\n    let differnceInMinutes = Math.abs((h2 - h1) * 60 + (m2 - m1));\\n    let operations = 0;\\n    const increaseValues = [60, 15, 5, 1]; // it is important the increase values to be ordered descenting\\n\\n    for (const increase of increaseValues) {\\n        while (differnceInMinutes >= increase) { \\n            differnceInMinutes -= increase; // keep removing from the highest increas first will we reache the end.\\n            operations++;\\n        }\\n    }\\n    return operations;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Greedy"
                ],
                "code": "```\\nfunction convertTime(current: string, correct: string): number {\\n    const [h1, m1] = current.split(\":\").map(r => parseInt(r));\\n    const [h2, m2] = correct.split(\":\").map(r => parseInt(r));\\n    let differnceInMinutes = Math.abs((h2 - h1) * 60 + (m2 - m1));\\n    let operations = 0;\\n    const increaseValues = [60, 15, 5, 1]; // it is important the increase values to be ordered descenting\\n\\n    for (const increase of increaseValues) {\\n        while (differnceInMinutes >= increase) { \\n            differnceInMinutes -= increase; // keep removing from the highest increas first will we reache the end.\\n            operations++;\\n        }\\n    }\\n    return operations;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3817144,
                "title": "very-easy-jebasraja",
                "content": "# Intuition:KARUNYA UNIVERSITY::ACCENTURE\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) \\n    {\\n        String[] first=current.split(\":\");\\nString[] second=correct.split(\":\");\\n\\n\\nint firstlove=Integer.valueOf(first[0])*60+Integer.valueOf(first[1]);\\nint secondlove=Integer.valueOf(second[0])*60+Integer.valueOf(second[1]);\\n\\nSystem.out.println(firstlove+\" \"+secondlove +\"---->\"+\"\"+(firstlove-secondlove));\\n\\nint total=secondlove-firstlove;\\nint operiton=0;\\nSystem.out.println(total);\\n\\nwhile (total>0)\\n{  \\n  System.out.println(\"what the fuck\");   \\n  if (total>=60) \\n  {  \\n    \\n   System.out.println(\"jebas\");    \\n    operiton+=total/60;\\n    System.out.println(\"greater than 60\"+(total/60));\\n    total=total%60;\\n  }\\n  else if (total>=15) \\n  {\\n    System.out.println(\"raja\");\\n    operiton+=total/15;\\n    total=total%15;\\n  }\\n  else if (total>=5) \\n  {\\n    System.out.println(\"peter\");\\n    operiton+=total/5;\\n    System.out.println(\"greater than 5\"+(total/5));\\n    total=total%5; \\n  }\\n  else\\n  {  \\n    System.out.println(\"crime_luv\");\\n     operiton+=total;\\n     total=0;\\n    }\\n}\\n\\n\\nSystem.out.println(operiton);\\n\\nreturn operiton;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) \\n    {\\n        String[] first=current.split(\":\");\\nString[] second=correct.split(\":\");\\n\\n\\nint firstlove=Integer.valueOf(first[0])*60+Integer.valueOf(first[1]);\\nint secondlove=Integer.valueOf(second[0])*60+Integer.valueOf(second[1]);\\n\\nSystem.out.println(firstlove+\" \"+secondlove +\"---->\"+\"\"+(firstlove-secondlove));\\n\\nint total=secondlove-firstlove;\\nint operiton=0;\\nSystem.out.println(total);\\n\\nwhile (total>0)\\n{  \\n  System.out.println(\"what the fuck\");   \\n  if (total>=60) \\n  {  \\n    \\n   System.out.println(\"jebas\");    \\n    operiton+=total/60;\\n    System.out.println(\"greater than 60\"+(total/60));\\n    total=total%60;\\n  }\\n  else if (total>=15) \\n  {\\n    System.out.println(\"raja\");\\n    operiton+=total/15;\\n    total=total%15;\\n  }\\n  else if (total>=5) \\n  {\\n    System.out.println(\"peter\");\\n    operiton+=total/5;\\n    System.out.println(\"greater than 5\"+(total/5));\\n    total=total%5; \\n  }\\n  else\\n  {  \\n    System.out.println(\"crime_luv\");\\n     operiton+=total;\\n     total=0;\\n    }\\n}\\n\\n\\nSystem.out.println(operiton);\\n\\nreturn operiton;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808131,
                "title": "simple-easy-to-understand-go-golang-solution",
                "content": "```\\nfunc convertTime(current, correct string) int {\\n        timeRange := toMinutes(correct) - toMinutes(current)\\n        var counter int\\n\\n        for timeRange > 0 {\\n                var reduce int\\n\\n                if timeRange >= 60 {\\n                        reduce = 60\\n                } else if timeRange >= 15 && timeRange < 60 {\\n                        reduce = 15\\n                } else if timeRange >= 5 && timeRange < 15 {\\n                        reduce = 5\\n                } else {\\n                        reduce = 1\\n                }\\n\\n                timeRange -= reduce\\n                counter++\\n        }\\n\\n        return counter\\n}\\n\\nfunc toMinutes(time string) int {\\n        hours := time[:2]\\n        minutes := time[3:]\\n\\n        var res int\\n\\n        res += int(minutes[1] - \\'0\\')\\n        res += (int(minutes[0]-\\'0\\') * 10)\\n\\n        res += (int(hours[1]-\\'0\\') * 60)\\n        res += (int(hours[0]-\\'0\\') * 60 * 10)\\n\\n        return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc convertTime(current, correct string) int {\\n        timeRange := toMinutes(correct) - toMinutes(current)\\n        var counter int\\n\\n        for timeRange > 0 {\\n                var reduce int\\n\\n                if timeRange >= 60 {\\n                        reduce = 60\\n                } else if timeRange >= 15 && timeRange < 60 {\\n                        reduce = 15\\n                } else if timeRange >= 5 && timeRange < 15 {\\n                        reduce = 5\\n                } else {\\n                        reduce = 1\\n                }\\n\\n                timeRange -= reduce\\n                counter++\\n        }\\n\\n        return counter\\n}\\n\\nfunc toMinutes(time string) int {\\n        hours := time[:2]\\n        minutes := time[3:]\\n\\n        var res int\\n\\n        res += int(minutes[1] - \\'0\\')\\n        res += (int(minutes[0]-\\'0\\') * 10)\\n\\n        res += (int(hours[1]-\\'0\\') * 60)\\n        res += (int(hours[0]-\\'0\\') * 60 * 10)\\n\\n        return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3796815,
                "title": "easy-and-naiive-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n        public int convertTime(String current, String correct) {\\n        int H1 = Integer.valueOf(current.substring(0,2));\\n        int H2 = Integer.valueOf(correct.substring(0,2));\\n        int M1 = Integer.valueOf(current.substring(3));\\n        int M2 = Integer.valueOf(correct.substring(3));\\n\\n        int totSecs1 = H1 * 60 + M1;\\n        int totSecs2 = H2 * 60 + M2;\\n\\n        int rem = totSecs2 - totSecs1;\\n\\n        int minOps = 0;\\n\\n        int divideBy60 = rem / 60;\\n\\n        minOps += divideBy60;\\n        rem -= (60 * divideBy60);\\n\\n        int divideBy15 = rem / 15;\\n\\n        minOps += divideBy15;\\n        rem -= (15 * divideBy15);\\n\\n        int divideBy5 = rem / 5;\\n\\n        minOps += divideBy5;\\n        rem -= (5 * divideBy5);\\n\\n        minOps += rem;\\n\\n        return minOps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        public int convertTime(String current, String correct) {\\n        int H1 = Integer.valueOf(current.substring(0,2));\\n        int H2 = Integer.valueOf(correct.substring(0,2));\\n        int M1 = Integer.valueOf(current.substring(3));\\n        int M2 = Integer.valueOf(correct.substring(3));\\n\\n        int totSecs1 = H1 * 60 + M1;\\n        int totSecs2 = H2 * 60 + M2;\\n\\n        int rem = totSecs2 - totSecs1;\\n\\n        int minOps = 0;\\n\\n        int divideBy60 = rem / 60;\\n\\n        minOps += divideBy60;\\n        rem -= (60 * divideBy60);\\n\\n        int divideBy15 = rem / 15;\\n\\n        minOps += divideBy15;\\n        rem -= (15 * divideBy15);\\n\\n        int divideBy5 = rem / 5;\\n\\n        minOps += divideBy5;\\n        rem -= (5 * divideBy5);\\n\\n        minOps += rem;\\n\\n        return minOps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778453,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int operations = 0;\\n        int h1= (current[0]-\\'0\\')*10 + current[1]-\\'0\\', h2= (correct[0]-\\'0\\')*10 + correct[1]-\\'0\\';\\n        int m1= (current[3]-\\'0\\')*10 + current[4]-\\'0\\', m2= (correct[3]-\\'0\\')*10 + correct[4]-\\'0\\';\\n        operations = h2-h1; \\n        if(m2-m1 < 0){\\n            m2+=60-m1;\\n            operations--;\\n        }\\n        else m2-=m1;\\n        operations+= m2/15;\\n        m2 = m2%15;\\n        operations+= m2/5;\\n        m2 = m2%5;\\n        operations+=m2;\\n        return operations;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int operations = 0;\\n        int h1= (current[0]-\\'0\\')*10 + current[1]-\\'0\\', h2= (correct[0]-\\'0\\')*10 + correct[1]-\\'0\\';\\n        int m1= (current[3]-\\'0\\')*10 + current[4]-\\'0\\', m2= (correct[3]-\\'0\\')*10 + correct[4]-\\'0\\';\\n        operations = h2-h1; \\n        if(m2-m1 < 0){\\n            m2+=60-m1;\\n            operations--;\\n        }\\n        else m2-=m1;\\n        while(m2 > 0){\\n            if(m2%5==0) break;\\n            m2-=1;\\n            operations++;\\n        }\\n        while(m2 >= 15){\\n            m2-=15;\\n            operations++;\\n        }\\n        while(m2 > 0){\\n            m2-=5;\\n            operations++;\\n        }\\n        return operations;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        if(current==correct) return 0;\\n        string t1 = \"\", t2=\"\", t3=\"\", t4=\"\";\\n        t1=current[0]; t1+=current[1];\\n        t2=correct[0]; t2+=correct[1];\\n        t3=current[3]; t3+=current[4];\\n        t4=correct[3]; t4+=correct[4];\\n        int operations = 0, h1= stoi(t1), h2= stoi(t2), m1= stoi(t3), m2= stoi(t4);\\n        operations = h2-h1;\\n        m2-=m1;\\n        if(m2==0) return operations;\\n        if(m2 < 0){\\n            m2+=m1;\\n            m1 = 60-m1;\\n            m1+=m2;\\n            m2=m1;\\n            operations--;\\n        }\\n        while(m2 > 0){\\n            if(m2%5==0) break;\\n            m2-=1;\\n            operations++;\\n        }\\n        while(m2 >= 15){\\n            m2-=15;\\n            operations++;\\n        }\\n        while(m2 > 0){\\n            m2-=5;\\n            operations++;\\n        }\\n        return operations;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int operations = 0;\\n        int h1= (current[0]-\\'0\\')*10 + current[1]-\\'0\\', h2= (correct[0]-\\'0\\')*10 + correct[1]-\\'0\\';\\n        int m1= (current[3]-\\'0\\')*10 + current[4]-\\'0\\', m2= (correct[3]-\\'0\\')*10 + correct[4]-\\'0\\';\\n        operations = h2-h1; \\n        if(m2-m1 < 0){\\n            m2+=60-m1;\\n            operations--;\\n        }\\n        else m2-=m1;\\n        operations+= m2/15;\\n        m2 = m2%15;\\n        operations+= m2/5;\\n        m2 = m2%5;\\n        operations+=m2;\\n        return operations;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int operations = 0;\\n        int h1= (current[0]-\\'0\\')*10 + current[1]-\\'0\\', h2= (correct[0]-\\'0\\')*10 + correct[1]-\\'0\\';\\n        int m1= (current[3]-\\'0\\')*10 + current[4]-\\'0\\', m2= (correct[3]-\\'0\\')*10 + correct[4]-\\'0\\';\\n        operations = h2-h1; \\n        if(m2-m1 < 0){\\n            m2+=60-m1;\\n            operations--;\\n        }\\n        else m2-=m1;\\n        while(m2 > 0){\\n            if(m2%5==0) break;\\n            m2-=1;\\n            operations++;\\n        }\\n        while(m2 >= 15){\\n            m2-=15;\\n            operations++;\\n        }\\n        while(m2 > 0){\\n            m2-=5;\\n            operations++;\\n        }\\n        return operations;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        if(current==correct) return 0;\\n        string t1 = \"\", t2=\"\", t3=\"\", t4=\"\";\\n        t1=current[0]; t1+=current[1];\\n        t2=correct[0]; t2+=correct[1];\\n        t3=current[3]; t3+=current[4];\\n        t4=correct[3]; t4+=correct[4];\\n        int operations = 0, h1= stoi(t1), h2= stoi(t2), m1= stoi(t3), m2= stoi(t4);\\n        operations = h2-h1;\\n        m2-=m1;\\n        if(m2==0) return operations;\\n        if(m2 < 0){\\n            m2+=m1;\\n            m1 = 60-m1;\\n            m1+=m2;\\n            m2=m1;\\n            operations--;\\n        }\\n        while(m2 > 0){\\n            if(m2%5==0) break;\\n            m2-=1;\\n            operations++;\\n        }\\n        while(m2 >= 15){\\n            m2-=15;\\n            operations++;\\n        }\\n        while(m2 > 0){\\n            m2-=5;\\n            operations++;\\n        }\\n        return operations;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772272,
                "title": "convert-to-minutes-and-use-divmod",
                "content": "# Code\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        def minutes(h: str, m: str) -> int:\\n            return int(h) * 60 + int(m)\\n        \\n        diff = abs(minutes(*current.split(\":\")) - minutes(*correct.split(\":\")))\\n        result = 0\\n        for divider in [60, 15, 5, 1]:\\n            ops, diff = divmod(diff, divider)\\n            result += ops\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        def minutes(h: str, m: str) -> int:\\n            return int(h) * 60 + int(m)\\n        \\n        diff = abs(minutes(*current.split(\":\")) - minutes(*correct.split(\":\")))\\n        result = 0\\n        for divider in [60, 15, 5, 1]:\\n            ops, diff = divmod(diff, divider)\\n            result += ops\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754500,
                "title": "java-number-of-operations-using-stringtominutes-method-explained",
                "content": "# Approach\\nTo calculate the difference between the two times, we need to first convert them to \"integer-minutes\", so that the 24h-time is being represented by minutes of the day between 0 and 1440 (24*60).\\nTherefore I use StringToMinutes, which adds up the chars int the string representing the hours and minutes into seperate integers and returns their sum.\\n\\nThe actual problemsolving algorithm works as follows:\\nAs long as we can add 60 (minutes) to the current Time and its still smaller or equals to the correct time we do so. If its not possible anymore we continue to do so with 15, 5 and 1. That way we ensure that the minimal number of operations is used, since we add the highest numbers as long as its possible and then switch to the smaller ones.\\n\\n# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n\\n        int curTime=StringToMinute(current);\\n        int corTime=StringToMinute(correct);\\n        int counter=0;\\n\\n        while(curTime+60<=corTime){\\n            curTime+=60;\\n            counter++;\\n        }\\n        while(curTime+15<=corTime){\\n            curTime+=15;\\n            counter++;\\n        }\\n        while(curTime+5<=corTime){\\n            curTime+=5;\\n            counter++;\\n        }\\n        while(curTime+1<=corTime){\\n            curTime+=1;\\n            counter++;\\n        }\\n\\n        return counter;\\n    }\\n\\n    public int StringToMinute(String st){\\n        int min=0;\\n        int hours=0;\\n\\n        //the \"  -\\'0\\'  \" is needed since .charAt(i) would only return the Unicode points for the numbers \"1, 2, 3\" and so on\\n       hours+=(st.charAt(0)-\\'0\\')*10+st.charAt(1)-\\'0\\';\\n\\n       min+=(st.charAt(3)-\\'0\\')*10+(st.charAt(4)-\\'0\\');\\n\\n        return min+hours*60;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n\\n        int curTime=StringToMinute(current);\\n        int corTime=StringToMinute(correct);\\n        int counter=0;\\n\\n        while(curTime+60<=corTime){\\n            curTime+=60;\\n            counter++;\\n        }\\n        while(curTime+15<=corTime){\\n            curTime+=15;\\n            counter++;\\n        }\\n        while(curTime+5<=corTime){\\n            curTime+=5;\\n            counter++;\\n        }\\n        while(curTime+1<=corTime){\\n            curTime+=1;\\n            counter++;\\n        }\\n\\n        return counter;\\n    }\\n\\n    public int StringToMinute(String st){\\n        int min=0;\\n        int hours=0;\\n\\n        //the \"  -\\'0\\'  \" is needed since .charAt(i) would only return the Unicode points for the numbers \"1, 2, 3\" and so on\\n       hours+=(st.charAt(0)-\\'0\\')*10+st.charAt(1)-\\'0\\';\\n\\n       min+=(st.charAt(3)-\\'0\\')*10+(st.charAt(4)-\\'0\\');\\n\\n        return min+hours*60;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752857,
                "title": "100-beats-easy-solution-with-explanation-c",
                "content": "# Intuition\\nThe problem involves converting the time from the current time to the correct time. We need to calculate the number of steps needed to reach the correct time, where each step can be a jump of 60 minutes, 15 minutes, 5 minutes, or a remaining duration less than 5 minutes.\\n\\n# Approach\\nTo solve this problem, we can follow these steps:\\n1. Parse the hours and minutes from the `current` and `correct` strings and convert them into minutes. We can use the `stoi` function and substrings to extract the hours and minutes.\\n2. Calculate the difference `dis` between the correct time and the current time in minutes.\\n3. Initialize a counter `cnt` to keep track of the number of steps taken.\\n4. Use a `while` loop to iterate as long as `dis` is greater than or equal to zero.\\n5. Inside the loop, check if `dis` is greater than or equal to 60. If so, divide `dis` by 60 and add the quotient to `cnt`. Update `dis` by taking the remainder (`dis %= 60`).\\n6. Repeat the same process for 15 minutes and 5 minutes intervals, updating `cnt` and `dis` accordingly.\\n7. If `dis` is less than 5 minutes, add `dis` to `cnt` and break out of the loop.\\n8. Return the final value of `cnt`.\\n\\n# Complexity\\n- Time complexity: O(1) as the solution has a fixed number of calculations.\\n- Space complexity: O(1) as the space usage does not grow with the input size.\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int m1 = stoi(current.substr(0, 2)) * 60 + stoi(current.substr(3, 2));\\n        int m2 = stoi(correct.substr(0, 2)) * 60 + stoi(correct.substr(3, 2));\\n        int dis = m2 - m1;\\n        int cnt = 0;\\n        \\n        while (dis >= 0) {\\n            if (dis >= 60) {\\n                cnt += (dis / 60);\\n                dis %= 60;\\n            }\\n            else if (dis >= 15) {\\n                cnt += (dis / 15);\\n                dis %= 15;\\n            }\\n            else if (dis >= 5) {\\n                cnt += (dis / 5);\\n                dis %= 5;\\n            }\\n            else {\\n                cnt += dis;\\n                break;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int m1 = stoi(current.substr(0, 2)) * 60 + stoi(current.substr(3, 2));\\n        int m2 = stoi(correct.substr(0, 2)) * 60 + stoi(correct.substr(3, 2));\\n        int dis = m2 - m1;\\n        int cnt = 0;\\n        \\n        while (dis >= 0) {\\n            if (dis >= 60) {\\n                cnt += (dis / 60);\\n                dis %= 60;\\n            }\\n            else if (dis >= 15) {\\n                cnt += (dis / 15);\\n                dis %= 15;\\n            }\\n            else if (dis >= 5) {\\n                cnt += (dis / 5);\\n                dis %= 5;\\n            }\\n            else {\\n                cnt += dis;\\n                break;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739208,
                "title": "a-simple-greedy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int h1 = Integer.parseInt(current.substring(0, 2));\\n        int h2 = Integer.parseInt(correct.substring(0, 2));\\n        int m1 = Integer.parseInt(current.substring(3, 5));\\n        int m2 = Integer.parseInt(correct.substring(3, 5));\\n        int mdiff = (m2 - m1) + (h2 - h1) * 60;\\n        int times = 0;\\n        if(mdiff > 0) {\\n            times += mdiff / 60;\\n            mdiff %= 60;\\n            times += mdiff / 15;\\n            mdiff %= 15;\\n            times += mdiff / 5;\\n            mdiff %= 5;\\n            times += mdiff / 1;\\n            mdiff %= 1;\\n        }\\n        return times;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int h1 = Integer.parseInt(current.substring(0, 2));\\n        int h2 = Integer.parseInt(correct.substring(0, 2));\\n        int m1 = Integer.parseInt(current.substring(3, 5));\\n        int m2 = Integer.parseInt(correct.substring(3, 5));\\n        int mdiff = (m2 - m1) + (h2 - h1) * 60;\\n        int times = 0;\\n        if(mdiff > 0) {\\n            times += mdiff / 60;\\n            mdiff %= 60;\\n            times += mdiff / 15;\\n            mdiff %= 15;\\n            times += mdiff / 5;\\n            mdiff %= 5;\\n            times += mdiff / 1;\\n            mdiff %= 1;\\n        }\\n        return times;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724236,
                "title": "similar-like-coin-change",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n-coin change \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-bottom up dp\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int diff,int time[]){\\n        if(diff == 0){\\n            return 0;\\n        }\\n        vector<int> dp(diff+1,INT_MAX);\\n        dp[0] = 0;\\n        for(int i = 1;i<=diff;i++){\\n            for(int j =0;j<4;j++){\\n                if((i-time[j]>=0) && dp[i-time[j] != INT_MAX])\\n                 dp[i] = min(dp[i] ,dp[i-time[j]]+1);\\n            }\\n        }\\n        return dp[diff];\\n    }\\n    int convertTime(string current, string correct) {\\n        int curr = 0;\\n        int corr = 0;\\n        for(int i =0 ;i<2;i++){\\n                curr = curr*10 + (current[i] -\\'0\\');\\n                corr = corr*10 + (correct[i]-\\'0\\');\\n        }\\n        curr = curr*60;\\n        corr = corr*60;\\n        int minc = 0;\\n        int mincr = 0;\\n        for(int i =3 ;i<5;i++){\\n            minc = minc*10 + (current[i] -\\'0\\');\\n            mincr = mincr*10 + (correct[i]-\\'0\\');\\n        }\\n        curr = curr + minc;\\n        corr = corr + mincr;\\n        int diff = corr - curr;\\n        int time[4] = {1,5,15,60};\\n        return solve(diff,time) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int diff,int time[]){\\n        if(diff == 0){\\n            return 0;\\n        }\\n        vector<int> dp(diff+1,INT_MAX);\\n        dp[0] = 0;\\n        for(int i = 1;i<=diff;i++){\\n            for(int j =0;j<4;j++){\\n                if((i-time[j]>=0) && dp[i-time[j] != INT_MAX])\\n                 dp[i] = min(dp[i] ,dp[i-time[j]]+1);\\n            }\\n        }\\n        return dp[diff];\\n    }\\n    int convertTime(string current, string correct) {\\n        int curr = 0;\\n        int corr = 0;\\n        for(int i =0 ;i<2;i++){\\n                curr = curr*10 + (current[i] -\\'0\\');\\n                corr = corr*10 + (correct[i]-\\'0\\');\\n        }\\n        curr = curr*60;\\n        corr = corr*60;\\n        int minc = 0;\\n        int mincr = 0;\\n        for(int i =3 ;i<5;i++){\\n            minc = minc*10 + (current[i] -\\'0\\');\\n            mincr = mincr*10 + (correct[i]-\\'0\\');\\n        }\\n        curr = curr + minc;\\n        corr = corr + mincr;\\n        int diff = corr - curr;\\n        int time[4] = {1,5,15,60};\\n        return solve(diff,time) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723904,
                "title": "java-greedy-explained",
                "content": "**Idea:** Convert the times to minutes and find the difference between them (D), then find the operations required by finding the quotient by minutes in decreasing order and reducing D to the remainder\\n>**T/S:** O(1)/O(1)\\n```\\npublic int convertTime(String current, String correct) {\\n\\tvar ops = 0;\\n\\tvar diff = toMinutes(correct) - toMinutes(current);\\n\\n\\tfor (var m : List.of(60, 15, 5, 1)) {\\n\\t\\tops += diff / m;\\n\\t\\tdiff %= m;\\n\\t}\\n\\n\\treturn ops;\\n}\\n\\nprivate int toMinutes(String time) {\\n\\tvar parts = time.split(\":\");\\n\\treturn Integer.parseInt(parts[0]) * 60 + Integer.parseInt(parts[1]);\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int convertTime(String current, String correct) {\\n\\tvar ops = 0;\\n\\tvar diff = toMinutes(correct) - toMinutes(current);\\n\\n\\tfor (var m : List.of(60, 15, 5, 1)) {\\n\\t\\tops += diff / m;\\n\\t\\tdiff %= m;\\n\\t}\\n\\n\\treturn ops;\\n}\\n\\nprivate int toMinutes(String time) {\\n\\tvar parts = time.split(\":\");\\n\\treturn Integer.parseInt(parts[0]) * 60 + Integer.parseInt(parts[1]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3719106,
                "title": "c-easy-to-understand-solution-beats-100",
                "content": "![image.png](https://assets.leetcode.com/users/images/a8e6b42d-f876-4568-a5b4-fbbba3562ee5_1688500682.3755567.png)\\n# Approach\\nEssentially, we convert the correct hours into minutes and continue to add to the current minutes until we reach the same value.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int ConvertTime(string current, string correct) {\\n        if (current == correct)\\n        {\\n            return 0;\\n        }\\n\\n        int counter = 0;\\n        int correctHours = int.Parse(correct[..2]);\\n        int currentHours = int.Parse(current[..2]);\\n        int currentMinutes = int.Parse(current.Substring(3, 2));\\n        int correctMinutes = int.Parse(correct.Substring(3, 2)) + 60 * Math.Abs(correctHours - currentHours);\\n\\n        while (currentMinutes != correctMinutes)\\n        {\\n            if ((currentMinutes + 60) <= correctMinutes)\\n            {\\n                currentMinutes += 60;\\n            }\\n            else if ((currentMinutes + 15) <= correctMinutes)\\n            {\\n                currentMinutes += 15;\\n            }\\n            else if ((currentMinutes + 5) <= correctMinutes)\\n            {\\n                currentMinutes += 5;\\n            }\\n            else if ((currentMinutes + 1) <= correctMinutes)\\n            {\\n                currentMinutes += 1;\\n            }\\n\\n            counter++;\\n        }\\n\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int ConvertTime(string current, string correct) {\\n        if (current == correct)\\n        {\\n            return 0;\\n        }\\n\\n        int counter = 0;\\n        int correctHours = int.Parse(correct[..2]);\\n        int currentHours = int.Parse(current[..2]);\\n        int currentMinutes = int.Parse(current.Substring(3, 2));\\n        int correctMinutes = int.Parse(correct.Substring(3, 2)) + 60 * Math.Abs(correctHours - currentHours);\\n\\n        while (currentMinutes != correctMinutes)\\n        {\\n            if ((currentMinutes + 60) <= correctMinutes)\\n            {\\n                currentMinutes += 60;\\n            }\\n            else if ((currentMinutes + 15) <= correctMinutes)\\n            {\\n                currentMinutes += 15;\\n            }\\n            else if ((currentMinutes + 5) <= correctMinutes)\\n            {\\n                currentMinutes += 5;\\n            }\\n            else if ((currentMinutes + 1) <= correctMinutes)\\n            {\\n                currentMinutes += 1;\\n            }\\n\\n            counter++;\\n        }\\n\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700712,
                "title": "best-dynamic-programming-memorization-java",
                "content": "class Solution {\\n    public int convertTime(String current, String correct) {\\n        int diff=0;\\n        int count=0;\\n        for(int i=0;i<current.length()-1;i++){\\n            if(current.charAt(i)==\\':\\' || current.charAt(i+1)==\\':\\') continue;\\n            if(count==0){\\n                int s1=current.charAt(i)-\\'0\\';\\n                int s2=correct.charAt(i)-\\'0\\';\\n                int s3=current.charAt(i+1)-\\'0\\';\\n                int s4=correct.charAt(i+1)-\\'0\\';\\n                s1=s1*10+s3;\\n                s2=s2*10+s4;  \\n                diff+=Math.abs(s1-s2)*60;\\n\\n            }\\n            else{\\n                int s1=current.charAt(i)-\\'0\\';\\n                int s2=correct.charAt(i)-\\'0\\';\\n                int s3=current.charAt(i+1)-\\'0\\';\\n                int s4=correct.charAt(i+1)-\\'0\\';\\n                s1=s1*10+s3;\\n                s2=s2*10+s4;\\n                if(s1<s2){\\n                     diff+=Math.abs(s1-s2);\\n                }\\n                else{\\n                     diff-=Math.abs(s1-s2);\\n                }\\n            }\\n            count++;\\n\\n        }\\n        int[] dp=new int[diff+1];\\n        Arrays.fill(dp,-1);\\n        return helper(diff,dp);\\n    }\\n    public int helper(int diff,int[] dp){\\n        if(diff<0){\\n            return (int)1e9;\\n        }\\n        if(dp[diff]!=-1){\\n            return dp[diff];\\n        }\\n        if(diff==0){\\n            return dp[diff]=0;\\n        }\\n        return dp[diff]=Math.min(1+helper(diff-1,dp),Math.min(1+helper(diff-5,dp),Math.min(1+helper(diff-15,dp),1+helper(diff-60,dp))));\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int convertTime(String current, String correct) {\\n        int diff=0;\\n        int count=0;\\n        for(int i=0;i<current.length()-1;i++){\\n            if(current.charAt(i)==\\':\\' || current.charAt(i+1)==\\':\\') continue;\\n            if(count==0){\\n                int s1=current.charAt(i)-\\'0\\';\\n                int s2=correct.charAt(i)-\\'0\\';\\n                int s3=current.charAt(i+1)-\\'0\\';\\n                int s4=correct.charAt(i+1)-\\'0\\';\\n                s1=s1*10+s3;\\n                s2=s2*10+s4;  \\n                diff+=Math.abs(s1-s2)*60;\\n\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3699024,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\n\\nvar convertTime = function(current, correct) {\\n    const getMinutes = (time) => +time.slice(0, 2) * 60 + +time.slice(3);\\n    let diff = getMinutes(correct) - getMinutes(current);\\n    let sum = 0;\\n    const arr = [60, 15, 5,1]\\n    for(let i =0; i<arr.length; i++){\\n        sum += Math.floor(diff/arr[i]);\\n        diff %= arr[i];\\n    }\\n    return sum;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\n\\nvar convertTime = function(current, correct) {\\n    const getMinutes = (time) => +time.slice(0, 2) * 60 + +time.slice(3);\\n    let diff = getMinutes(correct) - getMinutes(current);\\n    let sum = 0;\\n    const arr = [60, 15, 5,1]\\n    for(let i =0; i<arr.length; i++){\\n        sum += Math.floor(diff/arr[i]);\\n        diff %= arr[i];\\n    }\\n    return sum;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3679004,
                "title": "beats-93-75-runtime-94-3-space-python3",
                "content": "# Approach\\nDirectly splice hours and minutes from string and convert to integer. Use modular arithmetic to account to circular cycle of hours and minutes. Use greedy approach on remaining minutes.\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        ops = 0\\n        cur_hours, cur_minutes = int(current[0:2]), int(current[3:5])\\n        cor_hours, cor_minutes = int(correct[0:2]), int(correct[3:5])\\n\\n        ops += (cor_hours - cur_hours) % 24 - (cor_minutes < cur_minutes)\\n        remaining = (cor_minutes - cur_minutes) % 60\\n        for q in (15, 5):\\n            ops += remaining // q\\n            remaining %= q\\n        \\n        return ops + remaining\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        ops = 0\\n        cur_hours, cur_minutes = int(current[0:2]), int(current[3:5])\\n        cor_hours, cor_minutes = int(correct[0:2]), int(correct[3:5])\\n\\n        ops += (cor_hours - cur_hours) % 24 - (cor_minutes < cur_minutes)\\n        remaining = (cor_minutes - cur_minutes) % 60\\n        for q in (15, 5):\\n            ops += remaining // q\\n            remaining %= q\\n        \\n        return ops + remaining\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676691,
                "title": "java-simple-solution-convert-to-minutes-and-traverse",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int convertTime(String current, String correct) {\\n        String[] splitCurrent = current.split(\":\");\\n        int currentInMinutes = Integer.parseInt(splitCurrent[0]) * 60 + Integer.parseInt(splitCurrent[1]);\\n\\n        String[] splitCorrect = correct.split(\":\");\\n        int correctInMinutes = Integer.parseInt(splitCorrect[0]) * 60 + Integer.parseInt(splitCorrect[1]);\\n\\n        int counter = 0;\\n        while (currentInMinutes != correctInMinutes) {\\n            if (currentInMinutes + 60 <= correctInMinutes) {\\n                currentInMinutes += 60;\\n            } else if (currentInMinutes + 15 <= correctInMinutes) {\\n                currentInMinutes += 15;\\n            } else if (currentInMinutes + 5 <= correctInMinutes) {\\n                currentInMinutes += 5;\\n            } else {\\n                currentInMinutes += 1;\\n            }\\n            counter++;\\n        }\\n\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int convertTime(String current, String correct) {\\n        String[] splitCurrent = current.split(\":\");\\n        int currentInMinutes = Integer.parseInt(splitCurrent[0]) * 60 + Integer.parseInt(splitCurrent[1]);\\n\\n        String[] splitCorrect = correct.split(\":\");\\n        int correctInMinutes = Integer.parseInt(splitCorrect[0]) * 60 + Integer.parseInt(splitCorrect[1]);\\n\\n        int counter = 0;\\n        while (currentInMinutes != correctInMinutes) {\\n            if (currentInMinutes + 60 <= correctInMinutes) {\\n                currentInMinutes += 60;\\n            } else if (currentInMinutes + 15 <= correctInMinutes) {\\n                currentInMinutes += 15;\\n            } else if (currentInMinutes + 5 <= correctInMinutes) {\\n                currentInMinutes += 5;\\n            } else {\\n                currentInMinutes += 1;\\n            }\\n            counter++;\\n        }\\n\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676611,
                "title": "beats-100-time-and-97-9-space-easy-approach",
                "content": "# Approach\\n\\nGet time difference between both times and use Greedy Approach (i.e first 60min, then 15min, 5min and 1min). \\n\\nThe time difference is (minCorr ~ minNow) if correct min is more than current min. (i.e the acute angle in the clock)\\n\\nBut in the other case, it should be the obtuse angle so, the difference is 60 - (minCorr ~ minNow). Further, in this case the hour isn\\'t complete yet so we decrease hour count by 1.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int hN = (current[0] - \\'0\\')*10 + (current[1] - \\'0\\')*1;\\n        int hC = (correct[0] - \\'0\\')*10 + (correct[1] - \\'0\\')*1;\\n        int mN = (current[3] - \\'0\\')*10 + (current[4] - \\'0\\')*1;\\n        int mC = (correct[3] - \\'0\\')*10 + (correct[4] - \\'0\\')*1;\\n        \\n        int res = abs(hN - hC);\\n        int diff{};\\n        if(mN > mC){\\n            diff = abs(60- (mN-mC));\\n            res--;\\n        }\\n        else{\\n            diff = abs(mN - mC);\\n        }\\n        \\n        while(diff){\\n            if(diff >=15){\\n                res++;\\n                diff -= 15;\\n            }\\n            else if(diff >=5){\\n                res++;\\n                diff -= 5;\\n            }\\n            else{\\n                res += diff;\\n                diff = 0;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int hN = (current[0] - \\'0\\')*10 + (current[1] - \\'0\\')*1;\\n        int hC = (correct[0] - \\'0\\')*10 + (correct[1] - \\'0\\')*1;\\n        int mN = (current[3] - \\'0\\')*10 + (current[4] - \\'0\\')*1;\\n        int mC = (correct[3] - \\'0\\')*10 + (correct[4] - \\'0\\')*1;\\n        \\n        int res = abs(hN - hC);\\n        int diff{};\\n        if(mN > mC){\\n            diff = abs(60- (mN-mC));\\n            res--;\\n        }\\n        else{\\n            diff = abs(mN - mC);\\n        }\\n        \\n        while(diff){\\n            if(diff >=15){\\n                res++;\\n                diff -= 15;\\n            }\\n            else if(diff >=5){\\n                res++;\\n                diff -= 5;\\n            }\\n            else{\\n                res += diff;\\n                diff = 0;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669379,
                "title": "java-brief-and-fast-solution-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRegarding the fact that we have String input values we will need to parse them to int and transform them in minutes.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly, we transform string values to int values in minutes. Then we create array with the values that we are allowed to use in operations. And starting from the biggest allowed value, we increase current time until it equals to correct time. Amount of operations will be the answer.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int result=0;\\n\\n        int cur = Integer.parseInt(current.substring(0,2))*60+Integer.parseInt(current.substring(3,5));\\n\\n        int cor = Integer.parseInt(correct.substring(0,2))*60+Integer.parseInt(correct.substring(3,5));\\n\\n        int [] time = {60,15,5,1};\\n\\n        for(int i=0;i<time.length;i++){\\n            while (cor-cur>=time[i])\\n            {\\n                result++;\\n                cur+=time[i];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int result=0;\\n\\n        int cur = Integer.parseInt(current.substring(0,2))*60+Integer.parseInt(current.substring(3,5));\\n\\n        int cor = Integer.parseInt(correct.substring(0,2))*60+Integer.parseInt(correct.substring(3,5));\\n\\n        int [] time = {60,15,5,1};\\n\\n        for(int i=0;i<time.length;i++){\\n            while (cor-cur>=time[i])\\n            {\\n                result++;\\n                cur+=time[i];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659381,
                "title": "2224-minimum-number-of-operations-to-convert-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n       \\n       int hour1 = Integer.parseInt(current.substring(0,2));\\n       int min1  = Integer.parseInt(current.substring(3));\\n       int hour2 = Integer.parseInt(correct.substring(0,2));\\n       int min2  = Integer.parseInt(correct.substring(3));\\n\\n       int time1 =  hour1*60 + min1;\\n       int time2 =  hour2*60 + min2;\\n\\n       int required = Math.abs(time2-time1);\\n       int count=0;\\n\\n       while(required != 0){\\n           if(required >= 60){\\n               required -= 60;\\n           }\\n           else if(required >=15){\\n               required -= 15;\\n           }\\n           else if(required >= 5){\\n               required -= 5;\\n           }\\n           else{\\n               required -= 1;\\n           }\\n           count++;\\n       }\\n       return count;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n       \\n       int hour1 = Integer.parseInt(current.substring(0,2));\\n       int min1  = Integer.parseInt(current.substring(3));\\n       int hour2 = Integer.parseInt(correct.substring(0,2));\\n       int min2  = Integer.parseInt(correct.substring(3));\\n\\n       int time1 =  hour1*60 + min1;\\n       int time2 =  hour2*60 + min2;\\n\\n       int required = Math.abs(time2-time1);\\n       int count=0;\\n\\n       while(required != 0){\\n           if(required >= 60){\\n               required -= 60;\\n           }\\n           else if(required >=15){\\n               required -= 15;\\n           }\\n           else if(required >= 5){\\n               required -= 5;\\n           }\\n           else{\\n               required -= 1;\\n           }\\n           count++;\\n       }\\n       return count;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643935,
                "title": "bfs-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool vis[1500];\\n    int convertStringTimeToInt(string timeString){\\n        int pos = timeString.find(\":\");\\n        int hours = stoi(timeString.substr(0,pos));\\n        int mins = stoi(timeString.substr(pos+1,timeString.size()));\\n        \\n        mins = hours*60 + mins;\\n        \\n        return mins;\\n    }\\n    \\n    \\n    int convertTime(string current, string correct) {\\n          vector<int> operations = {1,5,15,60};\\n         int ct = convertStringTimeToInt(current);\\n         int cti = convertStringTimeToInt(correct);\\n         \\n         queue<int> q;\\n        q.push(cti);\\n        \\n        int level=0;\\n        \\n        while(q.size()){\\n          \\n            int s=q.size();\\n            while(s--){\\n                int c=q.front();\\n                q.pop();\\n                \\n                if(c==ct) return level;\\n                \\n                if(vis[c]==true || c<0) continue;\\n                \\n                vis[c]=true;\\n                \\n                for(int i=0;i<operations.size();i++)\\n                      if(c-operations[i]>=0)\\n                      q.push(c-operations[i]);\\n                \\n               }\\n            level++;\\n       \\n        }\\n        return level;\\n    }\\n};\\n// we can surely do with beadth first search\\n\\n// time into minues ok \\n```\\n\\n",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool vis[1500];\\n    int convertStringTimeToInt(string timeString){\\n        int pos = timeString.find(\":\");\\n        int hours = stoi(timeString.substr(0,pos));\\n        int mins = stoi(timeString.substr(pos+1,timeString.size()));\\n        \\n        mins = hours*60 + mins;\\n        \\n        return mins;\\n    }\\n    \\n    \\n    int convertTime(string current, string correct) {\\n          vector<int> operations = {1,5,15,60};\\n         int ct = convertStringTimeToInt(current);\\n         int cti = convertStringTimeToInt(correct);\\n         \\n         queue<int> q;\\n        q.push(cti);\\n        \\n        int level=0;\\n        \\n        while(q.size()){\\n          \\n            int s=q.size();\\n            while(s--){\\n                int c=q.front();\\n                q.pop();\\n                \\n                if(c==ct) return level;\\n                \\n                if(vis[c]==true || c<0) continue;\\n                \\n                vis[c]=true;\\n                \\n                for(int i=0;i<operations.size();i++)\\n                      if(c-operations[i]>=0)\\n                      q.push(c-operations[i]);\\n                \\n               }\\n            level++;\\n       \\n        }\\n        return level;\\n    }\\n};\\n// we can surely do with beadth first search\\n\\n// time into minues ok \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592245,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        \\n        int currentHours = 0;\\n        int currentMinute = 0;\\n        int correctHours = 0;\\n        int correctMinute = 0;   \\n        \\n        int i = 0;\\n        \\n        while(current[i] != \\':\\') {\\n            currentHours = currentHours * 10 + (current[i] - \\'0\\');\\n            ++i;\\n        }     \\n        ++i;\\n        while(i < current.size()) {\\n            currentMinute = currentMinute * 10 + (current[i] - \\'0\\');\\n            ++i;\\n        }\\n        \\n        int j = 0;\\n        while(correct[j] != \\':\\') {\\n            correctHours = correctHours * 10 + (correct[j] - \\'0\\');\\n            ++j;\\n        }\\n        ++j;\\n        while(j < correct.size()) {\\n            correctMinute = correctMinute * 10 + (correct[j] - \\'0\\');\\n            ++j;\\n        }\\n        \\n        currentMinute += currentHours * 60;\\n        correctMinute += correctHours * 60;\\n        vector<int> minutes = {60, 15, 5, 1};\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < 4; ++i) {\\n            \\n              int minute = minutes[i];\\n            while(currentMinute < correctMinute) {\\n                currentMinute += minute;\\n                count++;\\n            }\\n\\n            if(currentMinute == correctMinute) {\\n                return count;\\n            }\\n\\n            currentMinute -= minute;\\n            count--;\\n        }\\n        \\n        return 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        \\n        int currentHours = 0;\\n        int currentMinute = 0;\\n        int correctHours = 0;\\n        int correctMinute = 0;   \\n        \\n        int i = 0;\\n        \\n        while(current[i] != \\':\\') {\\n            currentHours = currentHours * 10 + (current[i] - \\'0\\');\\n            ++i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3587174,
                "title": "javascript-modulus-division-remainder-57-ms-beats-80",
                "content": "```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nvar convertTime = function(current, correct) {\\n    a = Number(current.split(\\':\\').at(0)) * 60 + Number(current.split(\\':\\').at(1))\\n    b = Number(correct.split(\\':\\').at(0)) * 60 + Number(correct.split(\\':\\').at(1))    \\n    time = b - a\\n    count = 0    \\n          \\n    count += Math.floor(time / 60), time = time % 60\\n    count += Math.floor(time / 15), time = time % 15\\n    count += Math.floor(time / 5), time = time % 5\\n    count += time\\n\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nvar convertTime = function(current, correct) {\\n    a = Number(current.split(\\':\\').at(0)) * 60 + Number(current.split(\\':\\').at(1))\\n    b = Number(correct.split(\\':\\').at(0)) * 60 + Number(correct.split(\\':\\').at(1))    \\n    time = b - a\\n    count = 0    \\n          \\n    count += Math.floor(time / 60), time = time % 60\\n    count += Math.floor(time / 15), time = time % 15\\n    count += Math.floor(time / 5), time = time % 5\\n    count += time\\n\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3581668,
                "title": "c-intuitive-and-concise-with-explanation-why-greedy-work",
                "content": "greedy choose current viable max value\\n\\nThink about :\\nwe can use [1,5,15,60],for some number 60+X,\\n60+X = 60(1) + X = 15(4) + X = 5(12) + X = 1(60) + X\\n\\nif we can only use:\\n[1,4,5] , we can\\'t use greedy method.\\n\\n5+X = 5(1)+X = 4(1)+(X+1) = 1(5) + X\\nthink about X = 3\\n5+3 = 8 = 5(1) + 3 = 4(1) + (3+1) = 1(5) +3\\n\\n# Code\\n```\\n//============================================\\n// Greedy\\nclass Solution {\\n\\npublic:\\n    int convertTime(string current, string correct) {\\n\\n        vector<int> s_int(5);\\n\\n        //count differ , just do it.\\n        for(int i{};i<5;i++){\\n            s_int[i] = correct[i]-current[i];\\n        }\\n\\n        int hour,min;\\n        hour = s_int[0]*10+s_int[1];\\n        min  = s_int[3]*10+s_int[4];\\n        if(min<0) hour-=1,min+=60;\\n        \\n        return hour + min/15 + (min%15)/5 + (min%15%5);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//============================================\\n// Greedy\\nclass Solution {\\n\\npublic:\\n    int convertTime(string current, string correct) {\\n\\n        vector<int> s_int(5);\\n\\n        //count differ , just do it.\\n        for(int i{};i<5;i++){\\n            s_int[i] = correct[i]-current[i];\\n        }\\n\\n        int hour,min;\\n        hour = s_int[0]*10+s_int[1];\\n        min  = s_int[3]*10+s_int[4];\\n        if(min<0) hour-=1,min+=60;\\n        \\n        return hour + min/15 + (min%15)/5 + (min%15%5);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558466,
                "title": "easy-python-solution-time-complexity-o-1",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Split the current and correct strings at the colon (\":\") delimiter using the split method. The resulting substrings are assigned to curr and corr variables, respectively.\\n\\n2. The time values in curr and corr are converted to minutes by multiplying the hour part by 60 and adding the minute part. These converted values are assigned to cur_time and cor_time variables, respectively.\\n\\n3. The code enters a while loop that continues until cur_time becomes equal to or greater than cor_time.\\n\\n4. Within each iteration of the while loop, the code checks multiple conditions in a specific order to decide which operation to perform:\\n\\n5. Once the while loop completes, the function returns the value of ans, representing the minimum number of operations needed to convert the current time to the correct time.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def convertTime(self, current, correct):\\n        \"\"\"\\n        :type current: str\\n        :type correct: str\\n        :rtype: int\\n        \"\"\"\\n        curr = current.split(\":\")\\n        corr = correct.split(\":\")\\n        ans = 0\\n        cur_time = int(curr[0])*60 + int(curr[1])\\n        cor_time = int(corr[0])*60 + int(corr[1])\\n        while cur_time < cor_time:\\n            if cur_time + 60 <= cor_time:\\n                cur_time += 60\\n            elif cur_time + 15 <= cor_time:\\n                cur_time += 15\\n            elif cur_time + 5 <= cor_time:\\n                cur_time += 5\\n            elif cur_time + 1 <= cor_time:\\n                cur_time += 1\\n            ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def convertTime(self, current, correct):\\n        \"\"\"\\n        :type current: str\\n        :type correct: str\\n        :rtype: int\\n        \"\"\"\\n        curr = current.split(\":\")\\n        corr = correct.split(\":\")\\n        ans = 0\\n        cur_time = int(curr[0])*60 + int(curr[1])\\n        cor_time = int(corr[0])*60 + int(corr[1])\\n        while cur_time < cor_time:\\n            if cur_time + 60 <= cor_time:\\n                cur_time += 60\\n            elif cur_time + 15 <= cor_time:\\n                cur_time += 15\\n            elif cur_time + 5 <= cor_time:\\n                cur_time += 5\\n            elif cur_time + 1 <= cor_time:\\n                cur_time += 1\\n            ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553605,
                "title": "simple-ruby-solution",
                "content": "# Complexity\\n- Time complexity: O(1)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n# @param {String} current\\n# @param {String} correct\\n# @return {Integer}\\ndef convert_time(current, correct)\\n    curr = current.split(\\':\\')\\n    corr = correct.split(\\':\\')\\n    diff = corr[0].to_i*60 - curr[0].to_i*60 + corr[1].to_i - curr[1].to_i\\n    incs = [60, 15, 5, 1]\\n    ops = 0\\n    for i in incs do\\n        if diff == 0 then\\n            break\\n        end\\n        units = (diff/i).to_i\\n        diff = diff - units*i\\n        ops += units\\n    end\\n    return ops\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} current\\n# @param {String} correct\\n# @return {Integer}\\ndef convert_time(current, correct)\\n    curr = current.split(\\':\\')\\n    corr = correct.split(\\':\\')\\n    diff = corr[0].to_i*60 - curr[0].to_i*60 + corr[1].to_i - curr[1].to_i\\n    incs = [60, 15, 5, 1]\\n    ops = 0\\n    for i in incs do\\n        if diff == 0 then\\n            break\\n        end\\n        units = (diff/i).to_i\\n        diff = diff - units*i\\n        ops += units\\n    end\\n    return ops\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3547207,
                "title": "best-solution-in-o-1-time-and-space-complexity-100-correct-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConvert each time into minutes and then check the time difference between correct and current time.Then check how can we divide the difference into multiples of 1,5,15,60.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        string a=current.substr(0,2);\\n        //cout<<a<<endl;\\n        string b=correct.substr(0,2);\\n        //cout<<b<<endl;\\n        string c=current.substr(3);\\n        //cout<<c<<endl;\\n        string d=correct.substr(3);\\n        //cout<<d<<endl;\\n        int ans=((stoi(b)-stoi(a))*60)+(stoi(d)-stoi(c));\\n        \\n            \\n            //cout<<ans<<endl;\\n            //cout<<ans/60<<endl;\\n            //cout<<(ans%60)/15<<endl;\\n            //cout<<(ans%15)/5<<endl;\\n            //cout<<(ans%5)<<endl;\\n            return (ans/60)+(ans%60)/15+(ans%15)/5+(ans%5);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        string a=current.substr(0,2);\\n        //cout<<a<<endl;\\n        string b=correct.substr(0,2);\\n        //cout<<b<<endl;\\n        string c=current.substr(3);\\n        //cout<<c<<endl;\\n        string d=correct.substr(3);\\n        //cout<<d<<endl;\\n        int ans=((stoi(b)-stoi(a))*60)+(stoi(d)-stoi(c));\\n        \\n            \\n            //cout<<ans<<endl;\\n            //cout<<ans/60<<endl;\\n            //cout<<(ans%60)/15<<endl;\\n            //cout<<(ans%15)/5<<endl;\\n            //cout<<(ans%5)<<endl;\\n            return (ans/60)+(ans%60)/15+(ans%15)/5+(ans%5);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3540528,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        auto cur = ((current[0] - \\'0\\') * 10 + (current[1] - \\'0\\')) * 60 + (current[3] - \\'0\\') * 10 + (current[4] - \\'0\\');\\n        auto cor = ((correct[0] - \\'0\\') * 10 + (correct[1] - \\'0\\')) * 60 + (correct[3] - \\'0\\') * 10 + (correct[4] - \\'0\\');\\n        auto diff = cor - cur;\\n        return diff / 60 + diff % 60 / 15 + diff % 60 % 15 / 5 + diff % 60 % 15 % 5;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        auto cur = ((current[0] - \\'0\\') * 10 + (current[1] - \\'0\\')) * 60 + (current[3] - \\'0\\') * 10 + (current[4] - \\'0\\');\\n        auto cor = ((correct[0] - \\'0\\') * 10 + (correct[1] - \\'0\\')) * 60 + (correct[3] - \\'0\\') * 10 + (correct[4] - \\'0\\');\\n        auto diff = cor - cur;\\n        return diff / 60 + diff % 60 / 15 + diff % 60 % 15 / 5 + diff % 60 % 15 % 5;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538346,
                "title": "simple-kotlin-solution-for-beginners",
                "content": "```\\nclass Solution {\\n    fun convertTime(current: String, correct: String): Int {\\n        val hr1 = current.substring(0, 2).toInt()\\n        val min1 = current.substring(3, 5).toInt()\\n        val hr2 = correct.substring(0, 2).toInt()\\n        val min2 = correct.substring(3, 5).toInt()\\n        val mins = (hr2 - hr1) * 60 + (min2 - min1)\\n        return mins / 60 + (mins % 60) / 15 + (mins % 15) / 5 + (mins % 5)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun convertTime(current: String, correct: String): Int {\\n        val hr1 = current.substring(0, 2).toInt()\\n        val min1 = current.substring(3, 5).toInt()\\n        val hr2 = correct.substring(0, 2).toInt()\\n        val min2 = correct.substring(3, 5).toInt()\\n        val mins = (hr2 - hr1) * 60 + (min2 - min1)\\n        return mins / 60 + (mins % 60) / 15 + (mins % 15) / 5 + (mins % 5)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524387,
                "title": "beats-97-simple-javascript-solution",
                "content": "# Simple Javascript Solution\\n```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nvar convertTime = function (current, correct) {\\n    let currentArr = current.split(\":\")\\n    let currentMins = Number(currentArr[0]) * 60 + Number(currentArr[1]) \\n\\n    let correctArr = correct.split(\":\")\\n    let correctMins = Number(correctArr[0]) * 60 + Number(correctArr[1])\\n\\n    let noOfOperations = 0\\n    let deltaTime = correctMins - currentMins\\n\\n    while (deltaTime > 0) {\\n        if (deltaTime >= 60) currentMins += 60\\n        else if (deltaTime >= 15) currentMins += 15\\n        else if (deltaTime >= 5) currentMins += 5\\n        else if (deltaTime >= 1) currentMins += 1\\n\\n        deltaTime = correctMins - currentMins\\n        noOfOperations++\\n    };\\n    return noOfOperations\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nvar convertTime = function (current, correct) {\\n    let currentArr = current.split(\":\")\\n    let currentMins = Number(currentArr[0]) * 60 + Number(currentArr[1]) \\n\\n    let correctArr = correct.split(\":\")\\n    let correctMins = Number(correctArr[0]) * 60 + Number(correctArr[1])\\n\\n    let noOfOperations = 0\\n    let deltaTime = correctMins - currentMins\\n\\n    while (deltaTime > 0) {\\n        if (deltaTime >= 60) currentMins += 60\\n        else if (deltaTime >= 15) currentMins += 15\\n        else if (deltaTime >= 5) currentMins += 5\\n        else if (deltaTime >= 1) currentMins += 1\\n\\n        deltaTime = correctMins - currentMins\\n        noOfOperations++\\n    };\\n    return noOfOperations\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3493838,
                "title": "very-simple-solution",
                "content": "# Code\\n```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nvar convertTime = function(current, correct) {\\n    var currentSplit = current.split(\":\");\\n    var correctSplit = correct.split(\":\");\\n    var currentMins = parseInt(currentSplit[0]) * 60 + parseInt(currentSplit[1]);\\n    var correctMins = parseInt(correctSplit[0]) * 60 + parseInt(correctSplit[1]);\\n    var differenceMins = (correctMins - currentMins);\\n\\n    // 60 Minutes\\n    var count60 = Math.floor(differenceMins / 60);\\n    differenceMins -= count60 * 60;\\n\\n    // 15 Minutes\\n    var count15 = Math.floor(differenceMins / 15);\\n    differenceMins -= count15 * 15;\\n    \\n    // 5 Minutes\\n    var count5 = Math.floor(differenceMins / 5);\\n    differenceMins -= count5 * 5;\\n    \\n    // 1 Minutes\\n    var count1 = Math.floor(differenceMins);\\n    \\n    return count60 + count15 + count5 + count1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nvar convertTime = function(current, correct) {\\n    var currentSplit = current.split(\":\");\\n    var correctSplit = correct.split(\":\");\\n    var currentMins = parseInt(currentSplit[0]) * 60 + parseInt(currentSplit[1]);\\n    var correctMins = parseInt(correctSplit[0]) * 60 + parseInt(correctSplit[1]);\\n    var differenceMins = (correctMins - currentMins);\\n\\n    // 60 Minutes\\n    var count60 = Math.floor(differenceMins / 60);\\n    differenceMins -= count60 * 60;\\n\\n    // 15 Minutes\\n    var count15 = Math.floor(differenceMins / 15);\\n    differenceMins -= count15 * 15;\\n    \\n    // 5 Minutes\\n    var count5 = Math.floor(differenceMins / 5);\\n    differenceMins -= count5 * 5;\\n    \\n    // 1 Minutes\\n    var count1 = Math.floor(differenceMins);\\n    \\n    return count60 + count15 + count5 + count1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3492396,
                "title": "best-solution-with-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc convertTime(current string, correct string) int {\\n\\tif current == correct {\\n\\t\\treturn 0\\n\\t}\\n\\thour, _ := strconv.Atoi(current[:2])\\n\\tthour, _ := strconv.Atoi(correct[:2])\\n\\tminute, _ := strconv.Atoi(current[3:])\\n\\ttminute, _ := strconv.Atoi(correct[3:])\\n\\ttarget := thour*60 + tminute\\n\\tfrom := hour*60 + minute\\n\\treturn timeTakes(target-from, 0)\\n\\n}\\n\\nfunc timeTakes(minute int, operation int) int {\\n\\n\\tif minute == 0 {\\n\\t\\treturn operation\\n\\t}\\n\\n\\tif minute >= 60 {\\n\\t\\treturn timeTakes(minute%60, operation+(minute/60))\\n\\t} else if minute >= 15 {\\n\\t\\treturn timeTakes(minute%15, operation+(minute/15))\\n\\t} else if minute >= 5 {\\n\\t\\treturn timeTakes(minute%5, operation+(minute/5))\\n\\t} else {\\n\\t\\treturn timeTakes(minute%1, operation+(minute/1))\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Greedy"
                ],
                "code": "```\\nfunc convertTime(current string, correct string) int {\\n\\tif current == correct {\\n\\t\\treturn 0\\n\\t}\\n\\thour, _ := strconv.Atoi(current[:2])\\n\\tthour, _ := strconv.Atoi(correct[:2])\\n\\tminute, _ := strconv.Atoi(current[3:])\\n\\ttminute, _ := strconv.Atoi(correct[3:])\\n\\ttarget := thour*60 + tminute\\n\\tfrom := hour*60 + minute\\n\\treturn timeTakes(target-from, 0)\\n\\n}\\n\\nfunc timeTakes(minute int, operation int) int {\\n\\n\\tif minute == 0 {\\n\\t\\treturn operation\\n\\t}\\n\\n\\tif minute >= 60 {\\n\\t\\treturn timeTakes(minute%60, operation+(minute/60))\\n\\t} else if minute >= 15 {\\n\\t\\treturn timeTakes(minute%15, operation+(minute/15))\\n\\t} else if minute >= 5 {\\n\\t\\treturn timeTakes(minute%5, operation+(minute/5))\\n\\t} else {\\n\\t\\treturn timeTakes(minute%1, operation+(minute/1))\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486506,
                "title": "js-converttime-noodkhan-navin",
                "content": "```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\n```\\n```\\nfunction getmin(min1, min2, ops) {\\n  var A = min1;\\n  var B = min2;\\n  while (A < B && A + 15 <= B) {\\n    ops++;\\n    A += 15;\\n  }\\n  while (A < B && A + 5 <= B) {\\n    ops++;\\n    A += 5;\\n  }\\n  while (A < B) {\\n    ops++;\\n    A++;\\n  }\\n  return ops;\\n}\\n\\nfunction getpair(input, arr) {\\n  var hours = [];\\n  var mins = [];\\n  hours.push(input[0], input[1]);\\n  mins.push(input[input.length - 2], input[input.length - 1]);\\n  var h = +hours.join(\"\");\\n  var m = +mins.join(\"\");\\n  arr.push([h, m]);\\n  return arr;\\n}\\n\\nvar convertTime = function (current, correct) {\\n  if (current === correct) {\\n    return 0;\\n  }\\n  var ops = 0;\\n  var arr = [];\\n  getpair(current, arr);\\n  getpair(correct, arr);\\n  var cur = arr[0];\\n  var cor = arr[1];\\n  var X = cur[1];\\n  var Y = cor[1];\\n  while (cor[0] > cur[0]) {\\n    ops++;\\n    cur[0]++;\\n  }\\n  if (cor[1] > cur[1]) {\\n    return getmin(X, Y, ops);\\n  }\\n  if (Y < X && cur[0] < cor[0]) {\\n    return getmin(X, Y + 60, ops);\\n  } else {\\n    if (cor[1] !== cur[1]) {\\n      return getmin(X, Y + 60, ops) - 1;\\n    }\\n  }\\n  return ops;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\n```\n```\\nfunction getmin(min1, min2, ops) {\\n  var A = min1;\\n  var B = min2;\\n  while (A < B && A + 15 <= B) {\\n    ops++;\\n    A += 15;\\n  }\\n  while (A < B && A + 5 <= B) {\\n    ops++;\\n    A += 5;\\n  }\\n  while (A < B) {\\n    ops++;\\n    A++;\\n  }\\n  return ops;\\n}\\n\\nfunction getpair(input, arr) {\\n  var hours = [];\\n  var mins = [];\\n  hours.push(input[0], input[1]);\\n  mins.push(input[input.length - 2], input[input.length - 1]);\\n  var h = +hours.join(\"\");\\n  var m = +mins.join(\"\");\\n  arr.push([h, m]);\\n  return arr;\\n}\\n\\nvar convertTime = function (current, correct) {\\n  if (current === correct) {\\n    return 0;\\n  }\\n  var ops = 0;\\n  var arr = [];\\n  getpair(current, arr);\\n  getpair(correct, arr);\\n  var cur = arr[0];\\n  var cor = arr[1];\\n  var X = cur[1];\\n  var Y = cor[1];\\n  while (cor[0] > cur[0]) {\\n    ops++;\\n    cur[0]++;\\n  }\\n  if (cor[1] > cur[1]) {\\n    return getmin(X, Y, ops);\\n  }\\n  if (Y < X && cur[0] < cor[0]) {\\n    return getmin(X, Y + 60, ops);\\n  } else {\\n    if (cor[1] !== cur[1]) {\\n      return getmin(X, Y + 60, ops) - 1;\\n    }\\n  }\\n  return ops;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3462077,
                "title": "java-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n\\n        int h = Integer.parseInt(current.substring(0,2));\\n        int m = Integer.parseInt(current.substring(3,5));\\n        int cur = (h*60) + m;\\n\\n        int h1 = Integer.parseInt(correct.substring(0,2));\\n        int m1 = Integer.parseInt(correct.substring(3,5));\\n        int cor = (h1*60) + m1;\\n\\n        return helper(cur, cor, 0);\\n    }\\n    int helper(int cur, int cor, int ans)\\n    {\\n        if(cur == cor)\\n            return ans;\\n\\n        if(cur+60 <= cor)\\n            return helper(cur+60, cor, ans+1);\\n\\n        if(cur+15 <= cor)\\n            return helper(cur+15, cor, ans+1);\\n\\n        if(cur+5 <= cor)\\n            return helper(cur+5, cor, ans+1);\\n\\n        if(cur+1 <= cor)\\n            return helper(cur+1, cor, ans+1);\\n\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n\\n        int h = Integer.parseInt(current.substring(0,2));\\n        int m = Integer.parseInt(current.substring(3,5));\\n        int cur = (h*60) + m;\\n\\n        int h1 = Integer.parseInt(correct.substring(0,2));\\n        int m1 = Integer.parseInt(correct.substring(3,5));\\n        int cor = (h1*60) + m1;\\n\\n        return helper(cur, cor, 0);\\n    }\\n    int helper(int cur, int cor, int ans)\\n    {\\n        if(cur == cor)\\n            return ans;\\n\\n        if(cur+60 <= cor)\\n            return helper(cur+60, cor, ans+1);\\n\\n        if(cur+15 <= cor)\\n            return helper(cur+15, cor, ans+1);\\n\\n        if(cur+5 <= cor)\\n            return helper(cur+5, cor, ans+1);\\n\\n        if(cur+1 <= cor)\\n            return helper(cur+1, cor, ans+1);\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460658,
                "title": "java-straightforward-and-short-version",
                "content": "```\\n    public int convertTime(String fromStr, String toStr) {\\n        var fromH = Integer.parseInt(fromStr.split(\":\")[0]);\\n        var fromM = Integer.parseInt(fromStr.split(\":\")[1]);\\n        var toH   = Integer.parseInt(toStr.split(\":\")[0]);\\n        var toM   = Integer.parseInt(toStr.split(\":\")[1]);\\n        var diffH = toH-fromH;\\n        var diffM = toM-fromM+diffH*60;\\n        var res = 0;\\n        while (diffM>0){\\n            if (diffM>=60){\\n                res++;diffM-=60;\\n            } else if (diffM>=15){\\n                res++;diffM-=15;\\n            } else if (diffM>=5){\\n                res++;diffM-=5;\\n            } else {\\n                res+=diffM;diffM=0;\\n            }\\n        }\\n        return res;\\n    }\\n```\\nand short version\\n```\\n    public int convertTime(String f, String t) {\\n        String[] from=f.split(\":\"), to=t.split(\":\");\\n        int fromH = Integer.parseInt(from[0]), fromM = Integer.parseInt(from[1]),\\n            toH   = Integer.parseInt(to[0]),   toM   = Integer.parseInt(to[1]),\\n            diffH = toH-fromH,                 diffM = toM-fromM+diffH*60;\\n        return diffM/60+(diffM%60)/15+((diffM%60)%15)/5+((diffM%60)%15)%5;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public int convertTime(String fromStr, String toStr) {\\n        var fromH = Integer.parseInt(fromStr.split(\":\")[0]);\\n        var fromM = Integer.parseInt(fromStr.split(\":\")[1]);\\n        var toH   = Integer.parseInt(toStr.split(\":\")[0]);\\n        var toM   = Integer.parseInt(toStr.split(\":\")[1]);\\n        var diffH = toH-fromH;\\n        var diffM = toM-fromM+diffH*60;\\n        var res = 0;\\n        while (diffM>0){\\n            if (diffM>=60){\\n                res++;diffM-=60;\\n            } else if (diffM>=15){\\n                res++;diffM-=15;\\n            } else if (diffM>=5){\\n                res++;diffM-=5;\\n            } else {\\n                res+=diffM;diffM=0;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n    public int convertTime(String f, String t) {\\n        String[] from=f.split(\":\"), to=t.split(\":\");\\n        int fromH = Integer.parseInt(from[0]), fromM = Integer.parseInt(from[1]),\\n            toH   = Integer.parseInt(to[0]),   toM   = Integer.parseInt(to[1]),\\n            diffH = toH-fromH,                 diffM = toM-fromM+diffH*60;\\n        return diffM/60+(diffM%60)/15+((diffM%60)%15)/5+((diffM%60)%15)%5;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3440700,
                "title": "c-short",
                "content": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct)\\n    {\\n        int diff =\\n            + ((correct[0] - \\'0\\') * 10 + (correct[1] - \\'0\\')) * 60\\n            + ((correct[3] - \\'0\\') * 10 + (correct[4] - \\'0\\'))\\n            - ((current[0] - \\'0\\') * 10 + (current[1] - \\'0\\')) * 60\\n            - ((current[3] - \\'0\\') * 10 + (current[4] - \\'0\\'));\\n\\n        int ans = 0;\\n        for (auto i : { 60, 15, 5, 1 })\\n        {\\n            int c = diff / i;\\n            diff -= c*i, ans+=c;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct)\\n    {\\n        int diff =\\n            + ((correct[0] - \\'0\\') * 10 + (correct[1] - \\'0\\')) * 60\\n            + ((correct[3] - \\'0\\') * 10 + (correct[4] - \\'0\\'))\\n            - ((current[0] - \\'0\\') * 10 + (current[1] - \\'0\\')) * 60\\n            - ((current[3] - \\'0\\') * 10 + (current[4] - \\'0\\'));\\n\\n        int ans = 0;\\n        for (auto i : { 60, 15, 5, 1 })\\n        {\\n            int c = diff / i;\\n            diff -= c*i, ans+=c;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436858,
                "title": "beginner-level-solution-beats-94-12-runtime",
                "content": "# Intuition\\n1. Calculate the difference in terms of minutes.\\n2. Run through the list of correction and apply correction steps 1 by 1, from largest -> smallest.\\n3. Keep track of the counter.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def convertTime(self, current, correct):\\n        \"\"\"\\n        :type current: str\\n        :type correct: str\\n        :rtype: int\\n        \"\"\"\\n\\n        if current == correct: return 0\\n\\n        hh1 = int(current[:2])\\n        mm1 = int(current[-2:])\\n        hh2 = int(correct[:2])\\n        mm2 = int(correct[-2:])\\n\\n        correction = [1,5,15,60]\\n\\n        diff = (hh2-hh1) * 60 + (mm2 - mm1)\\n\\n        cntr = 0\\n        i = 3\\n        while diff > 0:\\n            while diff >= correction[i]:\\n                diff -= correction[i]\\n                cntr += 1\\n            i -= 1\\n\\n        return cntr\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def convertTime(self, current, correct):\\n        \"\"\"\\n        :type current: str\\n        :type correct: str\\n        :rtype: int\\n        \"\"\"\\n\\n        if current == correct: return 0\\n\\n        hh1 = int(current[:2])\\n        mm1 = int(current[-2:])\\n        hh2 = int(correct[:2])\\n        mm2 = int(correct[-2:])\\n\\n        correction = [1,5,15,60]\\n\\n        diff = (hh2-hh1) * 60 + (mm2 - mm1)\\n\\n        cntr = 0\\n        i = 3\\n        while diff > 0:\\n            while diff >= correction[i]:\\n                diff -= correction[i]\\n                cntr += 1\\n            i -= 1\\n\\n        return cntr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435143,
                "title": "beginner-friendly-java-solution-beats-94",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n      int minInCurr=Integer.parseInt(current.substring(0,current.length()-3))*60 +Integer.parseInt(current.substring(current.length()-2,current.length()));\\n      int minInCorr=Integer.parseInt(correct.substring(0,correct.length()-3))*60 +Integer.parseInt(correct.substring(correct.length()-2,correct.length()));\\n      int diff=minInCorr-minInCurr;\\n      int count=0;\\n      while(diff>0){\\n          if(diff>=60){\\n              count++;\\n              diff=diff-60;\\n          }else if(diff>=15){\\n              count++;\\n              diff=diff-15;\\n          }else if(diff>=5){\\n              count++;\\n              diff=diff-5;\\n          }else {\\n              count++;\\n              diff=diff-1;\\n          }\\n      }\\n      return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n      int minInCurr=Integer.parseInt(current.substring(0,current.length()-3))*60 +Integer.parseInt(current.substring(current.length()-2,current.length()));\\n      int minInCorr=Integer.parseInt(correct.substring(0,correct.length()-3))*60 +Integer.parseInt(correct.substring(correct.length()-2,correct.length()));\\n      int diff=minInCorr-minInCurr;\\n      int count=0;\\n      while(diff>0){\\n          if(diff>=60){\\n              count++;\\n              diff=diff-60;\\n          }else if(diff>=15){\\n              count++;\\n              diff=diff-15;\\n          }else if(diff>=5){\\n              count++;\\n              diff=diff-5;\\n          }else {\\n              count++;\\n              diff=diff-1;\\n          }\\n      }\\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3429988,
                "title": "beats-100-simple-solution-string-to-num",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n       int curr=((current[0]-\\'0\\')*10+(current[1]-\\'0\\'))*60+((current[3]-\\'0\\')*10+(current[4]-\\'0\\'));\\n       int corr=((correct[0]-\\'0\\')*10+(correct[1]-\\'0\\'))*60+((correct[3]-\\'0\\')*10+(correct[4]-\\'0\\')); \\n       int diff=corr-curr;\\n       int count=0;\\n       while(diff)\\n       {\\n       if(diff>=60)\\n       {\\n         diff=diff-60;\\n         count++;\\n       }\\n       else if(diff>=15&&diff<60)\\n            {\\n                diff=diff-15;\\n                count++;\\n            }\\n       else if(diff>=5&&diff<15)\\n             {\\n                 diff=diff-5;\\n                 count++;\\n             }\\n        else\\n        {\\n            diff=diff-1;\\n            count++;\\n        }     \\n       }\\n       return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n       int curr=((current[0]-\\'0\\')*10+(current[1]-\\'0\\'))*60+((current[3]-\\'0\\')*10+(current[4]-\\'0\\'));\\n       int corr=((correct[0]-\\'0\\')*10+(correct[1]-\\'0\\'))*60+((correct[3]-\\'0\\')*10+(correct[4]-\\'0\\')); \\n       int diff=corr-curr;\\n       int count=0;\\n       while(diff)\\n       {\\n       if(diff>=60)\\n       {\\n         diff=diff-60;\\n         count++;\\n       }\\n       else if(diff>=15&&diff<60)\\n            {\\n                diff=diff-15;\\n                count++;\\n            }\\n       else if(diff>=5&&diff<15)\\n             {\\n                 diff=diff-5;\\n                 count++;\\n             }\\n        else\\n        {\\n            diff=diff-1;\\n            count++;\\n        }     \\n       }\\n       return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419271,
                "title": "java-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int count = 0;\\n\\n        int m = (correct.charAt(3)*10 + correct.charAt(4)) - (current.charAt(3)*10 + current.charAt(4));\\n        int h = (correct.charAt(0)*10 + correct.charAt(1)) - (current.charAt(0)*10 + current.charAt(1));\\n        int min = h*60 + m;\\n\\n        while(min > 0){\\n            if(min >= 60){\\n                min -= 60;\\n                count++;\\n            }\\n            else if(min >= 15){\\n                min -= 15;\\n                count++;\\n            }\\n            else if(min >= 5){\\n                min -= 5;\\n                count++;\\n            }\\n            else{\\n                min -= 1;\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int count = 0;\\n\\n        int m = (correct.charAt(3)*10 + correct.charAt(4)) - (current.charAt(3)*10 + current.charAt(4));\\n        int h = (correct.charAt(0)*10 + correct.charAt(1)) - (current.charAt(0)*10 + current.charAt(1));\\n        int min = h*60 + m;\\n\\n        while(min > 0){\\n            if(min >= 60){\\n                min -= 60;\\n                count++;\\n            }\\n            else if(min >= 15){\\n                min -= 15;\\n                count++;\\n            }\\n            else if(min >= 5){\\n                min -= 5;\\n                count++;\\n            }\\n            else{\\n                min -= 1;\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3403576,
                "title": "javascript-solution-96",
                "content": "\\n```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nvar convertTime = function(current, correct) {\\n    let [h1,m1]=current.split(\":\")\\n    let [h2,m2]=correct.split(\":\")\\n    let diff = (h2-h1)*60+(m2-m1)\\n    \\n    let operations = 0\\n    while (diff>=60){\\n    diff -=60\\n    operations++\\n    }\\n    while (diff>=15){\\n    diff-=15\\n    operations++\\n    }\\n    while (diff>=5){\\n    diff -=5\\n    operations++\\n    }\\n    while (diff>=1){\\n    diff-=1\\n    operations++\\n    }\\n    return operations\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nvar convertTime = function(current, correct) {\\n    let [h1,m1]=current.split(\":\")\\n    let [h2,m2]=correct.split(\":\")\\n    let diff = (h2-h1)*60+(m2-m1)\\n    \\n    let operations = 0\\n    while (diff>=60){\\n    diff -=60\\n    operations++\\n    }\\n    while (diff>=15){\\n    diff-=15\\n    operations++\\n    }\\n    while (diff>=5){\\n    diff -=5\\n    operations++\\n    }\\n    while (diff>=1){\\n    diff-=1\\n    operations++\\n    }\\n    return operations\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3399884,
                "title": "naive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition is pretty simple, just keep checking if the time is up or not\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHave the times in an array to easily subtract the times in decreasing order to always remove the most of amount of time possible. Have a while loop until done\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> Not sure exactly, but above O(n) and below O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        // current is formatted as HH:MM hour and minute\\n\\n        // Increase current by 1, 5, 15, 60 minutes\\n        // Split the string, turn it all into minutes\\n        // Loop for 60 -> 15 -> 5 -> 1 until 0\\n        // Return number of operations needed to get to correct\\n\\n        // CURRNENT\\n        int hr = Integer.valueOf(current.substring(0, 2))*60;\\n        int min = Integer.valueOf(current.substring(3));\\n        int total = hr+min;\\n        int[] times = {60, 15, 5, 1};\\n        int count = 0;\\n\\n        // CORRECT\\n        int hrC = Integer.valueOf(correct.substring(0, 2))*60;\\n        int minC = Integer.valueOf(correct.substring(3));\\n        int totalC = hrC+minC;\\n\\n        int finalTotal = totalC - total;\\n\\n        //System.out.println(hr);\\n        //System.out.println(min);\\n        System.out.println(hr+min); //150\\n\\n        int i = 0;\\n        while(finalTotal != 0){\\n            if(finalTotal >= times[i]){\\n                finalTotal-=times[i];\\n                count++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n\\n        return(count);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        // current is formatted as HH:MM hour and minute\\n\\n        // Increase current by 1, 5, 15, 60 minutes\\n        // Split the string, turn it all into minutes\\n        // Loop for 60 -> 15 -> 5 -> 1 until 0\\n        // Return number of operations needed to get to correct\\n\\n        // CURRNENT\\n        int hr = Integer.valueOf(current.substring(0, 2))*60;\\n        int min = Integer.valueOf(current.substring(3));\\n        int total = hr+min;\\n        int[] times = {60, 15, 5, 1};\\n        int count = 0;\\n\\n        // CORRECT\\n        int hrC = Integer.valueOf(correct.substring(0, 2))*60;\\n        int minC = Integer.valueOf(correct.substring(3));\\n        int totalC = hrC+minC;\\n\\n        int finalTotal = totalC - total;\\n\\n        //System.out.println(hr);\\n        //System.out.println(min);\\n        System.out.println(hr+min); //150\\n\\n        int i = 0;\\n        while(finalTotal != 0){\\n            if(finalTotal >= times[i]){\\n                finalTotal-=times[i];\\n                count++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n\\n        return(count);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394257,
                "title": "simple-maths-o-n-soln-upvote-for-karma",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int ans=0;\\n        if(current==correct)\\n        return 0;\\n\\n        ans=(correct[0]*10+correct[1])-(current[0]*10+current[1]);\\n\\n        int a=(correct[3]*10+correct[4]);\\n        int b=(current[3]*10+current[4]);\\n      \\n        int c=abs(a-b);\\n\\n           if(a<b){\\n          ans--;\\n          c=a+60-b;\\n           }\\n          \\n          int rem=0;\\n          rem=c/15;\\n          c=c%15;\\n          rem+=c/5;\\n          c=c%5;\\n          rem+=c;\\n\\n         \\n          ans+=rem;\\n\\n          return ans;\\n\\n    }\\n};\\n//Upvote\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int ans=0;\\n        if(current==correct)\\n        return 0;\\n\\n        ans=(correct[0]*10+correct[1])-(current[0]*10+current[1]);\\n\\n        int a=(correct[3]*10+correct[4]);\\n        int b=(current[3]*10+current[4]);\\n      \\n        int c=abs(a-b);\\n\\n           if(a<b){\\n          ans--;\\n          c=a+60-b;\\n           }\\n          \\n          int rem=0;\\n          rem=c/15;\\n          c=c%15;\\n          rem+=c/5;\\n          c=c%5;\\n          rem+=c;\\n\\n         \\n          ans+=rem;\\n\\n          return ans;\\n\\n    }\\n};\\n//Upvote\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387273,
                "title": "js-runtime-58-ms-beats-76-27-memory-41-9-mb-beats-86-44",
                "content": "# Intuition\\nBreak current and correct in chunks of 60,15,5,1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nvar convertTime = function(current, correct) {\\n    var count = 0;\\n\\n    var crtArr = current.split(\\':\\')\\n    var crcArr = correct.split(\\':\\')\\n\\n    var crtHH = Number(crtArr[0])\\n    var crcHH = Number(crcArr[0])\\n    var diffHH = crcHH - crtHH;\\n    count = count + diffHH;\\n\\n    var crtMM = Number(crtArr[1])\\n    var crcMM = Number(crcArr[1])\\n\\n    // Detect if Minutes Current > Minutes Correct\\n    if(crtMM <= crcMM){\\n        var diffMM = crcMM - crtMM\\n    }else{\\n        diffMM = crcMM + (60 - crtMM)\\n        count = count - 1\\n    }\\n\\n    var d15 = diffMM/15\\n    var remain = diffMM%15\\n    if(d15>0){\\n        count = count + Math.floor(d15)\\n    }\\n\\n    if(remain){\\n        var d5 = remain/5\\n        remain = remain%5\\n        if(d5>0){\\n             count = count + Math.floor(d5)\\n        }\\n    }\\n    if(remain){\\n        count = count + remain\\n    }\\n\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nvar convertTime = function(current, correct) {\\n    var count = 0;\\n\\n    var crtArr = current.split(\\':\\')\\n    var crcArr = correct.split(\\':\\')\\n\\n    var crtHH = Number(crtArr[0])\\n    var crcHH = Number(crcArr[0])\\n    var diffHH = crcHH - crtHH;\\n    count = count + diffHH;\\n\\n    var crtMM = Number(crtArr[1])\\n    var crcMM = Number(crcArr[1])\\n\\n    // Detect if Minutes Current > Minutes Correct\\n    if(crtMM <= crcMM){\\n        var diffMM = crcMM - crtMM\\n    }else{\\n        diffMM = crcMM + (60 - crtMM)\\n        count = count - 1\\n    }\\n\\n    var d15 = diffMM/15\\n    var remain = diffMM%15\\n    if(d15>0){\\n        count = count + Math.floor(d15)\\n    }\\n\\n    if(remain){\\n        var d5 = remain/5\\n        remain = remain%5\\n        if(d5>0){\\n             count = count + Math.floor(d5)\\n        }\\n    }\\n    if(remain){\\n        count = count + remain\\n    }\\n\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 2025730,
                "content": [
                    {
                        "username": "IliyanP",
                        "content": "Just convert the time in minutes for bot current and correct, substract current from correct as absolute value and then use while loop to substract the values\\n60,15,5,1 from the difference of current and correct"
                    },
                    {
                        "username": "bortengineer",
                        "content": "There is nothing in the description indicating that \"current should be less than or equal to correct\"."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "In one operation you can INCREASE the time"
                    },
                    {
                        "username": "shuydo12",
                        "content": "Logic absent. I decreasing 1 counter-clockwise, but no increase 23+3*15+2*5+4 in case 142 0:00 => 23:59 //32"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "According to the description, you cannot go counter-clockwise:)"
                    }
                ]
            },
            {
                "id": 1814501,
                "content": [
                    {
                        "username": "IliyanP",
                        "content": "Just convert the time in minutes for bot current and correct, substract current from correct as absolute value and then use while loop to substract the values\\n60,15,5,1 from the difference of current and correct"
                    },
                    {
                        "username": "bortengineer",
                        "content": "There is nothing in the description indicating that \"current should be less than or equal to correct\"."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "In one operation you can INCREASE the time"
                    },
                    {
                        "username": "shuydo12",
                        "content": "Logic absent. I decreasing 1 counter-clockwise, but no increase 23+3*15+2*5+4 in case 142 0:00 => 23:59 //32"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "According to the description, you cannot go counter-clockwise:)"
                    }
                ]
            },
            {
                "id": 1728432,
                "content": [
                    {
                        "username": "IliyanP",
                        "content": "Just convert the time in minutes for bot current and correct, substract current from correct as absolute value and then use while loop to substract the values\\n60,15,5,1 from the difference of current and correct"
                    },
                    {
                        "username": "bortengineer",
                        "content": "There is nothing in the description indicating that \"current should be less than or equal to correct\"."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "In one operation you can INCREASE the time"
                    },
                    {
                        "username": "shuydo12",
                        "content": "Logic absent. I decreasing 1 counter-clockwise, but no increase 23+3*15+2*5+4 in case 142 0:00 => 23:59 //32"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "According to the description, you cannot go counter-clockwise:)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Total Beauty of the Gardens",
        "question_content": "<p>Alice is a caretaker of <code>n</code> gardens and she wants to plant flowers to maximize the total beauty of all her gardens.</p>\n\n<p>You are given a <strong>0-indexed</strong> integer array <code>flowers</code> of size <code>n</code>, where <code>flowers[i]</code> is the number of flowers already planted in the <code>i<sup>th</sup></code> garden. Flowers that are already planted <strong>cannot</strong> be removed. You are then given another integer <code>newFlowers</code>, which is the <strong>maximum</strong> number of flowers that Alice can additionally plant. You are also given the integers <code>target</code>, <code>full</code>, and <code>partial</code>.</p>\n\n<p>A garden is considered <strong>complete</strong> if it has <strong>at least</strong> <code>target</code> flowers. The <strong>total beauty</strong> of the gardens is then determined as the <strong>sum</strong> of the following:</p>\n\n<ul>\n\t<li>The number of <strong>complete</strong> gardens multiplied by <code>full</code>.</li>\n\t<li>The <strong>minimum</strong> number of flowers in any of the <strong>incomplete</strong> gardens multiplied by <code>partial</code>. If there are no incomplete gardens, then this value will be <code>0</code>.</li>\n</ul>\n\n<p>Return <em>the <strong>maximum</strong> total beauty that Alice can obtain after planting at most </em><code>newFlowers</code><em> flowers.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> flowers = [1,3,1,1], newFlowers = 7, target = 6, full = 12, partial = 1\n<strong>Output:</strong> 14\n<strong>Explanation:</strong> Alice can plant\n- 2 flowers in the 0<sup>th</sup> garden\n- 3 flowers in the 1<sup>st</sup> garden\n- 1 flower in the 2<sup>nd</sup> garden\n- 1 flower in the 3<sup>rd</sup> garden\nThe gardens will then be [3,6,2,2]. She planted a total of 2 + 3 + 1 + 1 = 7 flowers.\nThere is 1 garden that is complete.\nThe minimum number of flowers in the incomplete gardens is 2.\nThus, the total beauty is 1 * 12 + 2 * 1 = 12 + 2 = 14.\nNo other way of planting flowers can obtain a total beauty higher than 14.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> flowers = [2,4,5,3], newFlowers = 10, target = 5, full = 2, partial = 6\n<strong>Output:</strong> 30\n<strong>Explanation:</strong> Alice can plant\n- 3 flowers in the 0<sup>th</sup> garden\n- 0 flowers in the 1<sup>st</sup> garden\n- 0 flowers in the 2<sup>nd</sup> garden\n- 2 flowers in the 3<sup>rd</sup> garden\nThe gardens will then be [5,4,5,5]. She planted a total of 3 + 0 + 0 + 2 = 5 flowers.\nThere are 3 gardens that are complete.\nThe minimum number of flowers in the incomplete gardens is 4.\nThus, the total beauty is 3 * 2 + 4 * 6 = 6 + 24 = 30.\nNo other way of planting flowers can obtain a total beauty higher than 30.\nNote that Alice could make all the gardens complete but in this case, she would obtain a lower total beauty.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= flowers.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= flowers[i], target &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= newFlowers &lt;= 10<sup>10</sup></code></li>\n\t<li><code>1 &lt;= full, partial &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1931085,
                "title": "python-explanation-with-pictures",
                "content": "Its clear that if we have more complete gardens, we are likely to have fewer flowers in the smallest garden. We are not sure how many complete gardens we need to maximize the score, hence we will try every possible number of complete garden. \\n\\nWe want to use fewer flowers to fill a complete garden, hence, sort gardens by the number of flowers and complete each garden from the incomplete garden that having the most flowers. \\n\\nTherefore we will \\n- **count complete gardens from tail**\\n- **maximize the incomoplete garden from head**.\\n\\nNotice that we have at most `new` flowers to plant, if we make all the gardens after `j` complete, the remaining flowers equals `new` minus the cost to make these gardens complete.\\n\\nThen we maximize the number of flowers using the updated `new`, as shown in the picture below. Hence, we have the score in this case.\\n\\n![image](https://assets.leetcode.com/users/images/96ca4435-4e56-4005-8e9f-8b0e858df43f_1649563440.3317957.png)\\n\\n\\nThen we move on to make one more complete garden, that is, to make `j-1 -th` garden as complete. If there is still flowers left after making this garden complete, we will repeat the same process to calculate the maximum minimum number of flowers.\\n\\n![image](https://assets.leetcode.com/users/images/9823acd8-32f0-4123-a9d7-d9ef24d9acfc_1649563449.1329505.png)\\n\\nHow to calculate the maximum incomplete flower?\\n\\nRecall that we split the problem into two halves, getting the cost to complete gardens after `j` is straigtforward, we just need to iterate from `n-1` to `j` and calculate the cost.\\n\\n![image](https://assets.leetcode.com/users/images/3b6a4498-a4b1-4dec-97fd-e8d123a3d8e1_1649565225.0188658.png)\\n\\nFor the second half: **maximize the incomplete flowers**, we can build an auxiliary list `cost`, as shown in the picture below. Basically, `cost[i]` stands for the total cost to make all the gardens before `i` having the same number of flowers as `garden i\\'s`. \\nFor instance, I colored the `cost[1]` in purple and you can tell the reason why `cost[1] = 2`.\\n\\n![image](https://assets.leetcode.com/users/images/2e169773-1188-4498-aaca-54eb35f787ef_1649565262.8332002.png)\\n\\nSuppose we have 6 flowers and would like to maximize the incomplete flowers. \\n- Find how many gardens will be planted using binary search. If `new` is no less than `cost[i]`, meaning we can make all the first `i` gardens having `A[i]` flowers.\\n- Check if we can increase the number of flowers in all the `i` gardens any more.\\n\\nMore details:\\n\\n![image](https://assets.leetcode.com/users/images/87fc33ad-baa2-496a-8f0b-bf88930ceece_1649565266.8852856.png)\\n\\n> In case I didn\\'t explain it well, take a look at the right hand side of the picture above. What does the `idx=3` of the binary search tell? It means that the `new=6` we have is enough to make `3` gardens having the same number of flowers\\n\\n**Steps**\\n> In short, we will stop by every incomplete garden (by decreasing order), for each garden:\\n> -  Maximize the smallest incomplete garden.\\n> -  Get the current score and update the maximum score.\\n> -  Make this garden complete, if possible and move on to the next incomplete garden.\\n\\n**Complexity**\\n`O(n logn)`.\\n`O(n)` steps in the iteration, since we have to complete at most `n` buildings before finding out the maximum score. Binary search in each step takes `O(logn)` (I think it can be reduced to `O(1)` since the minimum flower is monotonically decreasing, as we increase the number of complete gardens).\\n\\n\\n**Code**\\n```\\nclass Solution:\\n    def maximumBeauty(self, A: List[int], new: int, t: int, full: int, part: int) -> int:\\n        A = [min(t, a) for a in A]\\n        A.sort()\\n\\t\\t\\n\\t\\t# Two edge cases\\n        if min(A) == t: return full * len(A)\\n        if new >= t * len(A) - sum(A):\\n            return max(full*len(A), full*(len(A)-1) + part*(t-1))\\n        \\n\\t\\t# Build the array `cost`.\\n        cost = [0]\\n        for i in range(1, len(A)):\\n            pre = cost[-1]\\n            cost.append(pre + i * (A[i] - A[i - 1]))\\n\\n\\t\\t# Since there might be some gardens having `target` flowers already, we will skip them.\\n        j = len(A) - 1\\n        while A[j] == t:\\n            j -= 1\\n        \\n\\t\\t# Start the iteration\\n        ans = 0\\n        while new >= 0:\\n\\t\\t\\n\\t\\t\\t# idx stands for the first `j` gardens, notice a edge case might happen.\\n            idx = min(j, bisect_right(cost, new) - 1)\\n\\t\\t\\t\\n\\t\\t\\t# bar is the current minimum flower in the incomplete garden\\n            bar = A[idx] + (new - cost[idx]) // (idx + 1)\\n\\t\\t\\t\\n            ans = max(ans, bar * part + full *(len(A) - j - 1))\\n            \\n\\t\\t\\t# Now we would like to complete garden j, thus deduct the cost for garden j \\n\\t\\t\\t# from new and move on to the previous(next) incomplete garden!\\n\\t\\t\\tnew -= (t - A[j])\\n            j -= 1\\n            \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, A: List[int], new: int, t: int, full: int, part: int) -> int:\\n        A = [min(t, a) for a in A]\\n        A.sort()\\n\\t\\t\\n\\t\\t# Two edge cases\\n        if min(A) == t: return full * len(A)\\n        if new >= t * len(A) - sum(A):\\n            return max(full*len(A), full*(len(A)-1) + part*(t-1))\\n        \\n\\t\\t# Build the array `cost`.\\n        cost = [0]\\n        for i in range(1, len(A)):\\n            pre = cost[-1]\\n            cost.append(pre + i * (A[i] - A[i - 1]))\\n\\n\\t\\t# Since there might be some gardens having `target` flowers already, we will skip them.\\n        j = len(A) - 1\\n        while A[j] == t:\\n            j -= 1\\n        \\n\\t\\t# Start the iteration\\n        ans = 0\\n        while new >= 0:\\n\\t\\t\\n\\t\\t\\t# idx stands for the first `j` gardens, notice a edge case might happen.\\n            idx = min(j, bisect_right(cost, new) - 1)\\n\\t\\t\\t\\n\\t\\t\\t# bar is the current minimum flower in the incomplete garden\\n            bar = A[idx] + (new - cost[idx]) // (idx + 1)\\n\\t\\t\\t\\n            ans = max(ans, bar * part + full *(len(A) - j - 1))\\n            \\n\\t\\t\\t# Now we would like to complete garden j, thus deduct the cost for garden j \\n\\t\\t\\t# from new and move on to the previous(next) incomplete garden!\\n\\t\\t\\tnew -= (t - A[j])\\n            j -= 1\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934318,
                "title": "two-pointers",
                "content": "I do not think that we need a binary search here.\\n\\nWe sort gardens (descending), and then go left to right and make gardens full (until we run out of flowers). Thus, our first pointer `p1` indicates full gardens, and the last garden defines the minimum number of flowers (`minF`) among all gardens.\\n \\n> There is a special case when we can make all gardens full - it may be better to only plant `target - 1` flowers in the last garden, if `(target - 1) * partial > full`.\\n\\nWe then go right-to-left, and try increasing the minimum number of flowers. The second pointer - `p2` - indicates how many gardens have less flowers than `minF`.\\n \\nWe plan necessary flowers to gardens right of `p2`. If we do not have enough flowers, we take it from the rightmost full garden, decreasing `p1`. For each `minF` we can achieve, we track and return the maximum beauty.\\n\\nHere is an example for `[9, 7, 7, 6, 5, 4, 3, 2, 1, 1]` gardens, with target `8` and `9` new flowers to plant. As you see, for `minF == 2`, we have 5 full gardens. For `minF == 3`, we move `p1` to get enough flowers to plant, and now we have 4 full gardens. \\n\\n![image](https://assets.leetcode.com/users/images/e4932391-61ca-434f-b02e-3e7adddb92ec_1649643539.741906.png)\\n\\n**C++**\\n```cpp\\nlong long maximumBeauty(vector<int>& fl, long long newFlowers, int target, int full, int partial) {\\n    sort(begin(fl), end(fl), greater<int>());\\n    long long p1 = 0, sum = 0, res = 0, sz = fl.size();\\n    for (; p1 < sz; ++p1) {\\n        if (target - fl[p1] > newFlowers)\\n            break;\\n        newFlowers -= max(0, target - fl[p1]);\\n    }\\n    if (p1 == sz)\\n        return max(sz * full, (sz - 1) * full + (fl.back() < target ? (long long)(target - 1) * partial : full));\\n    for (long long minF = fl.back(), p2 = fl.size() - 1; minF < target; ) {\\n        while (p2 >= p1 && fl[p2] <= minF)\\n            sum += fl[p2--];\\n        int needed = (sz - p2 - 1) * minF - sum;\\n        if (needed > newFlowers) {\\n            if (--p1 < 0)\\n                break;\\n            newFlowers += max(0, target - fl[p1]);\\n        }\\n        else {\\n            res = max(p1 * full + minF * partial, res);    \\n            ++minF;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long maximumBeauty(vector<int>& fl, long long newFlowers, int target, int full, int partial) {\\n    sort(begin(fl), end(fl), greater<int>());\\n    long long p1 = 0, sum = 0, res = 0, sz = fl.size();\\n    for (; p1 < sz; ++p1) {\\n        if (target - fl[p1] > newFlowers)\\n            break;\\n        newFlowers -= max(0, target - fl[p1]);\\n    }\\n    if (p1 == sz)\\n        return max(sz * full, (sz - 1) * full + (fl.back() < target ? (long long)(target - 1) * partial : full));\\n    for (long long minF = fl.back(), p2 = fl.size() - 1; minF < target; ) {\\n        while (p2 >= p1 && fl[p2] <= minF)\\n            sum += fl[p2--];\\n        int needed = (sz - p2 - 1) * minF - sum;\\n        if (needed > newFlowers) {\\n            if (--p1 < 0)\\n                break;\\n            newFlowers += max(0, target - fl[p1]);\\n        }\\n        else {\\n            res = max(p1 * full + minF * partial, res);    \\n            ++minF;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1932250,
                "title": "c-commented-explanation-clean-code",
                "content": "/*\\n      \\n      Pre-Requisites :--> Prefix Sum + Binary Search\\n      \\n      Logic in a Nutshell :--> Actually in these type of questions , where the optimal answer is dependent on two distinct entities ,\\n      \\n                               We used to fix one entity and try to change ( increment / decrement ) its value ; and then figure out what \\n                               \\n                               is the impact of the first operation on the second entity.\\n                               \\n                               \\n                Maybe , it sounds not so good , but analyzing the question you can easily get that Our answer depends on \\n                 \\n                 (1) Number of full flowers --> (num_full*fullValue)  --> val1\\n                 (2) Minimum value of Incomplete flower --> (min_incomp*partialValue)  --> val2\\n                 \\n                 \\n               And the optimal answer will be the maxValue from any of the combinations of these two entity \\n               \\n               [ e.g :- 2 full flower + 3 partial flower\\n                        4 full flower + 1 partial flower\\n                        1 full flower + 3 partial flower ]\\n                        \\n                        \\n      Approach :-->  But how can we determine which valid combination fetchs us our desired output.\\n      \\n                     For these we have to make some basic but important observations ........\\n                     \\n                    \\n                    Observation(1) -->  We are given with fixed value of newFlowers (Let us consider it K) . Now we can use atmost K flowers.\\n \\n                         So how can we use minimum number of newFlowers and get maximum number of full flowers( whose value >= taregt) ???\\n                         \\n                         So obviously , we have to pick the Maximum valued flowers and try to put extra flowers till flowers[i]!=target.\\n                         \\n            [ E.g :- flowers [2,4,6,7,9] , newFlowers = 5 , fullValue = 10 ---> Now we pick the flowers[4]=9 and use 1 flower .......]\\n                                        \\n                                        \\n                   Observation(2) --> Now after we are done with the first part ( Current number of full flowers that we can achieve using atmost newFlowers amount of flowers )       \\n                   \\n                   After using certain amount of flowers in making certain amount of flowers \"full\" , let us say we have \"rest\" amount of newFlowers , we have to decide what we can do further with these amount of flowers.\\n                   \\n                   So , for these we have to look at the definition of\\n                   \\n                \"sumofbeauty\" --> \"# of full flowers * fullVal \" + \" Minimum valued incomplete flower * partialVal \"\\n                \\n                \\n                So it is not that we can make one flower[i] so big with \"rest\" flowers , as the minimum incomplete flowers[i] remains the same and it will not increment our result that much.\\n                \\n                Well ,we have to evenly distribute the \"rest\" flowers to all of the incomplete flowers and pick the Minimum one.\\n                \\n                wait wait , so as a whole we have to maximize the minimum flowers[i] --> bang on !!! Here comes the approach of Binary Search.\\n                   \\n                Finally , we have to fix the value of the incomplete flowers [ which have flowers[i] < target ] to \"mid\" and check whether all the incomplete flowers can reach to the \"mid\" value and if yes then increment the value properly.   \\n                   \\n    */\\n\\t\\n\\t`class Solution {\\npublic:\\n    \\n\\n    typedef long long ll;\\n    \\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        \\n        ll n=flowers.size();\\n        \\n        sort(flowers.begin(),flowers.end());\\n        \\n        vector<ll>prefix(n,0LL);\\n        \\n        prefix[0]=flowers[0];\\n        \\n        for(ll i=1;i<n;i++){\\n            prefix[i]=prefix[i-1]+(ll)flowers[i];\\n        }\\n        \\n        \\n        ll max_beauty=0LL;\\n        \\n        // Travrese from the end of the array as discussed previously.......\\n        \\n        // Check Whether we can make full flowers from index n-1 to index i [ if not then break ]\\n        \\n        // There is one additional corner case --> Sometimes it will be optimal that we\\'ll select 0 number of full flowers and try to maximize the partial_beauty using newFlowers.\\n        \\n        \\n        for(ll i=n;i>=0;i--){\\n            \\n            if(i==n){\\n                \\n                \\n            }\\n        \\n            else{\\n                \\n                ll req_for_full=max(0LL,(ll)(target-flowers[i]));\\n                \\n                if(req_for_full > newFlowers){\\n                    break;\\n                }\\n                \\n                newFlowers-=req_for_full; \\n                \\n                flowers.pop_back();  // This the line where your code fails even after it is correct logically , as there is some situation when number of full flowers and number of partial flowers can collide and it increase our answer than the actual one . Try the Example TestCase 2 by your own.\\n                \\n            }\\n            \\n            \\n            ll curr_beauty_full=((n-i)*full);\\n            \\n            ll curr_beauty_partial=0LL;\\n            \\n            ll low=0,high=target-1;\\n            \\n            while(low<=high){\\n                \\n                ll mid=(low+high)/2;\\n                \\n                ll idx=upper_bound(flowers.begin(),flowers.end(),mid)-flowers.begin();\\n                \\n                if(idx==0){\\n                    \\n                    low=mid+1;\\n                    \\n                }\\n                \\n                else{\\n                    \\n                    ll have_flowers=prefix[idx-1];\\n                    \\n                    ll req_flowers=(idx*mid);\\n                    \\n                    ll extra_flowers=(req_flowers-have_flowers);\\n                    \\n                    if(extra_flowers<=newFlowers){\\n                        \\n                        curr_beauty_partial=(mid*partial);\\n                        \\n                        low=mid+1;\\n                        \\n                    }\\n                    \\n                    else{\\n                        \\n                        high=mid-1;\\n                        \\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n            max_beauty=max(max_beauty,curr_beauty_partial+curr_beauty_full);\\n            \\n        }\\n        \\n        return max_beauty;\\n        \\n    }\\n};`",
                "solutionTags": [
                    "Binary Search",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    \\n\\n    typedef long long ll;\\n    \\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        \\n        ll n=flowers.size();\\n        \\n        sort(flowers.begin(),flowers.end());\\n        \\n        vector<ll>prefix(n,0LL);\\n        \\n        prefix[0]=flowers[0];\\n        \\n        for(ll i=1;i<n;i++){\\n            prefix[i]=prefix[i-1]+(ll)flowers[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1931867,
                "title": "python3-prefix-sum-binary-search-o-log-target-log-n-n-accepted",
                "content": "First, sort the `flowers` list in ascending order. If we want to make some gardens full, we should choose those with more planted flowers to \"fulfill\".\\n\\nAssume that we want to get scores by making the largest `k` gardens full, while the rest `n-k` gardens have a max-min value of `flowers`. We need to sum up all missing values of the largest `k` flowers `sum[(max(0,target-flower) for flower in flowers[:-k]]`, which can be optimized by a \"reversed\" prefix sum array (for *prefix sum*, see [LC 303](https://leetcode.com/problems/range-sum-query-immutable/)) in a O(n) time. Here, I use `lack[k]` to accumulate the total flowers required to make the largest `k` `flower` full. (**Note**: In some corner cases, all gardens are already full before planting new flowers, as we can\\'t remove any planted flowers. Thus, we should start `k` with the min one that lets `lack[i]`>0 to avoid handling some full gardens as *incomplete* ones.)\\n\\nAfter fulfilling `k` gardens, the rest `n-k` gardens can be planted with **at most** `newFlowers-lack[k]` flowers. We\\'re just curious about what is the max min value when adding `newFlowers-lack[k]` to `flowers[:n-k]`. This question satisfies the property of *binary-search* with a lower bound as `flowers[0]` (the origin min value) and an upper bound as `target` (**Note**: *In fact, after adding all  `newFlowers-lack[k]`, the min value of  `flowers[:n-k]` may >= `target`. However, we don\\'t want to account for this case here because it will be considered later when we increase `k` to `n`, so the upper bound is limited to `target-1` inclusively*), so the score from the remaining `n-k` incomplete gardens can be obtained in `O(log(target)*cost(condition))`, in which `cost(condition)` denotes the time cost to check if the current min-value `flower` can be achieved by adding  `newFlowers-lack[k]` flowers.\\n \\nTraditionally, finding the max-min value of an array after adding some numbers is a typical **load balancer problem**, which is similar to Q3 this week and the first challenge problem hosted by Amazon Last Mile Delivery last week. But the traditional linear way to calculate the max-min value is of time complexity in `O(n)` even with the auxiliary of the pre-sum array, which leads to a TLE in the contest. To reduce the runtime, we just need to check if a min `flower` can be achieved after adding `f` new flowers to the first `k` gardens *optimally*, here I use `fill(flower, f, k)` as a conditional checker to determine if it is feasible to all first `k` gardens are of >= `flower` flowers. Given the `fill` function, we can quickly apply the [binary search template](https://leetcode.com/discuss/general-discussion/786126/python-powerful-ultimate-binary-search-template-solved-many-problems) to finish the skeleton of getting the actual max-min of `flower[:k]`.\\n\\nNow, let\\'s look into `fill(flower, f, k)`: we check how many elements < `flower` there by binary-search as well,  we call it `m`. Then, we try to make up the total diff values between those elements and our required `flower`, so we just need to check if the sum of the first `m` elements >= `m*flower` after adding `m` to the left-hand of the inequity, which can be easily solved when we have already known the sum of first `m` elements by pre-sum array, so  `fill(flower, f, k)` is called in `O(log(n))`, which is the complexity of `cost(condition)` .\\n\\nFinally, we traverse the `flowers` linearly to consider `k` garden full and `n-k` gardens incomplete, the total score is `k*full + flower*partial`, in which `flower` is the max-min value of the `n-k` incomplete gardens, which is calculated by the binary search method above in `O(log(target)*log(n))`, along with a space complexity `O(n)`. (`n` = `len(flowers)`)\\n\\n\\n```py\\nimport bisect\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        n = len(flowers)\\n        flowers.sort()\\n        pre,lack = [0],[0]\\n        \\n        # corner case in which no incomplete garden can be created. \\n        if flowers[0] >= target:\\n            return n*full\\n        \\n        # pre-sum in an ascending order\\n        for i in flowers:\\n            pre.append(pre[-1]+i)\\n        \\n        # pre-sum in a descending order, meanwhile, count how many gardens are already full\\n        cnt = 0\\n        for i in flowers[::-1]:\\n            if i >= target:\\n                cnt+=1\\n            lack.append(lack[-1]+max(target-i,0))\\n        \\n        # conditional checker: whether all first k elements can >= flower after adding f to them\\n        def fill(flower,f,k):\\n            i = bisect.bisect_left(flowers,flower,lo=0,hi=k)\\n            return pre[i] + f >= i*flower\\n            \\n        res = 0\\n        # start from the min number of full gardens\\n        for k in range(cnt,n):\\n            if lack[k] < newFlowers:\\n                left, right = flowers[0], target+1\\n                while left < right:\\n                    mid = (left+right)//2\\n                    if not fill(mid,newFlowers-lack[k],n-k):\\n                        right = mid\\n                    else:\\n                        left = mid + 1\\n                left -= 1\\n                \\n                if left >= target:\\n                    # the n-k gardens must be incomplete, which can have a max value as target-1\\n                    \\n                    res = max(res,(target-1)*partial+k*full)\\n                else:\\n                    res = max(res,k*full+left*partial)\\n        \\n        # A corner case: All n gardens can be full, no incomplete gardens\\n        if lack[-1] <= newFlowers:\\n            res = max(res,n*full)\\n        return res\\n        \\n            \\n```\\nI know it looks ugly, but anyway, it is accepted.\\n\\n**Update**: credit to [@ithachien](https://leetcode.com/ithachien/) (see the comment below), I realize that in the last corner case (all gardens can be fulfilled) we don\\'t have to do binary search to find out the max-min value of the first `n-k` gardens. It must be able to reach the largest min value as `target-1` because the remaining flowers are always sufficient, so I added the \"short-circuitting\" case before the loop as:\\n\\n```py\\nres = 0\\nif lack[-1] <= newFlowers:\\n    res = max(res,n*full)\\n    for k in range(cnt,n):\\n        res = max(res,(target-1)*partial+k*full)\\n    return res\\n```\\n\\nBesides, the lower bound of the max-min value for the first `n-k` garden after planting the remaining flowers can be further increased to `(newFlowers-lack[k])//(n-k) + flowers[0]` as all flowers are evenly assigned to all `n-k` garden, which narrows down the search range.\\n\\nBased on the minor optimization above, my code turned out to be of a runtime in 2432 ms, and beats 100% Python3 submissions so far.",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```py\\nimport bisect\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        n = len(flowers)\\n        flowers.sort()\\n        pre,lack = [0],[0]\\n        \\n        # corner case in which no incomplete garden can be created. \\n        if flowers[0] >= target:\\n            return n*full\\n        \\n        # pre-sum in an ascending order\\n        for i in flowers:\\n            pre.append(pre[-1]+i)\\n        \\n        # pre-sum in a descending order, meanwhile, count how many gardens are already full\\n        cnt = 0\\n        for i in flowers[::-1]:\\n            if i >= target:\\n                cnt+=1\\n            lack.append(lack[-1]+max(target-i,0))\\n        \\n        # conditional checker: whether all first k elements can >= flower after adding f to them\\n        def fill(flower,f,k):\\n            i = bisect.bisect_left(flowers,flower,lo=0,hi=k)\\n            return pre[i] + f >= i*flower\\n            \\n        res = 0\\n        # start from the min number of full gardens\\n        for k in range(cnt,n):\\n            if lack[k] < newFlowers:\\n                left, right = flowers[0], target+1\\n                while left < right:\\n                    mid = (left+right)//2\\n                    if not fill(mid,newFlowers-lack[k],n-k):\\n                        right = mid\\n                    else:\\n                        left = mid + 1\\n                left -= 1\\n                \\n                if left >= target:\\n                    # the n-k gardens must be incomplete, which can have a max value as target-1\\n                    \\n                    res = max(res,(target-1)*partial+k*full)\\n                else:\\n                    res = max(res,k*full+left*partial)\\n        \\n        # A corner case: All n gardens can be full, no incomplete gardens\\n        if lack[-1] <= newFlowers:\\n            res = max(res,n*full)\\n        return res\\n        \\n            \\n```\n```py\\nres = 0\\nif lack[-1] <= newFlowers:\\n    res = max(res,n*full)\\n    for k in range(cnt,n):\\n        res = max(res,(target-1)*partial+k*full)\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931056,
                "title": "c-iterate-over-number-of-gardens-we-make-full-then-binary-search",
                "content": "Note that if we make `i` gardens full, then for the optimal solution, those gardens are the `i` biggest ones.\\n```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        int full_cnt = 0;\\n        for(int i = flowers.size() - 1; i >= 0; i--) {\\n            if(flowers[i] < target) break;\\n            full_cnt++;\\n        }\\n        int n = flowers.size() - full_cnt;\\n        if(n == 0) return (long long)full_cnt * (long long)full;\\n        \\n        vector<long long> fill_up(n, 0), fill_target(n, 0);\\n        \\n        // fill_up: flowers needed to get min of flowers to flowers[i]\\n        fill_up[0] = 0;\\n        for(int i = 1; i < n; i++) {\\n            fill_up[i] = (flowers[i] - flowers[i-1]) * (long long)i + fill_up[i-1];\\n        }\\n        // fill_target[i] fill flowers[i] to flowers[n-1] to target level\\n        fill_target[n-1] = (long long) target - flowers[n-1];\\n        for(int i = n - 2; i >= 0; i--) {\\n            fill_target[i] = fill_target[i+1] + (long long)(target - flowers[i]); \\n        }\\n        long long ret = 0;\\n        for(int num_fill = 0; num_fill <= n; num_fill++) {\\n            long long m = 0;\\n            long long rm = newFlowers;\\n            if(num_fill != 0) {\\n                rm -= fill_target[n-num_fill];\\n            }\\n            if(rm < 0) break;\\n            if(num_fill != n) {\\n                auto ptr = upper_bound(fill_up.begin(), fill_up.end(), rm);\\n                // can get min to flowers[idx-1] level, but not flowers[idx] level\\n                int idx = ptr - fill_up.begin();\\n                if(idx >= n - num_fill) idx = n - num_fill;\\n                m = flowers[idx - 1];\\n                m += (rm - fill_up[idx - 1]) / idx; \\n                m = min(m, (long long)target - 1);\\n            }\\n            long long tmp = m * (long long) partial + (full_cnt + num_fill) * (long long) full;\\n            ret = max(tmp, ret);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        int full_cnt = 0;\\n        for(int i = flowers.size() - 1; i >= 0; i--) {\\n            if(flowers[i] < target) break;\\n            full_cnt++;\\n        }\\n        int n = flowers.size() - full_cnt;\\n        if(n == 0) return (long long)full_cnt * (long long)full;\\n        \\n        vector<long long> fill_up(n, 0), fill_target(n, 0);\\n        \\n        // fill_up: flowers needed to get min of flowers to flowers[i]\\n        fill_up[0] = 0;\\n        for(int i = 1; i < n; i++) {\\n            fill_up[i] = (flowers[i] - flowers[i-1]) * (long long)i + fill_up[i-1];\\n        }\\n        // fill_target[i] fill flowers[i] to flowers[n-1] to target level\\n        fill_target[n-1] = (long long) target - flowers[n-1];\\n        for(int i = n - 2; i >= 0; i--) {\\n            fill_target[i] = fill_target[i+1] + (long long)(target - flowers[i]); \\n        }\\n        long long ret = 0;\\n        for(int num_fill = 0; num_fill <= n; num_fill++) {\\n            long long m = 0;\\n            long long rm = newFlowers;\\n            if(num_fill != 0) {\\n                rm -= fill_target[n-num_fill];\\n            }\\n            if(rm < 0) break;\\n            if(num_fill != n) {\\n                auto ptr = upper_bound(fill_up.begin(), fill_up.end(), rm);\\n                // can get min to flowers[idx-1] level, but not flowers[idx] level\\n                int idx = ptr - fill_up.begin();\\n                if(idx >= n - num_fill) idx = n - num_fill;\\n                m = flowers[idx - 1];\\n                m += (rm - fill_up[idx - 1]) / idx; \\n                m = min(m, (long long)target - 1);\\n            }\\n            long long tmp = m * (long long) partial + (full_cnt + num_fill) * (long long) full;\\n            ret = max(tmp, ret);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2553928,
                "title": "c-prefix-sum-binary-search-easy-solution-clean-code",
                "content": "First of all, we would need to find the minimum and maximum number of complete gardens that can be formed using ```newFlowers``` . This can be easily done using sorting.\\n\\nThe most important to thing to figure out in this problem is the minimum number of flowers present in a garden, if ```x``` gardens are already complete after using some (if not all) ```newFlowers```. We will then iterate from ```minComplete``` garden to ```maxComplete``` garden, and keep track of the maximum answer.\\n\\nNow to find minimum number of flowers present for ```x``` complete gardens, we need to store the prefix difference array. What is the motivation? See, we have to maximise the minimum value of flowers for every garden. So we start increasing from the smallest to the next largest. For that, we will need the difference times the number of elements we have to increase.\\n\\nFor example, suppose for the ```flowers = [2, 5, 6, 11, 13]``` if we want to have minimum value to be 5 we need at least ```5 - 2 = 3``` flowers. Now, if we need 6 minimum value, then we need ```(6 - 5) * 2 + 3 = 4``` flowers. This was the pattern. Also, make sure that this value that you increment doesn\\'t make it equal to target.\\n\\nLastly, we will be having some ```newFlowers```, we find the least value for which it is possible, and then we may have some remaining flowers, we can then check for remaining group whether it is possible to increase that minimum value or not. \\n\\nLook at the code for better understanding.\\n\\n```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        int tot = flowers.size();\\n        long long maxBeauty = 0ll;\\n        int maxComplete = 0, minComplete = 0;\\n        sort(flowers.begin(), flowers.end());\\n        long long tempNewFlowers = newFlowers;\\n        for (int i = tot - 1; i >= 0; i--) {\\n            if (flowers[i] >= target) {\\n                minComplete++;\\n                maxComplete++;\\n            }\\n            else if (target - flowers[i] <= tempNewFlowers) {\\n                maxComplete++;\\n                tempNewFlowers -= target - flowers[i];\\n            } else {\\n                break;\\n            }\\n        }\\n        flowers.push_back(target - 1);\\n        vector<long long> preDif(tot + 1, 0ll);\\n        for (int i = 1; i < tot; i++) {\\n            preDif[i] = (long long)(i * (flowers[i] - flowers[i - 1])) + preDif[i - 1];\\n        }\\n        int right = tot - 1;\\n        while(right >= 0 && flowers[right] >= target) {\\n            right--;\\n        }\\n        if (right >= 0) {\\n            flowers[right + 1] = target - 1;\\n            preDif[right + 1] = preDif[right] + (long long) (right + 1) * (long long)(flowers[right + 1] - flowers[right]);   \\n        }\\n        vector<long long> minFlower(maxComplete + 1);\\n        for (int complete = minComplete; complete <= maxComplete && right >= 0; complete++) {\\n            int pos = upper_bound(preDif.begin(), preDif.begin() + right + 1, newFlowers) - preDif.begin();\\n            pos--;\\n            minFlower[complete] = min((long long)target - 1, (long long)flowers[pos] + (long long)((newFlowers - preDif[pos]) / (pos + 1)));\\n            newFlowers -= (target - flowers[right]);\\n            right--;\\n            if (right >= 0) {\\n                flowers[right + 1] = target - 1;\\n                preDif[right + 1] = preDif[right] + (long long) (right + 1) * (long long)(flowers[right + 1] - flowers[right]);   \\n            }\\n        }\\n        for (int complete = minComplete; complete <= maxComplete; complete++) {\\n            maxBeauty = max(maxBeauty, (long long)complete * (long long)full + minFlower[complete] * (long long)partial);\\n        }\\n        return maxBeauty;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```newFlowers```\n```x```\n```newFlowers```\n```minComplete```\n```maxComplete```\n```x```\n```flowers = [2, 5, 6, 11, 13]```\n```5 - 2 = 3```\n```(6 - 5) * 2 + 3 = 4```\n```newFlowers```\n```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        int tot = flowers.size();\\n        long long maxBeauty = 0ll;\\n        int maxComplete = 0, minComplete = 0;\\n        sort(flowers.begin(), flowers.end());\\n        long long tempNewFlowers = newFlowers;\\n        for (int i = tot - 1; i >= 0; i--) {\\n            if (flowers[i] >= target) {\\n                minComplete++;\\n                maxComplete++;\\n            }\\n            else if (target - flowers[i] <= tempNewFlowers) {\\n                maxComplete++;\\n                tempNewFlowers -= target - flowers[i];\\n            } else {\\n                break;\\n            }\\n        }\\n        flowers.push_back(target - 1);\\n        vector<long long> preDif(tot + 1, 0ll);\\n        for (int i = 1; i < tot; i++) {\\n            preDif[i] = (long long)(i * (flowers[i] - flowers[i - 1])) + preDif[i - 1];\\n        }\\n        int right = tot - 1;\\n        while(right >= 0 && flowers[right] >= target) {\\n            right--;\\n        }\\n        if (right >= 0) {\\n            flowers[right + 1] = target - 1;\\n            preDif[right + 1] = preDif[right] + (long long) (right + 1) * (long long)(flowers[right + 1] - flowers[right]);   \\n        }\\n        vector<long long> minFlower(maxComplete + 1);\\n        for (int complete = minComplete; complete <= maxComplete && right >= 0; complete++) {\\n            int pos = upper_bound(preDif.begin(), preDif.begin() + right + 1, newFlowers) - preDif.begin();\\n            pos--;\\n            minFlower[complete] = min((long long)target - 1, (long long)flowers[pos] + (long long)((newFlowers - preDif[pos]) / (pos + 1)));\\n            newFlowers -= (target - flowers[right]);\\n            right--;\\n            if (right >= 0) {\\n                flowers[right + 1] = target - 1;\\n                preDif[right + 1] = preDif[right] + (long long) (right + 1) * (long long)(flowers[right + 1] - flowers[right]);   \\n            }\\n        }\\n        for (int complete = minComplete; complete <= maxComplete; complete++) {\\n            maxBeauty = max(maxBeauty, (long long)complete * (long long)full + minFlower[complete] * (long long)partial);\\n        }\\n        return maxBeauty;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932287,
                "title": "o-n-sliding-window",
                "content": "```python\\nclass Solution:\\n    def maximumBeauty(self, A: List[int], to_add: int, target: int, full: int, partial: int) -> int:\\n        N = len(A)\\n        A.sort()\\n        P = list(accumulate(A, initial=0))\\n        \\n        ans = 0\\n        j = N - 1\\n        for k in range(N + 1):\\n            j = min(j, N - k - 1)\\n            while j >= 0:\\n                h = (P[j + 1] + to_add) // (j + 1)\\n                if h < A[j] and j >= 0:\\n                    j -= 1\\n                else:\\n                    break\\n\\n            cand = k * full\\n            if j >= 0 and A[j] < target:\\n                cand += min(h, target - 1) * partial\\n            ans = max(ans, cand)\\n            \\n            if k == N:\\n                break\\n            if (delta := target - A[~k]) > 0:\\n                to_add -= delta\\n            if to_add < 0:\\n                break\\n        \\n        return ans\\n```\\n\\nSort `A`.  You should take `k` plants and make them a height of `target`, and then try to improve the remaining `A[..j]` of them to be the best height possible.\\n\\nSince `j` is monotone decreasing as `k` increases, we can slide `j` down.  In the while loop `j >= 0`, we search for the largest `j` such that we can make `A[..j]` atleast the height `h` of `A[j]`.\\n\\nNow we have a candidate answer: `k` completed plants, plus a height of `h` for the partial.  There is a corner case where the height `h` as well as `A[j]` must be less than `target` for it to count.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maximumBeauty(self, A: List[int], to_add: int, target: int, full: int, partial: int) -> int:\\n        N = len(A)\\n        A.sort()\\n        P = list(accumulate(A, initial=0))\\n        \\n        ans = 0\\n        j = N - 1\\n        for k in range(N + 1):\\n            j = min(j, N - k - 1)\\n            while j >= 0:\\n                h = (P[j + 1] + to_add) // (j + 1)\\n                if h < A[j] and j >= 0:\\n                    j -= 1\\n                else:\\n                    break\\n\\n            cand = k * full\\n            if j >= 0 and A[j] < target:\\n                cand += min(h, target - 1) * partial\\n            ans = max(ans, cand)\\n            \\n            if k == N:\\n                break\\n            if (delta := target - A[~k]) > 0:\\n                to_add -= delta\\n            if to_add < 0:\\n                break\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931754,
                "title": "c-solution-dp-binary-search-prefix-sums-explained-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        long long ans = 0;\\n        int n = flowers.size();\\n        if(n == 0) return 0;\\n        sort(flowers.begin(), flowers.end());\\n        vector<long long> pref(n, 0); // Prefix sums array\\n        pref[0] = flowers[0];\\n        for(int i = 1; i < n; i++) {\\n            pref[i] = pref[i - 1] + flowers[i];\\n        }\\n        for(int i = n; i >= 0; i--) {\\n            // When i is n, none of the elements are incremented till target.\\n            if(i < n) { // The ith element(0-indexed) is incremented till target. This is handling the case of \"full\". We are doing this from the end because it will cost the least number of new Flowers.\\n                long long toAdd = max(0, target - flowers[i]);\\n                if(newFlowers < toAdd) {\\n                    break; // We are breaking because we would\\'ve already found the best answer in the previous iterations\\n                }\\n                newFlowers -= toAdd;\\n                flowers.pop_back();\\n            }\\n            long long beautyForFullCase = (long long)(n - i) * full; // All the elements from i to n -1 are incremented till target, so they have a beauty of (n - 1) * full\\n            \\n            // Here, we do binary search on x, which is the the maximum number we can increment all the numbers from 0 to i - 1 to. The maximum we can increment to is target-1 because after that, \"partial\" will not be applicable. Binary search is done to find out the maximum possible answer for the partial case.\\n            int l = 0, r = target - 1;\\n            long long beautyForPartialCase = 0;\\n            while(l <= r) {\\n                long long mid = l + (r - l) / 2; // mid is the maximum number we can increment to\\n                auto it = upper_bound(flowers.begin(), flowers.end(), mid); // will point to an element that is atleast 1 more than the incomplete garden with most number of flowers\\n                if(it == flowers.begin()) { // there are no incomplete gardens\\n                    l = mid + 1;\\n                } else {\\n                    long long len = distance(flowers.begin(), it); // number of incomplete gardens\\n                    long long sum = pref[len - 1];\\n                    long long needed = ((long long)mid * len) - sum; // number of flowers needed to make \"mid\" as the minimum element\\n                    if(needed <= newFlowers) { // if it is possible to plant flowers such that the minimum number of flowers for any garden is \"mid\", then we go to check for higher values through Binary search\\n                        l = mid + 1;\\n                        beautyForPartialCase = (long long)mid * partial; // (minimum number of flowers in any incomplete garden) * (partial) = total beauty of incomplete gardens\\n                    } else {\\n                        r = mid - 1;\\n                    }\\n                }\\n            }\\n            ans = max(ans, beautyForFullCase + beautyForPartialCase); // checking if this answer is better than the previous answers computed.\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        long long ans = 0;\\n        int n = flowers.size();\\n        if(n == 0) return 0;\\n        sort(flowers.begin(), flowers.end());\\n        vector<long long> pref(n, 0); // Prefix sums array\\n        pref[0] = flowers[0];\\n        for(int i = 1; i < n; i++) {\\n            pref[i] = pref[i - 1] + flowers[i];\\n        }\\n        for(int i = n; i >= 0; i--) {\\n            // When i is n, none of the elements are incremented till target.\\n            if(i < n) { // The ith element(0-indexed) is incremented till target. This is handling the case of \"full\". We are doing this from the end because it will cost the least number of new Flowers.\\n                long long toAdd = max(0, target - flowers[i]);\\n                if(newFlowers < toAdd) {\\n                    break; // We are breaking because we would\\'ve already found the best answer in the previous iterations\\n                }\\n                newFlowers -= toAdd;\\n                flowers.pop_back();\\n            }\\n            long long beautyForFullCase = (long long)(n - i) * full; // All the elements from i to n -1 are incremented till target, so they have a beauty of (n - 1) * full\\n            \\n            // Here, we do binary search on x, which is the the maximum number we can increment all the numbers from 0 to i - 1 to. The maximum we can increment to is target-1 because after that, \"partial\" will not be applicable. Binary search is done to find out the maximum possible answer for the partial case.\\n            int l = 0, r = target - 1;\\n            long long beautyForPartialCase = 0;\\n            while(l <= r) {\\n                long long mid = l + (r - l) / 2; // mid is the maximum number we can increment to\\n                auto it = upper_bound(flowers.begin(), flowers.end(), mid); // will point to an element that is atleast 1 more than the incomplete garden with most number of flowers\\n                if(it == flowers.begin()) { // there are no incomplete gardens\\n                    l = mid + 1;\\n                } else {\\n                    long long len = distance(flowers.begin(), it); // number of incomplete gardens\\n                    long long sum = pref[len - 1];\\n                    long long needed = ((long long)mid * len) - sum; // number of flowers needed to make \"mid\" as the minimum element\\n                    if(needed <= newFlowers) { // if it is possible to plant flowers such that the minimum number of flowers for any garden is \"mid\", then we go to check for higher values through Binary search\\n                        l = mid + 1;\\n                        beautyForPartialCase = (long long)mid * partial; // (minimum number of flowers in any incomplete garden) * (partial) = total beauty of incomplete gardens\\n                    } else {\\n                        r = mid - 1;\\n                    }\\n                }\\n            }\\n            ans = max(ans, beautyForFullCase + beautyForPartialCase); // checking if this answer is better than the previous answers computed.\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931410,
                "title": "python-o-nlogn-dp-and-binary-search",
                "content": "The idea is that after sorting the flowers array from low to high, in the optimal result, the full/compete gardens must be on the right side, while partial gardens are on the left. Otherwise, we are wasting some newFlowers thus the result can\\'t be optimal.\\n\\nSo we just need to check every index and do 2 things:\\n1) try to make the right part of current index all full, if not possible, simply continue to next index\\n2) after making the right part all full, we need to calculate what is the maximum value of min flowers in the left part we can make with remaing newFlowers.\\n\\nStep 1) above can be done with pre_sum array easily. Step 2) is more tricky.\\nThe algorithm I used is to keep an auxiliary dp array during iteration, which will store below information:\\n- at index j: dp[j] = (j+1) * flowers[j] - presum[j+1]\\n- essentially, the extra flowers needed to make every garden left of index j equal to flowers[j]\\n- this dp array is guaranteed to be increasing order\\n\\nSo in order to achieve Step 2), we will do a binary search on the dp array to get the rightmost j index possible with remaining newFlowers (rem_flowers), and every garden left of index j (including j) will be brought up to the same min_partial value which satisfies:\\n- min_partial * (j+1) - presum[j+1] <= rem_flowers\\n- min_partial <= target - 1\\n\\nThe rest is just update max_beauty with min_partial and total full/complete gardens\\n\\nOverall time complexity O(NlogN), space complexity O(N)\\n\\n```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        \\n\\t\\t# move out already completed garden\\n        already_complete = 0\\n        temp = []\\n        for f in flowers:\\n            if f >= target:\\n                already_complete += 1\\n            else:\\n                temp.append(f)\\n\\n        max_beauty = 0\\n        \\n        flowers = temp\\n        flowers.sort()\\n        \\n        presum = [0] + list(accumulate(flowers))\\n        N = len(flowers)\\n        \\n        dp_arr = []\\n        \\n        for i in range(N+1):\\n            # iterate all index: left part is all partial, right part (>= i) is all complete\\n            \\n            # update the dp arr for binary search below\\n            if i < N:\\n                dp_arr.append((i+1) * flowers[i] - presum[i+1])\\n            \\n            right_sum = presum[-1] - presum[i]\\n            right_count = N - i\\n            \\n            # if can\\'t make the right part all complete, go to next index\\n            if right_sum + newFlowers < right_count * target:\\n                continue\\n            \\n            # remaining flowers after making right part all complete\\n            rem_flowers = newFlowers - (right_count * target - right_sum)\\n            \\n            # binary search to find the maximum possible min flowers in the left part (named \\'min_partial\\')\\n            if i == 0:\\n                min_partial = 0\\n            else:\\n                j = min(bisect.bisect_right(dp_arr, rem_flowers) - 1, i-1)\\n                min_partial = min((rem_flowers + presum[j+1]) // (j+1), target-1)\\n                 \\n            complete = right_count + already_complete\\n            max_beauty = max(max_beauty, complete * full + min_partial * partial)\\n\\n            \\n        return max_beauty\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        \\n\\t\\t# move out already completed garden\\n        already_complete = 0\\n        temp = []\\n        for f in flowers:\\n            if f >= target:\\n                already_complete += 1\\n            else:\\n                temp.append(f)\\n\\n        max_beauty = 0\\n        \\n        flowers = temp\\n        flowers.sort()\\n        \\n        presum = [0] + list(accumulate(flowers))\\n        N = len(flowers)\\n        \\n        dp_arr = []\\n        \\n        for i in range(N+1):\\n            # iterate all index: left part is all partial, right part (>= i) is all complete\\n            \\n            # update the dp arr for binary search below\\n            if i < N:\\n                dp_arr.append((i+1) * flowers[i] - presum[i+1])\\n            \\n            right_sum = presum[-1] - presum[i]\\n            right_count = N - i\\n            \\n            # if can\\'t make the right part all complete, go to next index\\n            if right_sum + newFlowers < right_count * target:\\n                continue\\n            \\n            # remaining flowers after making right part all complete\\n            rem_flowers = newFlowers - (right_count * target - right_sum)\\n            \\n            # binary search to find the maximum possible min flowers in the left part (named \\'min_partial\\')\\n            if i == 0:\\n                min_partial = 0\\n            else:\\n                j = min(bisect.bisect_right(dp_arr, rem_flowers) - 1, i-1)\\n                min_partial = min((rem_flowers + presum[j+1]) // (j+1), target-1)\\n                 \\n            complete = right_count + already_complete\\n            max_beauty = max(max_beauty, complete * full + min_partial * partial)\\n\\n            \\n        return max_beauty\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030980,
                "title": "binary-search-with-upper-bound-function",
                "content": "\\n* The first thing that striked my mind was binary search infact but not in a very good way. \\n* I noticed that our N gardens will be made of x complete + N-x incomplete gardens , where 0 <= x <= N. \\n* Now lets think greedily , to make x gardens complete which gardens should I choose. The answer is x largest garden. \\n> eg : 5 4 1 2 , target = 5 , newFlowers = 7 \\nNow to make 3 gardens complete , we choose 5 , 4 , 2\\nIncreasing 4 -> 5 and 2 -> 5 resulting in usage of 4 newFlowers. \\nAnd we have 3 more flowers left. \\nThis is the optimal way of choosing because any other way will result in less number of flowers remaining. \\nSo we sort the array in reverse so that we always choose i largest gardens. \\n\\n* Now the question arises that how will we calculate the number of flowers needed for completing x gardens. \\n>eg : Consider the above example : 5 4 2 1 , \\nThe sum of first 3 numbers is 11 and we want to make 3 gardens complete so we require 3 * target = 15 flowers but we already have 11 so requires 4 more. \\nrequire[i] = i * target - prefixSum[i]. \\nAn edge case what if the flower array was  : 6 4 2 1 \\nApplying the same logic we get 15 - 12 = 3 , but on actual check we require 4. \\nThe problem is 6 because it is greater then target. \\nSo will be incrementing our sum as : \\n(pfSum[i] = pfSum[i-1] + min(flower[i] ,target)); \\n\\n* Now looking for the incomplete gardens we observe that for the remaing gardens we need to obtain the maximum minima. Also we observe that an incomplete garden will always contain flowers less then target giving us the upper bound of having atmost target - 1 flower in an incomplete garden.\\n> eg : 1 2 3 4 , target = 6 \\nRight now the min is 1 using 0 newFlowers\\nSuppose we choose our min as 2 so we need to increase the flower in 1st garden so : 2 2 3 4  , min = 2 , flowerUsed = 1\\nChoose min as 3 so : 3 3 3 4 , min : 3 , flowerUsed = 3 \\nChoose min as 4 so : 4 4 4 4 , min : 4 , flowerUsed = 6 \\nChoose min as 5 so : 5 5 5 5 , min : 5 , flowerUsed = 10 \\nThis is the most optimal case where all the incomplete gardens contains max flowers. we just need to make sure that flowersUsed <= newFlowers(left after planting the complete gardens). \\n\\n* But we cant simply iterate over the options to choose min instead we can apply binary search here. We need to find that number for which flowerUsed is largest and flowerUsed <= newFlower. \\n> eg : 1 2 3 4 \\nfor 1 we need 0 \\nfor 2 we need 0 + 1*(2-1) = 1\\nfor 3 we need 1 + 2*(3 - 2) = 3 \\nfor 4 we need 3 + 3*(4 - 3)  =6 \\nusedFlower[i] = usedFlower[i-1] + i * (flower[i] - flower[i-1])\\nSo suppose we have 4 newFlowers left \\nwe apply upper bound for 4 on [0 , 1 , 3 , 6] and we get index 3. \\nSubtract 1 from it and you get 3 which corresponds to choosing min as 3. \\nBut suppose we have newFlowers as 10 \\nupperBound will give 4 and we subtract 1 and get 3. \\nNow 10 - 6 = 4 and the array becomes 4 4 4 4 and we have 4 more left which will be distributed amongst the 4. \\n\\nHere comes the code :\\n```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flower, long long newFlowers, int target, int full, int partial) {\\n        int n = flower.size();\\n        sort(flower.begin(),flower.end());\\n\\t\\t\\n\\t\\t// This r is for storing the flower that will be used \\n        vector<long long>r; \\n        r.push_back(0); \\n        for(int i = 1 ; i < n ; i++){\\n            long long cur = r.back() + i*(flower[i] - flower[i-1]); \\n            r.push_back(cur);\\n        }\\n        reverse(flower.begin(),flower.end());\\n        long long ans = 0 ;\\n        long long sum = 0 ; \\n        for(int i = 0 ; i < n ; i++){\\n            \\n            //i : complete , n-i : incomplete \\n            long long k = newFlowers ; \\n            long long req = 1ll * i*target - sum ; \\n            if(k < req) break ;\\n            sum += min(flower[i], target); \\n            k -= max(0ll , req) ; \\n        \\n            long long int cur = 1ll * i * full ; \\n            if(flower[i] >= target){\\n                ans = max(ans , cur) ;\\n                r.pop_back(); \\n                continue ; \\n            }\\n\\t\\t\\t\\n            auto I = upper_bound(r.begin(),r.end(),k)-r.begin(); \\n            I = I - 1; \\n            \\n            k -= r[I]; \\n            long long Min = flower[n - I - 1] ; \\n            long long inc = k/(I+1); \\n            Min = min(Min+inc , 1ll * target-1) ; \\n\\t\\t\\t\\n            cur += Min * partial ; \\n\\t\\t\\t\\n            ans = max(ans , cur) ;\\n\\t\\t\\t\\n\\t\\t\\t//popping because next time we will have 1 complete garden more \\n            r.pop_back(); \\n            \\n        }\\n        \\n        if((1ll * n*target - sum) < newFlowers){\\n            ans = max(ans ,1ll * n *full); \\n        }\\n        return ans ;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flower, long long newFlowers, int target, int full, int partial) {\\n        int n = flower.size();\\n        sort(flower.begin(),flower.end());\\n\\t\\t\\n\\t\\t// This r is for storing the flower that will be used \\n        vector<long long>r; \\n        r.push_back(0); \\n        for(int i = 1 ; i < n ; i++){\\n            long long cur = r.back() + i*(flower[i] - flower[i-1]); \\n            r.push_back(cur);\\n        }\\n        reverse(flower.begin(),flower.end());\\n        long long ans = 0 ;\\n        long long sum = 0 ; \\n        for(int i = 0 ; i < n ; i++){\\n            \\n            //i : complete , n-i : incomplete \\n            long long k = newFlowers ; \\n            long long req = 1ll * i*target - sum ; \\n            if(k < req) break ;\\n            sum += min(flower[i], target); \\n            k -= max(0ll , req) ; \\n        \\n            long long int cur = 1ll * i * full ; \\n            if(flower[i] >= target){\\n                ans = max(ans , cur) ;\\n                r.pop_back(); \\n                continue ; \\n            }\\n\\t\\t\\t\\n            auto I = upper_bound(r.begin(),r.end(),k)-r.begin(); \\n            I = I - 1; \\n            \\n            k -= r[I]; \\n            long long Min = flower[n - I - 1] ; \\n            long long inc = k/(I+1); \\n            Min = min(Min+inc , 1ll * target-1) ; \\n\\t\\t\\t\\n            cur += Min * partial ; \\n\\t\\t\\t\\n            ans = max(ans , cur) ;\\n\\t\\t\\t\\n\\t\\t\\t//popping because next time we will have 1 complete garden more \\n            r.pop_back(); \\n            \\n        }\\n        \\n        if((1ll * n*target - sum) < newFlowers){\\n            ans = max(ans ,1ll * n *full); \\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932731,
                "title": "java-sort-prefix-sum-preprocessing-and-scan-o-nlogn-solution-45ms-beats-100",
                "content": "**Ituition**\\n* We want to add complete garden gradually and try to maximize the minimum number of the incomplete gardens.\\n* Apparently sort can help achieve the goal.\\n* For the complete garden, we can try to increase the number of complete gardens from the end of the array. In this way, we can use the minimum number of flowers to do it.\\n* To maximize the minimum number of incomplete garden, we can maintain another pointer to test if it can be the mimumum value after we plant the remaining flowers.\\n* If it can be the minimum value, it means all the other values appears before it must have the same value. If we have a prefix sum array, we can calculate if it\\'s doable quickly.\\n* As the remaining flowers will keep decreasing, the pointer we used must move to the left side accordingly. Hence, we can have O(N) search solution here.\\n* We also need to handle the case - when we make up the minimum value, we may still have some flowers left and we should try to use all of them.\\n* Overall time complexity is O(NLogN) as (1) Sorting O(NLogN) (2) prefix sum O(N) (3) Two pointer search O(N)\\n\\n```\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        int n = flowers.length;\\n        long[] prefix = new long[n + 1];\\n        Arrays.sort(flowers);\\n        for (int i = 0; i < n; ++i) prefix[i + 1] = prefix[i] + Math.min(flowers[i], target);\\n        long res = 0;\\n        for (int c = 0, i = n - 1; c <= n; ++c) {\\n            long remain = prefix[n] - prefix[n - c] + newFlowers - c * (long) target, min = 0;\\n            if (0 > remain) break;\\n            i = Math.min(i, n - c - 1);\\n            while (0 <= i && (target <= flowers[i] || flowers[i] * (long) (i + 1) - prefix[i + 1] > remain)) i--;\\n            if (0 <= i) {\\n                long dif = flowers[i] * (long) (i + 1) - prefix[i + 1];\\n                min = Math.min(target - 1, flowers[i] + (remain - dif) / (i + 1));\\n                if (i + 1 < n - c) min = Math.min(min, flowers[i + 1]);\\n            }\\n            res = Math.max(res, c * (long) full + min * (long) partial);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        int n = flowers.length;\\n        long[] prefix = new long[n + 1];\\n        Arrays.sort(flowers);\\n        for (int i = 0; i < n; ++i) prefix[i + 1] = prefix[i] + Math.min(flowers[i], target);\\n        long res = 0;\\n        for (int c = 0, i = n - 1; c <= n; ++c) {\\n            long remain = prefix[n] - prefix[n - c] + newFlowers - c * (long) target, min = 0;\\n            if (0 > remain) break;\\n            i = Math.min(i, n - c - 1);\\n            while (0 <= i && (target <= flowers[i] || flowers[i] * (long) (i + 1) - prefix[i + 1] > remain)) i--;\\n            if (0 <= i) {\\n                long dif = flowers[i] * (long) (i + 1) - prefix[i + 1];\\n                min = Math.min(target - 1, flowers[i] + (remain - dif) / (i + 1));\\n                if (i + 1 < n - c) min = Math.min(min, flowers[i + 1]);\\n            }\\n            res = Math.max(res, c * (long) full + min * (long) partial);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981158,
                "title": "one-easy-step-forward-from-binary-search-to-two-pointers",
                "content": "During the contest, I solved this problem with binary search. And now, there\\'re a lot of binary-search solutions with detailed explanation and diagrams. \\n\\n**Before reading this post, you need to first read and understand: https://leetcode.com/poblems/maximum-total-beauty-of-the-gardens/discuss/1931085/Python-Explanation-with-pictures-Greedy (or any other posts about binary-search solutions) as I\\'m not going to explain the binary-search solution here.**\\n\\nIf you follow the aforementioned post, you may write your own version of binary search like mine:\\n\\n```c++\\n// Binary Search \\n// Time: O(nlogn)\\n// Space: O(n)\\n\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        const long long n = flowers.size();\\n        std::sort(flowers.begin(), flowers.end());\\n        std::vector<long long> costs(n, 0);\\n        // special case 1: all gardens are already complete\\n        if(flowers[0] >= target){\\n            return full * n;\\n        }\\n        flowers[0] = std::min(flowers[0], target); // cap it\\n        long long last_partial = 0;\\n        for(long long i = 1; i < n; ++i){\\n            if(flowers[i] >= target){\\n                flowers[i] = target;\\n            } else{\\n                last_partial = i;\\n            }\\n            costs[i] = costs[i - 1] + (flowers[i] - flowers[i - 1]) * i;\\n        }\\n        // special case 2: all gardens can be complete\\n        if(costs.back() + n * (target - flowers.back()) <= newFlowers){\\n            return std::max(full * n, full * (n - 1) + partial * static_cast<long long>(target - 1));\\n        }\\n        long long res = 0;\\n        for(auto first_complete = last_partial + 1; first_complete >= 0; --first_complete){\\n            newFlowers -= first_complete == n ? 0 : (target - flowers[first_complete]);\\n            if(newFlowers < 0){\\n                break;\\n            }\\n            // try to fill the first [0, first_complete) gardens to their maximum partial \\n            const auto it = std::upper_bound(costs.begin(), costs.begin() + first_complete, newFlowers);\\n            const auto extra = (newFlowers - *(it - 1)) / (it - costs.begin());\\n            res = std::max(res, full * (n - first_complete) + partial * (extra + flowers[it - costs.begin() - 1]));\\n        }\\n        return res;\\n        \\n    }\\n};\\n```\\n\\nWell, this is neat, and efficient enough with `O(nlogn)` complexity. And I would say this suffices for you to ace the Leetcode contest and any techinical interviews.\\n\\nBut wait a minute, just like me, you come across some other posts about two-pointer solutions and you want to optimize your code further! Unfortunately, as for now, these top posts about two-pointers solutions are not well written (in my opinion), and you don\\'t want to spend a whole lot of time reading and understanding their pieces of code.\\n\\nDon\\'t fret, from binary search to two pointers, there\\'s only a very small step forward. And that\\'s exactly what I\\'m going to write about.\\n\\nFirst, let\\'s take a look at the code (or the binary-search solution) above, and you may have already noticed:\\n\\n**When we iterate over `first_complete` and then do the binary search to find the maximal `it` for each `first_complete`, as `first_complete` decreases, `it` can never increase as `newFlowers` always decrease.** \\n\\n```c++\\nconst auto it = std::upper_bound(costs.begin(), costs.begin() + first_complete, newFlowers);\\n```\\n\\nThis is because as we make more gardens complete, we have fewer new flowers to optimize the first several incomplete gardens. Quite intutive.\\n\\nThen, to utilize this observation, instead of doing binary search each time, we may simply use another variable `best_effort` to **remember** the last position of `it` and decrement it all the time, which is the second pointer we need! (The first pointer is `first_complete` of course.) \\n\\nTherefore, with this key observation, to make the step forward from binary search to two pointers, you don\\'t need to make much modification to your code at all! And for your reference, you can see that most of my code is **the same**:\\n\\n```c++\\n// Sort + Two Pointers\\n// Time: O(nlogn)\\n// Space: O(n)\\n\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        const long long n = flowers.size();\\n        std::sort(flowers.begin(), flowers.end());\\n        std::vector<long long> costs(n, 0);\\n        // special case 1: all gardens are already complete\\n        if(flowers[0] >= target){\\n            return full * n;\\n        }\\n        flowers[0] = std::min(flowers[0], target); // cap it\\n        long long last_partial = 0;\\n        for(long long i = 1; i < n; ++i){\\n            if(flowers[i] >= target){\\n                flowers[i] = target;\\n            } else{\\n                last_partial = i;\\n            }\\n            costs[i] = costs[i - 1] + (flowers[i] - flowers[i - 1]) * i;\\n        }\\n        // special case 2: all gardens can be complete\\n        if(costs.back() + n * (target - flowers.back()) <= newFlowers){\\n            return std::max(full * n, full * (n - 1) + partial * static_cast<long long>(target - 1));\\n        }\\n        long long res = 0;\\n\\t\\t// --- ALL code above is the same as the binary-search solution --- //\\n        for(auto first_complete = last_partial + 1, best_effort = last_partial; first_complete >= 0; --first_complete){\\n            newFlowers -= first_complete == n ? 0 : (target - flowers[first_complete]);\\n            if(newFlowers < 0){\\n                break;\\n            }\\n            best_effort = std::min(best_effort, first_complete - 1);\\n            // try to fill the first [0, first_complete) gardens to their maximum partial \\n\\t\\t\\t// -> instead of binary search, we use another pointer here\\n            while(best_effort >= 0 && costs[best_effort] > newFlowers){\\n                --best_effort;\\n            }\\n            // we can only maximize [0, best_effort] gardens\\n            const auto extra = (newFlowers - costs[best_effort]) / (best_effort + 1);\\n            res = std::max(res, full * (n - first_complete) + partial * (extra + flowers[best_effort]));\\n        }\\n        return res;\\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```c++\\n// Binary Search \\n// Time: O(nlogn)\\n// Space: O(n)\\n\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        const long long n = flowers.size();\\n        std::sort(flowers.begin(), flowers.end());\\n        std::vector<long long> costs(n, 0);\\n        // special case 1: all gardens are already complete\\n        if(flowers[0] >= target){\\n            return full * n;\\n        }\\n        flowers[0] = std::min(flowers[0], target); // cap it\\n        long long last_partial = 0;\\n        for(long long i = 1; i < n; ++i){\\n            if(flowers[i] >= target){\\n                flowers[i] = target;\\n            } else{\\n                last_partial = i;\\n            }\\n            costs[i] = costs[i - 1] + (flowers[i] - flowers[i - 1]) * i;\\n        }\\n        // special case 2: all gardens can be complete\\n        if(costs.back() + n * (target - flowers.back()) <= newFlowers){\\n            return std::max(full * n, full * (n - 1) + partial * static_cast<long long>(target - 1));\\n        }\\n        long long res = 0;\\n        for(auto first_complete = last_partial + 1; first_complete >= 0; --first_complete){\\n            newFlowers -= first_complete == n ? 0 : (target - flowers[first_complete]);\\n            if(newFlowers < 0){\\n                break;\\n            }\\n            // try to fill the first [0, first_complete) gardens to their maximum partial \\n            const auto it = std::upper_bound(costs.begin(), costs.begin() + first_complete, newFlowers);\\n            const auto extra = (newFlowers - *(it - 1)) / (it - costs.begin());\\n            res = std::max(res, full * (n - first_complete) + partial * (extra + flowers[it - costs.begin() - 1]));\\n        }\\n        return res;\\n        \\n    }\\n};\\n```\n```c++\\nconst auto it = std::upper_bound(costs.begin(), costs.begin() + first_complete, newFlowers);\\n```\n```c++\\n// Sort + Two Pointers\\n// Time: O(nlogn)\\n// Space: O(n)\\n\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        const long long n = flowers.size();\\n        std::sort(flowers.begin(), flowers.end());\\n        std::vector<long long> costs(n, 0);\\n        // special case 1: all gardens are already complete\\n        if(flowers[0] >= target){\\n            return full * n;\\n        }\\n        flowers[0] = std::min(flowers[0], target); // cap it\\n        long long last_partial = 0;\\n        for(long long i = 1; i < n; ++i){\\n            if(flowers[i] >= target){\\n                flowers[i] = target;\\n            } else{\\n                last_partial = i;\\n            }\\n            costs[i] = costs[i - 1] + (flowers[i] - flowers[i - 1]) * i;\\n        }\\n        // special case 2: all gardens can be complete\\n        if(costs.back() + n * (target - flowers.back()) <= newFlowers){\\n            return std::max(full * n, full * (n - 1) + partial * static_cast<long long>(target - 1));\\n        }\\n        long long res = 0;\\n\\t\\t// --- ALL code above is the same as the binary-search solution --- //\\n        for(auto first_complete = last_partial + 1, best_effort = last_partial; first_complete >= 0; --first_complete){\\n            newFlowers -= first_complete == n ? 0 : (target - flowers[first_complete]);\\n            if(newFlowers < 0){\\n                break;\\n            }\\n            best_effort = std::min(best_effort, first_complete - 1);\\n            // try to fill the first [0, first_complete) gardens to their maximum partial \\n\\t\\t\\t// -> instead of binary search, we use another pointer here\\n            while(best_effort >= 0 && costs[best_effort] > newFlowers){\\n                --best_effort;\\n            }\\n            // we can only maximize [0, best_effort] gardens\\n            const auto extra = (newFlowers - costs[best_effort]) / (best_effort + 1);\\n            res = std::max(res, full * (n - first_complete) + partial * (extra + flowers[best_effort]));\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942700,
                "title": "java-n-log-n-solution-greedy-sorting-prefix-sum",
                "content": "```\\nclass Solution {\\n    \\n    //BST\\n    private long getMax(int index,long rem,long target,long prefix_sum[],long arr[]){\\n        int left=0,right=index,in=-1;\\n        while(right>=left){\\n            int mid=left+(right-left)/2;\\n            \\n            //For calculating the value which we will add\\n            long val=(arr[mid]*(mid+1)-prefix_sum[mid]);\\n            if(rem>=val){\\n                \\n                //getting the index\\n                in=mid;\\n                left=mid+1;\\n            }else{\\n                right=mid-1;\\n            }\\n        }\\n        \\n        // edge case-1 in==-1 return 0;\\n        // edge case-2 in!=-1 return Math.min((rem+prefix_sum[in])/(in+1),target-1); \\n        // because we ultimately want a number which is less than target\\n        return in==-1?0:(Math.min((rem+prefix_sum[in])/(in+1),target-1));\\n    }\\n    public long maximumBeauty(int[] fl, long t, long target, long full, long partial) {\\n        \\n        //Edge case for fl having length 1\\n        if(fl.length==1){\\n            if(fl[0]>=target)\\n                return full;\\n            long result=Math.min(target-1,fl[0]+t)*partial;\\n            if(fl[0]+t>=target)\\n                result=Math.max(result,full);\\n            return result;\\n        }\\n        \\n        //converting the array to long array\\n        long arr[]=new long[fl.length];\\n        for(int i=0;i<fl.length;i++)\\n            arr[i]=(long)fl[i];\\n        \\n        //Sort the array for applying BST\\n        Arrays.sort(arr);\\n        \\n        //for removing the greatest or equal to elements than target\\n        int i=arr.length-1;\\n        while(i>-1&&arr[i]>=target)\\n            i--;\\n        long mid_val=(arr.length-i-1)*full;\\n        if(i==-1)\\n            return mid_val;\\n        \\n        //for prefix sum\\n        long prefix_sum[]=new long[arr.length];\\n        prefix_sum[0]=arr[0];\\n        for(int j=1;j<arr.length;j++)\\n            prefix_sum[j]=prefix_sum[j-1]+arr[j];\\n        \\n        // The present length after the reduction of the greatest or equal elements target\\n        int len=i+1;\\n        \\n        //Edge case 1\\n        long result=getMax(len-1,t,target,prefix_sum,arr)*partial;\\n        \\n        //Edge case 2\\n        if(t-target*(len)+prefix_sum[len-1]>=0)\\n            result=Math.max(result,len*full);\\n        \\n        // initialize sum=0 for calculating the sum in whie loop\\n        long sum=0;\\n        \\n        while(i>0){\\n            sum+=arr[i];\\n            long v=t-target*(len-i)+sum;\\n            if(v<0)\\n                break;\\n            result=Math.max(result,getMax(i-1,v,target,prefix_sum,arr)*partial+full*(len-i));\\n            i--;\\n        }\\n        \\n        //Return the result as mid_val+result\\n        return result+mid_val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Greedy",
                    "Sorting",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //BST\\n    private long getMax(int index,long rem,long target,long prefix_sum[],long arr[]){\\n        int left=0,right=index,in=-1;\\n        while(right>=left){\\n            int mid=left+(right-left)/2;\\n            \\n            //For calculating the value which we will add\\n            long val=(arr[mid]*(mid+1)-prefix_sum[mid]);\\n            if(rem>=val){\\n                \\n                //getting the index\\n                in=mid;\\n                left=mid+1;\\n            }else{\\n                right=mid-1;\\n            }\\n        }\\n        \\n        // edge case-1 in==-1 return 0;\\n        // edge case-2 in!=-1 return Math.min((rem+prefix_sum[in])/(in+1),target-1); \\n        // because we ultimately want a number which is less than target\\n        return in==-1?0:(Math.min((rem+prefix_sum[in])/(in+1),target-1));\\n    }\\n    public long maximumBeauty(int[] fl, long t, long target, long full, long partial) {\\n        \\n        //Edge case for fl having length 1\\n        if(fl.length==1){\\n            if(fl[0]>=target)\\n                return full;\\n            long result=Math.min(target-1,fl[0]+t)*partial;\\n            if(fl[0]+t>=target)\\n                result=Math.max(result,full);\\n            return result;\\n        }\\n        \\n        //converting the array to long array\\n        long arr[]=new long[fl.length];\\n        for(int i=0;i<fl.length;i++)\\n            arr[i]=(long)fl[i];\\n        \\n        //Sort the array for applying BST\\n        Arrays.sort(arr);\\n        \\n        //for removing the greatest or equal to elements than target\\n        int i=arr.length-1;\\n        while(i>-1&&arr[i]>=target)\\n            i--;\\n        long mid_val=(arr.length-i-1)*full;\\n        if(i==-1)\\n            return mid_val;\\n        \\n        //for prefix sum\\n        long prefix_sum[]=new long[arr.length];\\n        prefix_sum[0]=arr[0];\\n        for(int j=1;j<arr.length;j++)\\n            prefix_sum[j]=prefix_sum[j-1]+arr[j];\\n        \\n        // The present length after the reduction of the greatest or equal elements target\\n        int len=i+1;\\n        \\n        //Edge case 1\\n        long result=getMax(len-1,t,target,prefix_sum,arr)*partial;\\n        \\n        //Edge case 2\\n        if(t-target*(len)+prefix_sum[len-1]>=0)\\n            result=Math.max(result,len*full);\\n        \\n        // initialize sum=0 for calculating the sum in whie loop\\n        long sum=0;\\n        \\n        while(i>0){\\n            sum+=arr[i];\\n            long v=t-target*(len-i)+sum;\\n            if(v<0)\\n                break;\\n            result=Math.max(result,getMax(i-1,v,target,prefix_sum,arr)*partial+full*(len-i));\\n            i--;\\n        }\\n        \\n        //Return the result as mid_val+result\\n        return result+mid_val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977624,
                "title": "c-java-python-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***C++***\\n```\\nclass Solution \\n{\\n    public:\\n        long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) \\n        {\\n            int n = flowers.size();\\n            sort(flowers.begin(), flowers.end());\\n            if(n == 0)\\n                return 0;\\n            \\n   \\n            vector<long long>pre(n + 1, 0);\\n            \\n            for(int i = 1; i <= n; i++)\\n                pre[i] = pre[i - 1] + (long long)flowers[i - 1];\\n            \\n            long long res = LLONG_MIN;\\n            \\n            for(int t = n; t >= 0; t--)\\n            {\\n               \\n                long long fullCost = 0;\\n                long long partialCost = 0;\\n                \\n            \\n                if(t < n)\\n                {\\n                    if(flowers[t] < target)\\n                    {\\n                        long long need = (long long)target - (long long)flowers[t];\\n                        \\n                   \\n                        if(need > newFlowers)\\n                            break;\\n                        newFlowers -= need;\\n                    }\\n                }\\n                \\n                fullCost  = (long long)(n - t) * full;\\n                \\n                int l = 0;\\n                int r = target - 1;\\n                \\n                while(l <= r)\\n                {\\n                    int mid = l + (r - l) / 2; \\n                    int idx = upper_bound(flowers.begin(), flowers.begin() + t, mid) - flowers.begin(); \\n                    \\n                    if(idx == 0)\\n                    {\\n                        l = mid + 1;\\n                    }\\n                    else\\n                    {\\n                      \\n                        long long needToPlant = ((long long)mid * (long long)idx - pre[idx]);\\n                        \\n                        if(needToPlant > newFlowers)\\n                            r = mid - 1;\\n                        else\\n                        {\\n                            l = mid + 1;\\n                            partialCost = (long long)mid * partial;\\n                        }\\n                    }\\n                }\\n           \\n                res = max(res, fullCost + partialCost);\\n            }\\n            \\n            return res;\\n        }\\n};\\n```\\n\\n***Java***\\n```\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        int n = flowers.length;\\n        long[] prefix = new long[n + 1];\\n        Arrays.sort(flowers);\\n        for (int i = 0; i < n; ++i) prefix[i + 1] = prefix[i] + Math.min(flowers[i], target);\\n        long res = 0;\\n        for (int c = 0, i = n - 1; c <= n; ++c) {\\n            long remain = prefix[n] - prefix[n - c] + newFlowers - c * (long) target, min = 0;\\n            if (0 > remain) break;\\n            i = Math.min(i, n - c - 1);\\n            while (0 <= i && (target <= flowers[i] || flowers[i] * (long) (i + 1) - prefix[i + 1] > remain)) i--;\\n            if (0 <= i) {\\n                long dif = flowers[i] * (long) (i + 1) - prefix[i + 1];\\n                min = Math.min(target - 1, flowers[i] + (remain - dif) / (i + 1));\\n                if (i + 1 < n - c) min = Math.min(min, flowers[i + 1]);\\n            }\\n            res = Math.max(res, c * (long) full + min * (long) partial);\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n***Python***\\n```\\nimport bisect\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        n = len(flowers)\\n        flowers.sort()\\n        pre,lack = [0],[0]\\n        \\n        # corner case in which no incomplete garden can be created. \\n        if flowers[0] >= target:\\n            return n*full\\n        \\n        # pre-sum in an ascending order\\n        for i in flowers:\\n            pre.append(pre[-1]+i)\\n        \\n        # pre-sum in a descending order, meanwhile, count how many gardens are already full\\n        cnt = 0\\n        for i in flowers[::-1]:\\n            if i >= target:\\n                cnt+=1\\n            lack.append(lack[-1]+max(target-i,0))\\n        \\n        # conditional checker: whether all first k elements can >= flower after adding f to them\\n        def fill(flower,f,k):\\n            i = bisect.bisect_left(flowers,flower,lo=0,hi=k)\\n            return pre[i] + f >= i*flower\\n            \\n        res = 0\\n        # start from the min number of full gardens\\n        for k in range(cnt,n):\\n            if lack[k] < newFlowers:\\n                left, right = flowers[0], target+1\\n                while left < right:\\n                    mid = (left+right)//2\\n                    if not fill(mid,newFlowers-lack[k],n-k):\\n                        right = mid\\n                    else:\\n                        left = mid + 1\\n                left -= 1\\n                \\n                if left >= target:\\n                    # the n-k gardens must be incomplete, which can have a max value as target-1\\n                    \\n                    res = max(res,(target-1)*partial+k*full)\\n                else:\\n                    res = max(res,k*full+left*partial)\\n        \\n        # A corner case: All n gardens can be full, no incomplete gardens\\n        if lack[-1] <= newFlowers:\\n            res = max(res,n*full)\\n        return res\\n```\\n\\n***Consider upvote if useful!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n        long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) \\n        {\\n            int n = flowers.size();\\n            sort(flowers.begin(), flowers.end());\\n            if(n == 0)\\n                return 0;\\n            \\n   \\n            vector<long long>pre(n + 1, 0);\\n            \\n            for(int i = 1; i <= n; i++)\\n                pre[i] = pre[i - 1] + (long long)flowers[i - 1];\\n            \\n            long long res = LLONG_MIN;\\n            \\n            for(int t = n; t >= 0; t--)\\n            {\\n               \\n                long long fullCost = 0;\\n                long long partialCost = 0;\\n                \\n            \\n                if(t < n)\\n                {\\n                    if(flowers[t] < target)\\n                    {\\n                        long long need = (long long)target - (long long)flowers[t];\\n                        \\n                   \\n                        if(need > newFlowers)\\n                            break;\\n                        newFlowers -= need;\\n                    }\\n                }\\n                \\n                fullCost  = (long long)(n - t) * full;\\n                \\n                int l = 0;\\n                int r = target - 1;\\n                \\n                while(l <= r)\\n                {\\n                    int mid = l + (r - l) / 2; \\n                    int idx = upper_bound(flowers.begin(), flowers.begin() + t, mid) - flowers.begin(); \\n                    \\n                    if(idx == 0)\\n                    {\\n                        l = mid + 1;\\n                    }\\n                    else\\n                    {\\n                      \\n                        long long needToPlant = ((long long)mid * (long long)idx - pre[idx]);\\n                        \\n                        if(needToPlant > newFlowers)\\n                            r = mid - 1;\\n                        else\\n                        {\\n                            l = mid + 1;\\n                            partialCost = (long long)mid * partial;\\n                        }\\n                    }\\n                }\\n           \\n                res = max(res, fullCost + partialCost);\\n            }\\n            \\n            return res;\\n        }\\n};\\n```\n```\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        int n = flowers.length;\\n        long[] prefix = new long[n + 1];\\n        Arrays.sort(flowers);\\n        for (int i = 0; i < n; ++i) prefix[i + 1] = prefix[i] + Math.min(flowers[i], target);\\n        long res = 0;\\n        for (int c = 0, i = n - 1; c <= n; ++c) {\\n            long remain = prefix[n] - prefix[n - c] + newFlowers - c * (long) target, min = 0;\\n            if (0 > remain) break;\\n            i = Math.min(i, n - c - 1);\\n            while (0 <= i && (target <= flowers[i] || flowers[i] * (long) (i + 1) - prefix[i + 1] > remain)) i--;\\n            if (0 <= i) {\\n                long dif = flowers[i] * (long) (i + 1) - prefix[i + 1];\\n                min = Math.min(target - 1, flowers[i] + (remain - dif) / (i + 1));\\n                if (i + 1 < n - c) min = Math.min(min, flowers[i + 1]);\\n            }\\n            res = Math.max(res, c * (long) full + min * (long) partial);\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nimport bisect\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        n = len(flowers)\\n        flowers.sort()\\n        pre,lack = [0],[0]\\n        \\n        # corner case in which no incomplete garden can be created. \\n        if flowers[0] >= target:\\n            return n*full\\n        \\n        # pre-sum in an ascending order\\n        for i in flowers:\\n            pre.append(pre[-1]+i)\\n        \\n        # pre-sum in a descending order, meanwhile, count how many gardens are already full\\n        cnt = 0\\n        for i in flowers[::-1]:\\n            if i >= target:\\n                cnt+=1\\n            lack.append(lack[-1]+max(target-i,0))\\n        \\n        # conditional checker: whether all first k elements can >= flower after adding f to them\\n        def fill(flower,f,k):\\n            i = bisect.bisect_left(flowers,flower,lo=0,hi=k)\\n            return pre[i] + f >= i*flower\\n            \\n        res = 0\\n        # start from the min number of full gardens\\n        for k in range(cnt,n):\\n            if lack[k] < newFlowers:\\n                left, right = flowers[0], target+1\\n                while left < right:\\n                    mid = (left+right)//2\\n                    if not fill(mid,newFlowers-lack[k],n-k):\\n                        right = mid\\n                    else:\\n                        left = mid + 1\\n                left -= 1\\n                \\n                if left >= target:\\n                    # the n-k gardens must be incomplete, which can have a max value as target-1\\n                    \\n                    res = max(res,(target-1)*partial+k*full)\\n                else:\\n                    res = max(res,k*full+left*partial)\\n        \\n        # A corner case: All n gardens can be full, no incomplete gardens\\n        if lack[-1] <= newFlowers:\\n            res = max(res,n*full)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935513,
                "title": "python-greedy-algorithm-o-nlogn-no-binary-search",
                "content": "Based on https://leetcode.com/problems/maximum-total-beauty-of-the-gardens/discuss/1931085/Python-Explanation-with-pictures-Greedy.\\n```\\nfrom bisect import bisect_right\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers = [min(target, e) for e in flowers]\\n        flowers.sort()\\n        n = len(flowers)\\n        if min(flowers) == target: return n*full\\n        if newFlowers >= target*n - sum(flowers):\\n            return max(full*n, (n-1)*full + (target-1)*partial)\\n        cost = [0]*n\\n        for i in range(1,n):\\n            cost[i] = cost[i-1] + i*(flowers[i]-flowers[i-1])\\n        j = n - 1\\n        while flowers[j] == target:\\n            j -= 1\\n        res = 0\\n        l = j\\n        while newFlowers >= 0:\\n            while cost[l] > newFlowers:\\n                l -= 1\\n            idx = min(j, l)\\n            cur_min = flowers[idx] + (newFlowers-cost[idx])//(idx+1)\\n            res = max(res, cur_min*partial+full*(n-j-1))\\n            newFlowers -= (target-flowers[j])\\n            j -= 1\\n        return res\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Based on https://leetcode.com/problems/maximum-total-beauty-of-the-gardens/discuss/1931085/Python-Explanation-with-pictures-Greedy.\\n```\\nfrom bisect import bisect_right\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers = [min(target, e) for e in flowers]\\n        flowers.sort()\\n        n = len(flowers)\\n        if min(flowers) == target: return n*full\\n        if newFlowers >= target*n - sum(flowers):\\n            return max(full*n, (n-1)*full + (target-1)*partial)\\n        cost = [0]*n\\n        for i in range(1,n):\\n            cost[i] = cost[i-1] + i*(flowers[i]-flowers[i-1])\\n        j = n - 1\\n        while flowers[j] == target:\\n            j -= 1\\n        res = 0\\n        l = j\\n        while newFlowers >= 0:\\n            while cost[l] > newFlowers:\\n                l -= 1\\n            idx = min(j, l)\\n            cur_min = flowers[idx] + (newFlowers-cost[idx])//(idx+1)\\n            res = max(res, cur_min*partial+full*(n-j-1))\\n            newFlowers -= (target-flowers[j])\\n            j -= 1\\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 1932539,
                "title": "c-time-100-space-100-o-nlogn-prefix-sum-binary-search-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        if (target == flowers[0]) return flowers.size() * (long long)full;\\n        int n = flowers.size();\\n        long long max_beauty = 0;\\n        \\n        vector<long long> required_flower(n, 0);   //required_flower[i]: Number of flowers required to make first i gardens have at least flowers[i] flowers;\\n        for (int i = 1; i < n; ++i) {\\n            required_flower[i] = required_flower[i - 1] + i * (long long)(flowers[i] - flowers[i - 1]);\\n        }\\n        for (int j = n; j >= 0; --j) {\\n            if (j != n && flowers[j] < target) {                             //if j already full, we don\\'t decrease avaialble flowers\\n                newFlowers -= (target - flowers[j]);\\n            }\\n            if (newFlowers <= -1) break;                                    //if number of avaiable flowers smaller than 0\\n            long long score = (n - j) * (long long)full;                //score of making gardens j to n - 1 full\\n            if (j == 0) {                                                                //if j is at index 0, we don\\'t have any incomplete flowers\\n                max_beauty = max(score, max_beauty);\\n                break;\\n            }\\n            int candidate = max(0, binary_search(0, j - 1, newFlowers, required_flower));       \\n            long long max_flower = flowers[candidate] + (newFlowers - required_flower[candidate]) / (candidate + 1);    \\n            max_flower = min((long long)target - 1, max_flower);          //max flower of incomplete garden, can\\'t be higher or equal to target\\n            max_beauty = max(score + (long long)max_flower * partial, max_beauty);\\n        }\\n        return max_beauty;\\n    }\\n    int binary_search(int left, int right, int n, vector<long long>& vec) {\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (n >= vec[mid]) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return right;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        if (target == flowers[0]) return flowers.size() * (long long)full;\\n        int n = flowers.size();\\n        long long max_beauty = 0;\\n        \\n        vector<long long> required_flower(n, 0);   //required_flower[i]: Number of flowers required to make first i gardens have at least flowers[i] flowers;\\n        for (int i = 1; i < n; ++i) {\\n            required_flower[i] = required_flower[i - 1] + i * (long long)(flowers[i] - flowers[i - 1]);\\n        }\\n        for (int j = n; j >= 0; --j) {\\n            if (j != n && flowers[j] < target) {                             //if j already full, we don\\'t decrease avaialble flowers\\n                newFlowers -= (target - flowers[j]);\\n            }\\n            if (newFlowers <= -1) break;                                    //if number of avaiable flowers smaller than 0\\n            long long score = (n - j) * (long long)full;                //score of making gardens j to n - 1 full\\n            if (j == 0) {                                                                //if j is at index 0, we don\\'t have any incomplete flowers\\n                max_beauty = max(score, max_beauty);\\n                break;\\n            }\\n            int candidate = max(0, binary_search(0, j - 1, newFlowers, required_flower));       \\n            long long max_flower = flowers[candidate] + (newFlowers - required_flower[candidate]) / (candidate + 1);    \\n            max_flower = min((long long)target - 1, max_flower);          //max flower of incomplete garden, can\\'t be higher or equal to target\\n            max_beauty = max(score + (long long)max_flower * partial, max_beauty);\\n        }\\n        return max_beauty;\\n    }\\n    int binary_search(int left, int right, int n, vector<long long>& vec) {\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (n >= vec[mid]) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931773,
                "title": "java-binary-search-solution",
                "content": "```\\npublic long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n    int n = flowers.length;\\n\\n    List<Integer> gardens = new ArrayList<>();\\n\\n    for (int val : flowers) {\\n        if (val < target) {\\n            gardens.add(val);\\n        }\\n    }\\n\\n    if (gardens.size() == 0) {\\n        return (long) n * full;\\n    }\\n\\n    Collections.sort(gardens);\\n\\n    int m = gardens.size();\\n\\n    long[] costs = new long[m];\\n    for (int i = 1; i < m; ++i) {\\n        costs[i] = costs[i - 1] + (long) i * (gardens.get(i) - gardens.get(i - 1));\\n    }\\n\\n    long base = (long) (n - gardens.size()) * full;\\n    long max = 0;\\n\\n    for (int i = m - 1; i >= -1; --i) {\\n        long min = Math.min(getMin(gardens, costs, i, newFlowers), target - 1);\\n        max = Math.max(max, base + min * partial);\\n        if (i == -1 || target - gardens.get(i) > newFlowers) break;\\n        newFlowers -= target - gardens.get(i);\\n        base += full;\\n    }\\n\\n    return max;\\n}\\n\\nprivate long getMin(List<Integer> gardens, long[] costs, int i, long k, long limit) {\\n    if (i < 0) return 0;\\n    \\n    int l = 0, r = i;\\n    \\n    while (l < r) {\\n        int mid = (l + r) / 2 + 1;\\n        \\n        if (costs[mid] <= k) {\\n            l = mid;\\n        }\\n        else {\\n            r = mid - 1;\\n            limit = gardens.get(mid);\\n        }\\n    }\\n    \\n    return Math.min(gardens.get(l) + (k - costs[l]) / (l + 1), limit);\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n    int n = flowers.length;\\n\\n    List<Integer> gardens = new ArrayList<>();\\n\\n    for (int val : flowers) {\\n        if (val < target) {\\n            gardens.add(val);\\n        }\\n    }\\n\\n    if (gardens.size() == 0) {\\n        return (long) n * full;\\n    }\\n\\n    Collections.sort(gardens);\\n\\n    int m = gardens.size();\\n\\n    long[] costs = new long[m];\\n    for (int i = 1; i < m; ++i) {\\n        costs[i] = costs[i - 1] + (long) i * (gardens.get(i) - gardens.get(i - 1));\\n    }\\n\\n    long base = (long) (n - gardens.size()) * full;\\n    long max = 0;\\n\\n    for (int i = m - 1; i >= -1; --i) {\\n        long min = Math.min(getMin(gardens, costs, i, newFlowers), target - 1);\\n        max = Math.max(max, base + min * partial);\\n        if (i == -1 || target - gardens.get(i) > newFlowers) break;\\n        newFlowers -= target - gardens.get(i);\\n        base += full;\\n    }\\n\\n    return max;\\n}\\n\\nprivate long getMin(List<Integer> gardens, long[] costs, int i, long k, long limit) {\\n    if (i < 0) return 0;\\n    \\n    int l = 0, r = i;\\n    \\n    while (l < r) {\\n        int mid = (l + r) / 2 + 1;\\n        \\n        if (costs[mid] <= k) {\\n            l = mid;\\n        }\\n        else {\\n            r = mid - 1;\\n            limit = gardens.get(mid);\\n        }\\n    }\\n    \\n    return Math.min(gardens.get(l) + (k - costs[l]) / (l + 1), limit);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1931726,
                "title": "c-binary-search-comments",
                "content": "```\\n// Approach: Iterations  + Binary Search\\n// Time Complexity: NlogN (Approx.)\\n\\n// Idea: Idea is to complete k flowers and for remaining n - k flowers try to maximize the minimum by using remaining new flowers\\n\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        \\n        // Number of gardens\\n        int n = flowers.size();\\n    \\n        sort(flowers.begin(),flowers.end());\\n\\n        long long ans = 0;\\n\\n        // If All gardens are complete\\n        if(flowers[0] >= target)\\n        {\\n            return ((long long)n * full);\\n        }\\n\\n        // Prefix Sum Array\\n        long long prefix[n+1];\\n\\n        prefix[0] = 0;\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            prefix[i] = prefix[i-1] + flowers[i-1];\\n        }\\n\\n\\n        // Completed Gardens\\n        long long complete = 0;\\n\\n\\n        // Calculating Already Completed Gardens\\n        for(int i=n-1; i>= 0;i--)\\n        {\\n            if(flowers[i] >= target)\\n            {\\n                complete++;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n\\n        // This case if for keep the completed gardens as it is and try to maximize other flowers for partial multplication\\n        ans = (complete * full);\\n        long long lo = flowers[0];\\n        long long hi = target-1;\\n        long long minFlower = lo;\\n        while(lo <= hi)\\n        {\\n            long long mid = (lo + hi) / 2;\\n\\n            int count = flowers.end() - lower_bound(flowers.begin(),flowers.end(),mid);\\n\\n            int X = n - count;\\n\\n            long long req = mid * X - (prefix[X]);\\n\\n            if(req <= newFlowers)\\n            {\\n                minFlower = mid;\\n                lo = mid + 1;\\n\\n            }\\n            else\\n            {\\n                hi = mid - 1;\\n            }\\n\\n        }\\n\\n        ans += (minFlower * partial);\\n\\n        \\n\\n        for(int i=n - complete - 1;i >= 0;i--)\\n        {\\n            int diff = max(target - flowers[i], 0);\\n\\n            if(diff > newFlowers)\\n                break;\\n            newFlowers -= diff;\\n            complete++;\\n\\n            lo = flowers[0];\\n            hi = target - 1;\\n            minFlower = lo;\\n\\n            // Hey I have now make complete gardens \\n            // and now from remaining newFlowers try to maximize the flowers so that partial * min(flowers) will be maximums\\n            \\n            // Famous binary search implementation\\n            while(lo <= hi)\\n            {\\n                long long mid = (lo + hi) / 2;\\n\\n                int count = flowers.end() - lower_bound(flowers.begin(),flowers.begin() + n - complete,mid);\\n\\n                int X = n - count;\\n\\n                long long req = mid * X - (prefix[X]);\\n                \\n                if(req <= newFlowers)\\n                {\\n                    minFlower = mid;\\n                    lo = mid + 1;\\n\\n                }\\n                else\\n                {\\n                    hi = mid - 1;\\n                }\\n\\n            }\\n\\n            // Edge case if all completed then make the minFlower = 0\\n            if(complete == n)\\n                minFlower = 0;\\n\\n            // Try to maximize answer \\n            ans = max(complete * full + partial * minFlower,ans);\\n\\n        }\\n        \\n\\n        // You are done, return the answer\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        \\n        // Number of gardens\\n        int n = flowers.size();\\n    \\n        sort(flowers.begin(),flowers.end());\\n\\n        long long ans = 0;\\n\\n        // If All gardens are complete\\n        if(flowers[0] >= target)\\n        {\\n            return ((long long)n * full);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1931524,
                "title": "java-nlogn-small-proof-why-would-sort-work",
                "content": "Idea\\n1. Sort the array ,\\n2. choose every pivot from end to begin where element is less than target and make this = target\\n3. keep count of element >= target\\n4. Distribute remaining newFlowers from begining till index where it can be afforded\\n5. Check for max\\n\\nAttempt to Proof :\\n\\nTo maximize `MAX = (full * count (x_i >= target)) + (partial*(min(x_i < target))`  within contraints\\n\\nIterating count = 1 till length; \\n\\nSuppose this is sort order where `X0 = smallest , XN = largest in X0, X1, X2, X3, X4, X5...... XN`\\n\\n               We processed array till X5\\n\\n                X0, X1, X2, X3, X4, X5...... XN\\n\\t\\t\\t\\t\\t                |\\n\\t\\t\\t\\tNext to process is index = 4\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tSuppose X4 - X3 = d; \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tIf we increase the current count > target by 1, \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tto maximize MAX with count = N - 4\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t1. \\t\\tChoose sort order and process X4 after X5\\n\\n\\t\\t\\t\\t\\t\\t\\tX0, X1, X2, X3, X4, X5...... XN   \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t|\\n\\n\\t\\t\\t\\t\\t\\t\\tnewRemainingFlowersX4 = remaining - (target -  x4)\\n\\t\\t\\t\\t\\t\\t\\t\\n\\n\\t\\t\\t\\t2. Without loss of generality Choose X3 after X5 and keep count = N-4 same so full * count is same in MAX \\n\\n\\t\\t\\t\\t\\t\\t\\tX0, X1, X2, X4, X3, X5...... XN \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t|\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tnewRemainingflowersX3 =remaining - (target - x3)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tLets say our min in both remaining flowers was targeting (min = X4+a ) in arr[0......3]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tThen what remains to see that this can be achived in both cases \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tX0...X2 is same cost \\n\\t\\t\\t\\t\\n\\t\\t\\t\\teq 1 -> newRemainingFlowersX4 - newRemainingFlowersX3 = X4 - X3 = d;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\twhile extra cost to increase to min  = X4 + a in \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tcase 1 eq 2 -> X4-X3 + a = d+a\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tcase 2 = X4 - X4+ a = a;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tin eq1 extra d we get can be adjusted in eq2\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tSo sort order can be selected since min is not effected , count not effected  but remaining is more in can of sort order to process later elements.\\n\\t\\n\\t\\nLet me know your thoughts\\n\\n```\\nclass Solution {\\n\\tpublic long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n\\t\\tint len = flowers.length;\\n\\t\\tlong cumulativeCostArray[] = new long[len];\\n\\t\\tArrays.sort(flowers);\\n\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\t\\t\\tcumulativeCostArray[i] = cumulativeCostArray[i - 1] + (long) i * (flowers[i] - flowers[i - 1]);\\n\\t\\t}\\n\\n\\t\\tlong max = 0;\\n\\t\\tint i;\\n\\t\\tint countComplete = 0;\\n\\t\\tfor (i = len - 1; i >= 0; i--) {\\n\\t\\t\\tif (flowers[i] < target)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcountComplete++;\\n\\t\\t}\\n\\n\\t\\tif (countComplete == len)\\n\\t\\t\\treturn ((countComplete * (long) full));\\n\\n\\t\\tint id = binarySearchCumulativeCost(cumulativeCostArray, newFlowers, 0, i);\\n\\t\\tmax = currentPartitionCost(flowers, newFlowers, target, full, partial, cumulativeCostArray, max, countComplete, id);\\n\\n\\t\\tfor (int j = i; j >= 0; j--) {\\n\\t\\t\\tnewFlowers = newFlowers - (target - flowers[j]);\\n\\t\\t\\tif (newFlowers < 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcountComplete++;\\n\\t\\t\\tif (j == 0) {\\n\\t\\t\\t\\tmax = Math.max(max, countComplete * (long) full);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tid = binarySearchCumulativeCost(cumulativeCostArray, newFlowers, 0, j - 1);\\n\\t\\t\\tmax = Math.max(max, currentPartitionCost(flowers, newFlowers, target, full, partial, cumulativeCostArray, max,\\n\\t\\t\\t\\t\\tcountComplete, id));\\n\\t\\t}\\n\\n\\t\\treturn max;\\n\\t}\\n\\n\\tprivate long currentPartitionCost(int[] flowers, long newFlowers, int target, int full, int partial,\\n\\t\\t\\tlong[] costArray, long max, int countComplete, int id) {\\n\\t\\tif (id >= 0) {\\n\\t\\t\\tlong rem = (newFlowers - costArray[id]);\\n\\t\\t\\tlong minToAddFromRem = rem / (id + 1);\\n\\t\\t\\tmax = ((countComplete * (long) full) + ((Math.min(target - 1, minToAddFromRem + flowers[id])) * (long) partial));\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n\\n\\tpublic int binarySearchCumulativeCost(long cost[], long num, int s, int e) {\\n\\t\\tint i = s, j = e;\\n\\t\\twhile (i < j) {\\n\\t\\t\\tint mid = (i + j) / 2;\\n\\t\\t\\tif (cost[mid] <= num) {\\n\\t\\t\\t\\ti = mid + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tj = mid;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn cost[i] <= num ? i : (i - 1);\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n\\t\\tint len = flowers.length;\\n\\t\\tlong cumulativeCostArray[] = new long[len];\\n\\t\\tArrays.sort(flowers);\\n\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\t\\t\\tcumulativeCostArray[i] = cumulativeCostArray[i - 1] + (long) i * (flowers[i] - flowers[i - 1]);\\n\\t\\t}\\n\\n\\t\\tlong max = 0;\\n\\t\\tint i;\\n\\t\\tint countComplete = 0;\\n\\t\\tfor (i = len - 1; i >= 0; i--) {\\n\\t\\t\\tif (flowers[i] < target)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcountComplete++;\\n\\t\\t}\\n\\n\\t\\tif (countComplete == len)\\n\\t\\t\\treturn ((countComplete * (long) full));\\n\\n\\t\\tint id = binarySearchCumulativeCost(cumulativeCostArray, newFlowers, 0, i);\\n\\t\\tmax = currentPartitionCost(flowers, newFlowers, target, full, partial, cumulativeCostArray, max, countComplete, id);\\n\\n\\t\\tfor (int j = i; j >= 0; j--) {\\n\\t\\t\\tnewFlowers = newFlowers - (target - flowers[j]);\\n\\t\\t\\tif (newFlowers < 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcountComplete++;\\n\\t\\t\\tif (j == 0) {\\n\\t\\t\\t\\tmax = Math.max(max, countComplete * (long) full);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tid = binarySearchCumulativeCost(cumulativeCostArray, newFlowers, 0, j - 1);\\n\\t\\t\\tmax = Math.max(max, currentPartitionCost(flowers, newFlowers, target, full, partial, cumulativeCostArray, max,\\n\\t\\t\\t\\t\\tcountComplete, id));\\n\\t\\t}\\n\\n\\t\\treturn max;\\n\\t}\\n\\n\\tprivate long currentPartitionCost(int[] flowers, long newFlowers, int target, int full, int partial,\\n\\t\\t\\tlong[] costArray, long max, int countComplete, int id) {\\n\\t\\tif (id >= 0) {\\n\\t\\t\\tlong rem = (newFlowers - costArray[id]);\\n\\t\\t\\tlong minToAddFromRem = rem / (id + 1);\\n\\t\\t\\tmax = ((countComplete * (long) full) + ((Math.min(target - 1, minToAddFromRem + flowers[id])) * (long) partial));\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n\\n\\tpublic int binarySearchCumulativeCost(long cost[], long num, int s, int e) {\\n\\t\\tint i = s, j = e;\\n\\t\\twhile (i < j) {\\n\\t\\t\\tint mid = (i + j) / 2;\\n\\t\\t\\tif (cost[mid] <= num) {\\n\\t\\t\\t\\ti = mid + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tj = mid;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn cost[i] <= num ? i : (i - 1);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886015,
                "title": "python-3-simple-interface-explained-o-nlogn-o-1",
                "content": "# Intuition\\nWe can forget about gardens that are originally complete, because we can\\'t change their state. Let\\'s assume that we don\\'t have such gardens, then:\\n* There are actually only $N+1$ candidates for an answer:\\n\\n  1 \\u2014 $0$ complete gardens and $N$ incomplete gardens (with maximized minimum amount of flowers)\\n  2 \\u2014 $1$ complete gardens and $N-1$ incomplete gardens (with maximized minimum amount of flowers)\\n    ...\\n  N+1 \\u2014 $N$ complete gardens and $0$ incomplete gardens (with maximized minimum amount of flowers)\\n\\nNow all we need is to find efficient approach to iterate over these candidates.\\n\\n* We can notice that we can do only 4 actions\\n    1. Make garden complete\\n    2. Maximize minimum number of flowers among incomplete gardens\\n    3. Revert operation (1)\\n    4. Revert operation (2)\\n\\nUsing this interface we can easily write an algorithm (pseudo-code):\\n```\\nm = 0  # number of complete gardens\\nwhile can_make_more_gardens_complete:\\n    make_garden_complete()  # Operation 1\\n    m += 1\\nmaximize_min_number_of_flowers()  # Operation 2\\nans = ...  # update answer\\nfor _ in range(m):\\n    make_garden_incomplete()  # Operation 3\\n    maximize_min_number_of_flowers()  # Operation 2\\n    ans = max(ans, ...)  # update answer\\nreturn ans\\n```\\n\\n* If we sort `flowers`: Operations (1), (3) can be implemented with $O(1)$ time, operation (2) can be implemented with $\\\\Omega(1)$ time and we don\\'t actually need operation (4)\\n\\n\\n# Complexity\\n- Time complexity: $$O(N\\\\log N)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        n = len(flowers)\\n        flowers.sort() \\n        originally_complete = sum(flowers[i] >= target for i in range(n))\\n        work_end = n - originally_complete\\n        # [0,        j-1] \\u2014 incomplete (with >=`level` flowers each, where `0 <= `level` <= target - 1) \\n        # [j, work_end-1] \\u2014 complete\\n        # [work_end, n-1] \\u2014 originally complete\\n\\n        i = -1\\n        level = 0\\n        def maximize_min_number_of_flowers() -> None:\\n            nonlocal i, level, newFlowers\\n            if j == 0:\\n                return\\n            if i == -1:\\n                i = 0\\n                level = flowers[0]\\n            while i < j:\\n                next_level = flowers[i+1] if i + 1 < j else target - 1\\n                max_boost = min(next_level - level, newFlowers // (i+1))\\n                level += max_boost\\n                newFlowers -= max_boost * (i+1)\\n                if level != next_level:\\n                    break\\n                i += 1\\n        \\n        j = work_end\\n        def add_complete_garden() -> bool:\\n            nonlocal j, newFlowers\\n            if j - 1 < 0 or newFlowers < target - flowers[j-1]:\\n                return False\\n            newFlowers -= target - flowers[j-1]\\n            j -= 1\\n            return True\\n        def remove_complete_garden() -> None:\\n            nonlocal j, newFlowers\\n            assert j < work_end\\n            newFlowers += target - flowers[j]\\n            flowers[j] = flowers[j]\\n            j += 1\\n\\n        while add_complete_garden():\\n            pass\\n        maximize_min_number_of_flowers()\\n        ans = full * (n - j) + partial * level\\n        while j < work_end:\\n            remove_complete_garden()\\n            maximize_min_number_of_flowers()\\n            ans = max(ans, full * (n - j) + partial * level)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nm = 0  # number of complete gardens\\nwhile can_make_more_gardens_complete:\\n    make_garden_complete()  # Operation 1\\n    m += 1\\nmaximize_min_number_of_flowers()  # Operation 2\\nans = ...  # update answer\\nfor _ in range(m):\\n    make_garden_incomplete()  # Operation 3\\n    maximize_min_number_of_flowers()  # Operation 2\\n    ans = max(ans, ...)  # update answer\\nreturn ans\\n```\n```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        n = len(flowers)\\n        flowers.sort() \\n        originally_complete = sum(flowers[i] >= target for i in range(n))\\n        work_end = n - originally_complete\\n        # [0,        j-1] \\u2014 incomplete (with >=`level` flowers each, where `0 <= `level` <= target - 1) \\n        # [j, work_end-1] \\u2014 complete\\n        # [work_end, n-1] \\u2014 originally complete\\n\\n        i = -1\\n        level = 0\\n        def maximize_min_number_of_flowers() -> None:\\n            nonlocal i, level, newFlowers\\n            if j == 0:\\n                return\\n            if i == -1:\\n                i = 0\\n                level = flowers[0]\\n            while i < j:\\n                next_level = flowers[i+1] if i + 1 < j else target - 1\\n                max_boost = min(next_level - level, newFlowers // (i+1))\\n                level += max_boost\\n                newFlowers -= max_boost * (i+1)\\n                if level != next_level:\\n                    break\\n                i += 1\\n        \\n        j = work_end\\n        def add_complete_garden() -> bool:\\n            nonlocal j, newFlowers\\n            if j - 1 < 0 or newFlowers < target - flowers[j-1]:\\n                return False\\n            newFlowers -= target - flowers[j-1]\\n            j -= 1\\n            return True\\n        def remove_complete_garden() -> None:\\n            nonlocal j, newFlowers\\n            assert j < work_end\\n            newFlowers += target - flowers[j]\\n            flowers[j] = flowers[j]\\n            j += 1\\n\\n        while add_complete_garden():\\n            pass\\n        maximize_min_number_of_flowers()\\n        ans = full * (n - j) + partial * level\\n        while j < work_end:\\n            remove_complete_garden()\\n            maximize_min_number_of_flowers()\\n            ans = max(ans, full * (n - j) + partial * level)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313576,
                "title": "python3-2-pointer",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/af907302ab84ad94ecb97eeeb9b0bfa529041e30) for solutions of weekly 288. \\n\\n```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers = sorted(min(target, x) for x in flowers)\\n        prefix = [0]\\n        ii = -1 \\n        for i in range(len(flowers)): \\n            if flowers[i] < target: ii = i \\n            if i: prefix.append(prefix[-1] + (flowers[i]-flowers[i-1])*i)\\n        ans = 0 \\n        for k in range(len(flowers)+1): \\n            if k: newFlowers -= target - flowers[-k]\\n            if newFlowers >= 0: \\n                while 0 <= ii and (ii+k >= len(flowers) or prefix[ii] > newFlowers): ii -= 1\\n                if 0 <= ii: kk = min(target-1, flowers[ii] + (newFlowers - prefix[ii])//(ii+1))\\n                else: kk = 0 \\n                ans = max(ans, k*full + kk*partial)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers = sorted(min(target, x) for x in flowers)\\n        prefix = [0]\\n        ii = -1 \\n        for i in range(len(flowers)): \\n            if flowers[i] < target: ii = i \\n            if i: prefix.append(prefix[-1] + (flowers[i]-flowers[i-1])*i)\\n        ans = 0 \\n        for k in range(len(flowers)+1): \\n            if k: newFlowers -= target - flowers[-k]\\n            if newFlowers >= 0: \\n                while 0 <= ii and (ii+k >= len(flowers) or prefix[ii] > newFlowers): ii -= 1\\n                if 0 <= ii: kk = min(target-1, flowers[ii] + (newFlowers - prefix[ii])//(ii+1))\\n                else: kk = 0 \\n                ans = max(ans, k*full + kk*partial)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980804,
                "title": "c-solution-easy-to-understand",
                "content": "Firstly, I  recommend to see a hint and then visiting a code. \\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long long funbin(vector<int> &v,vector<long long> &pre,long long f,int t)\\n    {\\n        \\n        if(v.size()==0 || v[0]>=t)\\n            return 0;\\n        int r = 0,l = t-1;\\n        while(r<=l)\\n        {\\n            long long mid = (r+l)/2;\\n            long long sum = 0;\\n            long long rr = 0,ll = v.size()-1;\\n            while(rr<=ll)\\n            {\\n                long long midd = (rr+ll)/2;\\n                if(v[midd]>=mid)\\n                    ll = midd-1;\\n                else\\n                    rr = midd+1;\\n            }\\n            \\n            if(ll>=0)\\n                sum = pre[ll];\\n            \\n            long long sum1 = 1ll*(ll+1)*(mid) - sum;\\n            \\n            if(sum1>f)\\n                l = mid-1;\\n            else\\n                r = mid+1;\\n        \\n        }\\n\\n        return l;\\n    }\\n    long long maximumBeauty(vector<int>& v, long long f, int t, int fu, int pa){\\n        \\n        sort(v.begin(),v.end());\\n        int n = v.size();\\n        vector<long long> pre(n);\\n        pre[0] = v[0];\\n        \\n        for(int i=1; i<v.size(); ++i)\\n            pre[i]+=pre[i-1] + v[i];\\n        \\n        long long fans = pa*funbin(v,pre,f,t);\\n        int coun = 0;\\n        while((int)v.size())\\n        {\\n            coun++;\\n            int x = v.back();\\n            v.pop_back();\\n            long long a = max(0,t-x);\\n            f-=a;\\n            if(f<0)\\n                break;\\n            \\n            long long lo = funbin(v,pre,f,t);\\n            \\n            fans = max(fans,1ll*coun*fu + 1ll*pa*lo);  \\n        }\\n        \\n        \\n        return fans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long funbin(vector<int> &v,vector<long long> &pre,long long f,int t)\\n    {\\n        \\n        if(v.size()==0 || v[0]>=t)\\n            return 0;\\n        int r = 0,l = t-1;\\n        while(r<=l)\\n        {\\n            long long mid = (r+l)/2;\\n            long long sum = 0;\\n            long long rr = 0,ll = v.size()-1;\\n            while(rr<=ll)\\n            {\\n                long long midd = (rr+ll)/2;\\n                if(v[midd]>=mid)\\n                    ll = midd-1;\\n                else\\n                    rr = midd+1;\\n            }\\n            \\n            if(ll>=0)\\n                sum = pre[ll];\\n            \\n            long long sum1 = 1ll*(ll+1)*(mid) - sum;\\n            \\n            if(sum1>f)\\n                l = mid-1;\\n            else\\n                r = mid+1;\\n        \\n        }\\n\\n        return l;\\n    }\\n    long long maximumBeauty(vector<int>& v, long long f, int t, int fu, int pa){\\n        \\n        sort(v.begin(),v.end());\\n        int n = v.size();\\n        vector<long long> pre(n);\\n        pre[0] = v[0];\\n        \\n        for(int i=1; i<v.size(); ++i)\\n            pre[i]+=pre[i-1] + v[i];\\n        \\n        long long fans = pa*funbin(v,pre,f,t);\\n        int coun = 0;\\n        while((int)v.size())\\n        {\\n            coun++;\\n            int x = v.back();\\n            v.pop_back();\\n            long long a = max(0,t-x);\\n            f-=a;\\n            if(f<0)\\n                break;\\n            \\n            long long lo = funbin(v,pre,f,t);\\n            \\n            fans = max(fans,1ll*coun*fu + 1ll*pa*lo);  \\n        }\\n        \\n        \\n        return fans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967273,
                "title": "c-detailed-solution-with-intuitive-explanation",
                "content": "\\t\\tthe idea is to sort the array first (why?...it\\'ll be clear as you go through the below explanation)\\n\\n\\t\\tthe beauty value (which we have to optimize) depends on two things\\n\\t\\t\\t- full*(# of complete gardens) [value 1]\\n\\t\\t\\t- partial *(minimum value of all the partial gardens) [value 2]\\n\\n\\t\\twhen we have to different things which our answer depends on, then it is better to fix on of them\\n\\t\\tand vary the other\\n\\n\\t\\there we will fix the first guy (full *(# of complete gardens))\\n\\n\\t\\tbasically what we are trying to do is:\\n\\t\\tfirst fix #of complete gardens to 1, and find the optimal value of the second value [partial *(minimum value of all the partial gardens)]\\n\\t\\tthen fix #of complete gardens to 2, and find the optimal value of the second value  [partial *(minimum value of all the partial gardens)]\\n\\n\\t\\tso in general fix #of complete gardens to x [by distributing some flowers to some gardens in some fashion (which we\\'ll see in a while)],\\n\\t\\tand for the remaining n - x gardens, distribute some/all of the remaining flowers in such a fashion such that  the minimum of all the remaining (incomplete)\\n\\t\\tgardens in maximum\\n\\n\\t\\tand keep doing this\\n\\t\\tnow the first question arises : which x gardens should i chose to make full?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tA very intuitive answer would be to chose those x gardens which contain maximum number of flowers\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(so that we have to use minimum number of flowers, and can be left with more options for the second step)\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tNow at each step we are chosing x largest values from the array (x :[1...N])\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tso it means that we will sort the array and traverse from the back\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tat i, we would have made all the gardens from [n - 1 to i] complete by adding the required number of flowers to each of them\\n\\n\\t\\tnow the second step : how do we maximise the minimum value of all the partial / incomplete gardens?\\n\\t\\t\\t\\t\\t\\t\\t  we know that the range this value (minimum value of all the partial / incomplete gardens)\\n\\t\\t\\t\\t\\t\\t\\t  may lie in is [0, taret - 1]\\n\\t\\t\\t\\t\\t\\t\\t  that\\'s where binary search comes into the picture\\n\\n\\t\\t\\t\\t\\t\\t\\t  for a given value in this range (mid), we will see if it is possible to\\n\\t\\t\\t\\t\\t\\t\\t  somehow make the minimum value of this part of the array equal to mid?\\n\\t\\t\\t\\t\\t\\t\\t  if it is, then we have a candidate for this, and move ahead to find a larger value\\n\\n\\t\\t\\t\\t\\t\\t\\t  if it is not, then we\\'ll be forced to look for a smaller value\\n\\t\\t\\t\\t\\t\\t\\t  what we are doing here is, we find the first element greater than mid in the array (in the part before i) [let it\\'s index be idx]\\n\\t\\t\\t\\t\\t\\t\\t  and we will make all the elements coming before this equal to mid\\n\\n\\t\\t\\t\\t\\t\\t\\t  the number of flowers required to achive this will be mid*idx - sum[0..idx - 1] (quite easy to calculate)\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n\\n\\tll max(ll a, ll b) {return a > b ? a : b;}\\n\\n\\n\\n\\n\\tlong long maximumBeauty(vector<int>& a, long long newFlowers, int target, int full, int partial) {\\n\\n\\t\\tsort(a.begin(), a.end());\\n\\t\\tll n = a.size();\\n\\t\\tvector<ll> prefix(n, 0);\\n\\t\\tll sum = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tsum += a[i];\\n\\t\\t\\tprefix[i] = sum;\\n\\t\\t}\\n\\n\\t\\t// end se leke i tak sabko complete kar denge\\n\\t\\tll ans = 0;\\n\\t\\tfor (int i = n; i >= 0; i--) {\\n\\t\\t\\t// from n - 1 till i, all the gardens are complete (means all of them have >= target number of flowers)\\n\\n\\t\\t\\tif (i < n) {\\n\\t\\t\\t\\tll toAdd = max(0, target - a[i]);\\n\\t\\t\\t\\tif (newFlowers < toAdd) break;\\n\\t\\t\\t\\tnewFlowers -= toAdd;\\n\\t\\t\\t\\ta.pop_back();\\n\\t\\t\\t}\\n\\n\\t\\t\\tll low = 0, high = target - 1;\\n\\t\\t\\t// the minimum incomplete garden value will lie between 0 and target - 1 obviously\\n\\n\\t\\t\\tll currentPartialBeauty = 0;\\n\\t\\t\\tll currentFullBeauty = (ll)((n - i) * full);\\n\\t\\t\\twhile (low <= high) {\\n\\t\\t\\t\\tll mid = low + (high - low) / 2;\\n\\t\\t\\t\\t// mid is the candidate for the minimum guy in the array\\n\\n\\t\\t\\t\\tint idx = upper_bound(a.begin(), a.end(), mid) - a.begin(); // index of the first guy which is strictly greater than mid\\n\\t\\t\\t\\t// we intend to make every guy which comes before this equal to mid\\n\\t\\t\\t\\t//\\n\\n\\t\\t\\t\\tif (idx == 0) {\\n\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\t\\t// in this case there are no elements behind mid, means no element can be made  == mid\\n\\t\\t\\t\\t\\t// means all the values are greater than 1\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tll needed = (ll)mid * idx - (ll)prefix[idx - 1];\\n\\t\\t\\t\\t\\t// needed represents the number of flowers needed to make the minimum element in the array equal to mid\\n\\t\\t\\t\\t\\t// basically all the elements before idx will be set equal to mid. the array is increasing, so all the guys after idx -1\\n\\t\\t\\t\\t\\t// will be greater than mid (idx was the upper_bound index), so mid will be the minimum element in the array definitely\\n\\n\\t\\t\\t\\t\\t// if the number of flowers needed to make mid as the minimum is more than what we have, then we have to look for a lesser value of mid (as that would need lesser number of flowers to achieve)\\n\\t\\t\\t\\t\\t// in case we have sufficient number of flowers, we will search for a higher value of the minimum element\\n\\t\\t\\t\\t\\tif (needed <= newFlowers) {\\n\\t\\t\\t\\t\\t\\tcurrentPartialBeauty = mid * partial;\\n\\t\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\t\\t} else high = mid - 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tans = max(ans, currentPartialBeauty + currentFullBeauty);\\n\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define ll long long\\n\\n\\tll max(ll a, ll b) {return a > b ? a : b;}\\n\\n\\n\\n\\n\\tlong long maximumBeauty(vector<int>& a, long long newFlowers, int target, int full, int partial) {\\n\\n\\t\\tsort(a.begin(), a.end());\\n\\t\\tll n = a.size();\\n\\t\\tvector<ll> prefix(n, 0);\\n\\t\\tll sum = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tsum += a[i];\\n\\t\\t\\tprefix[i] = sum;\\n\\t\\t}\\n\\n\\t\\t// end se leke i tak sabko complete kar denge\\n\\t\\tll ans = 0;\\n\\t\\tfor (int i = n; i >= 0; i--) {\\n\\t\\t\\t// from n - 1 till i, all the gardens are complete (means all of them have >= target number of flowers)\\n\\n\\t\\t\\tif (i < n) {\\n\\t\\t\\t\\tll toAdd = max(0, target - a[i]);\\n\\t\\t\\t\\tif (newFlowers < toAdd) break;\\n\\t\\t\\t\\tnewFlowers -= toAdd;\\n\\t\\t\\t\\ta.pop_back();\\n\\t\\t\\t}\\n\\n\\t\\t\\tll low = 0, high = target - 1;\\n\\t\\t\\t// the minimum incomplete garden value will lie between 0 and target - 1 obviously\\n\\n\\t\\t\\tll currentPartialBeauty = 0;\\n\\t\\t\\tll currentFullBeauty = (ll)((n - i) * full);\\n\\t\\t\\twhile (low <= high) {\\n\\t\\t\\t\\tll mid = low + (high - low) / 2;\\n\\t\\t\\t\\t// mid is the candidate for the minimum guy in the array\\n\\n\\t\\t\\t\\tint idx = upper_bound(a.begin(), a.end(), mid) - a.begin(); // index of the first guy which is strictly greater than mid\\n\\t\\t\\t\\t// we intend to make every guy which comes before this equal to mid\\n\\t\\t\\t\\t//\\n\\n\\t\\t\\t\\tif (idx == 0) {\\n\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\t\\t// in this case there are no elements behind mid, means no element can be made  == mid\\n\\t\\t\\t\\t\\t// means all the values are greater than 1\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tll needed = (ll)mid * idx - (ll)prefix[idx - 1];\\n\\t\\t\\t\\t\\t// needed represents the number of flowers needed to make the minimum element in the array equal to mid\\n\\t\\t\\t\\t\\t// basically all the elements before idx will be set equal to mid. the array is increasing, so all the guys after idx -1\\n\\t\\t\\t\\t\\t// will be greater than mid (idx was the upper_bound index), so mid will be the minimum element in the array definitely\\n\\n\\t\\t\\t\\t\\t// if the number of flowers needed to make mid as the minimum is more than what we have, then we have to look for a lesser value of mid (as that would need lesser number of flowers to achieve)\\n\\t\\t\\t\\t\\t// in case we have sufficient number of flowers, we will search for a higher value of the minimum element\\n\\t\\t\\t\\t\\tif (needed <= newFlowers) {\\n\\t\\t\\t\\t\\t\\tcurrentPartialBeauty = mid * partial;\\n\\t\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\t\\t} else high = mid - 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tans = max(ans, currentPartialBeauty + currentFullBeauty);\\n\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934037,
                "title": "c-compute-scores-of-candidate-cases-using-binary-search-prefix-sum",
                "content": "The goal is to find the maximum beauty score. However, neither maximizing complete gardens nor maximizing the minimum number of flowers of incomplete gardens yield the optimum. Thus one might need to go through most possible cases and get the largest one.\\n\\nOne idea is to gradually make near-complete gardens full (and we know the \"full\" score), and find the largest \"partial\" score from the remaining gardens. If we want to maximize the total score given that we first make `k` gardens full, we greedily choose `k` incomplete gardens that are nearest to `target` size, and hence we have most quota to maximize partial score. To greedily make gardens full, we sort the array and make the nearest-to-target one full in order.\\n\\nThe remaining part is to compute partial score given that `k` gardens are complete. To achieve this, we first construct a prefix sum table of the sorted array, and then we can compute \"the flower needed to fill the 0-th to `i`-th garden up to `t`\" by `t * (i+1) - presum[i]`. The goal is to find the largest `t`, where `t` is within the interval `[min(flowers), target - 1]`. We can use binary search to find the optimal `t`, and for fixed `t`, we can perform another binary search on `flowers[0:n-k]` to get the maximum index `i` where `flowers[i] <= t`, which is the largest garden we need to fill up to `t`. The following example illustrates the process:\\n\\n```\\nk=2\\nquota=8\\ntarget=10\\nt: binary search through [1, 9]\\n  0|x         |    1\\n  1|xx        |    3\\n  2|xxx       |    6\\n  3|xxx       |    9\\n  4|xxxxx     |    14\\n  5|xxxxxxoooo|    20\\n  6|xxxxxxxxoo|    28\\n======================================\\nt=5\\n  0|xoooo|    |    1\\n  1|xxoo |    |    3\\n  2|xxxo |    |    6\\n  3|xxxo |    |    9\\n->4|xxxxx|    |    14    5*(4+1)-14=11 (>8)\\n  5|xxxxxxoooo|    20\\n  6|xxxxxxxxoo|    28\\n======================================\\nt=4\\n  0|xooo|     |    1\\n  1|xxoo|     |    3\\n  2|xxxo|     |    6\\n->3|xxxo|     |    9     4*(3+1)-9=7 (<=8)\\n  4|xxxxx     |    14    \\n  5|xxxxxxoooo|    20\\n  6|xxxxxxxxoo|    28\\n======================================\\n=>score(k=2) = full * k + partial * t\\n             = full * 2 + partial * 4\\n```\\nWe iterate through all possible `k`-s, and the maximum score ever computed is our answer.\\n\\n\\nThe following is the C++ code of this problem. Let `n` be the size of the `flowers` vector, and `t` be the numerical value of `target`, then the total time completity is `O(n (log t) (log n))`: each binary search over all possible partial points requires another nested binary search over the `flowers` array (in `upper_bound(flowers.begin(), flowers.begin() + i + 1, c)`), hence taking `O((log t) (log n))` per searching operation. The space complexity is `O(n)`, for building a prefix sum table.\\n```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        int n = flowers.size();\\n        std::sort(flowers.begin(), flowers.end());\\n        \\n        // construct prefix sum table\\n        vector<long long> presum(1, flowers[0]);\\n        for (int i = 1; i < n; ++i) presum.push_back(presum.back() + flowers[i]);\\n        \\n        // for each iteration, use binary search to find the largest\\n        // partial point of [0, i] given that [i+1, n) can be completed\\n        long long ans = 0, avfl = newFlowers;\\n        for (int i = n - 1; i >= 0 && avfl > 0; --i) {\\n            if (flowers[i] >= target) continue; \\n            \\n            // largest possible partial weight \\n            // must fall between [flowers[0], target - 1]\\n            int l = flowers[0], r = target - 1;\\n            while (l < r) {\\n                int c = l + (r-l+1)/2;\\n                int j = distance(flowers.begin(), prev(upper_bound(flowers.begin(), flowers.begin() + i + 1, c)));\\n                if (avfl < (long long)c * (j+1) - presum[j]) r = c-1;\\n                else l = c;\\n            }\\n            // beauty score of [0, i] incomplete + [i+1, n) complete \\n            // = full * (n-i-1) + partial * maxPartialWeight\\n            ans = std::max(ans, (long long)full * (n-1-i) + (long long)partial * l);\\n            avfl -= target - flowers[i];\\n        }\\n        // all-complete case\\n        if (avfl >= 0) ans = std::max(ans, (long long)full * n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nk=2\\nquota=8\\ntarget=10\\nt: binary search through [1, 9]\\n  0|x         |    1\\n  1|xx        |    3\\n  2|xxx       |    6\\n  3|xxx       |    9\\n  4|xxxxx     |    14\\n  5|xxxxxxoooo|    20\\n  6|xxxxxxxxoo|    28\\n======================================\\nt=5\\n  0|xoooo|    |    1\\n  1|xxoo |    |    3\\n  2|xxxo |    |    6\\n  3|xxxo |    |    9\\n->4|xxxxx|    |    14    5*(4+1)-14=11 (>8)\\n  5|xxxxxxoooo|    20\\n  6|xxxxxxxxoo|    28\\n======================================\\nt=4\\n  0|xooo|     |    1\\n  1|xxoo|     |    3\\n  2|xxxo|     |    6\\n->3|xxxo|     |    9     4*(3+1)-9=7 (<=8)\\n  4|xxxxx     |    14    \\n  5|xxxxxxoooo|    20\\n  6|xxxxxxxxoo|    28\\n======================================\\n=>score(k=2) = full * k + partial * t\\n             = full * 2 + partial * 4\\n```\n```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        int n = flowers.size();\\n        std::sort(flowers.begin(), flowers.end());\\n        \\n        // construct prefix sum table\\n        vector<long long> presum(1, flowers[0]);\\n        for (int i = 1; i < n; ++i) presum.push_back(presum.back() + flowers[i]);\\n        \\n        // for each iteration, use binary search to find the largest\\n        // partial point of [0, i] given that [i+1, n) can be completed\\n        long long ans = 0, avfl = newFlowers;\\n        for (int i = n - 1; i >= 0 && avfl > 0; --i) {\\n            if (flowers[i] >= target) continue; \\n            \\n            // largest possible partial weight \\n            // must fall between [flowers[0], target - 1]\\n            int l = flowers[0], r = target - 1;\\n            while (l < r) {\\n                int c = l + (r-l+1)/2;\\n                int j = distance(flowers.begin(), prev(upper_bound(flowers.begin(), flowers.begin() + i + 1, c)));\\n                if (avfl < (long long)c * (j+1) - presum[j]) r = c-1;\\n                else l = c;\\n            }\\n            // beauty score of [0, i] incomplete + [i+1, n) complete \\n            // = full * (n-i-1) + partial * maxPartialWeight\\n            ans = std::max(ans, (long long)full * (n-1-i) + (long long)partial * l);\\n            avfl -= target - flowers[i];\\n        }\\n        // all-complete case\\n        if (avfl >= 0) ans = std::max(ans, (long long)full * n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1933397,
                "title": "n-logn-2-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int par) {\\n        int n=flowers.size();\\n        vector<long long>flower;\\n        for(auto it:flowers)\\n            flower.push_back(it);\\n        sort(flower.begin(),flower.end());\\n         int r;\\n          int k=0;\\n        long long used=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(flower[i]<1LL*target)\\n            {\\n                r=i;break;\\n            }\\n            else\\n                k++;\\n        }\\n        long long res=0;\\n        vector<long long>prem(n),pre(n);\\n        \\n        prem[0]=flower[0];\\n        pre[0]=flower[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            pre[i]=pre[i-1]+flower[i];\\n            prem[i]=min(prem[i],flower[i]);\\n        }\\n        \\n        for(int i=r;i>=0;i--)\\n        {\\n            \\n            long long l=prem[i],hi=target-1,ans=-1,mid;\\n            while(l<=hi)\\n            {\\n                mid=l+(hi-l)/2;\\n                long long va=0;\\n                   if(flower[0]<mid)\\n                   {\\n                    int j=upper_bound(flower.begin(),flower.begin()+(n-k),mid)-flower.begin();\\n                       \\n                    va=(1LL*j*mid)-pre[j-1];   \\n                   }\\n                if(va<=newFlowers-used)\\n                {\\n                    ans=mid;\\n                    l=mid+1;\\n                }\\n                else\\n                    hi=mid-1;\\n            }\\n           if(ans!=-1)\\n           {               \\n               long long val=1LL*k*full+1LL*ans*par;\\n               res=max(res,val);\\n           }\\n            used+=abs(flower[i]-1LL*target);\\n            k++;  \\n        }\\n        if(used<=newFlowers)\\n        {\\n            res=max(res,1LL*n*full);\\n        }\\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int par) {\\n        int n=flowers.size();\\n        vector<long long>flower;\\n        for(auto it:flowers)\\n            flower.push_back(it);\\n        sort(flower.begin(),flower.end());\\n         int r;\\n          int k=0;\\n        long long used=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(flower[i]<1LL*target)\\n            {\\n                r=i;break;\\n            }\\n            else\\n                k++;\\n        }\\n        long long res=0;\\n        vector<long long>prem(n),pre(n);\\n        \\n        prem[0]=flower[0];\\n        pre[0]=flower[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            pre[i]=pre[i-1]+flower[i];\\n            prem[i]=min(prem[i],flower[i]);\\n        }\\n        \\n        for(int i=r;i>=0;i--)\\n        {\\n            \\n            long long l=prem[i],hi=target-1,ans=-1,mid;\\n            while(l<=hi)\\n            {\\n                mid=l+(hi-l)/2;\\n                long long va=0;\\n                   if(flower[0]<mid)\\n                   {\\n                    int j=upper_bound(flower.begin(),flower.begin()+(n-k),mid)-flower.begin();\\n                       \\n                    va=(1LL*j*mid)-pre[j-1];   \\n                   }\\n                if(va<=newFlowers-used)\\n                {\\n                    ans=mid;\\n                    l=mid+1;\\n                }\\n                else\\n                    hi=mid-1;\\n            }\\n           if(ans!=-1)\\n           {               \\n               long long val=1LL*k*full+1LL*ans*par;\\n               res=max(res,val);\\n           }\\n            used+=abs(flower[i]-1LL*target);\\n            k++;  \\n        }\\n        if(used<=newFlowers)\\n        {\\n            res=max(res,1LL*n*full);\\n        }\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1933197,
                "title": "java-neat-code-binary-search",
                "content": "```\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        Arrays.sort(flowers);\\n        long[] cost = new long[flowers.length + 1];\\n        long[] preSum = new long[flowers.length + 1];\\n        for (int i = 0; i < flowers.length; i++) {\\n            cost[i + 1] = cost[i] + Math.max(target - flowers[i], 0);\\n            preSum[i + 1] = preSum[i] + flowers[i];\\n        }\\n        if (flowers[0] >= target) {\\n            return (long)full * flowers.length;\\n        }\\n        long ans = 0;\\n        if (cost[flowers.length] - cost[0] <= newFlowers) {\\n            ans = (long)full * flowers.length;\\n        }\\n        for (int i = 0; i < flowers.length && flowers[i] < target; i++) {\\n            if (cost[flowers.length] - cost[i + 1] > newFlowers) continue;\\n            long remain = newFlowers - cost[flowers.length] + cost[i + 1];\\n            int left = 0, right = i;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                if (remain >= (long)(mid + 1) * flowers[mid] - preSum[mid + 1]){\\n                    left = mid + 1;\\n                }else {\\n                    right = mid - 1;\\n                }\\n            }\\n            long part = Math.min(flowers[right] + (remain - (long)flowers[right] * (right + 1) + preSum[right + 1]) / (right + 1), target - 1);\\n            ans = Math.max(ans, part * partial + (long)full * (flowers.length - i - 1));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        Arrays.sort(flowers);\\n        long[] cost = new long[flowers.length + 1];\\n        long[] preSum = new long[flowers.length + 1];\\n        for (int i = 0; i < flowers.length; i++) {\\n            cost[i + 1] = cost[i] + Math.max(target - flowers[i], 0);\\n            preSum[i + 1] = preSum[i] + flowers[i];\\n        }\\n        if (flowers[0] >= target) {\\n            return (long)full * flowers.length;\\n        }\\n        long ans = 0;\\n        if (cost[flowers.length] - cost[0] <= newFlowers) {\\n            ans = (long)full * flowers.length;\\n        }\\n        for (int i = 0; i < flowers.length && flowers[i] < target; i++) {\\n            if (cost[flowers.length] - cost[i + 1] > newFlowers) continue;\\n            long remain = newFlowers - cost[flowers.length] + cost[i + 1];\\n            int left = 0, right = i;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                if (remain >= (long)(mid + 1) * flowers[mid] - preSum[mid + 1]){\\n                    left = mid + 1;\\n                }else {\\n                    right = mid - 1;\\n                }\\n            }\\n            long part = Math.min(flowers[right] + (remain - (long)flowers[right] * (right + 1) + preSum[right + 1]) / (right + 1), target - 1);\\n            ans = Math.max(ans, part * partial + (long)full * (flowers.length - i - 1));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932699,
                "title": "c-binary-search-greedy-dp-explained-approach",
                "content": "Approach\\n\\n\\t- sort flowers in descending order\\n    - calculate postfix array for every element:\\n    - for any element i, postfix[i] = minimum number of flowers needed to plant the graden from i to n-1 with a minimum of flowers[i] flowers in each garden from i to n-1.\\n    - take every flower from i = 0:\\n\\t\\t\\t2cases: - considering 0 to i as full garden\\n\\t\\t\\t\\t\\t- only considering 0 to i-1 as full garden;\\n    \\n\\t\\t\\tupdate the ans.\\n    - return ans;\\n\\n\\n***Time complexity**: O(nlogn).*\\n\\n\\n**Solution Code:**\\n```\\nclass Solution {\\npublic:\\n    int binarySearch(vector<long long>& postfix, int l, int r, long long newFlowers) {\\n        while (l<=r) {\\n            int mid = (l+r)/2;\\n            if (postfix[mid] > newFlowers)\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        return l;\\n    }\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end(), greater<int>());\\n        int n = flowers.size();\\n        \\n        vector<long long> postfix(n, 0);\\n        for (int i=n-2; i>=0; i--)\\n            postfix[i] = postfix[i+1] + (flowers[i] - flowers[i+1])*(n-1-i);\\n            \\n        long long ans = 0;\\n        for (int i=0; i<n; i++) {\\n            if (flowers[i] >= target)\\n                continue;\\n            \\n            int requi = target - flowers[i];\\n            \\n            //if we don\\'t want to full the requirement to make the flower full i.e. to exceed its count by target\\n            int k = binarySearch(postfix, i, n-1, newFlowers);\\n            int curr_flower_count = target-1 < flowers[k] + (newFlowers-postfix[k])/(n-k) ? target-1\\n                                        : flowers[k] + (newFlowers-postfix[k])/(n-k);\\n            \\n            ans = ans > long(i)*full + long(partial)*curr_flower_count ? ans\\n                                        : long(i)*full + long(partial)*curr_flower_count;\\n            \\n            //otherwise, proceed with making the flower full\\n            if (requi <= newFlowers)\\n                newFlowers -= requi;\\n            else\\n                break;\\n            \\n            if (i == n-1)\\n                ans = ans > long(n)*full? ans: long(n)*full;\\n        }\\n        \\n        if (ans == 0)\\n            return long(full)*n;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binarySearch(vector<long long>& postfix, int l, int r, long long newFlowers) {\\n        while (l<=r) {\\n            int mid = (l+r)/2;\\n            if (postfix[mid] > newFlowers)\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        return l;\\n    }\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end(), greater<int>());\\n        int n = flowers.size();\\n        \\n        vector<long long> postfix(n, 0);\\n        for (int i=n-2; i>=0; i--)\\n            postfix[i] = postfix[i+1] + (flowers[i] - flowers[i+1])*(n-1-i);\\n            \\n        long long ans = 0;\\n        for (int i=0; i<n; i++) {\\n            if (flowers[i] >= target)\\n                continue;\\n            \\n            int requi = target - flowers[i];\\n            \\n            //if we don\\'t want to full the requirement to make the flower full i.e. to exceed its count by target\\n            int k = binarySearch(postfix, i, n-1, newFlowers);\\n            int curr_flower_count = target-1 < flowers[k] + (newFlowers-postfix[k])/(n-k) ? target-1\\n                                        : flowers[k] + (newFlowers-postfix[k])/(n-k);\\n            \\n            ans = ans > long(i)*full + long(partial)*curr_flower_count ? ans\\n                                        : long(i)*full + long(partial)*curr_flower_count;\\n            \\n            //otherwise, proceed with making the flower full\\n            if (requi <= newFlowers)\\n                newFlowers -= requi;\\n            else\\n                break;\\n            \\n            if (i == n-1)\\n                ans = ans > long(n)*full? ans: long(n)*full;\\n        }\\n        \\n        if (ans == 0)\\n            return long(full)*n;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932476,
                "title": "prefix-sum-bisection-search-in-rust",
                "content": "```\\nuse std::cmp::min;\\nuse std::cmp::max;\\nuse std::cmp::Ordering;\\n\\npub fn upper_bound<T: PartialOrd>(arr: &[T], target: T) -> usize {\\n    let mut l = 0;\\n    let mut r = arr.len();\\n    while l<r {\\n        let m = (l+r)/2;\\n        let v = unsafe {arr.get_unchecked(m)};\\n        if *v <= target {\\n            l = m + 1;\\n        }else{ //v > target\\n            r = m;\\n        }\\n    }\\n    //l==r\\n    l\\n}\\n\\npub fn lower_bound<T: PartialOrd>(arr: &[T], target: T) -> usize {\\n    let mut l = 0;\\n    let mut r = arr.len();\\n    while l<r {\\n        let m = (l+r)/2;\\n        let v = unsafe{arr.get_unchecked(m)};\\n        if *v >= target {\\n            r = m;\\n        }else{ //v < target\\n            l = m+1;\\n        }\\n    }\\n    //l==r\\n    l\\n}\\n\\nimpl Solution {\\n    pub fn maximum_beauty(mut flowers: Vec<i32>, new_flowers: i64, target: i32, full: i32, partial: i32) -> i64 {\\n        \\n        /*\\n        assert_eq!(upper_bound(&[5,7,10,10,10,45], 10), 5);\\n        assert_eq!(upper_bound(&[5,7,10,10,10,45], 45), 6);\\n        assert_eq!(upper_bound(&[5,7,10,10,10,45], 9), 2);\\n        \\n        assert_eq!(lower_bound(&[5,7,10,10,10,45], 9), 2);\\n        assert_eq!(lower_bound(&[5,7,10,10,10,45], 10), 2);\\n        assert_eq!(lower_bound(&[5,7,10,10,10,45], 45), 5);\\n        assert_eq!(lower_bound(&[5,7,10,10,10,45], 0), 0);\\n        assert_eq!(lower_bound(&[10], 11), 1);\\n        assert_eq!(lower_bound(&[], 11), 0);\\n        */\\n        \\n        //low to high\\n        flowers.sort();\\n        \\n        let ll = flowers.len();\\n        \\n        let mut arr = vec![0i64; ll];\\n        \\n        let mut prev_v = 0i64;\\n        for (i,v) in flowers.iter().enumerate() {\\n            arr[i] = i as i64 * (*v as i64-prev_v) as i64;\\n            prev_v = *v as i64;\\n            \\n            //prefix sum to enable bisection for incomplete gardens\\n            if i > 0 {\\n                arr[i] += arr[i-1];\\n            }\\n        }\\n        \\n        //prefix sum to enable bisection for incomplete gardens\\n        //let arr = arr.iter().scan(0, |sum, i| {*sum += i; Some(*sum)}).collect::<Vec<_>>();\\n        \\n        let mut best = 0i64;\\n        let mut left = new_flowers as i64;\\n        \\n        for i in (0..=ll).rev(){\\n            \\n             if i < ll {\\n                let v = flowers[i];    \\n                //amount to reach complete garden\\n                let need_to_target = max(target - v, 0i32);\\n                if need_to_target as i64 <= left {\\n                    left -= need_to_target as i64;\\n                }else{\\n                    //not enough\\n                    break;\\n                }\\n            }\\n            \\n            //try fill incomplete gardens\\n            let mut num_incomplete = upper_bound(&arr[..i], left as i64);\\n            \\n            //bound to be < target in order to qualify as incomplete garden, search for last item in sorted order that is smaller than target\\n            let bound_idx = lower_bound(&flowers[..num_incomplete], target); \\n            let found = \\n            if bound_idx > 0 {\\n                debug_assert!(flowers[bound_idx-1] < target);\\n                num_incomplete = bound_idx;\\n                true\\n            }else{\\n                false\\n            };\\n           \\n            let min_flowers = \\n            if !found {\\n                0i64\\n            }else{\\n                let idx = num_incomplete - 1;\\n                let accum = arr[idx];\\n                let remain = left as i64 - accum;\\n                let distribute_remain = remain / num_incomplete as i64;\\n                let min_flowers = flowers[idx] as i64 + distribute_remain;\\n                min(min_flowers, target as i64 - 1i64)\\n            };\\n            \\n            //cal score\\n            let num_complete = if i==ll { 0 } else { ll - i };\\n            let score = num_complete as i64 * full as i64 + min_flowers * partial as i64;\\n            best = max(best, score);        \\n        }\\n        best\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::min;\\nuse std::cmp::max;\\nuse std::cmp::Ordering;\\n\\npub fn upper_bound<T: PartialOrd>(arr: &[T], target: T) -> usize {\\n    let mut l = 0;\\n    let mut r = arr.len();\\n    while l<r {\\n        let m = (l+r)/2;\\n        let v = unsafe {arr.get_unchecked(m)};\\n        if *v <= target {\\n            l = m + 1;\\n        }else{ //v > target\\n            r = m;\\n        }\\n    }\\n    //l==r\\n    l\\n}\\n\\npub fn lower_bound<T: PartialOrd>(arr: &[T], target: T) -> usize {\\n    let mut l = 0;\\n    let mut r = arr.len();\\n    while l<r {\\n        let m = (l+r)/2;\\n        let v = unsafe{arr.get_unchecked(m)};\\n        if *v >= target {\\n            r = m;\\n        }else{ //v < target\\n            l = m+1;\\n        }\\n    }\\n    //l==r\\n    l\\n}\\n\\nimpl Solution {\\n    pub fn maximum_beauty(mut flowers: Vec<i32>, new_flowers: i64, target: i32, full: i32, partial: i32) -> i64 {\\n        \\n        /*\\n        assert_eq!(upper_bound(&[5,7,10,10,10,45], 10), 5);\\n        assert_eq!(upper_bound(&[5,7,10,10,10,45], 45), 6);\\n        assert_eq!(upper_bound(&[5,7,10,10,10,45], 9), 2);\\n        \\n        assert_eq!(lower_bound(&[5,7,10,10,10,45], 9), 2);\\n        assert_eq!(lower_bound(&[5,7,10,10,10,45], 10), 2);\\n        assert_eq!(lower_bound(&[5,7,10,10,10,45], 45), 5);\\n        assert_eq!(lower_bound(&[5,7,10,10,10,45], 0), 0);\\n        assert_eq!(lower_bound(&[10], 11), 1);\\n        assert_eq!(lower_bound(&[], 11), 0);\\n        */\\n        \\n        //low to high\\n        flowers.sort();\\n        \\n        let ll = flowers.len();\\n        \\n        let mut arr = vec![0i64; ll];\\n        \\n        let mut prev_v = 0i64;\\n        for (i,v) in flowers.iter().enumerate() {\\n            arr[i] = i as i64 * (*v as i64-prev_v) as i64;\\n            prev_v = *v as i64;\\n            \\n            //prefix sum to enable bisection for incomplete gardens\\n            if i > 0 {\\n                arr[i] += arr[i-1];\\n            }\\n        }\\n        \\n        //prefix sum to enable bisection for incomplete gardens\\n        //let arr = arr.iter().scan(0, |sum, i| {*sum += i; Some(*sum)}).collect::<Vec<_>>();\\n        \\n        let mut best = 0i64;\\n        let mut left = new_flowers as i64;\\n        \\n        for i in (0..=ll).rev(){\\n            \\n             if i < ll {\\n                let v = flowers[i];    \\n                //amount to reach complete garden\\n                let need_to_target = max(target - v, 0i32);\\n                if need_to_target as i64 <= left {\\n                    left -= need_to_target as i64;\\n                }else{\\n                    //not enough\\n                    break;\\n                }\\n            }\\n            \\n            //try fill incomplete gardens\\n            let mut num_incomplete = upper_bound(&arr[..i], left as i64);\\n            \\n            //bound to be < target in order to qualify as incomplete garden, search for last item in sorted order that is smaller than target\\n            let bound_idx = lower_bound(&flowers[..num_incomplete], target); \\n            let found = \\n            if bound_idx > 0 {\\n                debug_assert!(flowers[bound_idx-1] < target);\\n                num_incomplete = bound_idx;\\n                true\\n            }else{\\n                false\\n            };\\n           \\n            let min_flowers = \\n            if !found {\\n                0i64\\n            }else{\\n                let idx = num_incomplete - 1;\\n                let accum = arr[idx];\\n                let remain = left as i64 - accum;\\n                let distribute_remain = remain / num_incomplete as i64;\\n                let min_flowers = flowers[idx] as i64 + distribute_remain;\\n                min(min_flowers, target as i64 - 1i64)\\n            };\\n            \\n            //cal score\\n            let num_complete = if i==ll { 0 } else { ll - i };\\n            let score = num_complete as i64 * full as i64 + min_flowers * partial as i64;\\n            best = max(best, score);        \\n        }\\n        best\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1931864,
                "title": "c-solution-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        int n = flowers.size();\\n        sort(flowers.rbegin(), flowers.rend());\\n        int ps = 0;\\n        int complete = 0;\\n        while (ps < n && flowers[ps] >= target) {\\n            ++complete;\\n            ++ps;\\n        }\\n        if (ps == n) return (long long) n * full;\\n        vector<long long> req(n);\\n        long long sum = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            sum += flowers[i];\\n            long long rsum = (long long) flowers[i] * (n - i);\\n            req[i] = rsum - sum;\\n        }\\n        long long sol = 0;\\n        auto get = [&] (int low) -> pair<long long, long long> {\\n            int high = n - 1;\\n            int pos = n - 1;\\n            while (low <= high) {\\n                int mid = (low + high) / 2;\\n                if (req[mid] <= newFlowers) {\\n                    pos = mid;\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n            return make_pair(pos, req[pos]);\\n        };\\n        for (int i = ps; i < n; i++) {\\n            pair<long long, long long> p = get(i);\\n            long long rest = newFlowers - p.second;\\n            long long tot = flowers[p.first] + rest / (n - p.first);\\n            tot = min(tot, (long long) target - 1);\\n            long long val = (long long) complete * full;\\n            val += (long long) partial * tot;\\n            sol = max(sol, val);\\n            if (target - flowers[i] <= newFlowers) {\\n                newFlowers -= target - flowers[i];\\n                ++complete;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        if (complete == n) {\\n            sol = max(sol, (long long) n * full);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        int n = flowers.size();\\n        sort(flowers.rbegin(), flowers.rend());\\n        int ps = 0;\\n        int complete = 0;\\n        while (ps < n && flowers[ps] >= target) {\\n            ++complete;\\n            ++ps;\\n        }\\n        if (ps == n) return (long long) n * full;\\n        vector<long long> req(n);\\n        long long sum = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            sum += flowers[i];\\n            long long rsum = (long long) flowers[i] * (n - i);\\n            req[i] = rsum - sum;\\n        }\\n        long long sol = 0;\\n        auto get = [&] (int low) -> pair<long long, long long> {\\n            int high = n - 1;\\n            int pos = n - 1;\\n            while (low <= high) {\\n                int mid = (low + high) / 2;\\n                if (req[mid] <= newFlowers) {\\n                    pos = mid;\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n            return make_pair(pos, req[pos]);\\n        };\\n        for (int i = ps; i < n; i++) {\\n            pair<long long, long long> p = get(i);\\n            long long rest = newFlowers - p.second;\\n            long long tot = flowers[p.first] + rest / (n - p.first);\\n            tot = min(tot, (long long) target - 1);\\n            long long val = (long long) complete * full;\\n            val += (long long) partial * tot;\\n            sol = max(sol, val);\\n            if (target - flowers[i] <= newFlowers) {\\n                newFlowers -= target - flowers[i];\\n                ++complete;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        if (complete == n) {\\n            sol = max(sol, (long long) n * full);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931790,
                "title": "sort-and-then-linear-greedy",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        ll baseline = 0;\\n        while (!flowers.empty() && flowers.back() >= target) {\\n            baseline += full;\\n            flowers.pop_back();\\n        }\\n\\n        ll best = 0;\\n        ll water_level = 0;  // value of the minimum partial garden.\\n        ll water_width = 0;  // number of such gardens.\\n        deque<ll> pending;  // non-minimum partial gardens.\\n        \\n        // In each iteration, try to use the budget below to increase water_level.\\n        // Budget could be negative, indicating the scenario is invalid as we couldn\\'t make that many gardens \\'full\\'.\\n        ll budget = newFlowers;\\n        for (int x : flowers) {\\n            budget -= (target - x);\\n        }\\n\\n        for (int num_partials = 0; num_partials <= flowers.size(); num_partials++) {\\n            if (budget >= 0) {\\n                ll full_sum = (ll)full * (flowers.size() - num_partials);\\n                ll partial_sum = water_level * partial;\\n                ll cur = full_sum + partial_sum;\\n                best = max(best, cur);\\n            }\\n            if (num_partials == flowers.size()) break;\\n            \\n            pending.push_back(flowers[num_partials]);\\n            budget += target - flowers[num_partials];\\n            \\n            while (budget > 0) {\\n                ll next_water_level = min<ll>(pending.empty() ? target - 1 : pending.front(), water_width == 0 ? INT32_MAX : water_level + (budget / water_width));\\n                budget -= (next_water_level - water_level) * water_width;\\n                water_level = next_water_level;\\n                bool consumed = false;\\n                while (!pending.empty() && pending.front() == water_level) {\\n                    water_width++;\\n                    pending.pop_front();\\n                    consumed = true;\\n                }\\n                if (water_level == target - 1 || !consumed) break;\\n            }\\n        }\\n        return best + baseline;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        ll baseline = 0;\\n        while (!flowers.empty() && flowers.back() >= target) {\\n            baseline += full;\\n            flowers.pop_back();\\n        }\\n\\n        ll best = 0;\\n        ll water_level = 0;  // value of the minimum partial garden.\\n        ll water_width = 0;  // number of such gardens.\\n        deque<ll> pending;  // non-minimum partial gardens.\\n        \\n        // In each iteration, try to use the budget below to increase water_level.\\n        // Budget could be negative, indicating the scenario is invalid as we couldn\\'t make that many gardens \\'full\\'.\\n        ll budget = newFlowers;\\n        for (int x : flowers) {\\n            budget -= (target - x);\\n        }\\n\\n        for (int num_partials = 0; num_partials <= flowers.size(); num_partials++) {\\n            if (budget >= 0) {\\n                ll full_sum = (ll)full * (flowers.size() - num_partials);\\n                ll partial_sum = water_level * partial;\\n                ll cur = full_sum + partial_sum;\\n                best = max(best, cur);\\n            }\\n            if (num_partials == flowers.size()) break;\\n            \\n            pending.push_back(flowers[num_partials]);\\n            budget += target - flowers[num_partials];\\n            \\n            while (budget > 0) {\\n                ll next_water_level = min<ll>(pending.empty() ? target - 1 : pending.front(), water_width == 0 ? INT32_MAX : water_level + (budget / water_width));\\n                budget -= (next_water_level - water_level) * water_width;\\n                water_level = next_water_level;\\n                bool consumed = false;\\n                while (!pending.empty() && pending.front() == water_level) {\\n                    water_width++;\\n                    pending.pop_front();\\n                    consumed = true;\\n                }\\n                if (water_level == target - 1 || !consumed) break;\\n            }\\n        }\\n        return best + baseline;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931535,
                "title": "java-binary-search-solution-with-code-comments",
                "content": "**Intution** : \\nThe overall value depends on 2 things : \\n        (i) The number of complete gardens : For this, we can increment the counter.\\n\\t\\t(ii) The minimum flowers present in all of the partial gardens : For this, we try to increase the minimum number of flowers present in a partial Garden.\\n\\t\\t\\n\\t\\tclass Solution {\\n    \\n     Returns the index of the first Element which is smaller than val.\\n      sIdx <= index <= eIdx \\n    \\n    public int getIndex(int[] arr,int sIdx,int eIdx,long val){\\n        int ans = eIdx;\\n        while(sIdx <= eIdx){\\n            int mid = sIdx + (eIdx - sIdx)/2;\\n            if(arr[mid] < val){\\n                ans = mid;\\n                sIdx = mid + 1;\\n            }else{\\n                eIdx = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n    public long maximumBeauty(int[] flowers, long newFlowers, int _target, int _full, int _partial) {\\n        long[] cumsum = new long[flowers.length];                   //Store the cummulative sum.\\n        Arrays.sort(flowers);\\n        cumsum[0] = flowers[0];\\n        long complete = 0;\\n        long partial_c = 0;\\n        long target = (long)_target;\\n        long full = (long)_full;\\n        long partial = (long)_partial;\\n        int index = 0;\\n        if(flowers[0] < target) partial_c++;\\n        if(flowers[0] >= target)complete++;\\n        for(int i = 1;i<flowers.length;i++){\\n            cumsum[i] = cumsum[i - 1] + (long)flowers[i];\\n            if(flowers[i] >= target){\\n                complete++;\\n            }\\n            else {\\n                index = Math.max(i,index);                            //Finding the Maximum index whoose value lies below target.  \\n                partial_c++;\\n            }\\n        \\n        }\\n        //Intution : \\n        // The overall value depends on 2 things : \\n        // (i) The number of complete gardens : For this, we can increment the counter.\\n        // (ii) The minimum flowers present in all of the partial gardens : For this, we try to increase the minimum number of flowers present in a partial Garden.\\n        //     \\n        long ans = full*complete;\\n        if(partial_c > 0){                                              // If there is at least one partially filled Garden.\\n            long lo = flowers[0];                                       // The least value for the minimum value in a partial Garden.\\n            long hi = target - 1;                                       // The maximum possible value of a garden without making it a complete Garden.\\n            while(lo <= hi){\\n                long mid = lo + (hi - lo)/2;\\n                //Calculate the First Flower that is less than mid : \\n                int myIdx = getIndex(flowers,0,index,mid);              //Fetch the index of first garden whoose number of flowers < mid.\\n                long t_required = mid*(myIdx + 1) - cumsum[myIdx];      //Calculate the required number of flowers to make the number of flowers in partial garden at least mid.\\n                if(t_required <= newFlowers){                           //If there are enough flowers.\\n                    ans = Math.max(ans, full*complete + mid*partial);   //Store for a probable answer.\\n                    lo = mid + 1;                                       //Try to increase the minimum value of all partial Gardens that is possible by the Garden.\\n                }else{\\n                    hi = mid - 1;\\n                }\\n            }\\n        }\\n        if(index==0)return ans;\\n        for(int i = index;i>=0;i--){\\n            long calc = 0;\\n            long diff = target - flowers[i];                            //Number of flowers required to convert the Garden[i] to complete Garden.\\n            if(diff > newFlowers)break;                                 //Not enough flowers. Break\\n            newFlowers -= diff;                                         //reduce the number of Flowers Left.\\n            complete++;                                                 //Increase the number of complete Gardens.\\n            calc += full*complete;\\n            if(i==0){\\n                ans = Math.max(ans,calc);\\n                break;\\n            }                                                           // If there is at least one partially filled Garden.\\n            long lo = flowers[0];                                       // The least value for the minimum value in a partial Garden.\\n            long hi = target - 1;                                       // The maximum possible value of a garden without making it a complete Garden.\\n            while(lo <= hi){                                \\n                long mid = lo + (hi - lo)/2;\\n                //Calculate the First Flower that is less than mid : \\n                int myIdx = getIndex(flowers,0,i - 1,mid);\\n                long t_required = mid*(myIdx + 1) - cumsum[myIdx];\\n                if(t_required <= newFlowers){\\n                    ans = Math.max(ans, calc + mid*partial);\\n                    lo = mid + 1;\\n                }else{\\n                    hi = mid - 1;\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n\\n\\t\\t",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "class Solution {\\n    \\n     Returns the index of the first Element which is smaller than val.\\n      sIdx <= index <= eIdx \\n    \\n    public int getIndex(int[] arr,int sIdx,int eIdx,long val){\\n        int ans = eIdx;\\n        while(sIdx <= eIdx){\\n            int mid = sIdx + (eIdx - sIdx)/2;\\n            if(arr[mid] < val){\\n                ans = mid;\\n                sIdx = mid + 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1931259,
                "title": "python-an-o-n-logn-log-n-solution",
                "content": "the basic idea is to test for every possible complete garden number\\nfrom [(already complete) to (garden cnts)]\\nfor example with [1,2,3,4,5,5], target is 5,we need to make i=3 complete garder\\nwe should construct 1 extra complete garden\\nthe cheapest choice is make [4] to [5],(we can use accumulate to cal the cost)\\nif cost>newFlowers,we just break\\n\\nnow we still have (newFlowers-cost) flower\\nto make [1,2,3] in-compelte (no more than target-1 flower)\\nbut [maximize the smallest number] with (newFlowers-cost) flowers\\nwe can use binary search to find it in range [0,target-1]\\n\\nfor the test value {mid},we validate it as follows :\\nlet\\'s say we test how much we need to make the minium 2,(mid=2):\\n\\nany garden with flowers>=2 is not need plant,we can use bisect_left to find the index\\nso,[2,3]  not need no more flower\\nthe previous gardens [1] need  (mid*len-acc[len]) more flowers\\nin this example we need 1 more flowers\\njust compare it with (newFlowers-cost).\\n\\n\\n\\n```\\nclass Solution:\\n    def maximumBeauty(self, flowers, newFlowers, target, full, partial):\\n        flowers.sort()\\n        acc = [0] + list(accumulate(flowers))\\n        n = len(flowers)\\n\\n        def findwith(i, v):\\n            # make [0,i] as incomplete gardens\\n            # return the maxium-minium number with v extra flower\\n            if i < 0:\\n                return 0\\n            if v == 0:\\n                return flowers[0]\\n            l = 0\\n            r = target - 1 # the minium we need no more than target-1\\n            while l <= r:\\n                mid = (l + r) // 2\\n                j = min(i + 1,bisect.bisect_left(flowers, mid))\\n                #for flower greater than mid, we don\\'t need to plant more flowers\\n                #to make [0,j] all equal to mid,we need (mid * (j) - acc[j]) flowers\\n                if mid * (j) - acc[j] <= v:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n            return l - 1\\n\\n        ans = 0\\n        j = bisect.bisect_left(flowers, target)\\n        # how many gardens is already complete,(n - j)\\n        for i in range(n-j,n + 1):\\n            # make i complete gardens\\n            # (more) garden we need to construct i complete gardens\\n            more = i - (n - j)\\n            need = target * more - (acc[j] - acc[j - more])\\n            # {need} is flowers need for {more} complete gardens\\n            if need > newFlowers:\\n                break #no need to make more complete gardens\\n            mval = findwith(j - more - 1, newFlowers - need)\\n            #get the max-minium value with  {newFlowers - need} flowers\\n            ans = max(ans, full * i + mval * partial)\\n\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers, newFlowers, target, full, partial):\\n        flowers.sort()\\n        acc = [0] + list(accumulate(flowers))\\n        n = len(flowers)\\n\\n        def findwith(i, v):\\n            # make [0,i] as incomplete gardens\\n            # return the maxium-minium number with v extra flower\\n            if i < 0:\\n                return 0\\n            if v == 0:\\n                return flowers[0]\\n            l = 0\\n            r = target - 1 # the minium we need no more than target-1\\n            while l <= r:\\n                mid = (l + r) // 2\\n                j = min(i + 1,bisect.bisect_left(flowers, mid))\\n                #for flower greater than mid, we don\\'t need to plant more flowers\\n                #to make [0,j] all equal to mid,we need (mid * (j) - acc[j]) flowers\\n                if mid * (j) - acc[j] <= v:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n            return l - 1\\n\\n        ans = 0\\n        j = bisect.bisect_left(flowers, target)\\n        # how many gardens is already complete,(n - j)\\n        for i in range(n-j,n + 1):\\n            # make i complete gardens\\n            # (more) garden we need to construct i complete gardens\\n            more = i - (n - j)\\n            need = target * more - (acc[j] - acc[j - more])\\n            # {need} is flowers need for {more} complete gardens\\n            if need > newFlowers:\\n                break #no need to make more complete gardens\\n            mval = findwith(j - more - 1, newFlowers - need)\\n            #get the max-minium value with  {newFlowers - need} flowers\\n            ans = max(ans, full * i + mval * partial)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931087,
                "title": "c-soln-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        int full_cnt = 0;\\n        for(int i = flowers.size() - 1; i >= 0; i--) {\\n            if(flowers[i] < target) break;\\n            full_cnt++;\\n        }\\n        int n = flowers.size() - full_cnt;\\n        if(n == 0) return (long long)full_cnt * (long long)full;\\n        \\n        vector<long long> fill_up(n, 0), fill_target(n, 0);\\n        \\n        // fill_up: flowers needed to get min of flowers to flowers[i]\\n        fill_up[0] = 0;\\n        for(int i = 1; i < n; i++) {\\n            fill_up[i] = (flowers[i] - flowers[i-1]) * (long long)i + fill_up[i-1];\\n        }\\n        // fill_target[i] fill flowers[i] to flowers[n-1] to target level\\n        fill_target[n-1] = (long long) target - flowers[n-1];\\n        for(int i = n - 2; i >= 0; i--) {\\n            fill_target[i] = fill_target[i+1] + (long long)(target - flowers[i]); \\n        }\\n        long long ret = 0;\\n        for(int num_fill = 0; num_fill <= n; num_fill++) {\\n            long long m = 0;\\n            long long rm = newFlowers;\\n            if(num_fill != 0) {\\n                rm -= fill_target[n-num_fill];\\n            }\\n            if(rm < 0) break;\\n            if(num_fill != n) {\\n                auto ptr = upper_bound(fill_up.begin(), fill_up.end(), rm);\\n                // can get min to flowers[idx-1] level, but not flowers[idx] level\\n                int idx = ptr - fill_up.begin();\\n                if(idx >= n - num_fill) idx = n - num_fill;\\n                m = flowers[idx - 1];\\n                m += (rm - fill_up[idx - 1]) / idx; \\n                m = min(m, (long long)target - 1);\\n            }\\n            long long tmp = m * (long long) partial + (full_cnt + num_fill) * (long long) full;\\n            ret = max(tmp, ret);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        int full_cnt = 0;\\n        for(int i = flowers.size() - 1; i >= 0; i--) {\\n            if(flowers[i] < target) break;\\n            full_cnt++;\\n        }\\n        int n = flowers.size() - full_cnt;\\n        if(n == 0) return (long long)full_cnt * (long long)full;\\n        \\n        vector<long long> fill_up(n, 0), fill_target(n, 0);\\n        \\n        // fill_up: flowers needed to get min of flowers to flowers[i]\\n        fill_up[0] = 0;\\n        for(int i = 1; i < n; i++) {\\n            fill_up[i] = (flowers[i] - flowers[i-1]) * (long long)i + fill_up[i-1];\\n        }\\n        // fill_target[i] fill flowers[i] to flowers[n-1] to target level\\n        fill_target[n-1] = (long long) target - flowers[n-1];\\n        for(int i = n - 2; i >= 0; i--) {\\n            fill_target[i] = fill_target[i+1] + (long long)(target - flowers[i]); \\n        }\\n        long long ret = 0;\\n        for(int num_fill = 0; num_fill <= n; num_fill++) {\\n            long long m = 0;\\n            long long rm = newFlowers;\\n            if(num_fill != 0) {\\n                rm -= fill_target[n-num_fill];\\n            }\\n            if(rm < 0) break;\\n            if(num_fill != n) {\\n                auto ptr = upper_bound(fill_up.begin(), fill_up.end(), rm);\\n                // can get min to flowers[idx-1] level, but not flowers[idx] level\\n                int idx = ptr - fill_up.begin();\\n                if(idx >= n - num_fill) idx = n - num_fill;\\n                m = flowers[idx - 1];\\n                m += (rm - fill_up[idx - 1]) / idx; \\n                m = min(m, (long long)target - 1);\\n            }\\n            long long tmp = m * (long long) partial + (full_cnt + num_fill) * (long long) full;\\n            ret = max(tmp, ret);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895320,
                "title": "python3-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We will sort the gardens to have the small values in front and big values in the end.\\n- We will first remove as many full gardens as possible.\\n- We will then spend all the remaining newFlowers to increase the minimum\\n- We will then return the removed gardens one by one and repeat the previous step to find the max beauty at each step.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: nlogn\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n\\n        flowers.sort()\\n\\n        #Remove all already full gardens\\n        count = 0\\n        while flowers and flowers[-1] >= target:\\n            count += 1\\n            flowers.pop()\\n\\n        #Complete as many gardens as possible\\n        stack = []\\n        while flowers and newFlowers >= target - flowers[-1]:\\n            stack.append(max(0, target - flowers.pop()))\\n            newFlowers -= stack[-1]\\n        \\n        mini = 0\\n        i = 0\\n        #Spend all available newFlowers \\n        if flowers:\\n            while i < len(flowers) and (flowers[i] - mini) * i <= newFlowers:\\n                newFlowers -= (flowers[i] - mini) * i\\n                mini = flowers[i]\\n                i += 1\\n            mini += newFlowers // i\\n            newFlowers %= i\\n        \\n        #Max beauty\\n        maxi = (count + len(stack)) * full + mini * partial\\n\\n        while stack:\\n\\n            #Unplant flowers from one of the completed gardens\\n            newFlowers += stack[-1]\\n            flowers.append(target - stack.pop())\\n\\n            #Reduce mini to match the added garden if necessary\\n            if flowers[-1] < mini:\\n                newFlowers += i * (mini - flowers[-1])\\n                mini = flowers[-1]\\n\\n            #Spend available newFlowers\\n            while i < len(flowers) and (flowers[i] - mini) * i <= newFlowers:\\n                newFlowers -= (flowers[i] - mini) * i\\n                mini = flowers[i]\\n                i += 1\\n            mini += newFlowers // i\\n            newFlowers %= i\\n\\n            #Update max beauty\\n            maxi = max(maxi, (count + len(stack)) * full + min(mini, target - 1) * partial)\\n        \\n        return maxi\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n\\n        flowers.sort()\\n\\n        #Remove all already full gardens\\n        count = 0\\n        while flowers and flowers[-1] >= target:\\n            count += 1\\n            flowers.pop()\\n\\n        #Complete as many gardens as possible\\n        stack = []\\n        while flowers and newFlowers >= target - flowers[-1]:\\n            stack.append(max(0, target - flowers.pop()))\\n            newFlowers -= stack[-1]\\n        \\n        mini = 0\\n        i = 0\\n        #Spend all available newFlowers \\n        if flowers:\\n            while i < len(flowers) and (flowers[i] - mini) * i <= newFlowers:\\n                newFlowers -= (flowers[i] - mini) * i\\n                mini = flowers[i]\\n                i += 1\\n            mini += newFlowers // i\\n            newFlowers %= i\\n        \\n        #Max beauty\\n        maxi = (count + len(stack)) * full + mini * partial\\n\\n        while stack:\\n\\n            #Unplant flowers from one of the completed gardens\\n            newFlowers += stack[-1]\\n            flowers.append(target - stack.pop())\\n\\n            #Reduce mini to match the added garden if necessary\\n            if flowers[-1] < mini:\\n                newFlowers += i * (mini - flowers[-1])\\n                mini = flowers[-1]\\n\\n            #Spend available newFlowers\\n            while i < len(flowers) and (flowers[i] - mini) * i <= newFlowers:\\n                newFlowers -= (flowers[i] - mini) * i\\n                mini = flowers[i]\\n                i += 1\\n            mini += newFlowers // i\\n            newFlowers %= i\\n\\n            #Update max beauty\\n            maxi = max(maxi, (count + len(stack)) * full + min(mini, target - 1) * partial)\\n        \\n        return maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617558,
                "title": "c-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, long long full, long long partial)  \\n    {\\n        sort(flowers.rbegin(), flowers.rend());\\n        long long l = 0, n=flowers.size();;\\n        while(l < n && flowers[l] >= target) l++;\\n        long long ans = 0;\\n        vector<long long> required(n, 0);\\n        for(long long i = n-2 ; i >= l ; i--){\\n            required[i] = required[i+1] + (n-i-1)*(flowers[i]-flowers[i+1]);\\n        }\\n\\n        long long pre = l*full;\\n        ans = pre;\\n        for(int i = l ; i < n ; i++){\\n            long long part = solve(flowers, required, newFlowers, i, target);\\n            ans = max(ans, pre+part*partial);\\n            if(target-flowers[i] <= newFlowers){\\n                pre += full;\\n                newFlowers -= (target-flowers[i]);\\n            }else{\\n                break;\\n            }\\n        }\\n        return ans = max(ans, pre);\\n    }\\n\\n    long long solve(vector<int>& flowers, vector<long long>& req, long long newFlowers, int ind, long long target){\\n        long long l = ind, r = flowers.size(), n = flowers.size();\\n        long long ans = 0;\\n        while(l <= r){\\n            int mid = (l+r)/2;\\n            long long cnt = req[mid];\\n            if(cnt > newFlowers){\\n                l = mid+1;\\n            }else{\\n                ans = flowers[mid] + (newFlowers-cnt)/(n-mid);\\n                r = mid-1;\\n            }\\n        }\\n        return min(ans, target-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, long long full, long long partial)  \\n    {\\n        sort(flowers.rbegin(), flowers.rend());\\n        long long l = 0, n=flowers.size();;\\n        while(l < n && flowers[l] >= target) l++;\\n        long long ans = 0;\\n        vector<long long> required(n, 0);\\n        for(long long i = n-2 ; i >= l ; i--){\\n            required[i] = required[i+1] + (n-i-1)*(flowers[i]-flowers[i+1]);\\n        }\\n\\n        long long pre = l*full;\\n        ans = pre;\\n        for(int i = l ; i < n ; i++){\\n            long long part = solve(flowers, required, newFlowers, i, target);\\n            ans = max(ans, pre+part*partial);\\n            if(target-flowers[i] <= newFlowers){\\n                pre += full;\\n                newFlowers -= (target-flowers[i]);\\n            }else{\\n                break;\\n            }\\n        }\\n        return ans = max(ans, pre);\\n    }\\n\\n    long long solve(vector<int>& flowers, vector<long long>& req, long long newFlowers, int ind, long long target){\\n        long long l = ind, r = flowers.size(), n = flowers.size();\\n        long long ans = 0;\\n        while(l <= r){\\n            int mid = (l+r)/2;\\n            long long cnt = req[mid];\\n            if(cnt > newFlowers){\\n                l = mid+1;\\n            }else{\\n                ans = flowers[mid] + (newFlowers-cnt)/(n-mid);\\n                r = mid-1;\\n            }\\n        }\\n        return min(ans, target-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616200,
                "title": "python3-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n\\n        flowers.sort()\\n        n = len(flowers)\\n\\n        # 1: exclude complete gardens\\n        m = bisect.bisect_left(flowers, target)\\n        init = (n - m) * full\\n        \\n        if m == 0:\\n            return init\\n\\n        # 2. pre-processing\\n        need = [0] * m  # to flood till flowers[index], how many more flowers needed\\n        for index in range(1, m):\\n            need[index] = need[index - 1] + index * (flowers[index] - flowers[index - 1])\\n\\n        # gardens are all partials:\\n        ans = self.partial_garden(need, newFlowers, flowers, target, partial, m)\\n        \\n        # 3. loop all possible new complete garden index numbers\\n        for index in range(m - 1, -1, -1):\\n            if newFlowers + flowers[index] < target:\\n                break\\n            else:\\n                newFlowers -= (target - flowers[index]) # fill current \\'index\\' garden to be full\\n            \\n            cur_partial = self.partial_garden(need, newFlowers, flowers, target, partial, index)\\n            \\n            ans = max(ans, cur_partial + full * (m - index))\\n        \\n        return ans + init\\n\\n\\n    def partial_garden(self, nums, newFlowers, flowers, target, partial, ind):\\n        if ind == 0:\\n            return 0\\n        index = bisect.bisect_right(nums, newFlowers)\\n        index = min(index, ind)\\n        min_val = min(target - 1, flowers[index - 1] + (newFlowers - nums[index - 1]) // index)\\n        return min_val * partial\\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n\\n        flowers.sort()\\n        n = len(flowers)\\n\\n        # 1: exclude complete gardens\\n        m = bisect.bisect_left(flowers, target)\\n        init = (n - m) * full\\n        \\n        if m == 0:\\n            return init\\n\\n        # 2. pre-processing\\n        need = [0] * m  # to flood till flowers[index], how many more flowers needed\\n        for index in range(1, m):\\n            need[index] = need[index - 1] + index * (flowers[index] - flowers[index - 1])\\n\\n        # gardens are all partials:\\n        ans = self.partial_garden(need, newFlowers, flowers, target, partial, m)\\n        \\n        # 3. loop all possible new complete garden index numbers\\n        for index in range(m - 1, -1, -1):\\n            if newFlowers + flowers[index] < target:\\n                break\\n            else:\\n                newFlowers -= (target - flowers[index]) # fill current \\'index\\' garden to be full\\n            \\n            cur_partial = self.partial_garden(need, newFlowers, flowers, target, partial, index)\\n            \\n            ans = max(ans, cur_partial + full * (m - index))\\n        \\n        return ans + init\\n\\n\\n    def partial_garden(self, nums, newFlowers, flowers, target, partial, ind):\\n        if ind == 0:\\n            return 0\\n        index = bisect.bisect_right(nums, newFlowers)\\n        index = min(index, ind)\\n        min_val = min(target - 1, flowers[index - 1] + (newFlowers - nums[index - 1]) // index)\\n        return min_val * partial\\n            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582524,
                "title": "prefix-sum-binary-search-maths-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Idea is we will sort the flowers and we say ok we have some garden which are alredy full now I have `x` amount of extra flower \\n- so till what we can push the minima of non full garden using `x` amount of flower .\\n- and in each iteration we will increase the number of full garden and naturally now `x` will decrease to `x\\'` and how again we do same thing as above and will calculate the  maxima of all result \\n- we can get intial number of garden >=target using binay search \\n- now main gole is to get till what ciling i can push minima \\n- so for what we need cumilated difference \\n- eg 1 2 3 4 and i want to push minima celing till 3 so i need (1+2)extra flower or `dp[i-1]+flower[i]-flower[i-1]*i` flower.\\n- so now we have cumilated sum dp .\\n- now If I have `x` flower left then till which level I can push \\n- I can push atleast till that level where dp[i] is less than equal to x \\n- eg: dp= 1 2 5 7 and x=4 so I can push till flower[1] and dp[1]<x and after pushing till flower[1] I have some extra flower then I will distrubute rest of flower among `2` flower as i=1;  \\n- same thing in form of code\\n`ll temp = count - dp[j-1];`\\n`ll mini = (temp / j) + flowers[j-1];`\\n`ans = max(ans, min(mini, 1ll * target - 1) * 1ll * partial + ((n - j) * 1ll * full));`\\n\\nNow just dry run with sample test case U will get the idea and look at code at Once .\\n\\n`FYI:I literlly spend 2 hours on this question nahi hoga nahi hoga to kr k rahunga`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long \\n\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        int n = flowers.size();\\n        sort(flowers.begin(), flowers.end());\\n        vector<ll> dp(n, 0);   \\n\\n        // Calculate the cumulative difference of beauty values\\n        //how much flowers needed to make all j equal to i and j<i;\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = dp[i-1] + (flowers[i] - flowers[i-1]) * i;\\n        }\\n\\n        //atleast this any full garden will be there no matter what\\n        int j = lower_bound(flowers.begin(), flowers.end(), target) - flowers.begin();\\n\\n        if (j == 0) {\\n            return n * 1ll * full;\\n        }\\n\\n        ll count = newFlowers;\\n        ll ans = 0;\\n\\n        while (count > 0 && j >= 0) {\\n            int i = upper_bound(dp.begin(), dp.end(), count) - dp.begin();\\n\\n            if (i == 0) {\\n                break;\\n            }\\n\\n            if (i > j) {\\n                if (j == 0) {\\n                    ans = max(ans, (n - j) * 1ll * full);\\n                } else {\\n                    ll temp = count - dp[j-1];\\n                    ll mini = (temp / j) + flowers[j-1];\\n                    ans = max(ans, min(mini, 1ll * target - 1) * 1ll * partial + ((n - j) * 1ll * full));\\n                }\\n            } else {\\n                ll temp = count - dp[i-1];\\n                ll mini = (temp / i) + flowers[i-1];\\n                ans = max(ans, min(mini, 1ll * target - 1) * 1ll * partial + (n - j) * 1ll * full);\\n            }\\n\\n            if (j - 1 >= 0) {\\n                count -= target - flowers[j-1];\\n            }\\n\\n            // cout << \"upper \" << j << \" \" << \"lower \" << i << \" \" << ans << \" \" << count << \"\\\\n\";\\n            j--;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long \\n\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        int n = flowers.size();\\n        sort(flowers.begin(), flowers.end());\\n        vector<ll> dp(n, 0);   \\n\\n        // Calculate the cumulative difference of beauty values\\n        //how much flowers needed to make all j equal to i and j<i;\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = dp[i-1] + (flowers[i] - flowers[i-1]) * i;\\n        }\\n\\n        //atleast this any full garden will be there no matter what\\n        int j = lower_bound(flowers.begin(), flowers.end(), target) - flowers.begin();\\n\\n        if (j == 0) {\\n            return n * 1ll * full;\\n        }\\n\\n        ll count = newFlowers;\\n        ll ans = 0;\\n\\n        while (count > 0 && j >= 0) {\\n            int i = upper_bound(dp.begin(), dp.end(), count) - dp.begin();\\n\\n            if (i == 0) {\\n                break;\\n            }\\n\\n            if (i > j) {\\n                if (j == 0) {\\n                    ans = max(ans, (n - j) * 1ll * full);\\n                } else {\\n                    ll temp = count - dp[j-1];\\n                    ll mini = (temp / j) + flowers[j-1];\\n                    ans = max(ans, min(mini, 1ll * target - 1) * 1ll * partial + ((n - j) * 1ll * full));\\n                }\\n            } else {\\n                ll temp = count - dp[i-1];\\n                ll mini = (temp / i) + flowers[i-1];\\n                ans = max(ans, min(mini, 1ll * target - 1) * 1ll * partial + (n - j) * 1ll * full);\\n            }\\n\\n            if (j - 1 >= 0) {\\n                count -= target - flowers[j-1];\\n            }\\n\\n            // cout << \"upper \" << j << \" \" << \"lower \" << i << \" \" << ans << \" \" << count << \"\\\\n\";\\n            j--;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3357385,
                "title": "python-prefix-sum-with-binary-search-o-nlogn-intuition-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition would be first sort the array, since the position of the garden doesn\\'t matter.\\n\\nThen we consider the following:\\n## Do we binary search the maximum score?\\n  - After some thinking, determine whether a value can be achieved is hard, since there\\'s no greedy approach to get an achievable solution.\\n\\n## Do we binary search the number of garden to fill & threshold to be partial?\\n  - Notice that when total full garden increase(total score +), the minimum value of partial garden decreses(total score -), which don\\'t look like a monotonic problem.\\n\\n## Then we have an observation of the cost, apparently it consist of 3 parts, fill_cost, align_cost and spread cost. \\n- Fill cost: the cost to fill $i$ largerst garden to target\\n- Align cost: the cost to align previous garden to $i_{th}$ garden (which increase the minimun value).\\n- Speard cost: left flowers can\\'t align to $i+1_{th}$ element, but can increase the minimum value per the number of all aligned elements. \\n## How to calculate the each cost?\\n- using prefix sum to avoid summing up the previous k cost everytime\\n- Fill cost:\\n![Snipaste_2023-03-29_19-18-17.png](https://assets.leetcode.com/users/images/c5331ad6-72aa-4db2-b60e-10d2ed3c4b7f_1680131940.5136378.png)\\n- Align cost:\\n![Snipaste_2023-03-29_19-17-06.png](https://assets.leetcode.com/users/images/80499ab0-937c-493e-900e-32ebd671c021_1680131837.119551.png)\\n- Spread cost:\\n![Snipaste_2023-03-29_19-23-11.png](https://assets.leetcode.com/users/images/07d00b81-c301-4e81-98eb-944410a60455_1680132204.6220386.png)\\n\\n## Why align cost then other?\\nThe pain point is to determine what\\'s min partial after the fill, by using bisect_right, we not only have the cost of align previous $i - 1$ element to $i_{th}$, but also get the unit cost to increase the minimum value by 1.\\n\\n# Edge cases\\n- new flower too small / =0?\\n- new flower too big?\\n  - If we have enough flowers to fill all garden to target, the optimal solution would be fill all garden or left 1 garden to be target - 1 since partial >= 0\\n  - We should cap the \\n- All garden already reach the target?\\n  - Do nothing, return # of garden * full\\n- \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nsort: $O(NlogN)$\\niterate thru c1: $O(N)$\\nbinary search thru c2: $O(logN)$\\ntotal: $O(NlogN) + O(N) * O(logN) = O(NlogN)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(N)$\\n# Code\\n```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], nf: int, target: int, full: int, partial: int) -> int:\\n        flowers, base = sorted([v for v in flowers if v < target], reverse=True), len([v for v in flowers if v >= target]) * full\\n        if flowers == []:\\n            return base\\n        n = len(flowers)\\n        c1, c2 = [], []\\n        # calculate C1, the fill cost\\n        ttl = 0\\n        for i, v in enumerate(flowers):\\n            c1.append(i * target - ttl)\\n            ttl += v\\n        c1.append(n * target - ttl)\\n\\n        # calculate C2, the align cost\\n        flowers.reverse()\\n        ttl = 0\\n        for i, v in enumerate(flowers):\\n            c2.append(i * v - ttl)\\n            ttl += v\\n        c2.append(n * target - ttl)\\n\\n        # \\n        if nf >= c2[-1]:\\n            return base + full * (n-1) + max(full, (target - 1) * partial)\\n\\n        maxV = 0\\n        for k1, fc in enumerate(c1):\\n            # only continue if we have enough flower to fill k1 number of garden\\n            if fc > nf:\\n                break\\n            # set the upper bound to n - k1 to avoid overlap\\n            j = bisect_right(c2, nf - fc, 0, n - k1)\\n\\n            # flowers_left = total_flower - fill_cost[k1] - align_cost[j - 1]\\n            npv = min(flowers[j - 1] + (nf - fc - c2[j - 1]) // j, target - 1)\\n            nv = full * k1 + npv * partial\\n            maxV = max(maxV, nv)\\n        return base + maxV\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], nf: int, target: int, full: int, partial: int) -> int:\\n        flowers, base = sorted([v for v in flowers if v < target], reverse=True), len([v for v in flowers if v >= target]) * full\\n        if flowers == []:\\n            return base\\n        n = len(flowers)\\n        c1, c2 = [], []\\n        # calculate C1, the fill cost\\n        ttl = 0\\n        for i, v in enumerate(flowers):\\n            c1.append(i * target - ttl)\\n            ttl += v\\n        c1.append(n * target - ttl)\\n\\n        # calculate C2, the align cost\\n        flowers.reverse()\\n        ttl = 0\\n        for i, v in enumerate(flowers):\\n            c2.append(i * v - ttl)\\n            ttl += v\\n        c2.append(n * target - ttl)\\n\\n        # \\n        if nf >= c2[-1]:\\n            return base + full * (n-1) + max(full, (target - 1) * partial)\\n\\n        maxV = 0\\n        for k1, fc in enumerate(c1):\\n            # only continue if we have enough flower to fill k1 number of garden\\n            if fc > nf:\\n                break\\n            # set the upper bound to n - k1 to avoid overlap\\n            j = bisect_right(c2, nf - fc, 0, n - k1)\\n\\n            # flowers_left = total_flower - fill_cost[k1] - align_cost[j - 1]\\n            npv = min(flowers[j - 1] + (nf - fc - c2[j - 1]) // j, target - 1)\\n            nv = full * k1 + npv * partial\\n            maxV = max(maxV, nv)\\n        return base + maxV\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175542,
                "title": "maximum-total-beauty-of-the-gardens",
                "content": "# Intuition\\nI do not think that we need a binary search here.\\n\\nWe sort gardens (descending), and then go left to right and make gardens full (until we run out of flowers). Thus, our first pointer p1 indicates full gardens, and the last garden defines the minimum number of flowers (minF) among all gardens.\\n\\nThere is a special case when we can make all gardens full - it may be better to only plant target - 1 flowers in the last garden, if (target - 1) * partial > full.\\n\\nWe then go right-to-left, and try increasing the minimum number of flowers. The second pointer - p2 - indicates how many gardens have less flowers than minF.\\n\\nWe plan necessary flowers to gardens right of p2. If we do not have enough flowers, we take it from the rightmost full garden, decreasing p1. For each minF we can achieve, we track and return the maximum beauty.\\n\\nHere is an example for [9, 7, 7, 6, 5, 4, 3, 2, 1, 1] gardens, with target 8 and 9 new flowers to plant. As you see, for minF == 2, we have 5 full gardens. For minF == 3, we move p1 to get enough flowers to plant, and now we have 4 full gardens.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& fl, long long newFlowers, int target, int full, int partial) {\\n         sort(begin(fl), end(fl), greater<int>());\\n    long long p1 = 0, sum = 0, res = 0, sz = fl.size();\\n    for (; p1 < sz; ++p1) {\\n        if (target - fl[p1] > newFlowers)\\n            break;\\n        newFlowers -= max(0, target - fl[p1]);\\n    }\\n    if (p1 == sz)\\n        return max(sz * full, (sz - 1) * full + (fl.back() < target ? (long long)(target - 1) * partial : full));\\n    for (long long minF = fl.back(), p2 = fl.size() - 1; minF < target; ) {\\n        while (p2 >= p1 && fl[p2] <= minF)\\n            sum += fl[p2--];\\n        int needed = (sz - p2 - 1) * minF - sum;\\n        if (needed > newFlowers) {\\n            if (--p1 < 0)\\n                break;\\n            newFlowers += max(0, target - fl[p1]);\\n        }\\n        else {\\n            res = max(p1 * full + minF * partial, res);    \\n            ++minF;\\n        }\\n    }\\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& fl, long long newFlowers, int target, int full, int partial) {\\n         sort(begin(fl), end(fl), greater<int>());\\n    long long p1 = 0, sum = 0, res = 0, sz = fl.size();\\n    for (; p1 < sz; ++p1) {\\n        if (target - fl[p1] > newFlowers)\\n            break;\\n        newFlowers -= max(0, target - fl[p1]);\\n    }\\n    if (p1 == sz)\\n        return max(sz * full, (sz - 1) * full + (fl.back() < target ? (long long)(target - 1) * partial : full));\\n    for (long long minF = fl.back(), p2 = fl.size() - 1; minF < target; ) {\\n        while (p2 >= p1 && fl[p2] <= minF)\\n            sum += fl[p2--];\\n        int needed = (sz - p2 - 1) * minF - sum;\\n        if (needed > newFlowers) {\\n            if (--p1 < 0)\\n                break;\\n            newFlowers += max(0, target - fl[p1]);\\n        }\\n        else {\\n            res = max(p1 * full + minF * partial, res);    \\n            ++minF;\\n        }\\n    }\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066729,
                "title": "c-sort-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    ll maximumBeauty(vector<int>& F, ll newFlowers, int target, int full, int partial) {\\n        ll res = 0;\\n        sort(begin(F), end(F));\\n        vector<ll> preSum(F.size()+1, 0);\\n        for(int i = 0; i < F.size(); i++) preSum[i+1] = preSum[i]+F[i];\\n        for(int i = F.size()-1; i >= -1; i--) {\\n            if(i >= 0 && F[i] >= target) continue;\\n            int l = -1, h = i;\\n            while(l < h) {\\n                ll m = l + (h-l+1)/2, v_sum = preSum[m+1], t_sum = F[m]*(m+1), diff = t_sum - v_sum;\\n                if(diff > newFlowers) h = m-1;\\n                else l = m;\\n            }\\n            ll min_v = i == -1 ? 0 : min(target-1ll, (preSum[l+1]+(ll)newFlowers)/(l+1));\\n            res = max(res, min_v*partial+((ll)F.size()-i-1)*full);\\n            if(i != -1 && target-F[i] > newFlowers) break;\\n            if(i != -1) newFlowers -= max(0, target-F[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    ll maximumBeauty(vector<int>& F, ll newFlowers, int target, int full, int partial) {\\n        ll res = 0;\\n        sort(begin(F), end(F));\\n        vector<ll> preSum(F.size()+1, 0);\\n        for(int i = 0; i < F.size(); i++) preSum[i+1] = preSum[i]+F[i];\\n        for(int i = F.size()-1; i >= -1; i--) {\\n            if(i >= 0 && F[i] >= target) continue;\\n            int l = -1, h = i;\\n            while(l < h) {\\n                ll m = l + (h-l+1)/2, v_sum = preSum[m+1], t_sum = F[m]*(m+1), diff = t_sum - v_sum;\\n                if(diff > newFlowers) h = m-1;\\n                else l = m;\\n            }\\n            ll min_v = i == -1 ? 0 : min(target-1ll, (preSum[l+1]+(ll)newFlowers)/(l+1));\\n            res = max(res, min_v*partial+((ll)F.size()-i-1)*full);\\n            if(i != -1 && target-F[i] > newFlowers) break;\\n            if(i != -1) newFlowers -= max(0, target-F[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920340,
                "title": "nlog-n-greedy-two-pointers",
                "content": "```c++\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        int n = flowers.size();\\n        if (flowers[0] >= target) return n * (long long)full;\\n        vector<long long> fillLeft(n, 0);\\n        for (int i = 1; i < n; ++i) {\\n            fillLeft[i] = fillLeft[i - 1] + i * (long long)(flowers[i] - flowers[i - 1]);\\n        }\\n\\n        long long ret = 0;\\n        int r = n, l = n - 1;\\n        while (r > -1 && newFlowers > 0 && l > -1) {\\n            if (r < n) {\\n                if (flowers[r] < target) newFlowers += (flowers[r] - target);\\n                if (newFlowers <= 0) return ret;\\n            }\\n            long long val = 0;\\n            if (r > 0) {\\n                l = min(r - 1 , l);\\n                while (l > -1 && fillLeft[l] > newFlowers) --l; \\n                ++l;\\n                if (l == 0) val = flowers[0] + newFlowers;\\n                else  val = flowers[l - 1] + (newFlowers - fillLeft[l - 1])/l;\\n                val = min(val, (long long)target -1);\\n            } \\n            ret = max(ret, full * (long long) (n - r) + val * partial);\\n            --r;\\n        }\\n        return ret;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        int n = flowers.size();\\n        if (flowers[0] >= target) return n * (long long)full;\\n        vector<long long> fillLeft(n, 0);\\n        for (int i = 1; i < n; ++i) {\\n            fillLeft[i] = fillLeft[i - 1] + i * (long long)(flowers[i] - flowers[i - 1]);\\n        }\\n\\n        long long ret = 0;\\n        int r = n, l = n - 1;\\n        while (r > -1 && newFlowers > 0 && l > -1) {\\n            if (r < n) {\\n                if (flowers[r] < target) newFlowers += (flowers[r] - target);\\n                if (newFlowers <= 0) return ret;\\n            }\\n            long long val = 0;\\n            if (r > 0) {\\n                l = min(r - 1 , l);\\n                while (l > -1 && fillLeft[l] > newFlowers) --l; \\n                ++l;\\n                if (l == 0) val = flowers[0] + newFlowers;\\n                else  val = flowers[l - 1] + (newFlowers - fillLeft[l - 1])/l;\\n                val = min(val, (long long)target -1);\\n            } \\n            ret = max(ret, full * (long long) (n - r) + val * partial);\\n            --r;\\n        }\\n        return ret;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905279,
                "title": "c-suffix-sum-binary-search-explained-with-comments",
                "content": "typedef long long ll;\\n\\nclass Solution {\\npublic:\\n    \\n    ll getMaxMin(vector<int>& arr, int i, int n, ll cl, ll &s, vector<ll>& suf){\\n        \\n        // Here we are finding the maximum min val that can be obtained using \\'s\\'. Since values cannot be more than target,\\n        // res will have an upper bound of cl.\\n        \\n        if(i == n) return 0;\\n        ll res = arr[n-1];\\n        ll l = res, r = cl;\\n\\n        while(l <= r){\\n            // Here we use suffix sum to find if mid can be achieved using \\'s\\' values. For e.g for arr{4,3,2,1} to have a min value \\n            // of 4, we calculate upper bound on 4, which is index 1(i.e. value 3). Now if 4 were to be the min value in the array,\\n            // then sum[1...3] should be 3*4 = 12. Actual sum is suf[1], i.e. 6. Now we compare this value against s.\\n            ll mid = (l+r) >> 1;\\n            int k = upper_bound(arr.begin()+i, arr.end(), mid, greater<int>())-arr.begin();\\n            if(k == n) k--;\\n\\n            ll req = (((ll)(n-k) * (mid))-suf[k]);\\n            \\n            if(req > s){\\n                r = mid-1;\\n            }else{\\n                res = mid;\\n                l = mid+1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        //use a greedy approach, start with 0 full gardens, then 1 full garden upto n;\\n        sort(flowers.begin(), flowers.end(), [](const int& a, const int& b) -> bool{\\n            return a > b;\\n        });\\n        int n = flowers.size();\\n        int l = 0;\\n        //skip already full gardens\\n        while(l < n && flowers[l] >= target) l++;\\n        \\n        if(l == n) return (l*(ll)full);\\n        \\n        ll cl = target-1;\\n        \\n        //Find suffix sum\\n        vector<ll> suf(n);\\n        suf[n-1] = flowers[n-1];\\n        for(int i = n-2 ; i >=0 ; i--)\\n            suf[i] += (suf[i+1] + flowers[i]);\\n        \\n        ll fullCnt = l;\\n        \\n        ll res = (fullCnt * full + partial*getMaxMin(flowers, l, n, target-1, newFlowers, suf));\\n        \\n        for(int i = l ; i < n ; i++){\\n            ll reqFlowers = target-flowers[i];\\n            if(reqFlowers > newFlowers) break;\\n            newFlowers -= reqFlowers;\\n            fullCnt = i+1;\\n            \\n            res = max(res, fullCnt*full + partial*getMaxMin(flowers, i+1, n, target-1, newFlowers, suf));\\n        }\\n        \\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    ll getMaxMin(vector<int>& arr, int i, int n, ll cl, ll &s, vector<ll>& suf){\\n        \\n        // Here we are finding the maximum min val that can be obtained using \\'s\\'. Since values cannot be more than target,\\n        // res will have an upper bound of cl.\\n        \\n        if(i == n) return 0;\\n        ll res = arr[n-1];\\n        ll l = res, r = cl;\\n\\n        while(l <= r){\\n            // Here we use suffix sum to find if mid can be achieved using \\'s\\' values. For e.g for arr{4,3,2,1}",
                "codeTag": "Java"
            },
            {
                "id": 2667568,
                "title": "c-fast-simple",
                "content": "Link to the submission stats:\\nhttps://leetcode.com/submissions/detail/816324822/\\n\\n```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& ar, long long m, int t, int f, int p) {\\n        int n=ar.size();\\n        sort(ar.rbegin(),ar.rend());\\n        vector<long long> suf(n);\\n        vector<long long> mi(n);\\n        suf[n-1]=ar[n-1];\\n        mi[n-1]=0;\\n        for(int i=n-2;i>=0;i--){\\n            suf[i]=suf[i+1]+ar[i];\\n            mi[i]=mi[i+1]+(long long)(ar[i]-ar[i+1])*(n-i-1);\\n        }\\n        long long ans=0;\\n        int i=0;\\n        while(i<n && ar[i]>=t){i++;}\\n        while(i<n){\\n            if(m>=(long long)(t-1)*(n-i) - suf[i]){\\n                ans=max(ans,(long long)(i)*f + (long long)p*(t-1));\\n            }\\n            else{\\n                int lo=i,hi=n;\\n                int anss=-1;\\n                while(lo<hi){\\n                    int mid = (lo+hi)/2;\\n                    if(mi[mid]<=m){\\n                        anss=mid;\\n                        hi=mid;\\n                    }\\n                    else{\\n                        lo=mid+1;\\n                    }\\n                }\\n                long long mimi = m - mi[anss];\\n                mimi = ar[anss] + mimi/(n-anss);\\n                ans=max(ans,(long long)i*f + (long long)p*mimi);\\n            }\\n            long long dif = t-ar[i];\\n            if(m<dif){break;}\\n            m-=dif;\\n            i++;\\n        }\\n        if(i==n){ans=max(ans,(long long)f*n);}\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& ar, long long m, int t, int f, int p) {\\n        int n=ar.size();\\n        sort(ar.rbegin(),ar.rend());\\n        vector<long long> suf(n);\\n        vector<long long> mi(n);\\n        suf[n-1]=ar[n-1];\\n        mi[n-1]=0;\\n        for(int i=n-2;i>=0;i--){\\n            suf[i]=suf[i+1]+ar[i];\\n            mi[i]=mi[i+1]+(long long)(ar[i]-ar[i+1])*(n-i-1);\\n        }\\n        long long ans=0;\\n        int i=0;\\n        while(i<n && ar[i]>=t){i++;}\\n        while(i<n){\\n            if(m>=(long long)(t-1)*(n-i) - suf[i]){\\n                ans=max(ans,(long long)(i)*f + (long long)p*(t-1));\\n            }\\n            else{\\n                int lo=i,hi=n;\\n                int anss=-1;\\n                while(lo<hi){\\n                    int mid = (lo+hi)/2;\\n                    if(mi[mid]<=m){\\n                        anss=mid;\\n                        hi=mid;\\n                    }\\n                    else{\\n                        lo=mid+1;\\n                    }\\n                }\\n                long long mimi = m - mi[anss];\\n                mimi = ar[anss] + mimi/(n-anss);\\n                ans=max(ans,(long long)i*f + (long long)p*mimi);\\n            }\\n            long long dif = t-ar[i];\\n            if(m<dif){break;}\\n            m-=dif;\\n            i++;\\n        }\\n        if(i==n){ans=max(ans,(long long)f*n);}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609457,
                "title": "easy-c-binary-search-prefix-sum-solution-beats-88",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>&nums, long long nf, long long target, long long f, long long partial) {\\n//      sorting the array\\n        sort(nums.begin(),nums.end());\\n        long long full=0;\\n//      count the already full gardens \\n        for(auto num:nums){\\n            full+=(num>=target);\\n        }\\n//       create a prefix array\\n        vector<long long>pre(nums.size()-full);\\n        for(long long i=1ll;i<nums.size()-full;i++){\\n            pre[i]=pre[i-1]+(nums[i]-nums[i-1])*1ll*i;\\n        }\\n        \\n        \\n//      declare answer  \\n        long long ans=0;\\n//      if all gardens are alreay full, we can\\'t proceed further\\n        if(full==nums.size())return full*1ll*f;\\n        ans=max(ans,full*f+nums[0]*partial);\\n        \\n//      increasing the size of nums by one to handle the case of (already full == 0);\\n        nums.push_back(target);\\n        \\n//      loop from back\\n        for(int i = pre.size() ; i>=0;i--){\\n//      handle the case i==0 separately because prefix array will be empty this time and we cannot apply upper_bound on empthy vector\\n            if(i==0){\\n                if(nf>=target*1ll-nums[i]*1ll){\\n                    full++;\\n                    ans=max(ans,f*1ll*full) ;\\n                }\\n            }\\n//          if we are able to make ith garden full\\n            else if(nf>=target-nums[i]){\\n//              decreasing the flowers available  \\n                nf-=max(target-nums[i],0ll);\\n//              increasing count of full gardens because our current garden is also full now \\n                if(nums[i]<target)full++;\\n                \\n//              getting the index off the garden whose pre[index] <= available flowers;\\n                long long ind = upper_bound(pre.begin(),pre.end(),nf)-pre.begin()-1;\\n//              how much extra flowers we can add to the gardens to increase minimum\\n                long long delta=(nf*1ll-pre[ind])/(ind+1);\\n                \\n//              updating the answer\\n                if(delta + nums[ind] >= target)delta=target-nums[ind]-1;\\n                ans=max(ans , full *(1ll)* f + partial*1ll*(nums[ind]+delta));\\n//             decreasing the size of pre\\n                pre.pop_back();\\n                 \\n            }else break;\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>&nums, long long nf, long long target, long long f, long long partial) {\\n//      sorting the array\\n        sort(nums.begin(),nums.end());\\n        long long full=0;\\n//      count the already full gardens \\n        for(auto num:nums){\\n            full+=(num>=target);\\n        }\\n//       create a prefix array\\n        vector<long long>pre(nums.size()-full);\\n        for(long long i=1ll;i<nums.size()-full;i++){\\n            pre[i]=pre[i-1]+(nums[i]-nums[i-1])*1ll*i;\\n        }\\n        \\n        \\n//      declare answer  \\n        long long ans=0;\\n//      if all gardens are alreay full, we can\\'t proceed further\\n        if(full==nums.size())return full*1ll*f;\\n        ans=max(ans,full*f+nums[0]*partial);\\n        \\n//      increasing the size of nums by one to handle the case of (already full == 0);\\n        nums.push_back(target);\\n        \\n//      loop from back\\n        for(int i = pre.size() ; i>=0;i--){\\n//      handle the case i==0 separately because prefix array will be empty this time and we cannot apply upper_bound on empthy vector\\n            if(i==0){\\n                if(nf>=target*1ll-nums[i]*1ll){\\n                    full++;\\n                    ans=max(ans,f*1ll*full) ;\\n                }\\n            }\\n//          if we are able to make ith garden full\\n            else if(nf>=target-nums[i]){\\n//              decreasing the flowers available  \\n                nf-=max(target-nums[i],0ll);\\n//              increasing count of full gardens because our current garden is also full now \\n                if(nums[i]<target)full++;\\n                \\n//              getting the index off the garden whose pre[index] <= available flowers;\\n                long long ind = upper_bound(pre.begin(),pre.end(),nf)-pre.begin()-1;\\n//              how much extra flowers we can add to the gardens to increase minimum\\n                long long delta=(nf*1ll-pre[ind])/(ind+1);\\n                \\n//              updating the answer\\n                if(delta + nums[ind] >= target)delta=target-nums[ind]-1;\\n                ans=max(ans , full *(1ll)* f + partial*1ll*(nums[ind]+delta));\\n//             decreasing the size of pre\\n                pre.pop_back();\\n                 \\n            }else break;\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2414684,
                "title": "a-no-sort-java-solution-other-solutions",
                "content": "I am so frustrated by this question. I went through 3 different implementations and each time there was a stupid bug for me to debug. \\n\\nMy first solution didn\\'t sort the array at all. It is some kind of adjusting on the fly with heap and treeset. It is way too overcomplicated, so I will leave that for the last. \\n\\nHere this is the most optimal solution. It runs in 50ms scoring 90% Speed. O(1) Space with sort and **no** binary search. I\\'d actually recommend binary search instead, it may be slower but it is a lot easier to get right. or maybe it is just because I am so used to write binary search ...\\n\\n#### Java\\n```Java\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        Arrays.sort(flowers);\\n        if (flowers[0] >= target){\\n            return 1L*full*flowers.length;\\n        }\\n        int lo = flowers[0], k = 0; // here lo = maximum partial\\n        long left = newFlowers;\\n        for(;lo < target-1 && left >= 0; lo++){\\n            while(k < flowers.length && flowers[k] <= lo){\\n                ++k;\\n            }\\n            left -= k;\\n        }\\n        if (left < 0){\\n            left += k;\\n            --lo;\\n        }\\n        long ans = 1L*lo*partial; // start from no full, max partial\\n        for (int i = flowers.length-1,j=i; i >= 0 && left >= 0; i--){ // make flowers[i] FULL.\\n            j = Math.min(i-1, j);\\n            if (flowers[i] < target){ // need something\\n                left -= (target - Math.max(lo, flowers[i]));\\n                while(left < 0 && j >= 0){\\n                    if (lo>flowers[j]){ // keep moving the j pointers leftward\\n                        left += j+1;\\n                        lo--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n            if (left >= 0){\\n                ans = Math.max(ans, 1L*(flowers.length-i)*full + 1L*(i==0?0:lo)*partial);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n#### Solution 2 (Binary Search)\\nSame idea as above, except this time we binary search for the max min partial\\n\\n```Java\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        int lo = Arrays.stream(flowers).min().getAsInt(), hi = target - 1;\\n        long left = newFlowers;\\n        while(lo < hi){ // binary search\\n            int mid = (lo+hi+1)>>1;\\n            long cost = 0;\\n            for (int n : flowers){\\n                cost += Math.max(0, mid-n);\\n            }\\n            if (cost <= newFlowers){\\n                left = newFlowers-cost;\\n                lo=mid;\\n            }else{\\n                hi=mid-1;\\n            }\\n        }\\n        if (lo >= target){\\n            return 1L*full*flowers.length;\\n        }\\n        long ans = 1L*lo*partial;\\n        Arrays.sort(flowers);\\n        for (int i = flowers.length-1,j=i; i >= 0 && left >= 0; i--){\\n            j = Math.min(i-1, j);\\n            if (flowers[i] < target){\\n                left -= (target - Math.max(lo, flowers[i]));\\n                while(left < 0 && j >= 0){\\n                    if (lo>flowers[j]){\\n                        left += j+1;\\n                        lo--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n            if (left >= 0){\\n                ans = Math.max(ans, 1L*(flowers.length-i)*full + 1L*(i==0?0:lo)*partial);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n#### Solution 3 (So complicated)\\nInstead of sort, I, uh.. for some reason, think that we can adjust on the fly with heap and treeset! It works but the implementation is tricky. I do not recommend it.\\n\\nOne good thing about this approach though, is that even if `target <= 1e10`, it will still work unlike the other 2 solutions.\\n```Java\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        int lo = Arrays.stream(flowers).min().getAsInt(), hi = target - 1;\\n        while(lo < hi){\\n            int mid = (lo+hi+1)>>1;\\n            long cost = 0;\\n            for (int n : flowers){\\n                cost += Math.max(0, mid-n);\\n            }\\n            if (cost <= newFlowers){\\n                lo=mid;\\n            }else{\\n                hi=mid-1;\\n            }\\n        }\\n        if (lo >= target){\\n            return 1L*full*flowers.length;\\n        }\\n        int cap = 0, fc = 0;\\n        long left = newFlowers;\\n        var maxheap = new PriorityQueue<Integer>(Comparator.comparingInt(o -> -flowers[o]));\\n        var able    = new TreeSet<Integer>((a,b)->flowers[a]==flowers[b]?a-b:flowers[b]-flowers[a]);\\n        for (int i = 0; i < flowers.length; i++){\\n            if (flowers[i] >= target){\\n                ++fc;\\n            }else{\\n                maxheap.offer(i);\\n            }\\n            if (flowers[i] < lo){\\n                able.add(i);\\n                left -= (lo - flowers[i]);\\n            }\\n        }\\n        long ans = 1L*lo * partial + 1L*fc * full;\\n        while(!maxheap.isEmpty() && left >= 0){\\n            int cur = maxheap.poll();\\n            int req = target - Math.max(lo, flowers[cur]);\\n            able.remove(cur);\\n            while (left < req && !able.isEmpty()){\\n                long a = ((req-left-1)/able.size())+1;\\n                if (lo-a >= flowers[able.first()]){\\n                    lo-=a;\\n                    left += a*able.size();\\n                }else{\\n                    left += 1L*able.size() * (lo - flowers[able.first()]);\\n                    lo = flowers[able.pollFirst()];\\n                }\\n            }\\n            left -= req;\\n            if (left >= 0){\\n                if (++fc == flowers.length){\\n                    lo=0;\\n                }\\n                ans = Math.max(ans, 1L*lo*partial + 1L*fc*full);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```Java\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        Arrays.sort(flowers);\\n        if (flowers[0] >= target){\\n            return 1L*full*flowers.length;\\n        }\\n        int lo = flowers[0], k = 0; // here lo = maximum partial\\n        long left = newFlowers;\\n        for(;lo < target-1 && left >= 0; lo++){\\n            while(k < flowers.length && flowers[k] <= lo){\\n                ++k;\\n            }\\n            left -= k;\\n        }\\n        if (left < 0){\\n            left += k;\\n            --lo;\\n        }\\n        long ans = 1L*lo*partial; // start from no full, max partial\\n        for (int i = flowers.length-1,j=i; i >= 0 && left >= 0; i--){ // make flowers[i] FULL.\\n            j = Math.min(i-1, j);\\n            if (flowers[i] < target){ // need something\\n                left -= (target - Math.max(lo, flowers[i]));\\n                while(left < 0 && j >= 0){\\n                    if (lo>flowers[j]){ // keep moving the j pointers leftward\\n                        left += j+1;\\n                        lo--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n            if (left >= 0){\\n                ans = Math.max(ans, 1L*(flowers.length-i)*full + 1L*(i==0?0:lo)*partial);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```Java\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        int lo = Arrays.stream(flowers).min().getAsInt(), hi = target - 1;\\n        long left = newFlowers;\\n        while(lo < hi){ // binary search\\n            int mid = (lo+hi+1)>>1;\\n            long cost = 0;\\n            for (int n : flowers){\\n                cost += Math.max(0, mid-n);\\n            }\\n            if (cost <= newFlowers){\\n                left = newFlowers-cost;\\n                lo=mid;\\n            }else{\\n                hi=mid-1;\\n            }\\n        }\\n        if (lo >= target){\\n            return 1L*full*flowers.length;\\n        }\\n        long ans = 1L*lo*partial;\\n        Arrays.sort(flowers);\\n        for (int i = flowers.length-1,j=i; i >= 0 && left >= 0; i--){\\n            j = Math.min(i-1, j);\\n            if (flowers[i] < target){\\n                left -= (target - Math.max(lo, flowers[i]));\\n                while(left < 0 && j >= 0){\\n                    if (lo>flowers[j]){\\n                        left += j+1;\\n                        lo--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n            if (left >= 0){\\n                ans = Math.max(ans, 1L*(flowers.length-i)*full + 1L*(i==0?0:lo)*partial);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```Java\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        int lo = Arrays.stream(flowers).min().getAsInt(), hi = target - 1;\\n        while(lo < hi){\\n            int mid = (lo+hi+1)>>1;\\n            long cost = 0;\\n            for (int n : flowers){\\n                cost += Math.max(0, mid-n);\\n            }\\n            if (cost <= newFlowers){\\n                lo=mid;\\n            }else{\\n                hi=mid-1;\\n            }\\n        }\\n        if (lo >= target){\\n            return 1L*full*flowers.length;\\n        }\\n        int cap = 0, fc = 0;\\n        long left = newFlowers;\\n        var maxheap = new PriorityQueue<Integer>(Comparator.comparingInt(o -> -flowers[o]));\\n        var able    = new TreeSet<Integer>((a,b)->flowers[a]==flowers[b]?a-b:flowers[b]-flowers[a]);\\n        for (int i = 0; i < flowers.length; i++){\\n            if (flowers[i] >= target){\\n                ++fc;\\n            }else{\\n                maxheap.offer(i);\\n            }\\n            if (flowers[i] < lo){\\n                able.add(i);\\n                left -= (lo - flowers[i]);\\n            }\\n        }\\n        long ans = 1L*lo * partial + 1L*fc * full;\\n        while(!maxheap.isEmpty() && left >= 0){\\n            int cur = maxheap.poll();\\n            int req = target - Math.max(lo, flowers[cur]);\\n            able.remove(cur);\\n            while (left < req && !able.isEmpty()){\\n                long a = ((req-left-1)/able.size())+1;\\n                if (lo-a >= flowers[able.first()]){\\n                    lo-=a;\\n                    left += a*able.size();\\n                }else{\\n                    left += 1L*able.size() * (lo - flowers[able.first()]);\\n                    lo = flowers[able.pollFirst()];\\n                }\\n            }\\n            left -= req;\\n            if (left >= 0){\\n                if (++fc == flowers.length){\\n                    lo=0;\\n                }\\n                ans = Math.max(ans, 1L*lo*partial + 1L*fc*full);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311735,
                "title": "python-go-c-cumulative-sum-w-binary-search-vs-two-pointers-o-nlogn",
                "content": "*Python* solution w/ binary search\\n\\n```python\\ndef maximumBeauty(self, flowers, newFlowers, target, full, partial):\\n    F = sorted(x for x in flowers if x < target)\\n    A = list(itertools.accumulate(F))\\n    L = [x * (i + 1) - A[i] for i, x in enumerate(F)]\\n    R = [x for x in itertools.accumulate(range(len(F)), lambda a, i: a + F[~i] - target, initial=newFlowers) if x >= 0]\\n    return max(\\n        ((i := bisect.bisect(L, x, hi=len(flowers) - j)) and min(target - 1, (A[i - 1] + x) // i)) * partial + j * full\\n        for j, x in enumerate(R, len(flowers) - len(F))\\n    )\\n```\\n\\n*Python* solution w/ two pointers O(1) space\\n\\n```python\\ndef maximumBeauty(self, flowers, newFlowers, target, full, partial):\\n    res = tot = k = 0\\n    n = len(flowers)\\n    flowers.sort()\\n    while k < n and flowers[k] < target: k, tot = k + 1, tot + flowers[k]\\n    i = j = k - 1\\n    while j >= 0:\\n        if newFlowers < 0: return res\\n        while i > j or i >= 0 and (x := newFlowers + tot) < flowers[i] * (i + 1): i, tot = i - 1, tot - flowers[i]\\n        res = max(res, min(target - 1, x // (i + 1)) * partial + (n - 1 - j) * full)\\n        j, newFlowers = j - 1, newFlowers + flowers[j] - target\\n    return max(res, n * full)\\n```\\n\\n*Go* solution w/ two pointers O(1) space in 208ms\\n\\n```go\\nfunc min(x, y int64) int64 {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\nfunc max(x, y int64) int64 {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc maximumBeauty(flowers []int, newFlowers int64, target int, full int, partial int) int64 {\\n\\tvar (\\n\\t\\tres, tot, k int64\\n\\t\\tn           = int64(len(flowers))\\n\\t)\\n\\tsort.Ints(flowers)\\n\\tfor ; k < n && flowers[k] < target; k, tot = k+1, tot+int64(flowers[k]) {\\n\\t}\\n\\tfor i, j := k-1, k-1; j >= 0; j, newFlowers = j-1, newFlowers+int64(flowers[j]-target) {\\n\\t\\tif newFlowers < 0 {\\n\\t\\t\\treturn res\\n\\t\\t}\\n\\t\\tfor ; i > j || i >= 0 && tot+newFlowers < int64(flowers[i])*(i+1); i, tot = i-1, tot-int64(flowers[i]) {\\n\\t\\t}\\n\\t\\tres = max(res, min(int64(target-1), (tot+newFlowers)/(i+1))*int64(partial)+(n-1-j)*int64(full))\\n\\t}\\n\\treturn max(res, n*int64(full))\\n}\\n```\\n\\n*C++* solution w/ two pointers O(1) space in 182ms beat 100% :)\\n\\n```c++\\nlong long maximumBeauty(vector<int> &A, long long y, int c, int b, int a) {\\n    long long res = 0, x = 0, k = 0, n = A.size();\\n    sort(A.begin(), A.end());\\n    for (; k < n && A[k] < c; x += A[k++]);\\n    for (long long i = k, j = k; j > 0 && y >= 0; y -= c - A[--j]) {\\n        for (; i > j || i > 0 && x + y < A[i - 1] * i; x -= A[--i]);\\n        res = max(res, min((x + y) / i, (long long)c - 1) * a + (n - j) * b);\\n    }\\n    return y < 0 ? res : max(res, n * b);\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\ndef maximumBeauty(self, flowers, newFlowers, target, full, partial):\\n    F = sorted(x for x in flowers if x < target)\\n    A = list(itertools.accumulate(F))\\n    L = [x * (i + 1) - A[i] for i, x in enumerate(F)]\\n    R = [x for x in itertools.accumulate(range(len(F)), lambda a, i: a + F[~i] - target, initial=newFlowers) if x >= 0]\\n    return max(\\n        ((i := bisect.bisect(L, x, hi=len(flowers) - j)) and min(target - 1, (A[i - 1] + x) // i)) * partial + j * full\\n        for j, x in enumerate(R, len(flowers) - len(F))\\n    )\\n```\n```python\\ndef maximumBeauty(self, flowers, newFlowers, target, full, partial):\\n    res = tot = k = 0\\n    n = len(flowers)\\n    flowers.sort()\\n    while k < n and flowers[k] < target: k, tot = k + 1, tot + flowers[k]\\n    i = j = k - 1\\n    while j >= 0:\\n        if newFlowers < 0: return res\\n        while i > j or i >= 0 and (x := newFlowers + tot) < flowers[i] * (i + 1): i, tot = i - 1, tot - flowers[i]\\n        res = max(res, min(target - 1, x // (i + 1)) * partial + (n - 1 - j) * full)\\n        j, newFlowers = j - 1, newFlowers + flowers[j] - target\\n    return max(res, n * full)\\n```\n```go\\nfunc min(x, y int64) int64 {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\nfunc max(x, y int64) int64 {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc maximumBeauty(flowers []int, newFlowers int64, target int, full int, partial int) int64 {\\n\\tvar (\\n\\t\\tres, tot, k int64\\n\\t\\tn           = int64(len(flowers))\\n\\t)\\n\\tsort.Ints(flowers)\\n\\tfor ; k < n && flowers[k] < target; k, tot = k+1, tot+int64(flowers[k]) {\\n\\t}\\n\\tfor i, j := k-1, k-1; j >= 0; j, newFlowers = j-1, newFlowers+int64(flowers[j]-target) {\\n\\t\\tif newFlowers < 0 {\\n\\t\\t\\treturn res\\n\\t\\t}\\n\\t\\tfor ; i > j || i >= 0 && tot+newFlowers < int64(flowers[i])*(i+1); i, tot = i-1, tot-int64(flowers[i]) {\\n\\t\\t}\\n\\t\\tres = max(res, min(int64(target-1), (tot+newFlowers)/(i+1))*int64(partial)+(n-1-j)*int64(full))\\n\\t}\\n\\treturn max(res, n*int64(full))\\n}\\n```\n```c++\\nlong long maximumBeauty(vector<int> &A, long long y, int c, int b, int a) {\\n    long long res = 0, x = 0, k = 0, n = A.size();\\n    sort(A.begin(), A.end());\\n    for (; k < n && A[k] < c; x += A[k++]);\\n    for (long long i = k, j = k; j > 0 && y >= 0; y -= c - A[--j]) {\\n        for (; i > j || i > 0 && x + y < A[i - 1] * i; x -= A[--i]);\\n        res = max(res, min((x + y) / i, (long long)c - 1) * a + (n - j) * b);\\n    }\\n    return y < 0 ? res : max(res, n * b);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2188914,
                "title": "sorting-nested-binary-search-and-suffix-sum",
                "content": "Sort the flower array in descending order.\\nThen iterate though sorted flower array. In each iteration calculate beauty by trying to make leftmost garden full and maximize the minimum available flowers among rest of the non-full gardens by using remaining flowers to maximize sum for partial gardens. Return max of all beauty values calculated. Maximizing the sum for partially full gardens is the most tricky part and can be optimized by using suffix sum array and 2 nested binary search loops.\\nThis has a complexity of O(n*log(full)*log(n)), where n is size of flowers array and full is the target flowers for full garden.\\n\\n```\\nclass Solution {\\npublic:\\n    int bin_search(vector<int>& flowers, vector<long long>& sum, int stIndx, int endIndx, int low, int up, long long remF) {\\n        int l = low, u = up;\\n        int res = low;\\n        //Binary search within range low to target-1 to find maximum value possible for partial gardens\\n        //This is a nested binary search. Complexity is O(log(up-low)*log(endIndx-stIndx))\\n        while (l <= u) {\\n            int mid = l + (u - l) / 2;\\n            int lf = stIndx, uf = endIndx, hIndx = uf;\\n            \\n            //Binary search using suffix array to find index of the partial garden which has maximum available flowers <= mid.\\n            //This index can be used to calculate number of flowers required to make all gardens with < mid flowers equal to mid flowers and\\n            // then check if it can be satisfied by remaining flowers.\\n            while (lf <= uf) {\\n                int m = lf + (uf - lf) / 2;\\n                if (mid <= flowers[m]) {\\n                    lf = m + 1;\\n                }\\n                else {\\n                    uf = m - 1;\\n                    hIndx = m;\\n                }\\n            }\\n            long long s = (long long)mid * (endIndx - hIndx + 1) - sum[hIndx];\\n            // If remaining flowers can satisfy this then use try increasing partial count and check else try reducing partial count.\\n            if (remF >= s) {\\n                res = mid;\\n                l = mid + 1;\\n            }\\n            else {\\n                u = mid - 1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        //Sort flowers array in decending order of count\\n        sort(flowers.begin(), flowers.end(), greater<int>());\\n        int len = flowers.size();\\n        vector<long long> suffix_sum(len, 0);\\n        suffix_sum[len - 1] = flowers[len - 1];\\n        int i = 0;\\n        \\n        //Calculate suffix sum array where suffix_sum[i] denotes sum of flowers from index len-1 to i\\n        for (i = len - 2; i >= 0; i--) {\\n            suffix_sum[i] = flowers[i] + suffix_sum[i + 1];\\n        }\\n        int nComplete = 0, nPartial = 0;\\n        long long remF = newFlowers;\\n        \\n        //Calculate number of gardens with >= target count flowers. These will always be multiplied with full since flowers cannot be removed\\n        i = 0;\\n        while (i < flowers.size() && flowers[i] >= target) {\\n            i++;\\n        }\\n        nComplete = i;\\n        \\n        //If all gardens have >= target flowers then return nComplete*full as max beauty\\n        if (nComplete == len) {\\n            return ((long long)nComplete * full);\\n        }\\n\\n        // Iterate though all non-full gardens. In each iteration calculate beauty by trying to make leftmost garden full and maximize the\\n        // minimum available flowers among rest of the non-full gardens by using remaining flowers to maximize sum for partial gardens.\\n        // Return max of all beauty values calculated\\n        // This has a complexity of O(n*log(full)*log(n)), where n is size of flowers array\\n        long long max = nComplete * full + flowers[len - 1] * partial;\\n        for (i = nComplete; i < len; i++) {\\n            // maxPVal = maximize the minimum number of flowers for non-full gardens possible by distributing remaining flowers\\n            // This has complexity of O(log(full)*log(flowers.size()))\\n            int maxPVal = bin_search(flowers, suffix_sum, i, len - 1, flowers[len - 1], target - 1, remF);\\n            long long beauty = (long long)nComplete * full + (long long)maxPVal * partial;\\n            if (beauty > max) {\\n                max = beauty;\\n            }\\n            remF -= (target - flowers[i]);\\n            if (remF < 0) {\\n                break;\\n            }\\n            nComplete++;\\n            if (remF == 0 || i == len-1) {\\n                if (max < (long long)nComplete * full) {\\n                    max = (long long)nComplete * full;\\n                    break;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bin_search(vector<int>& flowers, vector<long long>& sum, int stIndx, int endIndx, int low, int up, long long remF) {\\n        int l = low, u = up;\\n        int res = low;\\n        //Binary search within range low to target-1 to find maximum value possible for partial gardens\\n        //This is a nested binary search. Complexity is O(log(up-low)*log(endIndx-stIndx))\\n        while (l <= u) {\\n            int mid = l + (u - l) / 2;\\n            int lf = stIndx, uf = endIndx, hIndx = uf;\\n            \\n            //Binary search using suffix array to find index of the partial garden which has maximum available flowers <= mid.\\n            //This index can be used to calculate number of flowers required to make all gardens with < mid flowers equal to mid flowers and\\n            // then check if it can be satisfied by remaining flowers.\\n            while (lf <= uf) {\\n                int m = lf + (uf - lf) / 2;\\n                if (mid <= flowers[m]) {\\n                    lf = m + 1;\\n                }\\n                else {\\n                    uf = m - 1;\\n                    hIndx = m;\\n                }\\n            }\\n            long long s = (long long)mid * (endIndx - hIndx + 1) - sum[hIndx];\\n            // If remaining flowers can satisfy this then use try increasing partial count and check else try reducing partial count.\\n            if (remF >= s) {\\n                res = mid;\\n                l = mid + 1;\\n            }\\n            else {\\n                u = mid - 1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        //Sort flowers array in decending order of count\\n        sort(flowers.begin(), flowers.end(), greater<int>());\\n        int len = flowers.size();\\n        vector<long long> suffix_sum(len, 0);\\n        suffix_sum[len - 1] = flowers[len - 1];\\n        int i = 0;\\n        \\n        //Calculate suffix sum array where suffix_sum[i] denotes sum of flowers from index len-1 to i\\n        for (i = len - 2; i >= 0; i--) {\\n            suffix_sum[i] = flowers[i] + suffix_sum[i + 1];\\n        }\\n        int nComplete = 0, nPartial = 0;\\n        long long remF = newFlowers;\\n        \\n        //Calculate number of gardens with >= target count flowers. These will always be multiplied with full since flowers cannot be removed\\n        i = 0;\\n        while (i < flowers.size() && flowers[i] >= target) {\\n            i++;\\n        }\\n        nComplete = i;\\n        \\n        //If all gardens have >= target flowers then return nComplete*full as max beauty\\n        if (nComplete == len) {\\n            return ((long long)nComplete * full);\\n        }\\n\\n        // Iterate though all non-full gardens. In each iteration calculate beauty by trying to make leftmost garden full and maximize the\\n        // minimum available flowers among rest of the non-full gardens by using remaining flowers to maximize sum for partial gardens.\\n        // Return max of all beauty values calculated\\n        // This has a complexity of O(n*log(full)*log(n)), where n is size of flowers array\\n        long long max = nComplete * full + flowers[len - 1] * partial;\\n        for (i = nComplete; i < len; i++) {\\n            // maxPVal = maximize the minimum number of flowers for non-full gardens possible by distributing remaining flowers\\n            // This has complexity of O(log(full)*log(flowers.size()))\\n            int maxPVal = bin_search(flowers, suffix_sum, i, len - 1, flowers[len - 1], target - 1, remF);\\n            long long beauty = (long long)nComplete * full + (long long)maxPVal * partial;\\n            if (beauty > max) {\\n                max = beauty;\\n            }\\n            remF -= (target - flowers[i]);\\n            if (remF < 0) {\\n                break;\\n            }\\n            nComplete++;\\n            if (remF == 0 || i == len-1) {\\n                if (max < (long long)nComplete * full) {\\n                    max = (long long)nComplete * full;\\n                    break;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165541,
                "title": "cpp-binary-search-prefix-sum",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    bool chk(vector<ll>&a,ll j,ll sum,ll trgt,vector<ll>&pfx)\\n    {\\n        ll idx=lower_bound(a.begin(),a.begin()+j+1,trgt)-a.begin();\\n        if(idx==0)return true;\\n        ll tmp=idx*trgt-pfx[idx-1];\\n        if(tmp<=sum)return true;\\n        return false;\\n    }\\n    ll find(vector<ll>&a,ll j,ll sum,ll trgt,vector<ll>&pfx)\\n    {\\n        if(j==-1)return 0;\\n        ll l=1,h=trgt-1,ans=0;\\n        while(l<=h)\\n        {\\n            ll mid=(l+h)/2;\\n            if(chk(a,j,sum,mid,pfx)==true)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                h=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        ll cnt=0;\\n        vector<ll>nms;\\n        for(int i=0;i<flowers.size();i++)\\n        {\\n            if(flowers[i]>=target)cnt++;\\n            else nms.push_back(flowers[i]);\\n        }\\n        ll ans=cnt*full;\\n        ll n=nms.size();\\n        if(n==0)return ans;\\n        sort(nms.begin(),nms.end());\\n        vector<ll>pfx(n,0);pfx[0]=nms[0];\\n        for(int i=1;i<n;i++)pfx[i]=nms[i]+pfx[i-1];\\n        ans+=nms[0]*partial;\\n        ll sum=0;\\n        for(int k=0;k<=n;k++)\\n        {\\n            if(k!=0)sum+=target-nms[n-k];\\n            if(newFlowers<sum)break;\\n            ll tmp=find(nms,n-1-k,newFlowers-sum,target,pfx);\\n            ans=max(ans,(cnt+k)*full+tmp*partial);\\n        }\\n        return ans;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    bool chk(vector<ll>&a,ll j,ll sum,ll trgt,vector<ll>&pfx)\\n    {\\n        ll idx=lower_bound(a.begin(),a.begin()+j+1,trgt)-a.begin();\\n        if(idx==0)return true;\\n        ll tmp=idx*trgt-pfx[idx-1];\\n        if(tmp<=sum)return true;\\n        return false;\\n    }\\n    ll find(vector<ll>&a,ll j,ll sum,ll trgt,vector<ll>&pfx)\\n    {\\n        if(j==-1)return 0;\\n        ll l=1,h=trgt-1,ans=0;\\n        while(l<=h)\\n        {\\n            ll mid=(l+h)/2;\\n            if(chk(a,j,sum,mid,pfx)==true)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                h=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        ll cnt=0;\\n        vector<ll>nms;\\n        for(int i=0;i<flowers.size();i++)\\n        {\\n            if(flowers[i]>=target)cnt++;\\n            else nms.push_back(flowers[i]);\\n        }\\n        ll ans=cnt*full;\\n        ll n=nms.size();\\n        if(n==0)return ans;\\n        sort(nms.begin(),nms.end());\\n        vector<ll>pfx(n,0);pfx[0]=nms[0];\\n        for(int i=1;i<n;i++)pfx[i]=nms[i]+pfx[i-1];\\n        ans+=nms[0]*partial;\\n        ll sum=0;\\n        for(int k=0;k<=n;k++)\\n        {\\n            if(k!=0)sum+=target-nms[n-k];\\n            if(newFlowers<sum)break;\\n            ll tmp=find(nms,n-1-k,newFlowers-sum,target,pfx);\\n            ans=max(ans,(cnt+k)*full+tmp*partial);\\n        }\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2160324,
                "title": "c",
                "content": "```\\n\\t#define ll long long\\npublic:\\n    long long maximumBeauty(vector<int>& f, long long newF, int t, int fl, int pl) {\\n        sort(f.begin(),f.end());\\n        int n = f.size();\\n        if(f[0]>=t)\\n            return (ll)fl*n;\\n        \\n        int rightpos = lower_bound(f.begin(),f.end(),t)-f.begin()-1;\\n        \\n        ll sum=0;\\n        for(int i = 0;i<=rightpos;i++) sum+=f[i];\\n        if(newF>=(ll)t*(rightpos+1)-sum)\\n            return (ll)(n-1)*fl + max((ll)fl,(ll)pl*(t-1));\\n        \\n        vector<ll>cost(rightpos+1);\\n        for(int i =1 ;i<=rightpos;i++)\\n            cost[i] = cost[i-1] + (ll)i*(f[i]-f[i-1]);\\n        \\n        ll ans = 0;\\n        while(newF>=0){\\n            int pos = min(rightpos,int(upper_bound(cost.begin(),cost.end(),newF)-cost.begin()-1));\\n            int minInc = f[pos] + (newF - cost[pos])/(pos+1);\\n            ans=max(ans,(ll)minInc*pl + (ll)fl * (n-rightpos-1));\\n            newF -= (t-f[rightpos]);\\n            rightpos--;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\t#define ll long long\\npublic:\\n    long long maximumBeauty(vector<int>& f, long long newF, int t, int fl, int pl) {\\n        sort(f.begin(),f.end());\\n        int n = f.size();\\n        if(f[0]>=t)\\n            return (ll)fl*n;\\n        \\n        int rightpos = lower_bound(f.begin(),f.end(),t)-f.begin()-1;\\n        \\n        ll sum=0;\\n        for(int i = 0;i<=rightpos;i++) sum+=f[i];\\n        if(newF>=(ll)t*(rightpos+1)-sum)\\n            return (ll)(n-1)*fl + max((ll)fl,(ll)pl*(t-1));\\n        \\n        vector<ll>cost(rightpos+1);\\n        for(int i =1 ;i<=rightpos;i++)\\n            cost[i] = cost[i-1] + (ll)i*(f[i]-f[i-1]);\\n        \\n        ll ans = 0;\\n        while(newF>=0){\\n            int pos = min(rightpos,int(upper_bound(cost.begin(),cost.end(),newF)-cost.begin()-1));\\n            int minInc = f[pos] + (newF - cost[pos])/(pos+1);\\n            ans=max(ans,(ll)minInc*pl + (ll)fl * (n-rightpos-1));\\n            newF -= (t-f[rightpos]);\\n            rightpos--;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2137453,
                "title": "c-sort-enumerate-greedy",
                "content": "```\\ntypedef long long LL;\\n\\nclass Solution {\\npublic:\\n    LL maximumBeauty(vector<int>& fs, LL nfs, int tar, int fu, int par) {\\n        \\n        LL ans = 0;\\n        LL cplt = 0;\\n        sort(fs.begin(), fs.end());\\n        while (fs.size())\\n        {\\n            if (fs.back() < tar) break;\\n            LL t = fs.back(); fs.pop_back();\\n            cplt ++ ;\\n        }\\n        \\n        int n = fs.size();\\n        \\n        vector<LL> psum, psum2;\\n        for (int i = n - 1; i >= 0; -- i)\\n            psum.push_back(tar - fs[i]);\\n        for (int i = 1; i < n; ++ i) psum[i] += psum[i - 1];\\n        \\n        psum2.push_back(0);\\n        for (int i = 1; i < n; ++ i)\\n            psum2.push_back(psum2.back() + (fs[i] - fs[i - 1]) * i);\\n        \\n        LL nfs_cp = nfs, cplt_cp = cplt;\\n        LL cum = 0;\\n        for (int i = 0; i <= n; ++ i)\\n        {\\n            LL res = 0;\\n            \\n            if (i > 0)\\n            {\\n                if (psum[i - 1] > nfs) break;\\n                nfs -= psum[i - 1];\\n                cplt += i;\\n            }\\n            if (i < n)\\n            {\\n                auto it = upper_bound(psum2.begin(), psum2.begin() + n - i, nfs);\\n                LL cnt = it - psum2.begin();\\n                if (it != psum2.begin())\\n                {\\n                    nfs -= *prev(it);    \\n                    LL idx = prev(it) - psum2.begin();\\n                    if (fs[idx] + nfs / cnt >= tar)\\n                        res += ((LL)tar - 1) * par;\\n                    else\\n                        res += ((LL)fs[idx] + nfs / cnt) * par;\\n                }                \\n            }\\n\\n            res += cplt * fu;\\n            ans = max(ans, res);\\n            nfs = nfs_cp, cplt = cplt_cp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long LL;\\n\\nclass Solution {\\npublic:\\n    LL maximumBeauty(vector<int>& fs, LL nfs, int tar, int fu, int par) {\\n        \\n        LL ans = 0;\\n        LL cplt = 0;\\n        sort(fs.begin(), fs.end());\\n        while (fs.size())\\n        {\\n            if (fs.back() < tar) break;\\n            LL t = fs.back(); fs.pop_back();\\n            cplt ++ ;\\n        }\\n        \\n        int n = fs.size();\\n        \\n        vector<LL> psum, psum2;\\n        for (int i = n - 1; i >= 0; -- i)\\n            psum.push_back(tar - fs[i]);\\n        for (int i = 1; i < n; ++ i) psum[i] += psum[i - 1];\\n        \\n        psum2.push_back(0);\\n        for (int i = 1; i < n; ++ i)\\n            psum2.push_back(psum2.back() + (fs[i] - fs[i - 1]) * i);\\n        \\n        LL nfs_cp = nfs, cplt_cp = cplt;\\n        LL cum = 0;\\n        for (int i = 0; i <= n; ++ i)\\n        {\\n            LL res = 0;\\n            \\n            if (i > 0)\\n            {\\n                if (psum[i - 1] > nfs) break;\\n                nfs -= psum[i - 1];\\n                cplt += i;\\n            }\\n            if (i < n)\\n            {\\n                auto it = upper_bound(psum2.begin(), psum2.begin() + n - i, nfs);\\n                LL cnt = it - psum2.begin();\\n                if (it != psum2.begin())\\n                {\\n                    nfs -= *prev(it);    \\n                    LL idx = prev(it) - psum2.begin();\\n                    if (fs[idx] + nfs / cnt >= tar)\\n                        res += ((LL)tar - 1) * par;\\n                    else\\n                        res += ((LL)fs[idx] + nfs / cnt) * par;\\n                }                \\n            }\\n\\n            res += cplt * fu;\\n            ans = max(ans, res);\\n            nfs = nfs_cp, cplt = cplt_cp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088661,
                "title": "short-binary-search-nlogn-solution",
                "content": "```python\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers.sort()\\n        n = len(flowers)\\n        if flowers[0] >= target : return n * full\\n        res = c = 0\\n        a = []\\n        for i,j in enumerate(flowers):\\n            j = min(j,target)\\n            c += j\\n            a.append(j  * (i+1) - c)\\n        import bisect\\n        for i in range(n-1,-1,-1):\\n            idx = bisect.bisect(a,newFlowers+1,0,i+1)-1\\n            k = min(flowers[idx] + (newFlowers-a[idx]) // (idx+1), target - 1)\\n            res = max(res, k * partial + (n-i-1) * full)\\n            newFlowers -= max(0, target-flowers[i])\\n            if newFlowers < 0: break\\n            res = max(res, (n-i) * full)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers.sort()\\n        n = len(flowers)\\n        if flowers[0] >= target : return n * full\\n        res = c = 0\\n        a = []\\n        for i,j in enumerate(flowers):\\n            j = min(j,target)\\n            c += j\\n            a.append(j  * (i+1) - c)\\n        import bisect\\n        for i in range(n-1,-1,-1):\\n            idx = bisect.bisect(a,newFlowers+1,0,i+1)-1\\n            k = min(flowers[idx] + (newFlowers-a[idx]) // (idx+1), target - 1)\\n            res = max(res, k * partial + (n-i-1) * full)\\n            newFlowers -= max(0, target-flowers[i])\\n            if newFlowers < 0: break\\n            res = max(res, (n-i) * full)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2051410,
                "title": "c-solution",
                "content": "```\\nint comp (const void* a, const void* b){\\n    return *(int*)a - *(int*)b;\\n}\\n    \\nlong long maximumBeauty(int* flowers, int flowersSize, long long newFlowers, int target, int full, int partial){\\n    if (flowersSize == 1){\\n        if (flowers[0] + newFlowers >= target){\\n            return full > (long long)(target-1)*partial ? full : (long long)(target-1)*partial;\\n        } else {\\n            return (long long)(flowers[0] + newFlowers)*partial;\\n        }\\n    }\\n    qsort(flowers,flowersSize,sizeof(int),comp);\\n    int end = flowersSize-1;\\n    long long now = 0;\\n    while (end >= 0 && flowers[end] >= target){\\n        end--;\\n        now++;\\n    }\\n    if (end < 0){\\n        return (long long)flowersSize*full;\\n    }\\n    \\n    now *= full;\\n    long long* p_add = malloc(sizeof(long long)*flowersSize);\\n    p_add[0] = flowers[1]-flowers[0];\\n    for (int i = 1 ; i < flowersSize-1 ; i++){\\n        p_add[i] = (i+1)*(flowers[i+1]-flowers[i]);\\n        p_add[i] +=  p_add[i-1];\\n        if (p_add[i] > newFlowers){\\n            break;\\n        }  \\n    }\\n    \\n    int head = 0;\\n    long long copy = newFlowers;\\n    while (head < end && copy >= p_add[head]){\\n        head++;\\n    }\\n    if (head > 0){\\n        copy -= p_add[head-1];\\n    }\\n    \\n    long long min = flowers[head]+copy/(head+1);\\n    if (min >= target){\\n        long long a = (long long)full*flowersSize;\\n        long long b = (long long)full*(flowersSize-1)+(long long)(target-1)*partial;\\n        return a > b ? a : b;\\n    }\\n    long long ans = (min*partial)+now;\\n    \\n    \\n    newFlowers -= target-flowers[end];\\n    if (newFlowers >= 0){\\n        now += full;\\n        while (newFlowers < p_add[head] || head >= (end-1) ){\\n            head--;\\n            if (head < 0){\\n                if (ans < (flowers[0]+newFlowers)*partial + now){\\n                    ans = (flowers[0]+newFlowers)*partial + now;\\n                    }  \\n                return ans;\\n            }\\n        }\\n        copy = newFlowers-p_add[head];\\n        min = flowers[head+1] + copy/(head+2);\\n        copy %= (head+2);\\n        while (end-1 > head+1 && target-flowers[end-1] <= copy) {\\n            copy -= (target-flowers[end-1]);\\n            now += full;\\n            newFlowers -= (target-flowers[end-1]);\\n            end--;\\n        }\\n        while (target-min <= copy) {\\n            copy -= (target-min);\\n            now += full;\\n            newFlowers -= (target-flowers[end-1]);\\n            end--;\\n        }\\n        if (ans < (min*partial)+now){\\n            ans = (min*partial)+now;\\n        }\\n    }   \\n    end--;\\n    \\n    while (1){\\n        newFlowers -= target-flowers[end];\\n        if (newFlowers >= 0){\\n            now += full;\\n            while (head >= (end-1) || newFlowers < p_add[head]){\\n                head--;\\n            }\\n            min = flowers[head+1] + (newFlowers-p_add[head])/(head+2);\\n            if (ans < (min*partial)+now){\\n                ans = (min*partial)+now;\\n            }\\n            end--;\\n        } else {\\n            break;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint comp (const void* a, const void* b){\\n    return *(int*)a - *(int*)b;\\n}\\n    \\nlong long maximumBeauty(int* flowers, int flowersSize, long long newFlowers, int target, int full, int partial){\\n    if (flowersSize == 1){\\n        if (flowers[0] + newFlowers >= target){\\n            return full > (long long)(target-1)*partial ? full : (long long)(target-1)*partial;\\n        } else {\\n            return (long long)(flowers[0] + newFlowers)*partial;\\n        }\\n    }\\n    qsort(flowers,flowersSize,sizeof(int),comp);\\n    int end = flowersSize-1;\\n    long long now = 0;\\n    while (end >= 0 && flowers[end] >= target){\\n        end--;\\n        now++;\\n    }\\n    if (end < 0){\\n        return (long long)flowersSize*full;\\n    }\\n    \\n    now *= full;\\n    long long* p_add = malloc(sizeof(long long)*flowersSize);\\n    p_add[0] = flowers[1]-flowers[0];\\n    for (int i = 1 ; i < flowersSize-1 ; i++){\\n        p_add[i] = (i+1)*(flowers[i+1]-flowers[i]);\\n        p_add[i] +=  p_add[i-1];\\n        if (p_add[i] > newFlowers){\\n            break;\\n        }  \\n    }\\n    \\n    int head = 0;\\n    long long copy = newFlowers;\\n    while (head < end && copy >= p_add[head]){\\n        head++;\\n    }\\n    if (head > 0){\\n        copy -= p_add[head-1];\\n    }\\n    \\n    long long min = flowers[head]+copy/(head+1);\\n    if (min >= target){\\n        long long a = (long long)full*flowersSize;\\n        long long b = (long long)full*(flowersSize-1)+(long long)(target-1)*partial;\\n        return a > b ? a : b;\\n    }\\n    long long ans = (min*partial)+now;\\n    \\n    \\n    newFlowers -= target-flowers[end];\\n    if (newFlowers >= 0){\\n        now += full;\\n        while (newFlowers < p_add[head] || head >= (end-1) ){\\n            head--;\\n            if (head < 0){\\n                if (ans < (flowers[0]+newFlowers)*partial + now){\\n                    ans = (flowers[0]+newFlowers)*partial + now;\\n                    }  \\n                return ans;\\n            }\\n        }\\n        copy = newFlowers-p_add[head];\\n        min = flowers[head+1] + copy/(head+2);\\n        copy %= (head+2);\\n        while (end-1 > head+1 && target-flowers[end-1] <= copy) {\\n            copy -= (target-flowers[end-1]);\\n            now += full;\\n            newFlowers -= (target-flowers[end-1]);\\n            end--;\\n        }\\n        while (target-min <= copy) {\\n            copy -= (target-min);\\n            now += full;\\n            newFlowers -= (target-flowers[end-1]);\\n            end--;\\n        }\\n        if (ans < (min*partial)+now){\\n            ans = (min*partial)+now;\\n        }\\n    }   \\n    end--;\\n    \\n    while (1){\\n        newFlowers -= target-flowers[end];\\n        if (newFlowers >= 0){\\n            now += full;\\n            while (head >= (end-1) || newFlowers < p_add[head]){\\n                head--;\\n            }\\n            min = flowers[head+1] + (newFlowers-p_add[head])/(head+2);\\n            if (ans < (min*partial)+now){\\n                ans = (min*partial)+now;\\n            }\\n            end--;\\n        } else {\\n            break;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2045810,
                "title": "javascript-time-o-n-excluding-sorting-space-o-1",
                "content": "```\\nvar maximumBeauty = function(flowers, newFlowers, target, full, partial) {\\n    flowers.sort((b, a) => a - b);\\n\\n    let p1 = 0, ans = 0;\\n\\n    while (target - flowers[p1] <= newFlowers)\\n        newFlowers -= Math.max(0, target - flowers[p1++]);\\n\\n    if (p1 == flowers.length)\\n        return (p1 - 1) * full + Math.max(full, flowers.at(-1) < target ? (target - 1) * partial : 0);\\n\\n    for (let p2 = flowers.length - 1, suffixSum = flowers[p2]; p1 >= 0 && target > flowers[p1]; ) {\\n        while (p1 < p2 && (flowers[p2 - 1] == flowers[p2] || suffixSum + newFlowers > (flowers.length - p2) * flowers[p2 - 1])) {\\n            suffixSum += flowers[--p2];\\n        }\\n\\n        const incompleteFlowersSpan = flowers.length - p2;\\n        const leftWall = p2 == p1 ? target : flowers[p2 - 1];\\n        const minIncompleteFlowers = leftWall -\\n\\t\\t\\tMath.ceil((incompleteFlowersSpan * leftWall - (suffixSum + newFlowers)) / incompleteFlowersSpan);\\n\\n        ans = Math.max(ans, p1 * full + minIncompleteFlowers * partial);\\n        newFlowers += target - flowers[--p1];\\n    }\\n\\n    return ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maximumBeauty = function(flowers, newFlowers, target, full, partial) {\\n    flowers.sort((b, a) => a - b);\\n\\n    let p1 = 0, ans = 0;\\n\\n    while (target - flowers[p1] <= newFlowers)\\n        newFlowers -= Math.max(0, target - flowers[p1++]);\\n\\n    if (p1 == flowers.length)\\n        return (p1 - 1) * full + Math.max(full, flowers.at(-1) < target ? (target - 1) * partial : 0);\\n\\n    for (let p2 = flowers.length - 1, suffixSum = flowers[p2]; p1 >= 0 && target > flowers[p1]; ) {\\n        while (p1 < p2 && (flowers[p2 - 1] == flowers[p2] || suffixSum + newFlowers > (flowers.length - p2) * flowers[p2 - 1])) {\\n            suffixSum += flowers[--p2];\\n        }\\n\\n        const incompleteFlowersSpan = flowers.length - p2;\\n        const leftWall = p2 == p1 ? target : flowers[p2 - 1];\\n        const minIncompleteFlowers = leftWall -\\n\\t\\t\\tMath.ceil((incompleteFlowersSpan * leftWall - (suffixSum + newFlowers)) / incompleteFlowersSpan);\\n\\n        ans = Math.max(ans, p1 * full + minIncompleteFlowers * partial);\\n        newFlowers += target - flowers[--p1];\\n    }\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1970184,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        int n  = flowers.size();\\n        sort(flowers.begin(), flowers.end(), greater<int>());\\n        vector<long long> prefix(n, LONG_LONG_MAX);\\n        prefix[n-1] = 0;\\n        for(int i = n-2; i >= 0; i--)\\n        {\\n            if(flowers[i] < target)\\n                    prefix[i] = (flowers[i] - flowers[i+1])*(n-i-1) + prefix[i+1];\\n            else\\n            {\\n                prefix[i] = (target-1 - flowers[i+1])*(n-i-1) + prefix[i+1];\\n                break;\\n            }\\n        }\\n        int start = 0;\\n        while(start < n && flowers[start] >= target)\\n            start++;\\n        long long comp = start;\\n        long long ans = (long long)start*full;\\n        for(int i = start; i < n; i++)\\n        {\\n            int index = lower_bound(prefix.begin()+i, prefix.end(), newFlowers, greater<long long>()) - prefix.begin();\\n            long long rem = newFlowers - prefix[index];\\n            long long min_value = min(flowers[index] + rem/(n-index), (long long)target-1);\\n            ans = max(ans, min_value*partial + comp*full);\\n            if(newFlowers - target+flowers[i] >= 0)\\n            {\\n                newFlowers= newFlowers-(target-flowers[i]);\\n                comp++;\\n            }\\n            else\\n                break;\\n            if(newFlowers <= 0)\\n                break;\\n        }\\n        if(newFlowers >= target - flowers[n-1])\\n            ans = max((long long)n*full, ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        int n  = flowers.size();\\n        sort(flowers.begin(), flowers.end(), greater<int>());\\n        vector<long long> prefix(n, LONG_LONG_MAX);\\n        prefix[n-1] = 0;\\n        for(int i = n-2; i >= 0; i--)\\n        {\\n            if(flowers[i] < target)\\n                    prefix[i] = (flowers[i] - flowers[i+1])*(n-i-1) + prefix[i+1];\\n            else\\n            {\\n                prefix[i] = (target-1 - flowers[i+1])*(n-i-1) + prefix[i+1];\\n                break;\\n            }\\n        }\\n        int start = 0;\\n        while(start < n && flowers[start] >= target)\\n            start++;\\n        long long comp = start;\\n        long long ans = (long long)start*full;\\n        for(int i = start; i < n; i++)\\n        {\\n            int index = lower_bound(prefix.begin()+i, prefix.end(), newFlowers, greater<long long>()) - prefix.begin();\\n            long long rem = newFlowers - prefix[index];\\n            long long min_value = min(flowers[index] + rem/(n-index), (long long)target-1);\\n            ans = max(ans, min_value*partial + comp*full);\\n            if(newFlowers - target+flowers[i] >= 0)\\n            {\\n                newFlowers= newFlowers-(target-flowers[i]);\\n                comp++;\\n            }\\n            else\\n                break;\\n            if(newFlowers <= 0)\\n                break;\\n        }\\n        if(newFlowers >= target - flowers[n-1])\\n            ans = max((long long)n*full, ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967596,
                "title": "problem-with-a-test-case-solved",
                "content": "Perhaps I don\\'t understand this question.  If `full > partial`, and you have at least enough `numFlowers` to complete out all your gardens, isn\\'t the solution just `# gardens * full`?\\n\\nflowers = [19,17,6,9,19]\\nnumFlowers = 24\\ntarget = 10\\nfull = 17\\npartial = 4\\n\\nIn this example, there are `5` gardens, with `full = 17`, so there\\'s no way I can have a more beautiful garden than `5 * 17 = 85`, right?  This test fails for me saying it\\'s possible to have beauty = 104, but I don\\'t see how that amount of beauty is possible.",
                "solutionTags": [],
                "code": "Perhaps I don\\'t understand this question.  If `full > partial`, and you have at least enough `numFlowers` to complete out all your gardens, isn\\'t the solution just `# gardens * full`?\\n\\nflowers = [19,17,6,9,19]\\nnumFlowers = 24\\ntarget = 10\\nfull = 17\\npartial = 4\\n\\nIn this example, there are `5` gardens, with `full = 17`, so there\\'s no way I can have a more beautiful garden than `5 * 17 = 85`, right?  This test fails for me saying it\\'s possible to have beauty = 104, but I don\\'t see how that amount of beauty is possible.",
                "codeTag": "Unknown"
            },
            {
                "id": 1964468,
                "title": "c-binary-search-explanation-beginner-friendly",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        long long ans;\\n        // Will use this vector to store all gardens with flowers less than target\\n        vector<long long int> p;\\n        long long int fullc = 0;\\n        for(int i=0;i<flowers.size();i++){\\n            if(flowers[i] >= target){\\n                fullc += 1;\\n            }else{\\n                p.push_back(flowers[i]);\\n            }\\n        }\\n        // Initalizing ans with base value\\n        ans = fullc * full;\\n        if(p.size() == 0)\\n            return ans;\\n        // Defining and creating prefix array which will be storing the number of flowers required for makeing all lower flowers\\n        // equal to the current number\\n        vector<long long int> pref(p.size(), 0);\\n        for(int i=1;i<p.size();i++){\\n            pref[i] = (p[i] - p[i-1]) * i + pref[i-1];\\n        }\\n        long long int val = 0;\\n        // Considering all partial and finding best possible ans\\n        long long int index = upper_bound(pref.begin(), pref.end(), newFlowers) - pref.begin();\\n        index -= 1;\\n\\n        long long int count = (newFlowers - pref[index]) / (index + 1);\\n        if(count + p[index] >= target){\\n            val = 1ll * partial * (target - 1);\\n        }else{\\n            val = (p[index] + count) * partial;\\n        }\\n        // Updating ans for base case\\n        ans = max(ans, val + ans);\\n        \\n        long long int i = p.size() - 1;\\n        \\n        // Iterating and adding garden to full group and calculating ans\\n        while(i >= 0){\\n            long long int currVal = 0;\\n            // Flowers required for current garden to reach target\\n            long long int toFull = target - p[i];\\n            \\n            // If enough flowers are not there then break the loop and exit (ans is already received)\\n            if(toFull >= newFlowers)\\n                break;\\n            fullc += 1;\\n            newFlowers -= toFull;\\n            // When all flowers are full\\n            if(i == 0){\\n                // updating ans if all garden are part of full group \\n                ans = max(ans, fullc * full);\\n                break;\\n            }\\n            // Binary search to find the best possible number closest to the remaining flowers\\n            // So that we can calculate the max beauty of the partial garden \\n            index = upper_bound(pref.begin(), pref.begin() + i, newFlowers) - pref.begin();\\n            index -= 1;\\n            \\n            // Calculating partila beauty for the current iteration\\n            long long int count = (newFlowers - pref[index]) / (index + 1);\\n            if(count + p[index] >= target){\\n                currVal = 1ll * partial * (target - 1);\\n            }else{\\n                currVal = 1ll * (p[index] + count) * partial;\\n            }\\n            \\n            // keep updating ans\\n            ans = max(ans, fullc * full + currVal);\\n            i-=1;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        long long ans;\\n        // Will use this vector to store all gardens with flowers less than target\\n        vector<long long int> p;\\n        long long int fullc = 0;\\n        for(int i=0;i<flowers.size();i++){\\n            if(flowers[i] >= target){\\n                fullc += 1;\\n            }else{\\n                p.push_back(flowers[i]);\\n            }\\n        }\\n        // Initalizing ans with base value\\n        ans = fullc * full;\\n        if(p.size() == 0)\\n            return ans;\\n        // Defining and creating prefix array which will be storing the number of flowers required for makeing all lower flowers\\n        // equal to the current number\\n        vector<long long int> pref(p.size(), 0);\\n        for(int i=1;i<p.size();i++){\\n            pref[i] = (p[i] - p[i-1]) * i + pref[i-1];\\n        }\\n        long long int val = 0;\\n        // Considering all partial and finding best possible ans\\n        long long int index = upper_bound(pref.begin(), pref.end(), newFlowers) - pref.begin();\\n        index -= 1;\\n\\n        long long int count = (newFlowers - pref[index]) / (index + 1);\\n        if(count + p[index] >= target){\\n            val = 1ll * partial * (target - 1);\\n        }else{\\n            val = (p[index] + count) * partial;\\n        }\\n        // Updating ans for base case\\n        ans = max(ans, val + ans);\\n        \\n        long long int i = p.size() - 1;\\n        \\n        // Iterating and adding garden to full group and calculating ans\\n        while(i >= 0){\\n            long long int currVal = 0;\\n            // Flowers required for current garden to reach target\\n            long long int toFull = target - p[i];\\n            \\n            // If enough flowers are not there then break the loop and exit (ans is already received)\\n            if(toFull >= newFlowers)\\n                break;\\n            fullc += 1;\\n            newFlowers -= toFull;\\n            // When all flowers are full\\n            if(i == 0){\\n                // updating ans if all garden are part of full group \\n                ans = max(ans, fullc * full);\\n                break;\\n            }\\n            // Binary search to find the best possible number closest to the remaining flowers\\n            // So that we can calculate the max beauty of the partial garden \\n            index = upper_bound(pref.begin(), pref.begin() + i, newFlowers) - pref.begin();\\n            index -= 1;\\n            \\n            // Calculating partila beauty for the current iteration\\n            long long int count = (newFlowers - pref[index]) / (index + 1);\\n            if(count + p[index] >= target){\\n                currVal = 1ll * partial * (target - 1);\\n            }else{\\n                currVal = 1ll * (p[index] + count) * partial;\\n            }\\n            \\n            // keep updating ans\\n            ans = max(ans, fullc * full + currVal);\\n            i-=1;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954929,
                "title": "moving-window-prefix-sum-binary-search-o-n-log-n",
                "content": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers.sort()\\n        F = flowers[:]\\n        n = len(flowers)\\n        ans = 0\\n        \\n        nf = newFlowers\\n        r = n - 1\\n        while r >= 0:\\n            if F[r] >= target:\\n                r -= 1\\n                continue\\n            diff = target - F[r]\\n            # print(f\"r {r}, diff {diff}, nf {nf}\")\\n            if nf < diff:\\n                break\\n            nf -= diff\\n            r -= 1\\n        # print(f\"r {r}, nf {nf}\")\\n        if r == -1:\\n            ans = n * full\\n            if F[0] < target:\\n                curr = (target-1) * partial + (n-1) * full\\n                ans = max(ans, curr)\\n            return ans\\n\\n        P = [0]  # Prefix sum, count needed to fill to current amount.\\n        pre = F[0]\\n        for i in range(1, n):\\n            if F[i] >= target:\\n                P.append(float(\"inf\"))\\n                break\\n            diff = F[i] - pre\\n            if diff == 0:\\n                P.append(P[-1])\\n                continue\\n            P.append(P[-1] + diff * (i))\\n            pre = F[i]\\n            \\n        # print(\"p sum\", P)\\n        ans = (n-1-r) * full\\n        max_partial = self.fill(F, nf, P, r+1)\\n        ans += max_partial * partial\\n        \\n        for i in range(r+1, n):\\n            if F[i] >= target:\\n                break\\n            diff = target - F[i]\\n            nf += diff\\n            max_partial = self.fill(F, nf, P, i+1)\\n            curr = (n-1-i) * full + max_partial * partial\\n            ans = max(ans, curr)\\n        \\n        return ans\\n    \\n    def fill(self, F, nf, P, r):\\n        n = len(F)\\n        i = bisect.bisect_right(P, nf, 0, r)\\n        # print(f\"i {i}, nf {nf}, P {P}\")\\n        h = F[i-1]\\n        inc = (nf - P[i-1])//i\\n        max_partial = h + inc\\n        # print(f\"h {h}, inc {inc}\")\\n        return max_partial\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers.sort()\\n        F = flowers[:]\\n        n = len(flowers)\\n        ans = 0\\n        \\n        nf = newFlowers\\n        r = n - 1\\n        while r >= 0:\\n            if F[r] >= target:\\n                r -= 1\\n                continue\\n            diff = target - F[r]\\n            # print(f\"r {r}, diff {diff}, nf {nf}\")\\n            if nf < diff:\\n                break\\n            nf -= diff\\n            r -= 1\\n        # print(f\"r {r}, nf {nf}\")\\n        if r == -1:\\n            ans = n * full\\n            if F[0] < target:\\n                curr = (target-1) * partial + (n-1) * full\\n                ans = max(ans, curr)\\n            return ans\\n\\n        P = [0]  # Prefix sum, count needed to fill to current amount.\\n        pre = F[0]\\n        for i in range(1, n):\\n            if F[i] >= target:\\n                P.append(float(\"inf\"))\\n                break\\n            diff = F[i] - pre\\n            if diff == 0:\\n                P.append(P[-1])\\n                continue\\n            P.append(P[-1] + diff * (i))\\n            pre = F[i]\\n            \\n        # print(\"p sum\", P)\\n        ans = (n-1-r) * full\\n        max_partial = self.fill(F, nf, P, r+1)\\n        ans += max_partial * partial\\n        \\n        for i in range(r+1, n):\\n            if F[i] >= target:\\n                break\\n            diff = target - F[i]\\n            nf += diff\\n            max_partial = self.fill(F, nf, P, i+1)\\n            curr = (n-1-i) * full + max_partial * partial\\n            ans = max(ans, curr)\\n        \\n        return ans\\n    \\n    def fill(self, F, nf, P, r):\\n        n = len(F)\\n        i = bisect.bisect_right(P, nf, 0, r)\\n        # print(f\"i {i}, nf {nf}, P {P}\")\\n        h = F[i-1]\\n        inc = (nf - P[i-1])//i\\n        max_partial = h + inc\\n        # print(f\"h {h}, inc {inc}\")\\n        return max_partial\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1948266,
                "title": "python-o-n-inspired-by-bakerston",
                "content": "Inspired by @Bakerston\\'s solution [https://leetcode.com/problems/maximum-total-beauty-of-the-gardens/discuss/1931085/Python-Explanation-with-pictures-Greedy.](http://)\\n\\nUse bucket sort instead of general sort\\nUse one loop search instead of binary search because of monotonicity\\nThe overall time complexity would be reduced to O(N), where n = 10^5\\n```\\ndef sln(self,flowers,newFlowers,target,full,partial):\\n\\tn = len(flowers)\\n\\ttemp = [0]*100001\\n\\tfor x in flowers:\\n\\t\\tif x < target:\\n\\t\\t\\ttemp[x] += 1\\n\\tnums = []\\n\\tfor x in range(100001):\\n\\t\\tfor _ in range(temp[x],0,-1):\\n\\t\\t\\tnums.append(x)\\n\\tif not nums:\\n\\t\\treturn full*n\\n\\tif newFlowers >= target*len(nums) - sum(nums):\\n\\t\\treturn max(full*n,full*(n-1)+partial*(target-1))\\n\\n\\tcost = [0]\\n\\tfor i in range(1,len(nums)):\\n\\t\\tpre = cost[-1]\\n\\t\\tcost.append(pre + i*(nums[i]-nums[i-1]))\\n\\n\\tj = len(nums)-1\\n\\tidx = j\\n\\tres = 0\\n\\twhile newFlowers >= 0:\\n\\t\\twhile cost[idx]>newFlowers:\\n\\t\\t\\tidx -= 1\\n\\t\\tidx = min(j,idx)\\n\\t\\t# current minimum flower in the incomplete gardens\\n\\t\\tbar = nums[idx] + (newFlowers-cost[idx])//(idx+1)\\n\\t\\tres = max(res,bar*partial + (n-j-1)*full)\\n\\t\\tnewFlowers -= (target - nums[j])\\n\\t\\tj -= 1\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python",
                    "Bucket Sort"
                ],
                "code": "```\\ndef sln(self,flowers,newFlowers,target,full,partial):\\n\\tn = len(flowers)\\n\\ttemp = [0]*100001\\n\\tfor x in flowers:\\n\\t\\tif x < target:\\n\\t\\t\\ttemp[x] += 1\\n\\tnums = []\\n\\tfor x in range(100001):\\n\\t\\tfor _ in range(temp[x],0,-1):\\n\\t\\t\\tnums.append(x)\\n\\tif not nums:\\n\\t\\treturn full*n\\n\\tif newFlowers >= target*len(nums) - sum(nums):\\n\\t\\treturn max(full*n,full*(n-1)+partial*(target-1))\\n\\n\\tcost = [0]\\n\\tfor i in range(1,len(nums)):\\n\\t\\tpre = cost[-1]\\n\\t\\tcost.append(pre + i*(nums[i]-nums[i-1]))\\n\\n\\tj = len(nums)-1\\n\\tidx = j\\n\\tres = 0\\n\\twhile newFlowers >= 0:\\n\\t\\twhile cost[idx]>newFlowers:\\n\\t\\t\\tidx -= 1\\n\\t\\tidx = min(j,idx)\\n\\t\\t# current minimum flower in the incomplete gardens\\n\\t\\tbar = nums[idx] + (newFlowers-cost[idx])//(idx+1)\\n\\t\\tres = max(res,bar*partial + (n-j-1)*full)\\n\\t\\tnewFlowers -= (target - nums[j])\\n\\t\\tj -= 1\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1946719,
                "title": "c-binary-search-gready",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) \\n    {\\n        int n=flowers.size();\\n        sort(flowers.begin(),flowers.end());\\n        vector<ll>suffix(n,0),prefix(n,0);\\n        prefix[0]=flowers[0];\\n        for(int i=1;i<n;i++)prefix[i]=prefix[i-1]+flowers[i];\\n        suffix[n-1]=max(0,target-flowers[n-1]);\\n        for(int i=n-2;i>=0;i--)suffix[i]=suffix[i+1]+max(0,target-flowers[i]);\\n        ll ans=0;\\n        if(suffix[0]<=newFlowers)ans=1ll*n*full;\\n        for(int i=0;i<target;i++)\\n        {\\n            auto it=upper_bound(flowers.begin(),flowers.end(),i);\\n            if(it==flowers.begin()&&*it>i)\\n            {\\n                continue;\\n            }else if(it==flowers.end())\\n            {\\n                if(prefix[n-1]>newFlowers)continue;\\n                ll left=newFlowers-(1ll*i*n-prefix[n-1]);\\n                if(left<0)continue;\\n                ll need=target-i;\\n                ll have=min(n-1ll,left/need);\\n                ans=max(ans,1ll*i*partial+1ll*have*full);\\n            }else\\n            {\\n                if(*it>i)it--;\\n                int idx=it-flowers.begin();\\n                ll left=newFlowers-(1ll*i*(idx+1)-prefix[idx]);\\n                if(left<0)continue;\\n                auto it2=upper_bound(suffix.rbegin(),suffix.rend(),left);\\n                if(it2==suffix.rbegin())\\n                {\\n                    ans=max(ans,1ll*i*partial);\\n                }else if(it2==suffix.rend())\\n                {\\n                    ans=max(ans,1ll*(n-1)*full+1ll*partial*i);\\n                }else\\n                {\\n                    if(*it2>left)it2--;\\n                    int idx2=it2-suffix.rbegin();\\n                    idx2=n-1-idx2;\\n                    if(idx2>idx)ans=max(ans,1ll*(n-idx2)*full+1ll*partial*i);\\n                    else\\n                    {\\n                        left-=suffix[idx+1];\\n                        ll need=target-i;\\n                        ll have=min(1ll*idx,1ll*left/need);\\n                        ans=max(ans,1ll*(have+n-idx-1)*full+1ll*partial*i);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Binary Search Tree"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) \\n    {\\n        int n=flowers.size();\\n        sort(flowers.begin(),flowers.end());\\n        vector<ll>suffix(n,0),prefix(n,0);\\n        prefix[0]=flowers[0];\\n        for(int i=1;i<n;i++)prefix[i]=prefix[i-1]+flowers[i];\\n        suffix[n-1]=max(0,target-flowers[n-1]);\\n        for(int i=n-2;i>=0;i--)suffix[i]=suffix[i+1]+max(0,target-flowers[i]);\\n        ll ans=0;\\n        if(suffix[0]<=newFlowers)ans=1ll*n*full;\\n        for(int i=0;i<target;i++)\\n        {\\n            auto it=upper_bound(flowers.begin(),flowers.end(),i);\\n            if(it==flowers.begin()&&*it>i)\\n            {\\n                continue;\\n            }else if(it==flowers.end())\\n            {\\n                if(prefix[n-1]>newFlowers)continue;\\n                ll left=newFlowers-(1ll*i*n-prefix[n-1]);\\n                if(left<0)continue;\\n                ll need=target-i;\\n                ll have=min(n-1ll,left/need);\\n                ans=max(ans,1ll*i*partial+1ll*have*full);\\n            }else\\n            {\\n                if(*it>i)it--;\\n                int idx=it-flowers.begin();\\n                ll left=newFlowers-(1ll*i*(idx+1)-prefix[idx]);\\n                if(left<0)continue;\\n                auto it2=upper_bound(suffix.rbegin(),suffix.rend(),left);\\n                if(it2==suffix.rbegin())\\n                {\\n                    ans=max(ans,1ll*i*partial);\\n                }else if(it2==suffix.rend())\\n                {\\n                    ans=max(ans,1ll*(n-1)*full+1ll*partial*i);\\n                }else\\n                {\\n                    if(*it2>left)it2--;\\n                    int idx2=it2-suffix.rbegin();\\n                    idx2=n-1-idx2;\\n                    if(idx2>idx)ans=max(ans,1ll*(n-idx2)*full+1ll*partial*i);\\n                    else\\n                    {\\n                        left-=suffix[idx+1];\\n                        ll need=target-i;\\n                        ll have=min(1ll*idx,1ll*left/need);\\n                        ans=max(ans,1ll*(have+n-idx-1)*full+1ll*partial*i);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941171,
                "title": "python-nlog-2-n-binary-search-solution",
                "content": "```\\nfrom bisect import bisect\\n\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers.sort()\\n        i = len(flowers) - 1\\n        fulled = 0\\n        while i >= 0 and flowers[i] >= target:\\n            fulled += full\\n            i -= 1\\n        i += 1\\n        flowers = flowers[:i]\\n        if not flowers: return fulled\\n        head = flowers[:]\\n        head.insert(0, 0)\\n        n = len(flowers)\\n        for i in range(n): head[i + 1] += head[i]\\n        ans, used = 0, 0\\n        for i in range(n - 1, -1, -1):\\n            if newFlowers < used: break\\n            lo, hi = flowers[0], target\\n            cur = lo\\n            while lo <= hi:\\n                mid = (lo + hi) // 2\\n                pos = min(i + 1, bisect(flowers, mid))\\n                needed = pos * mid - head[pos]\\n                if needed <= newFlowers - used:\\n                    cur = max(cur, mid)\\n                    lo = mid + 1\\n                else: hi = mid - 1\\n            if cur == target: cmax = max(full * n, full * (n - 1) + (target - 1) * partial)\\n            else: cmax = full * (n - 1 - i) + cur * partial\\n            ans = max(ans, cmax)\\n            used += (target - flowers[i])\\n        if newFlowers >= n * target - head[-1]: ans = max(ans, full * n)\\n        return ans + fulled\\n```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect\\n\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers.sort()\\n        i = len(flowers) - 1\\n        fulled = 0\\n        while i >= 0 and flowers[i] >= target:\\n            fulled += full\\n            i -= 1\\n        i += 1\\n        flowers = flowers[:i]\\n        if not flowers: return fulled\\n        head = flowers[:]\\n        head.insert(0, 0)\\n        n = len(flowers)\\n        for i in range(n): head[i + 1] += head[i]\\n        ans, used = 0, 0\\n        for i in range(n - 1, -1, -1):\\n            if newFlowers < used: break\\n            lo, hi = flowers[0], target\\n            cur = lo\\n            while lo <= hi:\\n                mid = (lo + hi) // 2\\n                pos = min(i + 1, bisect(flowers, mid))\\n                needed = pos * mid - head[pos]\\n                if needed <= newFlowers - used:\\n                    cur = max(cur, mid)\\n                    lo = mid + 1\\n                else: hi = mid - 1\\n            if cur == target: cmax = max(full * n, full * (n - 1) + (target - 1) * partial)\\n            else: cmax = full * (n - 1 - i) + cur * partial\\n            ans = max(ans, cmax)\\n            used += (target - flowers[i])\\n        if newFlowers >= n * target - head[-1]: ans = max(ans, full * n)\\n        return ans + fulled\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938865,
                "title": "python-greedy-binary-search-to-find-minimum-value-of-incomplete-gardens",
                "content": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers = sorted(flowers)[::-1]\\n        n = len(flowers)\\n        \\n        preSum = [0]\\n        for i in range(n-1, -1, -1):\\n            preSum.append(preSum[-1] + flowers[i])\\n        \\n        preSum = preSum[::-1]\\n        \\n        def findMin(left, numAdded):\\n            lo = flowers[-1]\\n            hi = target - 1\\n            \\n            def checkMin(value):\\n                a = left\\n                b = n - 1\\n                while(a <= b):\\n                    mid = (a + b)//2\\n                    if flowers[mid] >= value:\\n                        a = mid + 1\\n                    else:\\n                        b = mid - 1\\n                \\n                goodPoint = b + 1\\n                return preSum[goodPoint] + numAdded >= value *  (n - goodPoint)\\n            \\n            while(lo <= hi):\\n                mid = (lo + hi) // 2\\n                if checkMin(mid):\\n                    lo = mid + 1\\n                else:\\n                    hi = mid - 1\\n            \\n            return lo - 1\\n        \\n        start = n\\n        for i in range(n):\\n            if flowers[i] < target:\\n                start = i\\n                break\\n              \\n        rest = sum(flowers[start:])\\n        maxScore = start * full + ((findMin(start, newFlowers)) * partial if n-start > 0 else 0)\\n        while(start < n + 1):\\n            maxScore = max(maxScore, start * full + ((findMin(start, newFlowers)) * partial if n-start > 0 else 0))\\n            if start == n or newFlowers < target - flowers[start]:\\n                break\\n            else:\\n                rest -= flowers[start]\\n                newFlowers -= target - flowers[start]\\n                start += 1\\n        \\n        return maxScore\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers = sorted(flowers)[::-1]\\n        n = len(flowers)\\n        \\n        preSum = [0]\\n        for i in range(n-1, -1, -1):\\n            preSum.append(preSum[-1] + flowers[i])\\n        \\n        preSum = preSum[::-1]\\n        \\n        def findMin(left, numAdded):\\n            lo = flowers[-1]\\n            hi = target - 1\\n            \\n            def checkMin(value):\\n                a = left\\n                b = n - 1\\n                while(a <= b):\\n                    mid = (a + b)//2\\n                    if flowers[mid] >= value:\\n                        a = mid + 1\\n                    else:\\n                        b = mid - 1\\n                \\n                goodPoint = b + 1\\n                return preSum[goodPoint] + numAdded >= value *  (n - goodPoint)\\n            \\n            while(lo <= hi):\\n                mid = (lo + hi) // 2\\n                if checkMin(mid):\\n                    lo = mid + 1\\n                else:\\n                    hi = mid - 1\\n            \\n            return lo - 1\\n        \\n        start = n\\n        for i in range(n):\\n            if flowers[i] < target:\\n                start = i\\n                break\\n              \\n        rest = sum(flowers[start:])\\n        maxScore = start * full + ((findMin(start, newFlowers)) * partial if n-start > 0 else 0)\\n        while(start < n + 1):\\n            maxScore = max(maxScore, start * full + ((findMin(start, newFlowers)) * partial if n-start > 0 else 0))\\n            if start == n or newFlowers < target - flowers[start]:\\n                break\\n            else:\\n                rest -= flowers[start]\\n                newFlowers -= target - flowers[start]\\n                start += 1\\n        \\n        return maxScore\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937397,
                "title": "python-soln-using-binary-search",
                "content": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers_sorted = sorted(flowers)\\n        \\n        full_cnt = 0\\n        min_partial = 1000000\\n        prefix_sm = []\\n        \\n        for i, f in enumerate(flowers_sorted):\\n            if f >= target:\\n                full_cnt += 1\\n            else:\\n                min_partial = min(f, min_partial)\\n            \\n            if not prefix_sm:\\n                prefix_sm.append(0)\\n            else:\\n                nv = prefix_sm[-1] + ((f-flowers_sorted[i-1]) * len(prefix_sm))\\n                prefix_sm.append(nv)\\n        curr_score = full_cnt * full + partial * (0 if min_partial == 1000000 else min_partial)\\n        for f in range(full_cnt, len(flowers_sorted)+1):\\n            rem_flowers = self.calc_rem_flowers(f, flowers_sorted, newFlowers, target) if f > full_cnt else newFlowers\\n            if (rem_flowers <= 0):\\n                break\\n            min_partial = self.calc_min_partial(f, prefix_sm, flowers_sorted, rem_flowers)\\n            if min_partial >= target:\\n                min_partial = target - 1\\n            curr_score = max(curr_score, f * full + partial * min_partial)\\n            newFlowers = rem_flowers\\n        return curr_score\\n    \\n    def calc_rem_flowers(self, f, flowers_sorted, newFlowers, target):\\n        for i in range(len(flowers_sorted)-f, -1, -1):\\n            if target > flowers_sorted[i]:\\n                newFlowers = newFlowers - (target-flowers_sorted[i])\\n            if len(flowers_sorted) - i == f:\\n                return newFlowers\\n        return -1\\n    \\n    def calc_min_partial(self, f, prefix_sm, flowers_sorted, rem_flowers):\\n        # find the minimum value by distributing remaining flowers\\n        N = len(flowers_sorted)\\n        lo = 0\\n        hi = N-f\\n        idx = bisect.bisect_left(prefix_sm, rem_flowers, lo, hi)\\n        if idx == 0:\\n            # distributing 0 flowers\\n            return 0\\n        return flowers_sorted[idx-1] + (rem_flowers - prefix_sm[idx-1])//(idx-lo)\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers_sorted = sorted(flowers)\\n        \\n        full_cnt = 0\\n        min_partial = 1000000\\n        prefix_sm = []\\n        \\n        for i, f in enumerate(flowers_sorted):\\n            if f >= target:\\n                full_cnt += 1\\n            else:\\n                min_partial = min(f, min_partial)\\n            \\n            if not prefix_sm:\\n                prefix_sm.append(0)\\n            else:\\n                nv = prefix_sm[-1] + ((f-flowers_sorted[i-1]) * len(prefix_sm))\\n                prefix_sm.append(nv)\\n        curr_score = full_cnt * full + partial * (0 if min_partial == 1000000 else min_partial)\\n        for f in range(full_cnt, len(flowers_sorted)+1):\\n            rem_flowers = self.calc_rem_flowers(f, flowers_sorted, newFlowers, target) if f > full_cnt else newFlowers\\n            if (rem_flowers <= 0):\\n                break\\n            min_partial = self.calc_min_partial(f, prefix_sm, flowers_sorted, rem_flowers)\\n            if min_partial >= target:\\n                min_partial = target - 1\\n            curr_score = max(curr_score, f * full + partial * min_partial)\\n            newFlowers = rem_flowers\\n        return curr_score\\n    \\n    def calc_rem_flowers(self, f, flowers_sorted, newFlowers, target):\\n        for i in range(len(flowers_sorted)-f, -1, -1):\\n            if target > flowers_sorted[i]:\\n                newFlowers = newFlowers - (target-flowers_sorted[i])\\n            if len(flowers_sorted) - i == f:\\n                return newFlowers\\n        return -1\\n    \\n    def calc_min_partial(self, f, prefix_sm, flowers_sorted, rem_flowers):\\n        # find the minimum value by distributing remaining flowers\\n        N = len(flowers_sorted)\\n        lo = 0\\n        hi = N-f\\n        idx = bisect.bisect_left(prefix_sm, rem_flowers, lo, hi)\\n        if idx == 0:\\n            # distributing 0 flowers\\n            return 0\\n        return flowers_sorted[idx-1] + (rem_flowers - prefix_sm[idx-1])//(idx-lo)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934480,
                "title": "python-3-binary-search-prefix-sum",
                "content": "Sort the flowers, then greedily fill up the gardens from the maximum flowers, and use binary search to find the max minimum of the first unfilled gardens.\\n```\\ndef maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:        \\n        n = len(flowers)\\n        flowers.sort()\\n        if flowers[0] >= target: return n * full\\n        prefix = [0]\\n        for x in flowers:\\n            prefix.append(prefix[-1]+x)\\n        # calculate the max minimum base on the k and cnt\\n        def cal(cnt, i, j):\\n            if i == j: return 0\\n            l, r = flowers[0], target - 1\\n            while l < r:\\n                mid = (l + r + 1) // 2\\n                idx = bisect.bisect(flowers, mid, 0, j)\\n                if mid * idx - prefix[idx] > cnt:\\n                    r = mid - 1\\n                else: \\n                    l = mid\\n            return l                                        \\n        \\n        j = n - 1\\n        cnt = newFlowers\\n        # greedy to find first j that need to add to target\\n        while j and flowers[j] >= target:\\n            j -= 1          \\n        # nothing add to j, initial res\\n        res = cal(newFlowers, 0, j + 1) * partial + (n - j - 1) * full   \\n        while j >= 0:\\n            cnt = cnt - (target - flowers[j])\\n            if cnt < 0: break\\n            res = max(res, cal(cnt, 0, j) * partial + (n - j) * full)\\n            j -= 1\\n        return res\\n\\n",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "Sort the flowers, then greedily fill up the gardens from the maximum flowers, and use binary search to find the max minimum of the first unfilled gardens.\\n```\\ndef maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:        \\n        n = len(flowers)\\n        flowers.sort()\\n        if flowers[0] >= target: return n * full\\n        prefix = [0]\\n        for x in flowers:\\n            prefix.append(prefix[-1]+x)\\n        # calculate the max minimum base on the k and cnt\\n        def cal(cnt, i, j):\\n            if i == j: return 0\\n            l, r = flowers[0], target - 1\\n            while l < r:\\n                mid = (l + r + 1) // 2\\n                idx = bisect.bisect(flowers, mid, 0, j)\\n                if mid * idx - prefix[idx] > cnt:\\n                    r = mid - 1\\n                else: \\n                    l = mid\\n            return l                                        \\n        \\n        j = n - 1\\n        cnt = newFlowers\\n        # greedy to find first j that need to add to target\\n        while j and flowers[j] >= target:\\n            j -= 1          \\n        # nothing add to j, initial res\\n        res = cal(newFlowers, 0, j + 1) * partial + (n - j - 1) * full   \\n        while j >= 0:\\n            cnt = cnt - (target - flowers[j])\\n            if cnt < 0: break\\n            res = max(res, cal(cnt, 0, j) * partial + (n - j) * full)\\n            j -= 1\\n        return res\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1934220,
                "title": "c-prefix-sum-binary-search-faster-than-100",
                "content": "```\\nlong long maximumBeauty(vector<int> &flowers, long long newFlowers, int _target, int full, int partial) {\\n        long long target = _target;\\n        sort(flowers.begin(), flowers.end(), greater<int>());\\n        int n = flowers.size();\\n        long long min_full = 0;\\n        for (auto flower: flowers) {\\n            if (flower >= target)\\n                min_full++;\\n        }\\n        long long temp = newFlowers;\\n        long long max_full = 0;\\n        for (int i = 0; i < n; i++) {\\n            temp -= max((long long) 0, target - flowers[i]);\\n            if (temp < 0)\\n                break;\\n            max_full++;\\n        }\\n        vector<long long> partial_min_arr(n, 0);\\n        for (int i = n - 2; i >= 0; i--) {\\n            partial_min_arr[i] = partial_min_arr[i + 1] + (flowers[i] - flowers[i + 1]) * (n - 1 - i);\\n        }\\n        vector<long long> remain_by_num_full(n + 1, 0);\\n        temp = newFlowers;\\n        for (int i = min_full; i <= max_full; i++) {\\n            if (i != 0) {\\n                temp -= max((long long) 0, target - flowers[i - 1]);\\n            }\\n            remain_by_num_full[i] = max(temp, (long long) 0);\\n        }\\n        long long res = -1;\\n        for (long long num_full = min_full; num_full <= max_full; num_full++) {\\n            long long cur = full * num_full;\\n            long long remain = remain_by_num_full[num_full];\\n            long long partial_min_index = n - (upper_bound(partial_min_arr.rbegin(), partial_min_arr.rend(), remain)\\n                                               - partial_min_arr.rbegin());\\n            partial_min_index = max(partial_min_index, num_full);\\n            long long num_partial_fill = n - partial_min_index;\\n            long long num_partial = 0;\\n            if (num_partial_fill != 0)\\n                num_partial = min(\\n                        target - 1,\\n                        flowers[partial_min_index] + (remain - partial_min_arr[partial_min_index]) / num_partial_fill\\n                );\\n            cur += num_partial * partial;\\n            res = max(res, cur);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nlong long maximumBeauty(vector<int> &flowers, long long newFlowers, int _target, int full, int partial) {\\n        long long target = _target;\\n        sort(flowers.begin(), flowers.end(), greater<int>());\\n        int n = flowers.size();\\n        long long min_full = 0;\\n        for (auto flower: flowers) {\\n            if (flower >= target)\\n                min_full++;\\n        }\\n        long long temp = newFlowers;\\n        long long max_full = 0;\\n        for (int i = 0; i < n; i++) {\\n            temp -= max((long long) 0, target - flowers[i]);\\n            if (temp < 0)\\n                break;\\n            max_full++;\\n        }\\n        vector<long long> partial_min_arr(n, 0);\\n        for (int i = n - 2; i >= 0; i--) {\\n            partial_min_arr[i] = partial_min_arr[i + 1] + (flowers[i] - flowers[i + 1]) * (n - 1 - i);\\n        }\\n        vector<long long> remain_by_num_full(n + 1, 0);\\n        temp = newFlowers;\\n        for (int i = min_full; i <= max_full; i++) {\\n            if (i != 0) {\\n                temp -= max((long long) 0, target - flowers[i - 1]);\\n            }\\n            remain_by_num_full[i] = max(temp, (long long) 0);\\n        }\\n        long long res = -1;\\n        for (long long num_full = min_full; num_full <= max_full; num_full++) {\\n            long long cur = full * num_full;\\n            long long remain = remain_by_num_full[num_full];\\n            long long partial_min_index = n - (upper_bound(partial_min_arr.rbegin(), partial_min_arr.rend(), remain)\\n                                               - partial_min_arr.rbegin());\\n            partial_min_index = max(partial_min_index, num_full);\\n            long long num_partial_fill = n - partial_min_index;\\n            long long num_partial = 0;\\n            if (num_partial_fill != 0)\\n                num_partial = min(\\n                        target - 1,\\n                        flowers[partial_min_index] + (remain - partial_min_arr[partial_min_index]) / num_partial_fill\\n                );\\n            cur += num_partial * partial;\\n            res = max(res, cur);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934204,
                "title": "simple-python-search",
                "content": "I think the difficaulty is in the handeling of corner cases.\\n```\\nclass Solution:\\n    def fill_k(self, k):\\n        assert self.newFlowers >= self.need_to_full[k]\\n        rest = self.newFlowers - self.need_to_full[k]\\n        max_w = self.n-k\\n        score = k * self.full\\n        \\n        if max_w == 0:\\n            return score\\n        if rest == 0:\\n            return score + self.minh * self.partial\\n        \\n        while self.widths[-2] >= max_w:\\n            self.areas.pop()\\n            self.widths.pop()\\n            self.hights.pop()\\n        if self.widths[-1] > max_w:\\n            self.widths[-1] = max_w\\n            self.hights[-1] = self.hights[-2] + self.target\\n            self.areas[-1] = self.areas[-2] + self.target*max_w\\n        \\n        while self.areas[-2] > rest:\\n            self.areas.pop()\\n            self.widths.pop()\\n            self.hights.pop()\\n        rest -= self.areas[-2]\\n        add_h = self.hights[-2] + (rest//self.widths[-1])\\n        min_h = min(self.minh + add_h, self.target-1)\\n        score += min_h * self.partial\\n        return score\\n    \\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers.sort()\\n        already_full = 0\\n        while len(flowers) > 0 and flowers[-1] >= target:\\n            already_full += 1\\n            flowers.pop()\\n        \\n        if len(flowers) == 0:\\n            return already_full * full\\n        \\n        self.need_to_full = [0]\\n        for c in flowers[::-1]:\\n            need = target - c\\n            self.need_to_full.append(need + self.need_to_full[-1])\\n        #print(self.need_to_full)\\n        \\n        self.areas = [0]\\n        self.widths = [0]\\n        self.hights = [0]\\n        for i, c in enumerate(flowers[1:]):\\n            if c > flowers[i]:\\n                h = c - flowers[i]\\n                w = i+1\\n                area = h*w\\n                self.areas.append(self.areas[-1]+area)\\n                self.widths.append(w)\\n                self.hights.append(self.hights[-1]+h)\\n        h = target\\n        w = len(flowers)\\n        area = h*w\\n        self.areas.append(self.areas[-1]+area)\\n        self.widths.append(w)\\n        self.hights.append(self.hights[-1]+h)\\n        #print(self.widths)\\n        #print(self.areas)\\n        #print(self.hights)\\n        \\n        self.newFlowers = newFlowers\\n        self.full = full\\n        self.partial = partial\\n        self.minh = flowers[0]\\n        self.n = len(flowers)\\n        self.target = target\\n        #print(self.minh)\\n        \\n        r = 0\\n        for k in range(self.n+1):\\n            if self.newFlowers < self.need_to_full[k]:\\n                break\\n            r = max(r, self.fill_k(k))\\n        \\n        return r + already_full * self.full\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fill_k(self, k):\\n        assert self.newFlowers >= self.need_to_full[k]\\n        rest = self.newFlowers - self.need_to_full[k]\\n        max_w = self.n-k\\n        score = k * self.full\\n        \\n        if max_w == 0:\\n            return score\\n        if rest == 0:\\n            return score + self.minh * self.partial\\n        \\n        while self.widths[-2] >= max_w:\\n            self.areas.pop()\\n            self.widths.pop()\\n            self.hights.pop()\\n        if self.widths[-1] > max_w:\\n            self.widths[-1] = max_w\\n            self.hights[-1] = self.hights[-2] + self.target\\n            self.areas[-1] = self.areas[-2] + self.target*max_w\\n        \\n        while self.areas[-2] > rest:\\n            self.areas.pop()\\n            self.widths.pop()\\n            self.hights.pop()\\n        rest -= self.areas[-2]\\n        add_h = self.hights[-2] + (rest//self.widths[-1])\\n        min_h = min(self.minh + add_h, self.target-1)\\n        score += min_h * self.partial\\n        return score\\n    \\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers.sort()\\n        already_full = 0\\n        while len(flowers) > 0 and flowers[-1] >= target:\\n            already_full += 1\\n            flowers.pop()\\n        \\n        if len(flowers) == 0:\\n            return already_full * full\\n        \\n        self.need_to_full = [0]\\n        for c in flowers[::-1]:\\n            need = target - c\\n            self.need_to_full.append(need + self.need_to_full[-1])\\n        #print(self.need_to_full)\\n        \\n        self.areas = [0]\\n        self.widths = [0]\\n        self.hights = [0]\\n        for i, c in enumerate(flowers[1:]):\\n            if c > flowers[i]:\\n                h = c - flowers[i]\\n                w = i+1\\n                area = h*w\\n                self.areas.append(self.areas[-1]+area)\\n                self.widths.append(w)\\n                self.hights.append(self.hights[-1]+h)\\n        h = target\\n        w = len(flowers)\\n        area = h*w\\n        self.areas.append(self.areas[-1]+area)\\n        self.widths.append(w)\\n        self.hights.append(self.hights[-1]+h)\\n        #print(self.widths)\\n        #print(self.areas)\\n        #print(self.hights)\\n        \\n        self.newFlowers = newFlowers\\n        self.full = full\\n        self.partial = partial\\n        self.minh = flowers[0]\\n        self.n = len(flowers)\\n        self.target = target\\n        #print(self.minh)\\n        \\n        r = 0\\n        for k in range(self.n+1):\\n            if self.newFlowers < self.need_to_full[k]:\\n                break\\n            r = max(r, self.fill_k(k))\\n        \\n        return r + already_full * self.full\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934186,
                "title": "python-3-avoid-using-python-built-in-accumulate-function",
                "content": "Keep getting TLE\\nRealize the bottleneck is the python built-in `accumulate` function...\\nSame logic as the hint\\n* Greedily fill all gardens to target (descending prefix sum)\\n* Fill remaining garden and binary search the maximum lowest flowers\\n\\n\\n```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        q, q_acc = [], [0] #eligible gardens < target and its prefix sum\\n        full_need_acc = [0] #diff to target prefix sum\\n        ans = 0\\n        n = len(flowers)\\n        flowers.sort()\\n\\n        for f in flowers:\\n            if f >= target: \\n                ans += full\\n                continue\\n            q.append(f)\\n            q_acc.append(q_acc[-1] + f)\\n        \\n        for f in flowers[::-1]:\\n            if f >= target: continue\\n            full_need_acc.append(full_need_acc[-1] + max(0, target - f))\\n\\n        res = 0\\n        for i, x in enumerate(full_need_acc):\\n            if x > newFlowers: break\\n            if i == len(full_need_acc) - 1:\\n                res = max(res, i * full)\\n                continue\\n            l, h = flowers[0], target - 1\\n            while l < h:\\n                mid = l + (h - l + 1) // 2\\n                loc = bisect.bisect_left(q, mid, lo=0, hi=len(q)-i)\\n                if mid * loc - q_acc[loc] <= newFlowers - x:\\n                    l = mid\\n                else:\\n                    h = mid - 1\\n            res = max(res, i * full + l * partial)\\n        return ans + res\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        q, q_acc = [], [0] #eligible gardens < target and its prefix sum\\n        full_need_acc = [0] #diff to target prefix sum\\n        ans = 0\\n        n = len(flowers)\\n        flowers.sort()\\n\\n        for f in flowers:\\n            if f >= target: \\n                ans += full\\n                continue\\n            q.append(f)\\n            q_acc.append(q_acc[-1] + f)\\n        \\n        for f in flowers[::-1]:\\n            if f >= target: continue\\n            full_need_acc.append(full_need_acc[-1] + max(0, target - f))\\n\\n        res = 0\\n        for i, x in enumerate(full_need_acc):\\n            if x > newFlowers: break\\n            if i == len(full_need_acc) - 1:\\n                res = max(res, i * full)\\n                continue\\n            l, h = flowers[0], target - 1\\n            while l < h:\\n                mid = l + (h - l + 1) // 2\\n                loc = bisect.bisect_left(q, mid, lo=0, hi=len(q)-i)\\n                if mid * loc - q_acc[loc] <= newFlowers - x:\\n                    l = mid\\n                else:\\n                    h = mid - 1\\n            res = max(res, i * full + l * partial)\\n        return ans + res\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1933936,
                "title": "c-binary-search-o-n-log-n-log-target",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> sum;\\n    int binarysearch(vector<int>& nums,int l,int h,long long m){\\n        int re = 0;\\n        while(l<=h){\\n            int mid = (l+h)/2;\\n            if(nums[mid]<m){ re = mid; l=mid+1; }\\n            else h=mid-1;\\n        }\\n        return re;\\n    }\\n    long long find(vector<int>& nums,long long t,long long r,int x){\\n        long long l = nums[0],h=t-1,ans = 0;\\n        while(l<=h){\\n            long long m = (l+h)/2;\\n            long long temp = 0;\\n            int k = binarysearch(nums,0,nums.size()-x-1,m);\\n            temp = m*(k+1)-sum[k];\\n            if(temp<=r){\\n                ans = m; l=m+1;\\n            }\\n            else h=m-1;\\n        }\\n        return ans;\\n    }\\n    long long maximumBeauty(vector<int>& nums, long long n, int t, int full, int partial) {\\n        sort(nums.begin(),nums.end());\\n        long long l = 0,h=0,temp=n; // l = min no. of full garden, h = Max no. of garden that can be full\\n        vector<long long> arr; \\n        sum = vector<long long>(nums.size(),0); sum[0]=nums[0];\\n        for(int i = 1; i<nums.size();++i)sum[i]=nums[i]+sum[i-1];\\n        for(int i = nums.size()-1;i>=0;--i){\\n            if(nums[i]>=t) {l++;h++;}\\n            else{\\n                if(temp>=t-nums[i]){  // if ith garden is not full, Check if it can be completed \\n                    h++; temp-=t-nums[i];  \\n                    arr.push_back(temp);  // Store the no. of flowers left after ith garden is completed\\n                }\\n                else break;\\n            }\\n        }\\n        long long ans = (long long)full*l;  // calculate ans for `l`\\n        if(l<nums.size()) ans+=(long long)partial*find(nums,t,n,l);\\n        for(long long i = l+1;i<=h;++i){\\n            long long p = 0;\\n            if(nums.size()>i) p=find(nums,t,arr[i-l-1],i); // Get the maximized minimum no. of flowers if `i` gardens are completed and arr[i-l-1] flowers are left\\n            p = i*full +p*partial;\\n            ans = max(ans,p);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> sum;\\n    int binarysearch(vector<int>& nums,int l,int h,long long m){\\n        int re = 0;\\n        while(l<=h){\\n            int mid = (l+h)/2;\\n            if(nums[mid]<m){ re = mid; l=mid+1; }\\n            else h=mid-1;\\n        }\\n        return re;\\n    }\\n    long long find(vector<int>& nums,long long t,long long r,int x){\\n        long long l = nums[0],h=t-1,ans = 0;\\n        while(l<=h){\\n            long long m = (l+h)/2;\\n            long long temp = 0;\\n            int k = binarysearch(nums,0,nums.size()-x-1,m);\\n            temp = m*(k+1)-sum[k];\\n            if(temp<=r){\\n                ans = m; l=m+1;\\n            }\\n            else h=m-1;\\n        }\\n        return ans;\\n    }\\n    long long maximumBeauty(vector<int>& nums, long long n, int t, int full, int partial) {\\n        sort(nums.begin(),nums.end());\\n        long long l = 0,h=0,temp=n; // l = min no. of full garden, h = Max no. of garden that can be full\\n        vector<long long> arr; \\n        sum = vector<long long>(nums.size(),0); sum[0]=nums[0];\\n        for(int i = 1; i<nums.size();++i)sum[i]=nums[i]+sum[i-1];\\n        for(int i = nums.size()-1;i>=0;--i){\\n            if(nums[i]>=t) {l++;h++;}\\n            else{\\n                if(temp>=t-nums[i]){  // if ith garden is not full, Check if it can be completed \\n                    h++; temp-=t-nums[i];  \\n                    arr.push_back(temp);  // Store the no. of flowers left after ith garden is completed\\n                }\\n                else break;\\n            }\\n        }\\n        long long ans = (long long)full*l;  // calculate ans for `l`\\n        if(l<nums.size()) ans+=(long long)partial*find(nums,t,n,l);\\n        for(long long i = l+1;i<=h;++i){\\n            long long p = 0;\\n            if(nums.size()>i) p=find(nums,t,arr[i-l-1],i); // Get the maximized minimum no. of flowers if `i` gardens are completed and arr[i-l-1] flowers are left\\n            p = i*full +p*partial;\\n            ans = max(ans,p);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1933843,
                "title": "sort-iterate-over-minimum-values-greedy",
                "content": "We want to maximize `(mininum_value * partial + most_full(newFlowers - needed(minimum_value)) * full)`\\nconstrained by `0 <= minimum_value <= target`\\nwhere `most_full(X)` is the highest amount of full gardens we can have with `X` added flowers,\\nand `needed(Y)` is the fewest amount of flowers needed to make the minimum value `Y`.\\n\\n`most_full` and `needed` can each be efficiently updated while iterating through all `minimum_value`s since they are monotonic\\nwith respect to `minimum_value`. \\n\\nAn edge case is that `needed(minimum_value)` must be atleast `1` for `minimum_value > 0`. \\n\\nThe time complexity is `O(n log n + target)`. \\n\\n\\n\\n```\\n    using ll = long long;\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        ll n = flowers.size();\\n        vector<ll> needed(n+1, 0);\\n        ll full_ptr = n;\\n        for (ll i = n-1; i >= 0; --i) {\\n            needed[i] = needed[i+1] + max(0, target - flowers[i]);\\n            if (needed[i] <= newFlowers)\\n                full_ptr = i;\\n            \\n        }\\n\\n        ll needed_mv{0};\\n        ll pref_sum{0};\\n        ll ans = 0;\\n        ll partial_ptr{0};\\n        for (ll mv = 0; mv < (ll)target; ++mv) {\\n            while(partial_ptr < n && partial_ptr < full_ptr && flowers[partial_ptr] < mv) {\\n                pref_sum += flowers[partial_ptr++];\\n            }\\n            if (partial_ptr == 0 && mv > 0 && flowers[partial_ptr] <= mv) {\\n                pref_sum += flowers[partial_ptr++];\\n                full_ptr= max(partial_ptr, full_ptr);\\n            }\\n            needed_mv = mv * partial_ptr - pref_sum;\\n            if (needed_mv > newFlowers) break;\\n            while(needed_mv + needed[full_ptr] > newFlowers) {\\n                ++full_ptr;\\n            }\\n            ans = max(ans, (n - full_ptr) * full + ((ll)(partial_ptr != 0) * mv * partial));\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n    using ll = long long;\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        ll n = flowers.size();\\n        vector<ll> needed(n+1, 0);\\n        ll full_ptr = n;\\n        for (ll i = n-1; i >= 0; --i) {\\n            needed[i] = needed[i+1] + max(0, target - flowers[i]);\\n            if (needed[i] <= newFlowers)\\n                full_ptr = i;\\n            \\n        }\\n\\n        ll needed_mv{0};\\n        ll pref_sum{0};\\n        ll ans = 0;\\n        ll partial_ptr{0};\\n        for (ll mv = 0; mv < (ll)target; ++mv) {\\n            while(partial_ptr < n && partial_ptr < full_ptr && flowers[partial_ptr] < mv) {\\n                pref_sum += flowers[partial_ptr++];\\n            }\\n            if (partial_ptr == 0 && mv > 0 && flowers[partial_ptr] <= mv) {\\n                pref_sum += flowers[partial_ptr++];\\n                full_ptr= max(partial_ptr, full_ptr);\\n            }\\n            needed_mv = mv * partial_ptr - pref_sum;\\n            if (needed_mv > newFlowers) break;\\n            while(needed_mv + needed[full_ptr] > newFlowers) {\\n                ++full_ptr;\\n            }\\n            ans = max(ans, (n - full_ptr) * full + ((ll)(partial_ptr != 0) * mv * partial));\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1933623,
                "title": "python3-two-pointer-o-n-greedy",
                "content": "idea:\\n1. sort garden\\n2. try to complete from right to left using all the new flowers. Mark the position as `r`\\n3. release complete graden to get new flowers (index mark as `nr`), for current remaining new flowers:\\n\\t3.1 fill current gap to improve current minimum of incomplete garden within `[:l]` to `flowers[l]` until not enough remaining flowers.\\n\\t3.2 evenly adding the remaining flowers to incomplete garden.\\n4. calcualte current value\\n\\n```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers.sort()\\n        N = len(flowers)\\n        rem = newFlowers\\n        res = 0\\n        for r in range(N-1,-1,-1):\\n            if rem >= max(0,target-flowers[r]):\\n                rem -= max(0,target-flowers[r])\\n            else:\\n                r += 1\\n                break\\n        if r == 0:\\n            res = full*N\\n        l=0\\n        for nr in range(r, N+1):\\n            if nr != r:\\n                off = max(0, target-flowers[nr-1])\\n                if off == 0:\\n                    break\\n                rem += off\\n            for l in range(l, nr):\\n                if l == 0:\\n                    if nr == 1:\\n                        cur = full*(N-nr)+partial*min(target-1, rem+flowers[l])  \\n                    else:\\n                        cur = full*(N-nr)+partial*min(target-1, rem+flowers[l], flowers[l+1])\\n                elif 0<l<nr-1:\\n                    if rem >= (flowers[l]-flowers[l-1])*l:\\n                        rem -= (flowers[l]-flowers[l-1])*l\\n                        cur = full*(N-nr)+partial*min(target-1, rem//(l+1)+flowers[l], flowers[l+1])\\n                    else:\\n                        cur = full*(N-nr)+partial*min(target-1, rem//l+flowers[l-1], flowers[l])\\n                        res = max(res,cur)\\n                        break\\n                elif l == nr-1:\\n                    if rem >= (flowers[l]-flowers[l-1])*l:\\n                        cur = full*(N-nr)+partial*min(target-1, (rem-(flowers[l]-flowers[l-1])*l)//(l+1)+flowers[l])\\n                res = max(res,cur)\\n            \\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers.sort()\\n        N = len(flowers)\\n        rem = newFlowers\\n        res = 0\\n        for r in range(N-1,-1,-1):\\n            if rem >= max(0,target-flowers[r]):\\n                rem -= max(0,target-flowers[r])\\n            else:\\n                r += 1\\n                break\\n        if r == 0:\\n            res = full*N\\n        l=0\\n        for nr in range(r, N+1):\\n            if nr != r:\\n                off = max(0, target-flowers[nr-1])\\n                if off == 0:\\n                    break\\n                rem += off\\n            for l in range(l, nr):\\n                if l == 0:\\n                    if nr == 1:\\n                        cur = full*(N-nr)+partial*min(target-1, rem+flowers[l])  \\n                    else:\\n                        cur = full*(N-nr)+partial*min(target-1, rem+flowers[l], flowers[l+1])\\n                elif 0<l<nr-1:\\n                    if rem >= (flowers[l]-flowers[l-1])*l:\\n                        rem -= (flowers[l]-flowers[l-1])*l\\n                        cur = full*(N-nr)+partial*min(target-1, rem//(l+1)+flowers[l], flowers[l+1])\\n                    else:\\n                        cur = full*(N-nr)+partial*min(target-1, rem//l+flowers[l-1], flowers[l])\\n                        res = max(res,cur)\\n                        break\\n                elif l == nr-1:\\n                    if rem >= (flowers[l]-flowers[l-1])*l:\\n                        cur = full*(N-nr)+partial*min(target-1, (rem-(flowers[l]-flowers[l-1])*l)//(l+1)+flowers[l])\\n                res = max(res,cur)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932831,
                "title": "get-tle-when-submited-but-runs-fine-when-click-run-code",
                "content": "\\n```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers = sorted(flowers)\\n        n = len(flowers)\\n        i = n - 1\\n        while i >= 0 and flowers[i] >= target:\\n            i -= 1\\n        if i < 0:\\n            return n * full\\n        full_cnt = n - i - 1\\n        flowers = flowers[:i+1]\\n        n = len(flowers)\\n        psum, ssum = list(flowers), list(flowers)\\n        for i in range(1, n):\\n            psum[i] += psum[i - 1]       \\n        for i in range(-2, -(n+1), -1):\\n            ssum[i] += ssum[i + 1]\\n        \\n        max_score = flowers[0] * partial + full_cnt * full\\n        for min_flowers in range(flowers[0], target + 1):\\n            l1, r1 = 0, n - 1\\n            while l1 <= r1:\\n                m1 = (l1 + r1) // 2\\n                if flowers[m1] < min_flowers:\\n                    l1 = m1 + 1\\n                else:\\n                    r1 = m1 - 1\\n            l3, r3 = l1, n - 1\\n            while l3 <= r3:\\n                m3 = (l3 + r3) // 2\\n                if flowers[m3] <= min_flowers:\\n                    l3 = m3 + 1\\n                else:\\n                    r3 = m3 - 1\\n            remains = newFlowers if r1 < 0 else newFlowers - ((r1 + 1) * min_flowers - psum[r1])\\n            if remains < 0:\\n                break\\n            if min_flowers == target:\\n                score = full * (len(flowers) + full_cnt)\\n                max_score = max(score, max_score)\\n                break\\n            l2, r2 = l3, n - 1\\n            while l2 <= r2:\\n                m2 = (l2 + r2) // 2\\n                if (n  - m2) * target - ssum[m2] <= remains:\\n                    r2 = m2 - 1\\n                else:\\n                    l2 = m2 + 1\\n            \\n            full_cnt1 = full_cnt\\n            if l2 < n:\\n                remains -= ((n - l2) * target - ssum[l2])\\n                full_cnt1 += (n - l2)\\n            if l2 == l3 and remains > 0:\\n                full_cnt1 += min(remains // (target - min_flowers), l2 - 1)\\n            score = min_flowers * partial + full_cnt1 * full\\n            max_score = max(max_score, score)\\n            \\n        return max_score\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers = sorted(flowers)\\n        n = len(flowers)\\n        i = n - 1\\n        while i >= 0 and flowers[i] >= target:\\n            i -= 1\\n        if i < 0:\\n            return n * full\\n        full_cnt = n - i - 1\\n        flowers = flowers[:i+1]\\n        n = len(flowers)\\n        psum, ssum = list(flowers), list(flowers)\\n        for i in range(1, n):\\n            psum[i] += psum[i - 1]       \\n        for i in range(-2, -(n+1), -1):\\n            ssum[i] += ssum[i + 1]\\n        \\n        max_score = flowers[0] * partial + full_cnt * full\\n        for min_flowers in range(flowers[0], target + 1):\\n            l1, r1 = 0, n - 1\\n            while l1 <= r1:\\n                m1 = (l1 + r1) // 2\\n                if flowers[m1] < min_flowers:\\n                    l1 = m1 + 1\\n                else:\\n                    r1 = m1 - 1\\n            l3, r3 = l1, n - 1\\n            while l3 <= r3:\\n                m3 = (l3 + r3) // 2\\n                if flowers[m3] <= min_flowers:\\n                    l3 = m3 + 1\\n                else:\\n                    r3 = m3 - 1\\n            remains = newFlowers if r1 < 0 else newFlowers - ((r1 + 1) * min_flowers - psum[r1])\\n            if remains < 0:\\n                break\\n            if min_flowers == target:\\n                score = full * (len(flowers) + full_cnt)\\n                max_score = max(score, max_score)\\n                break\\n            l2, r2 = l3, n - 1\\n            while l2 <= r2:\\n                m2 = (l2 + r2) // 2\\n                if (n  - m2) * target - ssum[m2] <= remains:\\n                    r2 = m2 - 1\\n                else:\\n                    l2 = m2 + 1\\n            \\n            full_cnt1 = full_cnt\\n            if l2 < n:\\n                remains -= ((n - l2) * target - ssum[l2])\\n                full_cnt1 += (n - l2)\\n            if l2 == l3 and remains > 0:\\n                full_cnt1 += min(remains // (target - min_flowers), l2 - 1)\\n            score = min_flowers * partial + full_cnt1 * full\\n            max_score = max(max_score, score)\\n            \\n        return max_score\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932616,
                "title": "simple-solution-in-java-elegant-and-concise-using-binary-search",
                "content": "```\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        /*\\n           Sort the array,\\n           Complete the number of flowers from the last and check how much maximum minimum flowers in partial gardens we can get\\n           from the remaining flowers using binary search\\n        */\\n        \\n        long ans = 0;\\n        \\n        Arrays.sort(flowers);\\n        int numFlowers = flowers.length;\\n        long[] cost = new long[numFlowers]; // Cost to get minimum flowers as the current flower till the current index \\n        \\n        int isComplete = flowers[0] >= target ? 1 : 0;\\n        for(int i=1; i<numFlowers; i++){\\n            cost[i] = cost[i-1] + (flowers[i] - flowers[i-1])*i;\\n            if(flowers[i] >= target) isComplete++;\\n        }\\n        \\n        if(isComplete == flowers.length) return (long)numFlowers*full; // If all gardens are full\\n        \\n        long costToCompleteTillNow = 0;\\n        for(int i=numFlowers; i>=0; i--){\\n            if(i < numFlowers){\\n                costToCompleteTillNow += Math.max(0, target - flowers[i]);\\n                if(costToCompleteTillNow > newFlowers) break;\\n                if(i == 0){\\n                    ans = Math.max(ans, (numFlowers)*(long)full);\\n                    break;\\n                }   \\n            }\\n            // Find the index till which we can have partial garden from the remaining flowers\\n            long remFlower = newFlowers - costToCompleteTillNow;\\n            int maxPartialIndex = findByBinarySearch(remFlower, cost, 0, i-1);\\n            \\n            if(maxPartialIndex < 0) continue;\\n            \\n            long remFlowerAfterDist = remFlower - cost[maxPartialIndex]; // Remaining flowers after paying the cost to make all equal\\n            long flowerToAdd = remFlowerAfterDist/(maxPartialIndex + 1); // Equally distribute the remaining flowers\\n            \\n            ans = Math.max(ans, (((long)full*(numFlowers - i))  + ((long)partial)*(Math.min(target - 1, flowers[maxPartialIndex] + flowerToAdd))  ));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int findByBinarySearch(long key, long[] arr, int l, int h){  \\n        if(l > h || arr[l] > key) return -1;\\n        \\n        int ans = 0;\\n        h += 1;\\n        while(l < h){\\n            int m = l + (h-l)/2;\\n            if(arr[m] <= key){\\n                ans = m;\\n                l = m+1;\\n            }else h = m;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        /*\\n           Sort the array,\\n           Complete the number of flowers from the last and check how much maximum minimum flowers in partial gardens we can get\\n           from the remaining flowers using binary search\\n        */\\n        \\n        long ans = 0;\\n        \\n        Arrays.sort(flowers);\\n        int numFlowers = flowers.length;\\n        long[] cost = new long[numFlowers]; // Cost to get minimum flowers as the current flower till the current index \\n        \\n        int isComplete = flowers[0] >= target ? 1 : 0;\\n        for(int i=1; i<numFlowers; i++){\\n            cost[i] = cost[i-1] + (flowers[i] - flowers[i-1])*i;\\n            if(flowers[i] >= target) isComplete++;\\n        }\\n        \\n        if(isComplete == flowers.length) return (long)numFlowers*full; // If all gardens are full\\n        \\n        long costToCompleteTillNow = 0;\\n        for(int i=numFlowers; i>=0; i--){\\n            if(i < numFlowers){\\n                costToCompleteTillNow += Math.max(0, target - flowers[i]);\\n                if(costToCompleteTillNow > newFlowers) break;\\n                if(i == 0){\\n                    ans = Math.max(ans, (numFlowers)*(long)full);\\n                    break;\\n                }   \\n            }\\n            // Find the index till which we can have partial garden from the remaining flowers\\n            long remFlower = newFlowers - costToCompleteTillNow;\\n            int maxPartialIndex = findByBinarySearch(remFlower, cost, 0, i-1);\\n            \\n            if(maxPartialIndex < 0) continue;\\n            \\n            long remFlowerAfterDist = remFlower - cost[maxPartialIndex]; // Remaining flowers after paying the cost to make all equal\\n            long flowerToAdd = remFlowerAfterDist/(maxPartialIndex + 1); // Equally distribute the remaining flowers\\n            \\n            ans = Math.max(ans, (((long)full*(numFlowers - i))  + ((long)partial)*(Math.min(target - 1, flowers[maxPartialIndex] + flowerToAdd))  ));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int findByBinarySearch(long key, long[] arr, int l, int h){  \\n        if(l > h || arr[l] > key) return -1;\\n        \\n        int ans = 0;\\n        h += 1;\\n        while(l < h){\\n            int m = l + (h-l)/2;\\n            if(arr[m] <= key){\\n                ans = m;\\n                l = m+1;\\n            }else h = m;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932371,
                "title": "short-and-concise-prefix-sum-two-pointers-c-o-nlogn",
                "content": "Use two pointers to arrange the `newFlowers`. We arrange full gardens first by counting up `fc` (full count) from `0` to `n`, i.e. move the first pointer backward from the end of the sorted list. For each `fc`, we decrease `pc` (partial count) to fit the unused flowers after arranging the full gardens.\\n```\\nlong long maximumBeauty(vector<int>& F, long long newFlowers, int T, int full, int partial) {\\n    sort(F.begin(), F.end());\\n    vector<int64_t> ps(1); // prefix sum\\n    for (int &i : F) {\\n        i = min(i, T); // shave off those higher than target\\n        ps.push_back(ps.back() + (int64_t)i);\\n    }\\n    int64_t ans = 0;\\n    for (int64_t n = F.size(), pc = n, fc = 0; fc <= n; fc++) { // count up full ones\\n        int64_t x = newFlowers - (T * fc - (ps[n] - ps[n - fc]));\\n        if (x < 0) // x remaining flowers to fill partial ones\\n            break;\\n        for (pc = min(pc, n - fc); pc > 0 && F[pc - 1] * pc - ps[pc] > x; pc--); // count down partial ones\\n        int64_t pm = pc && F[0] < T ? min<int64_t>(T - 1, (x + ps[pc]) / pc) : 0;\\n        ans = max(ans, fc * full + pm * partial);\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Prefix Sum"
                ],
                "code": "```\\nlong long maximumBeauty(vector<int>& F, long long newFlowers, int T, int full, int partial) {\\n    sort(F.begin(), F.end());\\n    vector<int64_t> ps(1); // prefix sum\\n    for (int &i : F) {\\n        i = min(i, T); // shave off those higher than target\\n        ps.push_back(ps.back() + (int64_t)i);\\n    }\\n    int64_t ans = 0;\\n    for (int64_t n = F.size(), pc = n, fc = 0; fc <= n; fc++) { // count up full ones\\n        int64_t x = newFlowers - (T * fc - (ps[n] - ps[n - fc]));\\n        if (x < 0) // x remaining flowers to fill partial ones\\n            break;\\n        for (pc = min(pc, n - fc); pc > 0 && F[pc - 1] * pc - ps[pc] > x; pc--); // count down partial ones\\n        int64_t pm = pc && F[0] < T ? min<int64_t>(T - 1, (x + ps[pc]) / pc) : 0;\\n        ans = max(ans, fc * full + pm * partial);\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1932339,
                "title": "java-modularized-solution-with-dp-binary-search-o-nlogn",
                "content": "Note:\\nFor test cases beyond 72 (out of 77) adding a type cast (long) prior to calculations is necessary to ensure that correct value is picked up\\n\\n```\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        Arrays.sort(flowers);\\n\\n        int countOfFullGardens = getCountOfCompletedGardens(flowers, target);\\n        int updatedLength = flowers.length - countOfFullGardens;    \\n        // If all gardens are already full, return early\\n        if(updatedLength == 0) {\\n            return (long) full*countOfFullGardens;\\n        }\\n        \\n        long[] fillUpPartialGarden = getCountNeededForPartialGarden(flowers, updatedLength);\\n        long[] fillUpCompletedGarden = getCountNeededForCompleteGarden(flowers, updatedLength, target);\\n        \\n        long ans = 0;\\n        \\n        // Try to get the maximum number of completed gardens + max value of partial garden\\n        for(int filledGardens = 0; filledGardens <= updatedLength; filledGardens++) {\\n            long remainingFlowersCount = newFlowers; //reset in each iteration\\n            long partialCount = 0;\\n                        \\n            if(filledGardens > 0) {\\n                remainingFlowersCount -= fillUpCompletedGarden[updatedLength-filledGardens];\\n            }\\n            \\n            // If no flower remains after completing one more garden, break. No need to iterate ahead\\n            if(remainingFlowersCount < 0) {\\n                break;\\n            }\\n\\n            if(filledGardens < updatedLength) {            \\n                int indexForPartialGardens = binarySearch(fillUpPartialGarden, updatedLength, remainingFlowersCount);\\n                // Don\\'t consider completed garden again\\n                if(indexForPartialGardens > (updatedLength - 1 - filledGardens)) {\\n                    indexForPartialGardens = updatedLength - filledGardens - 1;\\n                }\\n                \\n                // Minimum number of flowers across all is flowers[indexForPartialGardens]\\n                // Divide the remaining number of flowers across all the gardens. \\n\\n                partialCount = (long) flowers[indexForPartialGardens] + (long) ((remainingFlowersCount - fillUpPartialGarden[indexForPartialGardens])/(long)(indexForPartialGardens+1));\\n                \\n                //partialCount is capped at target-1\\n                partialCount = Math.min(partialCount, target-1); \\n                \\n            }\\n            long temp = (long) (countOfFullGardens + filledGardens) * (long) full +  (long) partialCount * (long) partial;\\n            ans = Math.max(temp, ans);\\n        }\\n\\n        return ans;\\n    }\\n    \\n    // Expects sorted array of flowers and returns count of already complete gardens\\n    private int getCountOfCompletedGardens(int[] flowers, int target) {\\n        int countOfFullGardens = 0;\\n        for(int i = flowers.length - 1; i >= 0; i--) {\\n            if(flowers[i] < target)\\n                break;\\n            countOfFullGardens++;\\n        }\\n        return  countOfFullGardens;\\n    }\\n    \\n\\n    private long[] getCountNeededForPartialGarden(int[] flowers, int updatedLength) {\\n        long[] fillUpPartialGarden = new long[updatedLength];\\n        for(int i = 1; i < updatedLength; i++) {\\n            // At i, the i gardens preceding it (0 indexed) already have flowers[i-1] flowers\\n            fillUpPartialGarden[i] = (long)(flowers[i] - flowers[i-1]) *(long)i + (long)fillUpPartialGarden[i-1];\\n            \\n        }\\n        return fillUpPartialGarden;\\n    }\\n    \\n      \\n  // Returns an array where value at index i denotes the number of flowers needed so that all the length - i + 1 elements from the index onwards have completed gardens\\n    private long[] getCountNeededForCompleteGarden(int[] flowers, int updatedLength, long target) {\\n        long fillUpCompletedGarden[] = new long[updatedLength];\\n        \\n        fillUpCompletedGarden[updatedLength-1] = target - flowers[updatedLength-1];\\n        for(int i = updatedLength - 2; i >= 0; i--) {\\n            fillUpCompletedGarden[i] = (long)fillUpCompletedGarden[i+1] + (long)(target - flowers[i]); \\n        }\\n        return fillUpCompletedGarden;\\n    }\\n    \\n    // Returns the index such that nums[index] is the maximum value less than value\\n     private int binarySearch(long[] nums, int length, long value) {\\n        int low = 0;\\n        int high = length-1;\\n        int ans = low;\\n         \\n        while (low <= high) {\\n            int mid = low + (high-low)/2;\\n            if ((long) nums[mid] ==  (long) value) \\n                return mid;\\n            else if ((long) nums[mid] < (long) value) {\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else high = mid - 1;\\n        }\\n         \\n        return ans;\\n    }\\n}```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        Arrays.sort(flowers);\\n\\n        int countOfFullGardens = getCountOfCompletedGardens(flowers, target);\\n        int updatedLength = flowers.length - countOfFullGardens;    \\n        // If all gardens are already full, return early\\n        if(updatedLength == 0) {\\n            return (long) full*countOfFullGardens;\\n        }\\n        \\n        long[] fillUpPartialGarden = getCountNeededForPartialGarden(flowers, updatedLength);\\n        long[] fillUpCompletedGarden = getCountNeededForCompleteGarden(flowers, updatedLength, target);\\n        \\n        long ans = 0;\\n        \\n        // Try to get the maximum number of completed gardens + max value of partial garden\\n        for(int filledGardens = 0; filledGardens <= updatedLength; filledGardens++) {\\n            long remainingFlowersCount = newFlowers; //reset in each iteration\\n            long partialCount = 0;\\n                        \\n            if(filledGardens > 0) {\\n                remainingFlowersCount -= fillUpCompletedGarden[updatedLength-filledGardens];\\n            }\\n            \\n            // If no flower remains after completing one more garden, break. No need to iterate ahead\\n            if(remainingFlowersCount < 0) {\\n                break;\\n            }\\n\\n            if(filledGardens < updatedLength) {            \\n                int indexForPartialGardens = binarySearch(fillUpPartialGarden, updatedLength, remainingFlowersCount);\\n                // Don\\'t consider completed garden again\\n                if(indexForPartialGardens > (updatedLength - 1 - filledGardens)) {\\n                    indexForPartialGardens = updatedLength - filledGardens - 1;\\n                }\\n                \\n                // Minimum number of flowers across all is flowers[indexForPartialGardens]\\n                // Divide the remaining number of flowers across all the gardens. \\n\\n                partialCount = (long) flowers[indexForPartialGardens] + (long) ((remainingFlowersCount - fillUpPartialGarden[indexForPartialGardens])/(long)(indexForPartialGardens+1));\\n                \\n                //partialCount is capped at target-1\\n                partialCount = Math.min(partialCount, target-1); \\n                \\n            }\\n            long temp = (long) (countOfFullGardens + filledGardens) * (long) full +  (long) partialCount * (long) partial;\\n            ans = Math.max(temp, ans);\\n        }\\n\\n        return ans;\\n    }\\n    \\n    // Expects sorted array of flowers and returns count of already complete gardens\\n    private int getCountOfCompletedGardens(int[] flowers, int target) {\\n        int countOfFullGardens = 0;\\n        for(int i = flowers.length - 1; i >= 0; i--) {\\n            if(flowers[i] < target)\\n                break;\\n            countOfFullGardens++;\\n        }\\n        return  countOfFullGardens;\\n    }\\n    \\n\\n    private long[] getCountNeededForPartialGarden(int[] flowers, int updatedLength) {\\n        long[] fillUpPartialGarden = new long[updatedLength];\\n        for(int i = 1; i < updatedLength; i++) {\\n            // At i, the i gardens preceding it (0 indexed) already have flowers[i-1] flowers\\n            fillUpPartialGarden[i] = (long)(flowers[i] - flowers[i-1]) *(long)i + (long)fillUpPartialGarden[i-1];\\n            \\n        }\\n        return fillUpPartialGarden;\\n    }\\n    \\n      \\n  // Returns an array where value at index i denotes the number of flowers needed so that all the length - i + 1 elements from the index onwards have completed gardens\\n    private long[] getCountNeededForCompleteGarden(int[] flowers, int updatedLength, long target) {\\n        long fillUpCompletedGarden[] = new long[updatedLength];\\n        \\n        fillUpCompletedGarden[updatedLength-1] = target - flowers[updatedLength-1];\\n        for(int i = updatedLength - 2; i >= 0; i--) {\\n            fillUpCompletedGarden[i] = (long)fillUpCompletedGarden[i+1] + (long)(target - flowers[i]); \\n        }\\n        return fillUpCompletedGarden;\\n    }\\n    \\n    // Returns the index such that nums[index] is the maximum value less than value\\n     private int binarySearch(long[] nums, int length, long value) {\\n        int low = 0;\\n        int high = length-1;\\n        int ans = low;\\n         \\n        while (low <= high) {\\n            int mid = low + (high-low)/2;\\n            if ((long) nums[mid] ==  (long) value) \\n                return mid;\\n            else if ((long) nums[mid] < (long) value) {\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else high = mid - 1;\\n        }\\n         \\n        return ans;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1932314,
                "title": "c-o-nlogn-suffix-sum-binary-search",
                "content": "1. sort flowers array in descending order\\n2. ss[i]: suffix sum array, it means in order to make [i, n-1] same flowers as flower[i], how many extra flowers need to be added\\n3. iterate from 0 to n-1, [0,i) are full flowers, [i,n-1] are partial flowers\\n4. use binary search to calculate minimum number of flowers (Math.Min(target-1, f[h] + (nf - ss[h])/(n-h));)\\n* be careful of overflow and the fact that minimum must be smaller than target.\\n\\n```\\npublic long MaximumBeauty(int[] f, long nf, int target, int full, int partial) {\\n\\n\\tint n = f.Length;\\n\\n\\tArray.Sort(f, (x,y)=>{\\n\\t\\treturn y.CompareTo(x);\\n\\t});\\n\\n\\t// reachable idx\\n\\tlong[] ss = new long[n];\\n\\tfor(int j=n-2; j>=0; j--) {\\n\\t\\tss[j] = ss[j+1] + ((long)(f[j] - f[j+1])) * (n - 1 - j);\\n\\t}\\n\\n\\tint i=0;\\n\\twhile(i<n && f[i] >= target) {\\n\\t\\ti++;            \\n\\t}\\n\\n\\tlong res = 0;\\n\\tfor(; i<n && nf > 0; i++) {\\n\\t\\tint h = hb(i, nf, ss);\\n\\n\\t\\tlong mn = Math.Min(target-1, f[h] + (nf - ss[h])/(n-h));\\n\\t\\tres = Math.Max(res, (long)i*(long)full + mn*(long)partial);\\n\\n\\t\\tnf -= target - f[i];\\n\\t}\\n\\tif (nf >= 0) {\\n\\t\\tres = Math.Max(res, (long)n*(long)full);\\n\\t}\\n\\n\\treturn res;\\n}\\n\\nint hb(int l, long nf, long[] ss) {\\n\\tint h = ss.Length - 1;\\n\\n\\twhile(l < h) {\\n\\t\\tint m = (l + h) / 2;\\n\\t\\tif (nf < ss[m]) {\\n\\t\\t\\tl = m + 1;\\n\\t\\t} else {\\n\\t\\t\\th = m;\\n\\t\\t}\\n\\t}\\n\\n\\treturn h;\\n}\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\npublic long MaximumBeauty(int[] f, long nf, int target, int full, int partial) {\\n\\n\\tint n = f.Length;\\n\\n\\tArray.Sort(f, (x,y)=>{\\n\\t\\treturn y.CompareTo(x);\\n\\t});\\n\\n\\t// reachable idx\\n\\tlong[] ss = new long[n];\\n\\tfor(int j=n-2; j>=0; j--) {\\n\\t\\tss[j] = ss[j+1] + ((long)(f[j] - f[j+1])) * (n - 1 - j);\\n\\t}\\n\\n\\tint i=0;\\n\\twhile(i<n && f[i] >= target) {\\n\\t\\ti++;            \\n\\t}\\n\\n\\tlong res = 0;\\n\\tfor(; i<n && nf > 0; i++) {\\n\\t\\tint h = hb(i, nf, ss);\\n\\n\\t\\tlong mn = Math.Min(target-1, f[h] + (nf - ss[h])/(n-h));\\n\\t\\tres = Math.Max(res, (long)i*(long)full + mn*(long)partial);\\n\\n\\t\\tnf -= target - f[i];\\n\\t}\\n\\tif (nf >= 0) {\\n\\t\\tres = Math.Max(res, (long)n*(long)full);\\n\\t}\\n\\n\\treturn res;\\n}\\n\\nint hb(int l, long nf, long[] ss) {\\n\\tint h = ss.Length - 1;\\n\\n\\twhile(l < h) {\\n\\t\\tint m = (l + h) / 2;\\n\\t\\tif (nf < ss[m]) {\\n\\t\\t\\tl = m + 1;\\n\\t\\t} else {\\n\\t\\t\\th = m;\\n\\t\\t}\\n\\t}\\n\\n\\treturn h;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1932293,
                "title": "c-binary-search-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll unsigned long long int\\n    int possible(ll srt,ll end,ll left,ll target,vector<int> &flowers,vector<ll> &prefix){\\n        if(srt>end)return 0;\\n        \\n        ll n = flowers.size();\\n        ll l = flowers[end];          // min value in srt...end and minimum can\\'t be decreased than min value \\n        ll r = target-1;     // maximum value. we want to change number to atmost target-1. if we make target it becomes complete garden,\\n        ll ans = l;\\n        ll idx;\\n        while(l<=r){\\n            ll mid = l+(r-l)/2;\\n\\t\\t\\t\\n\\t\\t\\t// Finding index in flowers where flowers[idx] > mid\\n             auto it = upper_bound(flowers.rbegin(),flowers.rend(),mid);\\n            \\n            if(it==flowers.rend()){\\n                idx = srt-1;\\n            }else{\\n                idx = n-1-(it-flowers.rbegin());\\n            }\\n         \\n            // from idx+1...end all numbers will be smaller or equal to mid\\n\\t\\t\\t\\n\\t\\t\\t// This is the amount required to make all numbers in range idx+1..end to mid\\n            long long int change = mid*(end-idx)-(prefix[end+1]-prefix[idx+1]);\\n\\t\\t\\t\\n\\t\\t\\t// If change is less than flowers left we can increase every value which is less than mid, to mid and hence minimum in array becomes mid.\\n            if(change<=left){\\n                l = mid+1;\\n                ans = mid;\\n            }else{\\n                r = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        ll n = flowers.size();\\n        sort(flowers.begin(),flowers.end(),greater<int>());\\n        vector<ll> prefix(n+1,0);\\n        \\n        for(int i=1;i<=n;i++){\\n            prefix[i] = prefix[i-1]+flowers[i-1];\\n        }\\n        \\n        \\n        long long int k = newFlowers;\\n        ll score = 0;\\n        ll mul = 1;\\n\\t\\t\\n\\t\\t\\n        for(int i=0;i<n && k>=0;i++){\\n\\t\\t\\n\\t\\t// if garden is already full,we dont need to anything,just add up score\\n            if(flowers[i]>=target){\\n                score+=full;\\n                continue;\\n            }\\n\\t\\t\\t\\n            // Finding  maximum \"minimum value\" in leftover gardens by using the leftover flowers we have.\\n            ll mipossible = possible(i,n-1,k,target,flowers,prefix);\\n            \\n\\t\\t\\tscore = max(score,mul*i*full+mipossible*partial);\\n\\t\\t\\t\\n            // making garden[i] complete by using up flowers we have\\n\\t\\t\\tk-=(target-flowers[i]);\\n\\t\\t\\t\\n\\t\\t\\t// change flowers[i] to target as we increased flowers in i th garden\\n            flowers[i] = target;\\n        }\\n        \\n        if(k>=0)score = max(score,mul*n*full);\\n        \\n        return score;\\n    }\\n};\\n```\\n\\n*Time Complexity:   O(Nlog(target)log(N))*",
                "solutionTags": [
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll unsigned long long int\\n    int possible(ll srt,ll end,ll left,ll target,vector<int> &flowers,vector<ll> &prefix){\\n        if(srt>end)return 0;\\n        \\n        ll n = flowers.size();\\n        ll l = flowers[end];          // min value in srt...end and minimum can\\'t be decreased than min value \\n        ll r = target-1;     // maximum value. we want to change number to atmost target-1. if we make target it becomes complete garden,\\n        ll ans = l;\\n        ll idx;\\n        while(l<=r){\\n            ll mid = l+(r-l)/2;\\n\\t\\t\\t\\n\\t\\t\\t// Finding index in flowers where flowers[idx] > mid\\n             auto it = upper_bound(flowers.rbegin(),flowers.rend(),mid);\\n            \\n            if(it==flowers.rend()){\\n                idx = srt-1;\\n            }else{\\n                idx = n-1-(it-flowers.rbegin());\\n            }\\n         \\n            // from idx+1...end all numbers will be smaller or equal to mid\\n\\t\\t\\t\\n\\t\\t\\t// This is the amount required to make all numbers in range idx+1..end to mid\\n            long long int change = mid*(end-idx)-(prefix[end+1]-prefix[idx+1]);\\n\\t\\t\\t\\n\\t\\t\\t// If change is less than flowers left we can increase every value which is less than mid, to mid and hence minimum in array becomes mid.\\n            if(change<=left){\\n                l = mid+1;\\n                ans = mid;\\n            }else{\\n                r = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        ll n = flowers.size();\\n        sort(flowers.begin(),flowers.end(),greater<int>());\\n        vector<ll> prefix(n+1,0);\\n        \\n        for(int i=1;i<=n;i++){\\n            prefix[i] = prefix[i-1]+flowers[i-1];\\n        }\\n        \\n        \\n        long long int k = newFlowers;\\n        ll score = 0;\\n        ll mul = 1;\\n\\t\\t\\n\\t\\t\\n        for(int i=0;i<n && k>=0;i++){\\n\\t\\t\\n\\t\\t// if garden is already full,we dont need to anything,just add up score\\n            if(flowers[i]>=target){\\n                score+=full;\\n                continue;\\n            }\\n\\t\\t\\t\\n            // Finding  maximum \"minimum value\" in leftover gardens by using the leftover flowers we have.\\n            ll mipossible = possible(i,n-1,k,target,flowers,prefix);\\n            \\n\\t\\t\\tscore = max(score,mul*i*full+mipossible*partial);\\n\\t\\t\\t\\n            // making garden[i] complete by using up flowers we have\\n\\t\\t\\tk-=(target-flowers[i]);\\n\\t\\t\\t\\n\\t\\t\\t// change flowers[i] to target as we increased flowers in i th garden\\n            flowers[i] = target;\\n        }\\n        \\n        if(k>=0)score = max(score,mul*n*full);\\n        \\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576602,
                "content": [
                    {
                        "username": "f1re",
                        "content": "Case 1: Full score >= Partial score\\n\\n1. Sort the gardens in descending order.\\n2. Add all the full gardens to score\\n3. Keep adding flowers to the gardens with less flowers than target.\\n4. break when you can\\'t add any.\\n5. Add the remaining partial gardens to a list and perform binary search to find the min no of flowers after adding remaining new flowers.\\n\\nCase 2: Partial score > Full score:\\nRepeat step5 of case1."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "I think case 2 wont work for \\n [1,1,1,1]  newFlowers=4,target=3,full=5,partial=6 . Answer will be 16.\\n I think unless the partial -full is too large , we have to take at least one full. For the below one where the difference is large, we wont take any full. \\n[1,1,1,1]  newFlowers=4,target=3,full=2,partial=10 . Answer will be 20."
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Rounds to Complete All Tasks",
        "question_content": "<p>You are given a <strong>0-indexed</strong> integer array <code>tasks</code>, where <code>tasks[i]</code> represents the difficulty level of a task. In each round, you can complete either 2 or 3 tasks of the <strong>same difficulty level</strong>.</p>\n\n<p>Return <em>the <strong>minimum</strong> rounds required to complete all the tasks, or </em><code>-1</code><em> if it is not possible to complete all the tasks.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> tasks = [2,2,3,3,2,4,4,4,4,4]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> To complete all the tasks, a possible plan is:\n- In the first round, you complete 3 tasks of difficulty level 2. \n- In the second round, you complete 2 tasks of difficulty level 3. \n- In the third round, you complete 3 tasks of difficulty level 4. \n- In the fourth round, you complete 2 tasks of difficulty level 4.  \nIt can be shown that all the tasks cannot be completed in fewer than 4 rounds, so the answer is 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> tasks = [2,3,3]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> There is only 1 task of difficulty level 2, but in each round, you can only complete either 2 or 3 tasks of the same difficulty level. Hence, you cannot complete all the tasks, and the answer is -1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tasks.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= tasks[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1955622,
                "title": "java-c-python-sum-up-freq-2-3",
                "content": "# **Intuition**\\nIf the frequence `freq` of a level is 1,\\nthen it is not possible to complete all the tasks.\\n\\nOtherwise, we need to decompose `freq = 3 tasks + 3 tasks + .... + 2 tasks`,\\nwith the minimum number of 3 and 2.\\n\\nWe need a lot a 3-tasks, and plus one or two 2-tasks.\\n<br>\\n\\n# **Explanation**\\nTasks with same difficulty level can be done together,\\nin group of 2-tasks or 3-tasks.\\n\\nSo we count the frequnce `freq` for each level.\\n\\nIf `freq = 1`, not possible, return -1\\nIf `freq = 2`, needs one 2-tasks\\nIf `freq = 3`, needs one 3-tasks\\nIf `freq = 3k`, `freq = 3 * k`, needs `k` batchs.\\nIf `freq = 3k + 1`, `freq = 3 * (k - 1) + 2 + 2`, needs `k + 1` batchs.\\nIf `freq = 3k + 2`, `freq = 3 * k + 2`, needs `k + 1` batchs.\\n\\nTo summarize, needs `(freq + 2) / 3` batch, \\nreturn the sum of `(freq + 2) / 3` if possible.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public int minimumRounds(int[] A) {\\n        HashMap<Integer, Integer> count = new HashMap<>();\\n        for (int a : A)\\n            count.put(a, count.getOrDefault(a, 0) + 1);\\n        int res = 0;\\n        for (int freq : count.values()) {\\n            if (freq == 1) return -1;\\n            res += (freq + 2) / 3;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minimumRounds(vector<int>& A) {\\n        unordered_map<int, int> count;\\n        int res = 0, freq1;\\n        for (int a: A)\\n            ++count[a];\\n        for (auto& it: count) {\\n            if (it.second == 1) return -1;\\n            res += (it.second + 2) / 3;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minimumRounds(self, tasks):\\n        freq = Counter(tasks).values()\\n        return -1 if 1 in freq else sum((a + 2) // 3 for a in freq)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int minimumRounds(int[] A) {\\n        HashMap<Integer, Integer> count = new HashMap<>();\\n        for (int a : A)\\n            count.put(a, count.getOrDefault(a, 0) + 1);\\n        int res = 0;\\n        for (int freq : count.values()) {\\n            if (freq == 1) return -1;\\n            res += (freq + 2) / 3;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int minimumRounds(vector<int>& A) {\\n        unordered_map<int, int> count;\\n        int res = 0, freq1;\\n        for (int a: A)\\n            ++count[a];\\n        for (auto& it: count) {\\n            if (it.second == 1) return -1;\\n            res += (it.second + 2) / 3;\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def minimumRounds(self, tasks):\\n        freq = Counter(tasks).values()\\n        return -1 if 1 in freq else sum((a + 2) // 3 for a in freq)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2995189,
                "title": "easiest-c-solution-with-detailed-explanation",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Intuition:** question revolves around frequency so we will use map \\n\\n**Approach:**\\nFrom observation, we can see that there\\'s only 3 possible outcomes.\\n1. If the frequency is 1, the task cannot be performed so we return -1.\\n2. If the frequency is 3, the task can be performed and we return frequency/3.\\n3. Now if the frequency is not completely divisible by 3, then the possible remainders are 1 and 2. Lets check them out:\\n* If remainder is 1, i.e, lets take 7 frequency, then \\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E the groups are something like this \"\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\" \"\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\" \"\\uD83D\\uDD2E\", i.e, one \\uD83D\\uDD2E is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\" \"\\uD83D\\uDD2E\\uD83D\\uDD2E\" \"\\uD83D\\uDD2E\\uD83D\\uDD2E\", i.e, one is added to the division by 3.\\n* If remainder is 2, i.e, lets take 8 frequency, then \\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E the groups are something like this \"\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\" \"\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\" \"\\uD83D\\uDD2E\\uD83D\\uDD2E\", i.e, two \\uD83D\\uDD2E are left so the solution is to just add 1,i.e, one group of two to the solution.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<tasks.size();i++){\\n            mp[tasks[i]]++;\\n        }\\n        \\n        int output=0;\\n        \\n        for (auto freq : mp){\\n            if(freq.second==1)\\n                return -1;\\n            if(freq.second%3==0){\\n                output += freq.second/3;\\n            }\\n            else{\\n                output += freq.second/3 + 1;\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```\\n\\n**Time Complexity** => `O(N)`\\n**Space Complexity** => `O(N)`\\n\\n![image](https://assets.leetcode.com/users/images/12c08d97-9a80-4e62-8ff1-bd489ffd948a_1672802834.9151857.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<tasks.size();i++){\\n            mp[tasks[i]]++;\\n        }\\n        \\n        int output=0;\\n        \\n        for (auto freq : mp){\\n            if(freq.second==1)\\n                return -1;\\n            if(freq.second%3==0){\\n                output += freq.second/3;\\n            }\\n            else{\\n                output += freq.second/3 + 1;\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995202,
                "title": "java-solution-with-2-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    // This function returns the minimum number of rounds needed to\\n    // process all tasks in the given array of tasks.\\n    public int minimumRounds(int[] tasks) {\\n\\n        // Create a HashMap to store the count of each task\\n        HashMap<Integer, Integer> getCount = new HashMap<>();\\n\\n        // Iterate through the tasks array and store the count of each task\\n        // in the HashMap\\n        for (int t : tasks) {\\n            getCount.put(t, getCount.getOrDefault(t, 0) + 1);\\n        }\\n\\n        // Initialize a result variable to 0\\n        int result = 0;\\n\\n        // Iterate through the values in the HashMap (which represent the counts of the tasks)\\n        for (int count : getCount.values()) {\\n            // If a task has a count of 1, it cannot be grouped with other tasks\\n            // and so we return -1\\n            if (count == 1) return -1;\\n\\n            // Add the number of rounds needed to process the tasks with count greater than or equal to 3\\n            result += count / 3;\\n\\n            // If there are any tasks left with count less than 3, we need an additional round\\n            // to process these tasks\\n            if(count % 3 != 0) result++;\\n        }\\n\\n        // Return the total number of rounds needed to process all tasks\\n        return result;\\n    }\\n}\\n\\n```\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        // Sort the tasks array in ascending order\\n        Arrays.sort(tasks);\\n        int result = 0, count = 0;\\n        // Iterate through each task\\n        for (int i = 0; i < tasks.length; i++) {\\n            // Increment the count of tasks with the same value\\n            count++;\\n            // If we have reached the last task or the current task is different from the next task\\n            if (i == tasks.length - 1 || tasks[i] != tasks[i + 1]) {\\n                // If there is only one task with this value, we cannot create groups of 3\\n                // and we return -1\\n                if (count == 1) {\\n                    return -1;\\n                }\\n                // Add the number of full groups of 3 we can create from the tasks with this value\\n                result += count / 3;\\n                // If there are remaining tasks that cannot be included in a group of 3,\\n                // we need one more round to process these tasks\\n                if(count % 3 != 0) result++;\\n                // Reset the count for the next set of tasks\\n                count = 0;\\n           }\\n        }\\n        // Return the total number of rounds needed\\n        return result;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // This function returns the minimum number of rounds needed to\\n    // process all tasks in the given array of tasks.\\n    public int minimumRounds(int[] tasks) {\\n\\n        // Create a HashMap to store the count of each task\\n        HashMap<Integer, Integer> getCount = new HashMap<>();\\n\\n        // Iterate through the tasks array and store the count of each task\\n        // in the HashMap\\n        for (int t : tasks) {\\n            getCount.put(t, getCount.getOrDefault(t, 0) + 1);\\n        }\\n\\n        // Initialize a result variable to 0\\n        int result = 0;\\n\\n        // Iterate through the values in the HashMap (which represent the counts of the tasks)\\n        for (int count : getCount.values()) {\\n            // If a task has a count of 1, it cannot be grouped with other tasks\\n            // and so we return -1\\n            if (count == 1) return -1;\\n\\n            // Add the number of rounds needed to process the tasks with count greater than or equal to 3\\n            result += count / 3;\\n\\n            // If there are any tasks left with count less than 3, we need an additional round\\n            // to process these tasks\\n            if(count % 3 != 0) result++;\\n        }\\n\\n        // Return the total number of rounds needed to process all tasks\\n        return result;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        // Sort the tasks array in ascending order\\n        Arrays.sort(tasks);\\n        int result = 0, count = 0;\\n        // Iterate through each task\\n        for (int i = 0; i < tasks.length; i++) {\\n            // Increment the count of tasks with the same value\\n            count++;\\n            // If we have reached the last task or the current task is different from the next task\\n            if (i == tasks.length - 1 || tasks[i] != tasks[i + 1]) {\\n                // If there is only one task with this value, we cannot create groups of 3\\n                // and we return -1\\n                if (count == 1) {\\n                    return -1;\\n                }\\n                // Add the number of full groups of 3 we can create from the tasks with this value\\n                result += count / 3;\\n                // If there are remaining tasks that cannot be included in a group of 3,\\n                // we need one more round to process these tasks\\n                if(count % 3 != 0) result++;\\n                // Reset the count for the next set of tasks\\n                count = 0;\\n           }\\n        }\\n        // Return the total number of rounds needed\\n        return result;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955360,
                "title": "easy-math-implementation-c",
                "content": "If you think about this question, you will get to know that actually there are only three possibility to this question.\\nLets take those three possibility into account:\\n1. If the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\n2. If the frequency is directly divided by 3, then we return the frequency/3.\\n3. If the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\n\\t* \\tIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\n\\t* \\tIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\n\\nFor calculating the frequency we have to use the hashmap.\\n\\n**Hope you get it now :)**\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int> hm;\\n        for(int i=0;i<tasks.size();i++){\\n            hm[tasks[i]]++;\\n        }\\n        int freq,ans=0;\\n        for (auto i : hm){\\n            freq = i.second;\\n            if(freq==1)\\n                return -1;\\n            if(freq%3==0){\\n                ans += freq/3;\\n            }\\n            else{\\n                ans += freq/3 + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int> hm;\\n        for(int i=0;i<tasks.size();i++){\\n            hm[tasks[i]]++;\\n        }\\n        int freq,ans=0;\\n        for (auto i : hm){\\n            freq = i.second;\\n            if(freq==1)\\n                return -1;\\n            if(freq%3==0){\\n                ans += freq/3;\\n            }\\n            else{\\n                ans += freq/3 + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994730,
                "title": "python3-greedy-approach-one-liner-explained",
                "content": "\\n**What the problem is asking:**\\n(1) Since at each round we can only finish tasks at the same difficulty level, we count the frequency of each number in the tasks first.\\n(2) For each frequency, we need to decide:\\n - Is it possible to bring it down to 0 by only subtracting 2 or 3?\\n - What\\'s the minimum round of only subtracting 2 or 3 to bring it down to 0?\\n\\n**Observations:**\\n(1) If it is 1, it is impossible to bring it to 0, so return -1. Think it this way, if the number is even, we can always bring it to zero by subtracting 2s. If the number is odd and greater than 2, we can always subtract 3 from it to make it even, and then make it to zero by subtracting 2s\\n(2) If it is 2, we just need 1 round (subtract a 2) to bring it to 0.\\n(3) If it is greater than 2, we want to subtract 3 as many times as possible but making sure the leftover is still divisible by 2. Here is the trick:\\n - it is import to note that the leftover can never be more than 4, this is because if the leftover is 5, we can subtract a 3 and the leftover (2) is still divisable by 2, and if the leftover is 6, we can simply bring it down to 0 by subtracting 3 two times.\\n\\n**Algorithm:**\\n - Count the frequency of unique number in ```tasks```\\n - For each frequency:\\n    - if ```freq``` is 1, return -1\\n    - if ```(freq-2) % 3 == 0```, we need ```(freq-2) / 3 + 1``` rounds to bring it to 0.\\n    - if ```(freq-4) % 3 == 0```, we need ```(freq-4) / 3 + 2``` rounds.\\n    - if ```freq % 3 == 0```, we need ```freq / 3``` rounds.\\n    - We have only one case left, which is using 2 all the way, so we need ```freq / 2``` rounds.\\n\\n**Solution 1**\\n```python\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        frequency = Counter(tasks)\\n        res = 0\\n        for freq in frequency.values():\\n            if freq == 1:\\n                return -1\\n            elif (freq-2) % 3 == 0:\\n                res += (freq-2) // 3 + 1\\n            elif (freq - 4) % 3 == 0:\\n                res += (freq - 4) // 3 +2\\n            elif freq % 3 == 0:\\n                res += freq // 3\\n            else:\\n                res += freq // 2\\n        return res\\n```\\n\\n**Solution 2**: The code can be further optimized, basically we just need ceil(freq/3) for all valid cases.\\n\\nExamples:\\nleftover = 2, we need (freq-2) / 3 + 1 == ceil(freq/3)\\nleftover = 4, we need (freq-4) / 3 + 2 == ceil(freq/3)\\n\\n```python\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        frequency = Counter(tasks)\\n        res = 0\\n        for freq in frequency.values():\\n            if freq == 1:\\n                return -1\\n            res += ceil(freq/3)\\n        return res\\n```\\n\\n**Solution 3:** one-liner (Only for the sake of making it one line...)\\n```python\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        return sum(ceil(freq/3) for freq in Counter(tasks).values()) if 1 not in Counter(tasks).values() else -1\\n```\\n\\n**Solution 4:** Another interesting and better one-liner from [seibel](https://leetcode.com/seibel/)\\n```python\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        return max(-1,sum(ceil(freq/3) if freq>1 else -inf for freq in Counter(tasks).values()))\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```tasks```\n```freq```\n```(freq-2) % 3 == 0```\n```(freq-2) / 3 + 1```\n```(freq-4) % 3 == 0```\n```(freq-4) / 3 + 2```\n```freq % 3 == 0```\n```freq / 3```\n```freq / 2```\n```python\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        frequency = Counter(tasks)\\n        res = 0\\n        for freq in frequency.values():\\n            if freq == 1:\\n                return -1\\n            elif (freq-2) % 3 == 0:\\n                res += (freq-2) // 3 + 1\\n            elif (freq - 4) % 3 == 0:\\n                res += (freq - 4) // 3 +2\\n            elif freq % 3 == 0:\\n                res += freq // 3\\n            else:\\n                res += freq // 2\\n        return res\\n```\n```python\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        frequency = Counter(tasks)\\n        res = 0\\n        for freq in frequency.values():\\n            if freq == 1:\\n                return -1\\n            res += ceil(freq/3)\\n        return res\\n```\n```python\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        return sum(ceil(freq/3) for freq in Counter(tasks).values()) if 1 not in Counter(tasks).values() else -1\\n```\n```python\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        return max(-1,sum(ceil(freq/3) if freq>1 else -inf for freq in Counter(tasks).values()))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995198,
                "title": "java-o-n-hashmap",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        int count = 0; HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int x : tasks)\\n            map.put(x,map.getOrDefault(x,0)+1);\\n        for(int x : map.keySet())\\n            if(map.get(x)==1)return -1;\\n            else{\\n                count+=map.get(x)/3;\\n                if(map.get(x)%3!=0)count++;\\n            }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        int count = 0; HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int x : tasks)\\n            map.put(x,map.getOrDefault(x,0)+1);\\n        for(int x : map.keySet())\\n            if(map.get(x)==1)return -1;\\n            else{\\n                count+=map.get(x)/3;\\n                if(map.get(x)%3!=0)count++;\\n            }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956121,
                "title": "java-o-n-easy-solution-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Each round, we can complete either 2 or 3 tasks of the same difficulty level\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a map to store the key `task` and the value `number of tasks`\\n- Loop the map entries and take as many 3\\'s as possible\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n    - $$O(n)$$ Looping task array\\n    - $$O(n)$$ Looping the hashmap\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ - for the hashmap\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        int round = 0;\\n        Map<Integer, Integer> taskMap = new HashMap<>(); // map of <task,  number of each task>\\n        for (int i = 0; i < tasks.length; i++) {\\n            taskMap.put(tasks[i], taskMap.getOrDefault(tasks[i], 0) + 1);\\n        }\\n        \\n        for (Map.Entry<Integer, Integer> entry : taskMap.entrySet()) {\\n            if (entry.getValue() == 1) {\\n                return -1; // we cannot complete if there is only 1 task\\n            }\\n\\t\\t\\t// try to take as many 3\\'s as possible\\n            round += entry.getValue() / 3; \\n\\t\\t\\t\\n            /*\\n\\t\\t\\t\\tWe can have 1 or 2 tasks remaining. We\\'re not supposed to take task of count 1, but we can \\'borrow\\' 1 from the previous\\n\\t\\t\\t\\tex. [5,5,5,5,5,5,5] -> [5,5,5][5,5,5][5]\\n\\t\\t\\t\\tIn this example, treat the last [5,5,5], [5] as [5,5], [5,5]\\n            */\\n            if (entry.getValue() % 3 != 0) { \\n                round++; \\n            }\\n        }\\n        return round;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        int round = 0;\\n        Map<Integer, Integer> taskMap = new HashMap<>(); // map of <task,  number of each task>\\n        for (int i = 0; i < tasks.length; i++) {\\n            taskMap.put(tasks[i], taskMap.getOrDefault(tasks[i], 0) + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2995836,
                "title": "c-easy-fully-explained-map",
                "content": "\\uD83C\\uDFA5\\uD83D\\uDD25 Exciting News! Join my Coding Journey! Subscribe Now! \\uD83D\\uDD25\\uD83C\\uDFA5\\n\\n\\uD83D\\uDD17 Link in the leetcode profile \\n\\nNew coding channel alert! \\uD83D\\uDE80\\uD83D\\uDCBB Subscribe to unlock amazing coding content and tutorials. Help me reach 1K subs to start posting more videos! Join now! \\uD83C\\uDF1F\\uD83D\\uDCAA\\n\\nThanks for your support! \\uD83D\\uDE4F\\n\\n# Approach\\n1.we have to count freq of each task[i]\\nFor that we will use unoredered map and count freq of the task\\n2.if we have single task ->**freq[task[i]]==1, then return -1**\\nwhy -1?->**bcz we have to complete 2 or 3 task in one time**\\nif task is multiple of three then we can do three task together\\n**then add freq[task[i]]/3 to ans**\\notherwise add **freq[task[i]]/3 +1** to ans\\nlets suppose we have 2 task then we can do in one go\\nif we have 4 task then we will do 2,2\\nif we have 5 task then we will do 3,2\\n\\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n- Space complexity:O(N)\\n\\n***If you like the solution please upvote***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int ans=0;\\n        unordered_map<int,int>freq;\\n        for(int i=0;i<tasks.size();i++){\\n            freq[tasks[i]]++;\\n        }\\n        for(auto it:freq){\\n            int k=it.second;\\n            if(k==1)return -1;\\n            if(k%3==0)\\n            ans+=k/3;\\n            else \\n            ans+=(k/3)+1;\\n        }\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int ans=0;\\n        unordered_map<int,int>freq;\\n        for(int i=0;i<tasks.size();i++){\\n            freq[tasks[i]]++;\\n        }\\n        for(auto it:freq){\\n            int k=it.second;\\n            if(k==1)return -1;\\n            if(k%3==0)\\n            ans+=k/3;\\n            else \\n            ans+=(k/3)+1;\\n        }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995109,
                "title": "python-3-1-6-lines-w-example-t-m-97-32",
                "content": "Here\\'s the plan:\\n- Use`Counter` to determine the count`n`of each integer in the array.\\n- Determine whether`n = 1`for any integer. If so,`return -1`.\\n- For the count`n`of each integer in the array, add`n//3`to`ans`, plus 1 if`n%3 > 0`\\n- Return`ans`\\n```\\nclass Solution:\\n    def minimumRounds(self, tasks: list[int]) -> int:\\n                                            # Example: tasks = [2,2,3,3,2,4,4,4,4,4,4,4]\\n\\n        tasks = Counter(tasks)              #          tasks = {3:2, 2:3, 4:5}\\n        \\n        if 1 in tasks.values(): return -1   # <-- no solution if there\\'s a singleton\\n\\n        ans = 0                             # tasks.values() = [2, 3, 5]     \\n        for n in tasks.values():\\n            ans+= n//3 + bool(n%3)          # ans  = (2//3+True) + (3//3+False) + (5//3+True)\\n                                            #      = ( 0  +  1  ) + (  1 +  0 ) + (1   +  1 )\\n        return  ans                         #      = 4  <-- return\\n```\\nAnd, if you must, here\\'s a one-liner:\\n```\\nclass Solution:\\n    def minimumRounds(self, tasks: list[int]) -> int:\\n\\n        return sum(n//3 + bool(n%3) for n in Counter(tasks).values()) if 1 not in Counter(tasks).values() else -1\\n```\\n[https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/682458298/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRounds(self, tasks: list[int]) -> int:\\n                                            # Example: tasks = [2,2,3,3,2,4,4,4,4,4,4,4]\\n\\n        tasks = Counter(tasks)              #          tasks = {3:2, 2:3, 4:5}\\n        \\n        if 1 in tasks.values(): return -1   # <-- no solution if there\\'s a singleton\\n\\n        ans = 0                             # tasks.values() = [2, 3, 5]     \\n        for n in tasks.values():\\n            ans+= n//3 + bool(n%3)          # ans  = (2//3+True) + (3//3+False) + (5//3+True)\\n                                            #      = ( 0  +  1  ) + (  1 +  0 ) + (1   +  1 )\\n        return  ans                         #      = 4  <-- return\\n```\n```\\nclass Solution:\\n    def minimumRounds(self, tasks: list[int]) -> int:\\n\\n        return sum(n//3 + bool(n%3) for n in Counter(tasks).values()) if 1 not in Counter(tasks).values() else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994822,
                "title": "java-code-using-hash-map",
                "content": "# Intuition\\nIf Frequency is less than 2 then we can\\'t complete the taks if Frequency is 2 then we can do it in one round else if Frequency is greater or equal to 3 then we can make combination of 2 or 3 and done it the number of rounds needed will always will be ceiling value of Frequency/3\\n\\n# Approach\\n\\ntake int ans = 0,\\nwe are storing frequency of the element in the hash map and then we will loop through map if the frequncy is less than 2 then we can\\'t complete the task as we have to do task in group of 2 or 3 that\\'s why we will return -1\\nif frequncy is 2 then we can add 1 to the ans\\nelse we can take the ceiling value and add it to the answer variable.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity : O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] arr) {\\n        Map<Integer,Integer>map = new HashMap<>();\\n        for(int i:arr){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        }\\n        int ans = 0;\\n        for(Integer val:map.values()){\\n            int freq= val;\\n            if(freq<2){\\n                return -1;\\n            }\\n            else if(freq==2){\\n                ans+=1;\\n            }\\n            else{\\n                double res = freq/3.0;\\n                ans+=Math.ceil(res);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nHappy Coding \\n\\nRadhe Radhe \\u2764\\uFE0F\\uD83D\\uDD49\\uFE0F",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] arr) {\\n        Map<Integer,Integer>map = new HashMap<>();\\n        for(int i:arr){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        }\\n        int ans = 0;\\n        for(Integer val:map.values()){\\n            int freq= val;\\n            if(freq<2){\\n                return -1;\\n            }\\n            else if(freq==2){\\n                ans+=1;\\n            }\\n            else{\\n                double res = freq/3.0;\\n                ans+=Math.ceil(res);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955562,
                "title": "java-python-3-o-n-greedy-codes-w-brief-explanation-and-analysis",
                "content": "\\n1. If there is ONLY one task for a certain level, then impossible and return `-1`;\\n2. Otherwise, we can always complete the tasks; Use `% 3` to check the occurrence (denote as `v`) of the tasks for each level: \\na.) if the result is `0`, we group them `3` by `3` and need at least `v / 3` rounds; \\nb.) if the result is `1`, `v = 3m + 1 = 3(m - 1) + 4 = 3(m - 1) + 2 + 2`, we can group them into `m - 1` 3-groups and `2` 2-groups, totally `m + 1 = 1 + v / 3` groups; \\nc.) If the result is `2`, `v = 3m + 2`, we group the `2` into a group and the remaining into 3-groups, totally `m + 1 = 1 + v / 3` groups; \\n**NO matter the result of `% 3` is `1` or `2`, we need at least 1 + v / 3 rounds to complete**.\\n\\n```java\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> cnt = new HashMap<>();\\n        for (int t : tasks) {\\n            cnt.put(t, 1 + cnt.getOrDefault(t, 0));\\n        } \\n        int rounds = 0;\\n        for (int v : cnt.values()) {\\n            if (v == 1) {\\n                return -1;\\n            }\\n            rounds += v % 3 == 0 ? v / 3 : 1 + v / 3;\\n        }\\n        return rounds;\\n    }\\n```\\n```python\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        cnt = Counter(tasks)\\n        rounds = 0\\n        for v in cnt.values():\\n            if v == 1:\\n                return -1\\n            rounds += v // 3 if v % 3 == 0 else 1 + v // 3\\n        return rounds\\n```\\n\\nThe above codes can be further simplified as:\\n\\n```java\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> cnt = new HashMap<>();\\n        IntStream.of(tasks).forEach(t -> cnt.merge(t, 1, Integer::sum));\\n        int rounds = 0;\\n        for (int v : cnt.values()) {\\n            if (v == 1) {\\n                return -1;\\n            }\\n            rounds += (2 + v) / 3;\\n        }\\n        return rounds;\\n    }\\n```\\n```python\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        cnt = Counter(tasks)\\n        rounds = 0\\n        for v in cnt.values():\\n            if v == 1:\\n                return -1\\n            rounds += (2 + v) // 3\\n        return rounds\\n```\\nor\\n```java\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Long> cnt = IntStream.of(tasks).boxed().collect(Collectors.groupingBy(t -> t, Collectors.counting()));\\n        var values = cnt.values();\\n        return values.stream().anyMatch(v -> v == 1) ? -1 : (int)values.stream().mapToLong(v -> (2 + v) / 3).sum();\\n    }\\n```\\n```python\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        occur = Counter(tasks).values()\\n        return -1 if 1 in occur else sum((2 + v) // 3 for v in occur)\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(n)`, where `n = tasks.length`.\\n\\n--------\\n\\nPlease **let me know** if you have any **questions**, and **upvote** if the original post is helpful.",
                "solutionTags": [],
                "code": "```java\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> cnt = new HashMap<>();\\n        for (int t : tasks) {\\n            cnt.put(t, 1 + cnt.getOrDefault(t, 0));\\n        } \\n        int rounds = 0;\\n        for (int v : cnt.values()) {\\n            if (v == 1) {\\n                return -1;\\n            }\\n            rounds += v % 3 == 0 ? v / 3 : 1 + v / 3;\\n        }\\n        return rounds;\\n    }\\n```\n```python\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        cnt = Counter(tasks)\\n        rounds = 0\\n        for v in cnt.values():\\n            if v == 1:\\n                return -1\\n            rounds += v // 3 if v % 3 == 0 else 1 + v // 3\\n        return rounds\\n```\n```java\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> cnt = new HashMap<>();\\n        IntStream.of(tasks).forEach(t -> cnt.merge(t, 1, Integer::sum));\\n        int rounds = 0;\\n        for (int v : cnt.values()) {\\n            if (v == 1) {\\n                return -1;\\n            }\\n            rounds += (2 + v) / 3;\\n        }\\n        return rounds;\\n    }\\n```\n```python\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        cnt = Counter(tasks)\\n        rounds = 0\\n        for v in cnt.values():\\n            if v == 1:\\n                return -1\\n            rounds += (2 + v) // 3\\n        return rounds\\n```\n```java\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Long> cnt = IntStream.of(tasks).boxed().collect(Collectors.groupingBy(t -> t, Collectors.counting()));\\n        var values = cnt.values();\\n        return values.stream().anyMatch(v -> v == 1) ? -1 : (int)values.stream().mapToLong(v -> (2 + v) / 3).sum();\\n    }\\n```\n```python\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        occur = Counter(tasks).values()\\n        return -1 if 1 in occur else sum((2 + v) // 3 for v in occur)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1955400,
                "title": "python-o-n-explanation",
                "content": "We count the number of times each element is repeated in the array. If any element is repeated only once then we can return -1, else we need to calculate the minimum number of rounds it will take to complete that particular difficulty.\\n\\nCount = frequency of each element\\nIf the count is a multiple of 3 (count % 3 = 0): Then we can group all the tasks in groups of 3, thus we can complete it in (count / 3) rounds.\\nFor example: count = 9; rounds will be: 3, 3, 3\\n\\nIf count % 3 = 1: Then we group 4 of the tasks in a group of 2 and the rest in groups of 3, thus we will take 3 (count/3 - 1) times and take 2 twice.\\nFor example: count = 10; rounds = 3, 3, 2, 2\\n\\nIf count % 3 = 2: Then we group 2 tasks in a group of 2 and group the rest of the tasks in groups of 3, thus we will take 3 (count/3) times and take 2 one time.\\nFor example: count = 11; rounds = 3, 3, 3, 2\\n\\nFrom the above analysis we can see that if the result of (count % 3) is 0, then we will need (count / 3) rounds to complete the tasks and if the result of (count % 3) is 1 or 2, we will need (count / 3 + 1) rounds to complete the tasks.\\n\\n```python\\n\\tdef minimumRounds(self, tasks: List[int]) -> int:\\n        def tot(count):\\n            rem = count % 3\\n            div = count // 3\\n            \\n            if rem == 0: return div\\n            else: return div + 1\\n        \\n        d = {}\\n        for n in tasks:\\n            d[n] = d.get(n, 0) + 1\\n            \\n        ans = 0\\n        for count in d.values():\\n            if count == 1: return -1\\n            ans += tot(count)\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n\\tdef minimumRounds(self, tasks: List[int]) -> int:\\n        def tot(count):\\n            rem = count % 3\\n            div = count // 3\\n            \\n            if rem == 0: return div\\n            else: return div + 1\\n        \\n        d = {}\\n        for n in tasks:\\n            d[n] = d.get(n, 0) + 1\\n            \\n        ans = 0\\n        for count in d.values():\\n            if count == 1: return -1\\n            ans += tot(count)\\n            \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2997527,
                "title": "c-solution-with-detailed-explanations-time-complexity-analysis",
                "content": "## Explanation:\\n\\n### Solution 01\\n\\n- Here in the map we\\u2019re storing all the tasks count of the same difficulty level.\\n- Iterating over map and checking 3 conditions:\\n    - `if(temp < 2)` here we can\\u2019t perform the task as the minimum required task needed to do in a single day is 2 \\u2192 ***return -1.***\\n    - `if(temp == 2)` here only one day is needed to do the work, so increase 1 in our ans.\\n    - `if(temp >= 3)` here we\\u2019ve more than 2 tasks, so we\\u2019ll divide the task number by 3 & add it, even if we have more tasks to do that will be less than 3, so we\\u2019ll increase ans value by 1.\\n- Return ans.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n\\n        for(auto x:tasks){\\n            mp[x] += 1;\\n        }\\n\\n        for(auto x:mp){\\n            int temp = x.second;\\n            if(temp < 2) return -1;\\n            else if(temp == 2) ans++;\\n            else if(temp >= 3){\\n                ans += temp/3;\\n                if(temp%3 != 0) ans++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "Ordered Map",
                    "Counting"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n\\n        for(auto x:tasks){\\n            mp[x] += 1;\\n        }\\n\\n        for(auto x:mp){\\n            int temp = x.second;\\n            if(temp < 2) return -1;\\n            else if(temp == 2) ans++;\\n            else if(temp >= 3){\\n                ans += temp/3;\\n                if(temp%3 != 0) ans++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995074,
                "title": "faster-than-98-45-easy-explanation-simple-map-implementation",
                "content": "# Explanation \\uD83D\\uDC47\\n```\\nif a repetition < 2 then there is no possibililty of finishing that task\\n\\nand if it is divided by 3 then best way to finish that task in max possible way,\\n i.e. repetitions/3.\\n\\nbut if (repetition % 3 == 1) or (repetition % 3 == 2)\\nthen in the both cases we will get the answer as repetition/3 + 1;\\n\\n\\nlet me explain it:\\n\\nif(repetition%3 == 1)\\nthen\\nthe possible way to execute is x*3 + 2*2, where x=repetition/3 - 1;\\nso, x + 2 = repetition/3 - 1 + 2 = repetition/3 + 1;\\n\\nelse if (repetition%3 == 2)\\nthen\\nthe possible way to execute is x*3 + 1*2, where  x = repetition/3;\\nso, x + 1 = repetition/3 + 1;\\n\\n```\\n\\n<B></B>\\n<B></B>\\n\\n#### Time Complexity - O(n)\\n#### Space Complexity - O(n)\\n<B></B>\\n<B></B>\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<tasks.size();i++){\\n            mp[tasks[i]]++;\\n        }\\n        int ans=0;\\n        for(auto i : mp){\\n            int cur = i.second;\\n            if(cur<2)\\n                return -1;\\n            \\n            if(cur%3 == 0)\\n                ans += cur/3;\\n            else{\\n                ans += (cur/3 + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# If you find this helpful please upvote it.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nif a repetition < 2 then there is no possibililty of finishing that task\\n\\nand if it is divided by 3 then best way to finish that task in max possible way,\\n i.e. repetitions/3.\\n\\nbut if (repetition % 3 == 1) or (repetition % 3 == 2)\\nthen in the both cases we will get the answer as repetition/3 + 1;\\n\\n\\nlet me explain it:\\n\\nif(repetition%3 == 1)\\nthen\\nthe possible way to execute is x*3 + 2*2, where x=repetition/3 - 1;\\nso, x + 2 = repetition/3 - 1 + 2 = repetition/3 + 1;\\n\\nelse if (repetition%3 == 2)\\nthen\\nthe possible way to execute is x*3 + 1*2, where  x = repetition/3;\\nso, x + 1 = repetition/3 + 1;\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<tasks.size();i++){\\n            mp[tasks[i]]++;\\n        }\\n        int ans=0;\\n        for(auto i : mp){\\n            int cur = i.second;\\n            if(cur<2)\\n                return -1;\\n            \\n            if(cur%3 == 0)\\n                ans += cur/3;\\n            else{\\n                ans += (cur/3 + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996805,
                "title": "very-easy-to-understand-beginner-friendly-c-solution-with-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo find how many times each task with a same difficulty level is there, we can store the array elements in a hashmap, in which keys are the difficulty level and its values are the number of tasks in the array of that difficulty level.\\n\\nIn simpler words, keys will be the numbers in array and values will be the number of times each number is present in the array.\\n\\nCreate a variable `ans` for counting total rounds.\\n\\nThen traverse the hashmap and in each iteration:\\n\\n- if any number has frequency 1, simply return -1 (as we can\\'t complete this task).\\n```return -1;```\\n \\n- if frequency is 2 or 3, add 1 in `ans` (total rounds)\\n```ans += 1;```\\n\\n\\n- else, (from the image in intuition part, we see after every 3 numbers (in LHS) the number (in RHS) is increasing by 1.) So, simply we can divide the frequency by 3 and take ceil value of it and add in `ans`\\n```ans += ceil( frequency / 3 );```\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // function to convert a number into its ceil form.\\n\\n    int ceilTo(int x, int y) {\\n        if (x%y) {\\n            return (x/y)+1;\\n        }\\n\\n        return x/y;\\n    }\\n\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        unordered_map<int, int> m;\\n\\n        // inserting all the array elements into hashmap.\\n        for (auto x:tasks) {\\n            m[x]++;\\n        }\\n\\n        int ans = 0;    // variable to store total rounds required\\n\\n        for (auto x:m) {\\n            if (x.second == 1) return -1;\\n\\n            if (x.second > 3) {\\n                ans += ceilTo(x.second, 3);\\n            }\\n            else {\\n                ans += 1;\\n            }\\n        }\\n        // x.second means frequency\\n\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease LIKE :)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Greedy",
                    "Counting"
                ],
                "code": "```return -1;```\n```ans += 1;```\n```ans += ceil( frequency / 3 );```\n```\\nclass Solution {\\npublic:\\n\\n    // function to convert a number into its ceil form.\\n\\n    int ceilTo(int x, int y) {\\n        if (x%y) {\\n            return (x/y)+1;\\n        }\\n\\n        return x/y;\\n    }\\n\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        unordered_map<int, int> m;\\n\\n        // inserting all the array elements into hashmap.\\n        for (auto x:tasks) {\\n            m[x]++;\\n        }\\n\\n        int ans = 0;    // variable to store total rounds required\\n\\n        for (auto x:m) {\\n            if (x.second == 1) return -1;\\n\\n            if (x.second > 3) {\\n                ans += ceilTo(x.second, 3);\\n            }\\n            else {\\n                ans += 1;\\n            }\\n        }\\n        // x.second means frequency\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995478,
                "title": "easy-c-and-javascript-solution-frequency-map",
                "content": "# Good Morning\\n![Spider-Man-No-Way-Home-Doctor-Strange-Puffer-Jacket-568x614.jpg](https://assets.leetcode.com/users/images/33a33a7d-4dd2-4a1d-a7ba-1a797fbeefc0_1672806815.5246909.jpeg)\\n\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int>m;\\n        for(auto &i:tasks) m[i]++;\\n        int ans=0;\\n        for(auto &i:m)\\n        {\\n            if(i.second==1)\\n            {\\n                return -1;\\n            }\\n            ans+=ceil(i.second/3.0);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n# JavaScript Code\\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    let freq={}\\n    for(let i=0;i<tasks.length;i++)\\n    {\\n        if(freq[tasks[i]])\\n        {\\n            freq[tasks[i]]+=1;\\n        }\\n        else\\n        {\\n            freq[tasks[i]]=1;\\n        }\\n        \\n    }\\n    let ans=0;\\n    // console.log(freq);\\n    for(let obj in freq)\\n    {\\n        if(freq[obj]==1) return -1;\\n        else\\n        {\\n            ans+=Math.ceil(freq[obj]/3.0);\\n        }\\n    }\\n    return ans;\\n};\\n```\\n\\n#### Upvote to keep me motivated.",
                "solutionTags": [
                    "C++",
                    "JavaScript",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int>m;\\n        for(auto &i:tasks) m[i]++;\\n        int ans=0;\\n        for(auto &i:m)\\n        {\\n            if(i.second==1)\\n            {\\n                return -1;\\n            }\\n            ans+=ceil(i.second/3.0);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    let freq={}\\n    for(let i=0;i<tasks.length;i++)\\n    {\\n        if(freq[tasks[i]])\\n        {\\n            freq[tasks[i]]+=1;\\n        }\\n        else\\n        {\\n            freq[tasks[i]]=1;\\n        }\\n        \\n    }\\n    let ans=0;\\n    // console.log(freq);\\n    for(let obj in freq)\\n    {\\n        if(freq[obj]==1) return -1;\\n        else\\n        {\\n            ans+=Math.ceil(freq[obj]/3.0);\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955480,
                "title": "c-easy-solution-0ms-100-faster",
                "content": "\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        unordered_map<int,int> mp;\\n        \\n        //counting occuences of all values in a map\\n        for(auto i:tasks)   mp[i]++;\\n        \\n        int ans=0;\\n        \\n        for(auto i=mp.begin();i!=mp.end();i++){\\n            \\n            //corner case if count of any value is 1 then return -1\\n            if(i->second==1)    return -1;\\n            \\n            if(i->second%3==0)  ans+=((i->second)/3);\\n            \\n            else if(i->second<6)\\n                if(i->second==2)   ans+=1;\\n                else ans+=2;\\n            \\n            else{\\n                \\n                ans+=((((i->second)/6)*2));\\n                i->second%=6;\\n                if(i->second==4 || i->second==5)    ans+=2;\\n                else    ans+=1;\\n                \\n            }\\n        }//end of for\\n        \\n        return ans;\\n        \\n    }//end of main\\n};\\n\\'\\'\\'\\nPlease Upvote if you find it Helpful.\\n\\uD83D\\uDE42\\uD83D\\uDC4D",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        unordered_map<int,int> mp;\\n        \\n        //counting occuences of all values in a map\\n        for(auto i:tasks)   mp[i]++;\\n        \\n        int ans=0;\\n        \\n        for(auto i=mp.begin();i!=mp.end();i++){\\n            \\n            //corner case if count of any value is 1 then return -1\\n            if(i->second==1)    return -1;\\n            \\n            if(i->second%3==0)  ans+=((i->second)/3);\\n            \\n            else if(i->second<6)\\n                if(i->second==2)   ans+=1;\\n                else ans+=2;\\n            \\n            else{\\n                \\n                ans+=((((i->second)/6)*2));\\n                i->second%=6;\\n                if(i->second==4 || i->second==5)    ans+=2;\\n                else    ans+=1;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1955367,
                "title": "well-explained-python-solution",
                "content": "**Observation:**\\nThe question just boils downs to weather the ith task can be done by grouping it into groups of 2 or 3. \\nLet number of ith tasks be ***m***, ***a*** and ***b*** are the number of groups of 2\\'s and 3\\'s where ***a*** and ***b*** can assume any non negative values here. So, **m = 2 * a + 3 * b**\\n \\nWe can observe that this equation holds true for all values of ***m*** for ***m > 1***.\\n```\\n1 = Exception | 2 = 2 * 1 + 3 * 0 | 3 = 2 * 0 + 3 * 1 | 4 = 2 * 2 + 3 * 0 | 5 = 2 * 1 + 3 * 1 | 6 = 2 * 0 + 3 * 2 | 7 = 2 * 2 + 3 * 1 | 8 = 2 * 1 + 3 * 2 | 9 = 2 * 0 + 3 * 3 | 10 = 2 * 2 + 3 * 2 | 11 = 2 * 1 + 3 * 3 | 12 = 2 * 0 + 3 * 4 | 3 * 3 | 14 = 2 * 2 + 3 * 4 | 15 = 2 * 0 + 3 * 5 | 16 = 2 * 2 + 3 * 4 | 17 = 2 * 1 + 3 * 5 \\n```\\nThe repeated pattern for 3 consecutive integers here is: **A || B || C = 2  x + 3  y || 2  (x-1) + 3  (y+1) || 2  (x-2) + 3  (y+2)** [2 goes from x to x-2 while 3 goes from y to y+2] . Look at 1,2,3 and then 4, 5, 6 then 7, 8, 9. They repeat after every 3 values. Also we can notice why this is so: **B = A + 1 = A + (3 - 2) . Similarly C = B + 1 = B (3 - 2)**, since 3 is +ve and 2 is -ve, we have **x-1 or 2** for 2 and **y+1 or 2** for 3. Thus, total number of groups ***(x+y)*** increments after 3 values. \\n\\n**Reason:**\\nTake the base case of m = 2 and 3. They can be divided into group of one 2\\'s and one 3\\'s respectively. Now ontop of this base case add 2 and 3 to m = 2 and 3, we get 2+2 = 4, 2+3=5, 3+3 = 6, three consecutive numbers. Observe that adding 2 and 3 to previous values of m will give new values that will surely be divisible into groups of 2\\'s and 3\\'s as we just added 2 and 3 to a number which previously did follow this condition. \\n\\n**Code:**\\n```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        table, res = Counter(tasks), 0 # Counter to hold frequency of ith task and res stores the result.\\n        for count in table.values():\\n            if count <= 1: return -1 # If count <= 1 then it cannot follow the condition hence return -1.\\n            res += ceil(count / 3) # Total number of groups increments after 3 values. \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n1 = Exception | 2 = 2 * 1 + 3 * 0 | 3 = 2 * 0 + 3 * 1 | 4 = 2 * 2 + 3 * 0 | 5 = 2 * 1 + 3 * 1 | 6 = 2 * 0 + 3 * 2 | 7 = 2 * 2 + 3 * 1 | 8 = 2 * 1 + 3 * 2 | 9 = 2 * 0 + 3 * 3 | 10 = 2 * 2 + 3 * 2 | 11 = 2 * 1 + 3 * 3 | 12 = 2 * 0 + 3 * 4 | 3 * 3 | 14 = 2 * 2 + 3 * 4 | 15 = 2 * 0 + 3 * 5 | 16 = 2 * 2 + 3 * 4 | 17 = 2 * 1 + 3 * 5 \\n```\n```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        table, res = Counter(tasks), 0 # Counter to hold frequency of ith task and res stores the result.\\n        for count in table.values():\\n            if count <= 1: return -1 # If count <= 1 then it cannot follow the condition hence return -1.\\n            res += ceil(count / 3) # Total number of groups increments after 3 values. \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869479,
                "title": "multiple-javascript-solutions-118ms-map-maths-for-loop-object",
                "content": "***Happy Coding..!* Feel free to ask Q\\'s...**\\n*#happytohelpu*\\n\\n```\\n\\n// Solution 1\\nconst minimumRounds = (tasks, map = new Map(), res = 0) => {\\n    for (let i = 0; i < tasks.length; i++) {\\n        map.set(tasks[i], (map.get(tasks[i]) !== undefined ? (map.get(tasks[i]) + 1) : 1))\\n    }\\n    const iterator = map.values();\\n    for (const value of iterator) {\\n        if (value < 2) return -1;\\n        let temp = parseInt(value / 3) + (value % 3 !== 0 ? 1 : 0);\\n        res += temp;\\n    }\\n    return res;\\n};\\n\\n// Solution 2\\nconst minimumRounds = (tasks) => {\\n    const counts = {};\\n    for (let task of tasks) {\\n        counts[task] = (counts[task] || 0) + 1;\\n    }\\n    let rounds = 0;\\n    for (let count of Object.values(counts)) {\\n        if (count < 2) {\\n            return -1;\\n        }\\n        rounds += Math.ceil(count / 3);\\n    }\\n    return rounds;\\n};\\n\\n```\\n\\n***Do upvote if you find this solution useful.***",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\n\\n// Solution 1\\nconst minimumRounds = (tasks, map = new Map(), res = 0) => {\\n    for (let i = 0; i < tasks.length; i++) {\\n        map.set(tasks[i], (map.get(tasks[i]) !== undefined ? (map.get(tasks[i]) + 1) : 1))\\n    }\\n    const iterator = map.values();\\n    for (const value of iterator) {\\n        if (value < 2) return -1;\\n        let temp = parseInt(value / 3) + (value % 3 !== 0 ? 1 : 0);\\n        res += temp;\\n    }\\n    return res;\\n};\\n\\n// Solution 2\\nconst minimumRounds = (tasks) => {\\n    const counts = {};\\n    for (let task of tasks) {\\n        counts[task] = (counts[task] || 0) + 1;\\n    }\\n    let rounds = 0;\\n    for (let count of Object.values(counts)) {\\n        if (count < 2) {\\n            return -1;\\n        }\\n        rounds += Math.ceil(count / 3);\\n    }\\n    return rounds;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955543,
                "title": "watch-for-1",
                "content": "**Intuition:** When we have only 1 number, we return `-1`. For other quantities, we can always complete the tasks in rounds of twos or threes.\\n\\n#### Approach 1: Sorting\\nWe could use a counter (see approach 2 below), but I wanted to do something different. Here, we sort numbers and then count repeated numbers.\\n\\n**C++**\\n```cpp\\nint minimumRounds(vector<int>& t) {\\n    int res = 0, cnt = 1;\\n    sort(begin(t), end(t));\\n    for (int i = 1; i <= t.size(); ++i, ++cnt) {\\n        if (i == t.size() || t[i - 1] != t[i]) {\\n            if (cnt == 1)\\n                return -1;\\n            res += (cnt + 2) / 3;\\n            cnt = 0;\\n        }\\n    }\\n    return res;\\n}\\n```\\n\\n#### Approach 2: Counter\\n**Python 3**\\n```python\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        cnt = Counter(tasks).values()\\n        return -1 if 1 in cnt else sum((t + 2) // 3 for t in cnt)\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```cpp\\nint minimumRounds(vector<int>& t) {\\n    int res = 0, cnt = 1;\\n    sort(begin(t), end(t));\\n    for (int i = 1; i <= t.size(); ++i, ++cnt) {\\n        if (i == t.size() || t[i - 1] != t[i]) {\\n            if (cnt == 1)\\n                return -1;\\n            res += (cnt + 2) / 3;\\n            cnt = 0;\\n        }\\n    }\\n    return res;\\n}\\n```\n```python\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        cnt = Counter(tasks).values()\\n        return -1 if 1 in cnt else sum((t + 2) // 3 for t in cnt)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997037,
                "title": "short-and-easy-linq-solution",
                "content": "```csharp\\npublic class Solution\\n{\\n    public int MinimumRounds(int[] tasks)\\n    {\\n            var counts = tasks.GroupBy(x => x).Select(x => x.Count());\\n            return counts.Any(x => x == 1)\\n                ? -1\\n                : counts.Sum(x => (x + 2) / 3);\\n    }\\n}\\n```\\n## Explanation\\n1. Count the difficulty levels.\\n2. If any of them comes up only once, return `-1` because it is not possible to complete all the tasks.\\n3. Otherwise, each difficulty level will require `(x + 2) / 3` actions. Return the sum.",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public int MinimumRounds(int[] tasks)\\n    {\\n            var counts = tasks.GroupBy(x => x).Select(x => x.Count());\\n            return counts.Any(x => x == 1)\\n                ? -1\\n                : counts.Sum(x => (x + 2) / 3);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996053,
                "title": "java-hashmap-with-explanation",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        // Using a hashMap to store the frequency \\n        Map<Integer,Integer> m = new HashMap<>();\\n        for(int task:tasks){\\n            // storing the frequency using getOrDefault (it\\'s a function from Property class )\\n            m.put(task,m.getOrDefault(task,0)+1);\\n        }\\n        // to maintain the total round count taking one variable\\n        int rounds = 0;\\n        for(int value:m.values()){\\n            // if the frequency is 1 then we can\\'t group( Ref. Example 2) \\n            if(value==1)\\n                return -1;\\n            // else we are trying to complete 3 tasks at a time because maximum we can solve 3 tasks\\n            rounds+=(value/3);\\n            // anything is remaining that should be 2 or 1 \\n            /* If it\\'s 2 then we can solve 2 tasks at a time \\n               so simply we can do rounds++*/\\n\\n                //If it\\'s 1 then we will backtrack and we should  \\n                // have 1+3 = 4 tasks , we can solve it by 2-->2 i.e \\n                //rounds +=2 but we had backtracked once so \\n                //rounds+=(2-1) again that it rounds++;\\n            if(value%3>0)\\n            rounds++;\\n        }\\n        return rounds;\\n    }\\n}\\n```\\n# If you liked it , Please upvote it \\uD83D\\uDE09",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        // Using a hashMap to store the frequency \\n        Map<Integer,Integer> m = new HashMap<>();\\n        for(int task:tasks){\\n            // storing the frequency using getOrDefault (it\\'s a function from Property class )\\n            m.put(task,m.getOrDefault(task,0)+1);\\n        }\\n        // to maintain the total round count taking one variable\\n        int rounds = 0;\\n        for(int value:m.values()){\\n            // if the frequency is 1 then we can\\'t group( Ref. Example 2) \\n            if(value==1)\\n                return -1;\\n            // else we are trying to complete 3 tasks at a time because maximum we can solve 3 tasks\\n            rounds+=(value/3);\\n            // anything is remaining that should be 2 or 1 \\n            /* If it\\'s 2 then we can solve 2 tasks at a time \\n               so simply we can do rounds++*/\\n\\n                //If it\\'s 1 then we will backtrack and we should  \\n                // have 1+3 = 4 tasks , we can solve it by 2-->2 i.e \\n                //rounds +=2 but we had backtracked once so \\n                //rounds+=(2-1) again that it rounds++;\\n            if(value%3>0)\\n            rounds++;\\n        }\\n        return rounds;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995354,
                "title": "easy-c-100-faster",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $O(n$ $log(n))$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        sort(tasks.begin(), tasks.end());\\n        int result = 0, i, j;\\n        for(i=0; i<tasks.size(); ++i){\\n            for(j=i+1; j<tasks.size(); ++j)\\n                if(tasks[i]!=tasks[j]) break;\\n            \\n            j = j-i;\\n            if(j==1) return -1;\\n\\n            result += j/3;\\n            if(j%3)\\n                ++result;\\n\\n            i += (j-1);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        sort(tasks.begin(), tasks.end());\\n        int result = 0, i, j;\\n        for(i=0; i<tasks.size(); ++i){\\n            for(j=i+1; j<tasks.size(); ++j)\\n                if(tasks[i]!=tasks[j]) break;\\n            \\n            j = j-i;\\n            if(j==1) return -1;\\n\\n            result += j/3;\\n            if(j%3)\\n                ++result;\\n\\n            i += (j-1);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994703,
                "title": "js-fast-and-straight-forward-commented",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\nPlease upvote if you found this helpful~\\n\\n# Code\\n```\\nvar minimumRounds = function (tasks) {\\n  let counter = {}, res = 0;\\n//Count frequency of each task \\n  for (let t of tasks) {\\n    counter[t] = (counter[t] || 0) + 1;\\n  }\\n//Go through the task and try to get 3(max) done each time.\\n  for (let k in counter) {\\n//If the task only show up Once, that means not possible.\\n    if (counter[k] === 1) return -1;\\n      res += Math.ceil(counter[k] / 3);\\n  }\\n  return res;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumRounds = function (tasks) {\\n  let counter = {}, res = 0;\\n//Count frequency of each task \\n  for (let t of tasks) {\\n    counter[t] = (counter[t] || 0) + 1;\\n  }\\n//Go through the task and try to get 3(max) done each time.\\n  for (let k in counter) {\\n//If the task only show up Once, that means not possible.\\n    if (counter[k] === 1) return -1;\\n      res += Math.ceil(counter[k] / 3);\\n  }\\n  return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2995028,
                "title": "simple-and-easy-code-conceptual-solution-c",
                "content": "# **Please try to understand the discussion for this given solution before looking at the code\\nLink to the discussion : https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/discussion/comments/1740590\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int count=1;\\n        vector<int>cnt;\\n\\n        sort(tasks.begin(),tasks.end());\\n\\n        if(tasks.size()==1)\\n        return -1;\\n\\n        for(int i=1;i<tasks.size();i++){\\n            if(tasks[i]==tasks[i-1])\\n            count++;\\n            else{\\n                cnt.push_back(count);\\n                count=1;\\n            }\\n        }\\n        cnt.push_back(count);\\n\\n        count=0;\\n\\n        for(int i=0;i<cnt.size();i++){\\n            if(cnt[i]==1)\\n            return -1;\\n            if(cnt[i]==2 or cnt[i]==3)\\n            count++;\\n            if(cnt[i]>3)\\n            count+=(cnt[i]+2)/3;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int count=1;\\n        vector<int>cnt;\\n\\n        sort(tasks.begin(),tasks.end());\\n\\n        if(tasks.size()==1)\\n        return -1;\\n\\n        for(int i=1;i<tasks.size();i++){\\n            if(tasks[i]==tasks[i-1])\\n            count++;\\n            else{\\n                cnt.push_back(count);\\n                count=1;\\n            }\\n        }\\n        cnt.push_back(count);\\n\\n        count=0;\\n\\n        for(int i=0;i<cnt.size();i++){\\n            if(cnt[i]==1)\\n            return -1;\\n            if(cnt[i]==2 or cnt[i]==3)\\n            count++;\\n            if(cnt[i]>3)\\n            count+=(cnt[i]+2)/3;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995390,
                "title": "intuitive-memoization-using-coin-change-explained",
                "content": "# Upvote if helpful \\uD83D\\uDD25\\uD83D\\uDD25\\n\\n# Intuition\\n```\\nWhen we look at the problem we can instantly say that \\nit is coin change problem where we have only coins \\nof 2 and 3 and we want to use minimum number \\nof coins for the frequency of every element.\\n```\\n\\n# Approach\\n``` \\nfirst we will calculate the frequency of every value \\nusing map and store the frequency in another array.\\nafter that for every element in that array we will apply \\ncoin change function which will give us minimum coins required\\nfor every frequency in that array.\\nif minimum coins comes out 100005(ie >10^5) for any of \\nthe frequency then we will instantly return -1 \\nas the combinations of 2, 3 is not possible so no need to\\ncalculate further.\\n\\nNow CoinChange Function:\\n    base cases:\\n        if n is 2, 3 then we can just return 1 as 1 round will\\n        be enough for that frequency.\\n        if n==1 then we don\\'t have any choice so have to return some\\n            larger value.\\n\\n        for every frequency we have 2 recursive calls:\\n                i)either take coin of 2 (obviously if n>=2)\\n                ii)or either take coin of 3.\\n        take minimum between 2 and return to my parent call.\\n\\n    while doing so we will store it in our dp so that if next\\n    time if same value comes then we will return the stored value.\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int>dp;\\n    int coinchange(int n){\\n\\n        if(n==2 || n==3)return 1;\\n\\n        //if(n<0)return 100005;\\n\\n        if(n==1){\\n            return 100005;\\n        }\\n\\n        if(dp[n]!=-1)return dp[n];\\n\\n        int a=INT_MAX;\\n        if(n>=2){\\n            a= min(a, coinchange(n-2)+1);\\n        }\\n\\n        if(n>=3){\\n            a= min(a, coinchange(n-3)+1);\\n        }\\n\\n        return dp[n]= a;\\n        \\n    }\\n    int minimumRounds(vector<int>& tasks) {\\n        dp.resize(100005, -1);\\n\\n        unordered_map<int, int>mp;\\n        for(auto i: tasks)mp[i]++;\\n\\n        vector<int>arr;\\n        for(auto k: mp){\\n            arr.push_back(k.second);\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<arr.size(); i++){\\n            int curr= coinchange(arr[i]);\\n            if(curr>=100005)return -1;\\n            else ans+=curr;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n# Thank You.",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nWhen we look at the problem we can instantly say that \\nit is coin change problem where we have only coins \\nof 2 and 3 and we want to use minimum number \\nof coins for the frequency of every element.\\n```\n``` \\nfirst we will calculate the frequency of every value \\nusing map and store the frequency in another array.\\nafter that for every element in that array we will apply \\ncoin change function which will give us minimum coins required\\nfor every frequency in that array.\\nif minimum coins comes out 100005(ie >10^5) for any of \\nthe frequency then we will instantly return -1 \\nas the combinations of 2, 3 is not possible so no need to\\ncalculate further.\\n\\nNow CoinChange Function:\\n    base cases:\\n        if n is 2, 3 then we can just return 1 as 1 round will\\n        be enough for that frequency.\\n        if n==1 then we don\\'t have any choice so have to return some\\n            larger value.\\n\\n        for every frequency we have 2 recursive calls:\\n                i)either take coin of 2 (obviously if n>=2)\\n                ii)or either take coin of 3.\\n        take minimum between 2 and return to my parent call.\\n\\n    while doing so we will store it in our dp so that if next\\n    time if same value comes then we will return the stored value.\\n```\n```\\nclass Solution {\\npublic:\\nvector<int>dp;\\n    int coinchange(int n){\\n\\n        if(n==2 || n==3)return 1;\\n\\n        //if(n<0)return 100005;\\n\\n        if(n==1){\\n            return 100005;\\n        }\\n\\n        if(dp[n]!=-1)return dp[n];\\n\\n        int a=INT_MAX;\\n        if(n>=2){\\n            a= min(a, coinchange(n-2)+1);\\n        }\\n\\n        if(n>=3){\\n            a= min(a, coinchange(n-3)+1);\\n        }\\n\\n        return dp[n]= a;\\n        \\n    }\\n    int minimumRounds(vector<int>& tasks) {\\n        dp.resize(100005, -1);\\n\\n        unordered_map<int, int>mp;\\n        for(auto i: tasks)mp[i]++;\\n\\n        vector<int>arr;\\n        for(auto k: mp){\\n            arr.push_back(k.second);\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<arr.size(); i++){\\n            int curr= coinchange(arr[i]);\\n            if(curr>=100005)return -1;\\n            else ans+=curr;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955377,
                "title": "greedy-every-number-is-a-sum-of-2s-and-3s-except-1",
                "content": "**Intuition : Every number is a sum of 2s and 3s, except 1.**\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        int ans(0);\\n        unordered_map<int, int> m;\\n        for (auto t : tasks) m[t]++;\\n        \\n        for (auto p : m) {\\n            int val = p.second;\\n            \\n            if (val == 1) return -1;\\n            if (val % 3 == 0)  ans += val / 3; // as it will always take minimum number of moves.\\n            else {\\n\\t\\t\\t// here val % 3 is either 1 or 2. \\n            // divide val into groups such that there is a group 2 and rest of 3.\\n                int groupOfThree = val / 3;\\n\\t\\t\\t\\tif (val % 3 == 1)    groupOfThree--;\\n\\t\\t\\t\\tval -= groupOfThree * 3;\\n\\t\\t\\t\\tans += groupOfThree + val / 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Java Solution**\\n\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        \\n        HashMap<Integer, Integer> m = new HashMap<>();\\n        for (int task : tasks)\\n            m.put(task, m.getOrDefault(task, 0) + 1);\\n        \\n        int ans = 0;\\n        for (int val : m.values()) {\\n            if (val == 1) return -1;\\n            if (val % 3 == 0)  ans += val / 3;\\n            else {\\n                int groupOfThree = val / 3;\\n\\t\\t\\t\\tif (val % 3 == 1)    groupOfThree--;\\n\\t\\t\\t\\tval -= groupOfThree * 3;\\n\\t\\t\\t\\tans += groupOfThree + val / 2;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        int ans(0);\\n        unordered_map<int, int> m;\\n        for (auto t : tasks) m[t]++;\\n        \\n        for (auto p : m) {\\n            int val = p.second;\\n            \\n            if (val == 1) return -1;\\n            if (val % 3 == 0)  ans += val / 3; // as it will always take minimum number of moves.\\n            else {\\n\\t\\t\\t// here val % 3 is either 1 or 2. \\n            // divide val into groups such that there is a group 2 and rest of 3.\\n                int groupOfThree = val / 3;\\n\\t\\t\\t\\tif (val % 3 == 1)    groupOfThree--;\\n\\t\\t\\t\\tval -= groupOfThree * 3;\\n\\t\\t\\t\\tans += groupOfThree + val / 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        \\n        HashMap<Integer, Integer> m = new HashMap<>();\\n        for (int task : tasks)\\n            m.put(task, m.getOrDefault(task, 0) + 1);\\n        \\n        int ans = 0;\\n        for (int val : m.values()) {\\n            if (val == 1) return -1;\\n            if (val % 3 == 0)  ans += val / 3;\\n            else {\\n                int groupOfThree = val / 3;\\n\\t\\t\\t\\tif (val % 3 == 1)    groupOfThree--;\\n\\t\\t\\t\\tval -= groupOfThree * 3;\\n\\t\\t\\t\\tans += groupOfThree + val / 2;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994718,
                "title": "c-java-python-map-w-comments",
                "content": "1. Count the frequency of each task.\\n2. if a task repeats only once then it is impossible to complete ( return -1 )\\n3. Divide each frequency with the max completable tasks in a round (freq/3)\\n4. check if there\\'s tasks left after division, such that if there is, we perform another round. (+1)\\n\\n[+]  We add +2 to each frequency in consideration of leftover tasks\\n        \\n    Eg: tasks[1,1,1,1,1] freq = 5\\n            instead of 5/3 +1 do (5+2)/3\\n\\n\\n```c++ []\\nint minimumRounds(vector<int>& tasks) {\\n    unordered_map<int,int> m;\\n    for(int t : tasks) // count frequency\\n        ++m[t];\\n\\n    int rounds = 0;\\n    for(auto &p : m){ \\n        if(p.second == 1) return -1; // impossible to complete\\n        rounds+= (p.second+2)/3; // max completable tasks (3)\\n    }\\n    return rounds;\\n```\\n```java []\\npublic int minimumRounds(int[] tasks) {\\n    HashMap<Integer, Integer> m = new HashMap<>();\\n    for (int t : tasks)     // Count frequency\\n        m.put(t, m.getOrDefault(t, 0) + 1);\\n\\n    int rounds = 0;\\n    for (int freq : m.values()) {\\n        if (freq == 1) return -1;// impossible to complete\\n        rounds += (freq+2)/3;   // max possible rounds\\n    }\\n    return rounds;\\n```\\n```Python3 []\\ndef minimumRounds(self, tasks: List[int]) -> int:\\n    freqs = Counter(tasks).values()\\n    rounds = 0\\n    for f in freqs:\\n        if f == 1: \\n            return -1\\n        rounds += floor((f+2)/3)\\n    return rounds\\n```\\n```Python []\\ndef minimumRounds(self, tasks):\\n    freqs = Counter(tasks).values()\\n    rounds = 0\\n    for f in freqs:\\n        if f == 1: \\n            return -1\\n        rounds += (f+2)/3\\n    return rounds\\n\\n```\\n## RAW\\n```c++ []\\nint minimumRounds(vector<int>& tasks) {\\n    unordered_map<int,int> m;\\n    for(int &t : tasks) ++m[t];\\n    int rounds = 0;\\n    for(auto &p : m){        \\n        if(p.second == 1) return -1;\\n        rounds+= (p.second+2)/3;\\n    }\\n    return rounds;\\n```\\n```java []\\npublic int minimumRounds(int[] tasks) {\\n    HashMap<Integer, Integer> m = new HashMap<>();\\n    for (int t : tasks)\\n        m.put(t, m.getOrDefault(t, 0) + 1);\\n    int rounds = 0;\\n    for (int freq : m.values()) {\\n        if (freq == 1) return -1;\\n        rounds += (freq+2)/3;\\n    }\\n    return rounds;\\n```\\n### ***Complexity***\\n ***Time***  : $$O(n)$$\\n ***Sapce*** : $$O(n)$$\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```c++ []\\nint minimumRounds(vector<int>& tasks) {\\n    unordered_map<int,int> m;\\n    for(int t : tasks) // count frequency\\n        ++m[t];\\n\\n    int rounds = 0;\\n    for(auto &p : m){ \\n        if(p.second == 1) return -1; // impossible to complete\\n        rounds+= (p.second+2)/3; // max completable tasks (3)\\n    }\\n    return rounds;\\n```\n```java []\\npublic int minimumRounds(int[] tasks) {\\n    HashMap<Integer, Integer> m = new HashMap<>();\\n    for (int t : tasks)     // Count frequency\\n        m.put(t, m.getOrDefault(t, 0) + 1);\\n\\n    int rounds = 0;\\n    for (int freq : m.values()) {\\n        if (freq == 1) return -1;// impossible to complete\\n        rounds += (freq+2)/3;   // max possible rounds\\n    }\\n    return rounds;\\n```\n```Python3 []\\ndef minimumRounds(self, tasks: List[int]) -> int:\\n    freqs = Counter(tasks).values()\\n    rounds = 0\\n    for f in freqs:\\n        if f == 1: \\n            return -1\\n        rounds += floor((f+2)/3)\\n    return rounds\\n```\n```Python []\\ndef minimumRounds(self, tasks):\\n    freqs = Counter(tasks).values()\\n    rounds = 0\\n    for f in freqs:\\n        if f == 1: \\n            return -1\\n        rounds += (f+2)/3\\n    return rounds\\n\\n```\n```c++ []\\nint minimumRounds(vector<int>& tasks) {\\n    unordered_map<int,int> m;\\n    for(int &t : tasks) ++m[t];\\n    int rounds = 0;\\n    for(auto &p : m){        \\n        if(p.second == 1) return -1;\\n        rounds+= (p.second+2)/3;\\n    }\\n    return rounds;\\n```\n```java []\\npublic int minimumRounds(int[] tasks) {\\n    HashMap<Integer, Integer> m = new HashMap<>();\\n    for (int t : tasks)\\n        m.put(t, m.getOrDefault(t, 0) + 1);\\n    int rounds = 0;\\n    for (int freq : m.values()) {\\n        if (freq == 1) return -1;\\n        rounds += (freq+2)/3;\\n    }\\n    return rounds;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2994683,
                "title": "daily-leetcoding-challenge-january-day-4",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2999453,
                "title": "best-solution-ever-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        sort(tasks.begin(),tasks.end());\\n        int count=0;\\n        int num=1;\\n        for(int i=1;i<tasks.size();i++){\\n            if(tasks[i]!=tasks[i-1]){\\n                if(num==1)return -1;\\n                if(num==3|| num==2)count=count+1;\\n                if(num>3){\\n                    count=count+num/3;\\n                    if(num%3>0){\\n                        count=count+1;\\n                    }\\n                    \\n                }\\n                num=1;\\n            }else{\\n                num++;\\n            }\\n        \\n        }\\n        if(num<2)return -1;    \\n        if(num==2)count++;\\n        else if(num%3!=0)count+=num/3+1;\\n        else count+=num/3;\\n\\n        return count;\\n\\n\\n\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        sort(tasks.begin(),tasks.end());\\n        int count=0;\\n        int num=1;\\n        for(int i=1;i<tasks.size();i++){\\n            if(tasks[i]!=tasks[i-1]){\\n                if(num==1)return -1;\\n                if(num==3|| num==2)count=count+1;\\n                if(num>3){\\n                    count=count+num/3;\\n                    if(num%3>0){\\n                        count=count+1;\\n                    }\\n                    \\n                }\\n                num=1;\\n            }else{\\n                num++;\\n            }\\n        \\n        }\\n        if(num<2)return -1;    \\n        if(num==2)count++;\\n        else if(num%3!=0)count+=num/3+1;\\n        else count+=num/3;\\n\\n        return count;\\n\\n\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997681,
                "title": "c-all-cases-explained-for-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo use minimum rounds we need to complete as many tasks possible in group of 3 and remainder could be done in pair of two.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince we will completing as many tasks possible in group of 3. Following are the cases for varied frequency of tasks: -\\n\\n**Case 1: Multiple of 3**\\n```\\nfreq = 9\\n```\\nWhen frequency is multiple of 3, freq%3 would be zero and freq/3 would be the required answer.\\n\\n**Case 2: Multiple of 2 but not 3**\\n```\\nfreq = 16\\n```\\nfreq%3 = 1, so in order to minimize the rounds we would take (freq/3)-1 rounds of 3 and thus leaving us with 4 rounds which could be handled in pair of 2 more rounds.\\n\\n**Case 3: Multiple of neither 2 or 3**\\n```\\nfreq = 11\\nor\\nfreq = 7\\n```\\nif freq%3 == 1, we do same as case 2\\nelse freq%3 == 2, we use more 1 round for the remaining pair of task.\\n\\n**Case 4:**\\n```\\nfreq = 1\\n```\\nreturn -1.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(number of distinct tasks*2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> m;\\n\\n        for (auto x: tasks){\\n            m[x]++;\\n        }\\n\\n        int res= 0;\\n\\n        for (auto x : m){\\n            if (x.second == 1) return -1;\\n            \\n            res += x.second/3;\\n            x.second %= 3;\\n\\n            if (x.second == 1 || x.second == 2) res += 1;\\n            \\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nfreq = 9\\n```\n```\\nfreq = 16\\n```\n```\\nfreq = 11\\nor\\nfreq = 7\\n```\n```\\nfreq = 1\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> m;\\n\\n        for (auto x: tasks){\\n            m[x]++;\\n        }\\n\\n        int res= 0;\\n\\n        for (auto x : m){\\n            if (x.second == 1) return -1;\\n            \\n            res += x.second/3;\\n            x.second %= 3;\\n\\n            if (x.second == 1 || x.second == 2) res += 1;\\n            \\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995879,
                "title": "t-m-98-96-98-26-java-solution-easy",
                "content": "# Please upvote if you like my solution .\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Arrays.sort(tasks);\\n        int res = 0;\\n        int i=0;\\n        while(i<tasks.length) {\\n            int j=i+1;\\n            while(j<tasks.length && tasks[i] == tasks[j]) j++;\\n            if(j-i==1) return -1;\\n            res += (j-i)%3 == 0 ? (j-i)/3 : (j-i)/3 + 1;\\n            i = j;\\n        }\\n        return res;\\n    }\\n}\\n```\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes.\\nLet me know in comment if i can do better.\\nLets connect on Linkedin https://www.linkedin.com/in/kailas-rathod/",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Arrays.sort(tasks);\\n        int res = 0;\\n        int i=0;\\n        while(i<tasks.length) {\\n            int j=i+1;\\n            while(j<tasks.length && tasks[i] == tasks[j]) j++;\\n            if(j-i==1) return -1;\\n            res += (j-i)%3 == 0 ? (j-i)/3 : (j-i)/3 + 1;\\n            i = j;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995275,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        cnt=Counter(tasks)\\n        sm=0\\n        for i in cnt:\\n            if cnt[i]==1:\\n                return -1\\n            x=cnt[i]//3\\n            y=cnt[i]%3\\n            if y==0:\\n                sm+=x\\n            else:\\n                sm+=(x+1)\\n        return sm\\n                \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        cnt=Counter(tasks)\\n        sm=0\\n        for i in cnt:\\n            if cnt[i]==1:\\n                return -1\\n            x=cnt[i]//3\\n            y=cnt[i]%3\\n            if y==0:\\n                sm+=x\\n            else:\\n                sm+=(x+1)\\n        return sm\\n                \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995048,
                "title": "daily-solution-most-easy-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        map<int,int> m; // frequency\\n        for(int i=0; i<tasks.size(); i++)\\n        {\\n            m[tasks[i]]++;\\n        }\\n\\n        bool k = false; // to check the last if statement\\n        int ans = 0;\\n        for(auto it=m.begin(); it!=m.end(); it++)\\n        {\\n            if(it->second == 1) // if any one of the element comes 1 time only\\n            {\\n                k = true;\\n                break;\\n            }\\n            \\n            ans = ans + ceil(it->second/3.0); // gives the maximum number -->ceil()\\n            \\n        }\\n\\n        if(k)\\n        {\\n            return -1;\\n        }\\n        return ans; //ans\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        map<int,int> m; // frequency\\n        for(int i=0; i<tasks.size(); i++)\\n        {\\n            m[tasks[i]]++;\\n        }\\n\\n        bool k = false; // to check the last if statement\\n        int ans = 0;\\n        for(auto it=m.begin(); it!=m.end(); it++)\\n        {\\n            if(it->second == 1) // if any one of the element comes 1 time only\\n            {\\n                k = true;\\n                break;\\n            }\\n            \\n            ans = ans + ceil(it->second/3.0); // gives the maximum number -->ceil()\\n            \\n        }\\n\\n        if(k)\\n        {\\n            return -1;\\n        }\\n        return ans; //ans\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994998,
                "title": "cpp-solution-using-unordered-hashmap-and-math-fastest-174-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**The basic Idea to solve this problem is to get the frequency of all the tasks and then figure out how to do a task in 2 or 3 task schemes\\nThen add all such schemes**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n>**Create a frequency array or simply an empty hashmap\\n>Create an integer variable rounds = 0\\n>Tabulate the frequency of each task**\\n\\n>**Iterate the frequency table**\\n>>**If frequency is 1, return -1\\n>>Else Calculate frequency/3 + 1 [if frequency is not divisible by 3] else 0\\n>> Add the calculated value to the rounds variable**\\n\\n>**Return the rounds variable**\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->  \\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution // Using Unordered_Hashmap, beats 100%, 174 ms\\n{\\npublic:\\n    int minimumRounds(vector<int> &tasks)\\n    {\\n        ios_base::sync_with_stdio(0);\\n        unordered_map<int, int> mp;\\n        int rounds = 0;\\n        for (int task : tasks) // Get the Frequency of each element in tasks array\\n            mp[task]++;\\n        for (auto task : mp)\\n        {\\n            int frequency = task.second; // Store the frequency\\n            if (frequency == 1)       // If the frequency is 1, there is no way to do 2 or 3 tasks at the same time\\n                return -1;\\n            rounds += frequency / 3 + (frequency % 3 != 0); // Else there is always frequency/3 + (frequency % 3 > 0), chances to to the thing\\n            \\n            \\n            /*\\n            Lets say the frequency is 7\\n            it can be done as 2 2 3\\n\\n            for 8\\n            it can be done as 2 3 3\\n\\n            for 9\\n            it can be done as 3 3 3\\n\\n            for 10\\n            it can be done as 2 2 3 3\\n\\n            for 11\\n            it can be done as 2 3 3 3\\n\\n            See the pattern???\\n            */\\n        }\\n        return rounds;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution // Using Unordered_Hashmap, beats 100%, 174 ms\\n{\\npublic:\\n    int minimumRounds(vector<int> &tasks)\\n    {\\n        ios_base::sync_with_stdio(0);\\n        unordered_map<int, int> mp;\\n        int rounds = 0;\\n        for (int task : tasks) // Get the Frequency of each element in tasks array\\n            mp[task]++;\\n        for (auto task : mp)\\n        {\\n            int frequency = task.second; // Store the frequency\\n            if (frequency == 1)       // If the frequency is 1, there is no way to do 2 or 3 tasks at the same time\\n                return -1;\\n            rounds += frequency / 3 + (frequency % 3 != 0); // Else there is always frequency/3 + (frequency % 3 > 0), chances to to the thing\\n            \\n            \\n            /*\\n            Lets say the frequency is 7\\n            it can be done as 2 2 3\\n\\n            for 8\\n            it can be done as 2 3 3\\n\\n            for 9\\n            it can be done as 3 3 3\\n\\n            for 10\\n            it can be done as 2 2 3 3\\n\\n            for 11\\n            it can be done as 2 3 3 3\\n\\n            See the pattern???\\n            */\\n        }\\n        return rounds;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994702,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int n=tasks.size();\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        int ans=0;\\n        for(auto& it:mp){\\n            if(it.second==1) return -1;\\n            ans+=ceil(it.second/3.0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int n=tasks.size();\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        int ans=0;\\n        for(auto& it:mp){\\n            if(it.second==1) return -1;\\n            ans+=ceil(it.second/3.0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956128,
                "title": "easy-js-javascript",
                "content": "```\\nvar minimumRounds = function(tasks) {\\n    const hash = {};\\n    let minRounds = 0;\\n    \\n    for (const task of tasks) {\\n        hash[task] = hash[task] + 1 || 1;\\n    }\\n    \\n    for (const count of Object.values(hash)) {\\n        if (count < 2) return -1;\\n        minRounds += Math.ceil(count / 3);\\n    }\\n    \\n    return minRounds;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumRounds = function(tasks) {\\n    const hash = {};\\n    let minRounds = 0;\\n    \\n    for (const task of tasks) {\\n        hash[task] = hash[task] + 1 || 1;\\n    }\\n    \\n    for (const count of Object.values(hash)) {\\n        if (count < 2) return -1;\\n        minRounds += Math.ceil(count / 3);\\n    }\\n    \\n    return minRounds;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955642,
                "title": "c-0ms-o-n-commented-solution-easy-to-understand",
                "content": "Here is my commented solution to this question. I hope it helps...\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> m; // map to store task and its frequency\\n        for(int i=0; i<tasks.size(); i++)\\n            m[tasks[i]]++; // storing frequencies in map\\n        int answer=0;\\n        for(auto x:m){\\n            if(x.second==1) // if a task is present only once, return -1\\n                return -1;\\n            answer+=(x.second)/3;\\n            /* if x.second is not divisible by 3, then we would be required to consider the cases when only two tasks are selected \\n            - in last round for (x.second%3==2)\\n            - in last two rounds (x.second%3==1) */\\n            if(x.second%3==1 || x.second%3==2)\\n                answer++;\\n        }\\n        return answer;\\n    }\\n};\\n```\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n- where n is the size of vector tasks\\n\\nAny suggestions are highly appreciated !!!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> m; // map to store task and its frequency\\n        for(int i=0; i<tasks.size(); i++)\\n            m[tasks[i]]++; // storing frequencies in map\\n        int answer=0;\\n        for(auto x:m){\\n            if(x.second==1) // if a task is present only once, return -1\\n                return -1;\\n            answer+=(x.second)/3;\\n            /* if x.second is not divisible by 3, then we would be required to consider the cases when only two tasks are selected \\n            - in last round for (x.second%3==2)\\n            - in last two rounds (x.second%3==1) */\\n            if(x.second%3==1 || x.second%3==2)\\n                answer++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955299,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n     map<int,int> mp;\\n        for(auto task:tasks)\\n        {\\n            mp[task]++;\\n        }\\n        int ans=0;\\n        for(auto pr:mp)\\n        {\\n            if(pr.second==1)\\n            {\\n                return -1;\\n            }\\n            else if(pr.second==2)\\n            {\\n                ans++;\\n            }\\n            else\\n            {\\n                ans+=ceil((double)pr.second/3.0);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n     map<int,int> mp;\\n        for(auto task:tasks)\\n        {\\n            mp[task]++;\\n        }\\n        int ans=0;\\n        for(auto pr:mp)\\n        {\\n            if(pr.second==1)\\n            {\\n                return -1;\\n            }\\n            else if(pr.second==2)\\n            {\\n                ans++;\\n            }\\n            else\\n            {\\n                ans+=ceil((double)pr.second/3.0);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955288,
                "title": "clean-java-code",
                "content": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n  \\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int num : tasks){\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        int ans = 0;\\n        for(int key : map.keySet()){\\n            int val = map.get(key);\\n            if(val == 1) return -1;\\n            \\n            ans += val/3;\\n            if(val%3 != 0) ans += 1;\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n  \\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int num : tasks){\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2997519,
                "title": "simplest-c-map-o-n-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically its just simple maths in which if we first take all oureences in a map and then check if frequency of a number is divsible by 3that is the minimum rounds will take. ALso if remainder is 2 then we can take one more round beacuse 2 are left and if remainder is 1 then we have to take last 4 as (2 and 2) beacuse (3 and 1) is not doable so go wiht 2 and 2 . So if rem=1 we can do first freq-4 using 3 base rounding and rest 4 as (2 and 2).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust look at the code \\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& arr) {\\n       map<int,int>mp;\\n       int n=arr.size();\\n       for(int i=0;i<n;i++){\\n           mp[arr[i]]++;\\n       }\\n       int cnt=0;\\n       for(auto x:mp){\\n           if(x.second%3==0){\\n               cnt+=x.second/3;\\n              \\n           }\\n           else if(x.second%3==2){\\n             cnt+=x.second/3;\\n             cnt++;\\n           }\\n           else{\\n               cnt+=(x.second-4)/3;\\n               if((x.second-4)<0)return -1;\\n               cnt+=2;\\n           }\\n       }\\n       return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& arr) {\\n       map<int,int>mp;\\n       int n=arr.size();\\n       for(int i=0;i<n;i++){\\n           mp[arr[i]]++;\\n       }\\n       int cnt=0;\\n       for(auto x:mp){\\n           if(x.second%3==0){\\n               cnt+=x.second/3;\\n              \\n           }\\n           else if(x.second%3==2){\\n             cnt+=x.second/3;\\n             cnt++;\\n           }\\n           else{\\n               cnt+=(x.second-4)/3;\\n               if((x.second-4)<0)return -1;\\n               cnt+=2;\\n           }\\n       }\\n       return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997121,
                "title": "c-easy-fully-explained-map",
                "content": "# Intuition\\nif freq(level) == 1\\nwe cannot express in 3 tasks + 3 tasks + .. + 2 tasks\\n\\ncheck for freq(level) > 1\\nand try to express in 3 tasks + 3 tasks + .. + 2 tasks.\\n\\nso we should select the minimum number of 3 and 2.\\n\\nwe should select maximum of 3 tasks and at last add one (1 task or 2 task).\\n\\n# Approach\\nif freq(level) == 1 --> return -1;\\nif freq(level) == 2 --> one 2-task\\nif freq(level) == 3 --> one 3-task\\n\\nFrom observation, we can see that there\\'s only 3 possible outcomes.\\n\\n(A) If the frequency is 1, the task cannot be performed so we return -1.\\n(B) If the frequency is 3, the task can be performed and we return frequency/3.\\n(C) Now if the frequency is not completely divisible by 3, then the possible remainders are 1 and 2. Lets check them out:\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int>mp;\\n        for(int i = 0;i<tasks.size(); i++){\\n            mp[tasks[i]]++;\\n        }\\n        int ans = 0;\\n        for(auto x: mp){\\n            if(x.second <=1){\\n                return -1;\\n            }\\n      \\n            else {\\n               if(x.second%3 == 0)\\n               ans = ans + x.second/3;\\n\\n               else\\n               ans = ans + x.second/3 + 1;\\n\\n            }\\n\\n         \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int>mp;\\n        for(int i = 0;i<tasks.size(); i++){\\n            mp[tasks[i]]++;\\n        }\\n        int ans = 0;\\n        for(auto x: mp){\\n            if(x.second <=1){\\n                return -1;\\n            }\\n      \\n            else {\\n               if(x.second%3 == 0)\\n               ans = ans + x.second/3;\\n\\n               else\\n               ans = ans + x.second/3 + 1;\\n\\n            }\\n\\n         \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996726,
                "title": "c-using-map-efficient-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int ,int> mp;\\n        for(auto task : tasks){\\n            mp[task]++;\\n        }\\n        int round = 0;\\n        for(auto x : mp){\\n            if(x.second <=1){\\n                return -1;\\n            }\\n            else if(x.second == 2){\\n                round++;\\n            }\\n            else {\\n                round += ceil((double)x.second/3.0); \\n            }\\n        }\\n        return round;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int ,int> mp;\\n        for(auto task : tasks){\\n            mp[task]++;\\n        }\\n        int round = 0;\\n        for(auto x : mp){\\n            if(x.second <=1){\\n                return -1;\\n            }\\n            else if(x.second == 2){\\n                round++;\\n            }\\n            else {\\n                round += ceil((double)x.second/3.0); \\n            }\\n        }\\n        return round;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996693,
                "title": "one-line-c-solution",
                "content": "# Intuition\\nall about frequency so using map\\n\\n# Approach\\n1.If the frequency is 1, the task cannot be performed so we return -1.\\n2.If the frequency is 3, the task can be performed and we return frequency/3.\\n3.Now if the frequency is not completely divisible by 3, then return freq/3 + 1\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint countFreq(vector<int> arr, int n)\\n{\\n    int ans=0;\\n    unordered_map<int, int> mp;\\n \\n  \\n    for (int i = 0; i < n; i++)\\n        mp[arr[i]]++;\\n \\n    for (int i = 0; i < n; i++) {\\n      if (mp[arr[i]] != -1 && mp[arr[i]]==1)\\n      {\\n          \\n          return -1;\\n      }\\n      else if (mp[arr[i]] != -1 && mp[arr[i]]%3==0)\\n      {\\n          \\n          ans+=(mp[arr[i]])/3;\\n          mp[arr[i]] = -1;\\n      }\\n      else if (mp[arr[i]] != -1)\\n      {\\n          \\n          ans+=(mp[arr[i]])/3 +1;\\n          mp[arr[i]] = -1;\\n      }\\n    }\\n    return ans;\\n}\\n    int minimumRounds(vector<int>& tasks) {\\n        int n=tasks.size();\\n        return countFreq(tasks,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint countFreq(vector<int> arr, int n)\\n{\\n    int ans=0;\\n    unordered_map<int, int> mp;\\n \\n  \\n    for (int i = 0; i < n; i++)\\n        mp[arr[i]]++;\\n \\n    for (int i = 0; i < n; i++) {\\n      if (mp[arr[i]] != -1 && mp[arr[i]]==1)\\n      {\\n          \\n          return -1;\\n      }\\n      else if (mp[arr[i]] != -1 && mp[arr[i]]%3==0)\\n      {\\n          \\n          ans+=(mp[arr[i]])/3;\\n          mp[arr[i]] = -1;\\n      }\\n      else if (mp[arr[i]] != -1)\\n      {\\n          \\n          ans+=(mp[arr[i]])/3 +1;\\n          mp[arr[i]] = -1;\\n      }\\n    }\\n    return ans;\\n}\\n    int minimumRounds(vector<int>& tasks) {\\n        int n=tasks.size();\\n        return countFreq(tasks,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996352,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> mp;\\n        for(auto x: tasks) mp[x]++;\\n        int ans = 0;\\n        for(auto x: mp) {\\n            if(x.second < 2) return -1;\\n            ans += ceil(1.0 * x.second / 3);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> mp;\\n        for(auto x: tasks) mp[x]++;\\n        int ans = 0;\\n        for(auto x: mp) {\\n            if(x.second < 2) return -1;\\n            ans += ceil(1.0 * x.second / 3);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996323,
                "title": "c-hashmap-efficient-approach",
                "content": "# Intuition\\nWe need to count frequency of each element then apply conditions given in the problem.\\n\\n# Approach\\nWe use hashmap to store frequency of elements. Then, we check each element\\'s count if it is lesser than 2 we return -1. If its count is greater than 2, then we check whether that element is totally divided by 3, if yes then rounds will be count/3 else rounds will be cound/3 + 1. \\n**Example:** \\ntasks = [2,2,2,2]\\nrounds: count(2)/3+1 = 4/3+1 = 1+1 = 2\\nWe pass 2 tasks in the 1st round and again 2 tasks in the 2nd round.\\n\\ntasks = [2,2,2,2,2]\\nrounds: count(2)/3+1 = 5/3+1 = 1+1 = 2\\nWe pass 3/2 tasks in the 1st round and 2/3 tasks in the 2nd round.\\n\\ntasks = [2,2,2,2,2,2] (its count is totally divisible by 3)\\nrounds: count(2)/3 = 6/3 = 2\\nWe pass 3 tasks in the 1st round and again 3 tasks in the 2nd round.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int minimumRounds(vector<int>& tasks) \\n    {\\n        unordered_map<int,int> mp;\\n        for(auto &it : tasks)\\n            mp[it]++;\\n\\n        int rounds=0;\\n        for(auto it:mp)\\n        {\\n            if(it.second<2) return -1;\\n            if(it.second%3==0) rounds += it.second/3; //[2,2,2,2,2,2], rounds: 6/3 = 2 \\n            else rounds += it.second/3 + 1; //[2,2,2,2,2], rounds: 5/3 + 1 = 1 + 1 = 2\\n        }\\n        return rounds;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minimumRounds(vector<int>& tasks) \\n    {\\n        unordered_map<int,int> mp;\\n        for(auto &it : tasks)\\n            mp[it]++;\\n\\n        int rounds=0;\\n        for(auto it:mp)\\n        {\\n            if(it.second<2) return -1;\\n            if(it.second%3==0) rounds += it.second/3; //[2,2,2,2,2,2], rounds: 6/3 = 2 \\n            else rounds += it.second/3 + 1; //[2,2,2,2,2], rounds: 5/3 + 1 = 1 + 1 = 2\\n        }\\n        return rounds;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996272,
                "title": "c-easy-greedy-approach-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<tasks.size();i++){\\n            mp[tasks[i]]++;\\n        }\\n        int count=0;\\n        for(auto x: mp){       \\n            if(x.second ==1) return -1;\\n            while(x.second >3) {\\n                x.second-=3;\\n                count++;\\n            }\\n            if(x.second) count++;\\n        }\\n        return count;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<tasks.size();i++){\\n            mp[tasks[i]]++;\\n        }\\n        int count=0;\\n        for(auto x: mp){       \\n            if(x.second ==1) return -1;\\n            while(x.second >3) {\\n                x.second-=3;\\n                count++;\\n            }\\n            if(x.second) count++;\\n        }\\n        return count;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995917,
                "title": "c-simple-if-else-explaination-hashset",
                "content": "# Intuition\\n- We want to cover all the tasks in the lot of 2 or 3.\\n- To achieve that, we will store the frequency of tasks.\\n- If the frequency is 1, we will directly return -1. Bcz mp[it]<2 or mp[it]<3.\\n- If the frequency of any task is exactly 2 or 3. Take it as one round.\\n- Now the question arises, if the frequency is greater than 2 or 3.\\n-> We will try to cover all the tasks, which we can cover in the lot of 3.\\n-> And then for remaining tasks, we cover under lot of 2. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        // store the frequencies \\n        map<int,int> mp;\\n        for( auto &it : tasks ) mp[it]++;\\n\\n        int rounds = 0;\\n\\n        for( auto &it : mp ){\\n            // tasks = [2,3,3]\\n            if( it.second == 1 ) return -1;\\n            // tasks = [2,2,3,3,2]\\n            else if( it.second == 2 || it.second == 3 ) rounds++;\\n\\n            // tasks = [4,4,4,4,4]\\n            else if ( it.second>3 ){\\n                int rem = it.second%3;\\n                // multiple of 3 \\n                rounds += it.second/3;\\n                // multiple of 2 \\n                if( rem%2 == 0 ) rounds += rem/2;\\n                // For tasks = [4,4,4,4], rem == 1;\\n                else rounds += 1;\\n            }\\n        }\\n\\n        return rounds;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        // store the frequencies \\n        map<int,int> mp;\\n        for( auto &it : tasks ) mp[it]++;\\n\\n        int rounds = 0;\\n\\n        for( auto &it : mp ){\\n            // tasks = [2,3,3]\\n            if( it.second == 1 ) return -1;\\n            // tasks = [2,2,3,3,2]\\n            else if( it.second == 2 || it.second == 3 ) rounds++;\\n\\n            // tasks = [4,4,4,4,4]\\n            else if ( it.second>3 ){\\n                int rem = it.second%3;\\n                // multiple of 3 \\n                rounds += it.second/3;\\n                // multiple of 2 \\n                if( rem%2 == 0 ) rounds += rem/2;\\n                // For tasks = [4,4,4,4], rem == 1;\\n                else rounds += 1;\\n            }\\n        }\\n\\n        return rounds;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995770,
                "title": "clean-code-fully-explained-hash-map-java",
                "content": "# Request \\uD83D\\uDE0A :\\n```\\nIf you find this solution easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D.\\n```\\n# Approach [Explained in Comments] :\\n```\\nclass Solution \\n{\\n    public int minimumRounds(int[] tasks) \\n    {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (int t : tasks) \\n            map.put(t, map.getOrDefault(t, 0) + 1);//adding values in Map\\n        \\n        int count = 0;\\n        for (int key : map.keySet()) //creating a set and picking values form set\\n        {\\n            int value = map.get(key);\\n            if (value == 1) //single task\\n                return -1;\\n            else if (value == 2) //complete 2 task \\n                count += 1;\\n            else if (value % 3 == 0)//complete 3 task\\n                count += value / 3;//max 3 tasks & increase round count\\n            else \\n                count += value / 3 + 1;//greater than 3 tasks & increase round count\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nIf you find this solution easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D.\\n```\n```\\nclass Solution \\n{\\n    public int minimumRounds(int[] tasks) \\n    {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (int t : tasks) \\n            map.put(t, map.getOrDefault(t, 0) + 1);//adding values in Map\\n        \\n        int count = 0;\\n        for (int key : map.keySet()) //creating a set and picking values form set\\n        {\\n            int value = map.get(key);\\n            if (value == 1) //single task\\n                return -1;\\n            else if (value == 2) //complete 2 task \\n                count += 1;\\n            else if (value % 3 == 0)//complete 3 task\\n                count += value / 3;//max 3 tasks & increase round count\\n            else \\n                count += value / 3 + 1;//greater than 3 tasks & increase round count\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995335,
                "title": "c-easy-greedy-solution-using-hashmap",
                "content": "# **C++ Easy Greedy Solution Using HashMap**\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int>m;\\n        for(auto&task:tasks){\\n            m[task]++;\\n        }\\n        int ans=0;\\n        for(auto it=m.begin();it!=m.end();it++){\\n            if(it->second==1){\\n                ans=-1;\\n                break;\\n            }\\n            else{\\n                ans+=ceil((it->second)/3.0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# **Please Upvote it really Motivates me\\uD83D\\uDE0A**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int>m;\\n        for(auto&task:tasks){\\n            m[task]++;\\n        }\\n        int ans=0;\\n        for(auto it=m.begin();it!=m.end();it++){\\n            if(it->second==1){\\n                ans=-1;\\n                break;\\n            }\\n            else{\\n                ans+=ceil((it->second)/3.0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960040,
                "title": "minimum-rounds-to-complete-all-tasks",
                "content": "```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        d=Counter(tasks)\\n        c=0\\n\\t\\t\"\"\" If any task is present only once it cannot be completed\"\"\"\\n        for v in d.values():\\n            if v==1:\\n                return -1\\n        \\n        for k,v in d.items():\\n            if v==2 or v==3:\\n                c+=1\\n            elif v>3:\\n                c+=math.ceil(v/3)\\n        return c\\n\\t\\t\\nPlease upvote if you find this helpful\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        d=Counter(tasks)\\n        c=0\\n\\t\\t\"\"\" If any task is present only once it cannot be completed\"\"\"\\n        for v in d.values():\\n            if v==1:\\n                return -1\\n        \\n        for k,v in d.items():\\n            if v==2 or v==3:\\n                c+=1\\n            elif v>3:\\n                c+=math.ceil(v/3)\\n        return c\\n\\t\\t\\nPlease upvote if you find this helpful\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999499,
                "title": "java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for (int t : tasks) {\\n            count.put(t, count.getOrDefault(t, 0) + 1);\\n        }\\n        int ans = 0;\\n        for (int x : count.values()) {\\n            if (x == 1) {\\n                return -1;\\n            }\\n            ans += x / 3 + (x % 3 == 0 ? 0 : 1);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n#### My initial approach\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer, Integer> count = new HashMap<>();\\n        for (int t : tasks) {\\n            count.put(t, count.getOrDefault(t, 0) + 1);\\n        }\\n        int result = 0;\\n        for (int x : count.values()) {\\n            if (x == 1) return -1;\\n            result += x / 3;\\n            if(x % 3 != 0) result++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for (int t : tasks) {\\n            count.put(t, count.getOrDefault(t, 0) + 1);\\n        }\\n        int ans = 0;\\n        for (int x : count.values()) {\\n            if (x == 1) {\\n                return -1;\\n            }\\n            ans += x / 3 + (x % 3 == 0 ? 0 : 1);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer, Integer> count = new HashMap<>();\\n        for (int t : tasks) {\\n            count.put(t, count.getOrDefault(t, 0) + 1);\\n        }\\n        int result = 0;\\n        for (int x : count.values()) {\\n            if (x == 1) return -1;\\n            result += x / 3;\\n            if(x % 3 != 0) result++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999367,
                "title": "python-solution-beats-95",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        d, count = Counter(tasks), 0\\n        if 1 in d.values():\\n            return -1\\n        for i in d.values():\\n            count+=(i+2)//3\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        d, count = Counter(tasks), 0\\n        if 1 in d.values():\\n            return -1\\n        for i in d.values():\\n            count+=(i+2)//3\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999219,
                "title": "map-c-stl-o-n-space-and-time",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int> mp;\\n        for(int x:tasks) mp[x]++;\\n        int ans=0;\\n\\n        for(auto x:mp)\\n        {\\n            if(x.second==1) return -1;\\n            else if(x.second%3==0) ans+=(x.second/3);\\n            else if(x.second%3==2 || x.second%3==1) ans+=(x.second/3 + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int> mp;\\n        for(int x:tasks) mp[x]++;\\n        int ans=0;\\n\\n        for(auto x:mp)\\n        {\\n            if(x.second==1) return -1;\\n            else if(x.second%3==0) ans+=(x.second/3);\\n            else if(x.second%3==2 || x.second%3==1) ans+=(x.second/3 + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997700,
                "title": "complete-all-task-mathematical-approach",
                "content": "# Intuition\\nLet\\'s understand this problem little more deeper, consider a number 10 how can we achieve it in minimum tries?\\nThe easiest way any one can figure out is the number of times 3 jobs can be done which is 3 * 3 = 9 and we have a remainder 1.\\n\\nOne key thing we may observe is that 3 can be done by subtracting one from 9 and doing it as 2 jobs of 2. which means 4 can be achieved by 2 jobs of 2.\\n\\nNOTE: this will work for any number except 1, for which we should return -1.\\n\\n# Approach\\n- Find the frequency of the number using a hashmap.\\n- Find whether the frequency is 1, if so return -1, else\\n- Find the divisibility of that number by 3 and the reminder.\\n- If the remainder is greater than 0 then add one to the result.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n + m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        int res=0;\\n        HashMap<Integer, Integer> map= new HashMap();\\n        for(int i: tasks){\\n        \\tint count = map.getOrDefault(i, 0);\\n        \\tmap.put(i, ++count);\\n        }\\n\\t\\tfor (Map.Entry<Integer, Integer> e : map.entrySet()) {\\n\\t\\t\\tint i = e.getValue();\\n\\t\\t\\tif (i == 1)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\tres = res + i / 3;\\n\\t\\t\\tif (i % 3 == 0)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tres++;\\n\\t\\t}\\n\\t\\treturn res; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        int res=0;\\n        HashMap<Integer, Integer> map= new HashMap();\\n        for(int i: tasks){\\n        \\tint count = map.getOrDefault(i, 0);\\n        \\tmap.put(i, ++count);\\n        }\\n\\t\\tfor (Map.Entry<Integer, Integer> e : map.entrySet()) {\\n\\t\\t\\tint i = e.getValue();\\n\\t\\t\\tif (i == 1)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\tres = res + i / 3;\\n\\t\\t\\tif (i % 3 == 0)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tres++;\\n\\t\\t}\\n\\t\\treturn res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997255,
                "title": "easiest-c-solution-with-detailed-explanation",
                "content": "**PLEASE UPVOTE IF YOU FIND THIS APPROACH HELPFUL :)**\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a frequency-related problem, so we\\'ll use a map data structure to solve it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs we can observe that there\\'s only 2 possible outputs:-\\n1. If the frequency is equal to 1 then task can\\'t be performed so we will return -1.\\n2. If the frequency is greater than 1 then tasks can be performed and with two sub possibilies:-\\n    a. If the frequency is divisible by 3 then number of rounds required will be task\\'s frequency/3.\\n    b. If the frequency is not divisible by 3 then number of rounds required will be task\\'s (frequency/3)+1, as 1 or 2 tasks will be remaining in last and can be shifted with other tasks using one more round.\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n\\n        int rounds = 0;\\n\\n        // creating and initializing the map\\n        unordered_map<int, int> m;\\n        for(int i=0; i<tasks.size(); i++){\\n            m[tasks[i]]++;\\n        }\\n\\n        for(auto i:m){\\n            // when no of tasks with same level is only 1\\n            if(i.second == 1){\\n                return -1;\\n            }\\n            \\n            // when no of tasks with same level is more than 1\\n            else{\\n\\n                // when no of tasks with same level is divisible by 3\\n                if(i.second%3 == 0){\\n                    rounds += (i.second/3);\\n                }\\n                \\n                // when no of tasks with same level is remaining 1 or 2 in last, will add 1 more to round\\n                else if(i.second%3 == 1 || i.second%3 == 2){\\n                    rounds += (i.second/3)+1;\\n                }\\n            }\\n        }\\n\\n        return rounds;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n\\n        int rounds = 0;\\n\\n        // creating and initializing the map\\n        unordered_map<int, int> m;\\n        for(int i=0; i<tasks.size(); i++){\\n            m[tasks[i]]++;\\n        }\\n\\n        for(auto i:m){\\n            // when no of tasks with same level is only 1\\n            if(i.second == 1){\\n                return -1;\\n            }\\n            \\n            // when no of tasks with same level is more than 1\\n            else{\\n\\n                // when no of tasks with same level is divisible by 3\\n                if(i.second%3 == 0){\\n                    rounds += (i.second/3);\\n                }\\n                \\n                // when no of tasks with same level is remaining 1 or 2 in last, will add 1 more to round\\n                else if(i.second%3 == 1 || i.second%3 == 2){\\n                    rounds += (i.second/3)+1;\\n                }\\n            }\\n        }\\n\\n        return rounds;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997067,
                "title": "python-sol-beats-95-easy-to-understand",
                "content": "# Intuition\\nreturn -1 in case 1 in tasks\\nif not \\u2013 check the remainders of the division by 3\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        k = 0\\n        c = Counter(tasks).values()\\n        if 1 in c:\\n            return -1\\n        for j in c:\\n            k += j // 3 + bool(j % 3)\\n        return k\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        k = 0\\n        c = Counter(tasks).values()\\n        if 1 in c:\\n            return -1\\n        for j in c:\\n            k += j // 3 + bool(j % 3)\\n        return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996569,
                "title": "ruby-solution-3-lines",
                "content": "# Approach\\nFirstly, let\\'s check how many rounds the number of the same level tasks needs.\\n\\n![image.png](https://assets.leetcode.com/users/images/baf42dfb-5390-445e-bf44-4d425c67b3c0_1672817322.0993586.png)\\n\\nAs you can see, there is a pattern. If the number of the same level tasks is 1, it fails. If it is greater than 1, the necessary round can be found by adding 2 to it and dividing by 3. For example; if the total number of the same level tasks is `7`, the result is `(7 + 2) / 3 => 3`.\\n\\n# Code\\n```\\n# @param {Integer[]} tasks\\n# @return {Integer}\\ndef minimum_rounds(tasks)\\n  tasks_values = tasks.tally.values\\n\\n  return -1 if tasks_values.include? 1\\n\\n  tasks_values.sum { |val| (val + 2) / 3 }\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} tasks\\n# @return {Integer}\\ndef minimum_rounds(tasks)\\n  tasks_values = tasks.tally.values\\n\\n  return -1 if tasks_values.include? 1\\n\\n  tasks_values.sum { |val| (val + 2) / 3 }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2996562,
                "title": "c-easy-solution-tc-o-n-sc-o-n",
                "content": "# Intuition\\nthe first appraoch came in my mind was using linear time, i find it easy and solved it.\\n\\n# Approach\\nwe are storing the difficulty level of each tasks in map, then if it is divisible by 3 then simply add the quotient to count otherwise add quotient+1. return count.\\n\\n# Complexity\\n- Time complexity:\\nO(n) \\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int count=0;\\n        map <int,int> mp;\\n        for(int i:tasks){\\n            mp[i]++;\\n        }\\n        //for(auto it:mp){\\n        //    cout<<it.first<<\" \"<<it.second<<endl;\\n        //}\\n        for(auto it:mp){\\n            if(it.second==1) return -1;\\n            if(it.second!=0 && it.second%3==0){\\n                count+=(it.second/3);\\n            }\\n            else if(it.second!=0){\\n                count+=(it.second/3+1);\\n            }\\n           // cout<<count<<endl;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int count=0;\\n        map <int,int> mp;\\n        for(int i:tasks){\\n            mp[i]++;\\n        }\\n        //for(auto it:mp){\\n        //    cout<<it.first<<\" \"<<it.second<<endl;\\n        //}\\n        for(auto it:mp){\\n            if(it.second==1) return -1;\\n            if(it.second!=0 && it.second%3==0){\\n                count+=(it.second/3);\\n            }\\n            else if(it.second!=0){\\n                count+=(it.second/3+1);\\n            }\\n           // cout<<count<<endl;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2996431,
                "title": "java-simple-greedy-counting",
                "content": "# Intuition\\nCount frequencies of number. If you can divide by 3, then go for it because it will minimize the result. If you can\\'t then add +1 to the result of dividing by 3. If the frequency is 1 then return -1 because the problem states that we must take at least 2 elements at a time.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> numFreq = new HashMap<>();\\n        for (int x : tasks) {\\n            numFreq.put(x, numFreq.getOrDefault(x, 0) + 1);\\n        }\\n\\n        int rounds = 0;\\n        for (int freq : numFreq.values()) {\\n            if(freq < 2) return -1; // Can\\'t divide\\n            rounds += freq / 3;\\n            if(freq % 3 != 0) rounds++;\\n        }\\n\\n        return rounds;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> numFreq = new HashMap<>();\\n        for (int x : tasks) {\\n            numFreq.put(x, numFreq.getOrDefault(x, 0) + 1);\\n        }\\n\\n        int rounds = 0;\\n        for (int freq : numFreq.values()) {\\n            if(freq < 2) return -1; // Can\\'t divide\\n            rounds += freq / 3;\\n            if(freq % 3 != 0) rounds++;\\n        }\\n\\n        return rounds;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996311,
                "title": "java-5-solutions",
                "content": "# 5.counter + sort\\n```\\n    //5.counter + sort\\n    //Runtime: 15ms 95%; Memory: 84.6MB 60%\\n    //Time: O(N * logN); Space: O(logN)\\n    public int minimumRounds(int[] tasks) {\\n        Arrays.sort(tasks);\\n        int count = 0, res = 0;\\n        for (int i = 0; i < tasks.length; i++) {\\n            count++;\\n            if (i == tasks.length - 1 || tasks[i] != tasks[i + 1]) {\\n                if (count == 1) return -1;\\n                res += count / 3;\\n                if (count % 3 != 0) res++;\\n                count = 0;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n# 4.counter\\n```\\n    //4.counter\\n    //Time: O(N); Space: O(N)\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> counter = new HashMap<>();\\n        for (int i = 0; i < tasks.length; i++)\\n            counter.put(tasks[i], counter.getOrDefault(tasks[i], 0) + 1);\\n\\n        int res = 0;\\n        for (Map.Entry<Integer,Integer> entry: counter.entrySet()){\\n            int count = entry.getValue();\\n            if (count <= 1) return -1;\\n            res += count / 3;\\n            if (count % 3 != 0) res++;\\n        }\\n        return res;\\n    }\\n```\\n# 3.DP bottom-up\\n```\\n    //3.DP bottom-up\\n    //Runtime: 28ms 93%; Memory: 83.6MB 62%\\n    //Time: O(N * logN + N); Space: O(logN)\\n    //Time: O(N * logN); Space: O(logN)\\n    public int minimumRounds_3(int[] tasks) {\\n        Arrays.sort(tasks);\\n\\n        int dp1 = Integer.MAX_VALUE, dp2 = 0, dp3 = 0;\\n        for (int i = tasks.length - 2; i >= 0; i--) {\\n            int tmp = Integer.MAX_VALUE;\\n\\n            if (tasks[i + 1] == tasks[i])\\n                tmp = Math.min(tmp, dp2);\\n\\n            if (i + 2 < tasks.length && tasks[i + 2] == tasks[i])\\n                tmp = Math.min(tmp, dp3);\\n\\n            dp3 = dp2;\\n            dp2 = dp1;\\n            dp1 = tmp == Integer.MAX_VALUE ? tmp : tmp + 1;\\n        }\\n        return dp1 == Integer.MAX_VALUE ? -1 : dp1;\\n    }\\n```\\n# 2.DP bottom-up\\n```\\n    //2.DP bottom-up\\n    //Runtime: 17ms 95%; Memory: 52.3MB 99%\\n    //Time: O(N * logN + N); Space: O(logN + N)\\n    //Time: O(N * logN); Space: O(N)\\n    public int minimumRounds_2(int[] tasks) {\\n        Arrays.sort(tasks);\\n\\n        int[] dp = new int[tasks.length + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[tasks.length] = 0;\\n\\n        for (int i = tasks.length - 2; i >= 0; i--) {\\n            if (tasks[i] != tasks[i + 1] ) continue;\\n\\n            if (tasks[i + 1] == tasks[i])\\n                dp[i] = Math.min(dp[i], dp[i + 2]);\\n            if (i + 2 < tasks.length && tasks[i + 2] == tasks[i])\\n                dp[i] = Math.min(dp[i], dp[i + 3]);\\n\\n            if (dp[i] != Integer.MAX_VALUE)\\n                dp[i] = dp[i] + 1;\\n        }\\n        return dp[0] == Integer.MAX_VALUE ? -1 : dp[0] ;\\n    }\\n```\\n# 1.recursion + memo\\n```\\n    //1.recursion + memo\\n    //Runtime: 28ms 93%; Memory: 58MB 75%\\n    //Time: O(N * logN + N); Space: O(logN + N)\\n    //Time: O(N * logN); Space: O(N)\\n    public int minimumRounds_1(int[] tasks) {\\n        Arrays.sort(tasks);\\n        int res = helper(tasks ,0, new int[tasks.length]);\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n\\n    private int helper(int[] tasks, int begin, int[] memo){\\n        if (begin >= tasks.length) return 0;\\n\\n        if (memo[begin] != 0) return memo[begin];\\n\\n        int res = Integer.MAX_VALUE;\\n        if (begin + 1 < tasks.length && tasks[begin + 1] == tasks[begin])\\n            res = Math.min(res, helper(tasks, begin + 2, memo));\\n        if (begin + 2 < tasks.length && tasks[begin + 2] == tasks[begin])\\n            res = Math.min(res, helper(tasks, begin + 3, memo));\\n\\n        return memo[begin] = res == Integer.MAX_VALUE ? res : res + 1;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\n    //5.counter + sort\\n    //Runtime: 15ms 95%; Memory: 84.6MB 60%\\n    //Time: O(N * logN); Space: O(logN)\\n    public int minimumRounds(int[] tasks) {\\n        Arrays.sort(tasks);\\n        int count = 0, res = 0;\\n        for (int i = 0; i < tasks.length; i++) {\\n            count++;\\n            if (i == tasks.length - 1 || tasks[i] != tasks[i + 1]) {\\n                if (count == 1) return -1;\\n                res += count / 3;\\n                if (count % 3 != 0) res++;\\n                count = 0;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n    //4.counter\\n    //Time: O(N); Space: O(N)\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> counter = new HashMap<>();\\n        for (int i = 0; i < tasks.length; i++)\\n            counter.put(tasks[i], counter.getOrDefault(tasks[i], 0) + 1);\\n\\n        int res = 0;\\n        for (Map.Entry<Integer,Integer> entry: counter.entrySet()){\\n            int count = entry.getValue();\\n            if (count <= 1) return -1;\\n            res += count / 3;\\n            if (count % 3 != 0) res++;\\n        }\\n        return res;\\n    }\\n```\n```\\n    //3.DP bottom-up\\n    //Runtime: 28ms 93%; Memory: 83.6MB 62%\\n    //Time: O(N * logN + N); Space: O(logN)\\n    //Time: O(N * logN); Space: O(logN)\\n    public int minimumRounds_3(int[] tasks) {\\n        Arrays.sort(tasks);\\n\\n        int dp1 = Integer.MAX_VALUE, dp2 = 0, dp3 = 0;\\n        for (int i = tasks.length - 2; i >= 0; i--) {\\n            int tmp = Integer.MAX_VALUE;\\n\\n            if (tasks[i + 1] == tasks[i])\\n                tmp = Math.min(tmp, dp2);\\n\\n            if (i + 2 < tasks.length && tasks[i + 2] == tasks[i])\\n                tmp = Math.min(tmp, dp3);\\n\\n            dp3 = dp2;\\n            dp2 = dp1;\\n            dp1 = tmp == Integer.MAX_VALUE ? tmp : tmp + 1;\\n        }\\n        return dp1 == Integer.MAX_VALUE ? -1 : dp1;\\n    }\\n```\n```\\n    //2.DP bottom-up\\n    //Runtime: 17ms 95%; Memory: 52.3MB 99%\\n    //Time: O(N * logN + N); Space: O(logN + N)\\n    //Time: O(N * logN); Space: O(N)\\n    public int minimumRounds_2(int[] tasks) {\\n        Arrays.sort(tasks);\\n\\n        int[] dp = new int[tasks.length + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[tasks.length] = 0;\\n\\n        for (int i = tasks.length - 2; i >= 0; i--) {\\n            if (tasks[i] != tasks[i + 1] ) continue;\\n\\n            if (tasks[i + 1] == tasks[i])\\n                dp[i] = Math.min(dp[i], dp[i + 2]);\\n            if (i + 2 < tasks.length && tasks[i + 2] == tasks[i])\\n                dp[i] = Math.min(dp[i], dp[i + 3]);\\n\\n            if (dp[i] != Integer.MAX_VALUE)\\n                dp[i] = dp[i] + 1;\\n        }\\n        return dp[0] == Integer.MAX_VALUE ? -1 : dp[0] ;\\n    }\\n```\n```\\n    //1.recursion + memo\\n    //Runtime: 28ms 93%; Memory: 58MB 75%\\n    //Time: O(N * logN + N); Space: O(logN + N)\\n    //Time: O(N * logN); Space: O(N)\\n    public int minimumRounds_1(int[] tasks) {\\n        Arrays.sort(tasks);\\n        int res = helper(tasks ,0, new int[tasks.length]);\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n\\n    private int helper(int[] tasks, int begin, int[] memo){\\n        if (begin >= tasks.length) return 0;\\n\\n        if (memo[begin] != 0) return memo[begin];\\n\\n        int res = Integer.MAX_VALUE;\\n        if (begin + 1 < tasks.length && tasks[begin + 1] == tasks[begin])\\n            res = Math.min(res, helper(tasks, begin + 2, memo));\\n        if (begin + 2 < tasks.length && tasks[begin + 2] == tasks[begin])\\n            res = Math.min(res, helper(tasks, begin + 3, memo));\\n\\n        return memo[begin] = res == Integer.MAX_VALUE ? res : res + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2996266,
                "title": "c-simple-solution-detailed-explanation",
                "content": "# Intuition\\nFirst we need to get frequency of each element as in each round, we can only do tasks with same value. We can either sort the numbers and then get their frequnecy or we can use a hashmap and get frequencies.\\n\\n# Approach\\n- If the freq (frequency) is 1, then we simply return -1 since it is not possible to remove 1 task only\\n- If the freq is 2, then we add 1 to total count since 2 elements can be removed in one go.\\n- If the freq is 3 then we add 1 to total count since 3 elements can be removed in one go.\\n- We see that we need minimum passes, so we will always try to remove 3 elements if possible rather than 2.\\n- If the freq is 4, we can remove 3 elements in one pass, for second pass we will have only 1 ele left and we will not be able to remove this. But if we remove 2 elements in first pass and 2 elments in second pass, then we can remove 4 elements in total 2 passes. The lesson from this example is that if `(freq % 3)` is 1, then we need to remove 2 elments each in 2 passes and, and the remaining `(freq - 4)` will now be multiple of 3 and can be removed in `(freq -4)/3` passes taking total to `(freq - 4)/3 + 2`.\\n- We can use if-else and do above process. Also all of this can be achieved by returning -1 in case of freq = 1 and `(freq + 2)/3` in all other cases. This will have less time complexity. \\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> m;\\n        int n = tasks.size();\\n        int ans = 0;\\n        for(int i = 0; i<n; i++)\\n        {\\n            if(m.count(tasks[i]))\\n            {\\n                m[tasks[i]]++;\\n            }\\n            else{\\n                m.insert(pair(tasks[i],1));\\n            }\\n        }\\n\\n        for(auto it = m.begin(); it!= m.end(); it++)\\n        {\\n            int num = it->second;\\n            if(num == 1)\\n                return -1;\\n            if(num % 3 == 0)\\n            {\\n                ans += num/3;\\n            }\\n            else{\\n                if(num % 3 == 2)\\n                {\\n                    ans += (num/3 + 1);\\n                }\\n                else{   // remainder is 1 & num >=4\\n                    ans = ans + ((num -4)/3 + 2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> m;\\n        int n = tasks.size();\\n        int ans = 0;\\n        for(int i = 0; i<n; i++)\\n        {\\n            if(m.count(tasks[i]))\\n            {\\n                m[tasks[i]]++;\\n            }\\n            else{\\n                m.insert(pair(tasks[i],1));\\n            }\\n        }\\n\\n        for(auto it = m.begin(); it!= m.end(); it++)\\n        {\\n            int num = it->second;\\n            if(num == 1)\\n                return -1;\\n            if(num % 3 == 0)\\n            {\\n                ans += num/3;\\n            }\\n            else{\\n                if(num % 3 == 2)\\n                {\\n                    ans += (num/3 + 1);\\n                }\\n                else{   // remainder is 1 & num >=4\\n                    ans = ans + ((num -4)/3 + 2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996137,
                "title": "c-2-approaches-greedy-approach-with-explanation-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf number of tasks with a difficulty is 1, only then it is not possible to complete all the tasks else we need to compute minimum rounds to complete tasks\\n\\nIn each round complete 3 tasks, till remaining tasks are more than 3.\\n\\nNow, when for remaining tasks there are 3 possibilities:\\n1. Remaining tasks = 0 \\n- We have our answer \\n(6 tasks at beginning, in 2 rounds all tasks are completed)\\n\\n---\\n\\n2. Remaining tasks = 1 \\n- Convert an already completed round of 3 tasks to 2 tasks. \\n- So now we have 2 tasks remaining which can be completed in 1 round of 2 tasks. \\n- Therefore add 1 more round to answer\\n\\n---\\n\\n3. Remaining tasks = 2\\n- 2 remaining tasks can be completed in 1 round of 2 tasks. \\n- Therefore add 1 more round to answer\\n\\n(I have used ceil function for these cases)\\n\\n# Approach 1\\nSort the tasks vector to group the tasks with same difficulties together\\n\\n# Complexity\\n- Time complexity:  $$O(nlogn)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ceil3(int curr)\\n    {\\n        return (curr/3)+(curr%3!=0);\\n    }\\n    int minimumRounds(vector<int>& tasks) \\n    {\\n        if(tasks.size()==1) return -1;\\n\\n        sort(tasks.begin(),tasks.end());\\n\\n        int n=tasks.size() , ans=0 , curr=1;\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(i==n || tasks[i]!=tasks[i-1])\\n            {\\n                if(curr==1) return -1;\\n                else ans+=ceil3(curr) , curr=1;\\n            } \\n            else\\n            {\\n                curr++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Approach 2\\nUse map to group tasks of same difficulties\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ceil3(int curr)\\n    {\\n        return (curr/3)+(curr%3!=0);\\n    }\\n    int minimumRounds(vector<int>& tasks) \\n    {\\n        if(tasks.size()==1) return -1;\\n        int n=tasks.size() , ans=0 ;\\n\\n        unordered_map<int,int>freq;\\n        for(int diff:tasks) freq[diff]++;\\n        \\n        for(auto [diff,count]:freq)\\n        {\\n            if(count==1) return -1;\\n            else ans+=ceil3(count) ;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ceil3(int curr)\\n    {\\n        return (curr/3)+(curr%3!=0);\\n    }\\n    int minimumRounds(vector<int>& tasks) \\n    {\\n        if(tasks.size()==1) return -1;\\n\\n        sort(tasks.begin(),tasks.end());\\n\\n        int n=tasks.size() , ans=0 , curr=1;\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(i==n || tasks[i]!=tasks[i-1])\\n            {\\n                if(curr==1) return -1;\\n                else ans+=ceil3(curr) , curr=1;\\n            } \\n            else\\n            {\\n                curr++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int ceil3(int curr)\\n    {\\n        return (curr/3)+(curr%3!=0);\\n    }\\n    int minimumRounds(vector<int>& tasks) \\n    {\\n        if(tasks.size()==1) return -1;\\n        int n=tasks.size() , ans=0 ;\\n\\n        unordered_map<int,int>freq;\\n        for(int diff:tasks) freq[diff]++;\\n        \\n        for(auto [diff,count]:freq)\\n        {\\n            if(count==1) return -1;\\n            else ans+=ceil3(count) ;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995559,
                "title": "ruby-1-liner",
                "content": "```\\ndef minimum_rounds(tasks)\\n\\n  tasks.tally.sum{ 1<_2 and (2+_2)/3 or return -1 }\\n\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef minimum_rounds(tasks)\\n\\n  tasks.tally.sum{ 1<_2 and (2+_2)/3 or return -1 }\\n\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2995554,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Property to observe --> if the frequency of number is 1 then answer will be -1, but if frequency is divisible by 3 then we get ans as (frequency/3), else it will be (frequency/3) + 1.\\n2. Take few examples -->\\n   To reach 13 we can use 3 three\\'s and 2 two\\'s (most efficient), also to reach 17 most efficient way is to use 5 three\\'s and 1 two\\'s,this can be understood by taking few examples.\\n3. Now our tasks is to count frequency and if it is 1 then return -1 else we can count most efficient way to reach that value and add it to answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Hope You Understand!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ Using Map\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        map<int,int>mp;\\n        int ans=0;\\n        for(auto i:tasks)\\n        {\\n            mp[i]++;//Calculate frequency\\n        }\\n        for(auto i:mp)\\n        {\\n            if(i.second==1)\\n            return -1; // If frequency is 1 return -1\\n            while(i.second>0)\\n            {\\n                if(i.second%3==0)\\n                {\\n                    ans+=(i.second/3); // If multiple of 3\\n                    i.second=0;\\n                }\\n                else \\n                {\\n                    ans+=((i.second/3) +1); // If not multiple of 3\\n                    i.second=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        map<int,int>mp;\\n        int ans=0;\\n        for(auto i:tasks)\\n        {\\n            mp[i]++;//Calculate frequency\\n        }\\n        for(auto i:mp)\\n        {\\n            if(i.second==1)\\n            return -1; // If frequency is 1 return -1\\n            while(i.second>0)\\n            {\\n                if(i.second%3==0)\\n                {\\n                    ans+=(i.second/3); // If multiple of 3\\n                    i.second=0;\\n                }\\n                else \\n                {\\n                    ans+=((i.second/3) +1); // If not multiple of 3\\n                    i.second=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994788,
                "title": "c-o-n-using-some-linq",
                "content": "# Approach\\nWe can easily get element counts using LINQs GroupBy and Select. GroupBy generates an `IEnumerable` for each group key, with `.Select()` we can extract just the counts.\\nWe then process each of these counts.\\nIf `1` then we cant complete.\\nIf `count % 3 == 0` then we can complete the tasks in `count / 3` rounds\\nIf `count % 3 == 1` then we need 2 rounds of completing two tasks + `(count - 4) / 3` rounds of completing 3. `(count - 4)` since we completed 2 rounds of 2 tasks.\\nIf `count % 3 == 1` We need to do one round of two tasks + `(count - 2) / 3` of 3 tasks.\\n\\n# Complexity\\n- Time complexity:\\n`O(n)` at most we have `n` groups and we need to check them all\\n\\n- Space complexity:\\n`O(n)` at most we store counts `n` groups\\n\\n# Code\\n``` CSharp\\npublic class Solution {\\n    public int MinimumRounds(int[] tasks) {\\n        var groups = tasks.GroupBy(t => t).Select(t => t.Count());\\n        var rounds = 0;\\n        foreach (var count in groups) {\\n            if (count == 1) return -1;\\n            rounds += (count % 3) switch {\\n                0 => count / 3,\\n                1 => 2 + (count - 4) / 3,\\n                2 => 1 + (count - 2) / 3\\n            };\\n        }\\n        return rounds;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "``` CSharp\\npublic class Solution {\\n    public int MinimumRounds(int[] tasks) {\\n        var groups = tasks.GroupBy(t => t).Select(t => t.Count());\\n        var rounds = 0;\\n        foreach (var count in groups) {\\n            if (count == 1) return -1;\\n            rounds += (count % 3) switch {\\n                0 => count / 3,\\n                1 => 2 + (count - 4) / 3,\\n                2 => 1 + (count - 2) / 3\\n            };\\n        }\\n        return rounds;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994715,
                "title": "easy-solution-with-explanation-c-o-n",
                "content": "\\nWe will keep the frequency (f) of each level in a map.\\nIf ```f == 1```, we can only complete either 2 or 3 tasks of the same level. Hence, no solution possible.\\n\\nIf ```f % 3 == 0```, then we can complete 3 tasks in every round which will be equal to ```f/3```.\\nIf ```f % 3 != 0```, then number of rounds will always be ```f/3 + 1```.\\n\\n# Complexity\\n- Time complexity:\\n*O(n)*\\n\\n- Space complexity:\\n*O(n)*\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> mp;\\n        for(int& task : tasks) mp[task]++;\\n        \\n        int ans = 0;        \\n        for(auto [_, freq] : mp)\\n        {\\n            if(freq == 1) return -1;\\n            ans += (freq % 3 == 0) ? freq/3 : freq/3 + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```f == 1```\n```f % 3 == 0```\n```f/3```\n```f % 3 != 0```\n```f/3 + 1```\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> mp;\\n        for(int& task : tasks) mp[task]++;\\n        \\n        int ans = 0;        \\n        for(auto [_, freq] : mp)\\n        {\\n            if(freq == 1) return -1;\\n            ans += (freq % 3 == 0) ? freq/3 : freq/3 + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969673,
                "title": "python-easy-code-using-hashmap",
                "content": "```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        mp={}\\n        # storing frequency of each element in mp\\n        for i in tasks:\\n            if i in mp:\\n                mp[i]+=1\\n            else:\\n                mp[i]=1\\n        cnt=0\\n        for i in mp:\\n            f=0\\n            while mp[i]>3:\\n                mp[i]-=3\\n                f=1\\n                cnt+=1\\n            if mp[i]==2 or mp[i]==3:\\n                cnt+=1\\n            elif f==0:\\n                return -1\\n            else:\\n                cnt+=1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        mp={}\\n        # storing frequency of each element in mp\\n        for i in tasks:\\n            if i in mp:\\n                mp[i]+=1\\n            else:\\n                mp[i]=1\\n        cnt=0\\n        for i in mp:\\n            f=0\\n            while mp[i]>3:\\n                mp[i]-=3\\n                f=1\\n                cnt+=1\\n            if mp[i]==2 or mp[i]==3:\\n                cnt+=1\\n            elif f==0:\\n                return -1\\n            else:\\n                cnt+=1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965957,
                "title": "c-simple-solution-unordered-map-easy-implementation",
                "content": "```\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        unordered_map<int,int> m;\\n        \\n        for(auto x:tasks) \\n            m[x]++;     //Storing all task one by one and increasing their frequency\\n        \\n        int ans=0;\\n        \\n        for(auto m1:m)\\n        {\\n            if(m1.second==1)\\n                return -1;          // If there is only one task we can dirctly return -1 because it will not be possible to complete task because we can complete either 2 or 3 of the same difficulty level.\\n            else if(m1.second%3==0)\\n                ans+=m1.second/3;   // if task of same diffuclty level is mutiple of 3 we can do 3 task in each round;\\n            else\\n            ans+=m1.second/3+1;     // Here we can take all the remaining case like if task of same difficulty level is 2 then it will add 1, if 4 or 5 then it will add 2 and so on.\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        unordered_map<int,int> m;\\n        \\n        for(auto x:tasks) \\n            m[x]++;     //Storing all task one by one and increasing their frequency\\n        \\n        int ans=0;\\n        \\n        for(auto m1:m)\\n        {\\n            if(m1.second==1)\\n                return -1;          // If there is only one task we can dirctly return -1 because it will not be possible to complete task because we can complete either 2 or 3 of the same difficulty level.\\n            else if(m1.second%3==0)\\n                ans+=m1.second/3;   // if task of same diffuclty level is mutiple of 3 we can do 3 task in each round;\\n            else\\n            ans+=m1.second/3+1;     // Here we can take all the remaining case like if task of same difficulty level is 2 then it will add 1, if 4 or 5 then it will add 2 and so on.\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1964309,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) we can use a map `m` to count the frequency of each value `x` of the input array `A`, then perform a linear scan to accumulate and memoize optimal solutions via linear bottom-up DP.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minimumRounds(A: IntArray, INF: Int = (1e9 + 7).toInt()): Int {\\n        var m = mutableMapOf<Int, Int>()\\n        for (x in A)\\n            m[x] = 1 + (m[x] ?: 0)\\n        var dp = mutableListOf<Int>(INF, INF, 1, 1) // \\uD83D\\uDED1 base cases for 0, 1, 2, 3\\n        fun f(x: Int): Int {\\n            while (dp.size <= x) {\\n                var n = dp.size\\n                var a = dp[n - 2]\\n                var b = dp[n - 3]\\n                dp.add(1 + Math.min(a, b))\\n            }\\n            return dp[x]\\n        }\\n        var t = m.map{ (_, x) -> f(x) }.toList()\\n        if (t.any{ it == INF })\\n            return -1\\n        return t.sum()!!\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minimumRounds = (A, m = new Map()) => {\\n    for (let x of A)\\n        m.set(x, 1 + (m.get(x) || 0));\\n    let dp = [Infinity, Infinity, 1, 1]; // \\uD83D\\uDED1 base cases for 0, 1, 2, 3\\n    let f = x => {\\n        while (dp.length <= x) {\\n            let n = dp.length;\\n            let a = dp[n - 2],\\n                b = dp[n - 3];\\n            dp.push(1 + Math.min(a, b));\\n        }\\n        return dp[x];\\n    };\\n    let t = [...m].map(([_, cnt]) => cnt).map(x => f(x));\\n    if (t.some(x => x == Infinity))\\n        return -1;\\n    return _.sum(t);\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minimumRounds(self, A: List[int], INF = float(\\'inf\\')) -> int:\\n        m = Counter(A)\\n        dp = [INF, INF, 1, 1] # \\uD83D\\uDED1 base cases for 0, 1, 2, 3\\n        def f(x):\\n            while len(dp) <= x:\\n                n = len(dp)\\n                a = dp[n - 2]\\n                b = dp[n - 3]\\n                dp.append(1 + min(a, b))\\n            return dp[x]\\n        t = [f(x) for x in m.values()]\\n        if any(x == INF for x in t):\\n            return -1\\n        return sum(t)\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nuse std::cmp::min;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn minimum_rounds(A: VI) -> i32 {\\n        let INF = 1000000007;\\n        let mut m = HashMap::new();\\n        let mut dp = vec![INF, INF, 1, 1]; // \\uD83D\\uDED1 base cases for 0, 1, 2, 3\\n        for x in A {\\n            *m.entry(x).or_insert(0) += 1;\\n        }\\n        fn f(dp: &mut VI, x: i32) -> i32 {\\n            let x = x as usize;\\n            while dp.len() <= x {\\n                let n = dp.len();\\n                let a = dp[n - 2];\\n                let b = dp[n - 3];\\n                dp.push(1 + min(a, b));\\n            }\\n            dp[x]\\n        }\\n        let t: VI = m.into_values().map(|x| f(&mut dp, x)).collect();\\n        if t.iter().any(|&x| x == INF) { -1 } else { t.iter().sum() }\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    int minimumRounds(VI& A, int INF = 1e9 + 7, Map m = {}, VI t = {}) {\\n        for (auto x: A)\\n            ++m[x];\\n        VI dp{ INF, INF, 1, 1 }; // \\uD83D\\uDED1 base cases for 0, 1, 2, 3\\n        auto f = [&](auto x) {\\n            while (dp.size() <= x) {\\n                int n = dp.size(),\\n                    a = dp[n - 2],\\n                    b = dp[n - 3];\\n                dp.push_back(1 + min(a, b));\\n            }\\n            return dp[x];\\n        };\\n        transform(m.begin(), m.end(), back_inserter(t), [&](auto& pair) {\\n            auto [_, x] = pair;\\n            return f(x);\\n        });\\n        if (any_of(t.begin(), t.end(), [=](auto x) { return x == INF; }))\\n            return -1;\\n        return accumulate(t.begin(), t.end(), 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minimumRounds(A: IntArray, INF: Int = (1e9 + 7).toInt()): Int {\\n        var m = mutableMapOf<Int, Int>()\\n        for (x in A)\\n            m[x] = 1 + (m[x] ?: 0)\\n        var dp = mutableListOf<Int>(INF, INF, 1, 1) // \\uD83D\\uDED1 base cases for 0, 1, 2, 3\\n        fun f(x: Int): Int {\\n            while (dp.size <= x) {\\n                var n = dp.size\\n                var a = dp[n - 2]\\n                var b = dp[n - 3]\\n                dp.add(1 + Math.min(a, b))\\n            }\\n            return dp[x]\\n        }\\n        var t = m.map{ (_, x) -> f(x) }.toList()\\n        if (t.any{ it == INF })\\n            return -1\\n        return t.sum()!!\\n    }\\n}\\n```\n```\\nlet minimumRounds = (A, m = new Map()) => {\\n    for (let x of A)\\n        m.set(x, 1 + (m.get(x) || 0));\\n    let dp = [Infinity, Infinity, 1, 1]; // \\uD83D\\uDED1 base cases for 0, 1, 2, 3\\n    let f = x => {\\n        while (dp.length <= x) {\\n            let n = dp.length;\\n            let a = dp[n - 2],\\n                b = dp[n - 3];\\n            dp.push(1 + Math.min(a, b));\\n        }\\n        return dp[x];\\n    };\\n    let t = [...m].map(([_, cnt]) => cnt).map(x => f(x));\\n    if (t.some(x => x == Infinity))\\n        return -1;\\n    return _.sum(t);\\n};\\n```\n```\\nclass Solution:\\n    def minimumRounds(self, A: List[int], INF = float(\\'inf\\')) -> int:\\n        m = Counter(A)\\n        dp = [INF, INF, 1, 1] # \\uD83D\\uDED1 base cases for 0, 1, 2, 3\\n        def f(x):\\n            while len(dp) <= x:\\n                n = len(dp)\\n                a = dp[n - 2]\\n                b = dp[n - 3]\\n                dp.append(1 + min(a, b))\\n            return dp[x]\\n        t = [f(x) for x in m.values()]\\n        if any(x == INF for x in t):\\n            return -1\\n        return sum(t)\\n```\n```\\ntype VI = Vec<i32>;\\nuse std::cmp::min;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn minimum_rounds(A: VI) -> i32 {\\n        let INF = 1000000007;\\n        let mut m = HashMap::new();\\n        let mut dp = vec![INF, INF, 1, 1]; // \\uD83D\\uDED1 base cases for 0, 1, 2, 3\\n        for x in A {\\n            *m.entry(x).or_insert(0) += 1;\\n        }\\n        fn f(dp: &mut VI, x: i32) -> i32 {\\n            let x = x as usize;\\n            while dp.len() <= x {\\n                let n = dp.len();\\n                let a = dp[n - 2];\\n                let b = dp[n - 3];\\n                dp.push(1 + min(a, b));\\n            }\\n            dp[x]\\n        }\\n        let t: VI = m.into_values().map(|x| f(&mut dp, x)).collect();\\n        if t.iter().any(|&x| x == INF) { -1 } else { t.iter().sum() }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    int minimumRounds(VI& A, int INF = 1e9 + 7, Map m = {}, VI t = {}) {\\n        for (auto x: A)\\n            ++m[x];\\n        VI dp{ INF, INF, 1, 1 }; // \\uD83D\\uDED1 base cases for 0, 1, 2, 3\\n        auto f = [&](auto x) {\\n            while (dp.size() <= x) {\\n                int n = dp.size(),\\n                    a = dp[n - 2],\\n                    b = dp[n - 3];\\n                dp.push_back(1 + min(a, b));\\n            }\\n            return dp[x];\\n        };\\n        transform(m.begin(), m.end(), back_inserter(t), [&](auto& pair) {\\n            auto [_, x] = pair;\\n            return f(x);\\n        });\\n        if (any_of(t.begin(), t.end(), [=](auto x) { return x == INF; }))\\n            return -1;\\n        return accumulate(t.begin(), t.end(), 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960289,
                "title": "100-beats-in-both-runtime-and-memory-c-o-n",
                "content": "If the frequency counter `freq` is exactly `1` then we can\\'t complete it. So we should return -1.\\nOtherwise, we can use this way : `3 tasks + 3 tasks + . . . + 2 tasks + 2 tasks`. That is a lot of times `3 tasks` and at most `2 times 2 tasks`. \\n(Think we don\\'t need to perform 2 tasks 3 times. Because in that situation we can complete 3 tasks in 2 times!!!)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> freq;\\n        for (auto &task : tasks) {\\n            freq[task]++;\\n        }\\n        int round = 0;\\n        for (auto &element : freq) {\\n            if (element.second == 1) return -1;\\n            round += (element.second + 2)/3;\\n        }\\n        return round;\\n    }\\n};\\n```\\n\\nHere I used `(element.second + 2)` to take ceil value after dividing by `3`.\\nYou can write it in another way like this:\\n```\\nround += element.second + (element.second%3 > 0? 1 : 0);\\n```\\n\\nFeel free to comment if this helps you or not.",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> freq;\\n        for (auto &task : tasks) {\\n            freq[task]++;\\n        }\\n        int round = 0;\\n        for (auto &element : freq) {\\n            if (element.second == 1) return -1;\\n            round += (element.second + 2)/3;\\n        }\\n        return round;\\n    }\\n};\\n```\n```\\nround += element.second + (element.second%3 > 0? 1 : 0);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958192,
                "title": "java-consise-6-liner",
                "content": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int res = 0;\\n        for(int i:tasks) map.put(i,map.getOrDefault(i,0)+1);\\n        for(int i:map.values()){\\n            if(i == 1) return -1;\\n            if(i%3 == 0) res += i/3;\\n            else if((i-2) % 3 == 0) res += i/3 +1;\\n            else if(i%3 == 1) res += (i-4)/3 + 2;\\n            else if(i%2 == 0) res += i/2;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int res = 0;\\n        for(int i:tasks) map.put(i,map.getOrDefault(i,0)+1);\\n        for(int i:map.values()){\\n            if(i == 1) return -1;\\n            if(i%3 == 0) res += i/3;\\n            else if((i-2) % 3 == 0) res += i/3 +1;\\n            else if(i%3 == 1) res += (i-4)/3 + 2;\\n            else if(i%2 == 0) res += i/2;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956025,
                "title": "easy-java-solution-hashmap",
                "content": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        \\n        for(int val:tasks){\\n            hm.put(val,hm.getOrDefault(val,0)+1);\\n        }\\n        \\n        int count=0;\\n        \\n        for(int key:hm.keySet()){\\n            \\n            if(hm.get(key)<2){\\n                return -1;\\n            }\\n            \\n            int freq=hm.get(key);\\n            \\n            if(freq%3==0){\\n                count+=(freq/3);\\n            }else{\\n                count+=(freq/3)+1;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        \\n        for(int val:tasks){\\n            hm.put(val,hm.getOrDefault(val,0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1955789,
                "title": "java-easy-implementation",
                "content": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        \\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i: tasks){\\n            if(map.containsKey(i)) map.put(i, map.get(i) +1);\\n            else map.put(i,1);\\n        }\\n        \\n        int count = 0;\\n        for(int freq: map.values()){\\n            if(freq>1){\\n                count += freq/3;\\n                if(freq%3 !=0)\\n                count++;  \\n            } else  return -1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        \\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i: tasks){\\n            if(map.containsKey(i)) map.put(i, map.get(i) +1);\\n            else map.put(i,1);\\n        }\\n        \\n        int count = 0;\\n        for(int freq: map.values()){\\n            if(freq>1){\\n                count += freq/3;\\n                if(freq%3 !=0)\\n                count++;  \\n            } else  return -1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955322,
                "title": "javascript-easy-to-understand-hashmap",
                "content": "```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    \\n    function solve(x, cnt) {   \\n        if (x == 0) {\\n            return 0;\\n        }\\n        \\n        if (x < 2) {\\n            return Number.MAX_VALUE;\\n        }\\n        \\n        if (cnt[x]) {\\n            return cnt[x];\\n        }\\n        \\n        let left = 1 + solve(x - 3, cnt);\\n        let right = 1 + solve(x - 2, cnt);\\n        \\n        cnt[x] = Math.min(left, right);\\n        return cnt[x];\\n    }\\n    \\n    let hash = {};\\n    for (let x of tasks) {\\n        hash[x] = hash[x] ? hash[x] + 1 : 1;\\n    }\\n    \\n    let ans = 0;\\n    for (let x of Object.values(hash)) {\\n        let temp = solve(x, {});\\n        if (temp == Number.MAX_VALUE) {\\n            ans = -1;\\n            break;\\n        } else {\\n            ans += temp;\\n        }\\n    }\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    \\n    function solve(x, cnt) {   \\n        if (x == 0) {\\n            return 0;\\n        }\\n        \\n        if (x < 2) {\\n            return Number.MAX_VALUE;\\n        }\\n        \\n        if (cnt[x]) {\\n            return cnt[x];\\n        }\\n        \\n        let left = 1 + solve(x - 3, cnt);\\n        let right = 1 + solve(x - 2, cnt);\\n        \\n        cnt[x] = Math.min(left, right);\\n        return cnt[x];\\n    }\\n    \\n    let hash = {};\\n    for (let x of tasks) {\\n        hash[x] = hash[x] ? hash[x] + 1 : 1;\\n    }\\n    \\n    let ans = 0;\\n    for (let x of Object.values(hash)) {\\n        let temp = solve(x, {});\\n        if (temp == Number.MAX_VALUE) {\\n            ans = -1;\\n            break;\\n        } else {\\n            ans += temp;\\n        }\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955306,
                "title": "python-greedy-easy-to-understand-with-explanation",
                "content": "```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        # idea: greedy\\n        # find as many 3 as possible\\n        \\n        counter = Counter(tasks)\\n        steps = 0\\n        \\n        for key, value in counter.items():\\n            cur_step = self.composedBy(value)\\n            \\n            if cur_step == -1:\\n                return -1\\n            else:\\n                steps += cur_step\\n        \\n        return steps\\n    \\n    # find as many 3 as possible\\n    # every time substract a 2 form the num and mod by 3\\n    def composedBy(self, num):\\n        final_step = -1\\n        tmp_step = 0\\n        \\n        while num > 0:\\n            if num % 3 == 0:\\n                final_step = num // 3 + tmp_step\\n                return final_step\\n            \\n            else:\\n                num -= 2\\n                tmp_step += 1\\n        \\n        if num == 0:\\n            return tmp_step\\n        else:\\n            return final_step\\n                \\n                \\n                \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        # idea: greedy\\n        # find as many 3 as possible\\n        \\n        counter = Counter(tasks)\\n        steps = 0\\n        \\n        for key, value in counter.items():\\n            cur_step = self.composedBy(value)\\n            \\n            if cur_step == -1:\\n                return -1\\n            else:\\n                steps += cur_step\\n        \\n        return steps\\n    \\n    # find as many 3 as possible\\n    # every time substract a 2 form the num and mod by 3\\n    def composedBy(self, num):\\n        final_step = -1\\n        tmp_step = 0\\n        \\n        while num > 0:\\n            if num % 3 == 0:\\n                final_step = num // 3 + tmp_step\\n                return final_step\\n            \\n            else:\\n                num -= 2\\n                tmp_step += 1\\n        \\n        if num == 0:\\n            return tmp_step\\n        else:\\n            return final_step\\n                \\n                \\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 1955304,
                "title": "python-hashmap",
                "content": "**TC:** `O(n)`\\n**SC:** `O(n)`\\n```\\ndef minimumRounds(self, tasks: List[int]) -> int:\\n    d = Counter(tasks)\\n    res = 0 \\n    for i in d:\\n        n = d[i] \\n        if n<=1:\\n            return -1\\n        res += math.ceil(n/3)\\n    return res\\n```\\n\\nPLZ, PLZ **UPVOTE  GUYS!!**",
                "solutionTags": [],
                "code": "```\\ndef minimumRounds(self, tasks: List[int]) -> int:\\n    d = Counter(tasks)\\n    res = 0 \\n    for i in d:\\n        n = d[i] \\n        if n<=1:\\n            return -1\\n        res += math.ceil(n/3)\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3620358,
                "title": "beginner-friendly-explained-step-by-step-with-example",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n -  FIrst Store all the elements as key and their frequency as value in hashmap\\n - now iterate over hashmap , if you find any element which has frequency equals to 1 , we can\\'t complete that task because only 2 and 3 tasks allowed to complete.\\n - now for frequency greater than 1, since we need to return minimum rounds so we try to divide it by 3 if it is fully divisible by 3 then all quotient of it to our result --- and if it\\'s not complety divisible by 3 then we just add 1 to quotient because the remainder left by dividing by 3 will be occupied by presence of 2.\\n\\n# Example\\n\\n- 12---->completey divisible by 3 hence just add quotient [3,3,3,3]\\n- 13---->not  completey divisible by 3 hence just add quotient+1 [3,3,3,2,2]\\n- 14--->>not  completey divisible by 3 hence just add quotient+1 [3,3,3,3,2]\\n- 15---> completey divisible by 3 hence just add quotient [3,3,3,3,3]\\n\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n \\n\\n- Space complexity:\\n O(n)----for unordered_hashmap \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) \\n    {\\n        int res=0;\\n        unordered_map<int,int>helper;\\n        for(auto i:tasks)\\n        {\\n            helper[i]++;\\n        }\\n        for(auto i:helper)\\n        {\\n            if(i.second==1)\\n            {\\n              return -1;\\n            }\\n            if(i.second%3==0)\\n            {\\n                res+=(i.second/3);\\n            }\\n            else\\n            {\\n                res=res+(i.second/3)+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) \\n    {\\n        int res=0;\\n        unordered_map<int,int>helper;\\n        for(auto i:tasks)\\n        {\\n            helper[i]++;\\n        }\\n        for(auto i:helper)\\n        {\\n            if(i.second==1)\\n            {\\n              return -1;\\n            }\\n            if(i.second%3==0)\\n            {\\n                res+=(i.second/3);\\n            }\\n            else\\n            {\\n                res=res+(i.second/3)+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582124,
                "title": "dead-easy-detailed-description-for-dp-noob",
                "content": "\\n# Approach\\nPlease upvote\\n\\nEach time we can choose only one difficulty level.\\nLets say difficulty level X appeared K times. \\nWe need to take M rounds to finish X task which appeared K times.\\nIn each of the M rounds, we can take either 2 or 3 totalling K.\\nSo, \\nK=2x+3y where x+y=M\\nIn x rounds we collect 2 tasks, in y rounds we collect 3 tasks. Total we collect K tasks of a particular level. \\n\\nSolution: We will precompute the least number of rounds required to complete K tasks regardless of the difficulty level.\\n\\nEach difficulty level can come in the range 1-10^5\\nIf it comes only once, we cant collect the task since we can collect only 2 at a time or 3 at a time. So if a task comes only once, we return -1.\\n\\nDp definition:\\ndp[i]= least numbe of rounds required to collect a tasks of a particular difficulty level that appeard i times\\n\\nThe base conditions are:\\ndp[1]=-1\\ndp[2]=1\\ndp[3]=1\\ndp[4]=2\\n\\nDP expression:\\nfor(i=5 to 10^5)\\ndp[i]= Math.min(dp[i-2],dp[i-3])+1;\\nWe take minimum of number of rounds required to collect i-2 tasks and number of rounds rquired to collect i-3 tasks. Then we add 1 which is collecting the left over 2 or 3 tasks respectively. \\n\\nSummary:\\n1) Precompute least number of rounds required for any tasks which comes K times (k ranging from 1 to 10^5)\\n2) Use a hashmap <Task_difficulty, number_of_times_it_appeared> \\n3) Iterate over hashmap\\n    3.1) get the value for each Entry which denotes the count\\n    3.2) get the least number of rounds required for the value from the dp \\n    3.3) add it to the answer\\n    3.4) return -1 if count is 1\\n4) return ans\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nN-> for calculating dp array\\nN-> for iterating to create the hashmap\\nN-> for iterating over hashmap to calculate answer\\nO(n)\\n\\n- Space complexity:\\nN-> for HashMap\\nN-> for DP array\\nO(n)\\n\\nPlease upvote\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        int n=tasks.length;\\n        HashMap<Integer,Integer>hm=new HashMap();\\n        for(int i:tasks)\\n            hm.merge(i,1,(v1,v2)->v2=v1+1);\\n        int[] dp=new int[100001];\\n        //base conditions\\n        dp[1]=-1;\\n        dp[2]=1;\\n        dp[3]=1;\\n        dp[4]=2;\\n        for(int i=5;i<=100000;i++)\\n            dp[i]=Math.min(dp[i-2],dp[i-3])+1;\\n        int ans=0;\\n        for(Map.Entry<Integer,Integer>entry:hm.entrySet()){\\n            int count=entry.getValue();\\n            if(count==1)\\n                return -1;\\n            ans+=dp[count];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        int n=tasks.length;\\n        HashMap<Integer,Integer>hm=new HashMap();\\n        for(int i:tasks)\\n            hm.merge(i,1,(v1,v2)->v2=v1+1);\\n        int[] dp=new int[100001];\\n        //base conditions\\n        dp[1]=-1;\\n        dp[2]=1;\\n        dp[3]=1;\\n        dp[4]=2;\\n        for(int i=5;i<=100000;i++)\\n            dp[i]=Math.min(dp[i-2],dp[i-3])+1;\\n        int ans=0;\\n        for(Map.Entry<Integer,Integer>entry:hm.entrySet()){\\n            int count=entry.getValue();\\n            if(count==1)\\n                return -1;\\n            ans+=dp[count];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119693,
                "title": "simple-and-easy",
                "content": "cou# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int> mp;\\n        int n=tasks.size();\\n        for(int i=0;i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        int count=0;\\n        for(auto itr:mp){\\n            if(itr.second==1){\\n                return -1;\\n            }\\n            count+=itr.second/3;\\n            if(itr.second%3!=0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int> mp;\\n        int n=tasks.size();\\n        for(int i=0;i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        int count=0;\\n        for(auto itr:mp){\\n            if(itr.second==1){\\n                return -1;\\n            }\\n            count+=itr.second/3;\\n            if(itr.second%3!=0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008903,
                "title": "8-line-c-solution-using-maps",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<tasks.size();i++)  m[tasks[i]]++;\\n        int op=0;bool f=0;\\n        for(auto i:m){\\n            if(i.second==1) f=1;\\n            else op+=ceil(i.second/3.0);\\n        }\\n        return f?-1:op;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<tasks.size();i++)  m[tasks[i]]++;\\n        int op=0;bool f=0;\\n        for(auto i:m){\\n            if(i.second==1) f=1;\\n            else op+=ceil(i.second/3.0);\\n        }\\n        return f?-1:op;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999937,
                "title": "c-solution-daily-challenge",
                "content": "Runtime: 732 ms, faster than 5.73% of C++ online submissions for Minimum Rounds to Complete All Tasks.\\nMemory Usage: 104.6 MB, less than 24.39% of C++ online submissions for Minimum Rounds to \\nComplete\\n\\n\\n        int n=tasks.size();\\n        int count=0;\\n        map<int,int>Map;\\n        for(int i=0;i<n;i++)\\n            Map[tasks[i]]++;\\n        \\n         for(auto i:Map){\\n             if(i.second==1){\\n                 return -1;\\n             }\\n         }\\n        \\n        for(auto i:Map){\\n            cout<<i.first<<\"->\"<<i.second<<\"  \";\\n        }\\n        \\n        for(auto i:Map){\\n            int l=i.second;\\n            while(l>=2){\\n          if(l==2||l==3){\\n              count+=1;\\n              l=0;\\n          }else if(l==4||l==5){\\n              count+=2;\\n              l=0;\\n          }else{\\n              count=count+(l/3);\\n              l=l%3;\\n          }\\n            }\\n            if(l!=0){\\n                count+=1;\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "C",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Counting Sort"
                ],
                "code": "Runtime: 732 ms, faster than 5.73% of C++ online submissions for Minimum Rounds to Complete All Tasks.\\nMemory Usage: 104.6 MB, less than 24.39% of C++ online submissions for Minimum Rounds to \\nComplete\\n\\n\\n        int n=tasks.size();\\n        int count=0;\\n        map<int,int>Map;\\n        for(int i=0;i<n;i++)\\n            Map[tasks[i]]++;\\n        \\n         for(auto i:Map){\\n             if(i.second==1){\\n                 return -1;\\n             }\\n         }\\n        \\n        for(auto i:Map){\\n            cout<<i.first<<\"->\"<<i.second<<\"  \";\\n        }\\n        \\n        for(auto i:Map){\\n            int l=i.second;\\n            while(l>=2){\\n          if(l==2||l==3){\\n              count+=1;\\n              l=0;\\n          }else if(l==4||l==5){\\n              count+=2;\\n              l=0;\\n          }else{\\n              count=count+(l/3);\\n              l=l%3;\\n          }\\n            }\\n            if(l!=0){\\n                count+=1;\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2999738,
                "title": "short-code-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing Hashmap\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        int count = 0; HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int x : tasks)\\n            map.put(x,map.getOrDefault(x,0)+1);\\n        for(int x : map.keySet())\\n            if(map.get(x)==1)return -1;\\n            else{\\n                count+=map.get(x)/3;\\n                if(map.get(x)%3!=0)count++;\\n            }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        int count = 0; HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int x : tasks)\\n            map.put(x,map.getOrDefault(x,0)+1);\\n        for(int x : map.keySet())\\n            if(map.get(x)==1)return -1;\\n            else{\\n                count+=map.get(x)/3;\\n                if(map.get(x)%3!=0)count++;\\n            }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999360,
                "title": "using-simple-math-and-frequency-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to find the minimun number of rounds in which we can complete each task of same difficulty in either *2 tasks per round or 3 tasks per round*\\nnow any number N greater than 1 can be written in the form:\\n<c>    N = 2 * x + 3 * y; </c>\\nformally, any number *greater than 1* can be written as a sum of multiples of 2 and 3.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo the only time we will not be able to do a task in 2 or 3 rounds is then there is only 1 task of that difficulty.\\nSo, we create a frequency map of the various difficulties of the task and check if any of them occurs only once, if there is a task we return -1.\\nOtherwise, since we have to find the minimun number of rounds, we will try and do it same difficulty tasks in sets of 3 and then 2.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int n = tasks.size();\\n        map<int, int> mpp;\\n        \\n        for(int i = 0; i < n; i++) {\\n            mpp[tasks[i]]++;\\n        }\\n\\n        int numberOfRounds = 0;\\n\\n        for(auto it = mpp.begin(); it != mpp.end(); it++) {\\n            if(it -> second == 1) {\\n                return -1;\\n            }  // frequency of a task is 1, return -1.\\n\\n            int freq = it -> second;\\n\\n            if(freq % 3 == 2) {\\n                numberOfRounds += freq / 3 + 1;\\n            }   // we can do max freq/3 number of rounds of 3 and then we have to make 1 set of 2.\\n            else if(freq % 3 == 1) {\\n                numberOfRounds += (freq - 4) / 3 + 2;\\n            }   // we will make 2 sets of 2 and then remaining of them will be in sets of 3\\n            else {\\n                numberOfRounds += freq / 3;\\n            }   // min number of rounds = val / 3\\n        }\\n        return numberOfRounds;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int n = tasks.size();\\n        map<int, int> mpp;\\n        \\n        for(int i = 0; i < n; i++) {\\n            mpp[tasks[i]]++;\\n        }\\n\\n        int numberOfRounds = 0;\\n\\n        for(auto it = mpp.begin(); it != mpp.end(); it++) {\\n            if(it -> second == 1) {\\n                return -1;\\n            }  // frequency of a task is 1, return -1.\\n\\n            int freq = it -> second;\\n\\n            if(freq % 3 == 2) {\\n                numberOfRounds += freq / 3 + 1;\\n            }   // we can do max freq/3 number of rounds of 3 and then we have to make 1 set of 2.\\n            else if(freq % 3 == 1) {\\n                numberOfRounds += (freq - 4) / 3 + 2;\\n            }   // we will make 2 sets of 2 and then remaining of them will be in sets of 3\\n            else {\\n                numberOfRounds += freq / 3;\\n            }   // min number of rounds = val / 3\\n        }\\n        return numberOfRounds;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999296,
                "title": "using-ceil-function",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        sort(tasks.begin(),tasks.end());\\n        map<int,int>m;\\n        for(int i = 0 ; i < tasks.size() ; i++){\\n            m[tasks[i]]++;\\n        }\\n        int count=0;\\n        for(auto i:m){\\n            if(i.second<2) return -1;\\n            else{\\n                float gg=i.second;\\n                gg = ceil(gg/3);\\n                \\n                count+=gg;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        sort(tasks.begin(),tasks.end());\\n        map<int,int>m;\\n        for(int i = 0 ; i < tasks.size() ; i++){\\n            m[tasks[i]]++;\\n        }\\n        int count=0;\\n        for(auto i:m){\\n            if(i.second<2) return -1;\\n            else{\\n                float gg=i.second;\\n                gg = ceil(gg/3);\\n                \\n                count+=gg;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999188,
                "title": "simple-and-easy-to-understand-code-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n \\n\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<tasks.size();i++){\\n            m[tasks[i]]++;\\n        }\\n        int sum =0;\\n        for(auto it : m){\\n            if(it.second == 1){\\n                return -1;\\n            }\\n            else if(it.second % 3 == 0){\\n                sum += (it.second/3);\\n            }\\n            else{\\n                sum += ( (it.second/3) + 1 );\\n            }\\n\\n        }\\n        return sum;\\n\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n// class Solution {\\n// public:\\n\\n//     int count(int n){\\n//         int times =0;\\n//         while( (n!=4) || (n!=1) || (n!=0) ){\\n//             n -= 3;\\n//             times++;\\n            \\n//         }\\n//         while((n%2 ==0 ) && n>0){\\n//             n=n-2;\\n//             times++;\\n//         }\\n//         if(n==1){\\n//             return -1;\\n//         }\\n//         else{\\n//             return times;\\n//         }\\n//     }\\n\\n//     int minimumRounds(vector<int>& tasks) {\\n//         map<int,int>m;\\n//         for(int i=0;i<tasks.size();i++){\\n//             m[tasks[i]]++;\\n//         }\\n//         int sum =0;\\n//         for(auto it : m){\\n//             int ans = count(it.second);\\n//             if(ans ==-1) return -1;\\n//             else{\\n//                 sum = sum + ans;\\n//             }\\n\\n//         }\\n//         return sum;\\n\\n//     }\\n// };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n \\n\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<tasks.size();i++){\\n            m[tasks[i]]++;\\n        }\\n        int sum =0;\\n        for(auto it : m){\\n            if(it.second == 1){\\n                return -1;\\n            }\\n            else if(it.second % 3 == 0){\\n                sum += (it.second/3);\\n            }\\n            else{\\n                sum += ( (it.second/3) + 1 );\\n            }\\n\\n        }\\n        return sum;\\n\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n// class Solution {\\n// public:\\n\\n//     int count(int n){\\n//         int times =0;\\n//         while( (n!=4) || (n!=1) || (n!=0) ){\\n//             n -= 3;\\n//             times++;\\n            \\n//         }\\n//         while((n%2 ==0 ) && n>0){\\n//             n=n-2;\\n//             times++;\\n//         }\\n//         if(n==1){\\n//             return -1;\\n//         }\\n//         else{\\n//             return times;\\n//         }\\n//     }\\n\\n//     int minimumRounds(vector<int>& tasks) {\\n//         map<int,int>m;\\n//         for(int i=0;i<tasks.size();i++){\\n//             m[tasks[i]]++;\\n//         }\\n//         int sum =0;\\n//         for(auto it : m){\\n//             int ans = count(it.second);\\n//             if(ans ==-1) return -1;\\n//             else{\\n//                 sum = sum + ans;\\n//             }\\n\\n//         }\\n//         return sum;\\n\\n//     }\\n// };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999082,
                "title": "easy-understanding-c-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    int minimumRounds(vector<int>& v) {\\n        ll n = v.size();\\n        map<ll,ll> m;\\n        for(ll i=0;i<n;i++){\\n            m[v[i]]++;\\n        }\\n        ll flag = 0,count = 0;\\n        for(auto i:m){\\n            if(i.second < 2){\\n               return -1;\\n            }else{\\n                while(i.second>1){\\n                    if(i.second%3==0){\\n                        i.second -= 3;\\n                        count++;\\n                    }else if(i.second%2==0){\\n                        i.second -= 2;\\n                        count++;\\n                    }else {i.second-=3;count++;}\\n                }\\n            }\\n        }\\n        return\\xA0count;\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    int minimumRounds(vector<int>& v) {\\n        ll n = v.size();\\n        map<ll,ll> m;\\n        for(ll i=0;i<n;i++){\\n            m[v[i]]++;\\n        }\\n        ll flag = 0,count = 0;\\n        for(auto i:m){\\n            if(i.second < 2){\\n               return -1;\\n            }else{\\n                while(i.second>1){\\n                    if(i.second%3==0){\\n                        i.second -= 3;\\n                        count++;\\n                    }else if(i.second%2==0){\\n                        i.second -= 2;\\n                        count++;\\n                    }else {i.second-=3;count++;}\\n                }\\n            }\\n        }\\n        return\\xA0count;\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998958,
                "title": "go-simple-solution",
                "content": "# Code\\n```\\nfunc minimumRounds(tasks []int) int {\\n\\tans := 0\\n\\tmp := map[int]int{}\\n\\tfor _, v := range tasks {mp[v]++}\\n\\tfor _, v := range mp {\\n\\t\\tif v == 1 {return -1}\\n\\t\\tans += int(math.Ceil(float64(v)/3.0))\\n\\t}\\n\\treturn ans\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimumRounds(tasks []int) int {\\n\\tans := 0\\n\\tmp := map[int]int{}\\n\\tfor _, v := range tasks {mp[v]++}\\n\\tfor _, v := range mp {\\n\\t\\tif v == 1 {return -1}\\n\\t\\tans += int(math.Ceil(float64(v)/3.0))\\n\\t}\\n\\treturn ans\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2998604,
                "title": "javascript-dp-o-n",
                "content": "```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    \\n    const mem = [];\\n    \\n    const get = (n) => {\\n        if(mem[n] != undefined) return mem[n];\\n        if(n < 0) return Infinity;\\n        if(n === 0) return 0;\\n        \\n        const ans = 1 + Math.min(get(n - 2), get(n - 3));\\n        \\n        mem[n] = ans;\\n        return ans;\\n    }\\n    \\n    let ans = 0;\\n    \\n    const map = new Map();\\n    for(const t of tasks) {\\n        map.set(t, (map.get(t) ||\\xA00) + 1);\\n    }\\n    \\n    for(const n of map.values()) {\\n        const val = get(n);\\n        if(val === Infinity) return -1;\\n        ans += val;\\n    }\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    \\n    const mem = [];\\n    \\n    const get = (n) => {\\n        if(mem[n] != undefined) return mem[n];\\n        if(n < 0) return Infinity;\\n        if(n === 0) return 0;\\n        \\n        const ans = 1 + Math.min(get(n - 2), get(n - 3));\\n        \\n        mem[n] = ans;\\n        return ans;\\n    }\\n    \\n    let ans = 0;\\n    \\n    const map = new Map();\\n    for(const t of tasks) {\\n        map.set(t, (map.get(t) ||\\xA00) + 1);\\n    }\\n    \\n    for(const n of map.values()) {\\n        const val = get(n);\\n        if(val === Infinity) return -1;\\n        ans += val;\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2998462,
                "title": "easy-approach-c-map",
                "content": "# Intuition\\n\\n\\n# Approach\\n-Store in map\\n\\n-Simply compare if it is divisble by 3 or not(in three way)\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& num) {\\n        map<int, int> mp;\\n        int cnt=0;\\n        for(int i=0; i<num.size(); i++)\\n            mp[num[i]]++; \\n        for (auto i : mp)\\n        {\\n             // CASE 1// \\n            if(i.second==1) return -1;\\n            // CASE 2// \\n            else if((i.second)%3==0)\\n                 cnt += i.second/3;\\n            // CASE 3 //\\n            else if((i.second)%3==1)\\n            {\\n                cnt += (i.second-4)/3;\\n                cnt += 2;\\n            }\\n            // CASE 4//\\n            else if((i.second)%3==2)\\n            {\\n                cnt += (i.second-2)/3;\\n                cnt++;\\n            }\\n        }      \\n    return cnt;\\n }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& num) {\\n        map<int, int> mp;\\n        int cnt=0;\\n        for(int i=0; i<num.size(); i++)\\n            mp[num[i]]++; \\n        for (auto i : mp)\\n        {\\n             // CASE 1// \\n            if(i.second==1) return -1;\\n            // CASE 2// \\n            else if((i.second)%3==0)\\n                 cnt += i.second/3;\\n            // CASE 3 //\\n            else if((i.second)%3==1)\\n            {\\n                cnt += (i.second-4)/3;\\n                cnt += 2;\\n            }\\n            // CASE 4//\\n            else if((i.second)%3==2)\\n            {\\n                cnt += (i.second-2)/3;\\n                cnt++;\\n            }\\n        }      \\n    return cnt;\\n }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998451,
                "title": "java-c-100-solution-with-two-approachs-minimum-rounds-to-complete-all-tasks",
                "content": "- # Hashing Approach \\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer> hash = new HashMap<>();\\n        int ans = 0;\\n\\n        for(int x:tasks)\\n            hash.put(x,hash.getOrDefault(x,0)+1);\\n        \\n        for (Map.Entry<Integer, Integer> me : hash.entrySet()) {\\n            int x = me.getValue();\\n            if(x==1)\\n                return -1;\\n            if (x % 3 == 0) \\n                ans += x / 3;\\n            else if (x % 3 == 2) \\n                ans += (x - 2) / 3 + 1;\\n            else\\n                ans += (x - 4) / 3 + 2;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> hash;\\n        int ans = 0;\\n\\n        for(auto x:tasks)\\n            hash[x]++;\\n        \\n        for (auto asd : hash) {\\n            int x = asd.second;\\n            if(x==1)\\n                return -1;\\n            if (x % 3 == 0) \\n                ans += x / 3;\\n            else if (x % 3 == 2) \\n                ans += (x - 2) / 3 + 1;\\n            else\\n                ans += (x - 4) / 3 + 2;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n- # Sorting Approach \\n# Complexity\\n- Time complexity: $$O(nlog(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Java Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Arrays.sort(tasks);\\n        int res = 0;\\n        for (int i = 0; i < tasks.length;) {\\n            int j = i + 1;\\n            while (j < tasks.length && tasks[j] == tasks[i])\\n                j++;\\n            if (j == i + 1)\\n                return -1;\\n            res += compute(j - i);\\n            i = j;\\n        }\\n        return res; \\n    }\\n\\n    private int compute(int i) {\\n        if (i % 3 == 0)\\n            return i / 3;\\n        if (i % 3 == 2)\\n            return (i - 2) / 3 + 1;\\n        return (i - 4) / 3 + 2;\\n    }\\n}\\n```\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int compute(int i) {\\n        if (i % 3 == 0)\\n            return i / 3;\\n        if (i % 3 == 2)\\n            return (i - 2) / 3 + 1;\\n        return (i - 4) / 3 + 2;\\n    }\\n    int minimumRounds(vector<int>& tasks) {\\n        sort(tasks.begin(),tasks.end());\\n        int ans = 0;\\n        for (int i = 0; i < tasks.size();) {\\n            int j = i + 1;\\n            while (j < tasks.size() && tasks[j] == tasks[i])\\n                j++;\\n            if (j == i + 1) \\n                return -1;\\n            ans += compute(j - i);\\n            i = j;\\n        }\\n        return ans; \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer> hash = new HashMap<>();\\n        int ans = 0;\\n\\n        for(int x:tasks)\\n            hash.put(x,hash.getOrDefault(x,0)+1);\\n        \\n        for (Map.Entry<Integer, Integer> me : hash.entrySet()) {\\n            int x = me.getValue();\\n            if(x==1)\\n                return -1;\\n            if (x % 3 == 0) \\n                ans += x / 3;\\n            else if (x % 3 == 2) \\n                ans += (x - 2) / 3 + 1;\\n            else\\n                ans += (x - 4) / 3 + 2;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> hash;\\n        int ans = 0;\\n\\n        for(auto x:tasks)\\n            hash[x]++;\\n        \\n        for (auto asd : hash) {\\n            int x = asd.second;\\n            if(x==1)\\n                return -1;\\n            if (x % 3 == 0) \\n                ans += x / 3;\\n            else if (x % 3 == 2) \\n                ans += (x - 2) / 3 + 1;\\n            else\\n                ans += (x - 4) / 3 + 2;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Arrays.sort(tasks);\\n        int res = 0;\\n        for (int i = 0; i < tasks.length;) {\\n            int j = i + 1;\\n            while (j < tasks.length && tasks[j] == tasks[i])\\n                j++;\\n            if (j == i + 1)\\n                return -1;\\n            res += compute(j - i);\\n            i = j;\\n        }\\n        return res; \\n    }\\n\\n    private int compute(int i) {\\n        if (i % 3 == 0)\\n            return i / 3;\\n        if (i % 3 == 2)\\n            return (i - 2) / 3 + 1;\\n        return (i - 4) / 3 + 2;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int compute(int i) {\\n        if (i % 3 == 0)\\n            return i / 3;\\n        if (i % 3 == 2)\\n            return (i - 2) / 3 + 1;\\n        return (i - 4) / 3 + 2;\\n    }\\n    int minimumRounds(vector<int>& tasks) {\\n        sort(tasks.begin(),tasks.end());\\n        int ans = 0;\\n        for (int i = 0; i < tasks.size();) {\\n            int j = i + 1;\\n            while (j < tasks.size() && tasks[j] == tasks[i])\\n                j++;\\n            if (j == i + 1) \\n                return -1;\\n            ans += compute(j - i);\\n            i = j;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998041,
                "title": "clean-go-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nfunc minimumRounds(tasks []int) int {\\n    frequency := make(map[int]int)\\n    rounds := 0\\n\\n    for _, difficulty := range tasks {\\n        frequency[difficulty]++\\n    }\\n\\n    for _, count := range frequency {\\n        if count < 2 {\\n            return -1\\n        }\\n\\n        rounds += count / 3\\n\\n        if count % 3 > 0 {\\n            rounds++\\n        }\\n    }\\n\\n    return rounds\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimumRounds(tasks []int) int {\\n    frequency := make(map[int]int)\\n    rounds := 0\\n\\n    for _, difficulty := range tasks {\\n        frequency[difficulty]++\\n    }\\n\\n    for _, count := range frequency {\\n        if count < 2 {\\n            return -1\\n        }\\n\\n        rounds += count / 3\\n\\n        if count % 3 > 0 {\\n            rounds++\\n        }\\n    }\\n\\n    return rounds\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2997980,
                "title": "c-easy-to-understand-easy-to-code-array-map",
                "content": "# Please upvote if you like this solution.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)  --> For map operation.\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nint minimumRounds(vector<int> &tasks)\\n{\\n    unordered_map<int, int> mp;\\n\\n    for (int i = 0; i < tasks.size(); i++)\\n    {\\n        mp[tasks[i]]++;\\n    }\\n\\n    int count = 0;\\n\\n    for (auto element : mp)\\n    {\\n        if (element.second < 2)\\n        {\\n            return -1;\\n        }\\n\\n        else if (element.second % 3 == 0)\\n        {\\n            count += (element.second / 3);\\n        }\\n\\n        else\\n        {\\n            count += (element.second) / 3 + 1;\\n        }\\n    }\\n    return count;\\n}\\n```\\n![tp.png](https://assets.leetcode.com/users/images/cc759ec9-9dad-4dfd-8518-8a03f8a3054b_1672837424.4885995.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Ordered Map",
                    "Suffix Array"
                ],
                "code": "```\\nint minimumRounds(vector<int> &tasks)\\n{\\n    unordered_map<int, int> mp;\\n\\n    for (int i = 0; i < tasks.size(); i++)\\n    {\\n        mp[tasks[i]]++;\\n    }\\n\\n    int count = 0;\\n\\n    for (auto element : mp)\\n    {\\n        if (element.second < 2)\\n        {\\n            return -1;\\n        }\\n\\n        else if (element.second % 3 == 0)\\n        {\\n            count += (element.second / 3);\\n        }\\n\\n        else\\n        {\\n            count += (element.second) / 3 + 1;\\n        }\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2997940,
                "title": "java-simple-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        int count=0;\\n        Map<Integer,Integer> maplist=new HashMap<Integer,Integer>();\\n        for(int a:tasks)  maplist.put(a,maplist.getOrDefault(a,0)+1);\\n        Set<Integer> setlist=maplist.keySet();\\n        for(int key:setlist){\\n            int number=maplist.get(key);\\n            int i=0;\\n            while(true){\\n                if((number-3*i)<0){\\n                    if(number%2==0){\\n                         count+=(number/2);\\n                    }else return -1;\\n                }\\n                int rem=(number-3*i)/3;\\n                int rem1=number-3*rem;\\n                if(rem1%2==0){\\n                   count+=rem;\\n                   count+=(rem1)/2;  \\n                   break;\\n                }\\n                i++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        int count=0;\\n        Map<Integer,Integer> maplist=new HashMap<Integer,Integer>();\\n        for(int a:tasks)  maplist.put(a,maplist.getOrDefault(a,0)+1);\\n        Set<Integer> setlist=maplist.keySet();\\n        for(int key:setlist){\\n            int number=maplist.get(key);\\n            int i=0;\\n            while(true){\\n                if((number-3*i)<0){\\n                    if(number%2==0){\\n                         count+=(number/2);\\n                    }else return -1;\\n                }\\n                int rem=(number-3*i)/3;\\n                int rem1=number-3*rem;\\n                if(rem1%2==0){\\n                   count+=rem;\\n                   count+=(rem1)/2;  \\n                   break;\\n                }\\n                i++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997735,
                "title": "easy-solution-java-beginner-friendly-best-method",
                "content": "# Intuition\\nIf we observe the inputs carefully we can count the no. of tasks of same difficulty level in a HashMap and then check for the rounds a particular difficulty level is going to take if it is possible otherwise return -1.\\n\\nNow to calculate the no. of rounds required to complete a particular difficulty level we can see that it is following the below pattern :\\n1 -> -1\\n2 -> 1\\n3 -> 1\\n4 -> 2\\n5 -> 2\\n6 -> 2\\n7 -> 3\\n8 -> 3\\n9 -> 3\\n10 -> 4\\n11 -> 4\\n12 -> 4\\n\\nSo we can easily see that the answer the changing periodically except the edge case 1 as we can complete the task i.e. need to return -1.\\n\\n# Approach\\n- Check for the edge cases\\n- Initialize a int variable \\'rounds\\' as 0 and a HashMap \\'counts\\' to count the occurences of same difficulty level.\\n- Iterate over the tasks and count the occurences.\\n- Now for each difficulty level check the count : \\n    1. When count is 1 return -1\\n    2. When count is multiple of 3 add (count / 3)\\n    3. Otherwise add (count / 3 + 1)\\n    \\n- Return the result \\n\\n\\n# Complexity\\n- Time complexity:O(N) where N is length of the tasks\\n\\n- Space complexity: O(N) where N is length of the tasks\\n\\n**Please Upvote If this solution helps you to learn something. Thanks in advance.**\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        // edge cases\\n        if(tasks == null || tasks.length == 0){\\n            return -1;\\n        }\\n\\n        // intitalization\\n        Map<Integer, Integer> counts = new HashMap<>();\\n        int rounds = 0;\\n\\n        // iterate over the tasks\\n        for(int diffLevel : tasks){\\n            counts.put(diffLevel, counts.getOrDefault(diffLevel, 0) + 1);\\n        }\\n\\n        // iterate over the counts of same difficulty level\\n        for(int diffLevel : counts.keySet()){\\n            int count = counts.get(diffLevel);\\n            // when current count is 1\\n            if(count == 1){\\n                return -1;\\n            }\\n            if(count % 3 == 0){\\n                rounds += count / 3;\\n            }else{\\n                rounds += count / 3 + 1;\\n            }\\n        }\\n\\n        return rounds;\\n    }\\n}\\n```\\n\\n**Please Upvote If this solution helps you to learn something. Thanks in advance.**",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Math",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        // edge cases\\n        if(tasks == null || tasks.length == 0){\\n            return -1;\\n        }\\n\\n        // intitalization\\n        Map<Integer, Integer> counts = new HashMap<>();\\n        int rounds = 0;\\n\\n        // iterate over the tasks\\n        for(int diffLevel : tasks){\\n            counts.put(diffLevel, counts.getOrDefault(diffLevel, 0) + 1);\\n        }\\n\\n        // iterate over the counts of same difficulty level\\n        for(int diffLevel : counts.keySet()){\\n            int count = counts.get(diffLevel);\\n            // when current count is 1\\n            if(count == 1){\\n                return -1;\\n            }\\n            if(count % 3 == 0){\\n                rounds += count / 3;\\n            }else{\\n                rounds += count / 3 + 1;\\n            }\\n        }\\n\\n        return rounds;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997469,
                "title": "c-hashmap-easy-84-time-72-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& v) {\\n      unordered_map<int, int> um;\\n      for(auto &i: v) um[i]++;\\n      int ans = 0;\\n      for(auto &[f, s]: um){\\n        if(s < 2) return -1;\\n        else if(s % 3 == 0) ans += s / 3;\\n        else ans += s / 3 + 1;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& v) {\\n      unordered_map<int, int> um;\\n      for(auto &i: v) um[i]++;\\n      int ans = 0;\\n      for(auto &[f, s]: um){\\n        if(s < 2) return -1;\\n        else if(s % 3 == 0) ans += s / 3;\\n        else ans += s / 3 + 1;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997075,
                "title": "easiest-explanation-with-examples-o-n-beginner-friendly-very-fast",
                "content": "# PreRequisite\\nReader should know map STL.\\n\\n# Approach\\nMAPPING VALUES AND THEIR OCCURENCE .FOR MINIMUM ROUNDS ,GROUP OF 3\\'S SHOULD BE MAXIMUM . \\nTHEREFORE ONLY THREE CASES ACCORDING TO OUR PROBLEM .\\n\\nCASE I :\\n# **IF (it.second%3==0)**\\nThen ans+=it.second/3;\\n\\nCASE II :\\n# IF (it.second%3==1)\\nThen ans+=2(2 group of 2\\'s)+ (it.second-4)/3(remaining group of 3\\'s);\\n\\nexample :\\ni. [69,69,69,69,69,69,69,69,69,69] \\nTotal number of 69 is 10 .\\nNow 10 can be divided into 2 group of 3\\'s{6 elements} and\\n2 group of 2\\'s{4 elements}.\\n\\nii.Let frequency be 40 then 40%3==1 .\\nTherefore ans+= 2(from 2\\'s) +36/3 (from 3\\'s)\\n\\nCASE III.\\n# IF (it.second%3==2)\\nThen ans+= 1(1 group of 2\\'s)+ (it.second-2)/3(remaining group of 3\\'s)\\n\\n\\n# Complexity\\n- Time complexity:\\n O(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int>mpp;\\n        for(auto it : tasks)mpp[it]++;\\n        int ans=0;\\n        for(auto it : mpp){\\n            if(it.second<2)return -1;\\n            else{\\n                if(it.second%3==0){\\n                    ans+=(it.second/3);\\n                }\\n                else if(it.second%3==1){\\n                    ans+=2;\\n                    ans+=(it.second-4)/3; // 40 - 40%3==1 .therefore ans=2(from 2\\'s) +36/3 (from 3\\'s) \\n                }\\n                else if(it.second%3==2){\\n                    ans+=1;           \\n                    ans+=(it.second-2)/3; //17%3==2. 17 - 3 3 3 3 3 2 \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// 4 -- 2 2 \\n// 7 -- 2 2 3 \\n// 10 - 2 2 3 3\\n\\n// 5 -- 3 2 \\n// 8 -- 3 3 2\\n\\n// 6 -- 3 3 \\n// 9 -- 3 3 3 \\n\\n\\n\\n\\n\\n\\n```\\n\\nTHANK YOU READERS.UPVOTE IF LIKED THE EXPALANATION \\uD83D\\uDE0A\\nAMAN MAURYA .\\n",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int>mpp;\\n        for(auto it : tasks)mpp[it]++;\\n        int ans=0;\\n        for(auto it : mpp){\\n            if(it.second<2)return -1;\\n            else{\\n                if(it.second%3==0){\\n                    ans+=(it.second/3);\\n                }\\n                else if(it.second%3==1){\\n                    ans+=2;\\n                    ans+=(it.second-4)/3; // 40 - 40%3==1 .therefore ans=2(from 2\\'s) +36/3 (from 3\\'s) \\n                }\\n                else if(it.second%3==2){\\n                    ans+=1;           \\n                    ans+=(it.second-2)/3; //17%3==2. 17 - 3 3 3 3 3 2 \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// 4 -- 2 2 \\n// 7 -- 2 2 3 \\n// 10 - 2 2 3 3\\n\\n// 5 -- 3 2 \\n// 8 -- 3 3 2\\n\\n// 6 -- 3 3 \\n// 9 -- 3 3 3 \\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996789,
                "title": "very-easy-approach-in-java-explained",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We will count the frequency of each task in the input array and stores it in a map. Then, it iterates over the values (frequencies) in the map and checks if any task has a frequency of `less than 2`. \\n- If it finds such a task, it `returns -1` as required. Otherwise, it calculates the minimum number of rounds needed to complete all tasks. \\n\\n1. If the frequency of a task is greater than or equal to 3, we can complete 3 tasks in each round, so we need `map_count / 3` rounds.\\n1. If the frequency of a task is 2, we need at least one round to complete all tasks so we increment the ans.\\n- Finally, it adds the number of rounds needed for each task to the ans.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> m = new HashMap<Integer, Integer>();\\n\\n        for(int i=0; i<tasks.length; i++){\\n            if(m.containsKey(tasks[i])){\\n                m.put(tasks[i], m.get(tasks[i])+1);\\n            }else{\\n                m.put(tasks[i], 1);\\n            }\\n        }\\n        int ans =0;\\n        for(int map_count : m.values()){\\n            if(map_count < 2){\\n                return -1;\\n            }\\n            ans = ans+(map_count/3);\\n            if(map_count % 3 != 0){\\n                ans++;\\n            }\\n         }\\n        return ans;\\n    }\\n}\\n```\\n# Please Upvote if it was helpful",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> m = new HashMap<Integer, Integer>();\\n\\n        for(int i=0; i<tasks.length; i++){\\n            if(m.containsKey(tasks[i])){\\n                m.put(tasks[i], m.get(tasks[i])+1);\\n            }else{\\n                m.put(tasks[i], 1);\\n            }\\n        }\\n        int ans =0;\\n        for(int map_count : m.values()){\\n            if(map_count < 2){\\n                return -1;\\n            }\\n            ans = ans+(map_count/3);\\n            if(map_count % 3 != 0){\\n                ans++;\\n            }\\n         }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996734,
                "title": "easy-and-very-short-solution",
                "content": "# Intuition\\nOnly one case the result will be -1. If frequency of any number is 1. If not then the answer is always \\n\\n ```\\n    int((frequency+2)/3)\\n```\\nFor example:\\n    if 2 then answer is (2+2)/3 => 1 same for others\\n-  3 (3+2)/3 => 1\\n-    4 (4+2)/3 => 2\\n-    5 (5+2)/3 => 3\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        countFreq = Counter(tasks)\\n        res = 0\\n        for element in countFreq:\\n            if countFreq[element] == 1:\\n                return -1\\n            res += int((countFreq[element]+2)/3)\\n        return res\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    int((frequency+2)/3)\\n```\n```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        countFreq = Counter(tasks)\\n        res = 0\\n        for element in countFreq:\\n            if countFreq[element] == 1:\\n                return -1\\n            res += int((countFreq[element]+2)/3)\\n        return res\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996542,
                "title": "minimum-rounds-to-complete-all-tasks-using-queue-and-hashtable",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks)\\n    {\\n        unordered_map<int,int>mp;\\n        for(auto x:tasks)\\n        {\\n            mp[x]++;\\n        }\\n        queue<int>q;\\n        for(auto x:mp){\\n            if(x.second==1)\\n                return -1;\\n            else\\n                q.push(x.second);\\n        }\\n        int ans=0;\\n        while(!q.empty())\\n        {\\n            int n= q.front();\\n            q.pop();\\n            if(n>=3)\\n            {\\n                n-=3;\\n                ans++;\\n                \\n            }\\n            else if(n==2)\\n            {\\n                n-=2;\\n                ans++;\\n            }\\n            if(n==1)\\n            {\\n                ans++;\\n                continue;\\n            }\\n            else if (n==0)\\n                continue;\\n            else\\n                q.push(n);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Hash Table",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks)\\n    {\\n        unordered_map<int,int>mp;\\n        for(auto x:tasks)\\n        {\\n            mp[x]++;\\n        }\\n        queue<int>q;\\n        for(auto x:mp){\\n            if(x.second==1)\\n                return -1;\\n            else\\n                q.push(x.second);\\n        }\\n        int ans=0;\\n        while(!q.empty())\\n        {\\n            int n= q.front();\\n            q.pop();\\n            if(n>=3)\\n            {\\n                n-=3;\\n                ans++;\\n                \\n            }\\n            else if(n==2)\\n            {\\n                n-=2;\\n                ans++;\\n            }\\n            if(n==1)\\n            {\\n                ans++;\\n                continue;\\n            }\\n            else if (n==0)\\n                continue;\\n            else\\n                q.push(n);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996182,
                "title": "swift-easy-solution-with-hashmap",
                "content": "HashMap - Counting solution\\n\\n```\\nclass Solution {\\n    func minimumRounds(_ tasks: [Int]) -> Int {\\n        var hm: [Int: Int] = [:]\\n        for i in tasks {\\n            hm[i, default: 0] += 1\\n        }\\n        var count = 0\\n        for i in hm {\\n            if i.value > 1 {\\n                count += Int(i.value / 3)\\n                count += i.value % 3 == 0 ? 0 : 1    \\n            } else {\\n                return -1\\n            }\\n        }\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\n    func minimumRounds(_ tasks: [Int]) -> Int {\\n        var hm: [Int: Int] = [:]\\n        for i in tasks {\\n            hm[i, default: 0] += 1\\n        }\\n        var count = 0\\n        for i in hm {\\n            if i.value > 1 {\\n                count += Int(i.value / 3)\\n                count += i.value % 3 == 0 ? 0 : 1    \\n            } else {\\n                return -1\\n            }\\n        }\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996150,
                "title": "c-using-hashmap-intuitive-approach",
                "content": "**Approach:**\\n*  Store frequencies of tasks in hashmap, and take frequencies of tasks one by one. \\n* We can either take 2 or 3 tasks at once but we have to minimize the rounds so first we will check if 3 can be taken else take 2 tasks.\\n* After taking all pair of 2 or 3 tasks check in case at the end 1 task is left so that can\\'t be taken so return -1;\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> mpp;\\n        for(auto &it: tasks)\\n            mpp[it]++;\\n        \\n        int cnt = 0;\\n        for(auto &it: mpp){\\n            while(it.second>=2){\\n                cnt++;\\n                //greedily substract\\n                if(it.second%3==0)\\n                    it.second -= 3;\\n                else\\n                    it.second -= 2;\\n            }\\n            \\n            if(it.second != 0) return -1;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> mpp;\\n        for(auto &it: tasks)\\n            mpp[it]++;\\n        \\n        int cnt = 0;\\n        for(auto &it: mpp){\\n            while(it.second>=2){\\n                cnt++;\\n                //greedily substract\\n                if(it.second%3==0)\\n                    it.second -= 3;\\n                else\\n                    it.second -= 2;\\n            }\\n            \\n            if(it.second != 0) return -1;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995933,
                "title": "javascript-solution-with-comments-map-o-n-tc-o-n-sc",
                "content": "# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) N for hashMap to store frequencies \\n    \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    <!-- map to store frequencies -->\\n    const hash = new Map();\\n    <!-- total count | answer  -->\\n    let count = 0;\\n\\n    for(let task of tasks){\\n        <!-- if that number already exit in table than update it\\'s value -->\\n        if(hash.has(task)){\\n            hash.set(task, hash.get(task) + 1)\\n        }else{\\n            <!-- if that number don\\'t exit add ti table -->\\n            hash.set(task, 1)\\n        }\\n    }\\n    <!-- iterate over Map -->\\n    for(let [key, value] of hash){\\n        <!-- \\n            if frequncy is 1 the its not possible to complete tasks\\n            so return -1 \\n        -->\\n        if(value <= 1) return -1\\n\\n        <!-- if completely divisible to 3 than add directly to count -->\\n        if(value % 3 === 0){\\n            count += value/3\\n        }else{\\n        <!-- if not divisible with 3 -->\\n            count += Math.floor(value / 3) + 1\\n        }\\n    }\\n\\n    return count;\\n};\\n\\n```\\n\\n**If you like this solution please upvote, Thanks**",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    <!-- map to store frequencies -->\\n    const hash = new Map();\\n    <!-- total count | answer  -->\\n    let count = 0;\\n\\n    for(let task of tasks){\\n        <!-- if that number already exit in table than update it\\'s value -->\\n        if(hash.has(task)){\\n            hash.set(task, hash.get(task) + 1)\\n        }else{\\n            <!-- if that number don\\'t exit add ti table -->\\n            hash.set(task, 1)\\n        }\\n    }\\n    <!-- iterate over Map -->\\n    for(let [key, value] of hash){\\n        <!-- \\n            if frequncy is 1 the its not possible to complete tasks\\n            so return -1 \\n        -->\\n        if(value <= 1) return -1\\n\\n        <!-- if completely divisible to 3 than add directly to count -->\\n        if(value % 3 === 0){\\n            count += value/3\\n        }else{\\n        <!-- if not divisible with 3 -->\\n            count += Math.floor(value / 3) + 1\\n        }\\n    }\\n\\n    return count;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2995894,
                "title": "java-soln-hashmap",
                "content": "```\\nclass Solution {\\n    // This function returns the minimum number of rounds needed to\\n    // process all tasks in the given array of tasks.\\n    public int minimumRounds(int[] tasks) {\\n\\n        // Create a HashMap to store the count of each task\\n        HashMap<Integer, Integer> getCount = new HashMap<>();\\n\\n        // Iterate through the tasks array and store the count of each task\\n        // in the HashMap\\n        for (int t : tasks) {\\n            getCount.put(t, getCount.getOrDefault(t, 0) + 1);\\n        }\\n\\n        // Initialize a result variable to 0\\n        int result = 0;\\n\\n        // Iterate through the values in the HashMap (which represent the counts of the tasks)\\n        for (int count : getCount.values()) {\\n            // If a task has a count of 1, it cannot be grouped with other tasks\\n            // and so we return -1\\n            if (count == 1) return -1;\\n\\n            // Add the number of rounds needed to process the tasks with count greater than or equal to 3\\n            result += count / 3;\\n\\n            // If there are any tasks left with count less than 3, we need an additional round\\n            // to process these tasks\\n            if(count % 3 != 0) result++;\\n        }\\n\\n        // Return the total number of rounds needed to process all tasks\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "class Solution {\\n    // This function returns the minimum number of rounds needed to\\n    // process all tasks in the given array of tasks.\\n    public int minimumRounds(int[] tasks) {\\n\\n        // Create a HashMap to store the count of each task\\n        HashMap<Integer, Integer> getCount = new HashMap<>();\\n\\n        // Iterate through the tasks array and store the count of each task\\n        // in the HashMap\\n        for (int t : tasks) {\\n            getCount.put(t, getCount.getOrDefault(t, 0) + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2995830,
                "title": "c-100-working-maps-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n    unordered_map<int, int> mp;\\n    int c=0;\\n    for(int i=0;i<tasks.size();i++) mp[tasks[i]]++;\\n    for(auto x:mp) {\\n      if(x.second == 1) return -1;\\n      else if(x.second%3==0) c+=x.second/3;\\n      else c+=x.second/3+1;\\n    }\\n    return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n    unordered_map<int, int> mp;\\n    int c=0;\\n    for(int i=0;i<tasks.size();i++) mp[tasks[i]]++;\\n    for(auto x:mp) {\\n      if(x.second == 1) return -1;\\n      else if(x.second%3==0) c+=x.second/3;\\n      else c+=x.second/3+1;\\n    }\\n    return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995666,
                "title": "python-solution-using-mapping-counter-function",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst count the frequency of tasks using the python\\'s inbuilt counter function.\\nTake count variable as 0 for counting number of rounds.\\nIterate over the frequency array and if frequency is smaller than 2 then we simply return -1 as the answer else we will add floor value of (freq[i]+2)/3 to the existing count variable and then simply return it. \\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        frequency = Counter(tasks).values()\\n        count = 0\\n        for f in frequency:\\n            if f < 2:\\n                return -1\\n            count += floor((f+2)/3)\\n        return count\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst count the frequency of tasks using the python\\'s inbuilt counter function.\\nTake count variable as 0 for counting number of rounds.\\nIterate over the frequency array and if frequency is smaller than 2 then we simply return -1 as the answer else we will add floor value of (freq[i]+2)/3 to the existing count variable and then simply return it. \\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        frequency = Counter(tasks).values()\\n        count = 0\\n        for f in frequency:\\n            if f < 2:\\n                return -1\\n            count += floor((f+2)/3)\\n        return count\\n",
                "codeTag": "Java"
            },
            {
                "id": 2995639,
                "title": "c-using-map-ceiling-function",
                "content": "# Intuition\\nAs it frequency based question, we have to use map for it.\\n\\n# Approach\\nIf frequency of any task is 1. then return -1 because we can not do that task as we have to do 2 or 3 tasks in one go.\\n\\nNow, all we have is the remainder if we devide particular frequency by 3.\\n\\nIf remainder is 1, eg. freq task == 4, then we have to do two round each of 2-2 tasks which is indeed ceil(freq task / 3).\\n\\nIf remainder is 2, eg. freq task == 5, then we have to do two round each of 2-3 tasks which is indeed ceil(freq task / 3).\\n\\nIf remainder is 0, eg. freq task == 6, then we have to do two round each of 3-3 tasks which is indeed ceil(freq task / 3).\\n\\nThis is it !!!\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int minimumRounds(vector<int> &tasks)\\n    {\\n        unordered_map<int, int> mp;\\n        for (auto i : tasks)\\n            mp[i]++;\\n        int ans = 0;\\n        for (auto i : mp)\\n            if (i.second == 1)\\n                return -1;\\n        for (auto i : mp)\\n            ans += ceil(i.second / 3.0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minimumRounds(vector<int> &tasks)\\n    {\\n        unordered_map<int, int> mp;\\n        for (auto i : tasks)\\n            mp[i]++;\\n        int ans = 0;\\n        for (auto i : mp)\\n            if (i.second == 1)\\n                return -1;\\n        for (auto i : mp)\\n            ans += ceil(i.second / 3.0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995571,
                "title": "simple-and-easy-to-understand-using-ceil-and-unordered-map-detailed-explaination",
                "content": "# Intuition\\nIf the count of element is 1 ans is -1.\\nIf the count of element is\\ncount : ans\\n2 ____: 1\\n3_____: 1\\n4_____: 2\\n5_____: 2\\n6_____: 2\\n7_____: 3\\n8_____: 3\\n9_____: 3\\n....\\n\\nBy obseving this,we can easily predict that if we divide the number by 3 and use the ceil value we get correct answer.\\n\\n\\n# Approach\\nStore the count of each element in map and iterate it to get the result. \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& arr) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<arr.size();i++){\\n            mp[arr[i]]++;\\n        }\\n        int ans=0;\\n        for(auto x:mp){\\n            if(x.second==1){\\n                return -1;\\n            }\\n            else{\\n                ans+=ceil(x.second/3.0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& arr) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<arr.size();i++){\\n            mp[arr[i]]++;\\n        }\\n        int ans=0;\\n        for(auto x:mp){\\n            if(x.second==1){\\n                return -1;\\n            }\\n            else{\\n                ans+=ceil(x.second/3.0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995512,
                "title": "c-solution-easy-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int> hm;\\n        for(int i=0;i<tasks.size();i++){\\n            hm[tasks[i]]++;\\n        }\\n        int num,freq,ans=0;\\n        for (auto i : hm){\\n            freq = i.second;\\n            if(freq==1)\\n                return -1;\\n            if(freq%3==0){\\n                ans += freq/3;\\n            }\\n            else{\\n                ans += freq/3 + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int> hm;\\n        for(int i=0;i<tasks.size();i++){\\n            hm[tasks[i]]++;\\n        }\\n        int num,freq,ans=0;\\n        for (auto i : hm){\\n            freq = i.second;\\n            if(freq==1)\\n                return -1;\\n            if(freq%3==0){\\n                ans += freq/3;\\n            }\\n            else{\\n                ans += freq/3 + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995422,
                "title": "c-hashing-easy-to-understand",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple Mathematics\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        unordered_map<int,int> mp;\\n        for(int ele:tasks){\\n            mp[ele]++;\\n        }\\n        for(auto item:mp){\\n            int item_freq=item.second;\\n            if(item_freq==1){ // if element frequency==1 \\n                return -1;\\n            }\\n        }\\n        int res=0;\\n        for(auto p:mp){\\n            int item=p.first;\\n            int item_freq=p.second;\\n            int round=item_freq/3; \\n                                  //  if freq=9 --> it will be 3,3,3\\n            if(item_freq%3!=0)     //  if freq=7 --> it will be 3,2,2 .i.e. at least 3 round\\n               round++;\\n            res+=round;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        unordered_map<int,int> mp;\\n        for(int ele:tasks){\\n            mp[ele]++;\\n        }\\n        for(auto item:mp){\\n            int item_freq=item.second;\\n            if(item_freq==1){ // if element frequency==1 \\n                return -1;\\n            }\\n        }\\n        int res=0;\\n        for(auto p:mp){\\n            int item=p.first;\\n            int item_freq=p.second;\\n            int round=item_freq/3; \\n                                  //  if freq=9 --> it will be 3,3,3\\n            if(item_freq%3!=0)     //  if freq=7 --> it will be 3,2,2 .i.e. at least 3 round\\n               round++;\\n            res+=round;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995358,
                "title": "easy-cp-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf the number of tasks with the same difficulty level exceeds one, there must be one valid result for those tasks.Otherwise, return -1.\\n\\nBy analysing the conditions, all tasks can be solved by taking three tasks at a time, and if the task is less than 3 (which means 2), it can also be done.\\nSo divide the number of tasks (same difference) by three, and add one if the remainder is 2 for all difficulty levels. Finally, return the answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int>mp;\\n        for(auto a:tasks){\\n            if(mp.find(a)!=mp.end()){\\n                  mp[a]++;  \\n            }\\n            else{\\n                mp.insert({a,1});\\n            }\\n        }\\n        int c=0;\\n        for(auto it:mp){\\n            int k=it.second;\\n            if(k<2)return -1;\\n            c+=(k+2)/3;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int>mp;\\n        for(auto a:tasks){\\n            if(mp.find(a)!=mp.end()){\\n                  mp[a]++;  \\n            }\\n            else{\\n                mp.insert({a,1});\\n            }\\n        }\\n        int c=0;\\n        for(auto it:mp){\\n            int k=it.second;\\n            if(k<2)return -1;\\n            c+=(k+2)/3;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995347,
                "title": "c-easy-understanding",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int>mp;int c=0;\\n        for(int p=0;p<tasks.size();p++) mp[tasks[p]]++;\\n        for(auto &p:mp){\\n            if(p.second==1) return -1;\\n            c+=(p.second+2)/3;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int>mp;int c=0;\\n        for(int p=0;p<tasks.size();p++) mp[tasks[p]]++;\\n        for(auto &p:mp){\\n            if(p.second==1) return -1;\\n            c+=(p.second+2)/3;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995306,
                "title": "simple-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        c=0\\n        d={}\\n        tasks.sort()\\n        for i in tasks:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        for i in d:\\n            while d[i]:\\n                if d[i]==1:\\n                    return -1\\n                if d[i]%3==0:\\n                    d[i]-=3\\n                else:\\n                    d[i]-=2\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        c=0\\n        d={}\\n        tasks.sort()\\n        for i in tasks:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        for i in d:\\n            while d[i]:\\n                if d[i]==1:\\n                    return -1\\n                if d[i]%3==0:\\n                    d[i]-=3\\n                else:\\n                    d[i]-=2\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995285,
                "title": "c-begineer-friendly-easy-understanding-greedy-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\nhttps://www.youtube.com/watch?v=IVISUum7jVA/\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int minimumRounds(vector<int>& tasks) {\\n        // store the frequency in map.\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<tasks.size();i++){\\n            mp[tasks[i]]++;\\n        }\\n\\n        // store the ans. for 3 cases..\\n        int ans =0;\\n\\n        for(auto x:mp){\\n            int frequency = x.second;\\n\\n            // if freq is 1 return -1, not possible.\\n            if(frequency == 1) return -1;\\n\\n            // if frequ is divided by 3 with rem == 0\\n            else if(frequency%3  == 0 ) ans+= frequency/3;\\n\\n            // if rem == 2 or rem == 1\\n            else if(frequency%3 == 1 || frequency%3 == 2){\\n                ans += frequency/3 + 1;\\n            }\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int minimumRounds(vector<int>& tasks) {\\n        // store the frequency in map.\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<tasks.size();i++){\\n            mp[tasks[i]]++;\\n        }\\n\\n        // store the ans. for 3 cases..\\n        int ans =0;\\n\\n        for(auto x:mp){\\n            int frequency = x.second;\\n\\n            // if freq is 1 return -1, not possible.\\n            if(frequency == 1) return -1;\\n\\n            // if frequ is divided by 3 with rem == 0\\n            else if(frequency%3  == 0 ) ans+= frequency/3;\\n\\n            // if rem == 2 or rem == 1\\n            else if(frequency%3 == 1 || frequency%3 == 2){\\n                ans += frequency/3 + 1;\\n            }\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995238,
                "title": "c-easiest-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) \\n    {\\n        unordered_map<int,int>mp;\\n\\t\\t\\n\\t\\t//counting occurance of all value \\n        for(auto i:tasks)\\n        {\\n            mp[i]++;\\n        }\\n        \\n        int count = 0;\\n        for(auto i:mp)\\n        {\\n\\t\\t\\t// if any value is having count = 1 then definetely solution is not exist\\n\\t\\t\\t// because in one operation either we can take 2 or 3 tasks of same difficulty\\n            if(i.second == 1)return -1;\\n\\t\\t\\t\\n\\t\\t\\t/*\\n\\t\\t\\t\\tif value 2 occurs 3 times -> count = 3/3 = 1 means in 1 round we can take all tasks\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif value 3 occurs 2 times -> count = 2/3 = 0\\n\\t\\t\\t\\tbut also we are cheking \\n\\t\\t\\t\\tif occurance%3 > 0 then we count++\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tlet\\'s understand better in this example\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif any value is having occurance 7\\n\\t\\t\\t\\tso we shoud take 3 2 2 tasks means total 3 round\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tcount = 7/3 = 2 \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif 7%3 >1 count++\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tso count = 3\\n\\t\\t\\t*/\\n            count+=i.second/3;\\n            if(i.second%3)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) \\n    {\\n        unordered_map<int,int>mp;\\n\\t\\t\\n\\t\\t//counting occurance of all value \\n        for(auto i:tasks)\\n        {\\n            mp[i]++;\\n        }\\n        \\n        int count = 0;\\n        for(auto i:mp)\\n        {\\n\\t\\t\\t// if any value is having count = 1 then definetely solution is not exist\\n\\t\\t\\t// because in one operation either we can take 2 or 3 tasks of same difficulty\\n            if(i.second == 1)return -1;\\n\\t\\t\\t\\n\\t\\t\\t/*\\n\\t\\t\\t\\tif value 2 occurs 3 times -> count = 3/3 = 1 means in 1 round we can take all tasks\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif value 3 occurs 2 times -> count = 2/3 = 0\\n\\t\\t\\t\\tbut also we are cheking \\n\\t\\t\\t\\tif occurance%3 > 0 then we count++\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tlet\\'s understand better in this example\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif any value is having occurance 7\\n\\t\\t\\t\\tso we shoud take 3 2 2 tasks means total 3 round\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tcount = 7/3 = 2 \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif 7%3 >1 count++\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tso count = 3\\n\\t\\t\\t*/\\n            count+=i.second/3;\\n            if(i.second%3)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995235,
                "title": "python-greedy-solution-dictionary",
                "content": "# Intuition\\nWhenever we encounter with frequency 1 then we can\\'t able finish our task any number of rounds. While in other cases we see that every three number there minimum is always comes same.\\nEx - for 2 with freq 4,5,6,  we always get minimum round is 2\\n     for 2 with freq 7,8,9,  we always get minimum round is 3\\n     for 2 with freq 10,11,12,  we always get minimum round is 4\\nHence, we conclude frequency of element greater than 1 will always required minimum round ceiling value of (freq(n) / 3). Where n represent the diffulty level. \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        hashTable = defaultdict(int)\\n        for task in tasks:\\n            hashTable[task] += 1\\n\\n        ans = 0\\n        for key in hashTable:\\n            if hashTable[key] == 1: return -1\\n            ans += ceil(hashTable[key]/3)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        hashTable = defaultdict(int)\\n        for task in tasks:\\n            hashTable[task] += 1\\n\\n        ans = 0\\n        for key in hashTable:\\n            if hashTable[key] == 1: return -1\\n            ans += ceil(hashTable[key]/3)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995228,
                "title": "easy-hash-map-approach-linear-time-complexity-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) || for ordered hash-map\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int>mp;\\n        for(int i=0;i<tasks.size();i++)\\n        {\\n            mp[tasks[i]]++;\\n        }\\n\\n        int ans=0;\\n        for(auto it:mp)\\n        {\\n            if(it.second == 1)\\n                return -1;      // tasks is impossible to complete\\n            \\n            int cnt=0;\\n\\n            while(it.second > 3)\\n            {\\n                it.second -= 3; cnt++;     // calculate the rounds it will take to complete tasks\\n            }\\n            if(it.second)   // if total tasks would be in odd no. then after subtracting from 3 we\\'ll \\n                cnt++;      // increment the count  ex: 7-3 -> 4-3 -> 1  completed in 3 rounds [2,2,3]\\n\\n            ans+= cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# **PLEASE UPVOTE IF YOU UNDESTOOD THE SOLUTION!!**\\n\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int>mp;\\n        for(int i=0;i<tasks.size();i++)\\n        {\\n            mp[tasks[i]]++;\\n        }\\n\\n        int ans=0;\\n        for(auto it:mp)\\n        {\\n            if(it.second == 1)\\n                return -1;      // tasks is impossible to complete\\n            \\n            int cnt=0;\\n\\n            while(it.second > 3)\\n            {\\n                it.second -= 3; cnt++;     // calculate the rounds it will take to complete tasks\\n            }\\n            if(it.second)   // if total tasks would be in odd no. then after subtracting from 3 we\\'ll \\n                cnt++;      // increment the count  ex: 7-3 -> 4-3 -> 1  completed in 3 rounds [2,2,3]\\n\\n            ans+= cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995190,
                "title": "c-faster-than-100-5-lines-only-beginner-friendly-clean-code",
                "content": "\\n\\n# Code\\n```\\n//PLEASE UPVOTE IN CASE YOU LIKED THE SOLUTION\\n\\nclass Solution {\\npublic:\\n\\n    int minimumRounds(vector<int>& tasks) {\\n\\n       unordered_map<int,int>mpp;\\n       int res = 0;\\n\\n       for(auto &it : tasks) mpp[it]++;\\n\\n       for(auto &it : mpp) \\n       {\\n           if(it.second < 2) return -1;\\n\\n           res+= (it.second / 3) + (it.second % 3 > 0);\\n       }\\n\\n       return res;       \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\n//PLEASE UPVOTE IN CASE YOU LIKED THE SOLUTION\\n\\nclass Solution {\\npublic:\\n\\n    int minimumRounds(vector<int>& tasks) {\\n\\n       unordered_map<int,int>mpp;\\n       int res = 0;\\n\\n       for(auto &it : tasks) mpp[it]++;\\n\\n       for(auto &it : mpp) \\n       {\\n           if(it.second < 2) return -1;\\n\\n           res+= (it.second / 3) + (it.second % 3 > 0);\\n       }\\n\\n       return res;       \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995099,
                "title": "easy-to-understand-count-math",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeKotlin/src/main/kotlin/leetcode/medium/array/MinRoundsCompleteTasks.kt",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2995046,
                "title": "daily-leetcode-solution-minimum-rounds-to-complete-all-tasks-easy-c-sol-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <iostream>\\n#include <bits/stdc++.h>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    int minimumRounds(vector<int> &tasks)\\n    {\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i < tasks.size(); i++)\\n        {\\n            mp[tasks[i]]++;\\n        }\\n        int rounds = 0;\\n        for (auto &val : mp)\\n        {\\n            if (val.second == 1)\\n            {\\n                return -1;\\n            }\\n            else if (val.second % 3 == 0)\\n            {\\n                rounds += (val.second / 3);\\n            }\\n            else\\n            {\\n                rounds += (val.second / 3) + 1;\\n            }\\n        }\\n        return rounds;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <iostream>\\n#include <bits/stdc++.h>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    int minimumRounds(vector<int> &tasks)\\n    {\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i < tasks.size(); i++)\\n        {\\n            mp[tasks[i]]++;\\n        }\\n        int rounds = 0;\\n        for (auto &val : mp)\\n        {\\n            if (val.second == 1)\\n            {\\n                return -1;\\n            }\\n            else if (val.second % 3 == 0)\\n            {\\n                rounds += (val.second / 3);\\n            }\\n            else\\n            {\\n                rounds += (val.second / 3) + 1;\\n            }\\n        }\\n        return rounds;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2995022,
                "title": "daily-leetcode-challenge-c-detailed-explaination-code-day-4",
                "content": "# Approach\\n**Keep in mind we need to Return the minimum rounds required to complete all the tasks**\\n1. First we create unordered_map to store tasks and number of times task repeated as key and value respectively.\\n2. now we will go through the number of tasks(i.e. val.second) having same difficulty level(i.e. val.first)\\n    1. if the number of tasks is equal to 1(i.e. val.second) then, you can never complete either 2 or 3 tasks having same difficulty level in each round. In this case you will return -1.\\n    2. if the number of tasks is equal to 2(i.e. val.second) then, you can complete 2 tasks having same difficulty level in each round at a time. In this case you will add count = count + 1.\\n    3. if the number of tasks is >= 3(i.e. val.second) then, you can complete either 2 or 3 tasks having same difficulty level in each round at a time. lets understand with examples\\n        1. suppose we have vector, tasks = [4, 4, 4], then output will be 1, bcz we will take 3 tasks having same difficulty level(i.e. 4) at a time.\\n        2. suppose we have vector, tasks = [4, 4, 4, 4], then output will be 2, bcz we will not pick [[4, 4, 4], [4]] instead of picking this we will pick [[4, 4], [4, 4]].\\n        3. suppose we have vector, tasks = [4, 4, 4, 4, 4], then output will be 2, bcz we will not pick [[4, 4], [4, 4], [4]], instead of picking this we will pick [[4, 4, 4], [4, 4]].\\n        4. same logic implemented in the coding part.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: **O(n)** // where  n is the size of vector\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)** // where n is the size of vector\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> ump;\\n        for(int task : tasks){\\n            ump[task]++;\\n        }\\n        int count = 0; // it counts minimum rounds required to complete all the tasks\\n        for(auto val : ump){\\n            if(val.second == 1){\\n                return -1;\\n            }\\n            else if(val.second == 2){\\n                count = count + 1;\\n            }\\n            else if(val.second >= 3){\\n                int x = val.second / 3;\\n                int y = val.second % 3;\\n                if(y == 1 || y == 2)\\n                    count = count + x + 1;\\n                else if(y == 0)\\n                    count = count + x;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> ump;\\n        for(int task : tasks){\\n            ump[task]++;\\n        }\\n        int count = 0; // it counts minimum rounds required to complete all the tasks\\n        for(auto val : ump){\\n            if(val.second == 1){\\n                return -1;\\n            }\\n            else if(val.second == 2){\\n                count = count + 1;\\n            }\\n            else if(val.second >= 3){\\n                int x = val.second / 3;\\n                int y = val.second % 3;\\n                if(y == 1 || y == 2)\\n                    count = count + x + 1;\\n                else if(y == 0)\\n                    count = count + x;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994970,
                "title": "c-unordered-maps-intuitive-solution-easy-understand",
                "content": "# ***please give an upvote if you like the solution***\\n\\n\\n **Complexity**\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n) --> n is size of tasks array\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n) --> for map\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> map;\\n        for(int task: tasks){\\n            map[task]++;\\n        }\\n        int rounds = 0;\\n        for(auto task: map){\\n            if(task.second == 1) return -1;\\n            else rounds += task.second % 3 == 0 ? (task.second / 3) : (task.second / 3) + 1;\\n        }\\n        return rounds;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> map;\\n        for(int task: tasks){\\n            map[task]++;\\n        }\\n        int rounds = 0;\\n        for(auto task: map){\\n            if(task.second == 1) return -1;\\n            else rounds += task.second % 3 == 0 ? (task.second / 3) : (task.second / 3) + 1;\\n        }\\n        return rounds;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994926,
                "title": "python-one-liner-just-for-the-fun-of-it-but-still-o-n-and-faster-than-90-sometimes",
                "content": "Python one-liner just for the fun of it, but still O(n) and faster than 90% (sometimes)\\n\\n    return max(-1,sum([(ct + 2) // 3 if ct > 1 else float(\\'-inf\\') for key,ct in Counter(tasks).items()]))\\n\\nThe general idea is the same as the algorithm in the official solution\\n\\n1. Count how often each element occurs\\n2. Rounds for each level equals the ceiling of the number of occurrences divided by 3 (which (ct + 2) //3 means) and add all together\\n3. If a difficulty only occurs once, the entire input is \"invalid\", we need to return -1. The \"float(\\'-inf\\') is just a small trick to \"save\" that we need to return -1 after the sum has been taken.",
                "solutionTags": [],
                "code": "Python one-liner just for the fun of it, but still O(n) and faster than 90% (sometimes)\\n\\n    return max(-1,sum([(ct + 2) // 3 if ct > 1 else float(\\'-inf\\') for key,ct in Counter(tasks).items()]))\\n\\nThe general idea is the same as the algorithm in the official solution\\n\\n1. Count how often each element occurs\\n2. Rounds for each level equals the ceiling of the number of occurrences divided by 3 (which (ct + 2) //3 means) and add all together\\n3. If a difficulty only occurs once, the entire input is \"invalid\", we need to return -1. The \"float(\\'-inf\\') is just a small trick to \"save\" that we need to return -1 after the sum has been taken.",
                "codeTag": "Unknown"
            },
            {
                "id": 2994904,
                "title": "dart-100",
                "content": "\\nIf you Learned something new please give it upvote;\\notherwise thank you for having a look \\uD83D\\uDE4F\\uD83C\\uDFFB\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int minimumRounds(List<int> tasks) {\\n      Map<int, int> freq = {} ;\\n        int cont=0 ;\\n        for(int t in tasks)freq[t]=(freq[t] ?? 0) + 1;\\n        for(int it in freq.values){\\n            if(it == 1)return -1;\\n            if(it%3 == 0)cont += it~/3;\\n            else cont += it~/3+1 ;\\n        }\\n        return cont ;\\n  }\\n}\\n```\\n\\n\\nPls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding :)",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int minimumRounds(List<int> tasks) {\\n      Map<int, int> freq = {} ;\\n        int cont=0 ;\\n        for(int t in tasks)freq[t]=(freq[t] ?? 0) + 1;\\n        for(int it in freq.values){\\n            if(it == 1)return -1;\\n            if(it%3 == 0)cont += it~/3;\\n            else cont += it~/3+1 ;\\n        }\\n        return cont ;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416918,
                "title": "c-easy-solution-using-map-o-n",
                "content": "class Solution {\\npublic:\\n    int minimumRounds(vector<int>& task) {\\n\\t\\n        map<int,int>mp;\\n\\t\\t\\n\\t\\t// First calculate frequency of each element.\\n\\t\\t\\n        for(int i=0;i<task.size();++i){\\n            mp[task[i]]++;\\n        }\\n\\t\\t// If any element frequency is 1 then return -1 otherwise calculate minimum rounds required to complete all    the tasks.\\n\\t\\t\\n        int ans=0;\\n        for(auto &x: mp){\\n            if(x.second==1){\\n                return -1;\\n                break;\\n            }\\n            else{\\n            \\n                int div=x.second/3;\\n                int mod=x.second%3;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// If number of frequency a number which divisible by 3 that means  minimum rounds required  is (number of frequency/3) \\n\\t\\t\\t\\t\\n                if(mod==0){\\n                    ans+=div;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// We know that number of frequency a number always is not divisible by 3. Always remainder is 2 or 1. If remainder is 2 that means we  can complete 2  tasks of the same difficulty level and minimum required round is (number of frequency/3) +1 . For example a number which frequency is 20 . where (20%3)=2  , to complete first 18 task required minimum round  is  (20/3)=6 and remainder 2 complete 1 round. so total round is = 6+1 =7\\n\\t\\t\\t\\t\\n                else if(mod==2){\\n                    ans+=(div+1);\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//if remainder is 1 then we can calculate minimum round this way . for example a number which frequency is 10 . where (10%3)=1 , it\\'s not accepted because either 2 or 3 task completed at a time same difficulty level. If we bring 3 task from the value of (number of frequency/3) now remainder is 1+3=4 which is divisible by 2.  so, minimum require round is = ((number of frequency/3)-1) + 2 .\\n\\t\\t\\t\\t\\n                else{\\n                    ans+=((div-1)+2);\\n                }\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n//Time complexity O(n). Thanks all.\\n// If you think it\\'s helpful for you then please upvote.",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumRounds(vector<int>& task) {\\n\\t\\n        map<int,int>mp;\\n\\t\\t\\n\\t\\t// First calculate frequency of each element.\\n\\t\\t\\n        for(int i=0;i<task.size();++i){\\n            mp[task[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2396456,
                "title": "easy-java-solution-with-sorting-greedy-98-26-faster-and-81-32-memory",
                "content": "I originally thought that I am taking a brute force approach by sorting and greedily checking for numbers, but seems like this was the most optimal approach. Sharing it since everyone else is sharing HashMap approach and it seems not necessary.\\n\\n```\\nclass Solution {\\n    \\n    // Runtime: 15 ms, faster than 98.26% of Java online submissions for Minimum Rounds to Complete All Tasks.\\n    // Memory Usage: 94.3 MB, less than 81.32% of Java online submissions for Minimum Rounds to Complete All Tasks.\\n    public int minimumRounds(int[] tasks) {\\n        // Sort them to make all the same numbers come next to each other\\n        Arrays.sort(tasks);\\n        \\n        int count = 0;\\n        \\n        int currCount = 1;\\n        for(int i = 1; i < tasks.length; i++) {\\n            if(tasks[i] == tasks[i-1]) {\\n                currCount++;\\n            } else if(currCount < 2) {\\n                return -1;\\n            } else {\\n                if(currCount % 3 == 0) {\\n                    count += currCount / 3;\\n                } else {\\n                    count += currCount / 3 + 1;\\n                }\\n                currCount = 1;\\n            }\\n        }\\n        \\n        // Following is required to handle the last remaining currCount.\\n        if(currCount < 2) {\\n            return -1;\\n        } else {\\n            if(currCount % 3 == 0) {\\n                count += currCount / 3;\\n            } else {\\n                count += currCount / 3 + 1;\\n            }\\n            currCount = 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // Runtime: 15 ms, faster than 98.26% of Java online submissions for Minimum Rounds to Complete All Tasks.\\n    // Memory Usage: 94.3 MB, less than 81.32% of Java online submissions for Minimum Rounds to Complete All Tasks.\\n    public int minimumRounds(int[] tasks) {\\n        // Sort them to make all the same numbers come next to each other\\n        Arrays.sort(tasks);\\n        \\n        int count = 0;\\n        \\n        int currCount = 1;\\n        for(int i = 1; i < tasks.length; i++) {\\n            if(tasks[i] == tasks[i-1]) {\\n                currCount++;\\n            } else if(currCount < 2) {\\n                return -1;\\n            } else {\\n                if(currCount % 3 == 0) {\\n                    count += currCount / 3;\\n                } else {\\n                    count += currCount / 3 + 1;\\n                }\\n                currCount = 1;\\n            }\\n        }\\n        \\n        // Following is required to handle the last remaining currCount.\\n        if(currCount < 2) {\\n            return -1;\\n        } else {\\n            if(currCount % 3 == 0) {\\n                count += currCount / 3;\\n            } else {\\n                count += currCount / 3 + 1;\\n            }\\n            currCount = 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2372941,
                "title": "java-easy-simple-clean-solution",
                "content": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        \\n        final Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int task: tasks) {\\n            map.compute(task, (k,v) -> v == null ? 1 : 1 + v);            \\n        }\\n        \\n        int groups = 0;\\n        \\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            final int task = entry.getKey();\\n            final int count = entry.getValue();\\n            \\n            if (count == 1) return -1;\\n            groups += (count / 3) + (count % 3 == 0 ? 0 : 1);\\n        }\\n        \\n        return groups;\\n    }\\n}\\n```\\n\\nOR to ignore reminder check we can always add 2 and do int division\\n\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        \\n        final Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int task: tasks) {\\n            map.compute(task, (k,v) -> v == null ? 1 : 1 + v);            \\n        }\\n        \\n        int groups = 0;\\n        \\n        for (int count : map.values()) {\\n            if (count == 1) return -1;\\n            groups += (count + 2) / 3;\\n        }\\n        \\n        return groups;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        \\n        final Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int task: tasks) {\\n            map.compute(task, (k,v) -> v == null ? 1 : 1 + v);            \\n        }\\n        \\n        int groups = 0;\\n        \\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            final int task = entry.getKey();\\n            final int count = entry.getValue();\\n            \\n            if (count == 1) return -1;\\n            groups += (count / 3) + (count % 3 == 0 ? 0 : 1);\\n        }\\n        \\n        return groups;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214803,
                "title": "c-logical-explanation",
                "content": "First of all think on the cases when it is impossible to do the tasks. For this we need to think about odd and even numbers separately.\\nFor even numbers, it is crystal clear that atleast one way is possible since we can divide it into two tasks each.\\nFor odd numbers, taking into consideration that odd-odd=even, i.e. if we take 3 tasks in one turn then the left tasks would be even which can also result to a certain output. But in this case the odd number needs to be more than 1.\\nThis implies there is no solution for task whose difficulty level is unique in the array given.\\nNow, for calculating the minimum count, we need to club more 3 tasks than 2. \\nWe know that any natural number can be represented in the form of 3n, 3n+1, 3n+2 where n is any natural number. Hence, we just need to take care of the case when the remainder is 1 on division by 3 since both other cases can be covered by taking 0 and 2 tasks in the next turn simultaneously. \\nNow for remainder 1, subtract 2 one time from its value. This is required since 3n+1 needs to be converted to either 3m or 3m+2, now 3n+1 becomes 3n+1-2=3n-1=3(n-1)+2=3m+2.\\nUpvote if it helps:)\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int> m;\\n        for(int i=0; i<tasks.size(); i++) m[tasks[i]]++;\\n        int count=0;\\n        for(auto it:m) {\\n            if(it.second==1) return -1;\\n            else {\\n                if(it.second%3==1) {\\n                    count++;\\n                    it.second-=2;\\n                }\\n                count+=((it.second%3)==2)?1:0;\\n                count+=it.second/3;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int> m;\\n        for(int i=0; i<tasks.size(); i++) m[tasks[i]]++;\\n        int count=0;\\n        for(auto it:m) {\\n            if(it.second==1) return -1;\\n            else {\\n                if(it.second%3==1) {\\n                    count++;\\n                    it.second-=2;\\n                }\\n                count+=((it.second%3)==2)?1:0;\\n                count+=it.second/3;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2101837,
                "title": "c-mathematical-solution-with-explanation-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    //INTUITION: We can greedily want to minimize the no. of rounds by taking max no. of 3 task groups possible.\\n    //Now whatever the number of tasks be, it can either be divisible by 3, or leave a remainder of 1 or 2 when divided by 3.\\n    \\n    //Say 8 tasks are there ########...we can group them like ###/###/##, so remainder of 2, and 2 tasks are grouped into an extra group\\n    //Say 7 tasks are there #######.. we can divide like ###/###/#, that would leave 1 task ungrouped, so we would group it like ###/##/##\\n    //So in both cases of remainder 1 or 2 when divided by 3, we need to create an extra group apart from the 3-task groups\\n    \\n    \\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int> mp;\\n        for(auto t:tasks) ++mp[t];\\n        int ans = 0;\\n        for(auto m:mp) {\\n            if(m.second==1) return -1;\\n            ans+=m.second/3 + (m.second%3!=0 ? 1 : 0); //adding 1 extra group only when dividing by 3 leaves a remainder(either 1 or 2)\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //INTUITION: We can greedily want to minimize the no. of rounds by taking max no. of 3 task groups possible.\\n    //Now whatever the number of tasks be, it can either be divisible by 3, or leave a remainder of 1 or 2 when divided by 3.\\n    \\n    //Say 8 tasks are there ########...we can group them like ###/###/##, so remainder of 2, and 2 tasks are grouped into an extra group\\n    //Say 7 tasks are there #######.. we can divide like ###/###/#, that would leave 1 task ungrouped, so we would group it like ###/##/##\\n    //So in both cases of remainder 1 or 2 when divided by 3, we need to create an extra group apart from the 3-task groups\\n    \\n    \\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int> mp;\\n        for(auto t:tasks) ++mp[t];\\n        int ans = 0;\\n        for(auto m:mp) {\\n            if(m.second==1) return -1;\\n            ans+=m.second/3 + (m.second%3!=0 ? 1 : 0); //adding 1 extra group only when dividing by 3 leaves a remainder(either 1 or 2)\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040286,
                "title": "c-space-o-n-time-o-n",
                "content": "As simple As possible\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int>mp;\\n        for(int x:tasks)mp[x]++;\\n        int ans=0;\\n        for(auto x:mp){\\n            if(x.second==1){\\n                return -1;\\n            }else{\\n                int a=x.second/3;\\n                int b=x.second%3;\\n                ans+=a;\\n                ans+=b==0?0:1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int>mp;\\n        for(int x:tasks)mp[x]++;\\n        int ans=0;\\n        for(auto x:mp){\\n            if(x.second==1){\\n                return -1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1981732,
                "title": "simple-c-solution-and-easy-to-understand",
                "content": "```\\n//In this solution, we are basically trying all possiblities like doing work with blocks of 2 then with blocks 3 and at last combination of both 2 and 3.\\nclass Solution {\\n    private:\\n    int find(int val,int count,int y,int div) //This fun works for finding days if we do it in combination of 2 and 3;\\n    {\\n           int mini = INT_MAX;\\n           while(val>=y)\\n           {\\n               val-=y;\\n               ++count;\\n               if(val%div==0)\\n               {\\n                   mini = min(mini,count+val/div);\\n               }\\n           }\\n        \\n        return mini;\\n            \\n    }\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        map<int,int> mpp;\\n        for(int x:tasks)\\n        {\\n            mpp[x]++; \\n        }\\n        int days=0;\\n        for(auto &x:mpp)\\n        {\\n           int mini = INT_MAX; \\n           if(x.second==1)return -1; \\n           if(x.second%3==0)mini = min(mini,x.second/3);//only if we use blocks of 3\\n           if(x.second%2==0)mini = min(mini,x.second/2);//only if we use blocks of 2\\n           mini = min(mini,find(x.second,0,3,2));\\n           mini = min(mini,find(x.second,0,2,3)); \\n            \\n          // cout<<mini<<endl; \\n           days+=mini; \\n        } \\n        \\n        return days;\\n        \\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//In this solution, we are basically trying all possiblities like doing work with blocks of 2 then with blocks 3 and at last combination of both 2 and 3.\\nclass Solution {\\n    private:\\n    int find(int val,int count,int y,int div) //This fun works for finding days if we do it in combination of 2 and 3;\\n    {\\n           int mini = INT_MAX;\\n           while(val>=y)\\n           {\\n               val-=y;\\n               ++count;\\n               if(val%div==0)\\n               {\\n                   mini = min(mini,count+val/div);\\n               }\\n           }\\n        \\n        return mini;\\n            \\n    }\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        map<int,int> mpp;\\n        for(int x:tasks)\\n        {\\n            mpp[x]++; \\n        }\\n        int days=0;\\n        for(auto &x:mpp)\\n        {\\n           int mini = INT_MAX; \\n           if(x.second==1)return -1; \\n           if(x.second%3==0)mini = min(mini,x.second/3);//only if we use blocks of 3\\n           if(x.second%2==0)mini = min(mini,x.second/2);//only if we use blocks of 2\\n           mini = min(mini,find(x.second,0,3,2));\\n           mini = min(mini,find(x.second,0,2,3)); \\n            \\n          // cout<<mini<<endl; \\n           days+=mini; \\n        } \\n        \\n        return days;\\n        \\n        }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1961911,
                "title": "c-easy-simple-code-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> mp;\\n        int res = 0;\\n        for (int x : tasks) {mp[x]++;}\\n        for (auto x : mp) {\\n            if (x.second == 1) {return -1;} \\n            else {res += x.second / 3 + (x.second % 3 != 0);}\\n        }\\n        return res;\\n    }\\n};\\n```\\nDo up vote if it helped :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> mp;\\n        int res = 0;\\n        for (int x : tasks) {mp[x]++;}\\n        for (auto x : mp) {\\n            if (x.second == 1) {return -1;} \\n            else {res += x.second / 3 + (x.second % 3 != 0);}\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961075,
                "title": "c-simple-greedy-solution-explained-using-comments-hashmap-solution",
                "content": "**Time Complexity: O(N) as we are using simple traversal\\nSpace Complexity: O(N) as we are storing each element in the hashmap**\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int ans = 0;\\n        unordered_map<int,int>mp;\\n        for(int x: tasks){\\n            mp[x]++;\\n        }\\n        \\n        for(auto x: mp){\\n            //if the occurence of any difficulty is only 1 then there is no chance that the task can be done so we will simply return -1\\n            if(x.second == 1){\\n                return -1;\\n            }\\n            \\n            else{\\n                //as we are moving greedily so we will try to minimize the rounds so firstly we will prefer to complete the tasks in the group of three\\n                int rem = x.second%3;\\n                int usedrounds = x.second/3;\\n                ans+=usedrounds;\\n                \\n                //when we divide a number by 3  then the possible remainders can be 0 1 or 2\\n                if(rem == 1){\\n                    //for removing the last entry of the 3 so that remainder will now be 1 + 3\\n                    ans-=1;\\n                    \\n                    //if now the remainder is 4 then we can do it in the group of 2 2 \\n                    ans+=2;\\n                }\\n                \\n                else if(rem == 2){\\n                    //if the remainder is 2 then that level can be completely in one round by doing 2 tasks\\n                    ans+=1;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int ans = 0;\\n        unordered_map<int,int>mp;\\n        for(int x: tasks){\\n            mp[x]++;\\n        }\\n        \\n        for(auto x: mp){\\n            //if the occurence of any difficulty is only 1 then there is no chance that the task can be done so we will simply return -1\\n            if(x.second == 1){\\n                return -1;\\n            }\\n            \\n            else{\\n                //as we are moving greedily so we will try to minimize the rounds so firstly we will prefer to complete the tasks in the group of three\\n                int rem = x.second%3;\\n                int usedrounds = x.second/3;\\n                ans+=usedrounds;\\n                \\n                //when we divide a number by 3  then the possible remainders can be 0 1 or 2\\n                if(rem == 1){\\n                    //for removing the last entry of the 3 so that remainder will now be 1 + 3\\n                    ans-=1;\\n                    \\n                    //if now the remainder is 4 then we can do it in the group of 2 2 \\n                    ans+=2;\\n                }\\n                \\n                else if(rem == 2){\\n                    //if the remainder is 2 then that level can be completely in one round by doing 2 tasks\\n                    ans+=1;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957459,
                "title": "simple-python-solution-with-explanation-dictionary-o-n-time-o-n-space",
                "content": "```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        tasks_dict = defaultdict(int)\\n        for i in range(len(tasks)):\\n            tasks_dict[tasks[i]] += 1\\n        \\n        min_tasks = 0\\n        for i in tasks_dict:\\n            if tasks_dict[i] <= 1:\\n                # if there is 0 or 1 tasks for a difficulty level, it is not possible to complete task\\n                return -1\\n            else:\\n                # anything above 2, it is possible to complete tasks\\n                # to keep rounds to a minimum, we will try to complete 3 tasks in a single round as much as possible\\n                # hence \\n                # 6 tasks - 2 rounds - [3,3]\\n                # 7 tasks - 3 rounds - [3,2,2]\\n                # 8 tasks - 3 rounds - [3,3,2]\\n                # 9 tasks - 3 rounds - [3,3,3]\\n                # 10 tasks - 4 rounds - [3,3,2,2]\\n                # we can generalise the formula as:\\n                min_tasks += int((tasks_dict[i] + 2)/3)\\n                \\n        return min_tasks\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        tasks_dict = defaultdict(int)\\n        for i in range(len(tasks)):\\n            tasks_dict[tasks[i]] += 1\\n        \\n        min_tasks = 0\\n        for i in tasks_dict:\\n            if tasks_dict[i] <= 1:\\n                # if there is 0 or 1 tasks for a difficulty level, it is not possible to complete task\\n                return -1\\n            else:\\n                # anything above 2, it is possible to complete tasks\\n                # to keep rounds to a minimum, we will try to complete 3 tasks in a single round as much as possible\\n                # hence \\n                # 6 tasks - 2 rounds - [3,3]\\n                # 7 tasks - 3 rounds - [3,2,2]\\n                # 8 tasks - 3 rounds - [3,3,2]\\n                # 9 tasks - 3 rounds - [3,3,3]\\n                # 10 tasks - 4 rounds - [3,3,2,2]\\n                # we can generalise the formula as:\\n                min_tasks += int((tasks_dict[i] + 2)/3)\\n                \\n        return min_tasks\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956480,
                "title": "detailed-math-explanation-python-o-n-hash-map-both-beats-100",
                "content": "First, we need to know the frequency of each number, so using hash map is a good choice, run time will be O(N). If we use .sort() then go through the list, the run time will increase to O(NlogN). After we knowing the frequency (let\\'s denote it as **n**) of each number, we can get the minimum round to complete the process by solving the following\\n\\n![image](https://assets.leetcode.com/users/images/9b031e81-883b-47fe-8b78-b18d87c05299_1650183614.7385616.png)\\n\\nWe can write a function **solve**.  Want to get the minimum of **x+y** under the contrains, we can see that there are some trivial cases.  They are the followings:\\n1. **n \\u2261 0 (mod 3)**, n is a multiple of 3, we can just return **n // 3** \\n2.  **n = 2**, return 1 immediately\\n3.  **n = 1**, there is no solution then return -1\\n\\nAfter the easy cases, we get into the harder and the last case, that is  **n > 1 *and* n is not multiple of 3**. \\nLet\\'s see a useful fact, **gcd(2,3) = 1** implies the diophantine equation **2x + 3y = n** for **n > 1** **always has non-negative solution**.\\nNow we can let the **result = n // 2 and y = n // 3** and do the iteration from **n // 3** to **0**, when gets **(n - 3y) \\u2261 0 (mod 2)** in the iteration process, we can stop then return **y + (n - 3y) // 2**. If there is no a such **y**, we can just return the **result**\\n\\n```\\ndef solve(n):\\n    if (n % 3 == 0):\\n        return n // 3\\n    if (n == 2):\\n        return 1\\n    if (n == 1):\\n        return -1\\n    three_count = n // 3 # y\\n    res = n // 2 # result\\n    while(n - 3*three_count < n):\\n        if ((n - 3*three_count) % 2 == 0):\\n            res = three_count + (n - 3*three_count) // 2\\n            break\\n        three_count -= 1\\n    return res\\n```\\n\\nBy adding the minimum rounds for each numbers, we can get the desired result\\n**The final code**\\n```\\nclass Solution(object):\\n    def minimumRounds(self, tasks):\\n        \"\"\"\\n        :type tasks: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dic = {}\\n        for num in tasks:\\n            if num in dic:\\n                dic[num] += 1\\n            else:\\n                dic[num] = 1\\n        \\n        res = 0\\n        for i in dic:\\n            if (solve(dic[i]) == -1):\\n                return -1\\n            else:\\n                res += solve(dic[i])\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef solve(n):\\n    if (n % 3 == 0):\\n        return n // 3\\n    if (n == 2):\\n        return 1\\n    if (n == 1):\\n        return -1\\n    three_count = n // 3 # y\\n    res = n // 2 # result\\n    while(n - 3*three_count < n):\\n        if ((n - 3*three_count) % 2 == 0):\\n            res = three_count + (n - 3*three_count) // 2\\n            break\\n        three_count -= 1\\n    return res\\n```\n```\\nclass Solution(object):\\n    def minimumRounds(self, tasks):\\n        \"\"\"\\n        :type tasks: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dic = {}\\n        for num in tasks:\\n            if num in dic:\\n                dic[num] += 1\\n            else:\\n                dic[num] = 1\\n        \\n        res = 0\\n        for i in dic:\\n            if (solve(dic[i]) == -1):\\n                return -1\\n            else:\\n                res += solve(dic[i])\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955669,
                "title": "c-concise-solution",
                "content": "The trick to this problem is realizing that the solution is to group all equal numbers, and for each group just divide by 3 and add that to the result. If you do it on paper you can see the pattern form.\\n```\\npublic int MinimumRounds(int[] tasks) {\\n\\tvar freq = tasks.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count());\\t// group\\n\\tif (freq.Any(x => x.Value < 2)) // Check if invalid\\n\\t\\treturn -1; \\n\\tint result = 0;\\n\\tforeach (var kvp in freq) \\n\\t\\tresult += (int)Math.Ceiling((decimal)kvp.Value / (decimal)3);\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int MinimumRounds(int[] tasks) {\\n\\tvar freq = tasks.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count());\\t// group\\n\\tif (freq.Any(x => x.Value < 2)) // Check if invalid\\n\\t\\treturn -1; \\n\\tint result = 0;\\n\\tforeach (var kvp in freq) \\n\\t\\tresult += (int)Math.Ceiling((decimal)kvp.Value / (decimal)3);\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955550,
                "title": "c-hashmap-dp-clean-code",
                "content": "```\\n int minimumRounds(vector<int>& tasks) {\\n        \\n        // We can do 2 task or 3 tasks \\n        int n=tasks.size();\\n        unordered_map<int , int> mp;\\n        int max_count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            mp[tasks[i]]++;\\n            max_count=max(max_count , mp[tasks[i]]);\\n        }\\n        \\n        vector<int> dp(100001);\\n        dp[0]=0;\\n        dp[1]=0;\\n        \\n        dp[2]=1;\\n        dp[3]=1;\\n        dp[4]=2;\\n        \\n        for(int i=5;i<=100000;i++)\\n        {\\n            dp[i]= 1 + min(dp[i-2] , dp[i-3]);\\n        }\\n        \\n        \\n        int ans=0;\\n        \\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if(it->second==1)\\n            {\\n                return -1;\\n            }\\n            else\\n            {\\n                ans = ans + (long long )(dp[it->second]);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n        \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n int minimumRounds(vector<int>& tasks) {\\n        \\n        // We can do 2 task or 3 tasks \\n        int n=tasks.size();\\n        unordered_map<int , int> mp;\\n        int max_count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            mp[tasks[i]]++;\\n            max_count=max(max_count , mp[tasks[i]]);\\n        }\\n        \\n        vector<int> dp(100001);\\n        dp[0]=0;\\n        dp[1]=0;\\n        \\n        dp[2]=1;\\n        dp[3]=1;\\n        dp[4]=2;\\n        \\n        for(int i=5;i<=100000;i++)\\n        {\\n            dp[i]= 1 + min(dp[i-2] , dp[i-3]);\\n        }\\n        \\n        \\n        int ans=0;\\n        \\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if(it->second==1)\\n            {\\n                return -1;\\n            }\\n            else\\n            {\\n                ans = ans + (long long )(dp[it->second]);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955503,
                "title": "go-golang-time-o-n-log-n-163-ms-100-space-o-n-10-mb-100",
                "content": "```\\nfunc minimumRounds(tasks []int) int {\\n    result, count := 0, make(map[int]int)\\n\\n    for _, t := range tasks {\\n        count[t]++\\n    }\\n    for _, v := range count {\\n        for v > 0 {\\n            switch {\\n            case v % 3 == 0:\\n                result, v = result + v / 3, 0\\n            case v > 4:\\n                result++\\n                v -= 3\\n            case v % 2 == 0:\\n                result, v = result + v / 2, 0\\n            case v == 1:\\n                return -1\\n            }\\n        }\\n    }\\n    \\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimumRounds(tasks []int) int {\\n    result, count := 0, make(map[int]int)\\n\\n    for _, t := range tasks {\\n        count[t]++\\n    }\\n    for _, v := range count {\\n        for v > 0 {\\n            switch {\\n            case v % 3 == 0:\\n                result, v = result + v / 3, 0\\n            case v > 4:\\n                result++\\n                v -= 3\\n            case v % 2 == 0:\\n                result, v = result + v / 2, 0\\n            case v == 1:\\n                return -1\\n            }\\n        }\\n    }\\n    \\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955484,
                "title": "easy-hashmap-o-n-explained-using-dry-run",
                "content": "If you like it, pls **Upvote** :)\\n\\n## Code:\\n\\tclass Solution {\\n\\t\\tpublic int minimumRounds(int[] tasks) {\\n\\t\\t    // Create & Update HashMap\\n\\t\\t\\tMap<Integer, Integer> map = new HashMap<>();\\n\\t\\t\\tfor(int task : tasks){\\n\\t\\t\\t\\tif(! map.containsKey(task)){ map.put(task, 1); }\\n\\t\\t\\t\\telse{ map.put(task, map.get(task)+1); }\\n\\t\\t\\t}\\t\\t\\t\\n\\t\\t\\tint rounds = 0;\\n\\t\\t\\tfor(Map.Entry entry : map.entrySet()){                      // traverse hashmap\\n\\t\\t\\t\\tint val = (int) entry.getValue();\\n\\t\\t\\t\\tif(val == 1){ return -1; }                              // if any val == 1, just return -1\\n\\t\\t\\t\\tif(val >= 3){                                           // first check, if val >= 3        \\n\\t\\t\\t\\t\\trounds += val / 3;\\n\\t\\t\\t\\t\\tif(val % 3 != 0){ rounds += 1; }                    // if val % 3 != 0.  e.g.  4, 5, 7, 8, 10, 11........so on\\n\\t\\t\\t\\t}else if(val == 2){ rounds += 1; }\\n\\t\\t\\t}\\n\\t\\t\\treturn rounds;\\n\\t\\t}\\n\\t}\\n\\n## Dry Run:\\n\\tInput = [2,2,3,3,2,4,4,4,4,4]\\n\\tSteps:\\n\\tmap: \\n\\t\\t2 : 3\\n\\t\\t3 : 2\\n\\t\\t4 : 5\\n\\t\\t\\n\\tNow,\\t\\n\\t2 : 3\\n\\t\\trounds: 1\\n\\t3 : 2\\n\\t\\trounds: 2\\n\\t4 : 5\\n\\t\\trounds: 4\\n\\nIf any questions/suggestions, comment down below.\\nIf you liked it, pls **Upvote** :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int minimumRounds(int[] tasks) {\\n\\t\\t    // Create & Update HashMap\\n\\t\\t\\tMap<Integer, Integer> map = new HashMap<>();\\n\\t\\t\\tfor(int task : tasks){\\n\\t\\t\\t\\tif(! map.containsKey(task)){ map.put(task, 1); }",
                "codeTag": "Java"
            },
            {
                "id": 1955434,
                "title": "python-counter-method",
                "content": "\\'\\'\\'\\nfrom collections import Counter\\n\\nclass Solution:\\n\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        task_ct = Counter(tasks)\\n\\n\\t\\t# Since has to be 2 or 3 at a time, any occurrence of 1 will return -1\\n        if 1 in task_ct.values():\\n            return(-1)\\n\\n        output = 0\\n\\n        for i in task_ct.values():\\n\\t\\t\\n\\t\\t\\t# 3 at a time is the quickest\\n            this_round = i//3\\n\\t\\t\\t\\n\\t\\t\\t# If there\\'s a leftover 2, it counts as well\\n\\t\\t\\t# If there\\'s a leftover 1, it won\\'t affect the situation\\n\\t\\t\\t#     we can just \"borrow\" 1 from any of the 3 so there are two 2s\\n            if i%3 != 0:\\n                this_round += 1\\n            output += this_round\\n\\n        return(output)\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\'\\'\\'\\nfrom collections import Counter\\n\\nclass Solution:\\n\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        task_ct = Counter(tasks)\\n\\n\\t\\t# Since has to be 2 or 3 at a time, any occurrence of 1 will return -1\\n        if 1 in task_ct.values():\\n            return(-1)\\n\\n        output = 0\\n\\n        for i in task_ct.values():\\n\\t\\t\\n\\t\\t\\t# 3 at a time is the quickest\\n            this_round = i//3\\n\\t\\t\\t\\n\\t\\t\\t# If there\\'s a leftover 2, it counts as well\\n\\t\\t\\t# If there\\'s a leftover 1, it won\\'t affect the situation\\n\\t\\t\\t#     we can just \"borrow\" 1 from any of the 3 so there are two 2s\\n            if i%3 != 0:\\n                this_round += 1\\n            output += this_round\\n\\n        return(output)\\n\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1955358,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int> m;\\n        set<int> s;\\n        int n=tasks.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            m[tasks[i]]++;\\n            s.insert(tasks[i]);\\n        }\\n        \\n        int ans=0;\\n        for(auto it=s.begin();it!=s.end();it++)\\n        {\\n            if(m[*it]==1) return -1;\\n            ans+=m[*it]/3;\\n            if(m[*it]%3) ans++;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int> m;\\n        set<int> s;\\n        int n=tasks.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            m[tasks[i]]++;\\n            s.insert(tasks[i]);\\n        }\\n        \\n        int ans=0;\\n        for(auto it=s.begin();it!=s.end();it++)\\n        {\\n            if(m[*it]==1) return -1;\\n            ans+=m[*it]/3;\\n            if(m[*it]%3) ans++;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958259,
                "title": "beats-100-o-n-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    func minimumRounds(_ tasks: [Int]) -> Int {\\n        var map = [Int: Int]()\\n        var count = 0\\n            \\n        for item in tasks {\\n            map[item, default: 0] += 1\\n        }\\n        for (_, value) in map {\\n            if value < 2 {\\n                return -1\\n            }\\n            if value%3 == 0 {\\n                count += value/3\\n            } else {\\n                count += value/3+1\\n            }\\n        }\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimumRounds(_ tasks: [Int]) -> Int {\\n        var map = [Int: Int]()\\n        var count = 0\\n            \\n        for item in tasks {\\n            map[item, default: 0] += 1\\n        }\\n        for (_, value) in map {\\n            if value < 2 {\\n                return -1\\n            }\\n            if value%3 == 0 {\\n                count += value/3\\n            } else {\\n                count += value/3+1\\n            }\\n        }\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808074,
                "title": "c-easy-to-understand-3x-2y-freq",
                "content": "```\\n\\n pair<int, int> check(int num)\\n    {\\n\\n        for (int i = num / 3 + 1; i >= 0; i--)\\n        {\\n            for (int j = num / 2 + 1; j >= 0; j--)\\n            {\\n\\n                if (3 * i + 2 * j == num)\\n                {\\n                    return {i, j};\\n                }\\n            }\\n        }\\n        return {-1, -1};\\n    }\\n    int minimumRounds(vector<int> &tasks)\\n    {\\n        int n = tasks.size();\\n        map<int, int> mp;\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[tasks[i]]++;\\n        }\\n        int ans = 0;\\n\\n        for (auto itr : mp)\\n        { \\n            pair<int, int> p = check(itr.second);\\n            if (p.first != -1 and p.second != -1)\\n            {\\n                ans += p.first + p.second;\\n            }\\n            else\\n            {\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n```",
                "solutionTags": [
                    "Math",
                    "Greedy"
                ],
                "code": "```\\n\\n pair<int, int> check(int num)\\n    {\\n\\n        for (int i = num / 3 + 1; i >= 0; i--)\\n        {\\n            for (int j = num / 2 + 1; j >= 0; j--)\\n            {\\n\\n                if (3 * i + 2 * j == num)\\n                {\\n                    return {i, j};\\n                }\\n            }\\n        }\\n        return {-1, -1};\\n    }\\n    int minimumRounds(vector<int> &tasks)\\n    {\\n        int n = tasks.size();\\n        map<int, int> mp;\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[tasks[i]]++;\\n        }\\n        int ans = 0;\\n\\n        for (auto itr : mp)\\n        { \\n            pair<int, int> p = check(itr.second);\\n            if (p.first != -1 and p.second != -1)\\n            {\\n                ans += p.first + p.second;\\n            }\\n            else\\n            {\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3498291,
                "title": "java-solution-time-o-n-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> freq = new HashMap<Integer, Integer>();\\n\\n       if (tasks.length <2 ) return -1;\\n\\n        for (int i=0; i < tasks.length; i++){\\n            int task = tasks[i];\\n            Integer count = freq.get(task);\\n            if (count == null){\\n                count = 0;\\n            }\\n            freq.put(task,count+1);\\n        }\\n        \\n        int numRounds = 0;\\n\\n        for (int key : freq.keySet()){\\n            int round = getRounds(freq.get(key));\\n            \\n            if (round == 0) return -1;\\n\\n            numRounds += round;\\n\\n        }\\n        return numRounds;\\n    }\\n\\n    private int getRounds(int frequency){\\n        if (frequency < 2) return 0;\\n        if (frequency%3 ==0){\\n            return frequency/3;\\n        } else if (frequency%3 == 1){\\n            return (frequency-1)/3 + 1;\\n        } else {\\n            return (frequency-2)/3 + 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> freq = new HashMap<Integer, Integer>();\\n\\n       if (tasks.length <2 ) return -1;\\n\\n        for (int i=0; i < tasks.length; i++){\\n            int task = tasks[i];\\n            Integer count = freq.get(task);\\n            if (count == null){\\n                count = 0;\\n            }\\n            freq.put(task,count+1);\\n        }\\n        \\n        int numRounds = 0;\\n\\n        for (int key : freq.keySet()){\\n            int round = getRounds(freq.get(key));\\n            \\n            if (round == 0) return -1;\\n\\n            numRounds += round;\\n\\n        }\\n        return numRounds;\\n    }\\n\\n    private int getRounds(int frequency){\\n        if (frequency < 2) return 0;\\n        if (frequency%3 ==0){\\n            return frequency/3;\\n        } else if (frequency%3 == 1){\\n            return (frequency-1)/3 + 1;\\n        } else {\\n            return (frequency-2)/3 + 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472861,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) \\n    {\\n        std::ios::sync_with_stdio(false);\\n        std::cin.tie(nullptr);\\n        std::cout.tie(nullptr);\\n        int res = 0 ; \\n        unordered_map<int,int> m ; \\n        for(auto x:tasks)\\n        m[x]++ ; \\n\\n        for(auto x:m)\\n        {\\n            if(x.second==1)\\n            return -1;\\n            if(x.second%3==1)\\n            {\\n                res += (x.second-4)/3 +2;\\n            }\\n            else  res += x.second/3 + (x.second%3)/2;\\n\\n\\n        }\\n\\n\\n        return res; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) \\n    {\\n        std::ios::sync_with_stdio(false);\\n        std::cin.tie(nullptr);\\n        std::cout.tie(nullptr);\\n        int res = 0 ; \\n        unordered_map<int,int> m ; \\n        for(auto x:tasks)\\n        m[x]++ ; \\n\\n        for(auto x:m)\\n        {\\n            if(x.second==1)\\n            return -1;\\n            if(x.second%3==1)\\n            {\\n                res += (x.second-4)/3 +2;\\n            }\\n            else  res += x.second/3 + (x.second%3)/2;\\n\\n\\n        }\\n\\n\\n        return res; \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3133221,
                "title": "1000-iq-solution",
                "content": "So long as difficulty d occurs more than once, all tasks of that difficulty can be completed in at best `ceil(frequency of d / 3)` operations.\\nThink about it.:)\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Rust []\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn minimum_rounds(tasks: Vec<i32>) -> i32 {\\n        let mut map = HashMap::new();\\n        let mut ans = 0;\\n\\n        for task in tasks {\\n            let val = map.get_mut(&task);\\n\\n            if let Some(v) = val {\\n                *v += 1;\\n            } else {\\n                map.insert(task, 1);\\n            }\\n        }\\n\\n        for count in map.into_values() {\\n            if count == 1 {\\n                return -1;\\n            }\\n            ans += (count + 2) / 3;\\n        }\\n\\n        ans\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```Rust []\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn minimum_rounds(tasks: Vec<i32>) -> i32 {\\n        let mut map = HashMap::new();\\n        let mut ans = 0;\\n\\n        for task in tasks {\\n            let val = map.get_mut(&task);\\n\\n            if let Some(v) = val {\\n                *v += 1;\\n            } else {\\n                map.insert(task, 1);\\n            }\\n        }\\n\\n        for count in map.into_values() {\\n            if count == 1 {\\n                return -1;\\n            }\\n            ans += (count + 2) / 3;\\n        }\\n\\n        ans\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3064993,
                "title": "c-simple-solution",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int MinimumRounds(int[] tasks) {\\n        Dictionary<int,int> dict = new Dictionary<int,int>();\\n        int result = 0;\\n        foreach(int item in tasks){\\n            if(dict.ContainsKey(item)){\\n                dict[item]++;\\n            }else{\\n                dict.Add(item,1);\\n            }\\n        }\\n        foreach(var item in dict){            \\n            if(item.Value < 2){\\n                return -1;\\n            }\\n            result += (item.Value + 2) / 3;\\n        }    \\n        return result;     \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimumRounds(int[] tasks) {\\n        Dictionary<int,int> dict = new Dictionary<int,int>();\\n        int result = 0;\\n        foreach(int item in tasks){\\n            if(dict.ContainsKey(item)){\\n                dict[item]++;\\n            }else{\\n                dict.Add(item,1);\\n            }\\n        }\\n        foreach(var item in dict){            \\n            if(item.Value < 2){\\n                return -1;\\n            }\\n            result += (item.Value + 2) / 3;\\n        }    \\n        return result;     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015660,
                "title": "easy-and-simple-java-solution-by-sorting-the-array",
                "content": "\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Arrays.sort(tasks);        //sort the Array\\n        int round=0;\\n        int count=0;\\n        for(int i=0;i<tasks.length-1;i++)\\n        {\\n            if(tasks[i]==tasks[i+1])\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                count++;\\n                if(count==2||count==3)\\n                {\\n                    round++;\\n                }\\n                else if(count>3)\\n                {\\n                    int dif=count/3;\\n                    round=round+dif;\\n                    if(count%3==1||count%3==2)\\n                        round++;\\n                }\\n                else //count==1;\\n                    return -1;\\n                count=0;\\n            }\\n        }\\n\\t\\t//Now check for last element\\n        if(count>0)\\n            {\\n                count++;\\n                if(count==2||count==3)\\n                {\\n                    round++;\\n                }\\n                else if(count>3)\\n                {\\n                    int dif=count/3;\\n                    round=round+dif;\\n                    if(count%3==1||count%3==2)\\n                        round++;\\n                }\\n                else //count==1;\\n                    return -1;\\n        }\\n        if(tasks.length==1)\\n            return -1;\\n        if(tasks[tasks.length-1]!=tasks[tasks.length-2])\\n            return -1;\\n        else\\n            return round;\\n    }\\n}\\n\\n```\\nTime Complexity- O(N)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Arrays.sort(tasks);        //sort the Array\\n        int round=0;\\n        int count=0;\\n        for(int i=0;i<tasks.length-1;i++)\\n        {\\n            if(tasks[i]==tasks[i+1])\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                count++;\\n                if(count==2||count==3)\\n                {\\n                    round++;\\n                }\\n                else if(count>3)\\n                {\\n                    int dif=count/3;\\n                    round=round+dif;\\n                    if(count%3==1||count%3==2)\\n                        round++;\\n                }\\n                else //count==1;\\n                    return -1;\\n                count=0;\\n            }\\n        }\\n\\t\\t//Now check for last element\\n        if(count>0)\\n            {\\n                count++;\\n                if(count==2||count==3)\\n                {\\n                    round++;\\n                }\\n                else if(count>3)\\n                {\\n                    int dif=count/3;\\n                    round=round+dif;\\n                    if(count%3==1||count%3==2)\\n                        round++;\\n                }\\n                else //count==1;\\n                    return -1;\\n        }\\n        if(tasks.length==1)\\n            return -1;\\n        if(tasks[tasks.length-1]!=tasks[tasks.length-2])\\n            return -1;\\n        else\\n            return round;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003319,
                "title": "c-daily-challenge",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int n = tasks.size() ;\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[tasks[i]]++ ;\\n        }\\n        int c=0;\\n        for(auto it : mp){\\n            if(it.second==1) return -1;\\n            if(it.second % 3==0){\\n                c+=it.second/3 ;\\n            }\\n            else{\\n                c+=it.second/3 + 1;\\n            }\\n        }\\n      return c ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int n = tasks.size() ;\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[tasks[i]]++ ;\\n        }\\n        int c=0;\\n        for(auto it : mp){\\n            if(it.second==1) return -1;\\n            if(it.second % 3==0){\\n                c+=it.second/3 ;\\n            }\\n            else{\\n                c+=it.second/3 + 1;\\n            }\\n        }\\n      return c ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003071,
                "title": "javascript-time-space-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n![image.png](https://assets.leetcode.com/users/images/e56b4b4c-89f7-44e6-8f83-abe0a5ef624d_1672924306.9503403.png)\\n\\n\\n\\nText from the image: \\nWe can immedietly `return -1` if any of the frequencies is `1`.\\n\\nIf the frequency is `2`, simply increment the steps by one.\\n\\nIf we divide by `3` these numbers `(6, 7, 8)`\\nwe get following remainders: `6 % 3 = 0, 6 % 7 = 1, 6 % 8 = 2`\\n\\nSo, for `6`, we increment steps by 2 `(6 / 3 = 2)` since 6 is basically `3 + 3`\\n\\nFor `7`, we have a leftover. But `7` is just `2 + 2 + 3` and `7 / 3 = 2.333`\\nso if we take just the whole number part of the result `(2)` and add `1` we\\nget the size of our group aka steps.\\n\\nIn case of an 8 which is basically `3 + 3 + 2` and `8 / 3 = 2.6666` we have\\nsimilar case. Just take the whole number `(2)` and add 1 to it.\\n\\nThus we end up with the following formula\\n\\nIf number is divisible by 3, add `frequency / 3 `to steps\\notherwise, get the whole number part of `frequency / 3 `and add `1` to it\\n\\n> NB! If we divide by 2, we will end up with higher step count\\n\\n---\\n\\n***Fun mini game**: think of a number and try to use minimum number of 2s and 3s to get to it :)*\\n\\n---\\n# Complexity\\n- Time complexity: O(N); \\n    - To get frequiency is O(N) the looping to get the steps is also O(N). Getting an item from a map via key is O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n    - We are creating a frequency map so extra space is allocated\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    let map = {} // freq map\\n    let steps = 0 // steps result\\n\\n    for (let i of tasks) {\\n        if (map[i] !== undefined) {\\n            map[i]++\\n        } else {\\n            map[i] = 1\\n        }\\n    }\\n\\n    for (let i in map) {\\n        if (map[i] === 1) return -1\\n        else if (map[i] === 2) steps++\\n        else if (map[i] > 2) {\\n            if (map[i] % 3 > 0) steps += Math.trunc(map[i] / 3) + 1\\n            else steps += map[i] / 3\\n        }\\n    }\\n    return steps\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    let map = {} // freq map\\n    let steps = 0 // steps result\\n\\n    for (let i of tasks) {\\n        if (map[i] !== undefined) {\\n            map[i]++\\n        } else {\\n            map[i] = 1\\n        }\\n    }\\n\\n    for (let i in map) {\\n        if (map[i] === 1) return -1\\n        else if (map[i] === 2) steps++\\n        else if (map[i] > 2) {\\n            if (map[i] % 3 > 0) steps += Math.trunc(map[i] / 3) + 1\\n            else steps += map[i] / 3\\n        }\\n    }\\n    return steps\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1740459,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740590,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1741055,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740503,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740448,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740599,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1735490,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740415,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740413,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740637,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740459,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740590,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1741055,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740503,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740448,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740599,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1735490,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740415,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740413,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740637,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740857,
                "content": [
                    {
                        "username": "sachinbaral02",
                        "content": "A medium problem today hmmm.... lemme grab my coffee first\\u2615."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@cswartzell](/cswartzell) Using a sorting method can do it in O(1) space but I don\\'t consider this a big win, since we are also ruining  the original list provided. Regarding time complexity for array vs hashmap. I think this debate will always come in such questions. As a thumb rule I avoid using a hashmap if the values are continuous since there can be an even better solution where we just initialize an array to all zeroes and use it just as a map, but due to memory constraints, it wont be wise to use it when range is >10^6. \\n\\nHaving said that, I don\\'t think this question is about that, it is just a simple question for number theory and any way should be fine so I don\\'t give much significance to \\'Beats %\\' as long as runtime is in sane limits."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Are than any easier mediums than this? I was trying to see what the trick might be... I guess there kind of is one if you note that sorting O(nlogn) for 10^5 is still smaller than 10^9 so sorting solutions are actually faster than hashmap solutions despite the worse Time Complexity. Plus using a sorting method you can do it with O(1) space. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sachin](/sachinbaral02) not really a medium, on the easy side of medium!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "No Need to put a **lot of condition**\\ntake map ...count the freq....check if map contain 1 or not \\nif not then just do `count += ceil(it.second/3.0);` \\nif yes `return -1;`"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@sarpalmadhav](/sarpalmadhav) could you please explain is bit more ."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dhvani](/Knight-03), as pointed out in some other comment, I think `(it.second + 2)/3` is much better than using ceil function as it avoids pointer arithmetic."
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "Think of how to handle 5 & 7 :) That was the step I was missing for my solution."
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "Can someone please post recursive/dp solution? (i know it will give tle but i want to know how can i do using recursion)"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871518370/ bro i did it but it was failing a testcase . you can have a look ."
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "Sort the array of tasks in ascending order.\\nIterate through each task and count how many tasks have the same value.\\nIf there is only one task with a particular value, return -1 since we cannot create any groups of 3 from these tasks.\\nOtherwise, add the number of full groups of 3 that can be created from the tasks with this value to the result.\\nIf there are any remaining tasks that cannot be included in a group of 3, increment the result by 1 to indicate that another round is needed to process these tasks.\\nReturn the total number of rounds needed to process all of the tasks."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "these easy-mid questions are the silence before the storm that LC is going to bring soon"
                    },
                    {
                        "username": "fengvang24",
                        "content": "bro don\\'t rain on my parade"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": ":) kill me"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "The intuition is quite simple, just store freq of elements and then think how to group the freq in 3 or 2 \\nHint: Grouping in 3 would result in lesser rounds"
                    },
                    {
                        "username": "tanayak",
                        "content": "Simple Map based solution\\n```class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        TreeMap<Integer, Integer> difficultyMap = new TreeMap<>();\\n\\n        for(int i = 0; i < tasks.length; i++) {\\n            difficultyMap.put(tasks[i], difficultyMap.getOrDefault(tasks[i], 0) + 1);\\n        }\\n\\n        int count = 0;\\n        while(!difficultyMap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = difficultyMap.firstEntry();\\n            if(entry.getValue() < 2)\\n                return -1;\\n            else if(entry.getValue() == 2 || entry.getValue() == 3) {\\n                count++;\\n                difficultyMap.remove(entry.getKey());\\n            } else {\\n                int value = entry.getValue() - 3;\\n                if(value < 2) {\\n                    value = entry.getValue() - 2;\\n                }\\n                difficultyMap.put(entry.getKey(), value);\\n                count++;\\n            }\\n\\n        }\\n        return count;\\n    }\\n}```"
                    },
                    {
                        "username": "ArianLC",
                        "content": "// Javascript\\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    const totalDifficulties = {};\\n    for (const task of tasks) {\\n      totalDifficulties[task] = (totalDifficulties[task] || 0) + 1;\\n    }\\n    let totalRoundsToComplete = 0;\\n    for (const total of Object.values(totalDifficulties)) {\\n      if (total === 1) {return -1;}\\n      const remainderThree = total % 3;\\n      if (remainderThree === 0) {\\n        totalRoundsToComplete += Math.floor(total / 3);\\n      } else {\\n        totalRoundsToComplete += Math.floor((total / 3)) + 1\\n      }\\n    }\\n    return totalRoundsToComplete;\\n};\\n```"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "This was my first Medium level question and I brute forced it without using HashMap in C++, and it was accepted with 1175 ms runtime, lol."
                    }
                ]
            },
            {
                "id": 1740675,
                "content": [
                    {
                        "username": "sachinbaral02",
                        "content": "A medium problem today hmmm.... lemme grab my coffee first\\u2615."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@cswartzell](/cswartzell) Using a sorting method can do it in O(1) space but I don\\'t consider this a big win, since we are also ruining  the original list provided. Regarding time complexity for array vs hashmap. I think this debate will always come in such questions. As a thumb rule I avoid using a hashmap if the values are continuous since there can be an even better solution where we just initialize an array to all zeroes and use it just as a map, but due to memory constraints, it wont be wise to use it when range is >10^6. \\n\\nHaving said that, I don\\'t think this question is about that, it is just a simple question for number theory and any way should be fine so I don\\'t give much significance to \\'Beats %\\' as long as runtime is in sane limits."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Are than any easier mediums than this? I was trying to see what the trick might be... I guess there kind of is one if you note that sorting O(nlogn) for 10^5 is still smaller than 10^9 so sorting solutions are actually faster than hashmap solutions despite the worse Time Complexity. Plus using a sorting method you can do it with O(1) space. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sachin](/sachinbaral02) not really a medium, on the easy side of medium!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "No Need to put a **lot of condition**\\ntake map ...count the freq....check if map contain 1 or not \\nif not then just do `count += ceil(it.second/3.0);` \\nif yes `return -1;`"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@sarpalmadhav](/sarpalmadhav) could you please explain is bit more ."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dhvani](/Knight-03), as pointed out in some other comment, I think `(it.second + 2)/3` is much better than using ceil function as it avoids pointer arithmetic."
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "Think of how to handle 5 & 7 :) That was the step I was missing for my solution."
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "Can someone please post recursive/dp solution? (i know it will give tle but i want to know how can i do using recursion)"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871518370/ bro i did it but it was failing a testcase . you can have a look ."
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "Sort the array of tasks in ascending order.\\nIterate through each task and count how many tasks have the same value.\\nIf there is only one task with a particular value, return -1 since we cannot create any groups of 3 from these tasks.\\nOtherwise, add the number of full groups of 3 that can be created from the tasks with this value to the result.\\nIf there are any remaining tasks that cannot be included in a group of 3, increment the result by 1 to indicate that another round is needed to process these tasks.\\nReturn the total number of rounds needed to process all of the tasks."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "these easy-mid questions are the silence before the storm that LC is going to bring soon"
                    },
                    {
                        "username": "fengvang24",
                        "content": "bro don\\'t rain on my parade"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": ":) kill me"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "The intuition is quite simple, just store freq of elements and then think how to group the freq in 3 or 2 \\nHint: Grouping in 3 would result in lesser rounds"
                    },
                    {
                        "username": "tanayak",
                        "content": "Simple Map based solution\\n```class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        TreeMap<Integer, Integer> difficultyMap = new TreeMap<>();\\n\\n        for(int i = 0; i < tasks.length; i++) {\\n            difficultyMap.put(tasks[i], difficultyMap.getOrDefault(tasks[i], 0) + 1);\\n        }\\n\\n        int count = 0;\\n        while(!difficultyMap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = difficultyMap.firstEntry();\\n            if(entry.getValue() < 2)\\n                return -1;\\n            else if(entry.getValue() == 2 || entry.getValue() == 3) {\\n                count++;\\n                difficultyMap.remove(entry.getKey());\\n            } else {\\n                int value = entry.getValue() - 3;\\n                if(value < 2) {\\n                    value = entry.getValue() - 2;\\n                }\\n                difficultyMap.put(entry.getKey(), value);\\n                count++;\\n            }\\n\\n        }\\n        return count;\\n    }\\n}```"
                    },
                    {
                        "username": "ArianLC",
                        "content": "// Javascript\\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    const totalDifficulties = {};\\n    for (const task of tasks) {\\n      totalDifficulties[task] = (totalDifficulties[task] || 0) + 1;\\n    }\\n    let totalRoundsToComplete = 0;\\n    for (const total of Object.values(totalDifficulties)) {\\n      if (total === 1) {return -1;}\\n      const remainderThree = total % 3;\\n      if (remainderThree === 0) {\\n        totalRoundsToComplete += Math.floor(total / 3);\\n      } else {\\n        totalRoundsToComplete += Math.floor((total / 3)) + 1\\n      }\\n    }\\n    return totalRoundsToComplete;\\n};\\n```"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "This was my first Medium level question and I brute forced it without using HashMap in C++, and it was accepted with 1175 ms runtime, lol."
                    }
                ]
            },
            {
                "id": 1741997,
                "content": [
                    {
                        "username": "sachinbaral02",
                        "content": "A medium problem today hmmm.... lemme grab my coffee first\\u2615."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@cswartzell](/cswartzell) Using a sorting method can do it in O(1) space but I don\\'t consider this a big win, since we are also ruining  the original list provided. Regarding time complexity for array vs hashmap. I think this debate will always come in such questions. As a thumb rule I avoid using a hashmap if the values are continuous since there can be an even better solution where we just initialize an array to all zeroes and use it just as a map, but due to memory constraints, it wont be wise to use it when range is >10^6. \\n\\nHaving said that, I don\\'t think this question is about that, it is just a simple question for number theory and any way should be fine so I don\\'t give much significance to \\'Beats %\\' as long as runtime is in sane limits."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Are than any easier mediums than this? I was trying to see what the trick might be... I guess there kind of is one if you note that sorting O(nlogn) for 10^5 is still smaller than 10^9 so sorting solutions are actually faster than hashmap solutions despite the worse Time Complexity. Plus using a sorting method you can do it with O(1) space. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sachin](/sachinbaral02) not really a medium, on the easy side of medium!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "No Need to put a **lot of condition**\\ntake map ...count the freq....check if map contain 1 or not \\nif not then just do `count += ceil(it.second/3.0);` \\nif yes `return -1;`"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@sarpalmadhav](/sarpalmadhav) could you please explain is bit more ."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dhvani](/Knight-03), as pointed out in some other comment, I think `(it.second + 2)/3` is much better than using ceil function as it avoids pointer arithmetic."
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "Think of how to handle 5 & 7 :) That was the step I was missing for my solution."
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "Can someone please post recursive/dp solution? (i know it will give tle but i want to know how can i do using recursion)"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871518370/ bro i did it but it was failing a testcase . you can have a look ."
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "Sort the array of tasks in ascending order.\\nIterate through each task and count how many tasks have the same value.\\nIf there is only one task with a particular value, return -1 since we cannot create any groups of 3 from these tasks.\\nOtherwise, add the number of full groups of 3 that can be created from the tasks with this value to the result.\\nIf there are any remaining tasks that cannot be included in a group of 3, increment the result by 1 to indicate that another round is needed to process these tasks.\\nReturn the total number of rounds needed to process all of the tasks."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "these easy-mid questions are the silence before the storm that LC is going to bring soon"
                    },
                    {
                        "username": "fengvang24",
                        "content": "bro don\\'t rain on my parade"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": ":) kill me"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "The intuition is quite simple, just store freq of elements and then think how to group the freq in 3 or 2 \\nHint: Grouping in 3 would result in lesser rounds"
                    },
                    {
                        "username": "tanayak",
                        "content": "Simple Map based solution\\n```class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        TreeMap<Integer, Integer> difficultyMap = new TreeMap<>();\\n\\n        for(int i = 0; i < tasks.length; i++) {\\n            difficultyMap.put(tasks[i], difficultyMap.getOrDefault(tasks[i], 0) + 1);\\n        }\\n\\n        int count = 0;\\n        while(!difficultyMap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = difficultyMap.firstEntry();\\n            if(entry.getValue() < 2)\\n                return -1;\\n            else if(entry.getValue() == 2 || entry.getValue() == 3) {\\n                count++;\\n                difficultyMap.remove(entry.getKey());\\n            } else {\\n                int value = entry.getValue() - 3;\\n                if(value < 2) {\\n                    value = entry.getValue() - 2;\\n                }\\n                difficultyMap.put(entry.getKey(), value);\\n                count++;\\n            }\\n\\n        }\\n        return count;\\n    }\\n}```"
                    },
                    {
                        "username": "ArianLC",
                        "content": "// Javascript\\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    const totalDifficulties = {};\\n    for (const task of tasks) {\\n      totalDifficulties[task] = (totalDifficulties[task] || 0) + 1;\\n    }\\n    let totalRoundsToComplete = 0;\\n    for (const total of Object.values(totalDifficulties)) {\\n      if (total === 1) {return -1;}\\n      const remainderThree = total % 3;\\n      if (remainderThree === 0) {\\n        totalRoundsToComplete += Math.floor(total / 3);\\n      } else {\\n        totalRoundsToComplete += Math.floor((total / 3)) + 1\\n      }\\n    }\\n    return totalRoundsToComplete;\\n};\\n```"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "This was my first Medium level question and I brute forced it without using HashMap in C++, and it was accepted with 1175 ms runtime, lol."
                    }
                ]
            },
            {
                "id": 1741848,
                "content": [
                    {
                        "username": "sachinbaral02",
                        "content": "A medium problem today hmmm.... lemme grab my coffee first\\u2615."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@cswartzell](/cswartzell) Using a sorting method can do it in O(1) space but I don\\'t consider this a big win, since we are also ruining  the original list provided. Regarding time complexity for array vs hashmap. I think this debate will always come in such questions. As a thumb rule I avoid using a hashmap if the values are continuous since there can be an even better solution where we just initialize an array to all zeroes and use it just as a map, but due to memory constraints, it wont be wise to use it when range is >10^6. \\n\\nHaving said that, I don\\'t think this question is about that, it is just a simple question for number theory and any way should be fine so I don\\'t give much significance to \\'Beats %\\' as long as runtime is in sane limits."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Are than any easier mediums than this? I was trying to see what the trick might be... I guess there kind of is one if you note that sorting O(nlogn) for 10^5 is still smaller than 10^9 so sorting solutions are actually faster than hashmap solutions despite the worse Time Complexity. Plus using a sorting method you can do it with O(1) space. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sachin](/sachinbaral02) not really a medium, on the easy side of medium!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "No Need to put a **lot of condition**\\ntake map ...count the freq....check if map contain 1 or not \\nif not then just do `count += ceil(it.second/3.0);` \\nif yes `return -1;`"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@sarpalmadhav](/sarpalmadhav) could you please explain is bit more ."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dhvani](/Knight-03), as pointed out in some other comment, I think `(it.second + 2)/3` is much better than using ceil function as it avoids pointer arithmetic."
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "Think of how to handle 5 & 7 :) That was the step I was missing for my solution."
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "Can someone please post recursive/dp solution? (i know it will give tle but i want to know how can i do using recursion)"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871518370/ bro i did it but it was failing a testcase . you can have a look ."
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "Sort the array of tasks in ascending order.\\nIterate through each task and count how many tasks have the same value.\\nIf there is only one task with a particular value, return -1 since we cannot create any groups of 3 from these tasks.\\nOtherwise, add the number of full groups of 3 that can be created from the tasks with this value to the result.\\nIf there are any remaining tasks that cannot be included in a group of 3, increment the result by 1 to indicate that another round is needed to process these tasks.\\nReturn the total number of rounds needed to process all of the tasks."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "these easy-mid questions are the silence before the storm that LC is going to bring soon"
                    },
                    {
                        "username": "fengvang24",
                        "content": "bro don\\'t rain on my parade"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": ":) kill me"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "The intuition is quite simple, just store freq of elements and then think how to group the freq in 3 or 2 \\nHint: Grouping in 3 would result in lesser rounds"
                    },
                    {
                        "username": "tanayak",
                        "content": "Simple Map based solution\\n```class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        TreeMap<Integer, Integer> difficultyMap = new TreeMap<>();\\n\\n        for(int i = 0; i < tasks.length; i++) {\\n            difficultyMap.put(tasks[i], difficultyMap.getOrDefault(tasks[i], 0) + 1);\\n        }\\n\\n        int count = 0;\\n        while(!difficultyMap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = difficultyMap.firstEntry();\\n            if(entry.getValue() < 2)\\n                return -1;\\n            else if(entry.getValue() == 2 || entry.getValue() == 3) {\\n                count++;\\n                difficultyMap.remove(entry.getKey());\\n            } else {\\n                int value = entry.getValue() - 3;\\n                if(value < 2) {\\n                    value = entry.getValue() - 2;\\n                }\\n                difficultyMap.put(entry.getKey(), value);\\n                count++;\\n            }\\n\\n        }\\n        return count;\\n    }\\n}```"
                    },
                    {
                        "username": "ArianLC",
                        "content": "// Javascript\\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    const totalDifficulties = {};\\n    for (const task of tasks) {\\n      totalDifficulties[task] = (totalDifficulties[task] || 0) + 1;\\n    }\\n    let totalRoundsToComplete = 0;\\n    for (const total of Object.values(totalDifficulties)) {\\n      if (total === 1) {return -1;}\\n      const remainderThree = total % 3;\\n      if (remainderThree === 0) {\\n        totalRoundsToComplete += Math.floor(total / 3);\\n      } else {\\n        totalRoundsToComplete += Math.floor((total / 3)) + 1\\n      }\\n    }\\n    return totalRoundsToComplete;\\n};\\n```"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "This was my first Medium level question and I brute forced it without using HashMap in C++, and it was accepted with 1175 ms runtime, lol."
                    }
                ]
            },
            {
                "id": 1740891,
                "content": [
                    {
                        "username": "sachinbaral02",
                        "content": "A medium problem today hmmm.... lemme grab my coffee first\\u2615."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@cswartzell](/cswartzell) Using a sorting method can do it in O(1) space but I don\\'t consider this a big win, since we are also ruining  the original list provided. Regarding time complexity for array vs hashmap. I think this debate will always come in such questions. As a thumb rule I avoid using a hashmap if the values are continuous since there can be an even better solution where we just initialize an array to all zeroes and use it just as a map, but due to memory constraints, it wont be wise to use it when range is >10^6. \\n\\nHaving said that, I don\\'t think this question is about that, it is just a simple question for number theory and any way should be fine so I don\\'t give much significance to \\'Beats %\\' as long as runtime is in sane limits."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Are than any easier mediums than this? I was trying to see what the trick might be... I guess there kind of is one if you note that sorting O(nlogn) for 10^5 is still smaller than 10^9 so sorting solutions are actually faster than hashmap solutions despite the worse Time Complexity. Plus using a sorting method you can do it with O(1) space. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sachin](/sachinbaral02) not really a medium, on the easy side of medium!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "No Need to put a **lot of condition**\\ntake map ...count the freq....check if map contain 1 or not \\nif not then just do `count += ceil(it.second/3.0);` \\nif yes `return -1;`"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@sarpalmadhav](/sarpalmadhav) could you please explain is bit more ."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dhvani](/Knight-03), as pointed out in some other comment, I think `(it.second + 2)/3` is much better than using ceil function as it avoids pointer arithmetic."
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "Think of how to handle 5 & 7 :) That was the step I was missing for my solution."
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "Can someone please post recursive/dp solution? (i know it will give tle but i want to know how can i do using recursion)"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871518370/ bro i did it but it was failing a testcase . you can have a look ."
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "Sort the array of tasks in ascending order.\\nIterate through each task and count how many tasks have the same value.\\nIf there is only one task with a particular value, return -1 since we cannot create any groups of 3 from these tasks.\\nOtherwise, add the number of full groups of 3 that can be created from the tasks with this value to the result.\\nIf there are any remaining tasks that cannot be included in a group of 3, increment the result by 1 to indicate that another round is needed to process these tasks.\\nReturn the total number of rounds needed to process all of the tasks."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "these easy-mid questions are the silence before the storm that LC is going to bring soon"
                    },
                    {
                        "username": "fengvang24",
                        "content": "bro don\\'t rain on my parade"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": ":) kill me"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "The intuition is quite simple, just store freq of elements and then think how to group the freq in 3 or 2 \\nHint: Grouping in 3 would result in lesser rounds"
                    },
                    {
                        "username": "tanayak",
                        "content": "Simple Map based solution\\n```class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        TreeMap<Integer, Integer> difficultyMap = new TreeMap<>();\\n\\n        for(int i = 0; i < tasks.length; i++) {\\n            difficultyMap.put(tasks[i], difficultyMap.getOrDefault(tasks[i], 0) + 1);\\n        }\\n\\n        int count = 0;\\n        while(!difficultyMap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = difficultyMap.firstEntry();\\n            if(entry.getValue() < 2)\\n                return -1;\\n            else if(entry.getValue() == 2 || entry.getValue() == 3) {\\n                count++;\\n                difficultyMap.remove(entry.getKey());\\n            } else {\\n                int value = entry.getValue() - 3;\\n                if(value < 2) {\\n                    value = entry.getValue() - 2;\\n                }\\n                difficultyMap.put(entry.getKey(), value);\\n                count++;\\n            }\\n\\n        }\\n        return count;\\n    }\\n}```"
                    },
                    {
                        "username": "ArianLC",
                        "content": "// Javascript\\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    const totalDifficulties = {};\\n    for (const task of tasks) {\\n      totalDifficulties[task] = (totalDifficulties[task] || 0) + 1;\\n    }\\n    let totalRoundsToComplete = 0;\\n    for (const total of Object.values(totalDifficulties)) {\\n      if (total === 1) {return -1;}\\n      const remainderThree = total % 3;\\n      if (remainderThree === 0) {\\n        totalRoundsToComplete += Math.floor(total / 3);\\n      } else {\\n        totalRoundsToComplete += Math.floor((total / 3)) + 1\\n      }\\n    }\\n    return totalRoundsToComplete;\\n};\\n```"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "This was my first Medium level question and I brute forced it without using HashMap in C++, and it was accepted with 1175 ms runtime, lol."
                    }
                ]
            },
            {
                "id": 1740748,
                "content": [
                    {
                        "username": "sachinbaral02",
                        "content": "A medium problem today hmmm.... lemme grab my coffee first\\u2615."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@cswartzell](/cswartzell) Using a sorting method can do it in O(1) space but I don\\'t consider this a big win, since we are also ruining  the original list provided. Regarding time complexity for array vs hashmap. I think this debate will always come in such questions. As a thumb rule I avoid using a hashmap if the values are continuous since there can be an even better solution where we just initialize an array to all zeroes and use it just as a map, but due to memory constraints, it wont be wise to use it when range is >10^6. \\n\\nHaving said that, I don\\'t think this question is about that, it is just a simple question for number theory and any way should be fine so I don\\'t give much significance to \\'Beats %\\' as long as runtime is in sane limits."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Are than any easier mediums than this? I was trying to see what the trick might be... I guess there kind of is one if you note that sorting O(nlogn) for 10^5 is still smaller than 10^9 so sorting solutions are actually faster than hashmap solutions despite the worse Time Complexity. Plus using a sorting method you can do it with O(1) space. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sachin](/sachinbaral02) not really a medium, on the easy side of medium!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "No Need to put a **lot of condition**\\ntake map ...count the freq....check if map contain 1 or not \\nif not then just do `count += ceil(it.second/3.0);` \\nif yes `return -1;`"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@sarpalmadhav](/sarpalmadhav) could you please explain is bit more ."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dhvani](/Knight-03), as pointed out in some other comment, I think `(it.second + 2)/3` is much better than using ceil function as it avoids pointer arithmetic."
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "Think of how to handle 5 & 7 :) That was the step I was missing for my solution."
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "Can someone please post recursive/dp solution? (i know it will give tle but i want to know how can i do using recursion)"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871518370/ bro i did it but it was failing a testcase . you can have a look ."
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "Sort the array of tasks in ascending order.\\nIterate through each task and count how many tasks have the same value.\\nIf there is only one task with a particular value, return -1 since we cannot create any groups of 3 from these tasks.\\nOtherwise, add the number of full groups of 3 that can be created from the tasks with this value to the result.\\nIf there are any remaining tasks that cannot be included in a group of 3, increment the result by 1 to indicate that another round is needed to process these tasks.\\nReturn the total number of rounds needed to process all of the tasks."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "these easy-mid questions are the silence before the storm that LC is going to bring soon"
                    },
                    {
                        "username": "fengvang24",
                        "content": "bro don\\'t rain on my parade"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": ":) kill me"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "The intuition is quite simple, just store freq of elements and then think how to group the freq in 3 or 2 \\nHint: Grouping in 3 would result in lesser rounds"
                    },
                    {
                        "username": "tanayak",
                        "content": "Simple Map based solution\\n```class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        TreeMap<Integer, Integer> difficultyMap = new TreeMap<>();\\n\\n        for(int i = 0; i < tasks.length; i++) {\\n            difficultyMap.put(tasks[i], difficultyMap.getOrDefault(tasks[i], 0) + 1);\\n        }\\n\\n        int count = 0;\\n        while(!difficultyMap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = difficultyMap.firstEntry();\\n            if(entry.getValue() < 2)\\n                return -1;\\n            else if(entry.getValue() == 2 || entry.getValue() == 3) {\\n                count++;\\n                difficultyMap.remove(entry.getKey());\\n            } else {\\n                int value = entry.getValue() - 3;\\n                if(value < 2) {\\n                    value = entry.getValue() - 2;\\n                }\\n                difficultyMap.put(entry.getKey(), value);\\n                count++;\\n            }\\n\\n        }\\n        return count;\\n    }\\n}```"
                    },
                    {
                        "username": "ArianLC",
                        "content": "// Javascript\\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    const totalDifficulties = {};\\n    for (const task of tasks) {\\n      totalDifficulties[task] = (totalDifficulties[task] || 0) + 1;\\n    }\\n    let totalRoundsToComplete = 0;\\n    for (const total of Object.values(totalDifficulties)) {\\n      if (total === 1) {return -1;}\\n      const remainderThree = total % 3;\\n      if (remainderThree === 0) {\\n        totalRoundsToComplete += Math.floor(total / 3);\\n      } else {\\n        totalRoundsToComplete += Math.floor((total / 3)) + 1\\n      }\\n    }\\n    return totalRoundsToComplete;\\n};\\n```"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "This was my first Medium level question and I brute forced it without using HashMap in C++, and it was accepted with 1175 ms runtime, lol."
                    }
                ]
            },
            {
                "id": 1740559,
                "content": [
                    {
                        "username": "sachinbaral02",
                        "content": "A medium problem today hmmm.... lemme grab my coffee first\\u2615."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@cswartzell](/cswartzell) Using a sorting method can do it in O(1) space but I don\\'t consider this a big win, since we are also ruining  the original list provided. Regarding time complexity for array vs hashmap. I think this debate will always come in such questions. As a thumb rule I avoid using a hashmap if the values are continuous since there can be an even better solution where we just initialize an array to all zeroes and use it just as a map, but due to memory constraints, it wont be wise to use it when range is >10^6. \\n\\nHaving said that, I don\\'t think this question is about that, it is just a simple question for number theory and any way should be fine so I don\\'t give much significance to \\'Beats %\\' as long as runtime is in sane limits."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Are than any easier mediums than this? I was trying to see what the trick might be... I guess there kind of is one if you note that sorting O(nlogn) for 10^5 is still smaller than 10^9 so sorting solutions are actually faster than hashmap solutions despite the worse Time Complexity. Plus using a sorting method you can do it with O(1) space. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sachin](/sachinbaral02) not really a medium, on the easy side of medium!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "No Need to put a **lot of condition**\\ntake map ...count the freq....check if map contain 1 or not \\nif not then just do `count += ceil(it.second/3.0);` \\nif yes `return -1;`"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@sarpalmadhav](/sarpalmadhav) could you please explain is bit more ."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dhvani](/Knight-03), as pointed out in some other comment, I think `(it.second + 2)/3` is much better than using ceil function as it avoids pointer arithmetic."
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "Think of how to handle 5 & 7 :) That was the step I was missing for my solution."
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "Can someone please post recursive/dp solution? (i know it will give tle but i want to know how can i do using recursion)"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871518370/ bro i did it but it was failing a testcase . you can have a look ."
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "Sort the array of tasks in ascending order.\\nIterate through each task and count how many tasks have the same value.\\nIf there is only one task with a particular value, return -1 since we cannot create any groups of 3 from these tasks.\\nOtherwise, add the number of full groups of 3 that can be created from the tasks with this value to the result.\\nIf there are any remaining tasks that cannot be included in a group of 3, increment the result by 1 to indicate that another round is needed to process these tasks.\\nReturn the total number of rounds needed to process all of the tasks."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "these easy-mid questions are the silence before the storm that LC is going to bring soon"
                    },
                    {
                        "username": "fengvang24",
                        "content": "bro don\\'t rain on my parade"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": ":) kill me"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "The intuition is quite simple, just store freq of elements and then think how to group the freq in 3 or 2 \\nHint: Grouping in 3 would result in lesser rounds"
                    },
                    {
                        "username": "tanayak",
                        "content": "Simple Map based solution\\n```class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        TreeMap<Integer, Integer> difficultyMap = new TreeMap<>();\\n\\n        for(int i = 0; i < tasks.length; i++) {\\n            difficultyMap.put(tasks[i], difficultyMap.getOrDefault(tasks[i], 0) + 1);\\n        }\\n\\n        int count = 0;\\n        while(!difficultyMap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = difficultyMap.firstEntry();\\n            if(entry.getValue() < 2)\\n                return -1;\\n            else if(entry.getValue() == 2 || entry.getValue() == 3) {\\n                count++;\\n                difficultyMap.remove(entry.getKey());\\n            } else {\\n                int value = entry.getValue() - 3;\\n                if(value < 2) {\\n                    value = entry.getValue() - 2;\\n                }\\n                difficultyMap.put(entry.getKey(), value);\\n                count++;\\n            }\\n\\n        }\\n        return count;\\n    }\\n}```"
                    },
                    {
                        "username": "ArianLC",
                        "content": "// Javascript\\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    const totalDifficulties = {};\\n    for (const task of tasks) {\\n      totalDifficulties[task] = (totalDifficulties[task] || 0) + 1;\\n    }\\n    let totalRoundsToComplete = 0;\\n    for (const total of Object.values(totalDifficulties)) {\\n      if (total === 1) {return -1;}\\n      const remainderThree = total % 3;\\n      if (remainderThree === 0) {\\n        totalRoundsToComplete += Math.floor(total / 3);\\n      } else {\\n        totalRoundsToComplete += Math.floor((total / 3)) + 1\\n      }\\n    }\\n    return totalRoundsToComplete;\\n};\\n```"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "This was my first Medium level question and I brute forced it without using HashMap in C++, and it was accepted with 1175 ms runtime, lol."
                    }
                ]
            },
            {
                "id": 1855200,
                "content": [
                    {
                        "username": "sachinbaral02",
                        "content": "A medium problem today hmmm.... lemme grab my coffee first\\u2615."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@cswartzell](/cswartzell) Using a sorting method can do it in O(1) space but I don\\'t consider this a big win, since we are also ruining  the original list provided. Regarding time complexity for array vs hashmap. I think this debate will always come in such questions. As a thumb rule I avoid using a hashmap if the values are continuous since there can be an even better solution where we just initialize an array to all zeroes and use it just as a map, but due to memory constraints, it wont be wise to use it when range is >10^6. \\n\\nHaving said that, I don\\'t think this question is about that, it is just a simple question for number theory and any way should be fine so I don\\'t give much significance to \\'Beats %\\' as long as runtime is in sane limits."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Are than any easier mediums than this? I was trying to see what the trick might be... I guess there kind of is one if you note that sorting O(nlogn) for 10^5 is still smaller than 10^9 so sorting solutions are actually faster than hashmap solutions despite the worse Time Complexity. Plus using a sorting method you can do it with O(1) space. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sachin](/sachinbaral02) not really a medium, on the easy side of medium!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "No Need to put a **lot of condition**\\ntake map ...count the freq....check if map contain 1 or not \\nif not then just do `count += ceil(it.second/3.0);` \\nif yes `return -1;`"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@sarpalmadhav](/sarpalmadhav) could you please explain is bit more ."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dhvani](/Knight-03), as pointed out in some other comment, I think `(it.second + 2)/3` is much better than using ceil function as it avoids pointer arithmetic."
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "Think of how to handle 5 & 7 :) That was the step I was missing for my solution."
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "Can someone please post recursive/dp solution? (i know it will give tle but i want to know how can i do using recursion)"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871518370/ bro i did it but it was failing a testcase . you can have a look ."
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "Sort the array of tasks in ascending order.\\nIterate through each task and count how many tasks have the same value.\\nIf there is only one task with a particular value, return -1 since we cannot create any groups of 3 from these tasks.\\nOtherwise, add the number of full groups of 3 that can be created from the tasks with this value to the result.\\nIf there are any remaining tasks that cannot be included in a group of 3, increment the result by 1 to indicate that another round is needed to process these tasks.\\nReturn the total number of rounds needed to process all of the tasks."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "these easy-mid questions are the silence before the storm that LC is going to bring soon"
                    },
                    {
                        "username": "fengvang24",
                        "content": "bro don\\'t rain on my parade"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": ":) kill me"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "The intuition is quite simple, just store freq of elements and then think how to group the freq in 3 or 2 \\nHint: Grouping in 3 would result in lesser rounds"
                    },
                    {
                        "username": "tanayak",
                        "content": "Simple Map based solution\\n```class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        TreeMap<Integer, Integer> difficultyMap = new TreeMap<>();\\n\\n        for(int i = 0; i < tasks.length; i++) {\\n            difficultyMap.put(tasks[i], difficultyMap.getOrDefault(tasks[i], 0) + 1);\\n        }\\n\\n        int count = 0;\\n        while(!difficultyMap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = difficultyMap.firstEntry();\\n            if(entry.getValue() < 2)\\n                return -1;\\n            else if(entry.getValue() == 2 || entry.getValue() == 3) {\\n                count++;\\n                difficultyMap.remove(entry.getKey());\\n            } else {\\n                int value = entry.getValue() - 3;\\n                if(value < 2) {\\n                    value = entry.getValue() - 2;\\n                }\\n                difficultyMap.put(entry.getKey(), value);\\n                count++;\\n            }\\n\\n        }\\n        return count;\\n    }\\n}```"
                    },
                    {
                        "username": "ArianLC",
                        "content": "// Javascript\\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    const totalDifficulties = {};\\n    for (const task of tasks) {\\n      totalDifficulties[task] = (totalDifficulties[task] || 0) + 1;\\n    }\\n    let totalRoundsToComplete = 0;\\n    for (const total of Object.values(totalDifficulties)) {\\n      if (total === 1) {return -1;}\\n      const remainderThree = total % 3;\\n      if (remainderThree === 0) {\\n        totalRoundsToComplete += Math.floor(total / 3);\\n      } else {\\n        totalRoundsToComplete += Math.floor((total / 3)) + 1\\n      }\\n    }\\n    return totalRoundsToComplete;\\n};\\n```"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "This was my first Medium level question and I brute forced it without using HashMap in C++, and it was accepted with 1175 ms runtime, lol."
                    }
                ]
            },
            {
                "id": 1808911,
                "content": [
                    {
                        "username": "sachinbaral02",
                        "content": "A medium problem today hmmm.... lemme grab my coffee first\\u2615."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@cswartzell](/cswartzell) Using a sorting method can do it in O(1) space but I don\\'t consider this a big win, since we are also ruining  the original list provided. Regarding time complexity for array vs hashmap. I think this debate will always come in such questions. As a thumb rule I avoid using a hashmap if the values are continuous since there can be an even better solution where we just initialize an array to all zeroes and use it just as a map, but due to memory constraints, it wont be wise to use it when range is >10^6. \\n\\nHaving said that, I don\\'t think this question is about that, it is just a simple question for number theory and any way should be fine so I don\\'t give much significance to \\'Beats %\\' as long as runtime is in sane limits."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Are than any easier mediums than this? I was trying to see what the trick might be... I guess there kind of is one if you note that sorting O(nlogn) for 10^5 is still smaller than 10^9 so sorting solutions are actually faster than hashmap solutions despite the worse Time Complexity. Plus using a sorting method you can do it with O(1) space. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sachin](/sachinbaral02) not really a medium, on the easy side of medium!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "No Need to put a **lot of condition**\\ntake map ...count the freq....check if map contain 1 or not \\nif not then just do `count += ceil(it.second/3.0);` \\nif yes `return -1;`"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@sarpalmadhav](/sarpalmadhav) could you please explain is bit more ."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dhvani](/Knight-03), as pointed out in some other comment, I think `(it.second + 2)/3` is much better than using ceil function as it avoids pointer arithmetic."
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "Think of how to handle 5 & 7 :) That was the step I was missing for my solution."
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "Can someone please post recursive/dp solution? (i know it will give tle but i want to know how can i do using recursion)"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871518370/ bro i did it but it was failing a testcase . you can have a look ."
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "Sort the array of tasks in ascending order.\\nIterate through each task and count how many tasks have the same value.\\nIf there is only one task with a particular value, return -1 since we cannot create any groups of 3 from these tasks.\\nOtherwise, add the number of full groups of 3 that can be created from the tasks with this value to the result.\\nIf there are any remaining tasks that cannot be included in a group of 3, increment the result by 1 to indicate that another round is needed to process these tasks.\\nReturn the total number of rounds needed to process all of the tasks."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "these easy-mid questions are the silence before the storm that LC is going to bring soon"
                    },
                    {
                        "username": "fengvang24",
                        "content": "bro don\\'t rain on my parade"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": ":) kill me"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "The intuition is quite simple, just store freq of elements and then think how to group the freq in 3 or 2 \\nHint: Grouping in 3 would result in lesser rounds"
                    },
                    {
                        "username": "tanayak",
                        "content": "Simple Map based solution\\n```class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        TreeMap<Integer, Integer> difficultyMap = new TreeMap<>();\\n\\n        for(int i = 0; i < tasks.length; i++) {\\n            difficultyMap.put(tasks[i], difficultyMap.getOrDefault(tasks[i], 0) + 1);\\n        }\\n\\n        int count = 0;\\n        while(!difficultyMap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = difficultyMap.firstEntry();\\n            if(entry.getValue() < 2)\\n                return -1;\\n            else if(entry.getValue() == 2 || entry.getValue() == 3) {\\n                count++;\\n                difficultyMap.remove(entry.getKey());\\n            } else {\\n                int value = entry.getValue() - 3;\\n                if(value < 2) {\\n                    value = entry.getValue() - 2;\\n                }\\n                difficultyMap.put(entry.getKey(), value);\\n                count++;\\n            }\\n\\n        }\\n        return count;\\n    }\\n}```"
                    },
                    {
                        "username": "ArianLC",
                        "content": "// Javascript\\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    const totalDifficulties = {};\\n    for (const task of tasks) {\\n      totalDifficulties[task] = (totalDifficulties[task] || 0) + 1;\\n    }\\n    let totalRoundsToComplete = 0;\\n    for (const total of Object.values(totalDifficulties)) {\\n      if (total === 1) {return -1;}\\n      const remainderThree = total % 3;\\n      if (remainderThree === 0) {\\n        totalRoundsToComplete += Math.floor(total / 3);\\n      } else {\\n        totalRoundsToComplete += Math.floor((total / 3)) + 1\\n      }\\n    }\\n    return totalRoundsToComplete;\\n};\\n```"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "This was my first Medium level question and I brute forced it without using HashMap in C++, and it was accepted with 1175 ms runtime, lol."
                    }
                ]
            },
            {
                "id": 1745387,
                "content": [
                    {
                        "username": "sachinbaral02",
                        "content": "A medium problem today hmmm.... lemme grab my coffee first\\u2615."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@cswartzell](/cswartzell) Using a sorting method can do it in O(1) space but I don\\'t consider this a big win, since we are also ruining  the original list provided. Regarding time complexity for array vs hashmap. I think this debate will always come in such questions. As a thumb rule I avoid using a hashmap if the values are continuous since there can be an even better solution where we just initialize an array to all zeroes and use it just as a map, but due to memory constraints, it wont be wise to use it when range is >10^6. \\n\\nHaving said that, I don\\'t think this question is about that, it is just a simple question for number theory and any way should be fine so I don\\'t give much significance to \\'Beats %\\' as long as runtime is in sane limits."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Are than any easier mediums than this? I was trying to see what the trick might be... I guess there kind of is one if you note that sorting O(nlogn) for 10^5 is still smaller than 10^9 so sorting solutions are actually faster than hashmap solutions despite the worse Time Complexity. Plus using a sorting method you can do it with O(1) space. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sachin](/sachinbaral02) not really a medium, on the easy side of medium!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "No Need to put a **lot of condition**\\ntake map ...count the freq....check if map contain 1 or not \\nif not then just do `count += ceil(it.second/3.0);` \\nif yes `return -1;`"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@sarpalmadhav](/sarpalmadhav) could you please explain is bit more ."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dhvani](/Knight-03), as pointed out in some other comment, I think `(it.second + 2)/3` is much better than using ceil function as it avoids pointer arithmetic."
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "Think of how to handle 5 & 7 :) That was the step I was missing for my solution."
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "Can someone please post recursive/dp solution? (i know it will give tle but i want to know how can i do using recursion)"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871518370/ bro i did it but it was failing a testcase . you can have a look ."
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "Sort the array of tasks in ascending order.\\nIterate through each task and count how many tasks have the same value.\\nIf there is only one task with a particular value, return -1 since we cannot create any groups of 3 from these tasks.\\nOtherwise, add the number of full groups of 3 that can be created from the tasks with this value to the result.\\nIf there are any remaining tasks that cannot be included in a group of 3, increment the result by 1 to indicate that another round is needed to process these tasks.\\nReturn the total number of rounds needed to process all of the tasks."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "these easy-mid questions are the silence before the storm that LC is going to bring soon"
                    },
                    {
                        "username": "fengvang24",
                        "content": "bro don\\'t rain on my parade"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": ":) kill me"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "The intuition is quite simple, just store freq of elements and then think how to group the freq in 3 or 2 \\nHint: Grouping in 3 would result in lesser rounds"
                    },
                    {
                        "username": "tanayak",
                        "content": "Simple Map based solution\\n```class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        TreeMap<Integer, Integer> difficultyMap = new TreeMap<>();\\n\\n        for(int i = 0; i < tasks.length; i++) {\\n            difficultyMap.put(tasks[i], difficultyMap.getOrDefault(tasks[i], 0) + 1);\\n        }\\n\\n        int count = 0;\\n        while(!difficultyMap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = difficultyMap.firstEntry();\\n            if(entry.getValue() < 2)\\n                return -1;\\n            else if(entry.getValue() == 2 || entry.getValue() == 3) {\\n                count++;\\n                difficultyMap.remove(entry.getKey());\\n            } else {\\n                int value = entry.getValue() - 3;\\n                if(value < 2) {\\n                    value = entry.getValue() - 2;\\n                }\\n                difficultyMap.put(entry.getKey(), value);\\n                count++;\\n            }\\n\\n        }\\n        return count;\\n    }\\n}```"
                    },
                    {
                        "username": "ArianLC",
                        "content": "// Javascript\\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    const totalDifficulties = {};\\n    for (const task of tasks) {\\n      totalDifficulties[task] = (totalDifficulties[task] || 0) + 1;\\n    }\\n    let totalRoundsToComplete = 0;\\n    for (const total of Object.values(totalDifficulties)) {\\n      if (total === 1) {return -1;}\\n      const remainderThree = total % 3;\\n      if (remainderThree === 0) {\\n        totalRoundsToComplete += Math.floor(total / 3);\\n      } else {\\n        totalRoundsToComplete += Math.floor((total / 3)) + 1\\n      }\\n    }\\n    return totalRoundsToComplete;\\n};\\n```"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "This was my first Medium level question and I brute forced it without using HashMap in C++, and it was accepted with 1175 ms runtime, lol."
                    }
                ]
            },
            {
                "id": 1742018,
                "content": [
                    {
                        "username": "aminuolawale",
                        "content": "Well you only need to realise that \\n1. If an element occurs only once, the condition is violated\\n2. tasks of any difficulty level takes `ceil(no_occurences/3)` rounds.\\nWith this you have your solution."
                    },
                    {
                        "username": "user4037uh",
                        "content": "my 71st testcase is showing time limit exceeded can someone help its my 1st weeek on leetcode"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "same here, although mine was 75/79 case. I brute forced it by adding a loop counter. if the no. of loop exceeds 500, just print length of vector divided by count. The reason this worked is because my base logic was correct but slow and the later test cases had same count of occurrences for each task.  "
                    },
                    {
                        "username": "omi23",
                        "content": "Easiest medium questions I have ever seen."
                    },
                    {
                        "username": "MrSlend",
                        "content": "I keep getting time exceeded error when testing about 50,000 cases. Can anyone tell me what\\'s wrong?\\n\\nclass Solution {\\n    fun minimumRounds(tasks: IntArray):Int {\\n        var size = tasks.size;\\n        var arr = ArrayList<Int>();\\n        var store = 0;\\n        var result = 0;\\n        tasks.sort(); //sorts the array\\n\\n        for(i in 0..size-1){\\n            if(!arr.contains(tasks[i])){ \\n                arr.add(tasks[i]);\\n                store = occurences(tasks[i],tasks); //function\\n                if( store == -1) return -1;\\n                else result += store;\\n            }\\n        }\\n        \\n    return result;\\n    }\\n\\n    fun occurences(num:Int, t:IntArray):Int{\\n        var count = 0.0;\\n        for(i in 0..t.size-1){\\n            if(num == t[i])\\n                count++;\\n        }\\n        if (count==1.0)\\n            return -1;\\n        return Math.ceil(count/3.0).toInt();\\n    }\\n}"
                    },
                    {
                        "username": "deepeshsai1312",
                        "content": "i dont understand the question\\n"
                    },
                    {
                        "username": "rambabu135",
                        "content": "at first I filled whole my code with if else conditions.\\nat last I wrote for answers  for occurances from 1 to 16.\\nAnd magically I found the pattern. \\nThis question shows that pen and paper are really important while solving question even if you don\\'t know anything about question\\nstart writing the things on paper and question starts breaking into chunks."
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "    int minimumRounds(vector<int>& tasks) {\n        map<int,int>mp;\n        for(auto e : tasks) {\n            mp[e]++;\n        }\n        int counter=0;\n        for(auto p : mp){\n            if(p.second==1) return -1;\n            counter+=(p.second/3) + (bool)(p.second%3);\n        }\n        return counter;\n    }"
                    },
                    {
                        "username": "user3904Q",
                        "content": "For count(task[i]) % 3 == 2 and count(task[i]) % 3 == 1 the result is same, count//3 + 1 so :\\n\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        counter = collections.Counter(tasks)\\n        ans = 0\\n        for k in counter:\\n            count = counter[k]\\n            if count < 2:\\n                return - 1\\n            if count % 3 == 0:\\n                ans += count//3\\n            else:\\n                ans += count//3 + 1\\n        return ans \\n                \\n\\n"
                    },
                    {
                        "username": "imankitg",
                        "content": "Me: Solved medium-level question in under 10 minutes\\nOthers comment: This should be an easy question"
                    },
                    {
                        "username": "adarsh301998",
                        "content": "Golang (O)N \\n `func minimumRounds(tasks []int) int {\\n    count := map[int]int{}\\n    for _, v := range tasks {\\n        data, ok := count[v]\\n        if ok {\\n            data++\\n        }else {\\n            data = 1\\n        }\\n        count[v] = data\\n    }\\n    round := 0\\n    fmt.Println(\"1\", count)\\n    for _, v := range count {\\n        if v == 1 {\\n            return -1\\n        }\\n        round += (v/3)\\n        if v%3 != 0 {\\n            round++\\n        }\\n    }\\n    return round\\n}`"
                    }
                ]
            },
            {
                "id": 1741993,
                "content": [
                    {
                        "username": "aminuolawale",
                        "content": "Well you only need to realise that \\n1. If an element occurs only once, the condition is violated\\n2. tasks of any difficulty level takes `ceil(no_occurences/3)` rounds.\\nWith this you have your solution."
                    },
                    {
                        "username": "user4037uh",
                        "content": "my 71st testcase is showing time limit exceeded can someone help its my 1st weeek on leetcode"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "same here, although mine was 75/79 case. I brute forced it by adding a loop counter. if the no. of loop exceeds 500, just print length of vector divided by count. The reason this worked is because my base logic was correct but slow and the later test cases had same count of occurrences for each task.  "
                    },
                    {
                        "username": "omi23",
                        "content": "Easiest medium questions I have ever seen."
                    },
                    {
                        "username": "MrSlend",
                        "content": "I keep getting time exceeded error when testing about 50,000 cases. Can anyone tell me what\\'s wrong?\\n\\nclass Solution {\\n    fun minimumRounds(tasks: IntArray):Int {\\n        var size = tasks.size;\\n        var arr = ArrayList<Int>();\\n        var store = 0;\\n        var result = 0;\\n        tasks.sort(); //sorts the array\\n\\n        for(i in 0..size-1){\\n            if(!arr.contains(tasks[i])){ \\n                arr.add(tasks[i]);\\n                store = occurences(tasks[i],tasks); //function\\n                if( store == -1) return -1;\\n                else result += store;\\n            }\\n        }\\n        \\n    return result;\\n    }\\n\\n    fun occurences(num:Int, t:IntArray):Int{\\n        var count = 0.0;\\n        for(i in 0..t.size-1){\\n            if(num == t[i])\\n                count++;\\n        }\\n        if (count==1.0)\\n            return -1;\\n        return Math.ceil(count/3.0).toInt();\\n    }\\n}"
                    },
                    {
                        "username": "deepeshsai1312",
                        "content": "i dont understand the question\\n"
                    },
                    {
                        "username": "rambabu135",
                        "content": "at first I filled whole my code with if else conditions.\\nat last I wrote for answers  for occurances from 1 to 16.\\nAnd magically I found the pattern. \\nThis question shows that pen and paper are really important while solving question even if you don\\'t know anything about question\\nstart writing the things on paper and question starts breaking into chunks."
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "    int minimumRounds(vector<int>& tasks) {\n        map<int,int>mp;\n        for(auto e : tasks) {\n            mp[e]++;\n        }\n        int counter=0;\n        for(auto p : mp){\n            if(p.second==1) return -1;\n            counter+=(p.second/3) + (bool)(p.second%3);\n        }\n        return counter;\n    }"
                    },
                    {
                        "username": "user3904Q",
                        "content": "For count(task[i]) % 3 == 2 and count(task[i]) % 3 == 1 the result is same, count//3 + 1 so :\\n\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        counter = collections.Counter(tasks)\\n        ans = 0\\n        for k in counter:\\n            count = counter[k]\\n            if count < 2:\\n                return - 1\\n            if count % 3 == 0:\\n                ans += count//3\\n            else:\\n                ans += count//3 + 1\\n        return ans \\n                \\n\\n"
                    },
                    {
                        "username": "imankitg",
                        "content": "Me: Solved medium-level question in under 10 minutes\\nOthers comment: This should be an easy question"
                    },
                    {
                        "username": "adarsh301998",
                        "content": "Golang (O)N \\n `func minimumRounds(tasks []int) int {\\n    count := map[int]int{}\\n    for _, v := range tasks {\\n        data, ok := count[v]\\n        if ok {\\n            data++\\n        }else {\\n            data = 1\\n        }\\n        count[v] = data\\n    }\\n    round := 0\\n    fmt.Println(\"1\", count)\\n    for _, v := range count {\\n        if v == 1 {\\n            return -1\\n        }\\n        round += (v/3)\\n        if v%3 != 0 {\\n            round++\\n        }\\n    }\\n    return round\\n}`"
                    }
                ]
            },
            {
                "id": 1741886,
                "content": [
                    {
                        "username": "aminuolawale",
                        "content": "Well you only need to realise that \\n1. If an element occurs only once, the condition is violated\\n2. tasks of any difficulty level takes `ceil(no_occurences/3)` rounds.\\nWith this you have your solution."
                    },
                    {
                        "username": "user4037uh",
                        "content": "my 71st testcase is showing time limit exceeded can someone help its my 1st weeek on leetcode"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "same here, although mine was 75/79 case. I brute forced it by adding a loop counter. if the no. of loop exceeds 500, just print length of vector divided by count. The reason this worked is because my base logic was correct but slow and the later test cases had same count of occurrences for each task.  "
                    },
                    {
                        "username": "omi23",
                        "content": "Easiest medium questions I have ever seen."
                    },
                    {
                        "username": "MrSlend",
                        "content": "I keep getting time exceeded error when testing about 50,000 cases. Can anyone tell me what\\'s wrong?\\n\\nclass Solution {\\n    fun minimumRounds(tasks: IntArray):Int {\\n        var size = tasks.size;\\n        var arr = ArrayList<Int>();\\n        var store = 0;\\n        var result = 0;\\n        tasks.sort(); //sorts the array\\n\\n        for(i in 0..size-1){\\n            if(!arr.contains(tasks[i])){ \\n                arr.add(tasks[i]);\\n                store = occurences(tasks[i],tasks); //function\\n                if( store == -1) return -1;\\n                else result += store;\\n            }\\n        }\\n        \\n    return result;\\n    }\\n\\n    fun occurences(num:Int, t:IntArray):Int{\\n        var count = 0.0;\\n        for(i in 0..t.size-1){\\n            if(num == t[i])\\n                count++;\\n        }\\n        if (count==1.0)\\n            return -1;\\n        return Math.ceil(count/3.0).toInt();\\n    }\\n}"
                    },
                    {
                        "username": "deepeshsai1312",
                        "content": "i dont understand the question\\n"
                    },
                    {
                        "username": "rambabu135",
                        "content": "at first I filled whole my code with if else conditions.\\nat last I wrote for answers  for occurances from 1 to 16.\\nAnd magically I found the pattern. \\nThis question shows that pen and paper are really important while solving question even if you don\\'t know anything about question\\nstart writing the things on paper and question starts breaking into chunks."
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "    int minimumRounds(vector<int>& tasks) {\n        map<int,int>mp;\n        for(auto e : tasks) {\n            mp[e]++;\n        }\n        int counter=0;\n        for(auto p : mp){\n            if(p.second==1) return -1;\n            counter+=(p.second/3) + (bool)(p.second%3);\n        }\n        return counter;\n    }"
                    },
                    {
                        "username": "user3904Q",
                        "content": "For count(task[i]) % 3 == 2 and count(task[i]) % 3 == 1 the result is same, count//3 + 1 so :\\n\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        counter = collections.Counter(tasks)\\n        ans = 0\\n        for k in counter:\\n            count = counter[k]\\n            if count < 2:\\n                return - 1\\n            if count % 3 == 0:\\n                ans += count//3\\n            else:\\n                ans += count//3 + 1\\n        return ans \\n                \\n\\n"
                    },
                    {
                        "username": "imankitg",
                        "content": "Me: Solved medium-level question in under 10 minutes\\nOthers comment: This should be an easy question"
                    },
                    {
                        "username": "adarsh301998",
                        "content": "Golang (O)N \\n `func minimumRounds(tasks []int) int {\\n    count := map[int]int{}\\n    for _, v := range tasks {\\n        data, ok := count[v]\\n        if ok {\\n            data++\\n        }else {\\n            data = 1\\n        }\\n        count[v] = data\\n    }\\n    round := 0\\n    fmt.Println(\"1\", count)\\n    for _, v := range count {\\n        if v == 1 {\\n            return -1\\n        }\\n        round += (v/3)\\n        if v%3 != 0 {\\n            round++\\n        }\\n    }\\n    return round\\n}`"
                    }
                ]
            },
            {
                "id": 1741769,
                "content": [
                    {
                        "username": "aminuolawale",
                        "content": "Well you only need to realise that \\n1. If an element occurs only once, the condition is violated\\n2. tasks of any difficulty level takes `ceil(no_occurences/3)` rounds.\\nWith this you have your solution."
                    },
                    {
                        "username": "user4037uh",
                        "content": "my 71st testcase is showing time limit exceeded can someone help its my 1st weeek on leetcode"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "same here, although mine was 75/79 case. I brute forced it by adding a loop counter. if the no. of loop exceeds 500, just print length of vector divided by count. The reason this worked is because my base logic was correct but slow and the later test cases had same count of occurrences for each task.  "
                    },
                    {
                        "username": "omi23",
                        "content": "Easiest medium questions I have ever seen."
                    },
                    {
                        "username": "MrSlend",
                        "content": "I keep getting time exceeded error when testing about 50,000 cases. Can anyone tell me what\\'s wrong?\\n\\nclass Solution {\\n    fun minimumRounds(tasks: IntArray):Int {\\n        var size = tasks.size;\\n        var arr = ArrayList<Int>();\\n        var store = 0;\\n        var result = 0;\\n        tasks.sort(); //sorts the array\\n\\n        for(i in 0..size-1){\\n            if(!arr.contains(tasks[i])){ \\n                arr.add(tasks[i]);\\n                store = occurences(tasks[i],tasks); //function\\n                if( store == -1) return -1;\\n                else result += store;\\n            }\\n        }\\n        \\n    return result;\\n    }\\n\\n    fun occurences(num:Int, t:IntArray):Int{\\n        var count = 0.0;\\n        for(i in 0..t.size-1){\\n            if(num == t[i])\\n                count++;\\n        }\\n        if (count==1.0)\\n            return -1;\\n        return Math.ceil(count/3.0).toInt();\\n    }\\n}"
                    },
                    {
                        "username": "deepeshsai1312",
                        "content": "i dont understand the question\\n"
                    },
                    {
                        "username": "rambabu135",
                        "content": "at first I filled whole my code with if else conditions.\\nat last I wrote for answers  for occurances from 1 to 16.\\nAnd magically I found the pattern. \\nThis question shows that pen and paper are really important while solving question even if you don\\'t know anything about question\\nstart writing the things on paper and question starts breaking into chunks."
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "    int minimumRounds(vector<int>& tasks) {\n        map<int,int>mp;\n        for(auto e : tasks) {\n            mp[e]++;\n        }\n        int counter=0;\n        for(auto p : mp){\n            if(p.second==1) return -1;\n            counter+=(p.second/3) + (bool)(p.second%3);\n        }\n        return counter;\n    }"
                    },
                    {
                        "username": "user3904Q",
                        "content": "For count(task[i]) % 3 == 2 and count(task[i]) % 3 == 1 the result is same, count//3 + 1 so :\\n\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        counter = collections.Counter(tasks)\\n        ans = 0\\n        for k in counter:\\n            count = counter[k]\\n            if count < 2:\\n                return - 1\\n            if count % 3 == 0:\\n                ans += count//3\\n            else:\\n                ans += count//3 + 1\\n        return ans \\n                \\n\\n"
                    },
                    {
                        "username": "imankitg",
                        "content": "Me: Solved medium-level question in under 10 minutes\\nOthers comment: This should be an easy question"
                    },
                    {
                        "username": "adarsh301998",
                        "content": "Golang (O)N \\n `func minimumRounds(tasks []int) int {\\n    count := map[int]int{}\\n    for _, v := range tasks {\\n        data, ok := count[v]\\n        if ok {\\n            data++\\n        }else {\\n            data = 1\\n        }\\n        count[v] = data\\n    }\\n    round := 0\\n    fmt.Println(\"1\", count)\\n    for _, v := range count {\\n        if v == 1 {\\n            return -1\\n        }\\n        round += (v/3)\\n        if v%3 != 0 {\\n            round++\\n        }\\n    }\\n    return round\\n}`"
                    }
                ]
            },
            {
                "id": 1741740,
                "content": [
                    {
                        "username": "aminuolawale",
                        "content": "Well you only need to realise that \\n1. If an element occurs only once, the condition is violated\\n2. tasks of any difficulty level takes `ceil(no_occurences/3)` rounds.\\nWith this you have your solution."
                    },
                    {
                        "username": "user4037uh",
                        "content": "my 71st testcase is showing time limit exceeded can someone help its my 1st weeek on leetcode"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "same here, although mine was 75/79 case. I brute forced it by adding a loop counter. if the no. of loop exceeds 500, just print length of vector divided by count. The reason this worked is because my base logic was correct but slow and the later test cases had same count of occurrences for each task.  "
                    },
                    {
                        "username": "omi23",
                        "content": "Easiest medium questions I have ever seen."
                    },
                    {
                        "username": "MrSlend",
                        "content": "I keep getting time exceeded error when testing about 50,000 cases. Can anyone tell me what\\'s wrong?\\n\\nclass Solution {\\n    fun minimumRounds(tasks: IntArray):Int {\\n        var size = tasks.size;\\n        var arr = ArrayList<Int>();\\n        var store = 0;\\n        var result = 0;\\n        tasks.sort(); //sorts the array\\n\\n        for(i in 0..size-1){\\n            if(!arr.contains(tasks[i])){ \\n                arr.add(tasks[i]);\\n                store = occurences(tasks[i],tasks); //function\\n                if( store == -1) return -1;\\n                else result += store;\\n            }\\n        }\\n        \\n    return result;\\n    }\\n\\n    fun occurences(num:Int, t:IntArray):Int{\\n        var count = 0.0;\\n        for(i in 0..t.size-1){\\n            if(num == t[i])\\n                count++;\\n        }\\n        if (count==1.0)\\n            return -1;\\n        return Math.ceil(count/3.0).toInt();\\n    }\\n}"
                    },
                    {
                        "username": "deepeshsai1312",
                        "content": "i dont understand the question\\n"
                    },
                    {
                        "username": "rambabu135",
                        "content": "at first I filled whole my code with if else conditions.\\nat last I wrote for answers  for occurances from 1 to 16.\\nAnd magically I found the pattern. \\nThis question shows that pen and paper are really important while solving question even if you don\\'t know anything about question\\nstart writing the things on paper and question starts breaking into chunks."
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "    int minimumRounds(vector<int>& tasks) {\n        map<int,int>mp;\n        for(auto e : tasks) {\n            mp[e]++;\n        }\n        int counter=0;\n        for(auto p : mp){\n            if(p.second==1) return -1;\n            counter+=(p.second/3) + (bool)(p.second%3);\n        }\n        return counter;\n    }"
                    },
                    {
                        "username": "user3904Q",
                        "content": "For count(task[i]) % 3 == 2 and count(task[i]) % 3 == 1 the result is same, count//3 + 1 so :\\n\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        counter = collections.Counter(tasks)\\n        ans = 0\\n        for k in counter:\\n            count = counter[k]\\n            if count < 2:\\n                return - 1\\n            if count % 3 == 0:\\n                ans += count//3\\n            else:\\n                ans += count//3 + 1\\n        return ans \\n                \\n\\n"
                    },
                    {
                        "username": "imankitg",
                        "content": "Me: Solved medium-level question in under 10 minutes\\nOthers comment: This should be an easy question"
                    },
                    {
                        "username": "adarsh301998",
                        "content": "Golang (O)N \\n `func minimumRounds(tasks []int) int {\\n    count := map[int]int{}\\n    for _, v := range tasks {\\n        data, ok := count[v]\\n        if ok {\\n            data++\\n        }else {\\n            data = 1\\n        }\\n        count[v] = data\\n    }\\n    round := 0\\n    fmt.Println(\"1\", count)\\n    for _, v := range count {\\n        if v == 1 {\\n            return -1\\n        }\\n        round += (v/3)\\n        if v%3 != 0 {\\n            round++\\n        }\\n    }\\n    return round\\n}`"
                    }
                ]
            },
            {
                "id": 1741651,
                "content": [
                    {
                        "username": "aminuolawale",
                        "content": "Well you only need to realise that \\n1. If an element occurs only once, the condition is violated\\n2. tasks of any difficulty level takes `ceil(no_occurences/3)` rounds.\\nWith this you have your solution."
                    },
                    {
                        "username": "user4037uh",
                        "content": "my 71st testcase is showing time limit exceeded can someone help its my 1st weeek on leetcode"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "same here, although mine was 75/79 case. I brute forced it by adding a loop counter. if the no. of loop exceeds 500, just print length of vector divided by count. The reason this worked is because my base logic was correct but slow and the later test cases had same count of occurrences for each task.  "
                    },
                    {
                        "username": "omi23",
                        "content": "Easiest medium questions I have ever seen."
                    },
                    {
                        "username": "MrSlend",
                        "content": "I keep getting time exceeded error when testing about 50,000 cases. Can anyone tell me what\\'s wrong?\\n\\nclass Solution {\\n    fun minimumRounds(tasks: IntArray):Int {\\n        var size = tasks.size;\\n        var arr = ArrayList<Int>();\\n        var store = 0;\\n        var result = 0;\\n        tasks.sort(); //sorts the array\\n\\n        for(i in 0..size-1){\\n            if(!arr.contains(tasks[i])){ \\n                arr.add(tasks[i]);\\n                store = occurences(tasks[i],tasks); //function\\n                if( store == -1) return -1;\\n                else result += store;\\n            }\\n        }\\n        \\n    return result;\\n    }\\n\\n    fun occurences(num:Int, t:IntArray):Int{\\n        var count = 0.0;\\n        for(i in 0..t.size-1){\\n            if(num == t[i])\\n                count++;\\n        }\\n        if (count==1.0)\\n            return -1;\\n        return Math.ceil(count/3.0).toInt();\\n    }\\n}"
                    },
                    {
                        "username": "deepeshsai1312",
                        "content": "i dont understand the question\\n"
                    },
                    {
                        "username": "rambabu135",
                        "content": "at first I filled whole my code with if else conditions.\\nat last I wrote for answers  for occurances from 1 to 16.\\nAnd magically I found the pattern. \\nThis question shows that pen and paper are really important while solving question even if you don\\'t know anything about question\\nstart writing the things on paper and question starts breaking into chunks."
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "    int minimumRounds(vector<int>& tasks) {\n        map<int,int>mp;\n        for(auto e : tasks) {\n            mp[e]++;\n        }\n        int counter=0;\n        for(auto p : mp){\n            if(p.second==1) return -1;\n            counter+=(p.second/3) + (bool)(p.second%3);\n        }\n        return counter;\n    }"
                    },
                    {
                        "username": "user3904Q",
                        "content": "For count(task[i]) % 3 == 2 and count(task[i]) % 3 == 1 the result is same, count//3 + 1 so :\\n\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        counter = collections.Counter(tasks)\\n        ans = 0\\n        for k in counter:\\n            count = counter[k]\\n            if count < 2:\\n                return - 1\\n            if count % 3 == 0:\\n                ans += count//3\\n            else:\\n                ans += count//3 + 1\\n        return ans \\n                \\n\\n"
                    },
                    {
                        "username": "imankitg",
                        "content": "Me: Solved medium-level question in under 10 minutes\\nOthers comment: This should be an easy question"
                    },
                    {
                        "username": "adarsh301998",
                        "content": "Golang (O)N \\n `func minimumRounds(tasks []int) int {\\n    count := map[int]int{}\\n    for _, v := range tasks {\\n        data, ok := count[v]\\n        if ok {\\n            data++\\n        }else {\\n            data = 1\\n        }\\n        count[v] = data\\n    }\\n    round := 0\\n    fmt.Println(\"1\", count)\\n    for _, v := range count {\\n        if v == 1 {\\n            return -1\\n        }\\n        round += (v/3)\\n        if v%3 != 0 {\\n            round++\\n        }\\n    }\\n    return round\\n}`"
                    }
                ]
            },
            {
                "id": 1741602,
                "content": [
                    {
                        "username": "aminuolawale",
                        "content": "Well you only need to realise that \\n1. If an element occurs only once, the condition is violated\\n2. tasks of any difficulty level takes `ceil(no_occurences/3)` rounds.\\nWith this you have your solution."
                    },
                    {
                        "username": "user4037uh",
                        "content": "my 71st testcase is showing time limit exceeded can someone help its my 1st weeek on leetcode"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "same here, although mine was 75/79 case. I brute forced it by adding a loop counter. if the no. of loop exceeds 500, just print length of vector divided by count. The reason this worked is because my base logic was correct but slow and the later test cases had same count of occurrences for each task.  "
                    },
                    {
                        "username": "omi23",
                        "content": "Easiest medium questions I have ever seen."
                    },
                    {
                        "username": "MrSlend",
                        "content": "I keep getting time exceeded error when testing about 50,000 cases. Can anyone tell me what\\'s wrong?\\n\\nclass Solution {\\n    fun minimumRounds(tasks: IntArray):Int {\\n        var size = tasks.size;\\n        var arr = ArrayList<Int>();\\n        var store = 0;\\n        var result = 0;\\n        tasks.sort(); //sorts the array\\n\\n        for(i in 0..size-1){\\n            if(!arr.contains(tasks[i])){ \\n                arr.add(tasks[i]);\\n                store = occurences(tasks[i],tasks); //function\\n                if( store == -1) return -1;\\n                else result += store;\\n            }\\n        }\\n        \\n    return result;\\n    }\\n\\n    fun occurences(num:Int, t:IntArray):Int{\\n        var count = 0.0;\\n        for(i in 0..t.size-1){\\n            if(num == t[i])\\n                count++;\\n        }\\n        if (count==1.0)\\n            return -1;\\n        return Math.ceil(count/3.0).toInt();\\n    }\\n}"
                    },
                    {
                        "username": "deepeshsai1312",
                        "content": "i dont understand the question\\n"
                    },
                    {
                        "username": "rambabu135",
                        "content": "at first I filled whole my code with if else conditions.\\nat last I wrote for answers  for occurances from 1 to 16.\\nAnd magically I found the pattern. \\nThis question shows that pen and paper are really important while solving question even if you don\\'t know anything about question\\nstart writing the things on paper and question starts breaking into chunks."
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "    int minimumRounds(vector<int>& tasks) {\n        map<int,int>mp;\n        for(auto e : tasks) {\n            mp[e]++;\n        }\n        int counter=0;\n        for(auto p : mp){\n            if(p.second==1) return -1;\n            counter+=(p.second/3) + (bool)(p.second%3);\n        }\n        return counter;\n    }"
                    },
                    {
                        "username": "user3904Q",
                        "content": "For count(task[i]) % 3 == 2 and count(task[i]) % 3 == 1 the result is same, count//3 + 1 so :\\n\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        counter = collections.Counter(tasks)\\n        ans = 0\\n        for k in counter:\\n            count = counter[k]\\n            if count < 2:\\n                return - 1\\n            if count % 3 == 0:\\n                ans += count//3\\n            else:\\n                ans += count//3 + 1\\n        return ans \\n                \\n\\n"
                    },
                    {
                        "username": "imankitg",
                        "content": "Me: Solved medium-level question in under 10 minutes\\nOthers comment: This should be an easy question"
                    },
                    {
                        "username": "adarsh301998",
                        "content": "Golang (O)N \\n `func minimumRounds(tasks []int) int {\\n    count := map[int]int{}\\n    for _, v := range tasks {\\n        data, ok := count[v]\\n        if ok {\\n            data++\\n        }else {\\n            data = 1\\n        }\\n        count[v] = data\\n    }\\n    round := 0\\n    fmt.Println(\"1\", count)\\n    for _, v := range count {\\n        if v == 1 {\\n            return -1\\n        }\\n        round += (v/3)\\n        if v%3 != 0 {\\n            round++\\n        }\\n    }\\n    return round\\n}`"
                    }
                ]
            },
            {
                "id": 1741581,
                "content": [
                    {
                        "username": "aminuolawale",
                        "content": "Well you only need to realise that \\n1. If an element occurs only once, the condition is violated\\n2. tasks of any difficulty level takes `ceil(no_occurences/3)` rounds.\\nWith this you have your solution."
                    },
                    {
                        "username": "user4037uh",
                        "content": "my 71st testcase is showing time limit exceeded can someone help its my 1st weeek on leetcode"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "same here, although mine was 75/79 case. I brute forced it by adding a loop counter. if the no. of loop exceeds 500, just print length of vector divided by count. The reason this worked is because my base logic was correct but slow and the later test cases had same count of occurrences for each task.  "
                    },
                    {
                        "username": "omi23",
                        "content": "Easiest medium questions I have ever seen."
                    },
                    {
                        "username": "MrSlend",
                        "content": "I keep getting time exceeded error when testing about 50,000 cases. Can anyone tell me what\\'s wrong?\\n\\nclass Solution {\\n    fun minimumRounds(tasks: IntArray):Int {\\n        var size = tasks.size;\\n        var arr = ArrayList<Int>();\\n        var store = 0;\\n        var result = 0;\\n        tasks.sort(); //sorts the array\\n\\n        for(i in 0..size-1){\\n            if(!arr.contains(tasks[i])){ \\n                arr.add(tasks[i]);\\n                store = occurences(tasks[i],tasks); //function\\n                if( store == -1) return -1;\\n                else result += store;\\n            }\\n        }\\n        \\n    return result;\\n    }\\n\\n    fun occurences(num:Int, t:IntArray):Int{\\n        var count = 0.0;\\n        for(i in 0..t.size-1){\\n            if(num == t[i])\\n                count++;\\n        }\\n        if (count==1.0)\\n            return -1;\\n        return Math.ceil(count/3.0).toInt();\\n    }\\n}"
                    },
                    {
                        "username": "deepeshsai1312",
                        "content": "i dont understand the question\\n"
                    },
                    {
                        "username": "rambabu135",
                        "content": "at first I filled whole my code with if else conditions.\\nat last I wrote for answers  for occurances from 1 to 16.\\nAnd magically I found the pattern. \\nThis question shows that pen and paper are really important while solving question even if you don\\'t know anything about question\\nstart writing the things on paper and question starts breaking into chunks."
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "    int minimumRounds(vector<int>& tasks) {\n        map<int,int>mp;\n        for(auto e : tasks) {\n            mp[e]++;\n        }\n        int counter=0;\n        for(auto p : mp){\n            if(p.second==1) return -1;\n            counter+=(p.second/3) + (bool)(p.second%3);\n        }\n        return counter;\n    }"
                    },
                    {
                        "username": "user3904Q",
                        "content": "For count(task[i]) % 3 == 2 and count(task[i]) % 3 == 1 the result is same, count//3 + 1 so :\\n\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        counter = collections.Counter(tasks)\\n        ans = 0\\n        for k in counter:\\n            count = counter[k]\\n            if count < 2:\\n                return - 1\\n            if count % 3 == 0:\\n                ans += count//3\\n            else:\\n                ans += count//3 + 1\\n        return ans \\n                \\n\\n"
                    },
                    {
                        "username": "imankitg",
                        "content": "Me: Solved medium-level question in under 10 minutes\\nOthers comment: This should be an easy question"
                    },
                    {
                        "username": "adarsh301998",
                        "content": "Golang (O)N \\n `func minimumRounds(tasks []int) int {\\n    count := map[int]int{}\\n    for _, v := range tasks {\\n        data, ok := count[v]\\n        if ok {\\n            data++\\n        }else {\\n            data = 1\\n        }\\n        count[v] = data\\n    }\\n    round := 0\\n    fmt.Println(\"1\", count)\\n    for _, v := range count {\\n        if v == 1 {\\n            return -1\\n        }\\n        round += (v/3)\\n        if v%3 != 0 {\\n            round++\\n        }\\n    }\\n    return round\\n}`"
                    }
                ]
            },
            {
                "id": 1741577,
                "content": [
                    {
                        "username": "aminuolawale",
                        "content": "Well you only need to realise that \\n1. If an element occurs only once, the condition is violated\\n2. tasks of any difficulty level takes `ceil(no_occurences/3)` rounds.\\nWith this you have your solution."
                    },
                    {
                        "username": "user4037uh",
                        "content": "my 71st testcase is showing time limit exceeded can someone help its my 1st weeek on leetcode"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "same here, although mine was 75/79 case. I brute forced it by adding a loop counter. if the no. of loop exceeds 500, just print length of vector divided by count. The reason this worked is because my base logic was correct but slow and the later test cases had same count of occurrences for each task.  "
                    },
                    {
                        "username": "omi23",
                        "content": "Easiest medium questions I have ever seen."
                    },
                    {
                        "username": "MrSlend",
                        "content": "I keep getting time exceeded error when testing about 50,000 cases. Can anyone tell me what\\'s wrong?\\n\\nclass Solution {\\n    fun minimumRounds(tasks: IntArray):Int {\\n        var size = tasks.size;\\n        var arr = ArrayList<Int>();\\n        var store = 0;\\n        var result = 0;\\n        tasks.sort(); //sorts the array\\n\\n        for(i in 0..size-1){\\n            if(!arr.contains(tasks[i])){ \\n                arr.add(tasks[i]);\\n                store = occurences(tasks[i],tasks); //function\\n                if( store == -1) return -1;\\n                else result += store;\\n            }\\n        }\\n        \\n    return result;\\n    }\\n\\n    fun occurences(num:Int, t:IntArray):Int{\\n        var count = 0.0;\\n        for(i in 0..t.size-1){\\n            if(num == t[i])\\n                count++;\\n        }\\n        if (count==1.0)\\n            return -1;\\n        return Math.ceil(count/3.0).toInt();\\n    }\\n}"
                    },
                    {
                        "username": "deepeshsai1312",
                        "content": "i dont understand the question\\n"
                    },
                    {
                        "username": "rambabu135",
                        "content": "at first I filled whole my code with if else conditions.\\nat last I wrote for answers  for occurances from 1 to 16.\\nAnd magically I found the pattern. \\nThis question shows that pen and paper are really important while solving question even if you don\\'t know anything about question\\nstart writing the things on paper and question starts breaking into chunks."
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "    int minimumRounds(vector<int>& tasks) {\n        map<int,int>mp;\n        for(auto e : tasks) {\n            mp[e]++;\n        }\n        int counter=0;\n        for(auto p : mp){\n            if(p.second==1) return -1;\n            counter+=(p.second/3) + (bool)(p.second%3);\n        }\n        return counter;\n    }"
                    },
                    {
                        "username": "user3904Q",
                        "content": "For count(task[i]) % 3 == 2 and count(task[i]) % 3 == 1 the result is same, count//3 + 1 so :\\n\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        counter = collections.Counter(tasks)\\n        ans = 0\\n        for k in counter:\\n            count = counter[k]\\n            if count < 2:\\n                return - 1\\n            if count % 3 == 0:\\n                ans += count//3\\n            else:\\n                ans += count//3 + 1\\n        return ans \\n                \\n\\n"
                    },
                    {
                        "username": "imankitg",
                        "content": "Me: Solved medium-level question in under 10 minutes\\nOthers comment: This should be an easy question"
                    },
                    {
                        "username": "adarsh301998",
                        "content": "Golang (O)N \\n `func minimumRounds(tasks []int) int {\\n    count := map[int]int{}\\n    for _, v := range tasks {\\n        data, ok := count[v]\\n        if ok {\\n            data++\\n        }else {\\n            data = 1\\n        }\\n        count[v] = data\\n    }\\n    round := 0\\n    fmt.Println(\"1\", count)\\n    for _, v := range count {\\n        if v == 1 {\\n            return -1\\n        }\\n        round += (v/3)\\n        if v%3 != 0 {\\n            round++\\n        }\\n    }\\n    return round\\n}`"
                    }
                ]
            },
            {
                "id": 1741569,
                "content": [
                    {
                        "username": "aminuolawale",
                        "content": "Well you only need to realise that \\n1. If an element occurs only once, the condition is violated\\n2. tasks of any difficulty level takes `ceil(no_occurences/3)` rounds.\\nWith this you have your solution."
                    },
                    {
                        "username": "user4037uh",
                        "content": "my 71st testcase is showing time limit exceeded can someone help its my 1st weeek on leetcode"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "same here, although mine was 75/79 case. I brute forced it by adding a loop counter. if the no. of loop exceeds 500, just print length of vector divided by count. The reason this worked is because my base logic was correct but slow and the later test cases had same count of occurrences for each task.  "
                    },
                    {
                        "username": "omi23",
                        "content": "Easiest medium questions I have ever seen."
                    },
                    {
                        "username": "MrSlend",
                        "content": "I keep getting time exceeded error when testing about 50,000 cases. Can anyone tell me what\\'s wrong?\\n\\nclass Solution {\\n    fun minimumRounds(tasks: IntArray):Int {\\n        var size = tasks.size;\\n        var arr = ArrayList<Int>();\\n        var store = 0;\\n        var result = 0;\\n        tasks.sort(); //sorts the array\\n\\n        for(i in 0..size-1){\\n            if(!arr.contains(tasks[i])){ \\n                arr.add(tasks[i]);\\n                store = occurences(tasks[i],tasks); //function\\n                if( store == -1) return -1;\\n                else result += store;\\n            }\\n        }\\n        \\n    return result;\\n    }\\n\\n    fun occurences(num:Int, t:IntArray):Int{\\n        var count = 0.0;\\n        for(i in 0..t.size-1){\\n            if(num == t[i])\\n                count++;\\n        }\\n        if (count==1.0)\\n            return -1;\\n        return Math.ceil(count/3.0).toInt();\\n    }\\n}"
                    },
                    {
                        "username": "deepeshsai1312",
                        "content": "i dont understand the question\\n"
                    },
                    {
                        "username": "rambabu135",
                        "content": "at first I filled whole my code with if else conditions.\\nat last I wrote for answers  for occurances from 1 to 16.\\nAnd magically I found the pattern. \\nThis question shows that pen and paper are really important while solving question even if you don\\'t know anything about question\\nstart writing the things on paper and question starts breaking into chunks."
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "    int minimumRounds(vector<int>& tasks) {\n        map<int,int>mp;\n        for(auto e : tasks) {\n            mp[e]++;\n        }\n        int counter=0;\n        for(auto p : mp){\n            if(p.second==1) return -1;\n            counter+=(p.second/3) + (bool)(p.second%3);\n        }\n        return counter;\n    }"
                    },
                    {
                        "username": "user3904Q",
                        "content": "For count(task[i]) % 3 == 2 and count(task[i]) % 3 == 1 the result is same, count//3 + 1 so :\\n\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        counter = collections.Counter(tasks)\\n        ans = 0\\n        for k in counter:\\n            count = counter[k]\\n            if count < 2:\\n                return - 1\\n            if count % 3 == 0:\\n                ans += count//3\\n            else:\\n                ans += count//3 + 1\\n        return ans \\n                \\n\\n"
                    },
                    {
                        "username": "imankitg",
                        "content": "Me: Solved medium-level question in under 10 minutes\\nOthers comment: This should be an easy question"
                    },
                    {
                        "username": "adarsh301998",
                        "content": "Golang (O)N \\n `func minimumRounds(tasks []int) int {\\n    count := map[int]int{}\\n    for _, v := range tasks {\\n        data, ok := count[v]\\n        if ok {\\n            data++\\n        }else {\\n            data = 1\\n        }\\n        count[v] = data\\n    }\\n    round := 0\\n    fmt.Println(\"1\", count)\\n    for _, v := range count {\\n        if v == 1 {\\n            return -1\\n        }\\n        round += (v/3)\\n        if v%3 != 0 {\\n            round++\\n        }\\n    }\\n    return round\\n}`"
                    }
                ]
            },
            {
                "id": 1741530,
                "content": [
                    {
                        "username": "esper_desk",
                        "content": "The question looks complicated but all we need to understand is that any number greater than 1 can be split into rounds. If there is no task with difficulty level 1, then they can always be completed. We take as many 3\\'s as we can and remaining are used by 2\\'s. "
                    },
                    {
                        "username": "KalyanAmmisetty",
                        "content": "Every Number can be expressed as the sum of 2's and 3's except 1. so if we find the element frequency as 1 then we can return -1.\notherwise to reduce the cycles we will find a greedy way.\n1. we will find wheather it is multiple of 3 or not. if so we will increase count by that many times.\n2. suppose we have remainder 2(like 5,8,11..) we can simply add (freq/3(3's) + 1(2's)) to the value.\n3. we have a remainder 1.(like 7,10,13...)  we need to scarifice one 3 to make allocation for 2. \n         suppose we have 7 which greedly goes as (3+3+1) . to write this interms of 2's and 3's we need to scarifice one 3.  {7= 3+2+2}. so when the reaminder is 1 we need to increse count with ((freq/3) -1 +2) = (freq/3  + 1 ). \n\n            Here one corner case is there if we have frequency as 4 (3+1). we need to add it by 2.\n             check out my code if you have any douts.\n \nclass Solution {\n    public int minimumRounds(int[] tasks) {\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\n        for(int x:tasks)\n            map.put(x,map.getOrDefault(x,0)+1);\n        int count = 0;\n        for(Map.Entry<Integer,Integer> entry : map.entrySet())\n        {\n            int temp = entry.getValue();\n            if(temp==1) return -1;\n            else if(temp%3==0)  count+=(temp/3);\n            else if(temp%3==2) count+=((temp/3)+1);\n            else\n            {\n                if(temp==4) \n                    count+=2;\n                else\n                    count+=((temp/3)+1);\n            }\n        }\n        return count;\n    }\n}"
                    },
                    {
                        "username": "Khushi260",
                        "content": "the only condition for return -1 if count of a particular task ==1 otherwise if (count % 3 == 0) then result += 1 else result+=2;"
                    },
                    {
                        "username": "sanjay1e7",
                        "content": "We have to return -1 only if the frequency of any element is 1 otherwise, we can easily break them in parts of 3 and 2."
                    },
                    {
                        "username": "Balwierz",
                        "content": "Why is this problem medium? It should be easy."
                    },
                    {
                        "username": "prady8339",
                        "content": " HINT to understand pattern.\nfrequency : answer \n 1 :  return -1 \n 2 : 1 ans+=1\n 3 : 1 ans+=1\n 4 : 2 (n-1)%3==0 so ans += (n-1)/3 + 1; { 3 2 }\n 6 : 2 n%3==0 so ans += n/3; {3 3}\n 7 : 3 (n-1)%3==0 so ans += (n-1)/3 + 1; { 2 2 3 }\n 8 : 3 (n-2)%3==0 so ans += (n-1)/3 + 1; { 3 2 2 }\n 9 : 3  n%3==0 so ans += n/3; {3 3 3}\n10 : 4 (n-1)%3==0 so ans += (n-1)/3 + 1; \n11 : 4 (n-2)%3==0 so ans += (n-1)/3 + 1;\n12 : 4  n%3==0 so ans += n/3;\n\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2997905/simple-to-understand-cpp-solution/"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "I am getting 35 instead of 38 for \\n[119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nI don\\'t see how my result is flawed"
                    },
                    {
                        "username": "GD18",
                        "content": "Isnt this a little on the easier side to be a medium question lol"
                    },
                    {
                        "username": "surajku2022",
                        "content": "There are 3 ways to solve this question.\\n1. Brute force method using visited array. We can count occurrence of each number and then calculate minimum rounds.\\n2. By sorting the given array, so that we don\\'t have to iterate over array to get count of occurrences of a number.\\n3. Just use map to store the occurrence and then calculate by iterating over map."
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "Simply we just count tasks numbers in hash map then we iterate over it \nthen we have 2 conditions \n- if the freqency of this task is 1 so we can't batch it in group of 2's or 3's  so **return -1**\n- other wise mnRounds = freq/3 + (freq%3 != 0)  "
                    }
                ]
            },
            {
                "id": 1741482,
                "content": [
                    {
                        "username": "esper_desk",
                        "content": "The question looks complicated but all we need to understand is that any number greater than 1 can be split into rounds. If there is no task with difficulty level 1, then they can always be completed. We take as many 3\\'s as we can and remaining are used by 2\\'s. "
                    },
                    {
                        "username": "KalyanAmmisetty",
                        "content": "Every Number can be expressed as the sum of 2's and 3's except 1. so if we find the element frequency as 1 then we can return -1.\notherwise to reduce the cycles we will find a greedy way.\n1. we will find wheather it is multiple of 3 or not. if so we will increase count by that many times.\n2. suppose we have remainder 2(like 5,8,11..) we can simply add (freq/3(3's) + 1(2's)) to the value.\n3. we have a remainder 1.(like 7,10,13...)  we need to scarifice one 3 to make allocation for 2. \n         suppose we have 7 which greedly goes as (3+3+1) . to write this interms of 2's and 3's we need to scarifice one 3.  {7= 3+2+2}. so when the reaminder is 1 we need to increse count with ((freq/3) -1 +2) = (freq/3  + 1 ). \n\n            Here one corner case is there if we have frequency as 4 (3+1). we need to add it by 2.\n             check out my code if you have any douts.\n \nclass Solution {\n    public int minimumRounds(int[] tasks) {\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\n        for(int x:tasks)\n            map.put(x,map.getOrDefault(x,0)+1);\n        int count = 0;\n        for(Map.Entry<Integer,Integer> entry : map.entrySet())\n        {\n            int temp = entry.getValue();\n            if(temp==1) return -1;\n            else if(temp%3==0)  count+=(temp/3);\n            else if(temp%3==2) count+=((temp/3)+1);\n            else\n            {\n                if(temp==4) \n                    count+=2;\n                else\n                    count+=((temp/3)+1);\n            }\n        }\n        return count;\n    }\n}"
                    },
                    {
                        "username": "Khushi260",
                        "content": "the only condition for return -1 if count of a particular task ==1 otherwise if (count % 3 == 0) then result += 1 else result+=2;"
                    },
                    {
                        "username": "sanjay1e7",
                        "content": "We have to return -1 only if the frequency of any element is 1 otherwise, we can easily break them in parts of 3 and 2."
                    },
                    {
                        "username": "Balwierz",
                        "content": "Why is this problem medium? It should be easy."
                    },
                    {
                        "username": "prady8339",
                        "content": " HINT to understand pattern.\nfrequency : answer \n 1 :  return -1 \n 2 : 1 ans+=1\n 3 : 1 ans+=1\n 4 : 2 (n-1)%3==0 so ans += (n-1)/3 + 1; { 3 2 }\n 6 : 2 n%3==0 so ans += n/3; {3 3}\n 7 : 3 (n-1)%3==0 so ans += (n-1)/3 + 1; { 2 2 3 }\n 8 : 3 (n-2)%3==0 so ans += (n-1)/3 + 1; { 3 2 2 }\n 9 : 3  n%3==0 so ans += n/3; {3 3 3}\n10 : 4 (n-1)%3==0 so ans += (n-1)/3 + 1; \n11 : 4 (n-2)%3==0 so ans += (n-1)/3 + 1;\n12 : 4  n%3==0 so ans += n/3;\n\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2997905/simple-to-understand-cpp-solution/"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "I am getting 35 instead of 38 for \\n[119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nI don\\'t see how my result is flawed"
                    },
                    {
                        "username": "GD18",
                        "content": "Isnt this a little on the easier side to be a medium question lol"
                    },
                    {
                        "username": "surajku2022",
                        "content": "There are 3 ways to solve this question.\\n1. Brute force method using visited array. We can count occurrence of each number and then calculate minimum rounds.\\n2. By sorting the given array, so that we don\\'t have to iterate over array to get count of occurrences of a number.\\n3. Just use map to store the occurrence and then calculate by iterating over map."
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "Simply we just count tasks numbers in hash map then we iterate over it \nthen we have 2 conditions \n- if the freqency of this task is 1 so we can't batch it in group of 2's or 3's  so **return -1**\n- other wise mnRounds = freq/3 + (freq%3 != 0)  "
                    }
                ]
            },
            {
                "id": 1741479,
                "content": [
                    {
                        "username": "esper_desk",
                        "content": "The question looks complicated but all we need to understand is that any number greater than 1 can be split into rounds. If there is no task with difficulty level 1, then they can always be completed. We take as many 3\\'s as we can and remaining are used by 2\\'s. "
                    },
                    {
                        "username": "KalyanAmmisetty",
                        "content": "Every Number can be expressed as the sum of 2's and 3's except 1. so if we find the element frequency as 1 then we can return -1.\notherwise to reduce the cycles we will find a greedy way.\n1. we will find wheather it is multiple of 3 or not. if so we will increase count by that many times.\n2. suppose we have remainder 2(like 5,8,11..) we can simply add (freq/3(3's) + 1(2's)) to the value.\n3. we have a remainder 1.(like 7,10,13...)  we need to scarifice one 3 to make allocation for 2. \n         suppose we have 7 which greedly goes as (3+3+1) . to write this interms of 2's and 3's we need to scarifice one 3.  {7= 3+2+2}. so when the reaminder is 1 we need to increse count with ((freq/3) -1 +2) = (freq/3  + 1 ). \n\n            Here one corner case is there if we have frequency as 4 (3+1). we need to add it by 2.\n             check out my code if you have any douts.\n \nclass Solution {\n    public int minimumRounds(int[] tasks) {\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\n        for(int x:tasks)\n            map.put(x,map.getOrDefault(x,0)+1);\n        int count = 0;\n        for(Map.Entry<Integer,Integer> entry : map.entrySet())\n        {\n            int temp = entry.getValue();\n            if(temp==1) return -1;\n            else if(temp%3==0)  count+=(temp/3);\n            else if(temp%3==2) count+=((temp/3)+1);\n            else\n            {\n                if(temp==4) \n                    count+=2;\n                else\n                    count+=((temp/3)+1);\n            }\n        }\n        return count;\n    }\n}"
                    },
                    {
                        "username": "Khushi260",
                        "content": "the only condition for return -1 if count of a particular task ==1 otherwise if (count % 3 == 0) then result += 1 else result+=2;"
                    },
                    {
                        "username": "sanjay1e7",
                        "content": "We have to return -1 only if the frequency of any element is 1 otherwise, we can easily break them in parts of 3 and 2."
                    },
                    {
                        "username": "Balwierz",
                        "content": "Why is this problem medium? It should be easy."
                    },
                    {
                        "username": "prady8339",
                        "content": " HINT to understand pattern.\nfrequency : answer \n 1 :  return -1 \n 2 : 1 ans+=1\n 3 : 1 ans+=1\n 4 : 2 (n-1)%3==0 so ans += (n-1)/3 + 1; { 3 2 }\n 6 : 2 n%3==0 so ans += n/3; {3 3}\n 7 : 3 (n-1)%3==0 so ans += (n-1)/3 + 1; { 2 2 3 }\n 8 : 3 (n-2)%3==0 so ans += (n-1)/3 + 1; { 3 2 2 }\n 9 : 3  n%3==0 so ans += n/3; {3 3 3}\n10 : 4 (n-1)%3==0 so ans += (n-1)/3 + 1; \n11 : 4 (n-2)%3==0 so ans += (n-1)/3 + 1;\n12 : 4  n%3==0 so ans += n/3;\n\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2997905/simple-to-understand-cpp-solution/"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "I am getting 35 instead of 38 for \\n[119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nI don\\'t see how my result is flawed"
                    },
                    {
                        "username": "GD18",
                        "content": "Isnt this a little on the easier side to be a medium question lol"
                    },
                    {
                        "username": "surajku2022",
                        "content": "There are 3 ways to solve this question.\\n1. Brute force method using visited array. We can count occurrence of each number and then calculate minimum rounds.\\n2. By sorting the given array, so that we don\\'t have to iterate over array to get count of occurrences of a number.\\n3. Just use map to store the occurrence and then calculate by iterating over map."
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "Simply we just count tasks numbers in hash map then we iterate over it \nthen we have 2 conditions \n- if the freqency of this task is 1 so we can't batch it in group of 2's or 3's  so **return -1**\n- other wise mnRounds = freq/3 + (freq%3 != 0)  "
                    }
                ]
            },
            {
                "id": 1741465,
                "content": [
                    {
                        "username": "esper_desk",
                        "content": "The question looks complicated but all we need to understand is that any number greater than 1 can be split into rounds. If there is no task with difficulty level 1, then they can always be completed. We take as many 3\\'s as we can and remaining are used by 2\\'s. "
                    },
                    {
                        "username": "KalyanAmmisetty",
                        "content": "Every Number can be expressed as the sum of 2's and 3's except 1. so if we find the element frequency as 1 then we can return -1.\notherwise to reduce the cycles we will find a greedy way.\n1. we will find wheather it is multiple of 3 or not. if so we will increase count by that many times.\n2. suppose we have remainder 2(like 5,8,11..) we can simply add (freq/3(3's) + 1(2's)) to the value.\n3. we have a remainder 1.(like 7,10,13...)  we need to scarifice one 3 to make allocation for 2. \n         suppose we have 7 which greedly goes as (3+3+1) . to write this interms of 2's and 3's we need to scarifice one 3.  {7= 3+2+2}. so when the reaminder is 1 we need to increse count with ((freq/3) -1 +2) = (freq/3  + 1 ). \n\n            Here one corner case is there if we have frequency as 4 (3+1). we need to add it by 2.\n             check out my code if you have any douts.\n \nclass Solution {\n    public int minimumRounds(int[] tasks) {\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\n        for(int x:tasks)\n            map.put(x,map.getOrDefault(x,0)+1);\n        int count = 0;\n        for(Map.Entry<Integer,Integer> entry : map.entrySet())\n        {\n            int temp = entry.getValue();\n            if(temp==1) return -1;\n            else if(temp%3==0)  count+=(temp/3);\n            else if(temp%3==2) count+=((temp/3)+1);\n            else\n            {\n                if(temp==4) \n                    count+=2;\n                else\n                    count+=((temp/3)+1);\n            }\n        }\n        return count;\n    }\n}"
                    },
                    {
                        "username": "Khushi260",
                        "content": "the only condition for return -1 if count of a particular task ==1 otherwise if (count % 3 == 0) then result += 1 else result+=2;"
                    },
                    {
                        "username": "sanjay1e7",
                        "content": "We have to return -1 only if the frequency of any element is 1 otherwise, we can easily break them in parts of 3 and 2."
                    },
                    {
                        "username": "Balwierz",
                        "content": "Why is this problem medium? It should be easy."
                    },
                    {
                        "username": "prady8339",
                        "content": " HINT to understand pattern.\nfrequency : answer \n 1 :  return -1 \n 2 : 1 ans+=1\n 3 : 1 ans+=1\n 4 : 2 (n-1)%3==0 so ans += (n-1)/3 + 1; { 3 2 }\n 6 : 2 n%3==0 so ans += n/3; {3 3}\n 7 : 3 (n-1)%3==0 so ans += (n-1)/3 + 1; { 2 2 3 }\n 8 : 3 (n-2)%3==0 so ans += (n-1)/3 + 1; { 3 2 2 }\n 9 : 3  n%3==0 so ans += n/3; {3 3 3}\n10 : 4 (n-1)%3==0 so ans += (n-1)/3 + 1; \n11 : 4 (n-2)%3==0 so ans += (n-1)/3 + 1;\n12 : 4  n%3==0 so ans += n/3;\n\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2997905/simple-to-understand-cpp-solution/"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "I am getting 35 instead of 38 for \\n[119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nI don\\'t see how my result is flawed"
                    },
                    {
                        "username": "GD18",
                        "content": "Isnt this a little on the easier side to be a medium question lol"
                    },
                    {
                        "username": "surajku2022",
                        "content": "There are 3 ways to solve this question.\\n1. Brute force method using visited array. We can count occurrence of each number and then calculate minimum rounds.\\n2. By sorting the given array, so that we don\\'t have to iterate over array to get count of occurrences of a number.\\n3. Just use map to store the occurrence and then calculate by iterating over map."
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "Simply we just count tasks numbers in hash map then we iterate over it \nthen we have 2 conditions \n- if the freqency of this task is 1 so we can't batch it in group of 2's or 3's  so **return -1**\n- other wise mnRounds = freq/3 + (freq%3 != 0)  "
                    }
                ]
            },
            {
                "id": 1741403,
                "content": [
                    {
                        "username": "esper_desk",
                        "content": "The question looks complicated but all we need to understand is that any number greater than 1 can be split into rounds. If there is no task with difficulty level 1, then they can always be completed. We take as many 3\\'s as we can and remaining are used by 2\\'s. "
                    },
                    {
                        "username": "KalyanAmmisetty",
                        "content": "Every Number can be expressed as the sum of 2's and 3's except 1. so if we find the element frequency as 1 then we can return -1.\notherwise to reduce the cycles we will find a greedy way.\n1. we will find wheather it is multiple of 3 or not. if so we will increase count by that many times.\n2. suppose we have remainder 2(like 5,8,11..) we can simply add (freq/3(3's) + 1(2's)) to the value.\n3. we have a remainder 1.(like 7,10,13...)  we need to scarifice one 3 to make allocation for 2. \n         suppose we have 7 which greedly goes as (3+3+1) . to write this interms of 2's and 3's we need to scarifice one 3.  {7= 3+2+2}. so when the reaminder is 1 we need to increse count with ((freq/3) -1 +2) = (freq/3  + 1 ). \n\n            Here one corner case is there if we have frequency as 4 (3+1). we need to add it by 2.\n             check out my code if you have any douts.\n \nclass Solution {\n    public int minimumRounds(int[] tasks) {\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\n        for(int x:tasks)\n            map.put(x,map.getOrDefault(x,0)+1);\n        int count = 0;\n        for(Map.Entry<Integer,Integer> entry : map.entrySet())\n        {\n            int temp = entry.getValue();\n            if(temp==1) return -1;\n            else if(temp%3==0)  count+=(temp/3);\n            else if(temp%3==2) count+=((temp/3)+1);\n            else\n            {\n                if(temp==4) \n                    count+=2;\n                else\n                    count+=((temp/3)+1);\n            }\n        }\n        return count;\n    }\n}"
                    },
                    {
                        "username": "Khushi260",
                        "content": "the only condition for return -1 if count of a particular task ==1 otherwise if (count % 3 == 0) then result += 1 else result+=2;"
                    },
                    {
                        "username": "sanjay1e7",
                        "content": "We have to return -1 only if the frequency of any element is 1 otherwise, we can easily break them in parts of 3 and 2."
                    },
                    {
                        "username": "Balwierz",
                        "content": "Why is this problem medium? It should be easy."
                    },
                    {
                        "username": "prady8339",
                        "content": " HINT to understand pattern.\nfrequency : answer \n 1 :  return -1 \n 2 : 1 ans+=1\n 3 : 1 ans+=1\n 4 : 2 (n-1)%3==0 so ans += (n-1)/3 + 1; { 3 2 }\n 6 : 2 n%3==0 so ans += n/3; {3 3}\n 7 : 3 (n-1)%3==0 so ans += (n-1)/3 + 1; { 2 2 3 }\n 8 : 3 (n-2)%3==0 so ans += (n-1)/3 + 1; { 3 2 2 }\n 9 : 3  n%3==0 so ans += n/3; {3 3 3}\n10 : 4 (n-1)%3==0 so ans += (n-1)/3 + 1; \n11 : 4 (n-2)%3==0 so ans += (n-1)/3 + 1;\n12 : 4  n%3==0 so ans += n/3;\n\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2997905/simple-to-understand-cpp-solution/"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "I am getting 35 instead of 38 for \\n[119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nI don\\'t see how my result is flawed"
                    },
                    {
                        "username": "GD18",
                        "content": "Isnt this a little on the easier side to be a medium question lol"
                    },
                    {
                        "username": "surajku2022",
                        "content": "There are 3 ways to solve this question.\\n1. Brute force method using visited array. We can count occurrence of each number and then calculate minimum rounds.\\n2. By sorting the given array, so that we don\\'t have to iterate over array to get count of occurrences of a number.\\n3. Just use map to store the occurrence and then calculate by iterating over map."
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "Simply we just count tasks numbers in hash map then we iterate over it \nthen we have 2 conditions \n- if the freqency of this task is 1 so we can't batch it in group of 2's or 3's  so **return -1**\n- other wise mnRounds = freq/3 + (freq%3 != 0)  "
                    }
                ]
            },
            {
                "id": 1741386,
                "content": [
                    {
                        "username": "esper_desk",
                        "content": "The question looks complicated but all we need to understand is that any number greater than 1 can be split into rounds. If there is no task with difficulty level 1, then they can always be completed. We take as many 3\\'s as we can and remaining are used by 2\\'s. "
                    },
                    {
                        "username": "KalyanAmmisetty",
                        "content": "Every Number can be expressed as the sum of 2's and 3's except 1. so if we find the element frequency as 1 then we can return -1.\notherwise to reduce the cycles we will find a greedy way.\n1. we will find wheather it is multiple of 3 or not. if so we will increase count by that many times.\n2. suppose we have remainder 2(like 5,8,11..) we can simply add (freq/3(3's) + 1(2's)) to the value.\n3. we have a remainder 1.(like 7,10,13...)  we need to scarifice one 3 to make allocation for 2. \n         suppose we have 7 which greedly goes as (3+3+1) . to write this interms of 2's and 3's we need to scarifice one 3.  {7= 3+2+2}. so when the reaminder is 1 we need to increse count with ((freq/3) -1 +2) = (freq/3  + 1 ). \n\n            Here one corner case is there if we have frequency as 4 (3+1). we need to add it by 2.\n             check out my code if you have any douts.\n \nclass Solution {\n    public int minimumRounds(int[] tasks) {\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\n        for(int x:tasks)\n            map.put(x,map.getOrDefault(x,0)+1);\n        int count = 0;\n        for(Map.Entry<Integer,Integer> entry : map.entrySet())\n        {\n            int temp = entry.getValue();\n            if(temp==1) return -1;\n            else if(temp%3==0)  count+=(temp/3);\n            else if(temp%3==2) count+=((temp/3)+1);\n            else\n            {\n                if(temp==4) \n                    count+=2;\n                else\n                    count+=((temp/3)+1);\n            }\n        }\n        return count;\n    }\n}"
                    },
                    {
                        "username": "Khushi260",
                        "content": "the only condition for return -1 if count of a particular task ==1 otherwise if (count % 3 == 0) then result += 1 else result+=2;"
                    },
                    {
                        "username": "sanjay1e7",
                        "content": "We have to return -1 only if the frequency of any element is 1 otherwise, we can easily break them in parts of 3 and 2."
                    },
                    {
                        "username": "Balwierz",
                        "content": "Why is this problem medium? It should be easy."
                    },
                    {
                        "username": "prady8339",
                        "content": " HINT to understand pattern.\nfrequency : answer \n 1 :  return -1 \n 2 : 1 ans+=1\n 3 : 1 ans+=1\n 4 : 2 (n-1)%3==0 so ans += (n-1)/3 + 1; { 3 2 }\n 6 : 2 n%3==0 so ans += n/3; {3 3}\n 7 : 3 (n-1)%3==0 so ans += (n-1)/3 + 1; { 2 2 3 }\n 8 : 3 (n-2)%3==0 so ans += (n-1)/3 + 1; { 3 2 2 }\n 9 : 3  n%3==0 so ans += n/3; {3 3 3}\n10 : 4 (n-1)%3==0 so ans += (n-1)/3 + 1; \n11 : 4 (n-2)%3==0 so ans += (n-1)/3 + 1;\n12 : 4  n%3==0 so ans += n/3;\n\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2997905/simple-to-understand-cpp-solution/"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "I am getting 35 instead of 38 for \\n[119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nI don\\'t see how my result is flawed"
                    },
                    {
                        "username": "GD18",
                        "content": "Isnt this a little on the easier side to be a medium question lol"
                    },
                    {
                        "username": "surajku2022",
                        "content": "There are 3 ways to solve this question.\\n1. Brute force method using visited array. We can count occurrence of each number and then calculate minimum rounds.\\n2. By sorting the given array, so that we don\\'t have to iterate over array to get count of occurrences of a number.\\n3. Just use map to store the occurrence and then calculate by iterating over map."
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "Simply we just count tasks numbers in hash map then we iterate over it \nthen we have 2 conditions \n- if the freqency of this task is 1 so we can't batch it in group of 2's or 3's  so **return -1**\n- other wise mnRounds = freq/3 + (freq%3 != 0)  "
                    }
                ]
            },
            {
                "id": 1741344,
                "content": [
                    {
                        "username": "esper_desk",
                        "content": "The question looks complicated but all we need to understand is that any number greater than 1 can be split into rounds. If there is no task with difficulty level 1, then they can always be completed. We take as many 3\\'s as we can and remaining are used by 2\\'s. "
                    },
                    {
                        "username": "KalyanAmmisetty",
                        "content": "Every Number can be expressed as the sum of 2's and 3's except 1. so if we find the element frequency as 1 then we can return -1.\notherwise to reduce the cycles we will find a greedy way.\n1. we will find wheather it is multiple of 3 or not. if so we will increase count by that many times.\n2. suppose we have remainder 2(like 5,8,11..) we can simply add (freq/3(3's) + 1(2's)) to the value.\n3. we have a remainder 1.(like 7,10,13...)  we need to scarifice one 3 to make allocation for 2. \n         suppose we have 7 which greedly goes as (3+3+1) . to write this interms of 2's and 3's we need to scarifice one 3.  {7= 3+2+2}. so when the reaminder is 1 we need to increse count with ((freq/3) -1 +2) = (freq/3  + 1 ). \n\n            Here one corner case is there if we have frequency as 4 (3+1). we need to add it by 2.\n             check out my code if you have any douts.\n \nclass Solution {\n    public int minimumRounds(int[] tasks) {\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\n        for(int x:tasks)\n            map.put(x,map.getOrDefault(x,0)+1);\n        int count = 0;\n        for(Map.Entry<Integer,Integer> entry : map.entrySet())\n        {\n            int temp = entry.getValue();\n            if(temp==1) return -1;\n            else if(temp%3==0)  count+=(temp/3);\n            else if(temp%3==2) count+=((temp/3)+1);\n            else\n            {\n                if(temp==4) \n                    count+=2;\n                else\n                    count+=((temp/3)+1);\n            }\n        }\n        return count;\n    }\n}"
                    },
                    {
                        "username": "Khushi260",
                        "content": "the only condition for return -1 if count of a particular task ==1 otherwise if (count % 3 == 0) then result += 1 else result+=2;"
                    },
                    {
                        "username": "sanjay1e7",
                        "content": "We have to return -1 only if the frequency of any element is 1 otherwise, we can easily break them in parts of 3 and 2."
                    },
                    {
                        "username": "Balwierz",
                        "content": "Why is this problem medium? It should be easy."
                    },
                    {
                        "username": "prady8339",
                        "content": " HINT to understand pattern.\nfrequency : answer \n 1 :  return -1 \n 2 : 1 ans+=1\n 3 : 1 ans+=1\n 4 : 2 (n-1)%3==0 so ans += (n-1)/3 + 1; { 3 2 }\n 6 : 2 n%3==0 so ans += n/3; {3 3}\n 7 : 3 (n-1)%3==0 so ans += (n-1)/3 + 1; { 2 2 3 }\n 8 : 3 (n-2)%3==0 so ans += (n-1)/3 + 1; { 3 2 2 }\n 9 : 3  n%3==0 so ans += n/3; {3 3 3}\n10 : 4 (n-1)%3==0 so ans += (n-1)/3 + 1; \n11 : 4 (n-2)%3==0 so ans += (n-1)/3 + 1;\n12 : 4  n%3==0 so ans += n/3;\n\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2997905/simple-to-understand-cpp-solution/"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "I am getting 35 instead of 38 for \\n[119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nI don\\'t see how my result is flawed"
                    },
                    {
                        "username": "GD18",
                        "content": "Isnt this a little on the easier side to be a medium question lol"
                    },
                    {
                        "username": "surajku2022",
                        "content": "There are 3 ways to solve this question.\\n1. Brute force method using visited array. We can count occurrence of each number and then calculate minimum rounds.\\n2. By sorting the given array, so that we don\\'t have to iterate over array to get count of occurrences of a number.\\n3. Just use map to store the occurrence and then calculate by iterating over map."
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "Simply we just count tasks numbers in hash map then we iterate over it \nthen we have 2 conditions \n- if the freqency of this task is 1 so we can't batch it in group of 2's or 3's  so **return -1**\n- other wise mnRounds = freq/3 + (freq%3 != 0)  "
                    }
                ]
            },
            {
                "id": 1741296,
                "content": [
                    {
                        "username": "esper_desk",
                        "content": "The question looks complicated but all we need to understand is that any number greater than 1 can be split into rounds. If there is no task with difficulty level 1, then they can always be completed. We take as many 3\\'s as we can and remaining are used by 2\\'s. "
                    },
                    {
                        "username": "KalyanAmmisetty",
                        "content": "Every Number can be expressed as the sum of 2's and 3's except 1. so if we find the element frequency as 1 then we can return -1.\notherwise to reduce the cycles we will find a greedy way.\n1. we will find wheather it is multiple of 3 or not. if so we will increase count by that many times.\n2. suppose we have remainder 2(like 5,8,11..) we can simply add (freq/3(3's) + 1(2's)) to the value.\n3. we have a remainder 1.(like 7,10,13...)  we need to scarifice one 3 to make allocation for 2. \n         suppose we have 7 which greedly goes as (3+3+1) . to write this interms of 2's and 3's we need to scarifice one 3.  {7= 3+2+2}. so when the reaminder is 1 we need to increse count with ((freq/3) -1 +2) = (freq/3  + 1 ). \n\n            Here one corner case is there if we have frequency as 4 (3+1). we need to add it by 2.\n             check out my code if you have any douts.\n \nclass Solution {\n    public int minimumRounds(int[] tasks) {\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\n        for(int x:tasks)\n            map.put(x,map.getOrDefault(x,0)+1);\n        int count = 0;\n        for(Map.Entry<Integer,Integer> entry : map.entrySet())\n        {\n            int temp = entry.getValue();\n            if(temp==1) return -1;\n            else if(temp%3==0)  count+=(temp/3);\n            else if(temp%3==2) count+=((temp/3)+1);\n            else\n            {\n                if(temp==4) \n                    count+=2;\n                else\n                    count+=((temp/3)+1);\n            }\n        }\n        return count;\n    }\n}"
                    },
                    {
                        "username": "Khushi260",
                        "content": "the only condition for return -1 if count of a particular task ==1 otherwise if (count % 3 == 0) then result += 1 else result+=2;"
                    },
                    {
                        "username": "sanjay1e7",
                        "content": "We have to return -1 only if the frequency of any element is 1 otherwise, we can easily break them in parts of 3 and 2."
                    },
                    {
                        "username": "Balwierz",
                        "content": "Why is this problem medium? It should be easy."
                    },
                    {
                        "username": "prady8339",
                        "content": " HINT to understand pattern.\nfrequency : answer \n 1 :  return -1 \n 2 : 1 ans+=1\n 3 : 1 ans+=1\n 4 : 2 (n-1)%3==0 so ans += (n-1)/3 + 1; { 3 2 }\n 6 : 2 n%3==0 so ans += n/3; {3 3}\n 7 : 3 (n-1)%3==0 so ans += (n-1)/3 + 1; { 2 2 3 }\n 8 : 3 (n-2)%3==0 so ans += (n-1)/3 + 1; { 3 2 2 }\n 9 : 3  n%3==0 so ans += n/3; {3 3 3}\n10 : 4 (n-1)%3==0 so ans += (n-1)/3 + 1; \n11 : 4 (n-2)%3==0 so ans += (n-1)/3 + 1;\n12 : 4  n%3==0 so ans += n/3;\n\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2997905/simple-to-understand-cpp-solution/"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "I am getting 35 instead of 38 for \\n[119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nI don\\'t see how my result is flawed"
                    },
                    {
                        "username": "GD18",
                        "content": "Isnt this a little on the easier side to be a medium question lol"
                    },
                    {
                        "username": "surajku2022",
                        "content": "There are 3 ways to solve this question.\\n1. Brute force method using visited array. We can count occurrence of each number and then calculate minimum rounds.\\n2. By sorting the given array, so that we don\\'t have to iterate over array to get count of occurrences of a number.\\n3. Just use map to store the occurrence and then calculate by iterating over map."
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "Simply we just count tasks numbers in hash map then we iterate over it \nthen we have 2 conditions \n- if the freqency of this task is 1 so we can't batch it in group of 2's or 3's  so **return -1**\n- other wise mnRounds = freq/3 + (freq%3 != 0)  "
                    }
                ]
            },
            {
                "id": 1741265,
                "content": [
                    {
                        "username": "esper_desk",
                        "content": "The question looks complicated but all we need to understand is that any number greater than 1 can be split into rounds. If there is no task with difficulty level 1, then they can always be completed. We take as many 3\\'s as we can and remaining are used by 2\\'s. "
                    },
                    {
                        "username": "KalyanAmmisetty",
                        "content": "Every Number can be expressed as the sum of 2's and 3's except 1. so if we find the element frequency as 1 then we can return -1.\notherwise to reduce the cycles we will find a greedy way.\n1. we will find wheather it is multiple of 3 or not. if so we will increase count by that many times.\n2. suppose we have remainder 2(like 5,8,11..) we can simply add (freq/3(3's) + 1(2's)) to the value.\n3. we have a remainder 1.(like 7,10,13...)  we need to scarifice one 3 to make allocation for 2. \n         suppose we have 7 which greedly goes as (3+3+1) . to write this interms of 2's and 3's we need to scarifice one 3.  {7= 3+2+2}. so when the reaminder is 1 we need to increse count with ((freq/3) -1 +2) = (freq/3  + 1 ). \n\n            Here one corner case is there if we have frequency as 4 (3+1). we need to add it by 2.\n             check out my code if you have any douts.\n \nclass Solution {\n    public int minimumRounds(int[] tasks) {\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\n        for(int x:tasks)\n            map.put(x,map.getOrDefault(x,0)+1);\n        int count = 0;\n        for(Map.Entry<Integer,Integer> entry : map.entrySet())\n        {\n            int temp = entry.getValue();\n            if(temp==1) return -1;\n            else if(temp%3==0)  count+=(temp/3);\n            else if(temp%3==2) count+=((temp/3)+1);\n            else\n            {\n                if(temp==4) \n                    count+=2;\n                else\n                    count+=((temp/3)+1);\n            }\n        }\n        return count;\n    }\n}"
                    },
                    {
                        "username": "Khushi260",
                        "content": "the only condition for return -1 if count of a particular task ==1 otherwise if (count % 3 == 0) then result += 1 else result+=2;"
                    },
                    {
                        "username": "sanjay1e7",
                        "content": "We have to return -1 only if the frequency of any element is 1 otherwise, we can easily break them in parts of 3 and 2."
                    },
                    {
                        "username": "Balwierz",
                        "content": "Why is this problem medium? It should be easy."
                    },
                    {
                        "username": "prady8339",
                        "content": " HINT to understand pattern.\nfrequency : answer \n 1 :  return -1 \n 2 : 1 ans+=1\n 3 : 1 ans+=1\n 4 : 2 (n-1)%3==0 so ans += (n-1)/3 + 1; { 3 2 }\n 6 : 2 n%3==0 so ans += n/3; {3 3}\n 7 : 3 (n-1)%3==0 so ans += (n-1)/3 + 1; { 2 2 3 }\n 8 : 3 (n-2)%3==0 so ans += (n-1)/3 + 1; { 3 2 2 }\n 9 : 3  n%3==0 so ans += n/3; {3 3 3}\n10 : 4 (n-1)%3==0 so ans += (n-1)/3 + 1; \n11 : 4 (n-2)%3==0 so ans += (n-1)/3 + 1;\n12 : 4  n%3==0 so ans += n/3;\n\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2997905/simple-to-understand-cpp-solution/"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "I am getting 35 instead of 38 for \\n[119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nI don\\'t see how my result is flawed"
                    },
                    {
                        "username": "GD18",
                        "content": "Isnt this a little on the easier side to be a medium question lol"
                    },
                    {
                        "username": "surajku2022",
                        "content": "There are 3 ways to solve this question.\\n1. Brute force method using visited array. We can count occurrence of each number and then calculate minimum rounds.\\n2. By sorting the given array, so that we don\\'t have to iterate over array to get count of occurrences of a number.\\n3. Just use map to store the occurrence and then calculate by iterating over map."
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "Simply we just count tasks numbers in hash map then we iterate over it \nthen we have 2 conditions \n- if the freqency of this task is 1 so we can't batch it in group of 2's or 3's  so **return -1**\n- other wise mnRounds = freq/3 + (freq%3 != 0)  "
                    }
                ]
            },
            {
                "id": 1741111,
                "content": [
                    {
                        "username": "esper_desk",
                        "content": "The question looks complicated but all we need to understand is that any number greater than 1 can be split into rounds. If there is no task with difficulty level 1, then they can always be completed. We take as many 3\\'s as we can and remaining are used by 2\\'s. "
                    },
                    {
                        "username": "KalyanAmmisetty",
                        "content": "Every Number can be expressed as the sum of 2's and 3's except 1. so if we find the element frequency as 1 then we can return -1.\notherwise to reduce the cycles we will find a greedy way.\n1. we will find wheather it is multiple of 3 or not. if so we will increase count by that many times.\n2. suppose we have remainder 2(like 5,8,11..) we can simply add (freq/3(3's) + 1(2's)) to the value.\n3. we have a remainder 1.(like 7,10,13...)  we need to scarifice one 3 to make allocation for 2. \n         suppose we have 7 which greedly goes as (3+3+1) . to write this interms of 2's and 3's we need to scarifice one 3.  {7= 3+2+2}. so when the reaminder is 1 we need to increse count with ((freq/3) -1 +2) = (freq/3  + 1 ). \n\n            Here one corner case is there if we have frequency as 4 (3+1). we need to add it by 2.\n             check out my code if you have any douts.\n \nclass Solution {\n    public int minimumRounds(int[] tasks) {\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\n        for(int x:tasks)\n            map.put(x,map.getOrDefault(x,0)+1);\n        int count = 0;\n        for(Map.Entry<Integer,Integer> entry : map.entrySet())\n        {\n            int temp = entry.getValue();\n            if(temp==1) return -1;\n            else if(temp%3==0)  count+=(temp/3);\n            else if(temp%3==2) count+=((temp/3)+1);\n            else\n            {\n                if(temp==4) \n                    count+=2;\n                else\n                    count+=((temp/3)+1);\n            }\n        }\n        return count;\n    }\n}"
                    },
                    {
                        "username": "Khushi260",
                        "content": "the only condition for return -1 if count of a particular task ==1 otherwise if (count % 3 == 0) then result += 1 else result+=2;"
                    },
                    {
                        "username": "sanjay1e7",
                        "content": "We have to return -1 only if the frequency of any element is 1 otherwise, we can easily break them in parts of 3 and 2."
                    },
                    {
                        "username": "Balwierz",
                        "content": "Why is this problem medium? It should be easy."
                    },
                    {
                        "username": "prady8339",
                        "content": " HINT to understand pattern.\nfrequency : answer \n 1 :  return -1 \n 2 : 1 ans+=1\n 3 : 1 ans+=1\n 4 : 2 (n-1)%3==0 so ans += (n-1)/3 + 1; { 3 2 }\n 6 : 2 n%3==0 so ans += n/3; {3 3}\n 7 : 3 (n-1)%3==0 so ans += (n-1)/3 + 1; { 2 2 3 }\n 8 : 3 (n-2)%3==0 so ans += (n-1)/3 + 1; { 3 2 2 }\n 9 : 3  n%3==0 so ans += n/3; {3 3 3}\n10 : 4 (n-1)%3==0 so ans += (n-1)/3 + 1; \n11 : 4 (n-2)%3==0 so ans += (n-1)/3 + 1;\n12 : 4  n%3==0 so ans += n/3;\n\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2997905/simple-to-understand-cpp-solution/"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "I am getting 35 instead of 38 for \\n[119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nI don\\'t see how my result is flawed"
                    },
                    {
                        "username": "GD18",
                        "content": "Isnt this a little on the easier side to be a medium question lol"
                    },
                    {
                        "username": "surajku2022",
                        "content": "There are 3 ways to solve this question.\\n1. Brute force method using visited array. We can count occurrence of each number and then calculate minimum rounds.\\n2. By sorting the given array, so that we don\\'t have to iterate over array to get count of occurrences of a number.\\n3. Just use map to store the occurrence and then calculate by iterating over map."
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "Simply we just count tasks numbers in hash map then we iterate over it \nthen we have 2 conditions \n- if the freqency of this task is 1 so we can't batch it in group of 2's or 3's  so **return -1**\n- other wise mnRounds = freq/3 + (freq%3 != 0)  "
                    }
                ]
            },
            {
                "id": 1741105,
                "content": [
                    {
                        "username": "LiamAlsbury11",
                        "content": "My code works for all but 4 test cases (TLE). How can I optimize this piece of code? (I am a beginner).\\n\\n        tasks = sorted(tasks)\\n        t = 0\\n        h = 0\\n        for i in tasks:\\n            if h == i:\\n                continue\\n            if tasks.count(i) == 1:\\n                return -1\\n            elif tasks.count(i) == 2:\\n                t += 1\\n            elif (tasks.count(i)-1) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            elif (tasks.count(i)-2) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            else:\\n                t += (tasks.count(i)/3)\\n            h = i\\n            tasks = [z for z in tasks if z != i]\\n        return t"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "can someone please clear my doubt that why my code is showing TLE ? \\nI am using only one while loop so time comlexity is o(n)  then why TLE?\\n int minimumRounds(vector<int>& v) {\\n        int c=0;\\n        while(!v.empty()){\\n        sort(v.begin(), v.end());\\n        int co =count(v.begin(), v.end(),v[v.size()-1]);\\n        if(co==1) return -1;\\n          if (co==2 || co==4 ){\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n        if(co==3 ||  co>4){\\n            v.pop_back();\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n      \\n        \\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Oitanny](/Oitanny) Cheers!, Here's another tip: instead of using prev variable for counting, you can use the following code.\n```\nfor(int i = 0; i<n; i++)\n{\n  count = 1;\n  while(arr[i+1] == arr[i])\n    {\n      count++;\n      i++;\n    }\n  // here we get curr num as arr[i] and count as the count for currnum\n  // and can write actual logic here..\n}\n````\nThis is much neater, and is more efficient since we don't need to copy values in prev variable again and again!!"
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@sarpalmadhav](/sarpalmadhav)  Thank you so much!! Because of your suggestion i removed each occurence of count function from my code and it worked!! Keep spreading the knowledge and helping ppl in need :)"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "[@sarpalmadhav](/sarpalmadhav) thank you brother. I was unaware about the fact that count function is very expensive. thats why it is showing TLE\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Uday](/udaybhardwaj01) That\\'s not how you should count, the count function is very expensive, in each loop it will check full array. You are making this a n*n solution this way and it will give TLE for 10^5 nums. Just sort it and start from i = 0 and then move forward until the element is same, this is how you will get count for cur element.. then continue from next index, Don\\'t do this pop_back logic, even pop_back is expensive when all we have to do is read the sorted array."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "For some reason I get stack overflow and I cannot understand where it may be...\\nPlease Help!\\nLang: C++11\\n\\n`#define D (int)1e9`\\n`int minimumRounds(vector<int>& tasks) {`\\n`    int cnt[D+1], ans=0;`\\n`    for (int t:tasks) ++cnt[t];`\\n`        for (int i=1; i<=D; ++i) {`\\n`          `  `if (!cnt[i]) continue;`\\n`           `  `if (cnt[i]==1) return -1;`\\n`           `  `ans += (cnt[i]+2)/3;`\\n`    }`\\n`    return ans;`\\n`}`\\n\\nThanks in advance."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Thanks for your quick answer! My first optimization would be to find the mininum and maximum difficulties, in order to limit the lower and upper bound for the loop."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@kyriakoskourk](/kyriakoskourk), This has obvious loopholes, that #define D 1e9 is a nuclear bomb. You cant do 1e9 operations in 2 sec time limit. So that it self is big No. Also, Stack overlflow might be because you cant just right an int array of 1e9. At 4 bytes per int, you are asking for 4 GB of memory!!. As a thumb rule never declare static int array of more than 1e6 size. Regarding question, you will need to optimize approach. Read hashmaps or maybe read about how to sort and count frequencies in an array."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for easiest explanation\\nhttps://youtu.be/c--4FVRqa5g"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    \\n      class Solution:\\n         def minimumRounds(self, tasks: List[int]) -> int:\\n               tacks=Counter(tasks)\\n               if 1 in tacks.values():return -1\\n               ans=0\\n              for n in tacks.values():\\n                  ans+=n//3 + bool(n%3)\\n             return ans\\n    def minDeletionSize(strs):\\n        for j in range(len(strs[0])):\\n            res=0\\n            for i in range(len(strs)):\\n                if strs[i][j] < strs[i-1][j]:\\n                   res+=1\\n        return res \\uD83E\\uDD17\\uD83E\\uDD70\\n        "
                    },
                    {
                        "username": "varunkumarkandakatla",
                        "content": "here we need to take frequencies of tasks[i] to count the level of difficulty\\n\\nthen traverse the frequency loop and check if(freq[i]<2) return -1 \\nelse if(freq[i]>3) check remainder of freq[i]%3  if it is 0 direct add quotient to answer else add quotient+1 to answer .\\n\\nfinally return answerl\\n        "
                    },
                    {
                        "username": "mrping_11",
                        "content": "finally good old hashmap, this should be an easy problem."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer>h=new HashMap<>();\\n        int x=0;\\n        for(int i=0;i<tasks.length;i++){\\n            h.put(tasks[i],h.getOrDefault(tasks[i],0)+1);\\n        }\\n        // int i=0;\\n        int c=0;\\n        for(Map.Entry<Integer,Integer>e:h.entrySet()){\\n            if(e.getValue()==1) return -1;\\n            c+=(e.getValue()+2)/3;\\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "cswartzell",
                        "content": "ceil(freq/3)"
                    },
                    {
                        "username": "itshimashis",
                        "content": "we should make a map and store all the frequency of the numbers.\\nthen we traverse through the map ans check for every element.\\nif any element has frequency<2 then we should return at that very point . ans will be -1.\\nin a general sense an element can be picked in a multiple number of 2 and 3. lets say we take x1 turns where we pick up 2 pieces of that element and x2 turns where we take 3 pieces of that element in a go.\\n\\n\\nwe represent a equation 2*x1+3*x2=y \\nwhere y is the element\\'s frequency.  if a integer pair exists (x1,x2) that satisfies the equation, we take it. if there are a lot of that solution pair, we take the pair having the smallest sum (x1+x2). \\n \\nmy code :\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871018276/"
                    }
                ]
            },
            {
                "id": 1741093,
                "content": [
                    {
                        "username": "LiamAlsbury11",
                        "content": "My code works for all but 4 test cases (TLE). How can I optimize this piece of code? (I am a beginner).\\n\\n        tasks = sorted(tasks)\\n        t = 0\\n        h = 0\\n        for i in tasks:\\n            if h == i:\\n                continue\\n            if tasks.count(i) == 1:\\n                return -1\\n            elif tasks.count(i) == 2:\\n                t += 1\\n            elif (tasks.count(i)-1) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            elif (tasks.count(i)-2) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            else:\\n                t += (tasks.count(i)/3)\\n            h = i\\n            tasks = [z for z in tasks if z != i]\\n        return t"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "can someone please clear my doubt that why my code is showing TLE ? \\nI am using only one while loop so time comlexity is o(n)  then why TLE?\\n int minimumRounds(vector<int>& v) {\\n        int c=0;\\n        while(!v.empty()){\\n        sort(v.begin(), v.end());\\n        int co =count(v.begin(), v.end(),v[v.size()-1]);\\n        if(co==1) return -1;\\n          if (co==2 || co==4 ){\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n        if(co==3 ||  co>4){\\n            v.pop_back();\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n      \\n        \\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Oitanny](/Oitanny) Cheers!, Here's another tip: instead of using prev variable for counting, you can use the following code.\n```\nfor(int i = 0; i<n; i++)\n{\n  count = 1;\n  while(arr[i+1] == arr[i])\n    {\n      count++;\n      i++;\n    }\n  // here we get curr num as arr[i] and count as the count for currnum\n  // and can write actual logic here..\n}\n````\nThis is much neater, and is more efficient since we don't need to copy values in prev variable again and again!!"
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@sarpalmadhav](/sarpalmadhav)  Thank you so much!! Because of your suggestion i removed each occurence of count function from my code and it worked!! Keep spreading the knowledge and helping ppl in need :)"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "[@sarpalmadhav](/sarpalmadhav) thank you brother. I was unaware about the fact that count function is very expensive. thats why it is showing TLE\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Uday](/udaybhardwaj01) That\\'s not how you should count, the count function is very expensive, in each loop it will check full array. You are making this a n*n solution this way and it will give TLE for 10^5 nums. Just sort it and start from i = 0 and then move forward until the element is same, this is how you will get count for cur element.. then continue from next index, Don\\'t do this pop_back logic, even pop_back is expensive when all we have to do is read the sorted array."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "For some reason I get stack overflow and I cannot understand where it may be...\\nPlease Help!\\nLang: C++11\\n\\n`#define D (int)1e9`\\n`int minimumRounds(vector<int>& tasks) {`\\n`    int cnt[D+1], ans=0;`\\n`    for (int t:tasks) ++cnt[t];`\\n`        for (int i=1; i<=D; ++i) {`\\n`          `  `if (!cnt[i]) continue;`\\n`           `  `if (cnt[i]==1) return -1;`\\n`           `  `ans += (cnt[i]+2)/3;`\\n`    }`\\n`    return ans;`\\n`}`\\n\\nThanks in advance."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Thanks for your quick answer! My first optimization would be to find the mininum and maximum difficulties, in order to limit the lower and upper bound for the loop."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@kyriakoskourk](/kyriakoskourk), This has obvious loopholes, that #define D 1e9 is a nuclear bomb. You cant do 1e9 operations in 2 sec time limit. So that it self is big No. Also, Stack overlflow might be because you cant just right an int array of 1e9. At 4 bytes per int, you are asking for 4 GB of memory!!. As a thumb rule never declare static int array of more than 1e6 size. Regarding question, you will need to optimize approach. Read hashmaps or maybe read about how to sort and count frequencies in an array."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for easiest explanation\\nhttps://youtu.be/c--4FVRqa5g"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    \\n      class Solution:\\n         def minimumRounds(self, tasks: List[int]) -> int:\\n               tacks=Counter(tasks)\\n               if 1 in tacks.values():return -1\\n               ans=0\\n              for n in tacks.values():\\n                  ans+=n//3 + bool(n%3)\\n             return ans\\n    def minDeletionSize(strs):\\n        for j in range(len(strs[0])):\\n            res=0\\n            for i in range(len(strs)):\\n                if strs[i][j] < strs[i-1][j]:\\n                   res+=1\\n        return res \\uD83E\\uDD17\\uD83E\\uDD70\\n        "
                    },
                    {
                        "username": "varunkumarkandakatla",
                        "content": "here we need to take frequencies of tasks[i] to count the level of difficulty\\n\\nthen traverse the frequency loop and check if(freq[i]<2) return -1 \\nelse if(freq[i]>3) check remainder of freq[i]%3  if it is 0 direct add quotient to answer else add quotient+1 to answer .\\n\\nfinally return answerl\\n        "
                    },
                    {
                        "username": "mrping_11",
                        "content": "finally good old hashmap, this should be an easy problem."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer>h=new HashMap<>();\\n        int x=0;\\n        for(int i=0;i<tasks.length;i++){\\n            h.put(tasks[i],h.getOrDefault(tasks[i],0)+1);\\n        }\\n        // int i=0;\\n        int c=0;\\n        for(Map.Entry<Integer,Integer>e:h.entrySet()){\\n            if(e.getValue()==1) return -1;\\n            c+=(e.getValue()+2)/3;\\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "cswartzell",
                        "content": "ceil(freq/3)"
                    },
                    {
                        "username": "itshimashis",
                        "content": "we should make a map and store all the frequency of the numbers.\\nthen we traverse through the map ans check for every element.\\nif any element has frequency<2 then we should return at that very point . ans will be -1.\\nin a general sense an element can be picked in a multiple number of 2 and 3. lets say we take x1 turns where we pick up 2 pieces of that element and x2 turns where we take 3 pieces of that element in a go.\\n\\n\\nwe represent a equation 2*x1+3*x2=y \\nwhere y is the element\\'s frequency.  if a integer pair exists (x1,x2) that satisfies the equation, we take it. if there are a lot of that solution pair, we take the pair having the smallest sum (x1+x2). \\n \\nmy code :\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871018276/"
                    }
                ]
            },
            {
                "id": 1741076,
                "content": [
                    {
                        "username": "LiamAlsbury11",
                        "content": "My code works for all but 4 test cases (TLE). How can I optimize this piece of code? (I am a beginner).\\n\\n        tasks = sorted(tasks)\\n        t = 0\\n        h = 0\\n        for i in tasks:\\n            if h == i:\\n                continue\\n            if tasks.count(i) == 1:\\n                return -1\\n            elif tasks.count(i) == 2:\\n                t += 1\\n            elif (tasks.count(i)-1) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            elif (tasks.count(i)-2) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            else:\\n                t += (tasks.count(i)/3)\\n            h = i\\n            tasks = [z for z in tasks if z != i]\\n        return t"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "can someone please clear my doubt that why my code is showing TLE ? \\nI am using only one while loop so time comlexity is o(n)  then why TLE?\\n int minimumRounds(vector<int>& v) {\\n        int c=0;\\n        while(!v.empty()){\\n        sort(v.begin(), v.end());\\n        int co =count(v.begin(), v.end(),v[v.size()-1]);\\n        if(co==1) return -1;\\n          if (co==2 || co==4 ){\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n        if(co==3 ||  co>4){\\n            v.pop_back();\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n      \\n        \\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Oitanny](/Oitanny) Cheers!, Here's another tip: instead of using prev variable for counting, you can use the following code.\n```\nfor(int i = 0; i<n; i++)\n{\n  count = 1;\n  while(arr[i+1] == arr[i])\n    {\n      count++;\n      i++;\n    }\n  // here we get curr num as arr[i] and count as the count for currnum\n  // and can write actual logic here..\n}\n````\nThis is much neater, and is more efficient since we don't need to copy values in prev variable again and again!!"
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@sarpalmadhav](/sarpalmadhav)  Thank you so much!! Because of your suggestion i removed each occurence of count function from my code and it worked!! Keep spreading the knowledge and helping ppl in need :)"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "[@sarpalmadhav](/sarpalmadhav) thank you brother. I was unaware about the fact that count function is very expensive. thats why it is showing TLE\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Uday](/udaybhardwaj01) That\\'s not how you should count, the count function is very expensive, in each loop it will check full array. You are making this a n*n solution this way and it will give TLE for 10^5 nums. Just sort it and start from i = 0 and then move forward until the element is same, this is how you will get count for cur element.. then continue from next index, Don\\'t do this pop_back logic, even pop_back is expensive when all we have to do is read the sorted array."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "For some reason I get stack overflow and I cannot understand where it may be...\\nPlease Help!\\nLang: C++11\\n\\n`#define D (int)1e9`\\n`int minimumRounds(vector<int>& tasks) {`\\n`    int cnt[D+1], ans=0;`\\n`    for (int t:tasks) ++cnt[t];`\\n`        for (int i=1; i<=D; ++i) {`\\n`          `  `if (!cnt[i]) continue;`\\n`           `  `if (cnt[i]==1) return -1;`\\n`           `  `ans += (cnt[i]+2)/3;`\\n`    }`\\n`    return ans;`\\n`}`\\n\\nThanks in advance."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Thanks for your quick answer! My first optimization would be to find the mininum and maximum difficulties, in order to limit the lower and upper bound for the loop."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@kyriakoskourk](/kyriakoskourk), This has obvious loopholes, that #define D 1e9 is a nuclear bomb. You cant do 1e9 operations in 2 sec time limit. So that it self is big No. Also, Stack overlflow might be because you cant just right an int array of 1e9. At 4 bytes per int, you are asking for 4 GB of memory!!. As a thumb rule never declare static int array of more than 1e6 size. Regarding question, you will need to optimize approach. Read hashmaps or maybe read about how to sort and count frequencies in an array."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for easiest explanation\\nhttps://youtu.be/c--4FVRqa5g"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    \\n      class Solution:\\n         def minimumRounds(self, tasks: List[int]) -> int:\\n               tacks=Counter(tasks)\\n               if 1 in tacks.values():return -1\\n               ans=0\\n              for n in tacks.values():\\n                  ans+=n//3 + bool(n%3)\\n             return ans\\n    def minDeletionSize(strs):\\n        for j in range(len(strs[0])):\\n            res=0\\n            for i in range(len(strs)):\\n                if strs[i][j] < strs[i-1][j]:\\n                   res+=1\\n        return res \\uD83E\\uDD17\\uD83E\\uDD70\\n        "
                    },
                    {
                        "username": "varunkumarkandakatla",
                        "content": "here we need to take frequencies of tasks[i] to count the level of difficulty\\n\\nthen traverse the frequency loop and check if(freq[i]<2) return -1 \\nelse if(freq[i]>3) check remainder of freq[i]%3  if it is 0 direct add quotient to answer else add quotient+1 to answer .\\n\\nfinally return answerl\\n        "
                    },
                    {
                        "username": "mrping_11",
                        "content": "finally good old hashmap, this should be an easy problem."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer>h=new HashMap<>();\\n        int x=0;\\n        for(int i=0;i<tasks.length;i++){\\n            h.put(tasks[i],h.getOrDefault(tasks[i],0)+1);\\n        }\\n        // int i=0;\\n        int c=0;\\n        for(Map.Entry<Integer,Integer>e:h.entrySet()){\\n            if(e.getValue()==1) return -1;\\n            c+=(e.getValue()+2)/3;\\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "cswartzell",
                        "content": "ceil(freq/3)"
                    },
                    {
                        "username": "itshimashis",
                        "content": "we should make a map and store all the frequency of the numbers.\\nthen we traverse through the map ans check for every element.\\nif any element has frequency<2 then we should return at that very point . ans will be -1.\\nin a general sense an element can be picked in a multiple number of 2 and 3. lets say we take x1 turns where we pick up 2 pieces of that element and x2 turns where we take 3 pieces of that element in a go.\\n\\n\\nwe represent a equation 2*x1+3*x2=y \\nwhere y is the element\\'s frequency.  if a integer pair exists (x1,x2) that satisfies the equation, we take it. if there are a lot of that solution pair, we take the pair having the smallest sum (x1+x2). \\n \\nmy code :\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871018276/"
                    }
                ]
            },
            {
                "id": 1741069,
                "content": [
                    {
                        "username": "LiamAlsbury11",
                        "content": "My code works for all but 4 test cases (TLE). How can I optimize this piece of code? (I am a beginner).\\n\\n        tasks = sorted(tasks)\\n        t = 0\\n        h = 0\\n        for i in tasks:\\n            if h == i:\\n                continue\\n            if tasks.count(i) == 1:\\n                return -1\\n            elif tasks.count(i) == 2:\\n                t += 1\\n            elif (tasks.count(i)-1) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            elif (tasks.count(i)-2) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            else:\\n                t += (tasks.count(i)/3)\\n            h = i\\n            tasks = [z for z in tasks if z != i]\\n        return t"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "can someone please clear my doubt that why my code is showing TLE ? \\nI am using only one while loop so time comlexity is o(n)  then why TLE?\\n int minimumRounds(vector<int>& v) {\\n        int c=0;\\n        while(!v.empty()){\\n        sort(v.begin(), v.end());\\n        int co =count(v.begin(), v.end(),v[v.size()-1]);\\n        if(co==1) return -1;\\n          if (co==2 || co==4 ){\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n        if(co==3 ||  co>4){\\n            v.pop_back();\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n      \\n        \\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Oitanny](/Oitanny) Cheers!, Here's another tip: instead of using prev variable for counting, you can use the following code.\n```\nfor(int i = 0; i<n; i++)\n{\n  count = 1;\n  while(arr[i+1] == arr[i])\n    {\n      count++;\n      i++;\n    }\n  // here we get curr num as arr[i] and count as the count for currnum\n  // and can write actual logic here..\n}\n````\nThis is much neater, and is more efficient since we don't need to copy values in prev variable again and again!!"
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@sarpalmadhav](/sarpalmadhav)  Thank you so much!! Because of your suggestion i removed each occurence of count function from my code and it worked!! Keep spreading the knowledge and helping ppl in need :)"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "[@sarpalmadhav](/sarpalmadhav) thank you brother. I was unaware about the fact that count function is very expensive. thats why it is showing TLE\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Uday](/udaybhardwaj01) That\\'s not how you should count, the count function is very expensive, in each loop it will check full array. You are making this a n*n solution this way and it will give TLE for 10^5 nums. Just sort it and start from i = 0 and then move forward until the element is same, this is how you will get count for cur element.. then continue from next index, Don\\'t do this pop_back logic, even pop_back is expensive when all we have to do is read the sorted array."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "For some reason I get stack overflow and I cannot understand where it may be...\\nPlease Help!\\nLang: C++11\\n\\n`#define D (int)1e9`\\n`int minimumRounds(vector<int>& tasks) {`\\n`    int cnt[D+1], ans=0;`\\n`    for (int t:tasks) ++cnt[t];`\\n`        for (int i=1; i<=D; ++i) {`\\n`          `  `if (!cnt[i]) continue;`\\n`           `  `if (cnt[i]==1) return -1;`\\n`           `  `ans += (cnt[i]+2)/3;`\\n`    }`\\n`    return ans;`\\n`}`\\n\\nThanks in advance."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Thanks for your quick answer! My first optimization would be to find the mininum and maximum difficulties, in order to limit the lower and upper bound for the loop."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@kyriakoskourk](/kyriakoskourk), This has obvious loopholes, that #define D 1e9 is a nuclear bomb. You cant do 1e9 operations in 2 sec time limit. So that it self is big No. Also, Stack overlflow might be because you cant just right an int array of 1e9. At 4 bytes per int, you are asking for 4 GB of memory!!. As a thumb rule never declare static int array of more than 1e6 size. Regarding question, you will need to optimize approach. Read hashmaps or maybe read about how to sort and count frequencies in an array."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for easiest explanation\\nhttps://youtu.be/c--4FVRqa5g"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    \\n      class Solution:\\n         def minimumRounds(self, tasks: List[int]) -> int:\\n               tacks=Counter(tasks)\\n               if 1 in tacks.values():return -1\\n               ans=0\\n              for n in tacks.values():\\n                  ans+=n//3 + bool(n%3)\\n             return ans\\n    def minDeletionSize(strs):\\n        for j in range(len(strs[0])):\\n            res=0\\n            for i in range(len(strs)):\\n                if strs[i][j] < strs[i-1][j]:\\n                   res+=1\\n        return res \\uD83E\\uDD17\\uD83E\\uDD70\\n        "
                    },
                    {
                        "username": "varunkumarkandakatla",
                        "content": "here we need to take frequencies of tasks[i] to count the level of difficulty\\n\\nthen traverse the frequency loop and check if(freq[i]<2) return -1 \\nelse if(freq[i]>3) check remainder of freq[i]%3  if it is 0 direct add quotient to answer else add quotient+1 to answer .\\n\\nfinally return answerl\\n        "
                    },
                    {
                        "username": "mrping_11",
                        "content": "finally good old hashmap, this should be an easy problem."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer>h=new HashMap<>();\\n        int x=0;\\n        for(int i=0;i<tasks.length;i++){\\n            h.put(tasks[i],h.getOrDefault(tasks[i],0)+1);\\n        }\\n        // int i=0;\\n        int c=0;\\n        for(Map.Entry<Integer,Integer>e:h.entrySet()){\\n            if(e.getValue()==1) return -1;\\n            c+=(e.getValue()+2)/3;\\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "cswartzell",
                        "content": "ceil(freq/3)"
                    },
                    {
                        "username": "itshimashis",
                        "content": "we should make a map and store all the frequency of the numbers.\\nthen we traverse through the map ans check for every element.\\nif any element has frequency<2 then we should return at that very point . ans will be -1.\\nin a general sense an element can be picked in a multiple number of 2 and 3. lets say we take x1 turns where we pick up 2 pieces of that element and x2 turns where we take 3 pieces of that element in a go.\\n\\n\\nwe represent a equation 2*x1+3*x2=y \\nwhere y is the element\\'s frequency.  if a integer pair exists (x1,x2) that satisfies the equation, we take it. if there are a lot of that solution pair, we take the pair having the smallest sum (x1+x2). \\n \\nmy code :\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871018276/"
                    }
                ]
            },
            {
                "id": 1741035,
                "content": [
                    {
                        "username": "LiamAlsbury11",
                        "content": "My code works for all but 4 test cases (TLE). How can I optimize this piece of code? (I am a beginner).\\n\\n        tasks = sorted(tasks)\\n        t = 0\\n        h = 0\\n        for i in tasks:\\n            if h == i:\\n                continue\\n            if tasks.count(i) == 1:\\n                return -1\\n            elif tasks.count(i) == 2:\\n                t += 1\\n            elif (tasks.count(i)-1) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            elif (tasks.count(i)-2) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            else:\\n                t += (tasks.count(i)/3)\\n            h = i\\n            tasks = [z for z in tasks if z != i]\\n        return t"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "can someone please clear my doubt that why my code is showing TLE ? \\nI am using only one while loop so time comlexity is o(n)  then why TLE?\\n int minimumRounds(vector<int>& v) {\\n        int c=0;\\n        while(!v.empty()){\\n        sort(v.begin(), v.end());\\n        int co =count(v.begin(), v.end(),v[v.size()-1]);\\n        if(co==1) return -1;\\n          if (co==2 || co==4 ){\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n        if(co==3 ||  co>4){\\n            v.pop_back();\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n      \\n        \\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Oitanny](/Oitanny) Cheers!, Here's another tip: instead of using prev variable for counting, you can use the following code.\n```\nfor(int i = 0; i<n; i++)\n{\n  count = 1;\n  while(arr[i+1] == arr[i])\n    {\n      count++;\n      i++;\n    }\n  // here we get curr num as arr[i] and count as the count for currnum\n  // and can write actual logic here..\n}\n````\nThis is much neater, and is more efficient since we don't need to copy values in prev variable again and again!!"
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@sarpalmadhav](/sarpalmadhav)  Thank you so much!! Because of your suggestion i removed each occurence of count function from my code and it worked!! Keep spreading the knowledge and helping ppl in need :)"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "[@sarpalmadhav](/sarpalmadhav) thank you brother. I was unaware about the fact that count function is very expensive. thats why it is showing TLE\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Uday](/udaybhardwaj01) That\\'s not how you should count, the count function is very expensive, in each loop it will check full array. You are making this a n*n solution this way and it will give TLE for 10^5 nums. Just sort it and start from i = 0 and then move forward until the element is same, this is how you will get count for cur element.. then continue from next index, Don\\'t do this pop_back logic, even pop_back is expensive when all we have to do is read the sorted array."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "For some reason I get stack overflow and I cannot understand where it may be...\\nPlease Help!\\nLang: C++11\\n\\n`#define D (int)1e9`\\n`int minimumRounds(vector<int>& tasks) {`\\n`    int cnt[D+1], ans=0;`\\n`    for (int t:tasks) ++cnt[t];`\\n`        for (int i=1; i<=D; ++i) {`\\n`          `  `if (!cnt[i]) continue;`\\n`           `  `if (cnt[i]==1) return -1;`\\n`           `  `ans += (cnt[i]+2)/3;`\\n`    }`\\n`    return ans;`\\n`}`\\n\\nThanks in advance."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Thanks for your quick answer! My first optimization would be to find the mininum and maximum difficulties, in order to limit the lower and upper bound for the loop."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@kyriakoskourk](/kyriakoskourk), This has obvious loopholes, that #define D 1e9 is a nuclear bomb. You cant do 1e9 operations in 2 sec time limit. So that it self is big No. Also, Stack overlflow might be because you cant just right an int array of 1e9. At 4 bytes per int, you are asking for 4 GB of memory!!. As a thumb rule never declare static int array of more than 1e6 size. Regarding question, you will need to optimize approach. Read hashmaps or maybe read about how to sort and count frequencies in an array."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for easiest explanation\\nhttps://youtu.be/c--4FVRqa5g"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    \\n      class Solution:\\n         def minimumRounds(self, tasks: List[int]) -> int:\\n               tacks=Counter(tasks)\\n               if 1 in tacks.values():return -1\\n               ans=0\\n              for n in tacks.values():\\n                  ans+=n//3 + bool(n%3)\\n             return ans\\n    def minDeletionSize(strs):\\n        for j in range(len(strs[0])):\\n            res=0\\n            for i in range(len(strs)):\\n                if strs[i][j] < strs[i-1][j]:\\n                   res+=1\\n        return res \\uD83E\\uDD17\\uD83E\\uDD70\\n        "
                    },
                    {
                        "username": "varunkumarkandakatla",
                        "content": "here we need to take frequencies of tasks[i] to count the level of difficulty\\n\\nthen traverse the frequency loop and check if(freq[i]<2) return -1 \\nelse if(freq[i]>3) check remainder of freq[i]%3  if it is 0 direct add quotient to answer else add quotient+1 to answer .\\n\\nfinally return answerl\\n        "
                    },
                    {
                        "username": "mrping_11",
                        "content": "finally good old hashmap, this should be an easy problem."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer>h=new HashMap<>();\\n        int x=0;\\n        for(int i=0;i<tasks.length;i++){\\n            h.put(tasks[i],h.getOrDefault(tasks[i],0)+1);\\n        }\\n        // int i=0;\\n        int c=0;\\n        for(Map.Entry<Integer,Integer>e:h.entrySet()){\\n            if(e.getValue()==1) return -1;\\n            c+=(e.getValue()+2)/3;\\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "cswartzell",
                        "content": "ceil(freq/3)"
                    },
                    {
                        "username": "itshimashis",
                        "content": "we should make a map and store all the frequency of the numbers.\\nthen we traverse through the map ans check for every element.\\nif any element has frequency<2 then we should return at that very point . ans will be -1.\\nin a general sense an element can be picked in a multiple number of 2 and 3. lets say we take x1 turns where we pick up 2 pieces of that element and x2 turns where we take 3 pieces of that element in a go.\\n\\n\\nwe represent a equation 2*x1+3*x2=y \\nwhere y is the element\\'s frequency.  if a integer pair exists (x1,x2) that satisfies the equation, we take it. if there are a lot of that solution pair, we take the pair having the smallest sum (x1+x2). \\n \\nmy code :\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871018276/"
                    }
                ]
            },
            {
                "id": 1741008,
                "content": [
                    {
                        "username": "LiamAlsbury11",
                        "content": "My code works for all but 4 test cases (TLE). How can I optimize this piece of code? (I am a beginner).\\n\\n        tasks = sorted(tasks)\\n        t = 0\\n        h = 0\\n        for i in tasks:\\n            if h == i:\\n                continue\\n            if tasks.count(i) == 1:\\n                return -1\\n            elif tasks.count(i) == 2:\\n                t += 1\\n            elif (tasks.count(i)-1) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            elif (tasks.count(i)-2) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            else:\\n                t += (tasks.count(i)/3)\\n            h = i\\n            tasks = [z for z in tasks if z != i]\\n        return t"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "can someone please clear my doubt that why my code is showing TLE ? \\nI am using only one while loop so time comlexity is o(n)  then why TLE?\\n int minimumRounds(vector<int>& v) {\\n        int c=0;\\n        while(!v.empty()){\\n        sort(v.begin(), v.end());\\n        int co =count(v.begin(), v.end(),v[v.size()-1]);\\n        if(co==1) return -1;\\n          if (co==2 || co==4 ){\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n        if(co==3 ||  co>4){\\n            v.pop_back();\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n      \\n        \\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Oitanny](/Oitanny) Cheers!, Here's another tip: instead of using prev variable for counting, you can use the following code.\n```\nfor(int i = 0; i<n; i++)\n{\n  count = 1;\n  while(arr[i+1] == arr[i])\n    {\n      count++;\n      i++;\n    }\n  // here we get curr num as arr[i] and count as the count for currnum\n  // and can write actual logic here..\n}\n````\nThis is much neater, and is more efficient since we don't need to copy values in prev variable again and again!!"
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@sarpalmadhav](/sarpalmadhav)  Thank you so much!! Because of your suggestion i removed each occurence of count function from my code and it worked!! Keep spreading the knowledge and helping ppl in need :)"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "[@sarpalmadhav](/sarpalmadhav) thank you brother. I was unaware about the fact that count function is very expensive. thats why it is showing TLE\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Uday](/udaybhardwaj01) That\\'s not how you should count, the count function is very expensive, in each loop it will check full array. You are making this a n*n solution this way and it will give TLE for 10^5 nums. Just sort it and start from i = 0 and then move forward until the element is same, this is how you will get count for cur element.. then continue from next index, Don\\'t do this pop_back logic, even pop_back is expensive when all we have to do is read the sorted array."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "For some reason I get stack overflow and I cannot understand where it may be...\\nPlease Help!\\nLang: C++11\\n\\n`#define D (int)1e9`\\n`int minimumRounds(vector<int>& tasks) {`\\n`    int cnt[D+1], ans=0;`\\n`    for (int t:tasks) ++cnt[t];`\\n`        for (int i=1; i<=D; ++i) {`\\n`          `  `if (!cnt[i]) continue;`\\n`           `  `if (cnt[i]==1) return -1;`\\n`           `  `ans += (cnt[i]+2)/3;`\\n`    }`\\n`    return ans;`\\n`}`\\n\\nThanks in advance."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Thanks for your quick answer! My first optimization would be to find the mininum and maximum difficulties, in order to limit the lower and upper bound for the loop."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@kyriakoskourk](/kyriakoskourk), This has obvious loopholes, that #define D 1e9 is a nuclear bomb. You cant do 1e9 operations in 2 sec time limit. So that it self is big No. Also, Stack overlflow might be because you cant just right an int array of 1e9. At 4 bytes per int, you are asking for 4 GB of memory!!. As a thumb rule never declare static int array of more than 1e6 size. Regarding question, you will need to optimize approach. Read hashmaps or maybe read about how to sort and count frequencies in an array."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for easiest explanation\\nhttps://youtu.be/c--4FVRqa5g"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    \\n      class Solution:\\n         def minimumRounds(self, tasks: List[int]) -> int:\\n               tacks=Counter(tasks)\\n               if 1 in tacks.values():return -1\\n               ans=0\\n              for n in tacks.values():\\n                  ans+=n//3 + bool(n%3)\\n             return ans\\n    def minDeletionSize(strs):\\n        for j in range(len(strs[0])):\\n            res=0\\n            for i in range(len(strs)):\\n                if strs[i][j] < strs[i-1][j]:\\n                   res+=1\\n        return res \\uD83E\\uDD17\\uD83E\\uDD70\\n        "
                    },
                    {
                        "username": "varunkumarkandakatla",
                        "content": "here we need to take frequencies of tasks[i] to count the level of difficulty\\n\\nthen traverse the frequency loop and check if(freq[i]<2) return -1 \\nelse if(freq[i]>3) check remainder of freq[i]%3  if it is 0 direct add quotient to answer else add quotient+1 to answer .\\n\\nfinally return answerl\\n        "
                    },
                    {
                        "username": "mrping_11",
                        "content": "finally good old hashmap, this should be an easy problem."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer>h=new HashMap<>();\\n        int x=0;\\n        for(int i=0;i<tasks.length;i++){\\n            h.put(tasks[i],h.getOrDefault(tasks[i],0)+1);\\n        }\\n        // int i=0;\\n        int c=0;\\n        for(Map.Entry<Integer,Integer>e:h.entrySet()){\\n            if(e.getValue()==1) return -1;\\n            c+=(e.getValue()+2)/3;\\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "cswartzell",
                        "content": "ceil(freq/3)"
                    },
                    {
                        "username": "itshimashis",
                        "content": "we should make a map and store all the frequency of the numbers.\\nthen we traverse through the map ans check for every element.\\nif any element has frequency<2 then we should return at that very point . ans will be -1.\\nin a general sense an element can be picked in a multiple number of 2 and 3. lets say we take x1 turns where we pick up 2 pieces of that element and x2 turns where we take 3 pieces of that element in a go.\\n\\n\\nwe represent a equation 2*x1+3*x2=y \\nwhere y is the element\\'s frequency.  if a integer pair exists (x1,x2) that satisfies the equation, we take it. if there are a lot of that solution pair, we take the pair having the smallest sum (x1+x2). \\n \\nmy code :\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871018276/"
                    }
                ]
            },
            {
                "id": 1741002,
                "content": [
                    {
                        "username": "LiamAlsbury11",
                        "content": "My code works for all but 4 test cases (TLE). How can I optimize this piece of code? (I am a beginner).\\n\\n        tasks = sorted(tasks)\\n        t = 0\\n        h = 0\\n        for i in tasks:\\n            if h == i:\\n                continue\\n            if tasks.count(i) == 1:\\n                return -1\\n            elif tasks.count(i) == 2:\\n                t += 1\\n            elif (tasks.count(i)-1) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            elif (tasks.count(i)-2) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            else:\\n                t += (tasks.count(i)/3)\\n            h = i\\n            tasks = [z for z in tasks if z != i]\\n        return t"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "can someone please clear my doubt that why my code is showing TLE ? \\nI am using only one while loop so time comlexity is o(n)  then why TLE?\\n int minimumRounds(vector<int>& v) {\\n        int c=0;\\n        while(!v.empty()){\\n        sort(v.begin(), v.end());\\n        int co =count(v.begin(), v.end(),v[v.size()-1]);\\n        if(co==1) return -1;\\n          if (co==2 || co==4 ){\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n        if(co==3 ||  co>4){\\n            v.pop_back();\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n      \\n        \\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Oitanny](/Oitanny) Cheers!, Here's another tip: instead of using prev variable for counting, you can use the following code.\n```\nfor(int i = 0; i<n; i++)\n{\n  count = 1;\n  while(arr[i+1] == arr[i])\n    {\n      count++;\n      i++;\n    }\n  // here we get curr num as arr[i] and count as the count for currnum\n  // and can write actual logic here..\n}\n````\nThis is much neater, and is more efficient since we don't need to copy values in prev variable again and again!!"
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@sarpalmadhav](/sarpalmadhav)  Thank you so much!! Because of your suggestion i removed each occurence of count function from my code and it worked!! Keep spreading the knowledge and helping ppl in need :)"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "[@sarpalmadhav](/sarpalmadhav) thank you brother. I was unaware about the fact that count function is very expensive. thats why it is showing TLE\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Uday](/udaybhardwaj01) That\\'s not how you should count, the count function is very expensive, in each loop it will check full array. You are making this a n*n solution this way and it will give TLE for 10^5 nums. Just sort it and start from i = 0 and then move forward until the element is same, this is how you will get count for cur element.. then continue from next index, Don\\'t do this pop_back logic, even pop_back is expensive when all we have to do is read the sorted array."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "For some reason I get stack overflow and I cannot understand where it may be...\\nPlease Help!\\nLang: C++11\\n\\n`#define D (int)1e9`\\n`int minimumRounds(vector<int>& tasks) {`\\n`    int cnt[D+1], ans=0;`\\n`    for (int t:tasks) ++cnt[t];`\\n`        for (int i=1; i<=D; ++i) {`\\n`          `  `if (!cnt[i]) continue;`\\n`           `  `if (cnt[i]==1) return -1;`\\n`           `  `ans += (cnt[i]+2)/3;`\\n`    }`\\n`    return ans;`\\n`}`\\n\\nThanks in advance."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Thanks for your quick answer! My first optimization would be to find the mininum and maximum difficulties, in order to limit the lower and upper bound for the loop."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@kyriakoskourk](/kyriakoskourk), This has obvious loopholes, that #define D 1e9 is a nuclear bomb. You cant do 1e9 operations in 2 sec time limit. So that it self is big No. Also, Stack overlflow might be because you cant just right an int array of 1e9. At 4 bytes per int, you are asking for 4 GB of memory!!. As a thumb rule never declare static int array of more than 1e6 size. Regarding question, you will need to optimize approach. Read hashmaps or maybe read about how to sort and count frequencies in an array."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for easiest explanation\\nhttps://youtu.be/c--4FVRqa5g"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    \\n      class Solution:\\n         def minimumRounds(self, tasks: List[int]) -> int:\\n               tacks=Counter(tasks)\\n               if 1 in tacks.values():return -1\\n               ans=0\\n              for n in tacks.values():\\n                  ans+=n//3 + bool(n%3)\\n             return ans\\n    def minDeletionSize(strs):\\n        for j in range(len(strs[0])):\\n            res=0\\n            for i in range(len(strs)):\\n                if strs[i][j] < strs[i-1][j]:\\n                   res+=1\\n        return res \\uD83E\\uDD17\\uD83E\\uDD70\\n        "
                    },
                    {
                        "username": "varunkumarkandakatla",
                        "content": "here we need to take frequencies of tasks[i] to count the level of difficulty\\n\\nthen traverse the frequency loop and check if(freq[i]<2) return -1 \\nelse if(freq[i]>3) check remainder of freq[i]%3  if it is 0 direct add quotient to answer else add quotient+1 to answer .\\n\\nfinally return answerl\\n        "
                    },
                    {
                        "username": "mrping_11",
                        "content": "finally good old hashmap, this should be an easy problem."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer>h=new HashMap<>();\\n        int x=0;\\n        for(int i=0;i<tasks.length;i++){\\n            h.put(tasks[i],h.getOrDefault(tasks[i],0)+1);\\n        }\\n        // int i=0;\\n        int c=0;\\n        for(Map.Entry<Integer,Integer>e:h.entrySet()){\\n            if(e.getValue()==1) return -1;\\n            c+=(e.getValue()+2)/3;\\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "cswartzell",
                        "content": "ceil(freq/3)"
                    },
                    {
                        "username": "itshimashis",
                        "content": "we should make a map and store all the frequency of the numbers.\\nthen we traverse through the map ans check for every element.\\nif any element has frequency<2 then we should return at that very point . ans will be -1.\\nin a general sense an element can be picked in a multiple number of 2 and 3. lets say we take x1 turns where we pick up 2 pieces of that element and x2 turns where we take 3 pieces of that element in a go.\\n\\n\\nwe represent a equation 2*x1+3*x2=y \\nwhere y is the element\\'s frequency.  if a integer pair exists (x1,x2) that satisfies the equation, we take it. if there are a lot of that solution pair, we take the pair having the smallest sum (x1+x2). \\n \\nmy code :\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871018276/"
                    }
                ]
            },
            {
                "id": 1740989,
                "content": [
                    {
                        "username": "LiamAlsbury11",
                        "content": "My code works for all but 4 test cases (TLE). How can I optimize this piece of code? (I am a beginner).\\n\\n        tasks = sorted(tasks)\\n        t = 0\\n        h = 0\\n        for i in tasks:\\n            if h == i:\\n                continue\\n            if tasks.count(i) == 1:\\n                return -1\\n            elif tasks.count(i) == 2:\\n                t += 1\\n            elif (tasks.count(i)-1) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            elif (tasks.count(i)-2) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            else:\\n                t += (tasks.count(i)/3)\\n            h = i\\n            tasks = [z for z in tasks if z != i]\\n        return t"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "can someone please clear my doubt that why my code is showing TLE ? \\nI am using only one while loop so time comlexity is o(n)  then why TLE?\\n int minimumRounds(vector<int>& v) {\\n        int c=0;\\n        while(!v.empty()){\\n        sort(v.begin(), v.end());\\n        int co =count(v.begin(), v.end(),v[v.size()-1]);\\n        if(co==1) return -1;\\n          if (co==2 || co==4 ){\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n        if(co==3 ||  co>4){\\n            v.pop_back();\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n      \\n        \\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Oitanny](/Oitanny) Cheers!, Here's another tip: instead of using prev variable for counting, you can use the following code.\n```\nfor(int i = 0; i<n; i++)\n{\n  count = 1;\n  while(arr[i+1] == arr[i])\n    {\n      count++;\n      i++;\n    }\n  // here we get curr num as arr[i] and count as the count for currnum\n  // and can write actual logic here..\n}\n````\nThis is much neater, and is more efficient since we don't need to copy values in prev variable again and again!!"
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@sarpalmadhav](/sarpalmadhav)  Thank you so much!! Because of your suggestion i removed each occurence of count function from my code and it worked!! Keep spreading the knowledge and helping ppl in need :)"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "[@sarpalmadhav](/sarpalmadhav) thank you brother. I was unaware about the fact that count function is very expensive. thats why it is showing TLE\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Uday](/udaybhardwaj01) That\\'s not how you should count, the count function is very expensive, in each loop it will check full array. You are making this a n*n solution this way and it will give TLE for 10^5 nums. Just sort it and start from i = 0 and then move forward until the element is same, this is how you will get count for cur element.. then continue from next index, Don\\'t do this pop_back logic, even pop_back is expensive when all we have to do is read the sorted array."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "For some reason I get stack overflow and I cannot understand where it may be...\\nPlease Help!\\nLang: C++11\\n\\n`#define D (int)1e9`\\n`int minimumRounds(vector<int>& tasks) {`\\n`    int cnt[D+1], ans=0;`\\n`    for (int t:tasks) ++cnt[t];`\\n`        for (int i=1; i<=D; ++i) {`\\n`          `  `if (!cnt[i]) continue;`\\n`           `  `if (cnt[i]==1) return -1;`\\n`           `  `ans += (cnt[i]+2)/3;`\\n`    }`\\n`    return ans;`\\n`}`\\n\\nThanks in advance."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Thanks for your quick answer! My first optimization would be to find the mininum and maximum difficulties, in order to limit the lower and upper bound for the loop."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@kyriakoskourk](/kyriakoskourk), This has obvious loopholes, that #define D 1e9 is a nuclear bomb. You cant do 1e9 operations in 2 sec time limit. So that it self is big No. Also, Stack overlflow might be because you cant just right an int array of 1e9. At 4 bytes per int, you are asking for 4 GB of memory!!. As a thumb rule never declare static int array of more than 1e6 size. Regarding question, you will need to optimize approach. Read hashmaps or maybe read about how to sort and count frequencies in an array."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for easiest explanation\\nhttps://youtu.be/c--4FVRqa5g"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    \\n      class Solution:\\n         def minimumRounds(self, tasks: List[int]) -> int:\\n               tacks=Counter(tasks)\\n               if 1 in tacks.values():return -1\\n               ans=0\\n              for n in tacks.values():\\n                  ans+=n//3 + bool(n%3)\\n             return ans\\n    def minDeletionSize(strs):\\n        for j in range(len(strs[0])):\\n            res=0\\n            for i in range(len(strs)):\\n                if strs[i][j] < strs[i-1][j]:\\n                   res+=1\\n        return res \\uD83E\\uDD17\\uD83E\\uDD70\\n        "
                    },
                    {
                        "username": "varunkumarkandakatla",
                        "content": "here we need to take frequencies of tasks[i] to count the level of difficulty\\n\\nthen traverse the frequency loop and check if(freq[i]<2) return -1 \\nelse if(freq[i]>3) check remainder of freq[i]%3  if it is 0 direct add quotient to answer else add quotient+1 to answer .\\n\\nfinally return answerl\\n        "
                    },
                    {
                        "username": "mrping_11",
                        "content": "finally good old hashmap, this should be an easy problem."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer>h=new HashMap<>();\\n        int x=0;\\n        for(int i=0;i<tasks.length;i++){\\n            h.put(tasks[i],h.getOrDefault(tasks[i],0)+1);\\n        }\\n        // int i=0;\\n        int c=0;\\n        for(Map.Entry<Integer,Integer>e:h.entrySet()){\\n            if(e.getValue()==1) return -1;\\n            c+=(e.getValue()+2)/3;\\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "cswartzell",
                        "content": "ceil(freq/3)"
                    },
                    {
                        "username": "itshimashis",
                        "content": "we should make a map and store all the frequency of the numbers.\\nthen we traverse through the map ans check for every element.\\nif any element has frequency<2 then we should return at that very point . ans will be -1.\\nin a general sense an element can be picked in a multiple number of 2 and 3. lets say we take x1 turns where we pick up 2 pieces of that element and x2 turns where we take 3 pieces of that element in a go.\\n\\n\\nwe represent a equation 2*x1+3*x2=y \\nwhere y is the element\\'s frequency.  if a integer pair exists (x1,x2) that satisfies the equation, we take it. if there are a lot of that solution pair, we take the pair having the smallest sum (x1+x2). \\n \\nmy code :\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871018276/"
                    }
                ]
            },
            {
                "id": 1740984,
                "content": [
                    {
                        "username": "LiamAlsbury11",
                        "content": "My code works for all but 4 test cases (TLE). How can I optimize this piece of code? (I am a beginner).\\n\\n        tasks = sorted(tasks)\\n        t = 0\\n        h = 0\\n        for i in tasks:\\n            if h == i:\\n                continue\\n            if tasks.count(i) == 1:\\n                return -1\\n            elif tasks.count(i) == 2:\\n                t += 1\\n            elif (tasks.count(i)-1) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            elif (tasks.count(i)-2) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            else:\\n                t += (tasks.count(i)/3)\\n            h = i\\n            tasks = [z for z in tasks if z != i]\\n        return t"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "can someone please clear my doubt that why my code is showing TLE ? \\nI am using only one while loop so time comlexity is o(n)  then why TLE?\\n int minimumRounds(vector<int>& v) {\\n        int c=0;\\n        while(!v.empty()){\\n        sort(v.begin(), v.end());\\n        int co =count(v.begin(), v.end(),v[v.size()-1]);\\n        if(co==1) return -1;\\n          if (co==2 || co==4 ){\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n        if(co==3 ||  co>4){\\n            v.pop_back();\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n      \\n        \\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Oitanny](/Oitanny) Cheers!, Here's another tip: instead of using prev variable for counting, you can use the following code.\n```\nfor(int i = 0; i<n; i++)\n{\n  count = 1;\n  while(arr[i+1] == arr[i])\n    {\n      count++;\n      i++;\n    }\n  // here we get curr num as arr[i] and count as the count for currnum\n  // and can write actual logic here..\n}\n````\nThis is much neater, and is more efficient since we don't need to copy values in prev variable again and again!!"
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@sarpalmadhav](/sarpalmadhav)  Thank you so much!! Because of your suggestion i removed each occurence of count function from my code and it worked!! Keep spreading the knowledge and helping ppl in need :)"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "[@sarpalmadhav](/sarpalmadhav) thank you brother. I was unaware about the fact that count function is very expensive. thats why it is showing TLE\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Uday](/udaybhardwaj01) That\\'s not how you should count, the count function is very expensive, in each loop it will check full array. You are making this a n*n solution this way and it will give TLE for 10^5 nums. Just sort it and start from i = 0 and then move forward until the element is same, this is how you will get count for cur element.. then continue from next index, Don\\'t do this pop_back logic, even pop_back is expensive when all we have to do is read the sorted array."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "For some reason I get stack overflow and I cannot understand where it may be...\\nPlease Help!\\nLang: C++11\\n\\n`#define D (int)1e9`\\n`int minimumRounds(vector<int>& tasks) {`\\n`    int cnt[D+1], ans=0;`\\n`    for (int t:tasks) ++cnt[t];`\\n`        for (int i=1; i<=D; ++i) {`\\n`          `  `if (!cnt[i]) continue;`\\n`           `  `if (cnt[i]==1) return -1;`\\n`           `  `ans += (cnt[i]+2)/3;`\\n`    }`\\n`    return ans;`\\n`}`\\n\\nThanks in advance."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Thanks for your quick answer! My first optimization would be to find the mininum and maximum difficulties, in order to limit the lower and upper bound for the loop."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@kyriakoskourk](/kyriakoskourk), This has obvious loopholes, that #define D 1e9 is a nuclear bomb. You cant do 1e9 operations in 2 sec time limit. So that it self is big No. Also, Stack overlflow might be because you cant just right an int array of 1e9. At 4 bytes per int, you are asking for 4 GB of memory!!. As a thumb rule never declare static int array of more than 1e6 size. Regarding question, you will need to optimize approach. Read hashmaps or maybe read about how to sort and count frequencies in an array."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for easiest explanation\\nhttps://youtu.be/c--4FVRqa5g"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    \\n      class Solution:\\n         def minimumRounds(self, tasks: List[int]) -> int:\\n               tacks=Counter(tasks)\\n               if 1 in tacks.values():return -1\\n               ans=0\\n              for n in tacks.values():\\n                  ans+=n//3 + bool(n%3)\\n             return ans\\n    def minDeletionSize(strs):\\n        for j in range(len(strs[0])):\\n            res=0\\n            for i in range(len(strs)):\\n                if strs[i][j] < strs[i-1][j]:\\n                   res+=1\\n        return res \\uD83E\\uDD17\\uD83E\\uDD70\\n        "
                    },
                    {
                        "username": "varunkumarkandakatla",
                        "content": "here we need to take frequencies of tasks[i] to count the level of difficulty\\n\\nthen traverse the frequency loop and check if(freq[i]<2) return -1 \\nelse if(freq[i]>3) check remainder of freq[i]%3  if it is 0 direct add quotient to answer else add quotient+1 to answer .\\n\\nfinally return answerl\\n        "
                    },
                    {
                        "username": "mrping_11",
                        "content": "finally good old hashmap, this should be an easy problem."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer>h=new HashMap<>();\\n        int x=0;\\n        for(int i=0;i<tasks.length;i++){\\n            h.put(tasks[i],h.getOrDefault(tasks[i],0)+1);\\n        }\\n        // int i=0;\\n        int c=0;\\n        for(Map.Entry<Integer,Integer>e:h.entrySet()){\\n            if(e.getValue()==1) return -1;\\n            c+=(e.getValue()+2)/3;\\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "cswartzell",
                        "content": "ceil(freq/3)"
                    },
                    {
                        "username": "itshimashis",
                        "content": "we should make a map and store all the frequency of the numbers.\\nthen we traverse through the map ans check for every element.\\nif any element has frequency<2 then we should return at that very point . ans will be -1.\\nin a general sense an element can be picked in a multiple number of 2 and 3. lets say we take x1 turns where we pick up 2 pieces of that element and x2 turns where we take 3 pieces of that element in a go.\\n\\n\\nwe represent a equation 2*x1+3*x2=y \\nwhere y is the element\\'s frequency.  if a integer pair exists (x1,x2) that satisfies the equation, we take it. if there are a lot of that solution pair, we take the pair having the smallest sum (x1+x2). \\n \\nmy code :\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871018276/"
                    }
                ]
            },
            {
                "id": 1740967,
                "content": [
                    {
                        "username": "LiamAlsbury11",
                        "content": "My code works for all but 4 test cases (TLE). How can I optimize this piece of code? (I am a beginner).\\n\\n        tasks = sorted(tasks)\\n        t = 0\\n        h = 0\\n        for i in tasks:\\n            if h == i:\\n                continue\\n            if tasks.count(i) == 1:\\n                return -1\\n            elif tasks.count(i) == 2:\\n                t += 1\\n            elif (tasks.count(i)-1) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            elif (tasks.count(i)-2) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            else:\\n                t += (tasks.count(i)/3)\\n            h = i\\n            tasks = [z for z in tasks if z != i]\\n        return t"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "can someone please clear my doubt that why my code is showing TLE ? \\nI am using only one while loop so time comlexity is o(n)  then why TLE?\\n int minimumRounds(vector<int>& v) {\\n        int c=0;\\n        while(!v.empty()){\\n        sort(v.begin(), v.end());\\n        int co =count(v.begin(), v.end(),v[v.size()-1]);\\n        if(co==1) return -1;\\n          if (co==2 || co==4 ){\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n        if(co==3 ||  co>4){\\n            v.pop_back();\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n      \\n        \\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Oitanny](/Oitanny) Cheers!, Here's another tip: instead of using prev variable for counting, you can use the following code.\n```\nfor(int i = 0; i<n; i++)\n{\n  count = 1;\n  while(arr[i+1] == arr[i])\n    {\n      count++;\n      i++;\n    }\n  // here we get curr num as arr[i] and count as the count for currnum\n  // and can write actual logic here..\n}\n````\nThis is much neater, and is more efficient since we don't need to copy values in prev variable again and again!!"
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@sarpalmadhav](/sarpalmadhav)  Thank you so much!! Because of your suggestion i removed each occurence of count function from my code and it worked!! Keep spreading the knowledge and helping ppl in need :)"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "[@sarpalmadhav](/sarpalmadhav) thank you brother. I was unaware about the fact that count function is very expensive. thats why it is showing TLE\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Uday](/udaybhardwaj01) That\\'s not how you should count, the count function is very expensive, in each loop it will check full array. You are making this a n*n solution this way and it will give TLE for 10^5 nums. Just sort it and start from i = 0 and then move forward until the element is same, this is how you will get count for cur element.. then continue from next index, Don\\'t do this pop_back logic, even pop_back is expensive when all we have to do is read the sorted array."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "For some reason I get stack overflow and I cannot understand where it may be...\\nPlease Help!\\nLang: C++11\\n\\n`#define D (int)1e9`\\n`int minimumRounds(vector<int>& tasks) {`\\n`    int cnt[D+1], ans=0;`\\n`    for (int t:tasks) ++cnt[t];`\\n`        for (int i=1; i<=D; ++i) {`\\n`          `  `if (!cnt[i]) continue;`\\n`           `  `if (cnt[i]==1) return -1;`\\n`           `  `ans += (cnt[i]+2)/3;`\\n`    }`\\n`    return ans;`\\n`}`\\n\\nThanks in advance."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Thanks for your quick answer! My first optimization would be to find the mininum and maximum difficulties, in order to limit the lower and upper bound for the loop."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@kyriakoskourk](/kyriakoskourk), This has obvious loopholes, that #define D 1e9 is a nuclear bomb. You cant do 1e9 operations in 2 sec time limit. So that it self is big No. Also, Stack overlflow might be because you cant just right an int array of 1e9. At 4 bytes per int, you are asking for 4 GB of memory!!. As a thumb rule never declare static int array of more than 1e6 size. Regarding question, you will need to optimize approach. Read hashmaps or maybe read about how to sort and count frequencies in an array."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for easiest explanation\\nhttps://youtu.be/c--4FVRqa5g"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    \\n      class Solution:\\n         def minimumRounds(self, tasks: List[int]) -> int:\\n               tacks=Counter(tasks)\\n               if 1 in tacks.values():return -1\\n               ans=0\\n              for n in tacks.values():\\n                  ans+=n//3 + bool(n%3)\\n             return ans\\n    def minDeletionSize(strs):\\n        for j in range(len(strs[0])):\\n            res=0\\n            for i in range(len(strs)):\\n                if strs[i][j] < strs[i-1][j]:\\n                   res+=1\\n        return res \\uD83E\\uDD17\\uD83E\\uDD70\\n        "
                    },
                    {
                        "username": "varunkumarkandakatla",
                        "content": "here we need to take frequencies of tasks[i] to count the level of difficulty\\n\\nthen traverse the frequency loop and check if(freq[i]<2) return -1 \\nelse if(freq[i]>3) check remainder of freq[i]%3  if it is 0 direct add quotient to answer else add quotient+1 to answer .\\n\\nfinally return answerl\\n        "
                    },
                    {
                        "username": "mrping_11",
                        "content": "finally good old hashmap, this should be an easy problem."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer>h=new HashMap<>();\\n        int x=0;\\n        for(int i=0;i<tasks.length;i++){\\n            h.put(tasks[i],h.getOrDefault(tasks[i],0)+1);\\n        }\\n        // int i=0;\\n        int c=0;\\n        for(Map.Entry<Integer,Integer>e:h.entrySet()){\\n            if(e.getValue()==1) return -1;\\n            c+=(e.getValue()+2)/3;\\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "cswartzell",
                        "content": "ceil(freq/3)"
                    },
                    {
                        "username": "itshimashis",
                        "content": "we should make a map and store all the frequency of the numbers.\\nthen we traverse through the map ans check for every element.\\nif any element has frequency<2 then we should return at that very point . ans will be -1.\\nin a general sense an element can be picked in a multiple number of 2 and 3. lets say we take x1 turns where we pick up 2 pieces of that element and x2 turns where we take 3 pieces of that element in a go.\\n\\n\\nwe represent a equation 2*x1+3*x2=y \\nwhere y is the element\\'s frequency.  if a integer pair exists (x1,x2) that satisfies the equation, we take it. if there are a lot of that solution pair, we take the pair having the smallest sum (x1+x2). \\n \\nmy code :\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871018276/"
                    }
                ]
            },
            {
                "id": 1740953,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Its more of a Math topic problem may be."
                    },
                    {
                        "username": "PulkitAgga01",
                        "content": "From observation, we can see that there\\'s only 3 possible outcomes.\\n1. If the frequency is 1, the task cannot be performed so we return -1.\\n2. If the frequency is 3, the task can be performed and we return frequency/3.\\n3. Now if the frequency is not completely divisible by 3, then we can return frequency/3 +1."
                    },
                    {
                        "username": "IamAJ22",
                        "content": "I am gonna code every single day in this year #resolution"
                    },
                    {
                        "username": "loknadh_reddy",
                        "content": "is there no way to solve it using brute force without TLE ?\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996141/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Just use table of 3 and think along its remainders."
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good after tackling a greedy one :)"
                    },
                    {
                        "username": "prasadpreetish",
                        "content": "Hey I stored the frequencies in a HashMap and then I found the same pattern of the minwork i.e. if f =1 return -1 if f=2 || f=3 return 1 but I am not able to get this intution that minwork+= (f+2)/3; how to get this type of thinking. I mean how do I develop the skills to get through such thought process.\\n\\n`    // frequencies       [1,2,3,4,5,6,7,8,9]`\\n\\n`   // minwork return   [-1,1,1,2,2,2,3,3,3]`\\n\\nI was getting this pattern but didn\\'t get the formula sadly."
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "You don\\'t have to it will develope automatically just practice as many questions as possible \\nHere is my solution which is similar to climbing stairs problem or coin change problem:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Count frequency in a hash-map.\\n2. Sum up (frequency + 2) / 3."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Santanu Sen](/santanusen) That\\'s one way of giving the full answer in as little words as possible! This is a perfect spoiler for those who have not thought about it, but I like the brevity!!"
                    },
                    {
                        "username": "omscode",
                        "content": "really help , thanks!!"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Well we can solve this problem using dp ( top down approach) \n"
                    }
                ]
            },
            {
                "id": 1740948,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Its more of a Math topic problem may be."
                    },
                    {
                        "username": "PulkitAgga01",
                        "content": "From observation, we can see that there\\'s only 3 possible outcomes.\\n1. If the frequency is 1, the task cannot be performed so we return -1.\\n2. If the frequency is 3, the task can be performed and we return frequency/3.\\n3. Now if the frequency is not completely divisible by 3, then we can return frequency/3 +1."
                    },
                    {
                        "username": "IamAJ22",
                        "content": "I am gonna code every single day in this year #resolution"
                    },
                    {
                        "username": "loknadh_reddy",
                        "content": "is there no way to solve it using brute force without TLE ?\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996141/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Just use table of 3 and think along its remainders."
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good after tackling a greedy one :)"
                    },
                    {
                        "username": "prasadpreetish",
                        "content": "Hey I stored the frequencies in a HashMap and then I found the same pattern of the minwork i.e. if f =1 return -1 if f=2 || f=3 return 1 but I am not able to get this intution that minwork+= (f+2)/3; how to get this type of thinking. I mean how do I develop the skills to get through such thought process.\\n\\n`    // frequencies       [1,2,3,4,5,6,7,8,9]`\\n\\n`   // minwork return   [-1,1,1,2,2,2,3,3,3]`\\n\\nI was getting this pattern but didn\\'t get the formula sadly."
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "You don\\'t have to it will develope automatically just practice as many questions as possible \\nHere is my solution which is similar to climbing stairs problem or coin change problem:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Count frequency in a hash-map.\\n2. Sum up (frequency + 2) / 3."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Santanu Sen](/santanusen) That\\'s one way of giving the full answer in as little words as possible! This is a perfect spoiler for those who have not thought about it, but I like the brevity!!"
                    },
                    {
                        "username": "omscode",
                        "content": "really help , thanks!!"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Well we can solve this problem using dp ( top down approach) \n"
                    }
                ]
            },
            {
                "id": 1740893,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Its more of a Math topic problem may be."
                    },
                    {
                        "username": "PulkitAgga01",
                        "content": "From observation, we can see that there\\'s only 3 possible outcomes.\\n1. If the frequency is 1, the task cannot be performed so we return -1.\\n2. If the frequency is 3, the task can be performed and we return frequency/3.\\n3. Now if the frequency is not completely divisible by 3, then we can return frequency/3 +1."
                    },
                    {
                        "username": "IamAJ22",
                        "content": "I am gonna code every single day in this year #resolution"
                    },
                    {
                        "username": "loknadh_reddy",
                        "content": "is there no way to solve it using brute force without TLE ?\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996141/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Just use table of 3 and think along its remainders."
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good after tackling a greedy one :)"
                    },
                    {
                        "username": "prasadpreetish",
                        "content": "Hey I stored the frequencies in a HashMap and then I found the same pattern of the minwork i.e. if f =1 return -1 if f=2 || f=3 return 1 but I am not able to get this intution that minwork+= (f+2)/3; how to get this type of thinking. I mean how do I develop the skills to get through such thought process.\\n\\n`    // frequencies       [1,2,3,4,5,6,7,8,9]`\\n\\n`   // minwork return   [-1,1,1,2,2,2,3,3,3]`\\n\\nI was getting this pattern but didn\\'t get the formula sadly."
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "You don\\'t have to it will develope automatically just practice as many questions as possible \\nHere is my solution which is similar to climbing stairs problem or coin change problem:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Count frequency in a hash-map.\\n2. Sum up (frequency + 2) / 3."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Santanu Sen](/santanusen) That\\'s one way of giving the full answer in as little words as possible! This is a perfect spoiler for those who have not thought about it, but I like the brevity!!"
                    },
                    {
                        "username": "omscode",
                        "content": "really help , thanks!!"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Well we can solve this problem using dp ( top down approach) \n"
                    }
                ]
            },
            {
                "id": 1740888,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Its more of a Math topic problem may be."
                    },
                    {
                        "username": "PulkitAgga01",
                        "content": "From observation, we can see that there\\'s only 3 possible outcomes.\\n1. If the frequency is 1, the task cannot be performed so we return -1.\\n2. If the frequency is 3, the task can be performed and we return frequency/3.\\n3. Now if the frequency is not completely divisible by 3, then we can return frequency/3 +1."
                    },
                    {
                        "username": "IamAJ22",
                        "content": "I am gonna code every single day in this year #resolution"
                    },
                    {
                        "username": "loknadh_reddy",
                        "content": "is there no way to solve it using brute force without TLE ?\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996141/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Just use table of 3 and think along its remainders."
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good after tackling a greedy one :)"
                    },
                    {
                        "username": "prasadpreetish",
                        "content": "Hey I stored the frequencies in a HashMap and then I found the same pattern of the minwork i.e. if f =1 return -1 if f=2 || f=3 return 1 but I am not able to get this intution that minwork+= (f+2)/3; how to get this type of thinking. I mean how do I develop the skills to get through such thought process.\\n\\n`    // frequencies       [1,2,3,4,5,6,7,8,9]`\\n\\n`   // minwork return   [-1,1,1,2,2,2,3,3,3]`\\n\\nI was getting this pattern but didn\\'t get the formula sadly."
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "You don\\'t have to it will develope automatically just practice as many questions as possible \\nHere is my solution which is similar to climbing stairs problem or coin change problem:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Count frequency in a hash-map.\\n2. Sum up (frequency + 2) / 3."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Santanu Sen](/santanusen) That\\'s one way of giving the full answer in as little words as possible! This is a perfect spoiler for those who have not thought about it, but I like the brevity!!"
                    },
                    {
                        "username": "omscode",
                        "content": "really help , thanks!!"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Well we can solve this problem using dp ( top down approach) \n"
                    }
                ]
            },
            {
                "id": 1740876,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Its more of a Math topic problem may be."
                    },
                    {
                        "username": "PulkitAgga01",
                        "content": "From observation, we can see that there\\'s only 3 possible outcomes.\\n1. If the frequency is 1, the task cannot be performed so we return -1.\\n2. If the frequency is 3, the task can be performed and we return frequency/3.\\n3. Now if the frequency is not completely divisible by 3, then we can return frequency/3 +1."
                    },
                    {
                        "username": "IamAJ22",
                        "content": "I am gonna code every single day in this year #resolution"
                    },
                    {
                        "username": "loknadh_reddy",
                        "content": "is there no way to solve it using brute force without TLE ?\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996141/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Just use table of 3 and think along its remainders."
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good after tackling a greedy one :)"
                    },
                    {
                        "username": "prasadpreetish",
                        "content": "Hey I stored the frequencies in a HashMap and then I found the same pattern of the minwork i.e. if f =1 return -1 if f=2 || f=3 return 1 but I am not able to get this intution that minwork+= (f+2)/3; how to get this type of thinking. I mean how do I develop the skills to get through such thought process.\\n\\n`    // frequencies       [1,2,3,4,5,6,7,8,9]`\\n\\n`   // minwork return   [-1,1,1,2,2,2,3,3,3]`\\n\\nI was getting this pattern but didn\\'t get the formula sadly."
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "You don\\'t have to it will develope automatically just practice as many questions as possible \\nHere is my solution which is similar to climbing stairs problem or coin change problem:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Count frequency in a hash-map.\\n2. Sum up (frequency + 2) / 3."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Santanu Sen](/santanusen) That\\'s one way of giving the full answer in as little words as possible! This is a perfect spoiler for those who have not thought about it, but I like the brevity!!"
                    },
                    {
                        "username": "omscode",
                        "content": "really help , thanks!!"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Well we can solve this problem using dp ( top down approach) \n"
                    }
                ]
            },
            {
                "id": 1740860,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Its more of a Math topic problem may be."
                    },
                    {
                        "username": "PulkitAgga01",
                        "content": "From observation, we can see that there\\'s only 3 possible outcomes.\\n1. If the frequency is 1, the task cannot be performed so we return -1.\\n2. If the frequency is 3, the task can be performed and we return frequency/3.\\n3. Now if the frequency is not completely divisible by 3, then we can return frequency/3 +1."
                    },
                    {
                        "username": "IamAJ22",
                        "content": "I am gonna code every single day in this year #resolution"
                    },
                    {
                        "username": "loknadh_reddy",
                        "content": "is there no way to solve it using brute force without TLE ?\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996141/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Just use table of 3 and think along its remainders."
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good after tackling a greedy one :)"
                    },
                    {
                        "username": "prasadpreetish",
                        "content": "Hey I stored the frequencies in a HashMap and then I found the same pattern of the minwork i.e. if f =1 return -1 if f=2 || f=3 return 1 but I am not able to get this intution that minwork+= (f+2)/3; how to get this type of thinking. I mean how do I develop the skills to get through such thought process.\\n\\n`    // frequencies       [1,2,3,4,5,6,7,8,9]`\\n\\n`   // minwork return   [-1,1,1,2,2,2,3,3,3]`\\n\\nI was getting this pattern but didn\\'t get the formula sadly."
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "You don\\'t have to it will develope automatically just practice as many questions as possible \\nHere is my solution which is similar to climbing stairs problem or coin change problem:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Count frequency in a hash-map.\\n2. Sum up (frequency + 2) / 3."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Santanu Sen](/santanusen) That\\'s one way of giving the full answer in as little words as possible! This is a perfect spoiler for those who have not thought about it, but I like the brevity!!"
                    },
                    {
                        "username": "omscode",
                        "content": "really help , thanks!!"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Well we can solve this problem using dp ( top down approach) \n"
                    }
                ]
            },
            {
                "id": 1740838,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Its more of a Math topic problem may be."
                    },
                    {
                        "username": "PulkitAgga01",
                        "content": "From observation, we can see that there\\'s only 3 possible outcomes.\\n1. If the frequency is 1, the task cannot be performed so we return -1.\\n2. If the frequency is 3, the task can be performed and we return frequency/3.\\n3. Now if the frequency is not completely divisible by 3, then we can return frequency/3 +1."
                    },
                    {
                        "username": "IamAJ22",
                        "content": "I am gonna code every single day in this year #resolution"
                    },
                    {
                        "username": "loknadh_reddy",
                        "content": "is there no way to solve it using brute force without TLE ?\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996141/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Just use table of 3 and think along its remainders."
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good after tackling a greedy one :)"
                    },
                    {
                        "username": "prasadpreetish",
                        "content": "Hey I stored the frequencies in a HashMap and then I found the same pattern of the minwork i.e. if f =1 return -1 if f=2 || f=3 return 1 but I am not able to get this intution that minwork+= (f+2)/3; how to get this type of thinking. I mean how do I develop the skills to get through such thought process.\\n\\n`    // frequencies       [1,2,3,4,5,6,7,8,9]`\\n\\n`   // minwork return   [-1,1,1,2,2,2,3,3,3]`\\n\\nI was getting this pattern but didn\\'t get the formula sadly."
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "You don\\'t have to it will develope automatically just practice as many questions as possible \\nHere is my solution which is similar to climbing stairs problem or coin change problem:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Count frequency in a hash-map.\\n2. Sum up (frequency + 2) / 3."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Santanu Sen](/santanusen) That\\'s one way of giving the full answer in as little words as possible! This is a perfect spoiler for those who have not thought about it, but I like the brevity!!"
                    },
                    {
                        "username": "omscode",
                        "content": "really help , thanks!!"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Well we can solve this problem using dp ( top down approach) \n"
                    }
                ]
            },
            {
                "id": 1740825,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Its more of a Math topic problem may be."
                    },
                    {
                        "username": "PulkitAgga01",
                        "content": "From observation, we can see that there\\'s only 3 possible outcomes.\\n1. If the frequency is 1, the task cannot be performed so we return -1.\\n2. If the frequency is 3, the task can be performed and we return frequency/3.\\n3. Now if the frequency is not completely divisible by 3, then we can return frequency/3 +1."
                    },
                    {
                        "username": "IamAJ22",
                        "content": "I am gonna code every single day in this year #resolution"
                    },
                    {
                        "username": "loknadh_reddy",
                        "content": "is there no way to solve it using brute force without TLE ?\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996141/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Just use table of 3 and think along its remainders."
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good after tackling a greedy one :)"
                    },
                    {
                        "username": "prasadpreetish",
                        "content": "Hey I stored the frequencies in a HashMap and then I found the same pattern of the minwork i.e. if f =1 return -1 if f=2 || f=3 return 1 but I am not able to get this intution that minwork+= (f+2)/3; how to get this type of thinking. I mean how do I develop the skills to get through such thought process.\\n\\n`    // frequencies       [1,2,3,4,5,6,7,8,9]`\\n\\n`   // minwork return   [-1,1,1,2,2,2,3,3,3]`\\n\\nI was getting this pattern but didn\\'t get the formula sadly."
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "You don\\'t have to it will develope automatically just practice as many questions as possible \\nHere is my solution which is similar to climbing stairs problem or coin change problem:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Count frequency in a hash-map.\\n2. Sum up (frequency + 2) / 3."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Santanu Sen](/santanusen) That\\'s one way of giving the full answer in as little words as possible! This is a perfect spoiler for those who have not thought about it, but I like the brevity!!"
                    },
                    {
                        "username": "omscode",
                        "content": "really help , thanks!!"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Well we can solve this problem using dp ( top down approach) \n"
                    }
                ]
            },
            {
                "id": 1740816,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Its more of a Math topic problem may be."
                    },
                    {
                        "username": "PulkitAgga01",
                        "content": "From observation, we can see that there\\'s only 3 possible outcomes.\\n1. If the frequency is 1, the task cannot be performed so we return -1.\\n2. If the frequency is 3, the task can be performed and we return frequency/3.\\n3. Now if the frequency is not completely divisible by 3, then we can return frequency/3 +1."
                    },
                    {
                        "username": "IamAJ22",
                        "content": "I am gonna code every single day in this year #resolution"
                    },
                    {
                        "username": "loknadh_reddy",
                        "content": "is there no way to solve it using brute force without TLE ?\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996141/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Just use table of 3 and think along its remainders."
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good after tackling a greedy one :)"
                    },
                    {
                        "username": "prasadpreetish",
                        "content": "Hey I stored the frequencies in a HashMap and then I found the same pattern of the minwork i.e. if f =1 return -1 if f=2 || f=3 return 1 but I am not able to get this intution that minwork+= (f+2)/3; how to get this type of thinking. I mean how do I develop the skills to get through such thought process.\\n\\n`    // frequencies       [1,2,3,4,5,6,7,8,9]`\\n\\n`   // minwork return   [-1,1,1,2,2,2,3,3,3]`\\n\\nI was getting this pattern but didn\\'t get the formula sadly."
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "You don\\'t have to it will develope automatically just practice as many questions as possible \\nHere is my solution which is similar to climbing stairs problem or coin change problem:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Count frequency in a hash-map.\\n2. Sum up (frequency + 2) / 3."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Santanu Sen](/santanusen) That\\'s one way of giving the full answer in as little words as possible! This is a perfect spoiler for those who have not thought about it, but I like the brevity!!"
                    },
                    {
                        "username": "omscode",
                        "content": "really help , thanks!!"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Well we can solve this problem using dp ( top down approach) \n"
                    }
                ]
            },
            {
                "id": 1740805,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Its more of a Math topic problem may be."
                    },
                    {
                        "username": "PulkitAgga01",
                        "content": "From observation, we can see that there\\'s only 3 possible outcomes.\\n1. If the frequency is 1, the task cannot be performed so we return -1.\\n2. If the frequency is 3, the task can be performed and we return frequency/3.\\n3. Now if the frequency is not completely divisible by 3, then we can return frequency/3 +1."
                    },
                    {
                        "username": "IamAJ22",
                        "content": "I am gonna code every single day in this year #resolution"
                    },
                    {
                        "username": "loknadh_reddy",
                        "content": "is there no way to solve it using brute force without TLE ?\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996141/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Just use table of 3 and think along its remainders."
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good after tackling a greedy one :)"
                    },
                    {
                        "username": "prasadpreetish",
                        "content": "Hey I stored the frequencies in a HashMap and then I found the same pattern of the minwork i.e. if f =1 return -1 if f=2 || f=3 return 1 but I am not able to get this intution that minwork+= (f+2)/3; how to get this type of thinking. I mean how do I develop the skills to get through such thought process.\\n\\n`    // frequencies       [1,2,3,4,5,6,7,8,9]`\\n\\n`   // minwork return   [-1,1,1,2,2,2,3,3,3]`\\n\\nI was getting this pattern but didn\\'t get the formula sadly."
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "You don\\'t have to it will develope automatically just practice as many questions as possible \\nHere is my solution which is similar to climbing stairs problem or coin change problem:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Count frequency in a hash-map.\\n2. Sum up (frequency + 2) / 3."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Santanu Sen](/santanusen) That\\'s one way of giving the full answer in as little words as possible! This is a perfect spoiler for those who have not thought about it, but I like the brevity!!"
                    },
                    {
                        "username": "omscode",
                        "content": "really help , thanks!!"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Well we can solve this problem using dp ( top down approach) \n"
                    }
                ]
            },
            {
                "id": 1740795,
                "content": [
                    {
                        "username": "Katrinakaif9",
                        "content": "My code is not satisfying the first test case here but is running perfectly on other compilers with the same testcases. What do I do?"
                    },
                    {
                        "username": "How_Absurd",
                        "content": "a basic greedy question \\uD83D\\uDE0B\\uD83D\\uDE0B"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "Far better than the last one"
                    },
                    {
                        "username": "wentaog",
                        "content": "My approach was to get an occurrence count table for how many times each task number occurred. Then I iterated through the table, and found whether each number\\'s count can be split by 2s and 3s. The only occasion it would return -1 would be the number only occurred 1 time. The hard part then was to think about how to come up with the condition that checks the minimum step count to cut up the tasks count in 2s and 3s. Since you divide any number larger than 3, if it doesn\\'t have remainder, great, add that divided number to the result sum. But if it doesn\\'t, the remainder would be either 2 or 1. Since we omitted the 1 from failure condition, I was thinking we could simple get a 3 from counted, and cut the 4 to 2 2s. Which eventually becomes if there is a remainder, add one to the divide by 3 number, and eventually to the res. After iterating through the table, you will either return -1 midway when found 1, or return the correct result. "
                    },
                    {
                        "username": "SAURABH_YADAV_CSE",
                        "content": " map<int,int> mp;\\n        int count=0;\\n        int n = tasks.size();\\n        for(int i=0; i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second==1) return -1;\\n            if(it.second%3==0){\\n                count = count+it.second/3;\\n            }\\n            else count = count+ it.second/3+1;\\n        }\\n\\n    return count;"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "GargShubham",
                        "content": "Tasks : [119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nPAIR : \\n{112=10, 113=13, 114=8, 115=8, 116=11, 117=6, 118=7, 119=13, 120=9, 110=8, 111=7}\\nMy Ans : -1 (for 116 = 11)\\nRight Ans : 38 (According Leetcode)\\nFor  this test cases don\\'t you think for 11 there should be -1 but in ans it is not right why? \\nanyone ?"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "11 can be split up into 3+3+3+2 in total 4 tasks..."
                    },
                    {
                        "username": "close27",
                        "content": "Hashtable is not needed if we sort the input array."
                    },
                    {
                        "username": "calm27",
                        "content": "with hashtable it could be resolved in `O(n)`, and sorting is `O(nlogn)`. "
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple recursion problem similar to factorial use dp array not to get TLE"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes but you dont have to create freq to each element , just sort that array and using topdown approach , you can check it here\\n\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995897/go-top-down-knapsack-dp/?orderBy=most_relevant"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Yeah Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using recursion + memoization. Basic idea was to use recursion to find out minimum rounds required for count of each task. Here\\'s my [solution](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995412/no-dp-solutions/) in python."
                    }
                ]
            },
            {
                "id": 1740787,
                "content": [
                    {
                        "username": "Katrinakaif9",
                        "content": "My code is not satisfying the first test case here but is running perfectly on other compilers with the same testcases. What do I do?"
                    },
                    {
                        "username": "How_Absurd",
                        "content": "a basic greedy question \\uD83D\\uDE0B\\uD83D\\uDE0B"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "Far better than the last one"
                    },
                    {
                        "username": "wentaog",
                        "content": "My approach was to get an occurrence count table for how many times each task number occurred. Then I iterated through the table, and found whether each number\\'s count can be split by 2s and 3s. The only occasion it would return -1 would be the number only occurred 1 time. The hard part then was to think about how to come up with the condition that checks the minimum step count to cut up the tasks count in 2s and 3s. Since you divide any number larger than 3, if it doesn\\'t have remainder, great, add that divided number to the result sum. But if it doesn\\'t, the remainder would be either 2 or 1. Since we omitted the 1 from failure condition, I was thinking we could simple get a 3 from counted, and cut the 4 to 2 2s. Which eventually becomes if there is a remainder, add one to the divide by 3 number, and eventually to the res. After iterating through the table, you will either return -1 midway when found 1, or return the correct result. "
                    },
                    {
                        "username": "SAURABH_YADAV_CSE",
                        "content": " map<int,int> mp;\\n        int count=0;\\n        int n = tasks.size();\\n        for(int i=0; i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second==1) return -1;\\n            if(it.second%3==0){\\n                count = count+it.second/3;\\n            }\\n            else count = count+ it.second/3+1;\\n        }\\n\\n    return count;"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "GargShubham",
                        "content": "Tasks : [119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nPAIR : \\n{112=10, 113=13, 114=8, 115=8, 116=11, 117=6, 118=7, 119=13, 120=9, 110=8, 111=7}\\nMy Ans : -1 (for 116 = 11)\\nRight Ans : 38 (According Leetcode)\\nFor  this test cases don\\'t you think for 11 there should be -1 but in ans it is not right why? \\nanyone ?"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "11 can be split up into 3+3+3+2 in total 4 tasks..."
                    },
                    {
                        "username": "close27",
                        "content": "Hashtable is not needed if we sort the input array."
                    },
                    {
                        "username": "calm27",
                        "content": "with hashtable it could be resolved in `O(n)`, and sorting is `O(nlogn)`. "
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple recursion problem similar to factorial use dp array not to get TLE"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes but you dont have to create freq to each element , just sort that array and using topdown approach , you can check it here\\n\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995897/go-top-down-knapsack-dp/?orderBy=most_relevant"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Yeah Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using recursion + memoization. Basic idea was to use recursion to find out minimum rounds required for count of each task. Here\\'s my [solution](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995412/no-dp-solutions/) in python."
                    }
                ]
            },
            {
                "id": 1740774,
                "content": [
                    {
                        "username": "Katrinakaif9",
                        "content": "My code is not satisfying the first test case here but is running perfectly on other compilers with the same testcases. What do I do?"
                    },
                    {
                        "username": "How_Absurd",
                        "content": "a basic greedy question \\uD83D\\uDE0B\\uD83D\\uDE0B"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "Far better than the last one"
                    },
                    {
                        "username": "wentaog",
                        "content": "My approach was to get an occurrence count table for how many times each task number occurred. Then I iterated through the table, and found whether each number\\'s count can be split by 2s and 3s. The only occasion it would return -1 would be the number only occurred 1 time. The hard part then was to think about how to come up with the condition that checks the minimum step count to cut up the tasks count in 2s and 3s. Since you divide any number larger than 3, if it doesn\\'t have remainder, great, add that divided number to the result sum. But if it doesn\\'t, the remainder would be either 2 or 1. Since we omitted the 1 from failure condition, I was thinking we could simple get a 3 from counted, and cut the 4 to 2 2s. Which eventually becomes if there is a remainder, add one to the divide by 3 number, and eventually to the res. After iterating through the table, you will either return -1 midway when found 1, or return the correct result. "
                    },
                    {
                        "username": "SAURABH_YADAV_CSE",
                        "content": " map<int,int> mp;\\n        int count=0;\\n        int n = tasks.size();\\n        for(int i=0; i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second==1) return -1;\\n            if(it.second%3==0){\\n                count = count+it.second/3;\\n            }\\n            else count = count+ it.second/3+1;\\n        }\\n\\n    return count;"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "GargShubham",
                        "content": "Tasks : [119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nPAIR : \\n{112=10, 113=13, 114=8, 115=8, 116=11, 117=6, 118=7, 119=13, 120=9, 110=8, 111=7}\\nMy Ans : -1 (for 116 = 11)\\nRight Ans : 38 (According Leetcode)\\nFor  this test cases don\\'t you think for 11 there should be -1 but in ans it is not right why? \\nanyone ?"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "11 can be split up into 3+3+3+2 in total 4 tasks..."
                    },
                    {
                        "username": "close27",
                        "content": "Hashtable is not needed if we sort the input array."
                    },
                    {
                        "username": "calm27",
                        "content": "with hashtable it could be resolved in `O(n)`, and sorting is `O(nlogn)`. "
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple recursion problem similar to factorial use dp array not to get TLE"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes but you dont have to create freq to each element , just sort that array and using topdown approach , you can check it here\\n\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995897/go-top-down-knapsack-dp/?orderBy=most_relevant"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Yeah Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using recursion + memoization. Basic idea was to use recursion to find out minimum rounds required for count of each task. Here\\'s my [solution](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995412/no-dp-solutions/) in python."
                    }
                ]
            },
            {
                "id": 1740766,
                "content": [
                    {
                        "username": "Katrinakaif9",
                        "content": "My code is not satisfying the first test case here but is running perfectly on other compilers with the same testcases. What do I do?"
                    },
                    {
                        "username": "How_Absurd",
                        "content": "a basic greedy question \\uD83D\\uDE0B\\uD83D\\uDE0B"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "Far better than the last one"
                    },
                    {
                        "username": "wentaog",
                        "content": "My approach was to get an occurrence count table for how many times each task number occurred. Then I iterated through the table, and found whether each number\\'s count can be split by 2s and 3s. The only occasion it would return -1 would be the number only occurred 1 time. The hard part then was to think about how to come up with the condition that checks the minimum step count to cut up the tasks count in 2s and 3s. Since you divide any number larger than 3, if it doesn\\'t have remainder, great, add that divided number to the result sum. But if it doesn\\'t, the remainder would be either 2 or 1. Since we omitted the 1 from failure condition, I was thinking we could simple get a 3 from counted, and cut the 4 to 2 2s. Which eventually becomes if there is a remainder, add one to the divide by 3 number, and eventually to the res. After iterating through the table, you will either return -1 midway when found 1, or return the correct result. "
                    },
                    {
                        "username": "SAURABH_YADAV_CSE",
                        "content": " map<int,int> mp;\\n        int count=0;\\n        int n = tasks.size();\\n        for(int i=0; i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second==1) return -1;\\n            if(it.second%3==0){\\n                count = count+it.second/3;\\n            }\\n            else count = count+ it.second/3+1;\\n        }\\n\\n    return count;"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "GargShubham",
                        "content": "Tasks : [119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nPAIR : \\n{112=10, 113=13, 114=8, 115=8, 116=11, 117=6, 118=7, 119=13, 120=9, 110=8, 111=7}\\nMy Ans : -1 (for 116 = 11)\\nRight Ans : 38 (According Leetcode)\\nFor  this test cases don\\'t you think for 11 there should be -1 but in ans it is not right why? \\nanyone ?"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "11 can be split up into 3+3+3+2 in total 4 tasks..."
                    },
                    {
                        "username": "close27",
                        "content": "Hashtable is not needed if we sort the input array."
                    },
                    {
                        "username": "calm27",
                        "content": "with hashtable it could be resolved in `O(n)`, and sorting is `O(nlogn)`. "
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple recursion problem similar to factorial use dp array not to get TLE"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes but you dont have to create freq to each element , just sort that array and using topdown approach , you can check it here\\n\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995897/go-top-down-knapsack-dp/?orderBy=most_relevant"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Yeah Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using recursion + memoization. Basic idea was to use recursion to find out minimum rounds required for count of each task. Here\\'s my [solution](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995412/no-dp-solutions/) in python."
                    }
                ]
            },
            {
                "id": 1740758,
                "content": [
                    {
                        "username": "Katrinakaif9",
                        "content": "My code is not satisfying the first test case here but is running perfectly on other compilers with the same testcases. What do I do?"
                    },
                    {
                        "username": "How_Absurd",
                        "content": "a basic greedy question \\uD83D\\uDE0B\\uD83D\\uDE0B"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "Far better than the last one"
                    },
                    {
                        "username": "wentaog",
                        "content": "My approach was to get an occurrence count table for how many times each task number occurred. Then I iterated through the table, and found whether each number\\'s count can be split by 2s and 3s. The only occasion it would return -1 would be the number only occurred 1 time. The hard part then was to think about how to come up with the condition that checks the minimum step count to cut up the tasks count in 2s and 3s. Since you divide any number larger than 3, if it doesn\\'t have remainder, great, add that divided number to the result sum. But if it doesn\\'t, the remainder would be either 2 or 1. Since we omitted the 1 from failure condition, I was thinking we could simple get a 3 from counted, and cut the 4 to 2 2s. Which eventually becomes if there is a remainder, add one to the divide by 3 number, and eventually to the res. After iterating through the table, you will either return -1 midway when found 1, or return the correct result. "
                    },
                    {
                        "username": "SAURABH_YADAV_CSE",
                        "content": " map<int,int> mp;\\n        int count=0;\\n        int n = tasks.size();\\n        for(int i=0; i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second==1) return -1;\\n            if(it.second%3==0){\\n                count = count+it.second/3;\\n            }\\n            else count = count+ it.second/3+1;\\n        }\\n\\n    return count;"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "GargShubham",
                        "content": "Tasks : [119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nPAIR : \\n{112=10, 113=13, 114=8, 115=8, 116=11, 117=6, 118=7, 119=13, 120=9, 110=8, 111=7}\\nMy Ans : -1 (for 116 = 11)\\nRight Ans : 38 (According Leetcode)\\nFor  this test cases don\\'t you think for 11 there should be -1 but in ans it is not right why? \\nanyone ?"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "11 can be split up into 3+3+3+2 in total 4 tasks..."
                    },
                    {
                        "username": "close27",
                        "content": "Hashtable is not needed if we sort the input array."
                    },
                    {
                        "username": "calm27",
                        "content": "with hashtable it could be resolved in `O(n)`, and sorting is `O(nlogn)`. "
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple recursion problem similar to factorial use dp array not to get TLE"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes but you dont have to create freq to each element , just sort that array and using topdown approach , you can check it here\\n\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995897/go-top-down-knapsack-dp/?orderBy=most_relevant"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Yeah Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using recursion + memoization. Basic idea was to use recursion to find out minimum rounds required for count of each task. Here\\'s my [solution](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995412/no-dp-solutions/) in python."
                    }
                ]
            },
            {
                "id": 1740733,
                "content": [
                    {
                        "username": "Katrinakaif9",
                        "content": "My code is not satisfying the first test case here but is running perfectly on other compilers with the same testcases. What do I do?"
                    },
                    {
                        "username": "How_Absurd",
                        "content": "a basic greedy question \\uD83D\\uDE0B\\uD83D\\uDE0B"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "Far better than the last one"
                    },
                    {
                        "username": "wentaog",
                        "content": "My approach was to get an occurrence count table for how many times each task number occurred. Then I iterated through the table, and found whether each number\\'s count can be split by 2s and 3s. The only occasion it would return -1 would be the number only occurred 1 time. The hard part then was to think about how to come up with the condition that checks the minimum step count to cut up the tasks count in 2s and 3s. Since you divide any number larger than 3, if it doesn\\'t have remainder, great, add that divided number to the result sum. But if it doesn\\'t, the remainder would be either 2 or 1. Since we omitted the 1 from failure condition, I was thinking we could simple get a 3 from counted, and cut the 4 to 2 2s. Which eventually becomes if there is a remainder, add one to the divide by 3 number, and eventually to the res. After iterating through the table, you will either return -1 midway when found 1, or return the correct result. "
                    },
                    {
                        "username": "SAURABH_YADAV_CSE",
                        "content": " map<int,int> mp;\\n        int count=0;\\n        int n = tasks.size();\\n        for(int i=0; i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second==1) return -1;\\n            if(it.second%3==0){\\n                count = count+it.second/3;\\n            }\\n            else count = count+ it.second/3+1;\\n        }\\n\\n    return count;"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "GargShubham",
                        "content": "Tasks : [119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nPAIR : \\n{112=10, 113=13, 114=8, 115=8, 116=11, 117=6, 118=7, 119=13, 120=9, 110=8, 111=7}\\nMy Ans : -1 (for 116 = 11)\\nRight Ans : 38 (According Leetcode)\\nFor  this test cases don\\'t you think for 11 there should be -1 but in ans it is not right why? \\nanyone ?"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "11 can be split up into 3+3+3+2 in total 4 tasks..."
                    },
                    {
                        "username": "close27",
                        "content": "Hashtable is not needed if we sort the input array."
                    },
                    {
                        "username": "calm27",
                        "content": "with hashtable it could be resolved in `O(n)`, and sorting is `O(nlogn)`. "
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple recursion problem similar to factorial use dp array not to get TLE"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes but you dont have to create freq to each element , just sort that array and using topdown approach , you can check it here\\n\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995897/go-top-down-knapsack-dp/?orderBy=most_relevant"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Yeah Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using recursion + memoization. Basic idea was to use recursion to find out minimum rounds required for count of each task. Here\\'s my [solution](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995412/no-dp-solutions/) in python."
                    }
                ]
            },
            {
                "id": 1740696,
                "content": [
                    {
                        "username": "Katrinakaif9",
                        "content": "My code is not satisfying the first test case here but is running perfectly on other compilers with the same testcases. What do I do?"
                    },
                    {
                        "username": "How_Absurd",
                        "content": "a basic greedy question \\uD83D\\uDE0B\\uD83D\\uDE0B"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "Far better than the last one"
                    },
                    {
                        "username": "wentaog",
                        "content": "My approach was to get an occurrence count table for how many times each task number occurred. Then I iterated through the table, and found whether each number\\'s count can be split by 2s and 3s. The only occasion it would return -1 would be the number only occurred 1 time. The hard part then was to think about how to come up with the condition that checks the minimum step count to cut up the tasks count in 2s and 3s. Since you divide any number larger than 3, if it doesn\\'t have remainder, great, add that divided number to the result sum. But if it doesn\\'t, the remainder would be either 2 or 1. Since we omitted the 1 from failure condition, I was thinking we could simple get a 3 from counted, and cut the 4 to 2 2s. Which eventually becomes if there is a remainder, add one to the divide by 3 number, and eventually to the res. After iterating through the table, you will either return -1 midway when found 1, or return the correct result. "
                    },
                    {
                        "username": "SAURABH_YADAV_CSE",
                        "content": " map<int,int> mp;\\n        int count=0;\\n        int n = tasks.size();\\n        for(int i=0; i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second==1) return -1;\\n            if(it.second%3==0){\\n                count = count+it.second/3;\\n            }\\n            else count = count+ it.second/3+1;\\n        }\\n\\n    return count;"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "GargShubham",
                        "content": "Tasks : [119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nPAIR : \\n{112=10, 113=13, 114=8, 115=8, 116=11, 117=6, 118=7, 119=13, 120=9, 110=8, 111=7}\\nMy Ans : -1 (for 116 = 11)\\nRight Ans : 38 (According Leetcode)\\nFor  this test cases don\\'t you think for 11 there should be -1 but in ans it is not right why? \\nanyone ?"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "11 can be split up into 3+3+3+2 in total 4 tasks..."
                    },
                    {
                        "username": "close27",
                        "content": "Hashtable is not needed if we sort the input array."
                    },
                    {
                        "username": "calm27",
                        "content": "with hashtable it could be resolved in `O(n)`, and sorting is `O(nlogn)`. "
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple recursion problem similar to factorial use dp array not to get TLE"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes but you dont have to create freq to each element , just sort that array and using topdown approach , you can check it here\\n\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995897/go-top-down-knapsack-dp/?orderBy=most_relevant"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Yeah Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using recursion + memoization. Basic idea was to use recursion to find out minimum rounds required for count of each task. Here\\'s my [solution](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995412/no-dp-solutions/) in python."
                    }
                ]
            },
            {
                "id": 1740695,
                "content": [
                    {
                        "username": "Katrinakaif9",
                        "content": "My code is not satisfying the first test case here but is running perfectly on other compilers with the same testcases. What do I do?"
                    },
                    {
                        "username": "How_Absurd",
                        "content": "a basic greedy question \\uD83D\\uDE0B\\uD83D\\uDE0B"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "Far better than the last one"
                    },
                    {
                        "username": "wentaog",
                        "content": "My approach was to get an occurrence count table for how many times each task number occurred. Then I iterated through the table, and found whether each number\\'s count can be split by 2s and 3s. The only occasion it would return -1 would be the number only occurred 1 time. The hard part then was to think about how to come up with the condition that checks the minimum step count to cut up the tasks count in 2s and 3s. Since you divide any number larger than 3, if it doesn\\'t have remainder, great, add that divided number to the result sum. But if it doesn\\'t, the remainder would be either 2 or 1. Since we omitted the 1 from failure condition, I was thinking we could simple get a 3 from counted, and cut the 4 to 2 2s. Which eventually becomes if there is a remainder, add one to the divide by 3 number, and eventually to the res. After iterating through the table, you will either return -1 midway when found 1, or return the correct result. "
                    },
                    {
                        "username": "SAURABH_YADAV_CSE",
                        "content": " map<int,int> mp;\\n        int count=0;\\n        int n = tasks.size();\\n        for(int i=0; i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second==1) return -1;\\n            if(it.second%3==0){\\n                count = count+it.second/3;\\n            }\\n            else count = count+ it.second/3+1;\\n        }\\n\\n    return count;"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "GargShubham",
                        "content": "Tasks : [119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nPAIR : \\n{112=10, 113=13, 114=8, 115=8, 116=11, 117=6, 118=7, 119=13, 120=9, 110=8, 111=7}\\nMy Ans : -1 (for 116 = 11)\\nRight Ans : 38 (According Leetcode)\\nFor  this test cases don\\'t you think for 11 there should be -1 but in ans it is not right why? \\nanyone ?"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "11 can be split up into 3+3+3+2 in total 4 tasks..."
                    },
                    {
                        "username": "close27",
                        "content": "Hashtable is not needed if we sort the input array."
                    },
                    {
                        "username": "calm27",
                        "content": "with hashtable it could be resolved in `O(n)`, and sorting is `O(nlogn)`. "
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple recursion problem similar to factorial use dp array not to get TLE"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes but you dont have to create freq to each element , just sort that array and using topdown approach , you can check it here\\n\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995897/go-top-down-knapsack-dp/?orderBy=most_relevant"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Yeah Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using recursion + memoization. Basic idea was to use recursion to find out minimum rounds required for count of each task. Here\\'s my [solution](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995412/no-dp-solutions/) in python."
                    }
                ]
            },
            {
                "id": 1740691,
                "content": [
                    {
                        "username": "Katrinakaif9",
                        "content": "My code is not satisfying the first test case here but is running perfectly on other compilers with the same testcases. What do I do?"
                    },
                    {
                        "username": "How_Absurd",
                        "content": "a basic greedy question \\uD83D\\uDE0B\\uD83D\\uDE0B"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "Far better than the last one"
                    },
                    {
                        "username": "wentaog",
                        "content": "My approach was to get an occurrence count table for how many times each task number occurred. Then I iterated through the table, and found whether each number\\'s count can be split by 2s and 3s. The only occasion it would return -1 would be the number only occurred 1 time. The hard part then was to think about how to come up with the condition that checks the minimum step count to cut up the tasks count in 2s and 3s. Since you divide any number larger than 3, if it doesn\\'t have remainder, great, add that divided number to the result sum. But if it doesn\\'t, the remainder would be either 2 or 1. Since we omitted the 1 from failure condition, I was thinking we could simple get a 3 from counted, and cut the 4 to 2 2s. Which eventually becomes if there is a remainder, add one to the divide by 3 number, and eventually to the res. After iterating through the table, you will either return -1 midway when found 1, or return the correct result. "
                    },
                    {
                        "username": "SAURABH_YADAV_CSE",
                        "content": " map<int,int> mp;\\n        int count=0;\\n        int n = tasks.size();\\n        for(int i=0; i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second==1) return -1;\\n            if(it.second%3==0){\\n                count = count+it.second/3;\\n            }\\n            else count = count+ it.second/3+1;\\n        }\\n\\n    return count;"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "GargShubham",
                        "content": "Tasks : [119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nPAIR : \\n{112=10, 113=13, 114=8, 115=8, 116=11, 117=6, 118=7, 119=13, 120=9, 110=8, 111=7}\\nMy Ans : -1 (for 116 = 11)\\nRight Ans : 38 (According Leetcode)\\nFor  this test cases don\\'t you think for 11 there should be -1 but in ans it is not right why? \\nanyone ?"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "11 can be split up into 3+3+3+2 in total 4 tasks..."
                    },
                    {
                        "username": "close27",
                        "content": "Hashtable is not needed if we sort the input array."
                    },
                    {
                        "username": "calm27",
                        "content": "with hashtable it could be resolved in `O(n)`, and sorting is `O(nlogn)`. "
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple recursion problem similar to factorial use dp array not to get TLE"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes but you dont have to create freq to each element , just sort that array and using topdown approach , you can check it here\\n\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995897/go-top-down-knapsack-dp/?orderBy=most_relevant"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Yeah Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using recursion + memoization. Basic idea was to use recursion to find out minimum rounds required for count of each task. Here\\'s my [solution](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995412/no-dp-solutions/) in python."
                    }
                ]
            },
            {
                "id": 1740683,
                "content": [
                    {
                        "username": "Katrinakaif9",
                        "content": "My code is not satisfying the first test case here but is running perfectly on other compilers with the same testcases. What do I do?"
                    },
                    {
                        "username": "How_Absurd",
                        "content": "a basic greedy question \\uD83D\\uDE0B\\uD83D\\uDE0B"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "Far better than the last one"
                    },
                    {
                        "username": "wentaog",
                        "content": "My approach was to get an occurrence count table for how many times each task number occurred. Then I iterated through the table, and found whether each number\\'s count can be split by 2s and 3s. The only occasion it would return -1 would be the number only occurred 1 time. The hard part then was to think about how to come up with the condition that checks the minimum step count to cut up the tasks count in 2s and 3s. Since you divide any number larger than 3, if it doesn\\'t have remainder, great, add that divided number to the result sum. But if it doesn\\'t, the remainder would be either 2 or 1. Since we omitted the 1 from failure condition, I was thinking we could simple get a 3 from counted, and cut the 4 to 2 2s. Which eventually becomes if there is a remainder, add one to the divide by 3 number, and eventually to the res. After iterating through the table, you will either return -1 midway when found 1, or return the correct result. "
                    },
                    {
                        "username": "SAURABH_YADAV_CSE",
                        "content": " map<int,int> mp;\\n        int count=0;\\n        int n = tasks.size();\\n        for(int i=0; i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second==1) return -1;\\n            if(it.second%3==0){\\n                count = count+it.second/3;\\n            }\\n            else count = count+ it.second/3+1;\\n        }\\n\\n    return count;"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "GargShubham",
                        "content": "Tasks : [119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nPAIR : \\n{112=10, 113=13, 114=8, 115=8, 116=11, 117=6, 118=7, 119=13, 120=9, 110=8, 111=7}\\nMy Ans : -1 (for 116 = 11)\\nRight Ans : 38 (According Leetcode)\\nFor  this test cases don\\'t you think for 11 there should be -1 but in ans it is not right why? \\nanyone ?"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "11 can be split up into 3+3+3+2 in total 4 tasks..."
                    },
                    {
                        "username": "close27",
                        "content": "Hashtable is not needed if we sort the input array."
                    },
                    {
                        "username": "calm27",
                        "content": "with hashtable it could be resolved in `O(n)`, and sorting is `O(nlogn)`. "
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple recursion problem similar to factorial use dp array not to get TLE"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes but you dont have to create freq to each element , just sort that array and using topdown approach , you can check it here\\n\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995897/go-top-down-knapsack-dp/?orderBy=most_relevant"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Yeah Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using recursion + memoization. Basic idea was to use recursion to find out minimum rounds required for count of each task. Here\\'s my [solution](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995412/no-dp-solutions/) in python."
                    }
                ]
            }
        ]
    }
]