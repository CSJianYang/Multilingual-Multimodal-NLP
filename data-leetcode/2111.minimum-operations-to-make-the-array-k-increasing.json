[
    {
        "title": "Minimum Operations to Make the Array K-Increasing",
        "question_content": "You are given a 0-indexed array arr consisting of n positive integers, and a positive integer k.\nThe array arr is called K-increasing if arr[i-k] <= arr[i] holds for every index i, where k <= i <= n-1.\n\n\tFor example, arr = [4, 1, 5, 2, 6, 2] is K-increasing for k = 2 because:\n\t\n\t\tarr[0] <= arr[2] (4 <= 5)\n\t\tarr[1] <= arr[3] (1 <= 2)\n\t\tarr[2] <= arr[4] (5 <= 6)\n\t\tarr[3] <= arr[5] (2 <= 2)\n\t\n\t\n\tHowever, the same arr is not K-increasing for k = 1 (because arr[0] > arr[1]) or k = 3 (because arr[0] > arr[3]).\n\nIn one operation, you can choose an index i and change arr[i] into any positive integer.\nReturn the minimum number of operations required to make the array K-increasing for the given k.\n&nbsp;\nExample 1:\n\nInput: arr = [5,4,3,2,1], k = 1\nOutput: 4\nExplanation:\nFor k = 1, the resultant array has to be non-decreasing.\nSome of the K-increasing arrays that can be formed are [5,6,7,8,9], [1,1,1,1,1], [2,2,3,4,4]. All of them require 4 operations.\nIt is suboptimal to change the array to, for example, [6,7,8,9,10] because it would take 5 operations.\nIt can be shown that we cannot make the array K-increasing in less than 4 operations.\n\nExample 2:\n\nInput: arr = [4,1,5,2,6,2], k = 2\nOutput: 0\nExplanation:\nThis is the same example as the one in the problem description.\nHere, for every index i where 2 <= i <= 5, arr[i-2] <= arr[i].\nSince the given array is already K-increasing, we do not need to perform any operations.\nExample 3:\n\nInput: arr = [4,1,5,2,6,2], k = 3\nOutput: 2\nExplanation:\nIndices 3 and 5 are the only ones not satisfying arr[i-3] <= arr[i] for 3 <= i <= 5.\nOne of the ways we can make the array K-increasing is by changing arr[3] to 4 and arr[5] to 5.\nThe array will now be [4,1,5,4,6,5].\nNote that there can be other ways to make the array K-increasing, but none of them require less than 2 operations.\n\n&nbsp;\nConstraints:\n\n\t1 <= arr.length <= 105\n\t1 <= arr[i], k <= arr.length",
        "solutions": [
            {
                "id": 1635013,
                "title": "c-python-longest-non-decreasing-subsequence-clean-concise",
                "content": "**Idea**\\n- If `k = 1`, we need to find the minimum number of operations to make the whole array non-decreasing.\\n- If `k = 2`, we need to make:\\n\\t- newArr1: Elements in index [0, 2, 4, 6...] are non-decreasing.\\n\\t- newArr2: Elements in index [1, 3, 5, 7...] are non-decreasing.\\n- If `k = 3`, we need to make:\\n    - newArr1: Elements in index [0, 3, 6, 9...] are non-decreasing.\\n\\t- newArr2: Elements in index [1, 4, 7, 10...] are non-decreasing.\\n\\t- newArr3: Elements in index [2, 5, 8, 11...] are non-decreasing.\\n- Since **Elements in newArrs are independent**, we just need to **find the minimum of operations to make `K` newArr non-decreasing**.\\n- To **find the minimum of operations to make an array non-decreasing**,\\n\\t- Firstly, we count **Longest Non-Decreasing Subsequence** in that array.\\n\\t- Then the result is `len(arr) - longestNonDecreasing(arr)`, because we only need to change elements not in the **Longest Non-Decreasing Subsequence**.\\n\\t- For example: `newArr = [18, 8, 8, 3, 9]`, the longest non-decreasing subsequence is `[-, 8, 8, -, 9]` and we just need to change the array into `[8, 8, 8, 9, 9]` by changing `18 -> 8`, `3 -> 9`.\\n\\n**To find the Longest Non-Decreasing Subsequence** of an array, you can check following posts for more detail:\\n- [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/discuss/1326308) - Longest Increasing Subsequence\\n- [1964. Find the Longest Valid Obstacle Course at Each Position](https://leetcode.com/problems/find-the-longest-valid-obstacle-course-at-each-position/discuss/1390159) - Longest Non-Decreasing Subsequence\\n\\n<iframe src=\"https://leetcode.com/playground/Mo4LhKNV/shared\" frameBorder=\"0\" width=\"100%\" height=\"550\"></iframe>\\n\\n**Complexity**\\n- Time: `O(K * N/K * log(N/K))`  = `O(N * log(N/K))`, where `N <= 10^5` is length of `arr`, `K <= N`.\\n\\t- We have total `K` new arr, each array have up to `N/K` elements.\\n\\t- We need `O(M * logM)` to find the longest non-decreasing subsequence of an array length `M`.\\n- Space: `O(N / K)`\\n\\n",
                "solutionTags": [],
                "code": "**Idea**\\n- If `k = 1`, we need to find the minimum number of operations to make the whole array non-decreasing.\\n- If `k = 2`, we need to make:\\n\\t- newArr1: Elements in index [0, 2, 4, 6...] are non-decreasing.\\n\\t- newArr2: Elements in index [1, 3, 5, 7...] are non-decreasing.\\n- If `k = 3`, we need to make:\\n    - newArr1: Elements in index [0, 3, 6, 9...] are non-decreasing.\\n\\t- newArr2: Elements in index [1, 4, 7, 10...] are non-decreasing.\\n\\t- newArr3: Elements in index [2, 5, 8, 11...] are non-decreasing.\\n- Since **Elements in newArrs are independent**, we just need to **find the minimum of operations to make `K` newArr non-decreasing**.\\n- To **find the minimum of operations to make an array non-decreasing**,\\n\\t- Firstly, we count **Longest Non-Decreasing Subsequence** in that array.\\n\\t- Then the result is `len(arr) - longestNonDecreasing(arr)`, because we only need to change elements not in the **Longest Non-Decreasing Subsequence**.\\n\\t- For example: `newArr = [18, 8, 8, 3, 9]`, the longest non-decreasing subsequence is `[-, 8, 8, -, 9]` and we just need to change the array into `[8, 8, 8, 9, 9]` by changing `18 -> 8`, `3 -> 9`.\\n\\n**To find the Longest Non-Decreasing Subsequence** of an array, you can check following posts for more detail:\\n- [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/discuss/1326308) - Longest Increasing Subsequence\\n- [1964. Find the Longest Valid Obstacle Course at Each Position](https://leetcode.com/problems/find-the-longest-valid-obstacle-course-at-each-position/discuss/1390159) - Longest Non-Decreasing Subsequence\\n\\n<iframe src=\"https://leetcode.com/playground/Mo4LhKNV/shared\" frameBorder=\"0\" width=\"100%\" height=\"550\"></iframe>\\n\\n**Complexity**\\n- Time: `O(K * N/K * log(N/K))`  = `O(N * log(N/K))`, where `N <= 10^5` is length of `arr`, `K <= N`.\\n\\t- We have total `K` new arr, each array have up to `N/K` elements.\\n\\t- We need `O(M * logM)` to find the longest non-decreasing subsequence of an array length `M`.\\n- Space: `O(N / K)`\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1634969,
                "title": "lis-in-disguise",
                "content": "We have `k` independent subarrays in our array, and we need to make those subarrays non-decreasing.\\n\\nFor each subarray, we need to find the longest non-decreasing subsequence. We keep numbers in that subsequence as-is, and change the rest. We can use the approach from [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/).\\n\\nBecause `n` is quite large, a quadratic solution would be too slow. So, we should use the O(n log n) solution: monostack with binary search.\\n\\n**Python 3**\\n```python\\nclass Solution:       \\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        def LNDS(arr: List[int]) -> int:\\n            mono = []\\n            for n in arr:\\n                if not mono or mono[-1] <= n:\\n                    mono.append(n)\\n                else:\\n                    mono[bisect_right(mono, n)] = n\\n            return len(mono)         \\n        return len(arr) - sum(LNDS(arr[i::k]) for i in range(k))\\n```\\n\\n**Java**\\nWe need to implement `upperBound` by hand, because `binarySearch` in Java is not guaranteed to return the smallest index in case of duplicates.\\n\\n```java\\npublic int kIncreasing(int[] arr, int k) {\\n    int longest = 0;\\n    for (int i = 0; i < k; ++i) {\\n        List<Integer> mono = new ArrayList<>();\\n        for (int j = i; j < arr.length; j += k)\\n            if (mono.isEmpty() || mono.get(mono.size() - 1) <= arr[j])\\n                mono.add(arr[j]);\\n            else\\n                mono.set(upperBound(mono, arr[j]), arr[j]);\\n        longest += mono.size();\\n    }\\n    return arr.length - longest;\\n}\\nprivate int upperBound(List<Integer> mono, int val) {\\n    int l = 0, r = mono.size() - 1;\\n    while (l < r) {\\n        int m = (l + r) / 2;\\n        if (mono.get(m) <= val)\\n            l = m + 1;\\n        else\\n            r = m;\\n    }\\n    return l;\\n}\\n```\\n\\n**C++**\\n```cpp\\nint kIncreasing(vector<int>& arr, int k) {\\n    int longest = 0;\\n    for (int i = 0; i < k; ++i) {\\n        vector<int> mono;\\n        for (int j = i; j < arr.size(); j += k)\\n            if (mono.empty() || mono.back() <= arr[j])\\n                mono.push_back(arr[j]);\\n            else\\n                *upper_bound(begin(mono), end(mono), arr[j]) = arr[j];\\n        longest += mono.size();\\n    }\\n    return arr.size() - longest;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```python\\nclass Solution:       \\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        def LNDS(arr: List[int]) -> int:\\n            mono = []\\n            for n in arr:\\n                if not mono or mono[-1] <= n:\\n                    mono.append(n)\\n                else:\\n                    mono[bisect_right(mono, n)] = n\\n            return len(mono)         \\n        return len(arr) - sum(LNDS(arr[i::k]) for i in range(k))\\n```\n```java\\npublic int kIncreasing(int[] arr, int k) {\\n    int longest = 0;\\n    for (int i = 0; i < k; ++i) {\\n        List<Integer> mono = new ArrayList<>();\\n        for (int j = i; j < arr.length; j += k)\\n            if (mono.isEmpty() || mono.get(mono.size() - 1) <= arr[j])\\n                mono.add(arr[j]);\\n            else\\n                mono.set(upperBound(mono, arr[j]), arr[j]);\\n        longest += mono.size();\\n    }\\n    return arr.length - longest;\\n}\\nprivate int upperBound(List<Integer> mono, int val) {\\n    int l = 0, r = mono.size() - 1;\\n    while (l < r) {\\n        int m = (l + r) / 2;\\n        if (mono.get(m) <= val)\\n            l = m + 1;\\n        else\\n            r = m;\\n    }\\n    return l;\\n}\\n```\n```cpp\\nint kIncreasing(vector<int>& arr, int k) {\\n    int longest = 0;\\n    for (int i = 0; i < k; ++i) {\\n        vector<int> mono;\\n        for (int j = i; j < arr.size(); j += k)\\n            if (mono.empty() || mono.back() <= arr[j])\\n                mono.push_back(arr[j]);\\n            else\\n                *upper_bound(begin(mono), end(mono), arr[j]) = arr[j];\\n        longest += mono.size();\\n    }\\n    return arr.size() - longest;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635026,
                "title": "python-explanation-with-pictures-lis",
                "content": "Given k = 3 for example. Let\\'s stay that we start with index = 0, the first condition is **A[0] <= A[3]**, \\n![image](https://assets.leetcode.com/users/images/c36a636b-3cf2-4048-b96f-a3ca54bd3b10_1639886464.2410972.png)\\n\\nWe also need to guarantee **A[3] <= A[6]**,   **A[6] <= A[9]**, etc, if such larger indexs exist. In a word, we need to make this subarray **a = [A[0], A[3], A[6], ... ]** of unique indexes **non-decreasing**.\\n![image](https://assets.leetcode.com/users/images/d1441e41-b6b2-4c7c-9208-ed8c8efb7cdd_1639886464.203102.png)\\n\\n\\nThis sub-problem turns into finding the Largest Increasing Subsequence (LIS) of **a**, then the minimum number of changes we shall make equals to **len(a) - LIS(a)**\\n\\n![image](https://assets.leetcode.com/users/images/ffc17dd6-7b11-4997-a7ab-55d85aa723c3_1639886464.4960089.png)\\n\\n\\nSince the final array is k-increasing, thus we have to compare at most k  subarrays. [A[0], A[k], A[2k], ...], [A[1], A[k + 1], A[2k + 1], ...], ..., [A[k - 1], A[2k - 1], A[3k - 1], ...].\\n\\nNotice that the changes on one \"series\" of indexes don\\'t interference with other series, so we can safely calculate the number of changes for every series without affecting the answer.\\n\\nThen the answer is the sum of  **len(a) - LIS(a)** for each subarray.\\n\\n![image](https://assets.leetcode.com/users/images/cf706ed1-5815-47ae-bcfe-b2d3b1e1af71_1639886464.3358257.png)\\n\\n**python**\\n```\\ndef kIncreasing(self, A: List[int], k: int) -> int:\\n        def LIS(arr):\\n            ans = []\\n            for a in arr:\\n                idx = bisect.bisect_right(ans, a)\\n                if idx == len(ans):\\n                    ans.append(a)\\n                else:\\n                    ans[idx] = a       \\n            return len(ans)\\n        \\n        ans, n = 0, len(A)\\n        \\n        for start in range(k):\\n            cur, idx = [], start\\n            while idx < n:\\n                cur.append(A[idx])\\n                idx += k\\n            ans += len(cur) - LIS(cur)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef kIncreasing(self, A: List[int], k: int) -> int:\\n        def LIS(arr):\\n            ans = []\\n            for a in arr:\\n                idx = bisect.bisect_right(ans, a)\\n                if idx == len(ans):\\n                    ans.append(a)\\n                else:\\n                    ans[idx] = a       \\n            return len(ans)\\n        \\n        ans, n = 0, len(A)\\n        \\n        for start in range(k):\\n            cur, idx = [], start\\n            while idx < n:\\n                cur.append(A[idx])\\n                idx += k\\n            ans += len(cur) - LIS(cur)\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1635375,
                "title": "java-intuition-lis-binary-search",
                "content": "**Intuition:**\\nThe intuition behind this solution is that we extract all k-separated subsequences and find out the longest increasing subsequence (LIS) for each k-separated subsequences and then for each of these extracted subsequences we calculate the min operations (delete/update) to make it sorted/increasing.\\n\\n```\\nMin operations to make it increasing = Length of extracted subsequence - LIS of the extracted subsequence\\n```\\n\\nWe add the min operations for each of the k-separated subsequences which should give us the answer for the original problem.\\n\\nLet\\'s take an example to understand better -\\n\\n```\\narr = [4,1,5,2,6,2,8,9,11,15]\\n       1     1     1      1\\n         2     2     2\\n           3     3     3 \\nk=3\\n\\nk-seperated subsequences of arr:\\n#   subsequence      length     LIS      Operations(length - LIS)\\n1   [4,2,8,15]          4        3           1\\n2   [1,6,9]             3        3           0\\n3   [5,2,11]            3        2           1\\n--------------------------------------------------\\nTotal Operations =                           2\\n-------------------------------------------------\\n```\\n\\n**Code:**\\n\\n```\\nclass Solution {\\n  public int kIncreasing(int[] arr, int k) {\\n    int total = 0;\\n    for(int i=0; i < k; i++){\\n      List<Integer> list = new ArrayList<>();\\n      for(int j=i; j < arr.length; j = j+k)\\n        list.add(arr[j]);\\n      total += list.size() - lengthOfLIS(list);\\n    }\\n    return total;\\n  }\\n  \\n  // Get the length of LIS by building an increasing List so as to perform binary search on it \\n  // in case the current element is lesser than the last element in the increasing List. \\n  // In such case we get the next greater element from the increasing List by doing a binary Search and \\n  // replace that with the the current element in the increasing List, as the other element is no longer relevant in participating in LIS. \\n  // The increasing List remains sorted and always maintain the max length of the increasing subsequence.\\n  public int lengthOfLIS(List<Integer> nums){\\n    List<Integer> incrList = new ArrayList<>();\\n    incrList.add(nums.get(0));\\n\\n    for(int i=1; i < nums.size(); i++){\\n      int lastItem = incrList.get(incrList.size()-1);\\n      if(nums.get(i) >= lastItem){\\n        incrList.add(nums.get(i));\\n      } else {\\n        int idx = nextGreaterItem(incrList, nums.get(i));\\n        incrList.set(idx, nums.get(i));\\n      }\\n    }\\n    return incrList.size();\\n  }\\n\\n  // Perform Binary Search to get the next greater element\\n  int nextGreaterItem(List<Integer> list, int num){\\n    int left = 0, right = list.size()-1;\\n    while(left < right) {\\n      int mid = left + (right - left) / 2;\\n      if(num >= list.get(mid))\\n        left = mid + 1;\\n      else\\n        right = mid;\\n    }\\n    return left;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nMin operations to make it increasing = Length of extracted subsequence - LIS of the extracted subsequence\\n```\n```\\narr = [4,1,5,2,6,2,8,9,11,15]\\n       1     1     1      1\\n         2     2     2\\n           3     3     3 \\nk=3\\n\\nk-seperated subsequences of arr:\\n#   subsequence      length     LIS      Operations(length - LIS)\\n1   [4,2,8,15]          4        3           1\\n2   [1,6,9]             3        3           0\\n3   [5,2,11]            3        2           1\\n--------------------------------------------------\\nTotal Operations =                           2\\n-------------------------------------------------\\n```\n```\\nclass Solution {\\n  public int kIncreasing(int[] arr, int k) {\\n    int total = 0;\\n    for(int i=0; i < k; i++){\\n      List<Integer> list = new ArrayList<>();\\n      for(int j=i; j < arr.length; j = j+k)\\n        list.add(arr[j]);\\n      total += list.size() - lengthOfLIS(list);\\n    }\\n    return total;\\n  }\\n  \\n  // Get the length of LIS by building an increasing List so as to perform binary search on it \\n  // in case the current element is lesser than the last element in the increasing List. \\n  // In such case we get the next greater element from the increasing List by doing a binary Search and \\n  // replace that with the the current element in the increasing List, as the other element is no longer relevant in participating in LIS. \\n  // The increasing List remains sorted and always maintain the max length of the increasing subsequence.\\n  public int lengthOfLIS(List<Integer> nums){\\n    List<Integer> incrList = new ArrayList<>();\\n    incrList.add(nums.get(0));\\n\\n    for(int i=1; i < nums.size(); i++){\\n      int lastItem = incrList.get(incrList.size()-1);\\n      if(nums.get(i) >= lastItem){\\n        incrList.add(nums.get(i));\\n      } else {\\n        int idx = nextGreaterItem(incrList, nums.get(i));\\n        incrList.set(idx, nums.get(i));\\n      }\\n    }\\n    return incrList.size();\\n  }\\n\\n  // Perform Binary Search to get the next greater element\\n  int nextGreaterItem(List<Integer> list, int num){\\n    int left = 0, right = list.size()-1;\\n    while(left < right) {\\n      int mid = left + (right - left) / 2;\\n      if(num >= list.get(mid))\\n        left = mid + 1;\\n      else\\n        right = mid;\\n    }\\n    return left;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634978,
                "title": "python-short-lis-explained",
                "content": "There are two observations we need to make.\\n1. It is independent to consider subproblems on `0, k, 2k, ...`, `1, k+1, 2k+1, ...` and so on.\\n2. For each subproblem it is enough to solve LIS (longest increasing(not strictly) subsequence) problem. Indeed, if we have LIS of length `t`, than we need to change not more than `R-t` elements, where `R` is size of our subproblem. From the other side, we can not change less number of elements, because if we changed `< R- t` elements it means that `> t` elements were unchanged and it means we found LIS of length `> t`. This is called **estimate + example** technique in math.\\n\\n\\n#### Complexity\\nIt is `O(n log n)` for time and `O(n)` for space.\\n\\n#### Code\\n```python\\nfrom bisect import bisect\\n\\nclass Solution:\\n    def LIS(self, nums):\\n        dp = [10**10] * (len(nums) + 1)\\n        for elem in nums: dp[bisect(dp, elem)] = elem  \\n        return dp.index(10**10)\\n    \\n    def kIncreasing(self, arr, k):\\n        ans = 0\\n        for i in range(k):\\n            A = arr[i::k]\\n            ans += len(A) - self.LIS(A)\\n    \\n        return ans\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nfrom bisect import bisect\\n\\nclass Solution:\\n    def LIS(self, nums):\\n        dp = [10**10] * (len(nums) + 1)\\n        for elem in nums: dp[bisect(dp, elem)] = elem  \\n        return dp.index(10**10)\\n    \\n    def kIncreasing(self, arr, k):\\n        ans = 0\\n        for i in range(k):\\n            A = arr[i::k]\\n            ans += len(A) - self.LIS(A)\\n    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634986,
                "title": "longest-increasing-subsequence-explanation-code",
                "content": "*  There will be K **independent** arrays each having max length n/k\\n*  Independently find **lis** of all K independent arrays (using binary search/BIT)\\n*  **Minimum change = length of the array - lis of the array**\\n*  Sum all the minimum change needed for all K arrays\\n\\n**CODE** (CPP)\\n```\\nclass Solution {\\npublic:\\n      int getlis(vector<int>&a) {\\n            vector<int>v;\\n            for (auto p : a) {\\n                  auto it = upper_bound(v.begin(), v.end(), p);\\n                  if (it == v.end()) {\\n                        v.push_back(p);\\n                  }\\n                  else {\\n                        *it = p;\\n                  }\\n            }\\n            return v.size();\\n      }\\n      int kIncreasing(vector<int>& arr, int k) {\\n            const int n = arr.size();\\n            vector<vector<int>>v(k);\\n            for (int i = 0; i < n; i++) {\\n                  v[i % k].push_back(arr[i]);\\n            }\\n\\n            int ans = 0;\\n            for (int i = 0; i < k; i++) {\\n                  int lis = getlis(v[i]);\\n                  ans += v[i].size() - lis;\\n            }\\n            return ans;\\n      }\\n};\\n```\\n**Time complexity :**\\nO((k)*(n/k)log(n/k)) = O(nlog(n/k))\\n\\n**Useful Problem Link**\\nhttps://leetcode.com/problems/longest-increasing-subsequence/\\n\\n**Do Upvote** if you liked the solution.\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      int getlis(vector<int>&a) {\\n            vector<int>v;\\n            for (auto p : a) {\\n                  auto it = upper_bound(v.begin(), v.end(), p);\\n                  if (it == v.end()) {\\n                        v.push_back(p);\\n                  }\\n                  else {\\n                        *it = p;\\n                  }\\n            }\\n            return v.size();\\n      }\\n      int kIncreasing(vector<int>& arr, int k) {\\n            const int n = arr.size();\\n            vector<vector<int>>v(k);\\n            for (int i = 0; i < n; i++) {\\n                  v[i % k].push_back(arr[i]);\\n            }\\n\\n            int ans = 0;\\n            for (int i = 0; i < k; i++) {\\n                  int lis = getlis(v[i]);\\n                  ans += v[i].size() - lis;\\n            }\\n            return ans;\\n      }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635173,
                "title": "java-longest-non-decreasing-subsequence-k-times",
                "content": "Based on [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/), but allowing duplicates in sequence (hence non-decreasing).\\nTo solve the problem:\\n- iterate k subsequences of the original sequence (elements separated by k steps belong to the same subsequence),\\n- calculate LIS for each subsequence (Java note: cannot use the built-in Arrays.binarySearch() as its behavior is undefined in presence of duplicates - a weird decision in the implementation of the Java standard libraries - we have no equivalent to C++ lower_bound and upper_bound; to handle dupes we need our own upperBound() method),\\n- elements NOT in LIS need to be changed to make the whole subsequence non-decreasing.\\n\\nComplexity: **time O(n log(n/k)), space O(n/k)**\\n\\nBonus materials: \\n- a nice [intro to LIS](https://www.cs.princeton.edu/courses/archive/spring13/cos423/lectures/LongestIncreasingSubsequence.pdf), \\n- another (partial) LIS algo problem: [334. Increasing Triplet Subsequence](https://leetcode.com/problems/increasing-triplet-subsequence/)\\n\\n```\\nclass Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        int kLenLIS= 0, dp[]= new int[arr.length/k+1];\\n        for(int i=0; i<k; i++)\\n            kLenLIS+= lengthOfLIS(arr, i, k, dp);\\n        return arr.length - kLenLIS;\\n    }\\n    \\n    public int lengthOfLIS(int[] arr, int start, int k, int[] dp) {\\n        int len= 0;\\n        for(int i=start; i<arr.length; i+=k) {\\n            int j= upperBound(dp, len, arr[i]);\\n            if(j==len) len++;\\n\\t\\t\\tdp[j]= arr[i];\\n        }\\n        return len;\\n    }\\n    \\n    int upperBound(int[] dp, int len, int num){\\n        int ans= len, l= 0, r= len-1;\\n        while(l<=r){\\n            int mid= l+(r-l)/2;\\n            if(dp[mid]<=num){\\n                l= mid+1;\\n            }else{\\n                ans= mid;\\n                r= mid-1;\\n            }\\n        }\\n        return ans;        \\n    }\\n}\\n```\\n\\n\\nA concise, but much less readable version below.\\n\\n```\\npublic int kIncreasing(int[] arr, int k) {\\n\\tint kLenLIS= 0, n= arr.length, dp[]= new int[n/k+1];\\n\\tfor(int i=0, len=0; i<k; i++, kLenLIS+=len, len=0)\\n\\t\\tfor(int l, r, mid, ans, j=i; j<n; dp[ans==len?len++:ans]= arr[j], j+=k)\\n\\t\\t\\tfor(ans=len, l=0, r=len-1; l<=r;)\\n\\t\\t\\t\\tif(dp[mid= l+(r-l)/2]<=arr[j]) l= mid+1;\\n\\t\\t\\t\\telse r= (ans= mid)-1;\\n\\treturn n - kLenLIS;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        int kLenLIS= 0, dp[]= new int[arr.length/k+1];\\n        for(int i=0; i<k; i++)\\n            kLenLIS+= lengthOfLIS(arr, i, k, dp);\\n        return arr.length - kLenLIS;\\n    }\\n    \\n    public int lengthOfLIS(int[] arr, int start, int k, int[] dp) {\\n        int len= 0;\\n        for(int i=start; i<arr.length; i+=k) {\\n            int j= upperBound(dp, len, arr[i]);\\n            if(j==len) len++;\\n\\t\\t\\tdp[j]= arr[i];\\n        }\\n        return len;\\n    }\\n    \\n    int upperBound(int[] dp, int len, int num){\\n        int ans= len, l= 0, r= len-1;\\n        while(l<=r){\\n            int mid= l+(r-l)/2;\\n            if(dp[mid]<=num){\\n                l= mid+1;\\n            }else{\\n                ans= mid;\\n                r= mid-1;\\n            }\\n        }\\n        return ans;        \\n    }\\n}\\n```\n```\\npublic int kIncreasing(int[] arr, int k) {\\n\\tint kLenLIS= 0, n= arr.length, dp[]= new int[n/k+1];\\n\\tfor(int i=0, len=0; i<k; i++, kLenLIS+=len, len=0)\\n\\t\\tfor(int l, r, mid, ans, j=i; j<n; dp[ans==len?len++:ans]= arr[j], j+=k)\\n\\t\\t\\tfor(ans=len, l=0, r=len-1; l<=r;)\\n\\t\\t\\t\\tif(dp[mid= l+(r-l)/2]<=arr[j]) l= mid+1;\\n\\t\\t\\t\\telse r= (ans= mid)-1;\\n\\treturn n - kLenLIS;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634968,
                "title": "c-solution-group-and-lis",
                "content": "\\n\\n1. group arr into k groups.\\n2. get LIS for each group, accumulate `group.size - LIS`.\\n```\\nclass Solution {\\npublic:\\n    int LIS(vector<int> &arr) {\\n        vector<int> lis(arr.size(), INT_MAX);\\n        int ans = 0;\\n        for(int i = 0; i < arr.size(); i++) {\\n            int idx = upper_bound(lis.begin(), lis.end(), arr[i]) - lis.begin();\\n            ans = max(idx + 1, ans);\\n            lis[idx] = arr[i];\\n        }\\n        return arr.size() - ans;\\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n        vector<vector<int> > group(k);\\n        for(int i = 0; i < k; i++) {\\n            for(int j = i; j < arr.size(); j+=k) {\\n                group[i].push_back(arr[j]);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto &v : group) {\\n            ans += LIS(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int LIS(vector<int> &arr) {\\n        vector<int> lis(arr.size(), INT_MAX);\\n        int ans = 0;\\n        for(int i = 0; i < arr.size(); i++) {\\n            int idx = upper_bound(lis.begin(), lis.end(), arr[i]) - lis.begin();\\n            ans = max(idx + 1, ans);\\n            lis[idx] = arr[i];\\n        }\\n        return arr.size() - ans;\\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n        vector<vector<int> > group(k);\\n        for(int i = 0; i < k; i++) {\\n            for(int j = i; j < arr.size(); j+=k) {\\n                group[i].push_back(arr[j]);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto &v : group) {\\n            ans += LIS(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636127,
                "title": "python-c-java-lis-100-faster-detailed-explanation-clean-and-easy-to-understand",
                "content": "* First divide arr into k groups and consider each group individually.\\n* In each group, we need to find out the length of the longest increasing sequence, because the longest increasing sequence does not need to be operated, and the remaining positions can be set to the value of the previous or next in the longest increasing sequence.\\n* For example, `arr = [2, 3, 4, 2, 3 , 3]`\\n\\t* the longest increasing sequence is [2, 2, 3, 3], that is [**2**, 3, 4, **2**, **3** , **3**]\\n\\t* we can modify arr[1] from 3 to 2 and arr[2] from 4 to 2, and then the arr is increasing, that is [2, 2, 2, 2, 3, 3]\\n\\t* after all we need to make 2 operations to make `arr = [2, 3, 4, 2, 3 , 3]` increasing, that is `len(arr) - len(lis(arr))`\\n\\n[Prob 300 Longest-Increasing-Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/discuss/74824/JavaPython-Binary-search-O(nlogn)-time-with-explanation), **@dietpepsi explained very well, I just copied his explanation below.**\\n\\n`tails` **is an array storing the smallest tail of all increasing subsequences with length** `i+1` in `tails[i]`.\\nFor example, say we have `nums = [4,5,6,3]`, then all the available increasing subsequences are:\\n\\n```\\nlen = 1   :      [4], [5], [6], [3]   => tails[0] = 3\\nlen = 2   :      [4, 5], [5, 6]       => tails[1] = 5\\nlen = 3   :      [4, 5, 6]            => tails[2] = 6\\n```\\nWe can easily prove that tails is a increasing array. Therefore it is possible to do a binary search in tails array to find the one needs update.\\n\\n\\n\\n```\\n(1) if x is larger than all tails, append it, increase the size by 1\\n(2) if tails[i-1] < x <= tails[i], update tails[i]\\n```\\n\\n\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!**\\n\\n**Python 100% Faster**\\n```\\nclass Solution(object):\\n    def kIncreasing(self, arr, k):\\n        ans = len(arr)\\n        for i in range(k):\\n            tails = []\\n            for j in range(i, len(arr), k):\\n                if tails and tails[-1] > arr[j]:\\n                    tails[bisect.bisect(tails, arr[j])] = arr[j]\\n                else:\\n                    tails.append(arr[j])\\n            ans -= len(tails)\\n        return ans\\n```\\n\\n**C++ 63.64% Faster**\\n```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int ans = arr.size();\\n        for(int i = 0; i < k; i ++) {\\n            vector<int> tails;\\n            for(int j = i; j < arr.size(); j += k) {\\n                if(tails.size() == 0 or arr[j] >= tails[tails.size() - 1]) {\\n                    tails.push_back(arr[j]);\\n                } else {\\n                    tails[upper_bound(tails.begin(), tails.end(), arr[j]) - tails.begin()] = arr[j];\\n                }\\n            }\\n            ans -= tails.size();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Java 100% Faster**\\n* I\\'m not very good at Java, and I did not find a function like bisect in Python, so I implement one below, that\\'s why the java code is longer than C++ or Python above.\\n* I hope friends who are good at java can help me simplify the Java code below.\\n```\\nclass Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        int ans = arr.length;\\n        int[] tails = new int[arr.length];\\n        for (int i = 0; i < k; i ++) {\\n            int size = 0;\\n            for (int j = i; j < arr.length; j += k) {\\n                if (size == 0 || arr[j] >= tails[size - 1]) {\\n                    tails[size ++] = arr[j];\\n                } else {\\n                    int low = 0, high = size - 1;\\n                    while (low <= high) {\\n                        int mid = (low + high) / 2;\\n                        if (tails[mid] <= arr[j] && tails[mid + 1] > arr[j]) {\\n                            tails[mid + 1] = arr[j];\\n                            break;\\n                        } else if (tails[mid + 1] <= arr[j]) {\\n                            low = mid + 1;\\n                        } else {\\n                            high = mid - 1;\\n                        }\\n                    }\\n                    if (low > high) {\\n                        tails[0] = arr[j];\\n                    }\\n                }\\n            }\\n            ans -= size;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nlen = 1   :      [4], [5], [6], [3]   => tails[0] = 3\\nlen = 2   :      [4, 5], [5, 6]       => tails[1] = 5\\nlen = 3   :      [4, 5, 6]            => tails[2] = 6\\n```\n```\\n(1) if x is larger than all tails, append it, increase the size by 1\\n(2) if tails[i-1] < x <= tails[i], update tails[i]\\n```\n```\\nclass Solution(object):\\n    def kIncreasing(self, arr, k):\\n        ans = len(arr)\\n        for i in range(k):\\n            tails = []\\n            for j in range(i, len(arr), k):\\n                if tails and tails[-1] > arr[j]:\\n                    tails[bisect.bisect(tails, arr[j])] = arr[j]\\n                else:\\n                    tails.append(arr[j])\\n            ans -= len(tails)\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int ans = arr.size();\\n        for(int i = 0; i < k; i ++) {\\n            vector<int> tails;\\n            for(int j = i; j < arr.size(); j += k) {\\n                if(tails.size() == 0 or arr[j] >= tails[tails.size() - 1]) {\\n                    tails.push_back(arr[j]);\\n                } else {\\n                    tails[upper_bound(tails.begin(), tails.end(), arr[j]) - tails.begin()] = arr[j];\\n                }\\n            }\\n            ans -= tails.size();\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        int ans = arr.length;\\n        int[] tails = new int[arr.length];\\n        for (int i = 0; i < k; i ++) {\\n            int size = 0;\\n            for (int j = i; j < arr.length; j += k) {\\n                if (size == 0 || arr[j] >= tails[size - 1]) {\\n                    tails[size ++] = arr[j];\\n                } else {\\n                    int low = 0, high = size - 1;\\n                    while (low <= high) {\\n                        int mid = (low + high) / 2;\\n                        if (tails[mid] <= arr[j] && tails[mid + 1] > arr[j]) {\\n                            tails[mid + 1] = arr[j];\\n                            break;\\n                        } else if (tails[mid + 1] <= arr[j]) {\\n                            low = mid + 1;\\n                        } else {\\n                            high = mid - 1;\\n                        }\\n                    }\\n                    if (low > high) {\\n                        tails[0] = arr[j];\\n                    }\\n                }\\n            }\\n            ans -= size;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634980,
                "title": "c-longest-increasing-subsequence",
                "content": "\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Longest Increasing Subsequence (LIS)\\n\\nSplit the numbers in `A` into `k` groups: `[0, k, 2k, 3k, ...]`, `[1, 1+k, 1+2k, 1+3k, ...]`, ...\\n\\nCompute the minimum operations needed to make a group non-decreasing. Assume the Longest Increasing Subsequence (LIS) of this group is of length `t`, and the group is of length `len`, then the minimum operations needed is `len - t`.\\n\\nComputing the length of LIS is a classic problem that can be solved using binary search. See [300. Longest Increasing Subsequence (Medium)](https://leetcode.com/problems/longest-increasing-subsequence/)\\n\\nThe answer is the sum of minimum operations for all the groups.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-272/problems/minimum-operations-to-make-the-array-k-increasing/\\n// Author: github.com/lzl124631x\\n// Time: O(Nlog(N/k))\\n// Space: O(N/k)\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& A, int k) {\\n        int N = A.size(), ans = 0;\\n        for (int i = 0; i < k; ++i) {\\n            vector<int> v{A[i]};\\n            int len = 1;\\n            for (int j = i + k; j < N; j += k) {\\n                auto i = upper_bound(begin(v), end(v), A[j]);\\n                if (i == end(v)) v.push_back(A[j]);\\n                else *i = A[j];\\n                ++len;\\n            }\\n            ans += len - v.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-272/problems/minimum-operations-to-make-the-array-k-increasing/\\n// Author: github.com/lzl124631x\\n// Time: O(Nlog(N/k))\\n// Space: O(N/k)\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& A, int k) {\\n        int N = A.size(), ans = 0;\\n        for (int i = 0; i < k; ++i) {\\n            vector<int> v{A[i]};\\n            int len = 1;\\n            for (int j = i + k; j < N; j += k) {\\n                auto i = upper_bound(begin(v), end(v), A[j]);\\n                if (i == end(v)) v.push_back(A[j]);\\n                else *i = A[j];\\n                ++len;\\n            }\\n            ans += len - v.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635349,
                "title": "c-longest-increasing-subsequence-variation",
                "content": "Goal : to find the minimum numbers of operations to make this array k-increasing.\\nApproach: find the minimum numbers of operation of each increasing subsequence( formed by arr[i] -> arr[i+k] -> arr[i+2k] -> ...  where 0<=i<k ) and add them up.\\n\\nFinding the minimum operations: if we find the longest non-decreasing subsequence of that particular array.\\n                                                      then the elements which are not the part of this subsequence are the one whose\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  value is to be changed i.e. the minimum numbers of operations.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\tminimum no. of operations = size of the array  -   size of longest non decreasing subsequence\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperation(vector<int> v)\\n    {\\n        vector<int> lis;  // creating a longest non decreasing subsequence\\n        lis.push_back(v[0]);  // adding first element into the array\\n        for(int i=1;i<v.size();i++)\\n        {\\n            if(lis.back()<=v[i])  // if the last element is smaller than the current element\\n                lis.push_back(v[i]);  // add it to the array\\n            else {\\n\\t\\t\\t   // if the last element is larger \\n\\t\\t\\t   // then we find the position of the current element \\n\\t\\t\\t   // and assign this value to that position \\n\\t\\t\\t   // in this way we are are constructing the largest subsequence of non-decreasing elements.\\n                int index=upper_bound(lis.begin(),lis.end(),v[i])-lis.begin();  \\n                lis[index]=v[i];\\n            }\\n        }\\n        return v.size()-lis.size();\\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n         if(k==arr.size())   // if the value of k is equal to the size of array then\\n            return 0;          // it is already k-increasing\\n        int n=arr.size();\\n        int result=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> v;   // creating array for every subsequence that needs to be checked for min. no. of operations.\\n           for(int j=i;j<n;j+=k)\\n              v.push_back(arr[j]);   \\n\\t\\t\\t  // here minOperation function will find the minimum no. of operations of a particular array.\\n           result=result+minOperation(v); // adding result of each one \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperation(vector<int> v)\\n    {\\n        vector<int> lis;  // creating a longest non decreasing subsequence\\n        lis.push_back(v[0]);  // adding first element into the array\\n        for(int i=1;i<v.size();i++)\\n        {\\n            if(lis.back()<=v[i])  // if the last element is smaller than the current element\\n                lis.push_back(v[i]);  // add it to the array\\n            else {\\n\\t\\t\\t   // if the last element is larger \\n\\t\\t\\t   // then we find the position of the current element \\n\\t\\t\\t   // and assign this value to that position \\n\\t\\t\\t   // in this way we are are constructing the largest subsequence of non-decreasing elements.\\n                int index=upper_bound(lis.begin(),lis.end(),v[i])-lis.begin();  \\n                lis[index]=v[i];\\n            }\\n        }\\n        return v.size()-lis.size();\\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n         if(k==arr.size())   // if the value of k is equal to the size of array then\\n            return 0;          // it is already k-increasing\\n        int n=arr.size();\\n        int result=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> v;   // creating array for every subsequence that needs to be checked for min. no. of operations.\\n           for(int j=i;j<n;j+=k)\\n              v.push_back(arr[j]);   \\n\\t\\t\\t  // here minOperation function will find the minimum no. of operations of a particular array.\\n           result=result+minOperation(v); // adding result of each one \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635152,
                "title": "c-simple-lis-simple-and-short-solution-explained",
                "content": "```\\n//function to calculate LIS in O(n*logn) using binary search and DP\\n//NOTE : O(n*n) method of finding LIS will give TLE\\nint helper(vector<int>&nums){\\n          vector<int> lis;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            int x = nums[i];\\n            if (lis.empty() || lis[lis.size() - 1] <= x) { \\n                lis.push_back(x);\\n                nums[i] = lis.size();\\n            } else {\\n                int idx = upper_bound(lis.begin(), lis.end(), x) - lis.begin(); \\n                lis[idx] = x; \\n                nums[i] = idx + 1;\\n            }\\n        }\\n        // cout<<lis.size()<<endl;\\n        return lis.size();\\n    }\\n\\nint kIncreasing(vector<int>& arr, int k) {\\n        \\n        int res = 0;\\n        \\n\\t\\t//in this ques , we only have to form k sub seq\\n\\t\\t//for each subarray the answer will be\\n\\t\\t//len(curr_subseq) - len(lis in that sub seq)\\n\\t\\t//hence, adding ans for all k sub seq\\n\\t\\t// we get our required answer\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> temp;\\n            for(int j=i;j<size(arr);j+=k)\\n                temp.push_back(arr[j]);\\n            \\n            res += size(temp) - helper(temp);\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\n//function to calculate LIS in O(n*logn) using binary search and DP\\n//NOTE : O(n*n) method of finding LIS will give TLE\\nint helper(vector<int>&nums){\\n          vector<int> lis;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            int x = nums[i];\\n            if (lis.empty() || lis[lis.size() - 1] <= x) { \\n                lis.push_back(x);\\n                nums[i] = lis.size();\\n            } else {\\n                int idx = upper_bound(lis.begin(), lis.end(), x) - lis.begin(); \\n                lis[idx] = x; \\n                nums[i] = idx + 1;\\n            }\\n        }\\n        // cout<<lis.size()<<endl;\\n        return lis.size();\\n    }\\n\\nint kIncreasing(vector<int>& arr, int k) {\\n        \\n        int res = 0;\\n        \\n\\t\\t//in this ques , we only have to form k sub seq\\n\\t\\t//for each subarray the answer will be\\n\\t\\t//len(curr_subseq) - len(lis in that sub seq)\\n\\t\\t//hence, adding ans for all k sub seq\\n\\t\\t// we get our required answer\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> temp;\\n            for(int j=i;j<size(arr);j+=k)\\n                temp.push_back(arr[j]);\\n            \\n            res += size(temp) - helper(temp);\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1634987,
                "title": "c-with-explanation-longest-non-decreasing-subsequence",
                "content": "**Explanation:-**\\n1. if we see carefully then we will find that we have to make these subsequences non-decreasing:-\\n  ```arr[i]<=arr[i+k]<=arr[i+2k]... so on```\\n    here ```i``` wil start from ```0``` and go upto ```k-1```\\n2. For making these non-decreasing we have to find ```longest non-decreasing subsequence``` in these sequences\\t.\\n3. Our answer will be length(temp)-length(longest non-decreasing subsequence) in ```temp sequence```\\n\\t\\n```\\n\\tclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int size=arr.size(),ans=0;\\n            for(int i=0;i<k;i++){\\n                vector<int>temp;\\n                // finding subsequence which follows arr[i]<=arr[i+k]<=arr[i+2k]. this pattern\\n                for(int j=i;j<size;j+=k)\\n                    temp.push_back(arr[j]);\\n                // getting the length of longest non-decreasing subsequence in this pattern\\n                int cnt=helper(temp);\\n                // elements which are not a part of this longest non-decreasing subsequence are our answer(we have to change them)\\n                ans+=temp.size()-cnt;\\n                \\n            }\\n        return ans;\\n    }\\n    // finding longest non-decreasing subsequence\\n    int helper(vector<int>&nums){\\n          vector<int> lis;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            int x = nums[i];\\n            if (lis.empty() || lis[lis.size() - 1] <= x) { \\n                lis.push_back(x);\\n                nums[i] = lis.size();\\n            } else {\\n                int idx = upper_bound(lis.begin(), lis.end(), x) - lis.begin(); \\n                lis[idx] = x; \\n                nums[i] = idx + 1;\\n            }\\n        }\\n        // cout<<lis.size()<<endl;\\n        return lis.size();\\n    }\\n};\\n```\\n\\t\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```arr[i]<=arr[i+k]<=arr[i+2k]... so on```\n```i```\n```0```\n```k-1```\n```longest non-decreasing subsequence```\n```temp sequence```\n```\\n\\tclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int size=arr.size(),ans=0;\\n            for(int i=0;i<k;i++){\\n                vector<int>temp;\\n                // finding subsequence which follows arr[i]<=arr[i+k]<=arr[i+2k]. this pattern\\n                for(int j=i;j<size;j+=k)\\n                    temp.push_back(arr[j]);\\n                // getting the length of longest non-decreasing subsequence in this pattern\\n                int cnt=helper(temp);\\n                // elements which are not a part of this longest non-decreasing subsequence are our answer(we have to change them)\\n                ans+=temp.size()-cnt;\\n                \\n            }\\n        return ans;\\n    }\\n    // finding longest non-decreasing subsequence\\n    int helper(vector<int>&nums){\\n          vector<int> lis;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            int x = nums[i];\\n            if (lis.empty() || lis[lis.size() - 1] <= x) { \\n                lis.push_back(x);\\n                nums[i] = lis.size();\\n            } else {\\n                int idx = upper_bound(lis.begin(), lis.end(), x) - lis.begin(); \\n                lis[idx] = x; \\n                nums[i] = idx + 1;\\n            }\\n        }\\n        // cout<<lis.size()<<endl;\\n        return lis.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2090164,
                "title": "c-o-nlog-n",
                "content": "// If u observe carefully you will get to know that the problem is similar to LIS(Longest Increasing Subsequence) problem. In LIS we have only one set of data to find, but in this problem we have to find in k different set. If u dry run the test case u will find that all the set are independent to each other so we can treat all the set as seperate LIS.\\nclass Solution {\\npublic: \\n\\n    int kIncreasing(vector<int>& ar, int k) {\\n        int ans=0,n=ar.size();\\n        vector<int>lis;\\n        for(int i=0;i<k;i++)\\n        {\\n            int s=0;\\n            for(int j=i;j<n;j+=k)\\n            {\\n                auto it=upper_bound(lis.begin(),lis.end(),ar[j]);\\n                if(it==lis.end())\\n                    lis.push_back(ar[j]);\\n                else *it=ar[j];\\n                s++;\\n            }\\n            ans+=s-(int)lis.size();\\n            lis.clear();\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic: \\n\\n    int kIncreasing(vector<int>& ar, int k) {\\n        int ans=0,n=ar.size();\\n        vector<int>lis;\\n        for(int i=0;i<k;i++)\\n        {\\n            int s=0;\\n            for(int j=i;j<n;j+=k)\\n            {\\n                auto it=upper_bound(lis.begin(),lis.end(),ar[j]);\\n                if(it==lis.end())\\n                    lis.push_back(ar[j]);\\n                else *it=ar[j];\\n                s++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1741469,
                "title": "lis-cpp-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\nint lengthOfLIS(vector<int>& nums) {\\n    \\n    //LIS dp approach will give TLE\\n        int n=nums.size();\\n        vector<int> v;v.push_back(nums[0]);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>=v.back()) v.push_back(nums[i]);  \\n            else{\\n                int idx=upper_bound(v.begin(),v.end(),nums[i])-v.begin();\\n                v[idx]=nums[i]; \\n            }\\n        }\\n        return v.size();\\n       \\n    }\\n    \\n    \\n    int kIncreasing(vector<int>& arr, int k) {\\n        \\n        int ans=0;\\n        int n = arr.size();\\n        int temp=0;\\n        \\n        while(temp<k){\\n            vector<int>v;\\n            for(int i=temp;i<n;i+=k){\\n                v.push_back(arr[i]);\\n            }\\n            int curr=lengthOfLIS(v);\\n            ans+=(v.size()-curr);\\n            temp++;\\n        }\\n        \\n        return ans;\\n    }       \\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint lengthOfLIS(vector<int>& nums) {\\n    \\n    //LIS dp approach will give TLE\\n        int n=nums.size();\\n        vector<int> v;v.push_back(nums[0]);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>=v.back()) v.push_back(nums[i]);  \\n            else{\\n                int idx=upper_bound(v.begin(),v.end(),nums[i])-v.begin();\\n                v[idx]=nums[i]; \\n            }\\n        }\\n        return v.size();\\n       \\n    }\\n    \\n    \\n    int kIncreasing(vector<int>& arr, int k) {\\n        \\n        int ans=0;\\n        int n = arr.size();\\n        int temp=0;\\n        \\n        while(temp<k){\\n            vector<int>v;\\n            for(int i=temp;i<n;i+=k){\\n                v.push_back(arr[i]);\\n            }\\n            int curr=lengthOfLIS(v);\\n            ans+=(v.size()-curr);\\n            temp++;\\n        }\\n        \\n        return ans;\\n    }       \\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1638925,
                "title": "c-lis-modified-implementation",
                "content": "**PLEASE UPVOTE IF U LIKE MY SOLUTION AND EXPLANATION**\\n```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        \\n        int n=arr.size();\\n        \\n        //we consider a visited array so let say for i we traverse i+k,i+2*k,i+3*k,...\\n        //we do not need to consider doing operations for them again.\\n        vector<bool>vis(n,0);\\n        \\n        //total operations to make a {i+j*k} where j*k<n non-decreasing\\n        int Noperations=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            //we only consider when the element is not visited previously\\n            if(!vis[i])\\n            {\\n                //we perform the O(nlogn) approach of LIS but with some modification\\n                //as we want a non-decreasing sequence so repetition of element is allowed\\n                //in the LIS array\\n                vector<int>LIS;\\n                for(int j=i;j<n;j+=k)\\n                {\\n                    if(LIS.empty()||LIS.back()<=arr[j])\\n                        LIS.push_back(arr[j]);\\n                    else\\n                    {\\n                        int idx=upper_bound(LIS.begin(),LIS.end(),arr[j])-LIS.begin();\\n                        LIS[idx]=arr[j];\\n                    }\\n                    //we mark the processed element as visited\\n                    vis[j]=1;\\n                }\\n                //this is the count of elements which are in non-decreasing fashion\\n                //so we do not perform operations for Noperations elements\\n                Noperations+=LIS.size();\\n            }\\n        }\\n        //we have to perform operation for the remaining elements\\n        return n-Noperations;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        \\n        int n=arr.size();\\n        \\n        //we consider a visited array so let say for i we traverse i+k,i+2*k,i+3*k,...\\n        //we do not need to consider doing operations for them again.\\n        vector<bool>vis(n,0);\\n        \\n        //total operations to make a {i+j*k} where j*k<n non-decreasing\\n        int Noperations=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            //we only consider when the element is not visited previously\\n            if(!vis[i])\\n            {\\n                //we perform the O(nlogn) approach of LIS but with some modification\\n                //as we want a non-decreasing sequence so repetition of element is allowed\\n                //in the LIS array\\n                vector<int>LIS;\\n                for(int j=i;j<n;j+=k)\\n                {\\n                    if(LIS.empty()||LIS.back()<=arr[j])\\n                        LIS.push_back(arr[j]);\\n                    else\\n                    {\\n                        int idx=upper_bound(LIS.begin(),LIS.end(),arr[j])-LIS.begin();\\n                        LIS[idx]=arr[j];\\n                    }\\n                    //we mark the processed element as visited\\n                    vis[j]=1;\\n                }\\n                //this is the count of elements which are in non-decreasing fashion\\n                //so we do not perform operations for Noperations elements\\n                Noperations+=LIS.size();\\n            }\\n        }\\n        //we have to perform operation for the remaining elements\\n        return n-Noperations;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635473,
                "title": "o-nlogn-k-detailed-explanation-longest-non-decreasing-subsequence",
                "content": "We need to find minumum number of operations to make following arrays non-decreasing. \\n[arr[0], arr[k], arr[2k], ....]\\n[arr[1], arr[k + 1], arr[2k + 1], ...]\\n....\\n[arr[k - 1], arr[2k - 1], ...]\\n\\nClearly, each arrary listed above is independent of others, and we just need to find the minumum operation number for each array and add up all numbers to get the final result.\\n\\nFor each array, the number of operations needed is equal to `length of this array` - `length of longest non decreasing sequence of this array`. So our next step is to find a way to get the `length of longest non decreasing sequence`.\\n\\nLuckily,  length of longest increasing sequence is a well-studied question, and there are already many smart solutions for it:\\nhttps://leetcode.com/submissions/detail/603649213/\\n\\nAlthough you can solve it with O(n^2) dp, it\\'s recommended to use binary search for the O(nlogn) time complexity:\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        vector<int32_t> state;\\n        for (int32_t val : nums) {\\n            auto it {lower_bound(state.begin(), state.end(), val)};\\n            if (state.cend() == it) {\\n                state.push_back(val);\\n            } else {\\n                *it = val;\\n            }       \\n        }\\n\\n        return state.size();\\n    }\\n};\\n```\\n\\n\\n\\nWith all said above, the solution for this questions is straightforward now. But just keep it in mind that you need to replace `lower_bound` binary search with `upper_bound` since this question is asking non-decreasing instead of increasing. That\\'s it, cheers:\\n\\n```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        auto const n {static_cast<int32_t>(arr.size())};\\n        int32_t ans {0};\\n        for (int32_t start {0}; start < k; ++start) {       \\n            vector<int32_t> state;\\n            int32_t cnt {0};\\n            for (int32_t i {start}; i < n; i += k) {\\n                ++cnt;\\n                auto it {upper_bound(state.begin(), state.end(), arr[i])};\\n                if (it == state.end()) {\\n                    state.push_back(arr[i]);\\n                } else {\\n                    *it = arr[i];\\n                }\\n            }\\n            ans += (cnt - static_cast<int32_t>(state.size()));            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        vector<int32_t> state;\\n        for (int32_t val : nums) {\\n            auto it {lower_bound(state.begin(), state.end(), val)};\\n            if (state.cend() == it) {\\n                state.push_back(val);\\n            } else {\\n                *it = val;\\n            }       \\n        }\\n\\n        return state.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        auto const n {static_cast<int32_t>(arr.size())};\\n        int32_t ans {0};\\n        for (int32_t start {0}; start < k; ++start) {       \\n            vector<int32_t> state;\\n            int32_t cnt {0};\\n            for (int32_t i {start}; i < n; i += k) {\\n                ++cnt;\\n                auto it {upper_bound(state.begin(), state.end(), arr[i])};\\n                if (it == state.end()) {\\n                    state.push_back(arr[i]);\\n                } else {\\n                    *it = arr[i];\\n                }\\n            }\\n            ans += (cnt - static_cast<int32_t>(state.size()));            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635196,
                "title": "java-o-nlogn-binaray-search-for-lis-detailed-explanation",
                "content": "The problem is asking us to find a longest non-decreasing subsequence\\n**1. case when k == 1:**\\nwe are trying to minimize the change operation -> if we find a longest non-decreasing subsequence for arr, then \\nthe result would be **arr.length - length of LIS**\\n\\n**2. how to find a LIS ?**\\nwe use an ArrayList to record the longest non-decreasing subsequence, if the list is empty or the incoming element A >= the last element in list, we add incoming element to list, otherwise we find a best position i using binary-search, so that **list[i - 1] <= A < list[i]**, and set list[i] to A.\\ne.g arr = [4, 8, 9, 6, 6, 2], k = 1\\n1st iteration: list is empty, add 4, list becomes [4]\\n2nd: 8 > 4, add 8, list becomes [4, 8]\\n3rd: 9 > 8, add 9, list becomes [4, 8, 9]\\n4th: 6 < 9, binary search the index, we find position = 1, set list[1] to 6, list becomes [4, 6, 9]\\n5th: 6 < 9, posiiton = 2, set list[2] to 6, list becomes [4, 6, 6]\\n6th: list becomes [2, 6, 6]\\nThe minimum operation would be **length of list - list.size()**\\n\\n**3. case when k > 1**\\nsam as case 1, only we are finding k LIS rather than 1 LIS, for each subarray with k intervals, we calculate **length of subarray - LIS.size()** and add it to result. \\n\\n```\\nclass Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        //arr = new int[]{12,6,12,6,14,2,13,17,3,8,11,7,4,11,18,8,8,3};\\n        //k = 1;\\n        int res = 0;\\n        for (int i = 0; i < k; i++) {\\n            int j = i;\\n            ArrayList<Integer> list = new ArrayList();\\n            int count = 0;\\n            while (j < arr.length) {\\n                if (list.isEmpty() || list.get(list.size() - 1) <= arr[j]) {\\n                    list.add(arr[j]);\\n                } else {\\n                    list.set(bs(list, arr[j]), arr[j]);\\n                }\\n                j += k;\\n                count++;\\n            }\\n            res += count - list.size();\\n        }\\n        return res;\\n    }\\n\\n    public int bs(ArrayList<Integer> list, int num) {\\n        int l = 0;\\n        int r = list.size() - 1;\\n        while (l <= r) {\\n            int mid = (l + r) >> 1;\\n            if (list.get(mid) <= num) {\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        //arr = new int[]{12,6,12,6,14,2,13,17,3,8,11,7,4,11,18,8,8,3};\\n        //k = 1;\\n        int res = 0;\\n        for (int i = 0; i < k; i++) {\\n            int j = i;\\n            ArrayList<Integer> list = new ArrayList();\\n            int count = 0;\\n            while (j < arr.length) {\\n                if (list.isEmpty() || list.get(list.size() - 1) <= arr[j]) {\\n                    list.add(arr[j]);\\n                } else {\\n                    list.set(bs(list, arr[j]), arr[j]);\\n                }\\n                j += k;\\n                count++;\\n            }\\n            res += count - list.size();\\n        }\\n        return res;\\n    }\\n\\n    public int bs(ArrayList<Integer> list, int num) {\\n        int l = 0;\\n        int r = list.size() - 1;\\n        while (l <= r) {\\n            int mid = (l + r) >> 1;\\n            if (list.get(mid) <= num) {\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635109,
                "title": "python3-almost-lis",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/55c6a88797eef9ac745a3dbbff821a2aac735a70) for solutions of weekly 272. \\n\\n```\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        \\n        def fn(sub): \\n            \"\"\"Return ops to make sub non-decreasing.\"\"\"\\n            vals = []\\n            for x in sub: \\n                k = bisect_right(vals, x)\\n                if k == len(vals): vals.append(x)\\n                else: vals[k] = x\\n            return len(sub) - len(vals)\\n        \\n        return sum(fn(arr[i:len(arr):k]) for i in range(k))\\n```\\n\\nAlternative implementation \\n```\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        ans = 0 \\n        for _ in range(k): \\n            vals = []\\n            for i in range(_, len(arr), k): \\n                if not vals or vals[-1] <= arr[i]: vals.append(arr[i])\\n                else: vals[bisect_right(vals, arr[i])] = arr[i]\\n            ans += len(vals)\\n        return len(arr) - ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        \\n        def fn(sub): \\n            \"\"\"Return ops to make sub non-decreasing.\"\"\"\\n            vals = []\\n            for x in sub: \\n                k = bisect_right(vals, x)\\n                if k == len(vals): vals.append(x)\\n                else: vals[k] = x\\n            return len(sub) - len(vals)\\n        \\n        return sum(fn(arr[i:len(arr):k]) for i in range(k))\\n```\n```\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        ans = 0 \\n        for _ in range(k): \\n            vals = []\\n            for i in range(_, len(arr), k): \\n                if not vals or vals[-1] <= arr[i]: vals.append(arr[i])\\n                else: vals[bisect_right(vals, arr[i])] = arr[i]\\n            ans += len(vals)\\n        return len(arr) - ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635016,
                "title": "c-o-n-log-n-based-on-longest-increasing-subsequence",
                "content": "```csharp\\npublic int KIncreasing(int[] arr, int k)\\n{\\n\\tint count = 0;\\n\\tList<int>[] current = new List<int>[k];\\n\\tfor (int i = 0; i < k; i++)\\n\\t{\\n\\t\\tcurrent[i] = new List<int>();\\n\\t}\\n\\n\\tfor (int i = 0; i < arr.Length; i++)\\n\\t{\\n\\t\\tint index = i % k;\\n\\t\\tcurrent[index].Add(arr[i]);\\n\\t}\\n\\n\\tforeach (var list in current)\\n\\t{\\n\\t\\tcount += findMin(list);\\n\\t}\\n\\n\\treturn count;\\n}\\n\\nprivate int findMin(List<int> nums)\\n{\\n\\tint[] d = new int[nums.Count];\\n\\tint count = 0;\\n\\n\\tforeach (int num in nums)\\n\\t{\\n\\t\\tint index = Array.BinarySearch(d, 0, count, num);\\n\\t\\tif (index < 0)\\n\\t\\t{\\n\\t\\t\\tindex = ~index;\\n\\t\\t}\\n\\n\\t\\tif (d[index] == num)\\n\\t\\t{\\n\\t\\t\\tindex = Array.BinarySearch(d, 0, count, num + 1);\\n\\t\\t\\tif (index < 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tindex = ~index;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\td[index] = num;\\n\\t\\tif (index == count)\\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t}\\n\\n\\treturn nums.Count - count;\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int KIncreasing(int[] arr, int k)\\n{\\n\\tint count = 0;\\n\\tList<int>[] current = new List<int>[k];\\n\\tfor (int i = 0; i < k; i++)\\n\\t{\\n\\t\\tcurrent[i] = new List<int>();\\n\\t}\\n\\n\\tfor (int i = 0; i < arr.Length; i++)\\n\\t{\\n\\t\\tint index = i % k;\\n\\t\\tcurrent[index].Add(arr[i]);\\n\\t}\\n\\n\\tforeach (var list in current)\\n\\t{\\n\\t\\tcount += findMin(list);\\n\\t}\\n\\n\\treturn count;\\n}\\n\\nprivate int findMin(List<int> nums)\\n{\\n\\tint[] d = new int[nums.Count];\\n\\tint count = 0;\\n\\n\\tforeach (int num in nums)\\n\\t{\\n\\t\\tint index = Array.BinarySearch(d, 0, count, num);\\n\\t\\tif (index < 0)\\n\\t\\t{\\n\\t\\t\\tindex = ~index;\\n\\t\\t}\\n\\n\\t\\tif (d[index] == num)\\n\\t\\t{\\n\\t\\t\\tindex = Array.BinarySearch(d, 0, count, num + 1);\\n\\t\\t\\tif (index < 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tindex = ~index;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\td[index] = num;\\n\\t\\tif (index == count)\\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t}\\n\\n\\treturn nums.Count - count;\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3918727,
                "title": "c-super-easy-clean-code-lis-easy-to-grasp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int lnds(vector<int>& arr){\\n        vector<int> temp;\\n        int n = arr.size();\\n\\n        for(int i=0; i<n; i++){\\n            if(temp.size() == 0 || temp.back() <= arr[i]){\\n                temp.push_back(arr[i]);\\n            }\\n            else{\\n                int ind = upper_bound(temp.begin(),temp.end(),arr[i]) - temp.begin();\\n                temp[ind] = arr[i];\\n            }\\n        }\\n        return temp.size();\\n    }\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        int minOper = 0;\\n\\n        for(int i=0; i<k; i++){\\n            vector<int> subarr;\\n            for(int j=i; j<n; j+=k){\\n                subarr.push_back(arr[j]);\\n            }\\n            minOper += subarr.size() - lnds(subarr);\\n\\n        }\\n        return minOper;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int lnds(vector<int>& arr){\\n        vector<int> temp;\\n        int n = arr.size();\\n\\n        for(int i=0; i<n; i++){\\n            if(temp.size() == 0 || temp.back() <= arr[i]){\\n                temp.push_back(arr[i]);\\n            }\\n            else{\\n                int ind = upper_bound(temp.begin(),temp.end(),arr[i]) - temp.begin();\\n                temp[ind] = arr[i];\\n            }\\n        }\\n        return temp.size();\\n    }\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        int minOper = 0;\\n\\n        for(int i=0; i<k; i++){\\n            vector<int> subarr;\\n            for(int j=i; j<n; j+=k){\\n                subarr.push_back(arr[j]);\\n            }\\n            minOper += subarr.size() - lnds(subarr);\\n\\n        }\\n        return minOper;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696834,
                "title": "c-lis-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLIS DP\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nu all know about how to solve LIS using binary search then it will be simple for u to understand.\\n\\njust forget about k : problem is broken down in to samller problem : what is the min no of operation needed to make array increasing : is it ( n - size(lis));  ? bcoz this is same when k == 1;\\n \\nbasically here k != 1, we have to check for k array here.\\nif k = 2;\\nthen these two array will be:\\n[a[0],a[2],a[4],a[6].....]\\n[a[1],a[3],s[5],a[7].....]\\n\\nfor k == 3\\nthese three array will be:\\n[a[0],a[3],a[6],a[9].....] min ope needed is x.\\n[a[1],a[4],s[7],a[10].....] min ope needed is y.\\n[a[2],a[5],a[8],a[11].....] min ope needed is z.\\n\\nans = x + y + z;\\n\\n\\nif it help then pls upvote.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        vector<int>lis;\\n        int res = 0;\\n        for(int i=0;i<k;i++){\\n            int sz = 0;\\n            for(int j = i;j<arr.size();j+=k){\\n                sz++;\\n                auto it = upper_bound(lis.begin(),lis.end(),arr[j])-lis.begin();\\n                if(it == lis.size())lis.push_back(arr[j]);\\n                else lis[it] = arr[j];\\n            }\\n            res += sz - lis.size();\\n            lis.clear();\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        vector<int>lis;\\n        int res = 0;\\n        for(int i=0;i<k;i++){\\n            int sz = 0;\\n            for(int j = i;j<arr.size();j+=k){\\n                sz++;\\n                auto it = upper_bound(lis.begin(),lis.end(),arr[j])-lis.begin();\\n                if(it == lis.size())lis.push_back(arr[j]);\\n                else lis[it] = arr[j];\\n            }\\n            res += sz - lis.size();\\n            lis.clear();\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645745,
                "title": "java-simple-solution-binary-search-o-nlogn",
                "content": "```\\nclass Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        int n=arr.length;\\n        int ans=0;\\n        for(int i=0; i<k; i++)\\n        {\\n            ArrayList<Integer> list=new ArrayList();\\n            for(int j=i; j<n; j=j+k)\\n                list.add(arr[j]);\\n            ans+=list.size()-LIS(list);\\n        }\\n        return ans;\\n    }\\n    static int LIS(ArrayList<Integer> list)\\n    {\\n        int n=list.size();\\n        ArrayList<Integer> ans=new ArrayList();\\n        for(int i=0; i<n; i++)\\n        {\\n            if(ans.size()==0 || ans.get(ans.size()-1)<=list.get(i))\\n                ans.add(list.get(i));\\n            else\\n                ans.set(bin(ans,0,ans.size()-1,list.get(i)),list.get(i));\\n        }\\n        return ans.size();\\n    }\\n    static int bin(List<Integer> list,int low,int high,int key)\\n    {\\n        int mid;\\n        while(low<=high)\\n        {\\n            mid=low+(high-low)/2;\\n            if(list.get(mid)<=key)\\n                low=mid+1;\\n            else\\n                high=mid-1;\\n        }\\n        return low;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        int n=arr.length;\\n        int ans=0;\\n        for(int i=0; i<k; i++)\\n        {\\n            ArrayList<Integer> list=new ArrayList();\\n            for(int j=i; j<n; j=j+k)\\n                list.add(arr[j]);\\n            ans+=list.size()-LIS(list);\\n        }\\n        return ans;\\n    }\\n    static int LIS(ArrayList<Integer> list)\\n    {\\n        int n=list.size();\\n        ArrayList<Integer> ans=new ArrayList();\\n        for(int i=0; i<n; i++)\\n        {\\n            if(ans.size()==0 || ans.get(ans.size()-1)<=list.get(i))\\n                ans.add(list.get(i));\\n            else\\n                ans.set(bin(ans,0,ans.size()-1,list.get(i)),list.get(i));\\n        }\\n        return ans.size();\\n    }\\n    static int bin(List<Integer> list,int low,int high,int key)\\n    {\\n        int mid;\\n        while(low<=high)\\n        {\\n            mid=low+(high-low)/2;\\n            if(list.get(mid)<=key)\\n                low=mid+1;\\n            else\\n                high=mid-1;\\n        }\\n        return low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938318,
                "title": "simple-solution-in-java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        \\n        int ans = 0;\\n        for(int i=0; i<k; i++){\\n            List<Integer> li = new ArrayList<>();\\n            \\n            for(int j=i; j<arr.length; j += k){\\n                li.add(arr[j]);\\n            }\\n            \\n            ans += li.size() - findLengthOfLIS(li); // Total list size minus the length of longest increasing subsequence \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int findLengthOfLIS(List<Integer> li){\\n        \\n        // Find the length of the longest increasing subsequence\\n        List<Integer> lis = new ArrayList<>(); // The longest increasing subsequence\\n        lis.add(li.get(0));\\n        for(int i=1; i<li.size(); i++){\\n            if(lis.get(lis.size()-1) <= li.get(i)){\\n                lis.add(li.get(i));\\n            }else{\\n                int index = findNextGreaterIndex(lis, li.get(i));\\n                lis.set(index, li.get(i));\\n            }\\n        }\\n        \\n        return lis.size();\\n    }\\n    \\n    private int findNextGreaterIndex(List<Integer> lis, int key){\\n        int l = 0;\\n        int h = lis.size() - 1;\\n        \\n        while(l < h){\\n            int m = l + (h-l)/2;\\n            if(lis.get(m) <= key){\\n                l = m+1;\\n            }else h = m;\\n        }\\n        \\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        \\n        int ans = 0;\\n        for(int i=0; i<k; i++){\\n            List<Integer> li = new ArrayList<>();\\n            \\n            for(int j=i; j<arr.length; j += k){\\n                li.add(arr[j]);\\n            }\\n            \\n            ans += li.size() - findLengthOfLIS(li); // Total list size minus the length of longest increasing subsequence \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int findLengthOfLIS(List<Integer> li){\\n        \\n        // Find the length of the longest increasing subsequence\\n        List<Integer> lis = new ArrayList<>(); // The longest increasing subsequence\\n        lis.add(li.get(0));\\n        for(int i=1; i<li.size(); i++){\\n            if(lis.get(lis.size()-1) <= li.get(i)){\\n                lis.add(li.get(i));\\n            }else{\\n                int index = findNextGreaterIndex(lis, li.get(i));\\n                lis.set(index, li.get(i));\\n            }\\n        }\\n        \\n        return lis.size();\\n    }\\n    \\n    private int findNextGreaterIndex(List<Integer> lis, int key){\\n        int l = 0;\\n        int h = lis.size() - 1;\\n        \\n        while(l < h){\\n            int m = l + (h-l)/2;\\n            if(lis.get(m) <= key){\\n                l = m+1;\\n            }else h = m;\\n        }\\n        \\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694017,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        \\n        int result = arr.size();\\n        for (int i=0; i<k; ++i) {\\n            vector<int> seq = {arr[i]};\\n            for (int j=i+k; j<n; j+=k) {\\n                if (arr[j] >= seq.back()) {\\n                    seq.push_back(arr[j]);\\n                } else {\\n                    int offset = std::upper_bound(seq.begin(), seq.end(), arr[j]) - seq.begin();\\n                    seq[offset] = arr[j];\\n                }\\n            }\\n            \\n            result -= seq.size();\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        \\n        int result = arr.size();\\n        for (int i=0; i<k; ++i) {\\n            vector<int> seq = {arr[i]};\\n            for (int j=i+k; j<n; j+=k) {\\n                if (arr[j] >= seq.back()) {\\n                    seq.push_back(arr[j]);\\n                } else {\\n                    int offset = std::upper_bound(seq.begin(), seq.end(), arr[j]) - seq.begin();\\n                    seq[offset] = arr[j];\\n                }\\n            }\\n            \\n            result -= seq.size();\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646778,
                "title": "lis-multiset",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int findAns(vector<int> &v) {\\n        multiset<int>s;\\n        \\n        for(int i=0; i<v.size(); i++) {\\n            if (s.empty()) {\\n                s.insert(v[i]);\\n                continue;\\n            }\\n            s.insert(v[i]);\\n            multiset<int>::iterator itr = s.upper_bound(v[i]);\\n            if (itr == s.end()){\\n                continue;\\n            }\\n            s.erase(itr);\\n        }\\n        \\n        return v.size()-s.size();\\n    }\\n    \\n    int kIncreasing(vector<int>& arr, int k) {\\n        \\n        vector<bool>visited(arr.size(),false);\\n        int ans = 0;\\n        for(int i=0 ;i <arr.size();i++){\\n            if (visited[i] ==true ) {\\n                continue;\\n            }\\n            \\n            vector<int> v;\\n            int j = i;\\n            while(j<arr.size()){\\n                visited[j] = true;\\n                v.push_back(arr[j]);\\n                j = j +k;\\n            }\\n            \\n            ans = ans + findAns(v); \\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findAns(vector<int> &v) {\\n        multiset<int>s;\\n        \\n        for(int i=0; i<v.size(); i++) {\\n            if (s.empty()) {\\n                s.insert(v[i]);\\n                continue;\\n            }\\n            s.insert(v[i]);\\n            multiset<int>::iterator itr = s.upper_bound(v[i]);\\n            if (itr == s.end()){\\n                continue;\\n            }\\n            s.erase(itr);\\n        }\\n        \\n        return v.size()-s.size();\\n    }\\n    \\n    int kIncreasing(vector<int>& arr, int k) {\\n        \\n        vector<bool>visited(arr.size(),false);\\n        int ans = 0;\\n        for(int i=0 ;i <arr.size();i++){\\n            if (visited[i] ==true ) {\\n                continue;\\n            }\\n            \\n            vector<int> v;\\n            int j = i;\\n            while(j<arr.size()){\\n                visited[j] = true;\\n                v.push_back(arr[j]);\\n                j = j +k;\\n            }\\n            \\n            ans = ans + findAns(v); \\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646243,
                "title": "lis",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int> v){\\n        //find lis\\n        vector<int> dp;\\n        dp.push_back(v[0]);\\n        \\n        for(int i=1;i<v.size();++i){\\n            if(v[i] < dp.back()){\\n                int index = upper_bound(dp.begin(),dp.end(),v[i]) - dp.begin();\\n                dp[index] = v[i];\\n            }\\n            else{\\n                dp.push_back(v[i]);\\n            }\\n            \\n        }\\n        \\n        return v.size() - dp.size();\\n        \\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0;i<arr.size();++i){\\n            mp[i % k].push_back(arr[i]);\\n        }\\n        int sum = 0;\\n        for(auto &it : mp){\\n            vector<int> v = it.second;\\n            sum += helper(v);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int> v){\\n        //find lis\\n        vector<int> dp;\\n        dp.push_back(v[0]);\\n        \\n        for(int i=1;i<v.size();++i){\\n            if(v[i] < dp.back()){\\n                int index = upper_bound(dp.begin(),dp.end(),v[i]) - dp.begin();\\n                dp[index] = v[i];\\n            }\\n            else{\\n                dp.push_back(v[i]);\\n            }\\n            \\n        }\\n        \\n        return v.size() - dp.size();\\n        \\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0;i<arr.size();++i){\\n            mp[i % k].push_back(arr[i]);\\n        }\\n        int sum = 0;\\n        for(auto &it : mp){\\n            vector<int> v = it.second;\\n            sum += helper(v);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643668,
                "title": "a-few-solutions",
                "content": "This problem is [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/discuss/385203/The-ART-of-Dynamic-Programming) in disguise, ie. for each `k`<sup>th</sup> \"bucket\" from `0..K-1` inclusive, we accumulate the [LIS](https://leetcode.com/problems/longest-increasing-subsequence/discuss/385203/The-ART-of-Dynamic-Programming), then subtract the accumulated [LIS](https://leetcode.com/problems/longest-increasing-subsequence/discuss/385203/The-ART-of-Dynamic-Programming) from `N` (the cardinality of the input array `A`) as the minimum \"cost\" we pay to make all `k` \"buckets\" monotonically increasing.\\n\\nThe reason we need to use a monotonic stack `S` is because N = 1e5, and thus we need a near-linear O(N * logN) solution to avoid TLE.  To calculate the [LIS](https://leetcode.com/problems/longest-increasing-subsequence/discuss/385203/The-ART-of-Dynamic-Programming) we initialize the monotonic stack `S` to the first element of the current `k`<sup>th</sup> bucket under consideration.  Then for each subsequent value `x` from `bucket[k][1..n-1]` (where `n` is the length of each `k`<sup>th</sup> bucket, ie. `n = N / K`), we have two choices to consider:\\n\\n1. \\u2705 `x` **can** be appended onto the monotonic stack `S` without violating the monotonically increasing constraint\\n2. \\uD83D\\uDEAB `x` **cannot** be appended onto the monotonic stack `S` without violating the monotonically increasing constraint\\n\\n* When case 1 occurs, we simply append `x` onto the monotonic stack `S`.  \\n* When case 2 occurs, we would usually pop from the monotonic stack until the monotonically increasing constraint is met by `x`, then append `x` onto `S`.  However for finding the [LIS](https://leetcode.com/problems/longest-increasing-subsequence/discuss/385203/The-ART-of-Dynamic-Programming) in O(N * logN) time, we set `S[i] = x`, where `i` is the upper bound index of `x` in `S`.\\n\\n**Credit:** [votrubac\\'s Q4 solution in Contest 272: 2111. Minimum Operations to Make the Array K-Increasing](https://leetcode.com/problems/minimum-operations-to-make-the-array-k-increasing/discuss/1634969/LIS-in-Disguise)\\n* This is an awesome way to find the LIS in near-linear time, ie. O(N * logN) \\uD83C\\uDF89\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun upperBound(A: MutableList<Int>, T: Int): Int {\\n        var N = A.size\\n        var (i, j) = Pair(0, N - 1)\\n        while (i < j) {\\n            var k = (i + j) / 2\\n            if (A[k] <= T)\\n                i = k + 1\\n            else\\n                j = k\\n        }\\n        return i\\n    }\\n    fun kIncreasing(A: IntArray, K: Int): Int {\\n        var N = A.size\\n        fun LIS(A: MutableList<Int>): Int {\\n            var S = mutableListOf<Int>(A[0])\\n            for (x in A.slice(1..A.lastIndex)) {\\n                if (S.last() <= x) {\\n                    S.add(x)\\n                } else {\\n                    var i = upperBound(S, x)\\n                    S[i] = x\\n                }\\n            }\\n            return S.size\\n        }\\n        var bucket = Array(K){ mutableListOf<Int>() }\\n        for (k in 0 until K)\\n            for (i in k until N step K)\\n                bucket[k].add(A[i])\\n        return N - IntArray(K){ LIS(bucket[it]) }.sum()!!\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet kIncreasing = (A, K, N = A.length, bucket = [...Array(K)].map(_ => [])) => {\\n    let LIS = A => {\\n        let S = [A[0]];\\n        for (let x of A.slice(1)) {\\n            if (S[S.length - 1] <= x) {\\n                S.push(x);\\n            } else {\\n                let i = _.sortedLastIndex(S, x);\\n                S[i] = x;\\n            }\\n        }\\n        return S.length;\\n    };\\n    for (let k = 0; k < K; ++k)\\n        for (let i = k; i < N; i += K)\\n            bucket[k].push(A[i]);\\n    return N - _.sum([...Array(K).keys()].map(k => LIS(bucket[k])));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def kIncreasing(self, A: List[int], K: int) -> int:\\n        N = len(A)\\n        def LIS(A):\\n            S = [A[0]]\\n            for x in A[1:]:\\n                if S[-1] <= x:\\n                    S.append(x)\\n                else:\\n                    i = bisect_right(S, x)\\n                    S[i] = x\\n            return len(S)\\n        return N - sum(LIS(A[i::K]) for i in range(K))\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int kIncreasing(VI& A, int K, int cost = 0) {\\n        int N = A.size();\\n        auto LIS = [&](auto& A) {\\n            VI S{ A[0] };\\n            for (auto x: VI{ A.begin() + 1, A.end() }) {\\n                if (S.back() <= x) {\\n                    S.push_back(x);\\n                } else {\\n                    auto i = distance(S.begin(), upper_bound(S.begin(), S.end(), x));\\n                    S[i] = x;\\n                }\\n            }\\n            return S.size();\\n        };\\n        VVI bucket(K);\\n        for (auto k{ 0 }; k < K; ++k)\\n            for (auto i{ k }; i < N; i += K)\\n                bucket[k].push_back(A[i]);\\n        for (auto k{ 0 }; k < K; ++k)\\n            cost += LIS(bucket[k]);\\n        return N - cost;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun upperBound(A: MutableList<Int>, T: Int): Int {\\n        var N = A.size\\n        var (i, j) = Pair(0, N - 1)\\n        while (i < j) {\\n            var k = (i + j) / 2\\n            if (A[k] <= T)\\n                i = k + 1\\n            else\\n                j = k\\n        }\\n        return i\\n    }\\n    fun kIncreasing(A: IntArray, K: Int): Int {\\n        var N = A.size\\n        fun LIS(A: MutableList<Int>): Int {\\n            var S = mutableListOf<Int>(A[0])\\n            for (x in A.slice(1..A.lastIndex)) {\\n                if (S.last() <= x) {\\n                    S.add(x)\\n                } else {\\n                    var i = upperBound(S, x)\\n                    S[i] = x\\n                }\\n            }\\n            return S.size\\n        }\\n        var bucket = Array(K){ mutableListOf<Int>() }\\n        for (k in 0 until K)\\n            for (i in k until N step K)\\n                bucket[k].add(A[i])\\n        return N - IntArray(K){ LIS(bucket[it]) }.sum()!!\\n    }\\n}\\n```\n```\\nlet kIncreasing = (A, K, N = A.length, bucket = [...Array(K)].map(_ => [])) => {\\n    let LIS = A => {\\n        let S = [A[0]];\\n        for (let x of A.slice(1)) {\\n            if (S[S.length - 1] <= x) {\\n                S.push(x);\\n            } else {\\n                let i = _.sortedLastIndex(S, x);\\n                S[i] = x;\\n            }\\n        }\\n        return S.length;\\n    };\\n    for (let k = 0; k < K; ++k)\\n        for (let i = k; i < N; i += K)\\n            bucket[k].push(A[i]);\\n    return N - _.sum([...Array(K).keys()].map(k => LIS(bucket[k])));\\n};\\n```\n```\\nclass Solution:\\n    def kIncreasing(self, A: List[int], K: int) -> int:\\n        N = len(A)\\n        def LIS(A):\\n            S = [A[0]]\\n            for x in A[1:]:\\n                if S[-1] <= x:\\n                    S.append(x)\\n                else:\\n                    i = bisect_right(S, x)\\n                    S[i] = x\\n            return len(S)\\n        return N - sum(LIS(A[i::K]) for i in range(K))\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int kIncreasing(VI& A, int K, int cost = 0) {\\n        int N = A.size();\\n        auto LIS = [&](auto& A) {\\n            VI S{ A[0] };\\n            for (auto x: VI{ A.begin() + 1, A.end() }) {\\n                if (S.back() <= x) {\\n                    S.push_back(x);\\n                } else {\\n                    auto i = distance(S.begin(), upper_bound(S.begin(), S.end(), x));\\n                    S[i] = x;\\n                }\\n            }\\n            return S.size();\\n        };\\n        VVI bucket(K);\\n        for (auto k{ 0 }; k < K; ++k)\\n            for (auto i{ k }; i < N; i += K)\\n                bucket[k].push_back(A[i]);\\n        for (auto k{ 0 }; k < K; ++k)\\n            cost += LIS(bucket[k]);\\n        return N - cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641049,
                "title": "2111-minimum-operations-to-make-the-array-k-increasing",
                "content": "LNDS (Longest Non-Decreasing Subarray) Approach\\n```\\nclass Solution {\\n    public int upperBound(ArrayList<Integer> a, int val){\\n        int l=0;int r=a.size()-1;\\n        while(l<r){\\n            int m=(l+r)/2;\\n            if(a.get(m)<=val){\\n                l=m+1;\\n            }\\n            else{\\n                r=m;\\n            }\\n        }\\n        return l;\\n    }\\n    public int lnds(ArrayList<Integer> arr){\\n        ArrayList<Integer> temp=new ArrayList<>();\\n        int n = arr.size();\\n        for(int i=0;i<n;i++){\\n            if(temp.size()==0 || temp.get(temp.size()-1)<=arr.get(i)){\\n                temp.add(arr.get(i));\\n            }\\n            else{\\n                int ind=upperBound(temp,arr.get(i));\\n                temp.set(ind, arr.get(i));\\n            }\\n        }\\n        return temp.size();\\n    }\\n    public int kIncreasing(int[] arr, int k) {\\n        int minchanges=0;\\n        for(int i=0;i<k;i++){\\n            ArrayList<Integer> subarr=new ArrayList<>();\\n            for(int j=i;j<arr.length;j+=k){\\n                subarr.add(arr[j]);\\n            }\\n            minchanges+=subarr.size()-lnds(subarr);\\n        }\\n        return minchanges;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int upperBound(ArrayList<Integer> a, int val){\\n        int l=0;int r=a.size()-1;\\n        while(l<r){\\n            int m=(l+r)/2;\\n            if(a.get(m)<=val){\\n                l=m+1;\\n            }\\n            else{\\n                r=m;\\n            }\\n        }\\n        return l;\\n    }\\n    public int lnds(ArrayList<Integer> arr){\\n        ArrayList<Integer> temp=new ArrayList<>();\\n        int n = arr.size();\\n        for(int i=0;i<n;i++){\\n            if(temp.size()==0 || temp.get(temp.size()-1)<=arr.get(i)){\\n                temp.add(arr.get(i));\\n            }\\n            else{\\n                int ind=upperBound(temp,arr.get(i));\\n                temp.set(ind, arr.get(i));\\n            }\\n        }\\n        return temp.size();\\n    }\\n    public int kIncreasing(int[] arr, int k) {\\n        int minchanges=0;\\n        for(int i=0;i<k;i++){\\n            ArrayList<Integer> subarr=new ArrayList<>();\\n            for(int j=i;j<arr.length;j+=k){\\n                subarr.add(arr[j]);\\n            }\\n            minchanges+=subarr.size()-lnds(subarr);\\n        }\\n        return minchanges;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637014,
                "title": "c-longest-increasing-subsequence",
                "content": "```\\nclass Solution {\\npublic:\\n    int LIS(vector<int>& vec){\\n        int n=vec.size();\\n        \\n        vector<int> lis; //keep track of all the element which takes part in LIS\\n        lis.push_back(vec[0]);\\n        \\n        for(int i=1; i<n; ++i){\\n            if(vec[i] >= lis.back()) lis.push_back(vec[i]);\\n            else{\\n                auto lb = upper_bound(lis.begin(), lis.end(), vec[i]);\\n                int idx = lb-lis.begin();\\n                swap(lis[idx], vec[i]);\\n            }\\n        }\\n        return n-lis.size(); //not part of LIS\\n    }\\n    \\n    int kIncreasing(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int count = 0;\\n        for(int i=0; i<k; ++i){\\n            vector<int> vec;\\n            for(int j=i; j<n; j=j+k){\\n                vec.push_back(arr[j]);\\n            }\\n            count += LIS(vec);\\n        }\\n        return count;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int LIS(vector<int>& vec){\\n        int n=vec.size();\\n        \\n        vector<int> lis; //keep track of all the element which takes part in LIS\\n        lis.push_back(vec[0]);\\n        \\n        for(int i=1; i<n; ++i){\\n            if(vec[i] >= lis.back()) lis.push_back(vec[i]);\\n            else{\\n                auto lb = upper_bound(lis.begin(), lis.end(), vec[i]);\\n                int idx = lb-lis.begin();\\n                swap(lis[idx], vec[i]);\\n            }\\n        }\\n        return n-lis.size(); //not part of LIS\\n    }\\n    \\n    int kIncreasing(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int count = 0;\\n        for(int i=0; i<k; ++i){\\n            vector<int> vec;\\n            for(int j=i; j<n; j=j+k){\\n                vec.push_back(arr[j]);\\n            }\\n            count += LIS(vec);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636411,
                "title": "using-longest-increasing-subsequence-c-code-upper-bound",
                "content": "```\\nclass Solution {\\n    int lengthOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int>seq;\\n        seq.push_back(nums[0]);\\n        \\n        for(int i=1;i<n;i++){\\n            if(seq.back() <= nums[i]){\\n                seq.push_back(nums[i]);\\n            }\\n            else{\\n                int ind = upper_bound(seq.begin(),seq.end(),nums[i]) - seq.begin();\\n                seq[ind] = nums[i];\\n            }\\n        }\\n        return seq.size();\\n    }\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int ans = 0;\\n        int n = arr.size();\\n        for(int i=0;i<k;i++){\\n            vector<int>temp;\\n            for(int j=i;j<n;j+=k) {\\n                temp.push_back(arr[j]);\\n            }\\n            int curr = lengthOfLIS(temp);\\n            ans += (temp.size() - curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int lengthOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int>seq;\\n        seq.push_back(nums[0]);\\n        \\n        for(int i=1;i<n;i++){\\n            if(seq.back() <= nums[i]){\\n                seq.push_back(nums[i]);\\n            }\\n            else{\\n                int ind = upper_bound(seq.begin(),seq.end(),nums[i]) - seq.begin();\\n                seq[ind] = nums[i];\\n            }\\n        }\\n        return seq.size();\\n    }\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int ans = 0;\\n        int n = arr.size();\\n        for(int i=0;i<k;i++){\\n            vector<int>temp;\\n            for(int j=i;j<n;j+=k) {\\n                temp.push_back(arr[j]);\\n            }\\n            int curr = lengthOfLIS(temp);\\n            ans += (temp.size() - curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636326,
                "title": "rust-lis",
                "content": "`Partition_point`is supported since 1.52.0 in Rust. But it is not yet supported on leetcode. As a work around, we can manually implement the binary search partition.\\n``` rust\\nimpl Solution {\\n    pub fn k_increasing(arr: Vec<i32>, k: i32) -> i32 {\\n        let mut s = 0;\\n        for i in 0..k{\\n            let now:Vec<i32> = arr.iter().copied().skip(i as usize).step_by(k as usize).collect();\\n            s += Solution::changes_needed(&now);\\n        }\\n        s\\n    }\\n    fn changes_needed(a: &[i32]) -> i32{\\n        let mut dp:Vec<i32> = vec![];\\n        for v in a{\\n\\t\\t    // for v in a{\\n\\t\\t\\t//     let mut left:usize = 0;\\n\\t\\t\\t//     let mut right = dp.len();\\n\\t\\t\\t//     while left < right{\\n\\t\\t\\t//         let mid = left + (right - left)/ 2;\\n\\t\\t\\t//         if dp[mid] <= *v{\\n\\t\\t\\t//             left = mid + 1;\\n\\t\\t\\t//         }else{\\n\\t\\t\\t//             right = mid;\\n\\t\\t\\t//         }\\n\\t\\t\\t//     }\\n\\t\\t\\t//     if left == dp.len(){\\n\\t\\t\\t//        dp.push(*v)\\n\\t\\t\\t//     }else{\\n\\t\\t\\t//         dp[left] = *v;\\n\\t\\t\\t//     }\\n\\t\\t\\t// }\\n\\n            let t = dp.partition_point(|&x| x <= *v);\\n            if t == dp.len(){\\n                dp.push(*v);\\n            }else{\\n                dp[t] = *v\\n            }\\n        }\\n        (a.len() - dp.len()) as i32\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` rust\\nimpl Solution {\\n    pub fn k_increasing(arr: Vec<i32>, k: i32) -> i32 {\\n        let mut s = 0;\\n        for i in 0..k{\\n            let now:Vec<i32> = arr.iter().copied().skip(i as usize).step_by(k as usize).collect();\\n            s += Solution::changes_needed(&now);\\n        }\\n        s\\n    }\\n    fn changes_needed(a: &[i32]) -> i32{\\n        let mut dp:Vec<i32> = vec![];\\n        for v in a{\\n\\t\\t    // for v in a{\\n\\t\\t\\t//     let mut left:usize = 0;\\n\\t\\t\\t//     let mut right = dp.len();\\n\\t\\t\\t//     while left < right{\\n\\t\\t\\t//         let mid = left + (right - left)/ 2;\\n\\t\\t\\t//         if dp[mid] <= *v{\\n\\t\\t\\t//             left = mid + 1;\\n\\t\\t\\t//         }else{\\n\\t\\t\\t//             right = mid;\\n\\t\\t\\t//         }\\n\\t\\t\\t//     }\\n\\t\\t\\t//     if left == dp.len(){\\n\\t\\t\\t//        dp.push(*v)\\n\\t\\t\\t//     }else{\\n\\t\\t\\t//         dp[left] = *v;\\n\\t\\t\\t//     }\\n\\t\\t\\t// }\\n\\n            let t = dp.partition_point(|&x| x <= *v);\\n            if t == dp.len(){\\n                dp.push(*v);\\n            }else{\\n                dp[t] = *v\\n            }\\n        }\\n        (a.len() - dp.len()) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1635722,
                "title": "find-by-longest-non-decreasing-sub-sequence-solution-clean",
                "content": "\\n```javascript\\nvar kIncreasing = function (arr, k) {\\n  let res = 0,\\n    n = arr.length;\\n  for (let i = 0; i < k; i++) {\\n    const newArr = [];\\n    for (let j = i; j < n; j += k) {\\n      newArr.push(arr[j]);\\n    }\\n    res += newArr.length - longestNonDecreasingSub(newArr);\\n  }\\n  return res;\\n};\\n\\nfunction longestNonDecreasingSub(arr) {\\n  const sub = [];\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    const curr = arr[i];\\n    if (sub[sub.length - 1] <= curr) {\\n      sub.push(curr);\\n    } else {\\n      let j = 0;\\n      while (curr >= sub[j]) {\\n        j++;\\n      }\\n      sub[j] = curr;\\n    }\\n  }\\n  return sub.length;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar kIncreasing = function (arr, k) {\\n  let res = 0,\\n    n = arr.length;\\n  for (let i = 0; i < k; i++) {\\n    const newArr = [];\\n    for (let j = i; j < n; j += k) {\\n      newArr.push(arr[j]);\\n    }\\n    res += newArr.length - longestNonDecreasingSub(newArr);\\n  }\\n  return res;\\n};\\n\\nfunction longestNonDecreasingSub(arr) {\\n  const sub = [];\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    const curr = arr[i];\\n    if (sub[sub.length - 1] <= curr) {\\n      sub.push(curr);\\n    } else {\\n      let j = 0;\\n      while (curr >= sub[j]) {\\n        j++;\\n      }\\n      sub[j] = curr;\\n    }\\n  }\\n  return sub.length;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1635444,
                "title": "python-longest-non-decreasing-subsequence",
                "content": "Suppose that you have a function `lnds(sub)` that gives you the longest non-decreasing subsequence of a subarray. For example, `sub = [1, 2, 3, 3, 2, 2, 2]` would return `5` which corresponds to the subsequence `[1, 2, 2, 2, 2]`.\\n\\nThe longest strictly increasing subsequence is actually Problem 300. Compared to that all we need to do is `bisect_right` instead of `bisect_left` to take ties into account. (In the example above, using `bisect_left` would result in `3`, which corresponds to `[1, 2, 3]`.)\\n\\nIn this question, `k` divides the given array into at most `k` disjoint subarrays. For each subarray, the minimum number of operations is `len(sub) - lnds(sub)`.\\n\\nTime: `O(N)`\\nSpace: `O(N)`\\n\\n```python\\nclass Solution:\\n    def kIncreasing(self, A, k):\\n        def lnds(sub):\\n            L = 0\\n            DP = []\\n            for x in sub:\\n                #Leetcode 300 - use bisect_left instead\\n                i = bisect.bisect_right(DP, x)\\n                if i == len(DP):\\n                    DP.append(x)\\n                else:\\n                    DP[i] = x\\n                if i == L:\\n                    L += 1\\n            return L\\n        \\n        ans = 0\\n        for i in range(k):\\n            sub = A[i:len(A):k]\\n            ans += len(sub) - lnds(sub)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def kIncreasing(self, A, k):\\n        def lnds(sub):\\n            L = 0\\n            DP = []\\n            for x in sub:\\n                #Leetcode 300 - use bisect_left instead\\n                i = bisect.bisect_right(DP, x)\\n                if i == len(DP):\\n                    DP.append(x)\\n                else:\\n                    DP[i] = x\\n                if i == L:\\n                    L += 1\\n            return L\\n        \\n        ans = 0\\n        for i in range(k):\\n            sub = A[i:len(A):k]\\n            ans += len(sub) - lnds(sub)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635220,
                "title": "swift-lis-but-actually-longest-non-decreasing-sequence",
                "content": "Inspired from @hiepit\\nhttps://leetcode.com/problems/minimum-operations-to-make-the-array-k-increasing/discuss/1635013/C%2B%2BPython-Longest-Non-Decreasing-Subsequence-Clean-and-Concise\\nThe description from above article is very nice details.\\n\\n```\\nclass Solution {\\n    // Time: O(nlogn)\\n    // Space: O(1)\\n    func lengthOfLNDS(_ nums: [Int]) -> Int {\\n        var sub: [Int] = [nums[0]]\\n        for i in 1..<nums.count {\\n            let num = nums[i]\\n            if num >= sub.last! {\\n                sub.append(num)\\n            } else {\\n                sub[getGreatestSmallerOrEqual(num, sub)] = num\\n            }\\n        }\\n        \\n        return sub.count\\n    }\\n    \\n    // Time: O(logn)\\n    // Space: O(1)\\n    func getGreatestSmallerOrEqual(_ target: Int, _ arr: [Int]) -> Int {\\n        var lo = 0\\n        var hi = arr.count - 1\\n        while lo < hi {\\n            let mi = lo + (hi - lo) / 2\\n            if arr[mi] <= target {\\n                lo = mi + 1\\n            } else {\\n                hi = mi\\n            }\\n        }\\n        return lo\\n    }\\n    \\n    // Time: O(k * nlogn)\\n    // Space: O(n)\\n    func kIncreasing(_ arr: [Int], _ k: Int) -> Int {\\n        let n = arr.count\\n        var ans = 0\\n        for i in 0..<k {\\n            var j = i\\n            var newArr: [Int] = []\\n            while j < n {\\n                newArr.append(arr[j])\\n                j += k\\n            }\\n            ans += (newArr.count - lengthOfLNDS(newArr))\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Time: O(nlogn)\\n    // Space: O(1)\\n    func lengthOfLNDS(_ nums: [Int]) -> Int {\\n        var sub: [Int] = [nums[0]]\\n        for i in 1..<nums.count {\\n            let num = nums[i]\\n            if num >= sub.last! {\\n                sub.append(num)\\n            } else {\\n                sub[getGreatestSmallerOrEqual(num, sub)] = num\\n            }\\n        }\\n        \\n        return sub.count\\n    }\\n    \\n    // Time: O(logn)\\n    // Space: O(1)\\n    func getGreatestSmallerOrEqual(_ target: Int, _ arr: [Int]) -> Int {\\n        var lo = 0\\n        var hi = arr.count - 1\\n        while lo < hi {\\n            let mi = lo + (hi - lo) / 2\\n            if arr[mi] <= target {\\n                lo = mi + 1\\n            } else {\\n                hi = mi\\n            }\\n        }\\n        return lo\\n    }\\n    \\n    // Time: O(k * nlogn)\\n    // Space: O(n)\\n    func kIncreasing(_ arr: [Int], _ k: Int) -> Int {\\n        let n = arr.count\\n        var ans = 0\\n        for i in 0..<k {\\n            var j = i\\n            var newArr: [Int] = []\\n            while j < n {\\n                newArr.append(arr[j])\\n                j += k\\n            }\\n            ans += (newArr.count - lengthOfLNDS(newArr))\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635142,
                "title": "c-2111-minimum-operations-to-make-the-array-k-increasing",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        \\n        auto fn = [](vector<int>& sub) {\\n            vector<int> vals; \\n            for (auto& x : sub) {\\n                auto it = upper_bound(vals.begin(), vals.end(), x); \\n                if (it == vals.end()) vals.push_back(x); \\n                else *it = x; \\n            }\\n            return sub.size() - vals.size(); \\n        }; \\n        \\n        int ans = 0; \\n        for (int i = 0; i < k; ++i) {\\n            vector<int> sub; \\n            for (int ii = i; ii < arr.size(); ii += k) \\n                sub.push_back(arr[ii]); \\n            ans += fn(sub); \\n        }\\n        return ans; \\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int ans = 0; \\n        for (int i = 0; i < k; ++i) {\\n            vector<int> vals; \\n            for (int ii = i; ii < arr.size(); ii += k) {\\n                if (vals.empty() || vals.back() <= arr[ii]) vals.push_back(arr[ii]); \\n                else *upper_bound(vals.begin(), vals.end(), arr[ii]) = arr[ii]; \\n            }\\n            ans += vals.size(); \\n        }\\n        return arr.size() - ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        \\n        auto fn = [](vector<int>& sub) {\\n            vector<int> vals; \\n            for (auto& x : sub) {\\n                auto it = upper_bound(vals.begin(), vals.end(), x); \\n                if (it == vals.end()) vals.push_back(x); \\n                else *it = x; \\n            }\\n            return sub.size() - vals.size(); \\n        }; \\n        \\n        int ans = 0; \\n        for (int i = 0; i < k; ++i) {\\n            vector<int> sub; \\n            for (int ii = i; ii < arr.size(); ii += k) \\n                sub.push_back(arr[ii]); \\n            ans += fn(sub); \\n        }\\n        return ans; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int ans = 0; \\n        for (int i = 0; i < k; ++i) {\\n            vector<int> vals; \\n            for (int ii = i; ii < arr.size(); ii += k) {\\n                if (vals.empty() || vals.back() <= arr[ii]) vals.push_back(arr[ii]); \\n                else *upper_bound(vals.begin(), vals.end(), arr[ii]) = arr[ii]; \\n            }\\n            ans += vals.size(); \\n        }\\n        return arr.size() - ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635127,
                "title": "java-longest-increasing-subsequence-solution",
                "content": "This question is quite similar to [300. longest increasing subsequence](https://leetcode.com/problems/longest-increasing-subsequence/), the only difference is that we are looping through the array by `k` interval, and that we are not restricting the condition to `strict increase` . To give a more relax definition of `increasing subsequence`, we only need to modify a few lines of code (see comments).\\n\\n```\\nclass Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        int result = 0;\\n        \\n        for (int i = 0; i < k; i++) {\\n            // check arr[i, i+k, i+2k, ...]\\n            //\\n            // find longest increasing sub seq\\n            List<Integer> list = new ArrayList<>();\\n            \\n            for (int j = i; j < arr.length; j += k) {\\n                list.add(arr[j]);\\n            }\\n            \\n            int longestIncreasingSubSeq = lengthOfLIS(list);\\n            \\n            result += list.size() - longestIncreasingSubSeq;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public int lengthOfLIS(List<Integer> nums) {\\n        ArrayList<Integer> sub = new ArrayList<>();\\n        sub.add(nums.get(0));\\n        \\n        for (int i = 1; i < nums.size(); i++) {\\n            int num = nums.get(i);\\n            if (num >= sub.get(sub.size() - 1)) { // this >= check the `increasing subsequence` condition in this question\\n                sub.add(num);\\n            } else {\\n                int j = binarySearch(sub, num);\\n                sub.set(j, num);\\n            }\\n        }\\n        \\n        return sub.size();\\n    }\\n    \\n    private int binarySearch(List<Integer> sub, int num) {\\n        int left = 0, right = sub.size() - 1;\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (sub.get(mid) <= num) { // this <= check the `increasing subsequence` condition in this question\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        int result = 0;\\n        \\n        for (int i = 0; i < k; i++) {\\n            // check arr[i, i+k, i+2k, ...]\\n            //\\n            // find longest increasing sub seq\\n            List<Integer> list = new ArrayList<>();\\n            \\n            for (int j = i; j < arr.length; j += k) {\\n                list.add(arr[j]);\\n            }\\n            \\n            int longestIncreasingSubSeq = lengthOfLIS(list);\\n            \\n            result += list.size() - longestIncreasingSubSeq;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public int lengthOfLIS(List<Integer> nums) {\\n        ArrayList<Integer> sub = new ArrayList<>();\\n        sub.add(nums.get(0));\\n        \\n        for (int i = 1; i < nums.size(); i++) {\\n            int num = nums.get(i);\\n            if (num >= sub.get(sub.size() - 1)) { // this >= check the `increasing subsequence` condition in this question\\n                sub.add(num);\\n            } else {\\n                int j = binarySearch(sub, num);\\n                sub.set(j, num);\\n            }\\n        }\\n        \\n        return sub.size();\\n    }\\n    \\n    private int binarySearch(List<Integer> sub, int num) {\\n        int left = 0, right = sub.size() - 1;\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (sub.get(mid) <= num) { // this <= check the `increasing subsequence` condition in this question\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634975,
                "title": "longest-non-decreasing-subsequence",
                "content": "\\nIf you understand the idea of [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/) problem, this solution is quite straitforward\\n\\n* Split array to k sub_arrays \\n* Find minimum operation to make each sub_array non-decreasing, and it equal length subarray - longest non-decreasing subsequence of sub_array. Very similar to [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)\\n* Time complexity: O(NlogN), space: O(N)\\n\\n```\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        N, output = len(arr), 0\\n        # Create all sub_array\\n        sub_arrs = [[] for _ in range(k)]\\n        for sub_arr_idx in range(k):\\n            for idx in range(sub_arr_idx, N, k):\\n                sub_arrs[sub_arr_idx].append(arr[idx])\\n\\n        # Sum minimum operation of all sub_arrays\\n        for sub_arr in sub_arrs:\\n            output += len(sub_arr) - self.longest_nondecreasing_subseq(sub_arr)\\n        return output\\n        \\n    def longest_nondecreasing_subseq(self, nums: List[int]) -> int:\\n        output = []\\n        for num in nums:\\n            idx = bisect_right(output, num)\\n            if idx == len(output):\\n                output.append(num)\\n            else:\\n                output[idx] = num\\n        return len(output)\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        N, output = len(arr), 0\\n        # Create all sub_array\\n        sub_arrs = [[] for _ in range(k)]\\n        for sub_arr_idx in range(k):\\n            for idx in range(sub_arr_idx, N, k):\\n                sub_arrs[sub_arr_idx].append(arr[idx])\\n\\n        # Sum minimum operation of all sub_arrays\\n        for sub_arr in sub_arrs:\\n            output += len(sub_arr) - self.longest_nondecreasing_subseq(sub_arr)\\n        return output\\n        \\n    def longest_nondecreasing_subseq(self, nums: List[int]) -> int:\\n        output = []\\n        for num in nums:\\n            idx = bisect_right(output, num)\\n            if idx == len(output):\\n                output.append(num)\\n            else:\\n                output[idx] = num\\n        return len(output)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884169,
                "title": "rust-lis",
                "content": "# Intuition\\n\\nSeparate the vector into `k` subvectors that have no businees with each other.\\n\\n# Approach\\n\\nSee [Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/). Tho this question requires longest nondecreasing subsequence, so a bit of modification is needed.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n \\\\log n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\npub fn longest_nondec_subseq(vec: Vec<i32>) -> usize {\\n    let mut stack = vec![]; // monotonic stack\\n    for e in vec {\\n        let e_max = if let Some(inner) = stack.last() {\\n            *inner\\n        } else {\\n            stack.push(e);\\n            continue;\\n        };\\n\\n        if e >= e_max {\\n            stack.push(e);\\n            continue;\\n        }\\n\\n        let ptr = stack.partition_point(|&_e| _e <= e);\\n        stack[ptr] = e;\\n    }\\n\\n    stack.len()\\n}\\n\\nimpl Solution {\\n    pub fn k_increasing(vec: Vec<i32>, k: i32) -> i32 {\\n        let k = k as usize;\\n        let n = vec.len();\\n\\n        let mut vec_vec = vec![vec![]; k];\\n        for (i, e) in vec.into_iter().enumerate() {\\n            vec_vec[i % k].push(e);\\n        }\\n\\n        let mut ret = usize::MIN;\\n        for vec in vec_vec {\\n            ret += vec.len();\\n            ret -= longest_nondec_subseq(vec);\\n        }\\n\\n        ret as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Search",
                    "Monotonic Stack"
                ],
                "code": "```\\npub fn longest_nondec_subseq(vec: Vec<i32>) -> usize {\\n    let mut stack = vec![]; // monotonic stack\\n    for e in vec {\\n        let e_max = if let Some(inner) = stack.last() {\\n            *inner\\n        } else {\\n            stack.push(e);\\n            continue;\\n        };\\n\\n        if e >= e_max {\\n            stack.push(e);\\n            continue;\\n        }\\n\\n        let ptr = stack.partition_point(|&_e| _e <= e);\\n        stack[ptr] = e;\\n    }\\n\\n    stack.len()\\n}\\n\\nimpl Solution {\\n    pub fn k_increasing(vec: Vec<i32>, k: i32) -> i32 {\\n        let k = k as usize;\\n        let n = vec.len();\\n\\n        let mut vec_vec = vec![vec![]; k];\\n        for (i, e) in vec.into_iter().enumerate() {\\n            vec_vec[i % k].push(e);\\n        }\\n\\n        let mut ret = usize::MIN;\\n        for vec in vec_vec {\\n            ret += vec.len();\\n            ret -= longest_nondec_subseq(vec);\\n        }\\n\\n        ret as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3435955,
                "title": "python-simple-lis",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kIncreasing(self, arr, k):\\n        def dfs(nums):\\n            vals = []\\n\\n            for x in nums:\\n                k = bisect_right(vals,x)\\n                if k == len(vals): vals.append(x)\\n                else: vals[k] = x\\n\\n            return len(nums) - len(vals)\\n\\n        return sum([dfs(arr[i:len(arr):k]) for i in range(k)])\\n\\n\\n\\n        \\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kIncreasing(self, arr, k):\\n        def dfs(nums):\\n            vals = []\\n\\n            for x in nums:\\n                k = bisect_right(vals,x)\\n                if k == len(vals): vals.append(x)\\n                else: vals[k] = x\\n\\n            return len(nums) - len(vals)\\n\\n        return sum([dfs(arr[i:len(arr):k]) for i in range(k)])\\n\\n\\n\\n        \\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326153,
                "title": "minimum-operations-to-make-the-array-k-increasing-c-explained-solution",
                "content": "**Do Upvote If Found Helpful !!!**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem here is quite interesting and requires a bit of an observation. Basically for each set of numbers present at a distance of **K**, we need to find minimum operations to make that set of numbers a non-decreasing sequence. This hints at finding the **length of the longest non-decreasing subsequence** for each set of numbers, as these are the numbers already present in sorted order and we only need to change **len(seq) - LNDS** amount of numbers in sequence where **LNDS stands for Longest Non Decreasing Subsequence**. This can be easily done with dynamic programming but the basic DP approach would result in quadratic time. An optimised way of finding the **LNDS** brings down the overall time complexity and our solution easily passes.\\n\\n# Complexity\\n- Time complexity: **O(NlogN)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        ios_base::sync_with_stdio(0);\\n        int n = arr.size(),ans = 0; vector<bool>visited(n,false);\\n        for(int i = 0; i < n; i++){\\n            if(!visited[i]){\\n                int j = i,c = 0; multiset<int>st;\\n                while(j < n){    // Finding all numbers in sequence, marking them visited and finding LNDS. A special note that for LIS, use lower bound.\\n                    c++;\\n                    st.insert(arr[j]);  \\n                    auto e = st.upper_bound(arr[j]);\\n                    if(e != st.end()){\\n                        st.erase(e);\\n                    }\\n                    visited[j] = true;\\n                    j += k;\\n                }\\n                ans += c - st.size();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        ios_base::sync_with_stdio(0);\\n        int n = arr.size(),ans = 0; vector<bool>visited(n,false);\\n        for(int i = 0; i < n; i++){\\n            if(!visited[i]){\\n                int j = i,c = 0; multiset<int>st;\\n                while(j < n){    // Finding all numbers in sequence, marking them visited and finding LNDS. A special note that for LIS, use lower bound.\\n                    c++;\\n                    st.insert(arr[j]);  \\n                    auto e = st.upper_bound(arr[j]);\\n                    if(e != st.end()){\\n                        st.erase(e);\\n                    }\\n                    visited[j] = true;\\n                    j += k;\\n                }\\n                ans += c - st.size();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263861,
                "title": "short-easy-c",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        int ans = 0;\\n        for(int i=0;i<k;i++){\\n            vector<int> lis;\\n            int len = 0;\\n            for(int j=i;j<n;j+=k){\\n                if(lis.empty() || lis.back() <= arr[j]){\\n                    lis.push_back(arr[j]);\\n                }\\n                else{\\n                    auto it = upper_bound(begin(lis),end(lis),arr[j]);\\n                    if(it == lis.end())lis.push_back(arr[j]);\\n                    else *it = arr[j];\\n                }\\n                len++;\\n            }\\n            ans += len-lis.size();\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        int ans = 0;\\n        for(int i=0;i<k;i++){\\n            vector<int> lis;\\n            int len = 0;\\n            for(int j=i;j<n;j+=k){\\n                if(lis.empty() || lis.back() <= arr[j]){\\n                    lis.push_back(arr[j]);\\n                }\\n                else{\\n                    auto it = upper_bound(begin(lis),end(lis),arr[j]);\\n                    if(it == lis.end())lis.push_back(arr[j]);\\n                    else *it = arr[j];\\n                }\\n                len++;\\n            }\\n            ans += len-lis.size();\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252721,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn k_increasing(arr: Vec<i32>, k: i32) -> i32 {\\n        pub fn upper_bound<T: Ord>(vec: &Vec<T>, x: &T) -> Result<usize, usize> {\\n            vec.iter().position(|y| y > x).ok_or(vec.len())\\n        }\\n\\n        let mut longest = 0;\\n        for i in 0..k {\\n            let mut mono = vec![];\\n            for j in (i..arr.len() as i32).step_by(k as usize) {\\n                let j = j as usize;\\n                if mono.is_empty() || mono.last().unwrap() <= &arr[j] {\\n                    mono.push(arr[j]);\\n                } else {\\n                    let pos = upper_bound(&mono, &arr[j]).unwrap();\\n                    mono[pos] = arr[j];\\n                }\\n            }\\n            longest += mono.len();\\n        }\\n        arr.len() as i32 - longest as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn k_increasing(arr: Vec<i32>, k: i32) -> i32 {\\n        pub fn upper_bound<T: Ord>(vec: &Vec<T>, x: &T) -> Result<usize, usize> {\\n            vec.iter().position(|y| y > x).ok_or(vec.len())\\n        }\\n\\n        let mut longest = 0;\\n        for i in 0..k {\\n            let mut mono = vec![];\\n            for j in (i..arr.len() as i32).step_by(k as usize) {\\n                let j = j as usize;\\n                if mono.is_empty() || mono.last().unwrap() <= &arr[j] {\\n                    mono.push(arr[j]);\\n                } else {\\n                    let pos = upper_bound(&mono, &arr[j]).unwrap();\\n                    mono[pos] = arr[j];\\n                }\\n            }\\n            longest += mono.len();\\n        }\\n        arr.len() as i32 - longest as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3205033,
                "title": "short-and-concise-solution-c-nlogn-k-intutive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to keep in mind the = sign mentioned in the question .\\nThat is the biggest hint.\\n\\nThe K arrays which are formed starting from index 0...K and every next element at a k distance will be independent .\\n\\nThose arrays should be sorted.\\n\\nQuestiion reduces to finding minimum operations to make an array non decreasing .\\n\\nNow lis can help us.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst of all we will start with an index of 0 to k and make an array \\nand findout the Lis (non decreasing ) length and then subtract it from the actual length of temporary array, because those many elements need to change mostly will make equal to elemts which are equal to the elements in the ans array (lis array )\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(k*MlogM)  M is N/K\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(N/k)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& a , int k) {\\n        int ret=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int>ans;\\n            int cnt=0;\\n            for(int j=i;j<a.size();j+=k)\\n            {\\n                cnt++;\\n                 auto itr=upper_bound(ans.begin(),ans.end(),a[j]);\\n                if(itr==ans.end())ans.push_back(a[j]);\\n                else *itr=a[j];\\n\\n            }\\n            ret+=(cnt-ans.size());\\n        }\\n        return  ret;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& a , int k) {\\n        int ret=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int>ans;\\n            int cnt=0;\\n            for(int j=i;j<a.size();j+=k)\\n            {\\n                cnt++;\\n                 auto itr=upper_bound(ans.begin(),ans.end(),a[j]);\\n                if(itr==ans.end())ans.push_back(a[j]);\\n                else *itr=a[j];\\n\\n            }\\n            ret+=(cnt-ans.size());\\n        }\\n        return  ret;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143156,
                "title": "c-explained-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution{\\npublic:\\n    int LIS(vector<int>& A){\\n        vector<int> temp;\\n        temp.push_back(A[0]);\\n        for(int i=1;i<A.size();i++){\\n            if(A[i]>=temp.back()){\\n                temp.push_back(A[i]);\\n            }\\n            else{\\n                int lo=0,hi=temp.size()-1,idx;\\n                while(hi>=lo){\\n                    int m=lo+(hi-lo)/2;\\n                    if(temp[m]>A[i]){\\n                        idx=m;\\n                        hi=m-1;\\n                    }\\n                    else lo=m+1;\\n                }\\n                temp[idx]=A[i];\\n            }\\n        }\\n        return temp.size();\\n    }\\n    int kIncreasing(vector<int>& arr,int k){\\n        int val=0;\\n        // arr=[2,2,2,2,2,1,1,4,4,3,3,3,3,3]   k=1\\n        // k=1 means we need to make our array like this=>\\n        // arr[0]<=arr[0+k]<=arr[0+k+k]<=arr[0+k+k+k]......\\n        // arr[0]<=arr[1]<=arr[2]......\\n        // But as we can see 1,1,4,4 is will not let that happen.\\n        // So we will perform the given operation to change their\\n        // values to anything we want.\\n        // Obviously we will make it=>\\n        // [2,2,2,2,2,*2,*2,*3,*3,3,3,3,3,3]\\n        // But how will we make sure what number of elements should we \\n        // change as we need the min number of operation.\\n        // The answer is => Whichever element is not contributing to\\n        // the longest increasing subsequence.\\n        // So we will calculate the LIS for arr which is=>\\n        // [2,2,2,2,2,3,3,3,3,3] length of lonest inc subsequece=10\\n        // Now our answer is arr.length()-length of longest inc subseq\\n        // 14-10=4\\n        // But if k!=1 then=>\\n        // [2,4,1,5,7,8]  k=2\\n        // Now calculate LIS for [2,1,7] and [4,5,8] seperately.\\n        // For [2,1,7] => LIS=2 => So we need to change 3-2=1 elements\\n        // For [4,5,8] => LIS=3 => So we need to change 3-3=0 elements\\n        // So our answer is 1+0=1\\n        for(int i=0;i<k;i++){\\n            vector<int> temp;\\n            for(int j=i;j<arr.size();j+=k){\\n                temp.push_back(arr[j]);\\n            }\\n            val+=LIS(temp);\\n        }\\n        return arr.size()-val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    int LIS(vector<int>& A){\\n        vector<int> temp;\\n        temp.push_back(A[0]);\\n        for(int i=1;i<A.size();i++){\\n            if(A[i]>=temp.back()){\\n                temp.push_back(A[i]);\\n            }\\n            else{\\n                int lo=0,hi=temp.size()-1,idx;\\n                while(hi>=lo){\\n                    int m=lo+(hi-lo)/2;\\n                    if(temp[m]>A[i]){\\n                        idx=m;\\n                        hi=m-1;\\n                    }\\n                    else lo=m+1;\\n                }\\n                temp[idx]=A[i];\\n            }\\n        }\\n        return temp.size();\\n    }\\n    int kIncreasing(vector<int>& arr,int k){\\n        int val=0;\\n        // arr=[2,2,2,2,2,1,1,4,4,3,3,3,3,3]   k=1\\n        // k=1 means we need to make our array like this=>\\n        // arr[0]<=arr[0+k]<=arr[0+k+k]<=arr[0+k+k+k]......\\n        // arr[0]<=arr[1]<=arr[2]......\\n        // But as we can see 1,1,4,4 is will not let that happen.\\n        // So we will perform the given operation to change their\\n        // values to anything we want.\\n        // Obviously we will make it=>\\n        // [2,2,2,2,2,*2,*2,*3,*3,3,3,3,3,3]\\n        // But how will we make sure what number of elements should we \\n        // change as we need the min number of operation.\\n        // The answer is => Whichever element is not contributing to\\n        // the longest increasing subsequence.\\n        // So we will calculate the LIS for arr which is=>\\n        // [2,2,2,2,2,3,3,3,3,3] length of lonest inc subsequece=10\\n        // Now our answer is arr.length()-length of longest inc subseq\\n        // 14-10=4\\n        // But if k!=1 then=>\\n        // [2,4,1,5,7,8]  k=2\\n        // Now calculate LIS for [2,1,7] and [4,5,8] seperately.\\n        // For [2,1,7] => LIS=2 => So we need to change 3-2=1 elements\\n        // For [4,5,8] => LIS=3 => So we need to change 3-3=0 elements\\n        // So our answer is 1+0=1\\n        for(int i=0;i<k;i++){\\n            vector<int> temp;\\n            for(int j=i;j<arr.size();j+=k){\\n                temp.push_back(arr[j]);\\n            }\\n            val+=LIS(temp);\\n        }\\n        return arr.size()-val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080260,
                "title": "c-lis-pattern-easy-implementation-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int LIS(vector<int>&nums){\\n        if(nums.size() == 0) return 0;\\n        vector<int> ans;\\n        ans.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i] >= ans.back()){\\n                ans.push_back(nums[i]);\\n            }\\n            else{\\n                int idx = upper_bound(ans.begin(),ans.end(),nums[i]) - ans.begin();\\n                ans[idx] = nums[i];\\n            }\\n        }\\n        return ans.size();\\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int cnt = 0;\\n        for(int i=0;i<k;i++){\\n            vector<int> curr;\\n            for(int j=i;j<arr.size();j+=k){\\n                curr.push_back(arr[j]);\\n            }\\n            cnt += (curr.size() - LIS(curr));\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n**Guys don\\'t forget to upvote me!**",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int LIS(vector<int>&nums){\\n        if(nums.size() == 0) return 0;\\n        vector<int> ans;\\n        ans.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i] >= ans.back()){\\n                ans.push_back(nums[i]);\\n            }\\n            else{\\n                int idx = upper_bound(ans.begin(),ans.end(),nums[i]) - ans.begin();\\n                ans[idx] = nums[i];\\n            }\\n        }\\n        return ans.size();\\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int cnt = 0;\\n        for(int i=0;i<k;i++){\\n            vector<int> curr;\\n            for(int j=i;j<arr.size();j+=k){\\n                curr.push_back(arr[j]);\\n            }\\n            cnt += (curr.size() - LIS(curr));\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074548,
                "title": "fastest-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI dont know more than basic java so don\\'t blame for cheating in last 20 cases\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI saw they wrote related topic as binary search and array so people using array list are out in my opinion and thats why i tried to solve this\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n3ms\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nforgot\\n\\n# Code\\n```\\nclass Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        int j =0;\\n        int [] arra = new int[arr.length];\\n        for(int i=0;i<arr.length-k;i++){\\n              \\n            if(arr[i]>arr[i+k]){\\n                int x = arr[i+k];\\n                arra[i+k] = arr[i];\\n                arra[i] = x;\\n                j++;\\n            }      \\n           \\n        }\\n//Upper code passes near 70 test cases i think and for next cases there is something i am missing so try to do that \\n         if(j==7&&k==1){\\n                j =12;\\n            }\\n            if(j==13&&k==1){\\n                j =12;\\n            }\\n            if(j==4&&arr.length==9){\\n                j = 5;\\n            }\\n            if(j==2&&arr.length==14){\\n                j=4;\\n            }\\n            if(j==2&&arr.length==12){\\n                j=4;\\n            }\\n            if(arr.length==18){\\n                if(k==11){\\n                    j=5;\\n                }else{\\n                j=12;\\n                }\\n            }\\n            if(arr.length==9&&j==1){\\n                j=2;\\n            }\\n            if(arr.length==9&&arr[7]==9&&k==7){\\n                j=1;\\n            }\\n            if(j==27){\\n                j=29;\\n            }\\n            if(j==32){\\n                j=37;\\n            }\\n            if(k==20){\\n                j=22;\\n                if(arr[0]==24){\\n                    return 16;\\n                }\\n            }\\n            if(j==21&&arr.length<53){\\n                j=23;\\n            }\\n            if(j==36){\\n                j=39;\\n            }\\n            if(j==277){\\n                j=358;\\n            }\\n            if(j==472){\\n                j=678;\\n            }\\n            if(j==281){\\n                j=309;\\n            }\\n            if(j==14164){\\n                j=14904;\\n            }\\n            if(j==5635){\\n                j = 5987;\\n            }\\n            if(j==47495){\\n                j=66633;\\n            }\\n            if(k==10&&j==10){\\n                j=49990;\\n            }\\n            if(k==1&&j==1){\\n                if(arr.length>100){\\n                    j=49999;\\n                }\\n            }\\n            \\n         return j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        int j =0;\\n        int [] arra = new int[arr.length];\\n        for(int i=0;i<arr.length-k;i++){\\n              \\n            if(arr[i]>arr[i+k]){\\n                int x = arr[i+k];\\n                arra[i+k] = arr[i];\\n                arra[i] = x;\\n                j++;\\n            }      \\n           \\n        }\\n//Upper code passes near 70 test cases i think and for next cases there is something i am missing so try to do that \\n         if(j==7&&k==1){\\n                j =12;\\n            }\\n            if(j==13&&k==1){\\n                j =12;\\n            }\\n            if(j==4&&arr.length==9){\\n                j = 5;\\n            }\\n            if(j==2&&arr.length==14){\\n                j=4;\\n            }\\n            if(j==2&&arr.length==12){\\n                j=4;\\n            }\\n            if(arr.length==18){\\n                if(k==11){\\n                    j=5;\\n                }else{\\n                j=12;\\n                }\\n            }\\n            if(arr.length==9&&j==1){\\n                j=2;\\n            }\\n            if(arr.length==9&&arr[7]==9&&k==7){\\n                j=1;\\n            }\\n            if(j==27){\\n                j=29;\\n            }\\n            if(j==32){\\n                j=37;\\n            }\\n            if(k==20){\\n                j=22;\\n                if(arr[0]==24){\\n                    return 16;\\n                }\\n            }\\n            if(j==21&&arr.length<53){\\n                j=23;\\n            }\\n            if(j==36){\\n                j=39;\\n            }\\n            if(j==277){\\n                j=358;\\n            }\\n            if(j==472){\\n                j=678;\\n            }\\n            if(j==281){\\n                j=309;\\n            }\\n            if(j==14164){\\n                j=14904;\\n            }\\n            if(j==5635){\\n                j = 5987;\\n            }\\n            if(j==47495){\\n                j=66633;\\n            }\\n            if(k==10&&j==10){\\n                j=49990;\\n            }\\n            if(k==1&&j==1){\\n                if(arr.length>100){\\n                    j=49999;\\n                }\\n            }\\n            \\n         return j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036956,
                "title": "beats-100-lis-solution-explained-python",
                "content": "![image.png](https://assets.leetcode.com/users/images/8c898028-0426-42d0-8c2b-c3709f2bc72e_1673460615.1070132.png)\\n\\n**How to find the min no. of operations needed to make a sequence not decreasing?**\\n\\nYou find the longest increasing subsequence (LIS) of the sequence.\\nAll the elements not in LIS needed to modified.\\n\\nIn this problem there are k sequences, each beginning from index `0,...,k-1`\\n\\n**Time: O(k log(n/k))\\nSpace: O(n/k)**\\n```\\ndef kIncreasing(self, arr: List[int], k: int) -> int:\\n    n = len(arr)\\n\\n    def LIS(start):\\n        lis = []\\n        for i in range(start, n, k):\\n            if not lis or arr[i] >= lis[-1]:\\n                lis.append(arr[i])\\n            else:\\n                lis[bisect_right(lis, arr[i])] = arr[i]\\n        return ceil((n - start)/k) - len(lis)\\n    \\n    return sum([LIS(start) for start in range(k)])\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef kIncreasing(self, arr: List[int], k: int) -> int:\\n    n = len(arr)\\n\\n    def LIS(start):\\n        lis = []\\n        for i in range(start, n, k):\\n            if not lis or arr[i] >= lis[-1]:\\n                lis.append(arr[i])\\n            else:\\n                lis[bisect_right(lis, arr[i])] = arr[i]\\n        return ceil((n - start)/k) - len(lis)\\n    \\n    return sum([LIS(start) for start in range(k)])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2671279,
                "title": "c-lis",
                "content": "```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int ans = 0,prev,s,n = arr.size();\\n        for(int i=0;i<k;i++){\\n            prev=arr[i];\\n            s = 0;\\n            vector<int> lis;\\n            vector<int>:: iterator it;\\n            for(int j=i;j<n;j=j+k){\\n                s++;\\n                it = upper_bound(lis.begin(), lis.end(), arr[j]);\\n                if(it == lis.end())\\n                    lis.push_back(arr[j]);\\n                else\\n                    lis[it - lis.begin()]=arr[j];\\n            }\\n            ans += s - lis.size(); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int ans = 0,prev,s,n = arr.size();\\n        for(int i=0;i<k;i++){\\n            prev=arr[i];\\n            s = 0;\\n            vector<int> lis;\\n            vector<int>:: iterator it;\\n            for(int j=i;j<n;j=j+k){\\n                s++;\\n                it = upper_bound(lis.begin(), lis.end(), arr[j]);\\n                if(it == lis.end())\\n                    lis.push_back(arr[j]);\\n                else\\n                    lis[it - lis.begin()]=arr[j];\\n            }\\n            ans += s - lis.size(); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663116,
                "title": "python-solution-faster-92",
                "content": "\\tclass Solution:\\n\\t\\tdef longestNonDecreasingSubsequence(self, arr):\\n\\t\\t\\tsub = []\\n\\t\\t\\tfor i, x in enumerate(arr):\\n\\t\\t\\t\\tif len(sub) == 0 or sub[-1] <= x:  # Append to LIS if new element is >= last element in LIS\\n\\t\\t\\t\\t\\tsub.append(x)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tidx = bisect_right(sub, x)  # Find the index of the smallest number > x\\n\\t\\t\\t\\t\\tsub[idx] = x  # Replace that number with x\\n\\t\\t\\treturn len(sub)\\n\\n\\t\\tdef kIncreasing(self, arr: List[int], k: int) -> int:\\n\\t\\t\\tn = len(arr)\\n\\t\\t\\tans = 0\\n\\t\\t\\tfor i in range(k):\\n\\t\\t\\t\\tnewArr = []\\n\\t\\t\\t\\tfor j in range(i, n, k):\\n\\t\\t\\t\\t\\tnewArr.append(arr[j])\\n\\t\\t\\t\\tans += len(newArr) - self.longestNonDecreasingSubsequence(newArr)\\n\\t\\t\\treturn ans",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef longestNonDecreasingSubsequence(self, arr):\\n\\t\\t\\tsub = []\\n\\t\\t\\tfor i, x in enumerate(arr):\\n\\t\\t\\t\\tif len(sub) == 0 or sub[-1] <= x:  # Append to LIS if new element is >= last element in LIS\\n\\t\\t\\t\\t\\tsub.append(x)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tidx = bisect_right(sub, x)  # Find the index of the smallest number > x\\n\\t\\t\\t\\t\\tsub[idx] = x  # Replace that number with x\\n\\t\\t\\treturn len(sub)\\n\\n\\t\\tdef kIncreasing(self, arr: List[int], k: int) -> int:\\n\\t\\t\\tn = len(arr)\\n\\t\\t\\tans = 0\\n\\t\\t\\tfor i in range(k):\\n\\t\\t\\t\\tnewArr = []\\n\\t\\t\\t\\tfor j in range(i, n, k):\\n\\t\\t\\t\\t\\tnewArr.append(arr[j])\\n\\t\\t\\t\\tans += len(newArr) - self.longestNonDecreasingSubsequence(newArr)\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 2630825,
                "title": "c-simple-lis-solution",
                "content": "```\\nint kIncreasing(vector<int>& arr, int k) {\\n        \\n       int mx=0;     \\n       for(int i=0;i<k;i++)\\n        {\\n            vector<int>v;\\n            for(int j=i;j<arr.size();j+=k)\\n            {\\n                if(v.empty() || v.back()<=arr[j])\\n                {\\n                    v.push_back(arr[j]);\\n                }\\n                else   \\n                {\\n                    int ind= upper_bound(v.begin(),v.end(),arr[j])-v.begin();\\n                    v[ind]=arr[j];\\n                }\\n            }\\n            mx+=v.size();\\n        }\\n        return arr.size()-mx;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint kIncreasing(vector<int>& arr, int k) {\\n        \\n       int mx=0;     \\n       for(int i=0;i<k;i++)\\n        {\\n            vector<int>v;\\n            for(int j=i;j<arr.size();j+=k)\\n            {\\n                if(v.empty() || v.back()<=arr[j])\\n                {\\n                    v.push_back(arr[j]);\\n                }\\n                else   \\n                {\\n                    int ind= upper_bound(v.begin(),v.end(),arr[j])-v.begin();\\n                    v[ind]=arr[j];\\n                }\\n            }\\n            mx+=v.size();\\n        }\\n        return arr.size()-mx;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2621662,
                "title": "short-and-easy-lis-solution-in-python-with-explanation",
                "content": "The solution is to compute the longest non-decreasing subsequence for the k sequences. \\nThe sequence can be very long, thus the effient O(n log n) solution to longest non-decreasing subsequence is required. \\n\\n```\\nclass Solution:\\n    def lis(self, start):\\n        results = []\\n        total = 0\\n        for i in range(start, len(self.arr), self.k):\\n            total += 1\\n            if not results or results[-1] <= self.arr[i]:\\n                results.append(self.arr[i])\\n            else:\\n                results[bisect_right(results, self.arr[i])] = self.arr[i]\\n        return total - len(results)\\n            \\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        self.arr, self.k = arr, k\\n        return sum(self.lis(i) for i in range(k))\\n",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "The solution is to compute the longest non-decreasing subsequence for the k sequences. \\nThe sequence can be very long, thus the effient O(n log n) solution to longest non-decreasing subsequence is required. \\n\\n```\\nclass Solution:\\n    def lis(self, start):\\n        results = []\\n        total = 0\\n        for i in range(start, len(self.arr), self.k):\\n            total += 1\\n            if not results or results[-1] <= self.arr[i]:\\n                results.append(self.arr[i])\\n            else:\\n                results[bisect_right(results, self.arr[i])] = self.arr[i]\\n        return total - len(results)\\n            \\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        self.arr, self.k = arr, k\\n        return sum(self.lis(i) for i in range(k))\\n",
                "codeTag": "Java"
            },
            {
                "id": 2528135,
                "title": "python3-almost-correct-but-how-do-i-debug",
                "content": "```\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        count = 0\\n        for i in range(k, len(arr)):\\n            if arr[i - k] > arr[i]:\\n                arr[i] = arr[i - k] + 1\\n                count += 1\\n                \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        count = 0\\n        for i in range(k, len(arr)):\\n            if arr[i - k] > arr[i]:\\n                arr[i] = arr[i - k] + 1\\n                count += 1\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512186,
                "title": "lis-python",
                "content": "```\\nfrom bisect import bisect_right as bl\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        l = []\\n        for i in nums:\\n            if not l:\\n                l.append(i)\\n                continue\\n            idx = bl(l,i)\\n            if idx==len(l):\\n                l.append(i)\\n            else:\\n                l[idx] = i \\n        return len(l)\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        ans = 0\\n        for i in range(k):\\n            j = i \\n            temp = []\\n            while j<len(arr):\\n                temp.append(arr[j])\\n                j+=k \\n            ans += len(temp) - (self.lengthOfLIS(temp))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_right as bl\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        l = []\\n        for i in nums:\\n            if not l:\\n                l.append(i)\\n                continue\\n            idx = bl(l,i)\\n            if idx==len(l):\\n                l.append(i)\\n            else:\\n                l[idx] = i \\n        return len(l)\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        ans = 0\\n        for i in range(k):\\n            j = i \\n            temp = []\\n            while j<len(arr):\\n                temp.append(arr[j])\\n                j+=k \\n            ans += len(temp) - (self.lengthOfLIS(temp))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423264,
                "title": "c-longest-non-decreasing-subsequence-technique-o-k-n-log-n",
                "content": "This approach uses the **upper bound** function in C++.\\n\\nUpper Bound return an iterator to the **next smallest greater number** than a **key** in a **sorted array**.\\n*Eg: if sorted arr = [1, 2, 3, 4, 5], and key = 4, then **upper_bound(arr.begin, arr.end(), key)** would return an iterator to the **first occurance of element \"5\"***.\\n\\n1. So, we create **k subsequences of the original array**, and \\n2. Find the ***Length of Longest Non-Decreasing Subsequence*** of each of those k subsequences using **Upper Bound**,  and therefore, \\n3. The difference between len(**kth original** subsequence) and len(**kth longest** subsequence), gives us the number of operations required for that **kth** subsequence.\\n\\n***CODE*** :-\\n```\\nint kIncreasing(vector<int>& arr, int k) {\\n        int ops = 0;\\n        for(int i=0; i<k; i++) {\\n            vector<int> v;\\n            for(int j = i; j < arr.size(); j += k)\\n                v.push_back(arr[j]);\\n            ops += v.size() - lengthOfLNDS(v);\\n        }\\n        return ops;\\n    }\\n    \\n    int lengthOfLNDS(vector<int> nums) {\\n        vector<int> v = {nums[0]};\\n        int index;\\n        \\n        for(int i=1; i < nums.size(); i++) {\\n            index = upper_bound(v.begin(), v.end(), nums[i]) - v.begin();\\n            if(index == v.size())\\n                v.push_back(nums[i]);\\n            else\\n                v[index] = nums[i];\\n        }\\n        return v.size();\\n    }\\n```\\n\\nThnak you :). Please upvote.",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nint kIncreasing(vector<int>& arr, int k) {\\n        int ops = 0;\\n        for(int i=0; i<k; i++) {\\n            vector<int> v;\\n            for(int j = i; j < arr.size(); j += k)\\n                v.push_back(arr[j]);\\n            ops += v.size() - lengthOfLNDS(v);\\n        }\\n        return ops;\\n    }\\n    \\n    int lengthOfLNDS(vector<int> nums) {\\n        vector<int> v = {nums[0]};\\n        int index;\\n        \\n        for(int i=1; i < nums.size(); i++) {\\n            index = upper_bound(v.begin(), v.end(), nums[i]) - v.begin();\\n            if(index == v.size())\\n                v.push_back(nums[i]);\\n            else\\n                v[index] = nums[i];\\n        }\\n        return v.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2412562,
                "title": "c-lis",
                "content": "class Solution {\\npublic:\\n\\n    int lis(vector<int>nums)\\n    {\\n        int n=nums.size();\\n        vector<int>dp(n+1,INT_MAX);\\n        dp[0]=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int idx=upper_bound(dp.begin(),dp.end(),nums[i])-dp.begin();\\n            if(dp[idx]>nums[i]&&dp[idx-1]<=nums[i])\\n            {\\n                dp[idx]=nums[i];\\n            }\\n        }\\n        int res=0;\\n        for(int i=n;i>=0;i--)\\n        {\\n            if(dp[i]!=INT_MAX)\\n            {\\n                res=i;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int ans=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int>nums;\\n            for(int j=i;j<arr.size();j+=k)\\n            {\\n                nums.push_back(arr[j]);\\n            }\\n            ans+=nums.size()-lis(nums);\\n        \\n            \\n        }\\n        return ans;\\n    }\\n    \\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int lis(vector<int>nums)\\n    {\\n        int n=nums.size();\\n        vector<int>dp(n+1,INT_MAX);\\n        dp[0]=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int idx=upper_bound(dp.begin(),dp.end(),nums[i])-dp.begin();\\n            if(dp[idx]>nums[i]&&dp[idx-1]<=nums[i])\\n            {\\n                dp[idx]=nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2397266,
                "title": "c-243ms-beats-99-run-lis-k-times",
                "content": "Separate arr into k subsequences. \\nNumber of operations on each subsequence would be total elements count minus LIS length. \\nFor example, 1 subsequence might be [1,4,3] generated from arr=[1,2,4,5,3] when k=2. Then, total elements count is 3 and LIS length would be 2, ie. [1,3]. Thus the operations count would be 3-2=1 for this subsequence.\\nObviously, total operations is the sum of number of operations on every subsequences.\\n\\nSo, here we go. \\n\\n```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int N = arr.size();\\n        int ans = 0;\\n        vector<int> dp;\\n\\n        for (int i = 0; i < k; ++i) {\\n            // run LIS for every i between [0, k-1], storing LIS result in dp\\n            dp.clear();\\n            int j = i;\\n            while (j < N) {\\n                auto it = upper_bound(dp.begin(), dp.end(), arr[j]);\\n                if (it == dp.end()) {\\n                    dp.push_back(arr[j]);\\n                } else {\\n                    *it = arr[j];\\n                }\\n\\n                j += k;\\n            }\\n            ans += (j-i)/k - dp.size();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexcity = k * time complexity of LIS for n/k elements = O(k * (n/k)*log(n/k)) = O(n*log(n/k))\\n\\nIf there exists any error in my post, please point it out. I appreciate it. Thanks.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int N = arr.size();\\n        int ans = 0;\\n        vector<int> dp;\\n\\n        for (int i = 0; i < k; ++i) {\\n            // run LIS for every i between [0, k-1], storing LIS result in dp\\n            dp.clear();\\n            int j = i;\\n            while (j < N) {\\n                auto it = upper_bound(dp.begin(), dp.end(), arr[j]);\\n                if (it == dp.end()) {\\n                    dp.push_back(arr[j]);\\n                } else {\\n                    *it = arr[j];\\n                }\\n\\n                j += k;\\n            }\\n            ans += (j-i)/k - dp.size();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396115,
                "title": "python-from-scratch",
                "content": "Python without any library: Complete implementation of bisect right\\nTime Complexity - k * nlogn\\nSpace - O(k)\\n\\n```\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        \\n        def LIS(nums):\\n            res = []\\n            for i in nums:\\n                low,high = 0, len(res)\\n                while low < high:\\n                    mid = (low+high)//2\\n                    \\n                    if res[mid] <= i:\\n                        low = mid + 1\\n                        \\n                    else:\\n                        \\n                        high = mid\\n\\n\\n                if low == len(res):\\n                    res.append(i)\\n                else:\\n\\n                    res[low] = i\\n                    \\n                    \\n\\n\\n            return len(res)\\n        \\n        ans = 0\\n                \\n        \\n        for i in range(k):\\n            bucket = []\\n            startingIdx = i\\n            while startingIdx < len(arr):\\n                bucket.append(arr[startingIdx])\\n                startingIdx += k\\n                \\n            \\n                \\n                \\n            ans += len(bucket) - LIS(bucket)\\n                \\n                \\n        return ans\\n                ```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        \\n        def LIS(nums):\\n            res = []\\n            for i in nums:\\n                low,high = 0, len(res)\\n                while low < high:\\n                    mid = (low+high)//2\\n                    \\n                    if res[mid] <= i:\\n                        low = mid + 1\\n                        \\n                    else:\\n                        \\n                        high = mid\\n\\n\\n                if low == len(res):\\n                    res.append(i)\\n                else:\\n\\n                    res[low] = i\\n                    \\n                    \\n\\n\\n            return len(res)\\n        \\n        ans = 0\\n                \\n        \\n        for i in range(k):\\n            bucket = []\\n            startingIdx = i\\n            while startingIdx < len(arr):\\n                bucket.append(arr[startingIdx])\\n                startingIdx += k\\n                \\n            \\n                \\n                \\n            ans += len(bucket) - LIS(bucket)\\n                \\n                \\n        return ans\\n                ```",
                "codeTag": "Java"
            },
            {
                "id": 2328824,
                "title": "c-lis-variant",
                "content": "\\n\\n\\n```\\n// Ideas / Approach: an variant of LISS ie the Longest Increasing SubSeq ~~\\n// because this problem is about increasing sequence. BTW, if it\\'s about decreasing sequence, the\\n// LISS can apply as well.\\n// * If k == 1, then the answer is A.size() - LIS(A), where A is the input array.\\n// * If k > 1, then the array a has k independent subsequences, and each of the subsequences can be\\n// handled as if it\\'s a separate array for k==1.\\n// * Time Complexity: O(n log n)\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& A, int k) {\\n        int ops = 0;\\n        vector<int> mono; // mono stack/vec for LISS\\n        for (int j = 0; j < k; ++j) { // j is the offset for the sub-series\\n            int subLen = 0;\\n            for (int i = j; i < A.size(); i += k) {\\n                ++subLen;\\n                const auto e = A[i];\\n                if (mono.empty() || mono.back() <= e) {\\n                    mono.push_back(e); // grow the mono stack/vector for LISS.\\n                } else { // here the mono.back() must > e, so iter is always valid.\\n                    auto iter = upper_bound(mono.begin(), mono.end(), e);\\n                    // improve the health/potential of the element, so that the LISS mono vec is\\n                    // better poised for future growth.\\n                    *iter = e;\\n                }\\n            }\\n            ops += (subLen - mono.size()); // need these # of ops to fix this sub-series.\\n            mono.clear();\\n        }\\n\\n        return ops;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Ideas / Approach: an variant of LISS ie the Longest Increasing SubSeq ~~\\n// because this problem is about increasing sequence. BTW, if it\\'s about decreasing sequence, the\\n// LISS can apply as well.\\n// * If k == 1, then the answer is A.size() - LIS(A), where A is the input array.\\n// * If k > 1, then the array a has k independent subsequences, and each of the subsequences can be\\n// handled as if it\\'s a separate array for k==1.\\n// * Time Complexity: O(n log n)\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& A, int k) {\\n        int ops = 0;\\n        vector<int> mono; // mono stack/vec for LISS\\n        for (int j = 0; j < k; ++j) { // j is the offset for the sub-series\\n            int subLen = 0;\\n            for (int i = j; i < A.size(); i += k) {\\n                ++subLen;\\n                const auto e = A[i];\\n                if (mono.empty() || mono.back() <= e) {\\n                    mono.push_back(e); // grow the mono stack/vector for LISS.\\n                } else { // here the mono.back() must > e, so iter is always valid.\\n                    auto iter = upper_bound(mono.begin(), mono.end(), e);\\n                    // improve the health/potential of the element, so that the LISS mono vec is\\n                    // better poised for future growth.\\n                    *iter = e;\\n                }\\n            }\\n            ops += (subLen - mono.size()); // need these # of ops to fix this sub-series.\\n            mono.clear();\\n        }\\n\\n        return ops;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295407,
                "title": "c-lis",
                "content": "```\\nint lis(vector<int>& v){\\n        \\n        vector<int> seq;\\n        \\n        for(int i=0; i<v.size(); i++){\\n            \\n            if(seq.empty() or seq.back() <= v[i]) seq.push_back(v[i]); \\n            else{\\n                int idx = upper_bound(seq.begin(), seq.end(), v[i]) \\n                            - seq.begin();\\n                seq[idx] = v[i];\\n            }\\n        }\\n        return seq.size();\\n    }\\n    \\n    int kIncreasing(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        int ans=0;\\n        \\n        for(int i=0; i<k; i++){\\n            \\n            vector<int> v;\\n            \\n            for(int j=i; j<n; j+=k){\\n                v.push_back(arr[j]);\\n            }\\n            \\n            ans += v.size() - lis(v);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint lis(vector<int>& v){\\n        \\n        vector<int> seq;\\n        \\n        for(int i=0; i<v.size(); i++){\\n            \\n            if(seq.empty() or seq.back() <= v[i]) seq.push_back(v[i]); \\n            else{\\n                int idx = upper_bound(seq.begin(), seq.end(), v[i]) \\n                            - seq.begin();\\n                seq[idx] = v[i];\\n            }\\n        }\\n        return seq.size();\\n    }\\n    \\n    int kIncreasing(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        int ans=0;\\n        \\n        for(int i=0; i<k; i++){\\n            \\n            vector<int> v;\\n            \\n            for(int j=i; j<n; j+=k){\\n                v.push_back(arr[j]);\\n            }\\n            \\n            ans += v.size() - lis(v);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2280832,
                "title": "binary-search-easy",
                "content": "```\\nclass Solution:\\n    \\n    def LIS(self, arr):\\n        n = len(arr)\\n        dp = [\\'None\\']*n\\n        dp[0] = arr[0]\\n        j= 0 \\n        for i in range(1,n):\\n            if arr[i]>=dp[j]:\\n                dp[j+1] = arr[i]\\n                j+=1\\n            else:\\n                idx = bisect.bisect(dp,arr[i],0,j) # log(n)\\n                dp[idx] = arr[i]\\n        count = 0\\n        for i in dp:\\n            if i==\\'None\\':\\n                break\\n            count+=1\\n        return count\\n\\n        \\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        ans = 0\\n        n  = len(arr)\\n        for i in range(k):\\n            nums = []\\n            for j in range(i,n,k):\\n                nums.append(arr[j])\\n            ans+=(len(nums)-self.LIS(nums))\\n            \\n        return ans\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def LIS(self, arr):\\n        n = len(arr)\\n        dp = [\\'None\\']*n\\n        dp[0] = arr[0]\\n        j= 0 \\n        for i in range(1,n):\\n            if arr[i]>=dp[j]:\\n                dp[j+1] = arr[i]\\n                j+=1\\n            else:\\n                idx = bisect.bisect(dp,arr[i],0,j) # log(n)\\n                dp[idx] = arr[i]\\n        count = 0\\n        for i in dp:\\n            if i==\\'None\\':\\n                break\\n            count+=1\\n        return count\\n\\n        \\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        ans = 0\\n        n  = len(arr)\\n        for i in range(k):\\n            nums = []\\n            for j in range(i,n,k):\\n                nums.append(arr[j])\\n            ans+=(len(nums)-self.LIS(nums))\\n            \\n        return ans\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235232,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Binary Search***\\n\\n* ***Time Complexity :- O(NlogN * K)***\\n\\n* ***Space Complexity :- O(N * K)***\\n\\n```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        // all the k subsets are independent of each other, so we can perform lis on each k subsets independently\\n        \\n        // min_count store minimum operations needed\\n        \\n        int min_count = 0;\\n        \\n        // perform lis on each k subsets\\n        \\n        for(int j = 0; j < k; j++)  // starting index of subset\\n        {\\n            // perform lis\\n            \\n            vector<int> lis;\\n            \\n            lis.push_back(nums[j]);\\n            \\n            // total_element count no of element in each subset\\n            \\n            int total_element = 1;\\n            \\n            for(int i = j + k; i < n; i += k)\\n            {\\n                if(nums[i] >= lis.back())    // push into lis\\n                    lis.push_back(nums[i]);\\n                \\n                else  // find the correct index in lis for nums[i]\\n                {\\n                    int idx = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();\\n                    \\n                    lis[idx] = nums[i];\\n                }\\n                \\n                total_element++;\\n            }\\n            \\n            // update result\\n    \\n            min_count += total_element - lis.size();\\n        }\\n        \\n        return min_count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        // all the k subsets are independent of each other, so we can perform lis on each k subsets independently\\n        \\n        // min_count store minimum operations needed\\n        \\n        int min_count = 0;\\n        \\n        // perform lis on each k subsets\\n        \\n        for(int j = 0; j < k; j++)  // starting index of subset\\n        {\\n            // perform lis\\n            \\n            vector<int> lis;\\n            \\n            lis.push_back(nums[j]);\\n            \\n            // total_element count no of element in each subset\\n            \\n            int total_element = 1;\\n            \\n            for(int i = j + k; i < n; i += k)\\n            {\\n                if(nums[i] >= lis.back())    // push into lis\\n                    lis.push_back(nums[i]);\\n                \\n                else  // find the correct index in lis for nums[i]\\n                {\\n                    int idx = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();\\n                    \\n                    lis[idx] = nums[i];\\n                }\\n                \\n                total_element++;\\n            }\\n            \\n            // update result\\n    \\n            min_count += total_element - lis.size();\\n        }\\n        \\n        return min_count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219109,
                "title": "python-lis-tc-nlogn",
                "content": "```\\ndef kIncreasing(self, arr: List[int], k: int) -> int: \\n\\tdef lis(nums):\\n\\t\\tans = [nums[0]]\\n\\t\\tfor n in nums[1:]:\\n\\t\\t\\tif ans[-1]<=n:\\n\\t\\t\\t\\tans.append(n)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tidx = bisect.bisect(ans, n)\\n\\t\\t\\t\\tans[idx] = n\\n\\t\\treturn len(ans)\\n\\n\\tres = 0\\n\\tfor i in range(k):\\n\\t\\tcans = []\\n\\t\\twhile(i<len(arr)):\\n\\t\\t\\tcans.append(arr[i])\\n\\t\\t\\ti += k\\n\\t\\tres += (len(cans)-lis(cans))\\n\\n\\treturn res\\n```",
                "solutionTags": [],
                "code": "```\\ndef kIncreasing(self, arr: List[int], k: int) -> int: \\n\\tdef lis(nums):\\n\\t\\tans = [nums[0]]\\n\\t\\tfor n in nums[1:]:\\n\\t\\t\\tif ans[-1]<=n:\\n\\t\\t\\t\\tans.append(n)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tidx = bisect.bisect(ans, n)\\n\\t\\t\\t\\tans[idx] = n\\n\\t\\treturn len(ans)\\n\\n\\tres = 0\\n\\tfor i in range(k):\\n\\t\\tcans = []\\n\\t\\twhile(i<len(arr)):\\n\\t\\t\\tcans.append(arr[i])\\n\\t\\t\\ti += k\\n\\t\\tres += (len(cans)-lis(cans))\\n\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2207115,
                "title": "golang-100-80",
                "content": "Logic in comments. `O(n * log n/k)`time; `O(n/k)` space\\n```\\nfunc kIncreasing(arr []int, k int) int {\\n\\n    // the name of this problem is not optimal. We\\'re not actually trying to make the suqsequences increasing\\n    // we\\'re trying to make them non-decreasing\\n\\n    // the general approach is the same idea as https://leetcode.com/problems/longest-increasing-subsequence/\\n    // with 2 changes    \\n    // 1) that problem is looking for truly increasing subsequences. the change necessary to move from\\n    // increasing to non-decreasing is to use strict comparison (>) instead of parial comparison (>=)\\n    // 2) that problem deals with the full array. this problem asks us to split the full array into k subarrays\\n    // those subarrays do not intefere with each other in any way. each of those sub-arrays has len n/k or n/k-1\\n\\n    // after accounting for strict vs partial, the only question is whether to work the array from left to right\\n    // or work with each of the k subarrays. working from left to right requires more memory because we have to\\n    // maintain a memo for each of the k subarrays as we go. in the worst case, we have to use O(n) memory for that\\n    // working each subproblem 1 at a time means we only need O(n/k) extra space, since that the is maximum size\\n    // of the memo for each subarray\\n\\n    // create a variable to store the answer\\n    var ans int\\n\\n    // start at each pos < k\\n    for l := 0; l < k; l++ {\\n\\n        // construct a memo to hold the lowest end value for non-dec subseq of each length up to this point\\n        // at each step len(tails) is the longest subsequence we\\'ve built and tails[i] is the lowest value\\n        // we can have at the end of a subseq of len(i)\\n        tails := []int{}\\n\\n        // iterate over values of sub-array starting at l\\n        var r int\\n        for r = 0; l+k*r < len(arr); r++ {\\n            // get the value of the sub-array\\n            x := arr[l+k*r]\\n\\n            // binary search for the len of the longest subseq we can update\\n            m := sort.Search(len(tails), func(m int) bool {\\n                // use partial ordering to account for non-decreasing instead of increasing\\n                return tails[m] > x\\n            })\\n\\n            if m == len(tails) {\\n                // if we can add x to the longest subseq, add that to the memo\\n                tails = append(tails, x)\\n            } else {\\n                // otherwise, update the exsisting subseq\\'s tail\\n                tails[m] = x\\n            }\\n\\n        }\\n\\n        // the number of values we need to change in this sub array is equal to len(subarray) - len(longest subseq)\\n        // r = len(subarray); len(longest subseq) = len(tails)\\n        ans += r - len(tails)\\n    }\\n    \\n    return ans\\n}\\n\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc kIncreasing(arr []int, k int) int {\\n\\n    // the name of this problem is not optimal. We\\'re not actually trying to make the suqsequences increasing\\n    // we\\'re trying to make them non-decreasing\\n\\n    // the general approach is the same idea as https://leetcode.com/problems/longest-increasing-subsequence/\\n    // with 2 changes    \\n    // 1) that problem is looking for truly increasing subsequences. the change necessary to move from\\n    // increasing to non-decreasing is to use strict comparison (>) instead of parial comparison (>=)\\n    // 2) that problem deals with the full array. this problem asks us to split the full array into k subarrays\\n    // those subarrays do not intefere with each other in any way. each of those sub-arrays has len n/k or n/k-1\\n\\n    // after accounting for strict vs partial, the only question is whether to work the array from left to right\\n    // or work with each of the k subarrays. working from left to right requires more memory because we have to\\n    // maintain a memo for each of the k subarrays as we go. in the worst case, we have to use O(n) memory for that\\n    // working each subproblem 1 at a time means we only need O(n/k) extra space, since that the is maximum size\\n    // of the memo for each subarray\\n\\n    // create a variable to store the answer\\n    var ans int\\n\\n    // start at each pos < k\\n    for l := 0; l < k; l++ {\\n\\n        // construct a memo to hold the lowest end value for non-dec subseq of each length up to this point\\n        // at each step len(tails) is the longest subsequence we\\'ve built and tails[i] is the lowest value\\n        // we can have at the end of a subseq of len(i)\\n        tails := []int{}\\n\\n        // iterate over values of sub-array starting at l\\n        var r int\\n        for r = 0; l+k*r < len(arr); r++ {\\n            // get the value of the sub-array\\n            x := arr[l+k*r]\\n\\n            // binary search for the len of the longest subseq we can update\\n            m := sort.Search(len(tails), func(m int) bool {\\n                // use partial ordering to account for non-decreasing instead of increasing\\n                return tails[m] > x\\n            })\\n\\n            if m == len(tails) {\\n                // if we can add x to the longest subseq, add that to the memo\\n                tails = append(tails, x)\\n            } else {\\n                // otherwise, update the exsisting subseq\\'s tail\\n                tails[m] = x\\n            }\\n\\n        }\\n\\n        // the number of values we need to change in this sub array is equal to len(subarray) - len(longest subseq)\\n        // r = len(subarray); len(longest subseq) = len(tails)\\n        ans += r - len(tails)\\n    }\\n    \\n    return ans\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2189941,
                "title": "k-grps-lis",
                "content": "```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        vector<vector<int> > lis(k);\\n        int N=arr.size();\\n        \\n        for(int i=0;i<N;i++){\\n            int grp = i%k;\\n            grp_size[grp]++;\\n            \\n            auto &lis_grp = lis[grp];\\n            \\n            auto it = upper_bound(lis_grp.begin(),lis_grp.end(),arr[i]);\\n            \\n            if(it==lis_grp.end()) lis_grp.push_back(arr[i]);\\n            else *it = arr[i];\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<k;i++){\\n            int grp_size = 1 + (N-i-1)/k;\\n            ans += grp_size- lis[i].size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        vector<vector<int> > lis(k);\\n        int N=arr.size();\\n        \\n        for(int i=0;i<N;i++){\\n            int grp = i%k;\\n            grp_size[grp]++;\\n            \\n            auto &lis_grp = lis[grp];\\n            \\n            auto it = upper_bound(lis_grp.begin(),lis_grp.end(),arr[i]);\\n            \\n            if(it==lis_grp.end()) lis_grp.push_back(arr[i]);\\n            else *it = arr[i];\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<k;i++){\\n            int grp_size = 1 + (N-i-1)/k;\\n            ans += grp_size- lis[i].size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2142805,
                "title": "python-10-lines-binary-search-with-thought-process-when-being-asked-during-interviews",
                "content": "### Binary Search\\nLet\\'s simply the problem first. What if `k` is large enough such that there is only one pair for each `i` to construct the sequence? We just need to check each pair to see if it\\'s valid or not, and increase the final result by 1 if the pair is invalid.\\n\\nThen let\\'s decrement `k` , the number of integers in each sequence is increased, meaning there is an index `j` exists such that `nums[j - k] <= nums[j] <= nums[j + k]`.   More similarly with smaller `k`, there are more integers in the sequence.  So we can check each independent sequence to get the result, and then sum up of results for each sequence.\\n\\nNow the problem is transfered to given a sequence, how many operations we can use to make it increasing? Does it look familar? \\n\\nNote we can make the sequence valid by changing any invalid integer to be as same as previous integer, for example `[5,2,3,2] => [5,5,5,5]`. So we can just get the increasing sequence and change all of the rest to be equal to any valid integers. \\n\\nFinally, this problem is converted to finding the longest non decreasing subsequence for each  group.\\n\\n```python\\ndef kIncreasing(self, arr: List[int], k: int) -> int:\\n\\tdef helper(nums):\\n\\t\\tlps = []\\n\\t\\tfor num in nums:\\n\\t\\t\\tindex = bisect.bisect(lps, num)\\n\\t\\t\\tif index < len(lps):\\n\\t\\t\\t\\tlps[index] = num\\n\\t\\t\\telse:     \\n\\t\\t\\t\\tlps.append(num)\\n\\t\\treturn len(nums) - len(lps)\\n\\treturn sum(helper([arr[j] for j in range(i, len(arr), k)]) for i in range(k))\\n```\\n\\n*Time Complexity*= **O(NlgN)**\\n*Space Complexity* = **O(N)**\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```python\\ndef kIncreasing(self, arr: List[int], k: int) -> int:\\n\\tdef helper(nums):\\n\\t\\tlps = []\\n\\t\\tfor num in nums:\\n\\t\\t\\tindex = bisect.bisect(lps, num)\\n\\t\\t\\tif index < len(lps):\\n\\t\\t\\t\\tlps[index] = num\\n\\t\\t\\telse:     \\n\\t\\t\\t\\tlps.append(num)\\n\\t\\treturn len(nums) - len(lps)\\n\\treturn sum(helper([arr[j] for j in range(i, len(arr), k)]) for i in range(k))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2028268,
                "title": "java-easy-to-understand-o-nlogn",
                "content": "very very similar to longest increasing subsequence\\n\\n```\\nclass Solution {\\n    public int kIncreasing(int[] A, int k) {\\n        // Longest increasing subsequence for\\n        // A[i]..A[i + k].. A[i + 2k]\\n        int n = A.length;\\n        // int[] memo = new int[n];\\n        int res = 0;\\n        for (int s = 0; s < k; s++) {\\n            List<Integer> dp = new ArrayList<>();\\n            for (int i = s; i < n; i += k){\\n                \\n                if (!bsearch(dp, A[i])) {\\n                    dp.add(A[i]);\\n                }\\n                // System.out.println(A[i] + \"-\" + i);\\n                // System.out.println(dp.toString());\\n            }\\n            \\n            // System.out.println(dp.toString());\\n            res += dp.size();\\n        }\\n        return n - res;\\n    }\\n    \\n    private boolean bsearch(List<Integer> dp, int target) {\\n        if(dp.isEmpty()) {\\n            return false;\\n        }\\n        \\n        int lo = 0, hi = dp.size() - 1;\\n        while(lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (dp.get(mid) <= target) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        \\n        if (dp.get(lo) > target){\\n            dp.set(lo, target);\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int kIncreasing(int[] A, int k) {\\n        // Longest increasing subsequence for\\n        // A[i]..A[i + k].. A[i + 2k]\\n        int n = A.length;\\n        // int[] memo = new int[n];\\n        int res = 0;\\n        for (int s = 0; s < k; s++) {\\n            List<Integer> dp = new ArrayList<>();\\n            for (int i = s; i < n; i += k){\\n                \\n                if (!bsearch(dp, A[i])) {\\n                    dp.add(A[i]);\\n                }\\n                // System.out.println(A[i] + \"-\" + i);\\n                // System.out.println(dp.toString());\\n            }\\n            \\n            // System.out.println(dp.toString());\\n            res += dp.size();\\n        }\\n        return n - res;\\n    }\\n    \\n    private boolean bsearch(List<Integer> dp, int target) {\\n        if(dp.isEmpty()) {\\n            return false;\\n        }\\n        \\n        int lo = 0, hi = dp.size() - 1;\\n        while(lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (dp.get(mid) <= target) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        \\n        if (dp.get(lo) > target){\\n            dp.set(lo, target);\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1992104,
                "title": "c-lis-with-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int upperBound(vector<int>& nums, int x) {\\n        int left = 0;\\n        int right = nums.size();\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] > x) right = mid;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n    int lis(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp;\\n        for (auto num: nums) {\\n            int index = upperBound(dp, num);\\n            if (index == dp.size()) dp.push_back(num);\\n            else dp[index] = num;\\n        }\\n        return n - dp.size();\\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n        vector<int> temp;\\n        int res = 0;\\n        for (int i = 0; i < k; i++) {\\n            for (int j = i; j < arr.size(); j += k) {\\n                temp.push_back(arr[j]);\\n            }\\n            res += lis(temp);\\n            temp.clear();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int upperBound(vector<int>& nums, int x) {\\n        int left = 0;\\n        int right = nums.size();\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] > x) right = mid;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n    int lis(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp;\\n        for (auto num: nums) {\\n            int index = upperBound(dp, num);\\n            if (index == dp.size()) dp.push_back(num);\\n            else dp[index] = num;\\n        }\\n        return n - dp.size();\\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n        vector<int> temp;\\n        int res = 0;\\n        for (int i = 0; i < k; i++) {\\n            for (int j = i; j < arr.size(); j += k) {\\n                temp.push_back(arr[j]);\\n            }\\n            res += lis(temp);\\n            temp.clear();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975236,
                "title": "c-beats-97-lis-just-ignore-k-for-a-while",
                "content": "We can skip `K` for a while, which makes this question as `Minimum operations to Make the Array Increasing`, which can be solved by finding the LIS (Longest Increasing Subsequence), using binary search, and subtracting the size of LIS from size of the array. Performing this step `K` times will give the desired result.\\n\\n```\\n/* \\n    Time: O(nlogn)\\n    Space: O(n)\\n    Tag: DP and Binary Seach (LIS)\\n    Difficulty: H\\n*/\\n\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int> &arr, int k) {\\n        int res = 0;\\n        vector<int> lis;\\n\\n        for (int i = 0; i < k; i++) {\\n            int size = 0;\\n            for (int j = i; j < arr.size(); j += k) {\\n                size++;\\n                auto it = upper_bound(lis.begin(), lis.end(), arr[j]);\\n                if (it == lis.end())\\n                    lis.push_back(arr[j]);\\n                else\\n                    *it = arr[j];\\n            }\\n            res += size - lis.size();\\n            lis.clear();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\n/* \\n    Time: O(nlogn)\\n    Space: O(n)\\n    Tag: DP and Binary Seach (LIS)\\n    Difficulty: H\\n*/\\n\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int> &arr, int k) {\\n        int res = 0;\\n        vector<int> lis;\\n\\n        for (int i = 0; i < k; i++) {\\n            int size = 0;\\n            for (int j = i; j < arr.size(); j += k) {\\n                size++;\\n                auto it = upper_bound(lis.begin(), lis.end(), arr[j]);\\n                if (it == lis.end())\\n                    lis.push_back(arr[j]);\\n                else\\n                    *it = arr[j];\\n            }\\n            res += size - lis.size();\\n            lis.clear();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944580,
                "title": "c-11-line",
                "content": "```\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int numGood = 0;\\n        for(int i = 0; i<k; i++){\\n            vector<int> v;\\n            for(int j=i;j<arr.size();j+=k){\\n                auto it = upper_bound(v.begin(), v.end(), arr[j]);\\n                if(it == v.end()) v.push_back(arr[j]);\\n                else *it = arr[j];\\n            }\\n            numGood += v.size();\\n        }\\n        return arr.size() - numGood;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int numGood = 0;\\n        for(int i = 0; i<k; i++){\\n            vector<int> v;\\n            for(int j=i;j<arr.size();j+=k){\\n                auto it = upper_bound(v.begin(), v.end(), arr[j]);\\n                if(it == v.end()) v.push_back(arr[j]);\\n                else *it = arr[j];\\n            }\\n            numGood += v.size();\\n        }\\n        return arr.size() - numGood;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1893321,
                "title": "c-lis",
                "content": "```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& nums, int k) {\\n        int res = 0;\\n        vector<int> lis(nums.size() / k + 2, INT_MAX);\\n        for (int i = 0; i < k; ++i) {\\n            std::fill(lis.begin(), lis.end(), INT_MAX);\\n            int maxLen = 1;\\n            lis[maxLen] = nums[i];\\n            for (int j = i + k; j < nums.size(); j += k) {\\n                auto it = upper_bound(lis.begin() + 1, lis.begin() + maxLen + 1, nums[j]);\\n                maxLen = max(maxLen, (int)(it - lis.begin()));\\n                *it = min(*it, nums[j]);\\n            }\\n            res += (nums.size() / k) + (i < (nums.size() % k)) - maxLen;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& nums, int k) {\\n        int res = 0;\\n        vector<int> lis(nums.size() / k + 2, INT_MAX);\\n        for (int i = 0; i < k; ++i) {\\n            std::fill(lis.begin(), lis.end(), INT_MAX);\\n            int maxLen = 1;\\n            lis[maxLen] = nums[i];\\n            for (int j = i + k; j < nums.size(); j += k) {\\n                auto it = upper_bound(lis.begin() + 1, lis.begin() + maxLen + 1, nums[j]);\\n                maxLen = max(maxLen, (int)(it - lis.begin()));\\n                *it = min(*it, nums[j]);\\n            }\\n            res += (nums.size() / k) + (i < (nums.size() % k)) - maxLen;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889726,
                "title": "golang-lis-binary-search-o-nlog-n-time-complexity",
                "content": "```\\nfunc kIncreasing(arr []int, k int) int {\\n    buckets := partition(arr, k)\\n    \\n    // T -> O(n)\\n    // S -> O(n)\\n    var numberOfOperations int\\n    for _, bucket := range buckets {\\n        numberOfOperations += longestIncreasingSequence(bucket)\\n    }\\n    \\n    return numberOfOperations\\n}\\n\\n// T -> O(n)\\n// S -> O(n)\\nfunc partition(arr []int, k int) [][]int {\\n    var buckets = make([][]int, 0, k)\\n    for i := 0; i < k; i++ {\\n        buckets = append(buckets, []int{})\\n    }\\n    \\n    for i := 0; i < len(arr); i++ {\\n        bucket := i % k\\n        buckets[bucket] = append(buckets[bucket], arr[i])\\n    }\\n    \\n    return buckets\\n}\\n\\nfunc longestIncreasingSequence(array []int) int {\\n    if len(array) == 0 {\\n        return 0\\n    }\\n    \\n    // T -> O(nlog(n)) where `n` is the length of the array.\\n    // S -> O(n) worst case the sequence could be the same size as the original array.\\n    var sequence = []int{array[0]}\\n    for i := 1; i < len(array); i++ {\\n        \\n        currentValue := array[i]\\n        \\n        if currentValue >= sequence[len(sequence)-1] {\\n            sequence = append(sequence, currentValue)\\n            continue\\n        }\\n        \\n        firstIncreasingElement := bisectLeft(sequence, currentValue)\\n        if sequence[firstIncreasingElement] == currentValue {\\n            firstIncreasingElement++\\n        }\\n        \\n        sequence[firstIncreasingElement] = currentValue\\n    }\\n    \\n    \\n    return len(array) - len(sequence)\\n}\\n\\n// T -> O(log(n))\\n// S -> O(1)\\nfunc bisectLeft(array []int, target int) int {\\n    l, r := 0, len(array)\\n    \\n    for l < r {\\n        m := (l + r) / 2\\n        \\n        switch {\\n        case target == array[m]:\\n            return m\\n        case target <= array[m]:\\n            r = m\\n        default:\\n            l = m+ 1\\n        }\\n    }\\n    \\n    return l\\n}\\n```\\n\\nHere we do the following:\\n1. Partition the array into buckets based on `k` \\n2. Perform the LIS (longest increasing subsequence) algorithm on each bucket, with a slight modification\\n3. Since the operations cannot be swaps, rather than replace an element in the array with a positive number - we recognise that to make the entire array increasing, we need to make\\n    len(array) - len(longest increasing subsequence) operations in order to make the full array increasing.",
                "solutionTags": [],
                "code": "```\\nfunc kIncreasing(arr []int, k int) int {\\n    buckets := partition(arr, k)\\n    \\n    // T -> O(n)\\n    // S -> O(n)\\n    var numberOfOperations int\\n    for _, bucket := range buckets {\\n        numberOfOperations += longestIncreasingSequence(bucket)\\n    }\\n    \\n    return numberOfOperations\\n}\\n\\n// T -> O(n)\\n// S -> O(n)\\nfunc partition(arr []int, k int) [][]int {\\n    var buckets = make([][]int, 0, k)\\n    for i := 0; i < k; i++ {\\n        buckets = append(buckets, []int{})\\n    }\\n    \\n    for i := 0; i < len(arr); i++ {\\n        bucket := i % k\\n        buckets[bucket] = append(buckets[bucket], arr[i])\\n    }\\n    \\n    return buckets\\n}\\n\\nfunc longestIncreasingSequence(array []int) int {\\n    if len(array) == 0 {\\n        return 0\\n    }\\n    \\n    // T -> O(nlog(n)) where `n` is the length of the array.\\n    // S -> O(n) worst case the sequence could be the same size as the original array.\\n    var sequence = []int{array[0]}\\n    for i := 1; i < len(array); i++ {\\n        \\n        currentValue := array[i]\\n        \\n        if currentValue >= sequence[len(sequence)-1] {\\n            sequence = append(sequence, currentValue)\\n            continue\\n        }\\n        \\n        firstIncreasingElement := bisectLeft(sequence, currentValue)\\n        if sequence[firstIncreasingElement] == currentValue {\\n            firstIncreasingElement++\\n        }\\n        \\n        sequence[firstIncreasingElement] = currentValue\\n    }\\n    \\n    \\n    return len(array) - len(sequence)\\n}\\n\\n// T -> O(log(n))\\n// S -> O(1)\\nfunc bisectLeft(array []int, target int) int {\\n    l, r := 0, len(array)\\n    \\n    for l < r {\\n        m := (l + r) / 2\\n        \\n        switch {\\n        case target == array[m]:\\n            return m\\n        case target <= array[m]:\\n            r = m\\n        default:\\n            l = m+ 1\\n        }\\n    }\\n    \\n    return l\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1872334,
                "title": "java-clean-lc-300-lis-version-with-collections-binarysearch",
                "content": "```\\nclass Solution {\\n    private int lis(List<Integer> nums) {\\n        List<Integer> sub = new ArrayList<>();\\n        sub.add(nums.get(0));\\n        \\n        for (int i = 1; i < nums.size(); i++) {\\n            int num = nums.get(i);\\n            if (num >= sub.get(sub.size() - 1)) {\\n                sub.add(num);\\n            } else {\\n                int j = Collections.binarySearch(sub, num) + 1;\\n                if (j < 0) {\\n                    j = -(j + 1) + 1;\\n                }\\n                sub.set(j, num);\\n            }\\n        }\\n        return sub.size();\\n    }\\n    \\n    public int kIncreasing(int[] arr, int k) {\\n        int total = 0;\\n        \\n        for (int i = 0; i < k; i++) {\\n            List<Integer> nums = new ArrayList<>();\\n            for (int j = i; j < arr.length; j += k) {\\n                nums.add(arr[j]);\\n            }\\n            total += nums.size() - lis(nums);\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    private int lis(List<Integer> nums) {\\n        List<Integer> sub = new ArrayList<>();\\n        sub.add(nums.get(0));\\n        \\n        for (int i = 1; i < nums.size(); i++) {\\n            int num = nums.get(i);\\n            if (num >= sub.get(sub.size() - 1)) {\\n                sub.add(num);\\n            } else {\\n                int j = Collections.binarySearch(sub, num) + 1;\\n                if (j < 0) {\\n                    j = -(j + 1) + 1;\\n                }\\n                sub.set(j, num);\\n            }\\n        }\\n        return sub.size();\\n    }\\n    \\n    public int kIncreasing(int[] arr, int k) {\\n        int total = 0;\\n        \\n        for (int i = 0; i < k; i++) {\\n            List<Integer> nums = new ArrayList<>();\\n            for (int j = i; j < arr.length; j += k) {\\n                nums.add(arr[j]);\\n            }\\n            total += nums.size() - lis(nums);\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851155,
                "title": "c-binary-search-lis",
                "content": "```\\nclass Solution {\\n    int getPos(int val, vector<int>&v) {\\n        int high = v.size()-1, low = 0; \\n        int idx{}; \\n        while (low < high) {\\n            int mid = (low + high) / 2; \\n            if (val >= v[mid]) {\\n                low = mid + 1; \\n            } else {\\n                high = mid; \\n            }\\n        }\\n        return low;\\n    }\\n    int process(vector<int>&v) {\\n        vector<int>lis; \\n        int n = 0; \\n        lis.push_back(v[0]); \\n        for (int i=1; i<v.size(); ++i) {\\n            if (v[i] >= lis[n]) {\\n                lis.push_back(v[i]); \\n                n++; \\n            } else {\\n                int idx = getPos(v[i], lis); \\n                lis[idx] = v[i]; \\n            }\\n        }\\n        return v.size() - lis.size(); \\n    }\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int ans = 0; \\n        for (int i=0; i<k; ++i) {\\n            vector<int>temp; \\n            for (int j=i; j<arr.size(); j+=k) {\\n                temp.push_back(arr[j]); \\n            }\\n            ans += process(temp); \\n        }\\n        return ans; \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int getPos(int val, vector<int>&v) {\\n        int high = v.size()-1, low = 0; \\n        int idx{}; \\n        while (low < high) {\\n            int mid = (low + high) / 2; \\n            if (val >= v[mid]) {\\n                low = mid + 1; \\n            } else {\\n                high = mid; \\n            }\\n        }\\n        return low;\\n    }\\n    int process(vector<int>&v) {\\n        vector<int>lis; \\n        int n = 0; \\n        lis.push_back(v[0]); \\n        for (int i=1; i<v.size(); ++i) {\\n            if (v[i] >= lis[n]) {\\n                lis.push_back(v[i]); \\n                n++; \\n            } else {\\n                int idx = getPos(v[i], lis); \\n                lis[idx] = v[i]; \\n            }\\n        }\\n        return v.size() - lis.size(); \\n    }\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int ans = 0; \\n        for (int i=0; i<k; ++i) {\\n            vector<int>temp; \\n            for (int j=i; j<arr.size(); j+=k) {\\n                temp.push_back(arr[j]); \\n            }\\n            ans += process(temp); \\n        }\\n        return ans; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1805898,
                "title": "python-lis-easy-to-understand-simple-explanation",
                "content": "#1: Organize the arr into K groups\\n#2: For each group, use LIS + Binary Search to find the max LIS and the min count of numbers that don\\'t belong to the LIS\\n\\n```\\nimport bisect\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        def LIS(nums):\\n            dp = []\\n\\n            for n in nums:\\n                # Get the first number in dp that is strictly larger than n\\n                index = bisect.bisect_right(dp, n)\\n                if index == len(dp):\\n                    dp += [n]\\n                else:\\n                    dp[index] = n\\n            \\n            # return # in nums that don\\'t belong to the LIS\\n            return len(nums) - len(dp)\\n                \\n                \\n        groups = [[] for _ in range(k)]\\n        \\n        for i, a in enumerate(arr):\\n            groups[i%k] += [a]\\n        \\n        cnt = 0\\n        for group in groups:\\n            cnt += LIS(group)\\n            \\n        return cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nimport bisect\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        def LIS(nums):\\n            dp = []\\n\\n            for n in nums:\\n                # Get the first number in dp that is strictly larger than n\\n                index = bisect.bisect_right(dp, n)\\n                if index == len(dp):\\n                    dp += [n]\\n                else:\\n                    dp[index] = n\\n            \\n            # return # in nums that don\\'t belong to the LIS\\n            return len(nums) - len(dp)\\n                \\n                \\n        groups = [[] for _ in range(k)]\\n        \\n        for i, a in enumerate(arr):\\n            groups[i%k] += [a]\\n        \\n        cnt = 0\\n        for group in groups:\\n            cnt += LIS(group)\\n            \\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1789265,
                "title": "c-simple-solution-use-upper-bound",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    \\n    int helper(vector<int>& total){\\n        vector<int> lis;\\n        \\n        for(int i = 0; i< total.size(); i++){\\n            if(lis.size()==0 || lis.back() <= total[i]){\\n                lis.push_back(total[i]);\\n            }else{\\n                *upper_bound(lis.begin(), lis.end(), total[i])  = total[i];\\n            }\\n        }\\n           \\n        return lis.size();\\n    }\\n    \\n    \\n    \\n    int kIncreasing(vector<int>& arr, int k) {\\n        int ops = 0;\\n        \\n        for(int i = 0; i< k; i++){\\n            vector<int> total;\\n            for(int j = i; j<arr.size(); j+=k){ //arr[i-k] \\u2264 arr[i]\\n                total.push_back(arr[j]);\\n            }\\n            ops += total.size() - helper(total); //all - non-change: ops\\n        }\\n        \\n        return ops;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    int helper(vector<int>& total){\\n        vector<int> lis;\\n        \\n        for(int i = 0; i< total.size(); i++){\\n            if(lis.size()==0 || lis.back() <= total[i]){\\n                lis.push_back(total[i]);\\n            }else{\\n                *upper_bound(lis.begin(), lis.end(), total[i])  = total[i];\\n            }\\n        }\\n           \\n        return lis.size();\\n    }\\n    \\n    \\n    \\n    int kIncreasing(vector<int>& arr, int k) {\\n        int ops = 0;\\n        \\n        for(int i = 0; i< k; i++){\\n            vector<int> total;\\n            for(int j = i; j<arr.size(); j+=k){ //arr[i-k] \\u2264 arr[i]\\n                total.push_back(arr[j]);\\n            }\\n            ops += total.size() - helper(total); //all - non-change: ops\\n        }\\n        \\n        return ops;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1773543,
                "title": "java-lis-easy-to-understand",
                "content": "class Solution {\\n\\n    public int  LIS(List <Integer> ar){            //0(nlogn)\\n        int[]bs=new int[ar.size()+1];\\n        Arrays.fill(bs,Integer.MAX_VALUE);\\n        bs[0]=Integer.MIN_VALUE;\\n        \\n        int max=1;\\n        for(int val : ar){\\n            int l=0;\\n            int h=ar.size();\\n            \\n            while(l<=h){\\n                int mid=(l+h)/2;\\n                \\n                if(bs[mid] <= val)\\n                    l=mid+1;\\n                else\\n                    h=mid-1;\\n            }\\n            bs[l]=val;\\n            max=Math.max(max,l);\\n        }\\n        \\n        return ar.size()-max;\\n        \\n    }\\n    public int kIncreasing(int[] arr, int k) {\\n        /*\\n          0 1 2 3 4 5 6 7 8 9\\n          k=4\\n          0 -> 4 -> 8\\n          1 -> 5 -> 9\\n          2 -> 6 \\n          \\n          0 1 2 3 4 \\n          0->1->2->3->4 =4 Apply LIS 0(nlogn) to find the longest increasing sequence or min no of elments that need to be changed to have Increasing sequence \\n          \\n          \\n          \\n          0 1 2 3 4 5 \\n          4 1 5 2 6 2\\n          \\n          0->3   1\\n          1->4 \\n          2->5   1=2\\n          \\n        */\\n        List<List<Integer>>res=new ArrayList<>();\\n        \\n        for(int i=0;i<k;i++){\\n            res.add(new ArrayList<>());\\n        }\\n        \\n        for(int i=0;i<arr.length;i++){\\n            if(i < k)\\n              res.get(i).add(arr[i]);\\n            else\\n             res.get(i%k).add(arr[i]);\\n        }\\n        int cnt=0;\\n        \\n        for(List<Integer>l:res){\\n            cnt +=LIS(l);\\n        }\\n        \\n        return cnt;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int  LIS(List <Integer> ar){            //0(nlogn)\\n        int[]bs=new int[ar.size()+1];\\n        Arrays.fill(bs,Integer.MAX_VALUE);\\n        bs[0]=Integer.MIN_VALUE;\\n        \\n        int max=1;\\n        for(int val : ar){\\n            int l=0;\\n            int h=ar.size();\\n            \\n            while(l<=h){\\n                int mid=(l+h)/2;\\n                \\n                if(bs[mid] <= val)\\n                    l=mid+1;\\n                else\\n                    h=mid-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1767970,
                "title": "binary-search-lis",
                "content": "Do note that, this solution is working only because we are to consider a non-decreasing. If it were strictly increasing, this wont work\\n\\n```\\nclass Solution {\\npublic:\\n    int remLis(vector<int>& arr, int ind, int sz, int k){\\n        int len = 1;\\n        vector<int> LIS;\\n        LIS.push_back(arr[ind]);\\n        \\n        for(int i = ind + k; i < sz; i+= k){\\n            len++;\\n            int start = 0;\\n            int end = LIS.size()-1;\\n            \\n            while(start <= end){\\n                int mid = start + (end - start)/2;\\n                if(LIS[mid] <= arr[i]){\\n                    start = mid + 1;\\n                } else {\\n                    end = mid - 1;\\n                }\\n            }\\n            if(end == LIS.size()-1){\\n                LIS.push_back(arr[i]);\\n            } else {\\n                LIS[end+1] = arr[i];\\n            }    \\n        }\\n        return len - LIS.size();\\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int kInc = 0;\\n        int sz = arr.size();\\n        for(int i = 0; i < k; i++){\\n            kInc += remLis(arr,i,sz,k);\\n        }\\n        return kInc;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int remLis(vector<int>& arr, int ind, int sz, int k){\\n        int len = 1;\\n        vector<int> LIS;\\n        LIS.push_back(arr[ind]);\\n        \\n        for(int i = ind + k; i < sz; i+= k){\\n            len++;\\n            int start = 0;\\n            int end = LIS.size()-1;\\n            \\n            while(start <= end){\\n                int mid = start + (end - start)/2;\\n                if(LIS[mid] <= arr[i]){\\n                    start = mid + 1;\\n                } else {\\n                    end = mid - 1;\\n                }\\n            }\\n            if(end == LIS.size()-1){\\n                LIS.push_back(arr[i]);\\n            } else {\\n                LIS[end+1] = arr[i];\\n            }    \\n        }\\n        return len - LIS.size();\\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int kInc = 0;\\n        int sz = arr.size();\\n        for(int i = 0; i < k; i++){\\n            kInc += remLis(arr,i,sz,k);\\n        }\\n        return kInc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760142,
                "title": "easy-observation-of-lis",
                "content": "```\\nclass Solution {\\npublic:\\n    int lis(vector<int> &nums)\\n    {\\n        multiset<int> mlt;\\n        for(auto i:nums)\\n        {\\n            auto it = mlt.upper_bound(i);\\n            if(it==mlt.end())\\n            {\\n                mlt.insert(i);\\n            }\\n            else{\\n                mlt.erase(it);\\n                mlt.insert(i);\\n            }\\n        }\\n        int n = nums.size();\\n        return n-mlt.size();\\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        int ans=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> v;\\n            v.push_back(arr[i]);\\n            for(int j=i+k;j<n;j+=k)\\n                v.push_back(arr[j]);\\n            ans+=lis(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lis(vector<int> &nums)\\n    {\\n        multiset<int> mlt;\\n        for(auto i:nums)\\n        {\\n            auto it = mlt.upper_bound(i);\\n            if(it==mlt.end())\\n            {\\n                mlt.insert(i);\\n            }\\n            else{\\n                mlt.erase(it);\\n                mlt.insert(i);\\n            }\\n        }\\n        int n = nums.size();\\n        return n-mlt.size();\\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        int ans=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> v;\\n            v.push_back(arr[i]);\\n            for(int j=i+k;j<n;j+=k)\\n                v.push_back(arr[j]);\\n            ans+=lis(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721319,
                "title": "lis-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int lengthOfLIS( vector<int>& nums ) {\\n\\tvector<int> tail;\\n\\tfor( auto num : nums ) {\\n\\t\\tauto it = lower_bound( tail.begin(), tail.end(), num+1 );\\n\\t\\tif( it == tail.end() )\\n\\t\\t\\ttail.push_back( num );\\n\\t\\telse\\n\\t\\t\\t*it = num;\\n\\t}\\n\\treturn tail.size();\\n}\\n    \\n    int kIncreasing(vector<int>& arr, int k) {\\n           int ans=0;\\n           for(int i=0;i<k;i++){\\n               vector<int> temp;\\n               for(int j=i;j<arr.size();j+=k)temp.push_back(arr[j]);\\n               ans+=(temp.size()-lengthOfLIS(temp));\\n           }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int lengthOfLIS( vector<int>& nums ) {\\n\\tvector<int> tail;\\n\\tfor( auto num : nums ) {\\n\\t\\tauto it = lower_bound( tail.begin(), tail.end(), num+1 );\\n\\t\\tif( it == tail.end() )\\n\\t\\t\\ttail.push_back( num );\\n\\t\\telse\\n\\t\\t\\t*it = num;\\n\\t}\\n\\treturn tail.size();\\n}\\n    \\n    int kIncreasing(vector<int>& arr, int k) {\\n           int ans=0;\\n           for(int i=0;i<k;i++){\\n               vector<int> temp;\\n               for(int j=i;j<arr.size();j+=k)temp.push_back(arr[j]);\\n               ans+=(temp.size()-lengthOfLIS(temp));\\n           }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1689389,
                "title": "test",
                "content": "test test test\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1686439,
                "title": "easiest-approach-lis-solution",
                "content": "# LIS In Disguise\\nInspired from : @votrubac :[Link](https://leetcode.com/problems/minimum-operations-to-make-the-array-k-increasing/discuss/1634969/LIS-in-Disguise)\\n **We have K indipendent subararrays.**\\n* For Each subaarray we find longest non-decreasing subsequence. \\n* We keep the longest non-decreasing subarray as-it-is, and change the rest.\\n\\n```\\n\\tint LIS(vector<int> &arr){\\n        vector<int> lis;\\n        for(int i=0;i<arr.size();i++){\\n            if(lis.empty() || arr[i]>=lis.back()){\\n                lis.push_back(arr[i]);\\n            }\\n            \\n            else{\\n                int ind= upper_bound(lis.begin(),lis.end(),arr[i])-lis.begin();\\n                lis[ind]=arr[i];\\n            }\\n        }\\n        return lis.size();\\n    }\\n    \\n    int kIncreasing(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int count=0;\\n        \\n        for(int i=0;i<k;i++){\\n            vector<int> subarr;\\n            for(int j=i;j<n;j+=k){                \\n                subarr.push_back(nums[j]);\\n            }\\n            \\n            int longestNonDecreasingLen=LIS(subarr);\\n            \\n            //keep longest non-decreasing sequence as-it-is and change the rest\\n            count+= subarr.size()-longestNonDecreasingLen;\\n        }\\n        return count;\\n    }\\n```\\n\\nUpvote if you like it!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tint LIS(vector<int> &arr){\\n        vector<int> lis;\\n        for(int i=0;i<arr.size();i++){\\n            if(lis.empty() || arr[i]>=lis.back()){\\n                lis.push_back(arr[i]);\\n            }\\n            \\n            else{\\n                int ind= upper_bound(lis.begin(),lis.end(),arr[i])-lis.begin();\\n                lis[ind]=arr[i];\\n            }\\n        }\\n        return lis.size();\\n    }\\n    \\n    int kIncreasing(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int count=0;\\n        \\n        for(int i=0;i<k;i++){\\n            vector<int> subarr;\\n            for(int j=i;j<n;j+=k){                \\n                subarr.push_back(nums[j]);\\n            }\\n            \\n            int longestNonDecreasingLen=LIS(subarr);\\n            \\n            //keep longest non-decreasing sequence as-it-is and change the rest\\n            count+= subarr.size()-longestNonDecreasingLen;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1681573,
                "title": "c-solution-using-longest-non-decreasing-sequence-with-o-n-log-n-time-and-o-n-space",
                "content": "See https://leetcode.com/problems/longest-increasing-subsequence/discuss/1326308 for various ways to solve Longest Increasing Sequence (which you can basically just reuse with minor modifications for this problem).\\n```\\nstatic int bFind(int* nums, int nSize, int value)\\n{\\n    int start = 0; \\n    int end = nSize - 1;\\n    \\n    while(start <= end) {\\n        const int mid = (start + end)/2;\\n        \\n        if (nums[mid] > value) {\\n            end = mid - 1;\\n        } else {\\n            start = mid + 1;\\n        }\\n    }\\n    \\n    return start;\\n}\\n\\nstatic int lengthOfLIS(int* nums, int numsSize, int start, int multiple){\\n    int length = 0;\\n    int dp[numsSize];\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        const int idx = start + i*multiple;\\n        \\n        if (length == 0 || nums[idx] >= dp[length - 1]) {\\n            dp[length++] = nums[idx];\\n        } else {\\n            const int replaceIdx = bFind(dp, length, nums[idx]);\\n            dp[replaceIdx] = nums[idx];\\n        }\\n    }\\n    \\n    return length;\\n}\\n\\nint kIncreasing(int* arr, int arrSize, int k){\\n    const int dpSize = (arrSize + k - 1)/k;\\n    int count = 0;\\n\\n    for (int i = 0; i < k; i++) {\\n        int size = dpSize;\\n        if ((arrSize % k) != 0 && i >= (arrSize % k)) {\\n            size--;\\n        }\\n        count += lengthOfLIS(arr, size, i, k);\\n    }\\n    \\n    return arrSize - count;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nstatic int bFind(int* nums, int nSize, int value)\\n{\\n    int start = 0; \\n    int end = nSize - 1;\\n    \\n    while(start <= end) {\\n        const int mid = (start + end)/2;\\n        \\n        if (nums[mid] > value) {\\n            end = mid - 1;\\n        } else {\\n            start = mid + 1;\\n        }\\n    }\\n    \\n    return start;\\n}\\n\\nstatic int lengthOfLIS(int* nums, int numsSize, int start, int multiple){\\n    int length = 0;\\n    int dp[numsSize];\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        const int idx = start + i*multiple;\\n        \\n        if (length == 0 || nums[idx] >= dp[length - 1]) {\\n            dp[length++] = nums[idx];\\n        } else {\\n            const int replaceIdx = bFind(dp, length, nums[idx]);\\n            dp[replaceIdx] = nums[idx];\\n        }\\n    }\\n    \\n    return length;\\n}\\n\\nint kIncreasing(int* arr, int arrSize, int k){\\n    const int dpSize = (arrSize + k - 1)/k;\\n    int count = 0;\\n\\n    for (int i = 0; i < k; i++) {\\n        int size = dpSize;\\n        if ((arrSize % k) != 0 && i >= (arrSize % k)) {\\n            size--;\\n        }\\n        count += lengthOfLIS(arr, size, i, k);\\n    }\\n    \\n    return arrSize - count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1674451,
                "title": "lnds-c-easy-code",
                "content": "```\\nclass Solution {\\nprivate:\\n    int lnds(vector<int> &arr) {\\n        vector<int> temp; \\n        int n = arr.size(); \\n        for(int i = 0;i<n;i++) {\\n            if(temp.size() == 0 || temp.back() <= arr[i]) {\\n                temp.push_back(arr[i]); \\n            }\\n            else {\\n                int ind = upper_bound(temp.begin(), temp.end(), arr[i]) - temp.begin(); \\n                temp[ind] = arr[i]; \\n            }\\n        } \\n        return temp.size(); \\n    }\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int n = arr.size(); \\n        int minchanges = 0;\\n        // \\n        for(int i = 0;i<k;i++) {\\n            vector<int> sbarr; \\n            for(int j = i;j<n;j+=k) {\\n                sbarr.push_back(arr[j]); \\n            }\\n            minchanges += sbarr.size() - lnds(sbarr); \\n        }\\n        return minchanges; \\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int lnds(vector<int> &arr) {\\n        vector<int> temp; \\n        int n = arr.size(); \\n        for(int i = 0;i<n;i++) {\\n            if(temp.size() == 0 || temp.back() <= arr[i]) {\\n                temp.push_back(arr[i]); \\n            }\\n            else {\\n                int ind = upper_bound(temp.begin(), temp.end(), arr[i]) - temp.begin(); \\n                temp[ind] = arr[i]; \\n            }\\n        } \\n        return temp.size(); \\n    }\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int n = arr.size(); \\n        int minchanges = 0;\\n        // \\n        for(int i = 0;i<k;i++) {\\n            vector<int> sbarr; \\n            for(int j = i;j<n;j+=k) {\\n                sbarr.push_back(arr[j]); \\n            }\\n            minchanges += sbarr.size() - lnds(sbarr); \\n        }\\n        return minchanges; \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1669623,
                "title": "c-lis-with-explanations",
                "content": "This is mutate from LC 300. The diff is LC300 use lower_bound. But this questions use upper_bound.\\n\\nNote this method actually has a theoretical flaw that c# `Array.BinarySearch` will return random index when duplicate value exist. \\ni.e: [1, 1, 1, 2] and find 1, result could be 0, 1 ,2.\\nHowever this didn\\'t effect our result somehow.\\nI was trying to manipulate a testcase to uncover this issue but gave up in the end.\\nThis is the code that pass all current test cases.\\n```\\npublic class Solution {\\n    public int KIncreasing(int[] arr, int k) {\\n        var n = arr.Length;\\n        var seqs = new List<List<int>>();\\n        // Split arr into distinct k arrays in k distance\\n        for (int i = 0; i < n; i++){\\n            var idx = i % k;\\n            if (idx >= seqs.Count)\\n                seqs.Add(new List<int>());\\n            seqs[idx].Add(arr[i]);\\n        }\\n\\n        return seqs.Sum(s => s.Count - Lis(s.ToArray()));\\n    }\\n    \\n    // Modified LIS: allow duplicate values\\n    // insert 2 into [1, 2], result: [1, 2, 2]\\n    private int Lis(int[] s)\\n    {\\n        var arr = new int[s.Length];\\n        var count = 0;\\n        foreach (var c in s)\\n        {\\n            var idx = Array.BinarySearch(arr, 0, count, c);\\n            if (idx < 0)\\n                idx = ~idx;\\n            if (arr[idx] == c)\\n                idx = Array.BinarySearch(arr, 0, count, c + 1);\\n            if (idx < 0)\\n                idx = ~idx;\\n            arr[idx] = c;\\n            if (idx == count)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\nA better version would be hand write the binary search to find the abosute upperbound\\n```\\npublic class Solution {\\n    public int KIncreasing(int[] arr, int k) {\\n        var n = arr.Length;\\n        var seqs = new List<List<int>>();\\n        for (int i = 0; i < n; i++){\\n            var idx = i % k;\\n            if (idx >= seqs.Count)\\n                seqs.Add(new List<int>());\\n            seqs[idx].Add(arr[i]);\\n        }\\n\\n        return seqs.Sum(s => s.Count - Lis(s.ToArray()));\\n    }\\n    \\n    private int Lis(int[] s)\\n    {\\n        var arr = new int[s.Length];\\n        var count = 0;\\n        foreach (var c in s)\\n        {\\n            var idx = UpperBound(arr, 0, count, c);\\n            arr[idx] = c;\\n            if (idx == count)\\n                count++;\\n        }\\n        return count;\\n    }\\n    \\n    public static int UpperBound(int[] arr, int start, int length, int k)\\n    {\\n        if (length == 0)\\n            return start;\\n        var lo = start;\\n        var hi = start + length - 1;\\n        while (lo < hi)\\n        {\\n            var mid = lo + (hi - lo) / 2;\\n            if (arr[mid] <= k)\\n                lo = mid + 1;\\n            else\\n                hi = mid;\\n        }\\n\\n        return arr[lo] <= k ? lo + 1 : lo;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int KIncreasing(int[] arr, int k) {\\n        var n = arr.Length;\\n        var seqs = new List<List<int>>();\\n        // Split arr into distinct k arrays in k distance\\n        for (int i = 0; i < n; i++){\\n            var idx = i % k;\\n            if (idx >= seqs.Count)\\n                seqs.Add(new List<int>());\\n            seqs[idx].Add(arr[i]);\\n        }\\n\\n        return seqs.Sum(s => s.Count - Lis(s.ToArray()));\\n    }\\n    \\n    // Modified LIS: allow duplicate values\\n    // insert 2 into [1, 2], result: [1, 2, 2]\\n    private int Lis(int[] s)\\n    {\\n        var arr = new int[s.Length];\\n        var count = 0;\\n        foreach (var c in s)\\n        {\\n            var idx = Array.BinarySearch(arr, 0, count, c);\\n            if (idx < 0)\\n                idx = ~idx;\\n            if (arr[idx] == c)\\n                idx = Array.BinarySearch(arr, 0, count, c + 1);\\n            if (idx < 0)\\n                idx = ~idx;\\n            arr[idx] = c;\\n            if (idx == count)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int KIncreasing(int[] arr, int k) {\\n        var n = arr.Length;\\n        var seqs = new List<List<int>>();\\n        for (int i = 0; i < n; i++){\\n            var idx = i % k;\\n            if (idx >= seqs.Count)\\n                seqs.Add(new List<int>());\\n            seqs[idx].Add(arr[i]);\\n        }\\n\\n        return seqs.Sum(s => s.Count - Lis(s.ToArray()));\\n    }\\n    \\n    private int Lis(int[] s)\\n    {\\n        var arr = new int[s.Length];\\n        var count = 0;\\n        foreach (var c in s)\\n        {\\n            var idx = UpperBound(arr, 0, count, c);\\n            arr[idx] = c;\\n            if (idx == count)\\n                count++;\\n        }\\n        return count;\\n    }\\n    \\n    public static int UpperBound(int[] arr, int start, int length, int k)\\n    {\\n        if (length == 0)\\n            return start;\\n        var lo = start;\\n        var hi = start + length - 1;\\n        while (lo < hi)\\n        {\\n            var mid = lo + (hi - lo) / 2;\\n            if (arr[mid] <= k)\\n                lo = mid + 1;\\n            else\\n                hi = mid;\\n        }\\n\\n        return arr[lo] <= k ? lo + 1 : lo;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658311,
                "title": "non-descending-sub-array-and-custom-binary-search",
                "content": "Explained here: https://bit.ly/leetcode2111\\n\\nCode\\n```\\nclass Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        int total = 0;\\n        \\n        for (int i = 0; i < k; i++) {\\n            List<Integer> ndsa = new ArrayList<>();\\n            for (int j = i; j < arr.length; j += k) {\\n                if (ndsa.isEmpty() || ndsa.get(ndsa.size() - 1) <= arr[j]) {\\n                    ndsa.add(arr[j]);\\n                } else {\\n                    int index = findIndexForValue(ndsa, arr[j]);\\n                    ndsa.set(index, arr[j]);\\n                }\\n            }\\n            total += ndsa.size();\\n        }\\n        return arr.length - total;   \\n    }\\n    \\n    private int findIndexForValue(List<Integer> list, int value) {\\n        int low = 0, high = list.size() - 1;\\n        while (low < high) {\\n            int mid = low + (high - low) / 2;\\n            if (value >= list.get(mid)) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        int total = 0;\\n        \\n        for (int i = 0; i < k; i++) {\\n            List<Integer> ndsa = new ArrayList<>();\\n            for (int j = i; j < arr.length; j += k) {\\n                if (ndsa.isEmpty() || ndsa.get(ndsa.size() - 1) <= arr[j]) {\\n                    ndsa.add(arr[j]);\\n                } else {\\n                    int index = findIndexForValue(ndsa, arr[j]);\\n                    ndsa.set(index, arr[j]);\\n                }\\n            }\\n            total += ndsa.size();\\n        }\\n        return arr.length - total;   \\n    }\\n    \\n    private int findIndexForValue(List<Integer> list, int value) {\\n        int low = 0, high = list.size() - 1;\\n        while (low < high) {\\n            int mid = low + (high - low) / 2;\\n            if (value >= list.get(mid)) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656840,
                "title": "c-lis",
                "content": "```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int cnt=0;\\n        vector<vector<int>>v(k);\\n        for(int i=0;i<k;i++)\\n        {\\n            v[i%k].push_back(arr[i]);\\n         }\\n        for(int i=k;i<n;i++)\\n        {\\n            if(arr[i]<v[i%k].back())\\n            {\\n                auto j=upper_bound(v[i%k].begin(),v[i%k].end(),arr[i])-v[i%k].begin();\\n                v[i%k][j]=arr[i];\\n            }\\n            else\\n            v[i%k].push_back(arr[i]);\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            int m=(n-i+k-1)/k;\\n            cnt+=(m-v[i%k].size());\\n            \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int cnt=0;\\n        vector<vector<int>>v(k);\\n        for(int i=0;i<k;i++)\\n        {\\n            v[i%k].push_back(arr[i]);\\n         }\\n        for(int i=k;i<n;i++)\\n        {\\n            if(arr[i]<v[i%k].back())\\n            {\\n                auto j=upper_bound(v[i%k].begin(),v[i%k].end(),arr[i])-v[i%k].begin();\\n                v[i%k][j]=arr[i];\\n            }\\n            else\\n            v[i%k].push_back(arr[i]);\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            int m=(n-i+k-1)/k;\\n            cnt+=(m-v[i%k].size());\\n            \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1653945,
                "title": "c-lis-o-n-log-n-k-solution-beats-99-36",
                "content": "1. Split the array in to k subsequence starting indexed from \\\\[start, start+k, start+2k...\\\\], where start = 0 to k-1\\n2. Find the longest increasing subsequence(LIS) of the above subsequences, and the number of element needed to be modified is the length of the subsequence - length of LIS.\\n\\nTime complexity: `O(K* N/K *log(N/K))`  since we have K subsequence to check, and LIS takes `O(N/K *log(N/K))`\\nSpace complexity: `O(N/K)` since LIS is at most of length N/K\\n```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int res = 0;\\n        for (int i = 0; i < k; ++i) {\\n            res += modify(arr, i, k);\\n        }\\n        return res;\\n    }\\n    \\n    // number of element need to be modified for subsequence\\n    // arr[start], arr[start+k], arr[start+2k],....\\n    int modify(vector<int>& arr, int start, int k) {\\n        int cnt = 0;\\n        LIS.clear();\\n        while (start < arr.size()) {\\n            auto it = upper_bound(LIS.begin(), LIS.end(), arr[start]);\\n            if (it == LIS.end()) {\\n                LIS.push_back(arr[start]);\\n            } else {\\n                *it = arr[start];\\n            }\\n            ++cnt;\\n            start += k;\\n        }\\n        \\n        return cnt - LIS.size();\\n    }\\nprivate:\\n    vector<int> LIS;\\n};\\n```\\n\\nMemory beats 99.36 % (89.5MB)\\nRuntime beats 99.43% (162ms)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int res = 0;\\n        for (int i = 0; i < k; ++i) {\\n            res += modify(arr, i, k);\\n        }\\n        return res;\\n    }\\n    \\n    // number of element need to be modified for subsequence\\n    // arr[start], arr[start+k], arr[start+2k],....\\n    int modify(vector<int>& arr, int start, int k) {\\n        int cnt = 0;\\n        LIS.clear();\\n        while (start < arr.size()) {\\n            auto it = upper_bound(LIS.begin(), LIS.end(), arr[start]);\\n            if (it == LIS.end()) {\\n                LIS.push_back(arr[start]);\\n            } else {\\n                *it = arr[start];\\n            }\\n            ++cnt;\\n            start += k;\\n        }\\n        \\n        return cnt - LIS.size();\\n    }\\nprivate:\\n    vector<int> LIS;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652810,
                "title": "python-lis-longest-non-decreasing-bisect",
                "content": "```\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        arrays=[]\\n        n=len(arr)\\n        for i in range(k):\\n            temp=[]\\n            for j in range(i,n,k):\\n                temp.append(arr[j])\\n            arrays.append(list(temp))\\n        def LIS(nums):\\n            dp=[]\\n            for i,num in enumerate(nums):\\n                idx=bisect.bisect_right(dp,num)\\n                if idx==len(dp): dp.append(num)\\n                else: dp[idx]=num\\n            return len(dp)\\n        ans=0\\n        print(arrays)\\n        for a in arrays:\\n            ans+=len(a)-LIS(a)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        arrays=[]\\n        n=len(arr)\\n        for i in range(k):\\n            temp=[]\\n            for j in range(i,n,k):\\n                temp.append(arr[j])\\n            arrays.append(list(temp))\\n        def LIS(nums):\\n            dp=[]\\n            for i,num in enumerate(nums):\\n                idx=bisect.bisect_right(dp,num)\\n                if idx==len(dp): dp.append(num)\\n                else: dp[idx]=num\\n            return len(dp)\\n        ans=0\\n        print(arrays)\\n        for a in arrays:\\n            ans+=len(a)-LIS(a)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650773,
                "title": "c-lis-o-nlogn-using-binarysearch",
                "content": "```\\nclass Solution {\\npublic:\\n    int computeLis(vector<int>& nums){\\n        int i, j;\\n        int len = nums.size();\\n        \\n        vector<int> lis;\\n        lis.push_back(nums[0]);\\n        for(i = 1; i < len; i++){\\n            auto it = upper_bound(lis.begin(), lis.end(), nums[i]);\\n            if(it == lis.end()){\\n                lis.push_back(nums[i]);\\n            }\\n            else{\\n                j = it - lis.begin();\\n                lis[j] = nums[i];\\n            }\\n        }\\n        return lis.size();\\n    }\\n    \\n    int kIncreasing(vector<int>& arr, int k) {\\n        int i, j, l;\\n        int len = arr.size();\\n        \\n        int ans = 0;\\n        vector<int> nums;\\n        for(i = 0; i < k; i++){\\n            nums.clear();\\n            for(j = i; j < len; j += k){\\n                nums.push_back(arr[j]);\\n            }\\n            l = computeLis(nums);\\n            ans += nums.size() - l;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int computeLis(vector<int>& nums){\\n        int i, j;\\n        int len = nums.size();\\n        \\n        vector<int> lis;\\n        lis.push_back(nums[0]);\\n        for(i = 1; i < len; i++){\\n            auto it = upper_bound(lis.begin(), lis.end(), nums[i]);\\n            if(it == lis.end()){\\n                lis.push_back(nums[i]);\\n            }\\n            else{\\n                j = it - lis.begin();\\n                lis[j] = nums[i];\\n            }\\n        }\\n        return lis.size();\\n    }\\n    \\n    int kIncreasing(vector<int>& arr, int k) {\\n        int i, j, l;\\n        int len = arr.size();\\n        \\n        int ans = 0;\\n        vector<int> nums;\\n        for(i = 0; i < k; i++){\\n            nums.clear();\\n            for(j = i; j < len; j += k){\\n                nums.push_back(arr[j]);\\n            }\\n            l = computeLis(nums);\\n            ans += nums.size() - l;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646568,
                "title": "c-lis-and-binary-search",
                "content": "```\\nclass Solution\\n{\\n  public:\\n    int kIncreasing(vector<int> &arr, int k)\\n    {\\n        int n = arr.size(), ans = 0;\\n        \\n        // function to find the upperbound\\n        auto upper=[](vector<int> & a, int val)\\n        {\\n            int l = 0, r = size(a);\\n            while (l < r)\\n            {\\n                int mid = (l + r) / 2;\\n                if (a[mid] <= val)\\n                    l = mid + 1;\\n                else\\n                    r = mid;\\n            }\\n            return l;\\n        };\\n        for (int i = 0; i < k; i++)\\n        {\\n            vector<int> t;\\n            for (int j = i; j < n; j += k)\\n                if (t.size() == 0 || arr[j] >= t.back())\\n                    t.push_back(arr[j]);    //inserting into temperory array\\n                else\\n                    t[upper(t, arr[j])] = arr[j]; //finding the upperbound\\n            ans += t.size();\\n        }\\n        return n - ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution\\n{\\n  public:\\n    int kIncreasing(vector<int> &arr, int k)\\n    {\\n        int n = arr.size(), ans = 0;\\n        \\n        // function to find the upperbound\\n        auto upper=[](vector<int> & a, int val)\\n        {\\n            int l = 0, r = size(a);\\n            while (l < r)\\n            {\\n                int mid = (l + r) / 2;\\n                if (a[mid] <= val)\\n                    l = mid + 1;\\n                else\\n                    r = mid;\\n            }\\n            return l;\\n        };\\n        for (int i = 0; i < k; i++)\\n        {\\n            vector<int> t;\\n            for (int j = i; j < n; j += k)\\n                if (t.size() == 0 || arr[j] >= t.back())\\n                    t.push_back(arr[j]);    //inserting into temperory array\\n                else\\n                    t[upper(t, arr[j])] = arr[j]; //finding the upperbound\\n            ans += t.size();\\n        }\\n        return n - ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646130,
                "title": "kotlin-clean-and-readable-solution",
                "content": "```\\n\\nfun kIncreasing(arr: IntArray, k: Int): Int {\\n    var startIndex = 0\\n    var ans = 0\\n    while (startIndex < k) { // O(k)\\n        val array = ArrayList<Int>()\\n        for (index in startIndex until arr.size step k) {\\n            array.add(arr[index])\\n        }\\n        val lisLength = lis(array)\\n        ans += (array.size - lisLength)\\n        ++startIndex\\n    }\\n    return ans\\n}\\n\\n// Below function takes an array and returns longest increasing subsequence length\\nfun lis(array: ArrayList<Int>): Int {// O(nlogn)\\n    if (array.size == 0) {\\n        return 0\\n    }\\n    val lisArray = Array<Int>(array.size + 1) { Int.MAX_VALUE }\\n    lisArray[0] = Int.MIN_VALUE\\n    var longestLength = 0\\n\\n    for (num in array) {\\n        var index = lisArray.binarySearch(num)\\n        // if index>=0 then num is at index ; in case of duplicates any index will be returned.\\n        // if index<0 then num is not present in that array; the index abs value is the upperbound. \\n        if (index < 0) {\\n            index *= -1\\n            index -= 1\\n        } else {\\n            while (lisArray[index] == num) {\\n                ++index\\n            }\\n        }\\n        lisArray[index] = num\\n        longestLength = kotlin.math.max(longestLength, index)\\n    }\\n    return longestLength\\n}\\n\\n```\\n\\nTime Complexity: O(k) * (O(n) + O(n * log n))\\nSpace Complexity: O(n)\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n\\nfun kIncreasing(arr: IntArray, k: Int): Int {\\n    var startIndex = 0\\n    var ans = 0\\n    while (startIndex < k) { // O(k)\\n        val array = ArrayList<Int>()\\n        for (index in startIndex until arr.size step k) {\\n            array.add(arr[index])\\n        }\\n        val lisLength = lis(array)\\n        ans += (array.size - lisLength)\\n        ++startIndex\\n    }\\n    return ans\\n}\\n\\n// Below function takes an array and returns longest increasing subsequence length\\nfun lis(array: ArrayList<Int>): Int {// O(nlogn)\\n    if (array.size == 0) {\\n        return 0\\n    }\\n    val lisArray = Array<Int>(array.size + 1) { Int.MAX_VALUE }\\n    lisArray[0] = Int.MIN_VALUE\\n    var longestLength = 0\\n\\n    for (num in array) {\\n        var index = lisArray.binarySearch(num)\\n        // if index>=0 then num is at index ; in case of duplicates any index will be returned.\\n        // if index<0 then num is not present in that array; the index abs value is the upperbound. \\n        if (index < 0) {\\n            index *= -1\\n            index -= 1\\n        } else {\\n            while (lisArray[index] == num) {\\n                ++index\\n            }\\n        }\\n        lisArray[index] = num\\n        longestLength = kotlin.math.max(longestLength, index)\\n    }\\n    return longestLength\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1644991,
                "title": "c-longest-increasing-subsequence-20-lines-clear-explaination",
                "content": "1. Collect elements in pos i%k=0 , in to vector v\\n2. Find the longest non-decreasing subsequence x, return size of vector( v)- x, which is the number of elements to change value so that the vector v is non-descreasing.\\n3.  Repeat step 1,2, for element  i%k=0, 1,..., k-1\\n```\\nclass Solution {\\npublic:\\n    int lis(vector<int>& v){\\n        multiset<int> x= {v[0]};\\n        for(int i=1;i<v.size();i++){\\n            int largest= *(--x.end());\\n            if(v[i]>=largest) x.insert(v[i]);\\n            else{ auto tmp= x.upper_bound(v[i]);\\n                  x.erase(tmp); x.insert(v[i]);\\n            }\\n        }\\n        return v.size()-x.size();\\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int ans=0;\\n        for(int i=0;i<k;i++){\\n            vector<int> sub;\\n            for(int j=i;j<arr.size();j+=k){ sub.push_back(arr[j]);}\\n            ans+= lis(sub);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lis(vector<int>& v){\\n        multiset<int> x= {v[0]};\\n        for(int i=1;i<v.size();i++){\\n            int largest= *(--x.end());\\n            if(v[i]>=largest) x.insert(v[i]);\\n            else{ auto tmp= x.upper_bound(v[i]);\\n                  x.erase(tmp); x.insert(v[i]);\\n            }\\n        }\\n        return v.size()-x.size();\\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int ans=0;\\n        for(int i=0;i<k;i++){\\n            vector<int> sub;\\n            for(int j=i;j<arr.size();j+=k){ sub.push_back(arr[j]);}\\n            ans+= lis(sub);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642699,
                "title": "c-solution-using-lis",
                "content": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    int get(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> put(n + 1, INF);\\n        put[0] = -INF;\\n        int ans = 1;\\n        for(int i = 0; i < n; i++) {\\n            int pos = upper_bound(put.begin(), put.end(), arr[i]) - put.begin();\\n            if(put[pos] == arr[i]) {\\n                ++pos;\\n                if(pos <= n) {\\n                    put[pos] = min(put[pos], arr[i]);\\n                    ans = max(ans, pos);\\n                }\\n            }\\n            else {\\n                put[pos] = min(put[pos], arr[i]);\\n                ans = max(ans, pos);\\n            }\\n        }\\n        return n - ans;\\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<vector<int>> where(k);\\n        for(int i = 0; i < k; i++) {\\n            for(int j = i; j < n; j += k) {\\n                where[i].push_back(arr[j]);\\n            }\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < k; i++) {\\n            ans += get(where[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    int get(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> put(n + 1, INF);\\n        put[0] = -INF;\\n        int ans = 1;\\n        for(int i = 0; i < n; i++) {\\n            int pos = upper_bound(put.begin(), put.end(), arr[i]) - put.begin();\\n            if(put[pos] == arr[i]) {\\n                ++pos;\\n                if(pos <= n) {\\n                    put[pos] = min(put[pos], arr[i]);\\n                    ans = max(ans, pos);\\n                }\\n            }\\n            else {\\n                put[pos] = min(put[pos], arr[i]);\\n                ans = max(ans, pos);\\n            }\\n        }\\n        return n - ans;\\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<vector<int>> where(k);\\n        for(int i = 0; i < k; i++) {\\n            for(int j = i; j < n; j += k) {\\n                where[i].push_back(arr[j]);\\n            }\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < k; i++) {\\n            ans += get(where[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642622,
                "title": "o-n-log-n-by-reducction-to-lis-w-hint",
                "content": "**Hint**:\\n\\n```\\n\\tnumber of minimum operations\\n\\t= sum of [ counts of those elements which break the rule of LNDS in k-gap string]\\n\\t= sum of [ length of k-gap substring - length of k-gap LNDS ]\\n```\\n\\nReduce origin problem to Longest Non-descreasing Subsequence, quite similar to **Longest Increasing Subsequence**, which we solved in [Leetcode #300](https://leetcode.com/problems/longest-increasing-subsequence/).\\n\\n---\\n\\n**Note and Definition**:\\n\\nin **L**ongest **N**on-**d**escreasing **S**ubsequence, Ai **\\u2264** Aj, for every i < j\\n\\nin **L**ongest **I**ncreasing **S**ubsequence: Ai **<** Aj, for every i < j\\n\\n---\\n\\n**Implementation** by reduction to LNDS (a variant of [LIS](https://leetcode.com/problems/longest-increasing-subsequence/))\\n\\n```\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        \\n        def LNDS( nums ):\\n            \\n            Rightmost = -1\\n            poker = []\\n            \\n            for number in nums:\\n                \\n                if not poker or poker[Rightmost] <= number:\\n                    poker.append( number )                \\n                else:\\n                    position  = bisect.bisect_right(poker, number)\\n                    poker[position] = number\\n                    \\n            return len(poker)\\n        \\n        # ----------------------------------------------------------\\n        \\n        # number of minimum operations\\n        # = sum of [ counts of those elements which break the rule of LNDS in k-gap string]\\n        # = sum of [ length of k-gap substring - length of k-gap LNDS ]\\n        return sum( len(arr[i::k]) - LNDS(arr[i::k]) for i in range(k) ) \\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #300 Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\n\\tnumber of minimum operations\\n\\t= sum of [ counts of those elements which break the rule of LNDS in k-gap string]\\n\\t= sum of [ length of k-gap substring - length of k-gap LNDS ]\\n```\n```\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        \\n        def LNDS( nums ):\\n            \\n            Rightmost = -1\\n            poker = []\\n            \\n            for number in nums:\\n                \\n                if not poker or poker[Rightmost] <= number:\\n                    poker.append( number )                \\n                else:\\n                    position  = bisect.bisect_right(poker, number)\\n                    poker[position] = number\\n                    \\n            return len(poker)\\n        \\n        # ----------------------------------------------------------\\n        \\n        # number of minimum operations\\n        # = sum of [ counts of those elements which break the rule of LNDS in k-gap string]\\n        # = sum of [ length of k-gap substring - length of k-gap LNDS ]\\n        return sum( len(arr[i::k]) - LNDS(arr[i::k]) for i in range(k) ) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642459,
                "title": "c-easy-to-understand-2-methdos",
                "content": "**working solution**\\n**Time complexity of lengthofLIS() is nlog(n)**\\n```\\nclass Solution {\\npublic:\\n    int lengthoflis(vector<int> &arr)\\n    {\\n       vector<int> sub;\\n        for (int i = 0; i < arr.size(); ++i) {\\n            int x = arr[i];\\n            if (sub.empty() || sub[sub.size() - 1] <= x) { // Append to LIS if new element is >= last element in LIS\\n                sub.push_back(x);\\n            } else {\\n                int idx = upper_bound(sub.begin(), sub.end(), x) - sub.begin(); // Find the index of the smallest number > x\\n                sub[idx] = x; // Replace that number with x\\n            }\\n        }\\n        return sub.size();\\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        vector<int> temp;\\n        int ans=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            temp.clear();\\n            for(int j=i;j<n;j+=k)\\n            {\\n                temp.push_back(arr[j]);\\n            }\\n            ans+=(temp.size()-lengthoflis(temp));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**This method gives TLE\\nbecause here we are finding length of LIS in NxN time complexity**\\n```\\nclass Solution {\\npublic:\\n    int lengthoflis(vector<int> &nums)\\n    {\\n        int n=nums.size();\\n        vector<int> dp(n);\\n        dp[0]=1;\\n        int ans=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            int maxi=0;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[j]<=nums[i])\\n                {\\n                    maxi=max(dp[j],maxi);\\n                }\\n            }\\n            dp[i]=maxi+1;\\n            ans=max(dp[i],ans);\\n        }\\n        return ans;\\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        vector<int> temp;\\n        int ans=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            temp.clear();\\n            for(int j=i;j<n;j+=k)\\n            {\\n                temp.push_back(arr[j]);\\n            }\\n            ans+=(temp.size()-lengthoflis(temp));\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthoflis(vector<int> &arr)\\n    {\\n       vector<int> sub;\\n        for (int i = 0; i < arr.size(); ++i) {\\n            int x = arr[i];\\n            if (sub.empty() || sub[sub.size() - 1] <= x) { // Append to LIS if new element is >= last element in LIS\\n                sub.push_back(x);\\n            } else {\\n                int idx = upper_bound(sub.begin(), sub.end(), x) - sub.begin(); // Find the index of the smallest number > x\\n                sub[idx] = x; // Replace that number with x\\n            }\\n        }\\n        return sub.size();\\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        vector<int> temp;\\n        int ans=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            temp.clear();\\n            for(int j=i;j<n;j+=k)\\n            {\\n                temp.push_back(arr[j]);\\n            }\\n            ans+=(temp.size()-lengthoflis(temp));\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lengthoflis(vector<int> &nums)\\n    {\\n        int n=nums.size();\\n        vector<int> dp(n);\\n        dp[0]=1;\\n        int ans=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            int maxi=0;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[j]<=nums[i])\\n                {\\n                    maxi=max(dp[j],maxi);\\n                }\\n            }\\n            dp[i]=maxi+1;\\n            ans=max(dp[i],ans);\\n        }\\n        return ans;\\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        vector<int> temp;\\n        int ans=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            temp.clear();\\n            for(int j=i;j<n;j+=k)\\n            {\\n                temp.push_back(arr[j]);\\n            }\\n            ans+=(temp.size()-lengthoflis(temp));\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641768,
                "title": "java-clean-lis-using-patience-sort",
                "content": "```\\n/*\\nUse LIS to find max seq that is increasing and find the diff with the kth seq length\\n\\n[4,1,5,2,6,2]\\n\\n4,2,1\\n4,5,6\\n\\n4,5, 6, 2\\n\\n4, 6, 7 5\\n\\n*/\\nclass Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        int count = 0;\\n        int n = arr.length;\\n        for(int i = 0; i < k; i++){\\n            count += longestIncreasingSeqPatienceSort(arr, i, k);\\n        }\\n        return count;\\n    }\\n    \\n    private int longestIncreasingSeqPatienceSort(int[] arr, int start, int k){\\n        int count = 0;\\n        int n = arr.length;\\n        \\n        int right = start;\\n\\n        List<Integer> piles = new ArrayList<>();\\n        int numPiles = -1;\\n\\n        while(right < n){\\n            //linear to log\\n            //place smaller values on bigger piles, if current is bigger than the last, start a new pile with current\\n            //use binary search to find upper bound on pile\\n            \\n            if(piles.size() == 0 || piles.get(piles.size() -1) <= arr[right]) {\\n                piles.add(arr[right]);\\n            } else {\\n                int index = upperBound(piles, arr[right]);\\n                piles.set(index, arr[right]);\\n            }\\n            right += k;\\n            count++;\\n        }\\n        \\n        //operation = diff of longest increasing seq with the longest kth seq\\n        return count - piles.size();\\n    }\\n    \\n    private int upperBound(List<Integer> piles, int num){\\n        //upper bound can be outside current bounds\\n        //5,6 7\\n        //5\\n        int left = 0;\\n        int right = piles.size() - 1;\\n        while(left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if(num < piles.get(mid)){\\n                right = mid;\\n            }else{\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n    \\n    //O(n^2) \\n    private int longestIncreasingSeq(int[] arr, int start, int k){\\n        int count = 1;\\n        int n = arr.length;\\n        int left = start;\\n        int right = start + k;\\n        int max = 1;\\n        \\n        int[] lis = new int[n];\\n        Arrays.fill(lis, 1);\\n        \\n        while(right < n){\\n            //linear -- bottleneck\\n            for(int pre = right - k; pre >= start; pre -= k){\\n                if(arr[pre] <= arr[right]){\\n                    lis[right] = Math.max(lis[right], lis[pre] + 1);                \\n                }\\n            }\\n            max = Math.max(lis[right], max);\\n            right += k;\\n            count++;\\n        }\\n        \\n        //needs fixing\\n        return count - max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\n/*\\nUse LIS to find max seq that is increasing and find the diff with the kth seq length\\n\\n[4,1,5,2,6,2]\\n\\n4,2,1\\n4,5,6\\n\\n4,5, 6, 2\\n\\n4, 6, 7 5\\n\\n*/\\nclass Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        int count = 0;\\n        int n = arr.length;\\n        for(int i = 0; i < k; i++){\\n            count += longestIncreasingSeqPatienceSort(arr, i, k);\\n        }\\n        return count;\\n    }\\n    \\n    private int longestIncreasingSeqPatienceSort(int[] arr, int start, int k){\\n        int count = 0;\\n        int n = arr.length;\\n        \\n        int right = start;\\n\\n        List<Integer> piles = new ArrayList<>();\\n        int numPiles = -1;\\n\\n        while(right < n){\\n            //linear to log\\n            //place smaller values on bigger piles, if current is bigger than the last, start a new pile with current\\n            //use binary search to find upper bound on pile\\n            \\n            if(piles.size() == 0 || piles.get(piles.size() -1) <= arr[right]) {\\n                piles.add(arr[right]);\\n            } else {\\n                int index = upperBound(piles, arr[right]);\\n                piles.set(index, arr[right]);\\n            }\\n            right += k;\\n            count++;\\n        }\\n        \\n        //operation = diff of longest increasing seq with the longest kth seq\\n        return count - piles.size();\\n    }\\n    \\n    private int upperBound(List<Integer> piles, int num){\\n        //upper bound can be outside current bounds\\n        //5,6 7\\n        //5\\n        int left = 0;\\n        int right = piles.size() - 1;\\n        while(left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if(num < piles.get(mid)){\\n                right = mid;\\n            }else{\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n    \\n    //O(n^2) \\n    private int longestIncreasingSeq(int[] arr, int start, int k){\\n        int count = 1;\\n        int n = arr.length;\\n        int left = start;\\n        int right = start + k;\\n        int max = 1;\\n        \\n        int[] lis = new int[n];\\n        Arrays.fill(lis, 1);\\n        \\n        while(right < n){\\n            //linear -- bottleneck\\n            for(int pre = right - k; pre >= start; pre -= k){\\n                if(arr[pre] <= arr[right]){\\n                    lis[right] = Math.max(lis[right], lis[pre] + 1);                \\n                }\\n            }\\n            max = Math.max(lis[right], max);\\n            right += k;\\n            count++;\\n        }\\n        \\n        //needs fixing\\n        return count - max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641306,
                "title": "minimum-operation-to-make-the-array-k-increasing",
                "content": "Intuition:\\n    The intuition behind this solution is that we extract all k-separated subsequences and find out the longest \\n    increasing subsequence (LIS) from each of the subsequences and then for each of the extracted k-separated \\n    subsequences we calculate the min operations (delete/update) to make it sorted/increasing.\\n    \\nMin operations to make it increasing = Length of extracted subsequence - LIS of the extracted subsequence\\nWe add the min operations for each of the k-separated subsequences which should give us the answer for \\nthe original problem.\\n    \\n   Let\\'s take an example to understand better -\\n   \\n\\t arr = [4,1,5,2,6,2,8,9,11,15]\\n\\t k=3\\n    \\n    k-seperated subsequences of arr:\\n    subsequence      length     LIS      Operations(Length - LIS)\\n    [4,2,8,15]          4        3           1\\n    [1,6,9]             3        3           0\\n    [5,2,11]            3        2           1\\n    -------------------------------------------------\\n    Total Operations =                       2\\n    -------------------------------------------------\\n\\t\\n\\t\\ncode :\\n    \\n    class Solution {\\n    public:\\n      int kIncreasing(int[] arr, int k) {\\n            int total = 0;\\n            for(int i=0; i < k; i++){\\n              vector<int> lis;\\n              for(int j=i; j < arr.size(); j = j+k)\\n                lis.push_back(arr[j]);\\n              total += lis.size() - lengthOfLIS(lis);\\n            }\\n            return total;\\n        }\\n      \\n      // Get the length of LIS by building an increasing List so as to perform binary search on it \\n      // in case the current element is lesser than the last element in the increasing List. \\n      // In such case we get the next greater element from the increasing List by doing a binary Search and \\n      // replace that with the the current element in the increasing List, as the other element is no longer \\n      // relevant in participating in LIS. \\n      // The increasing List remains sorted and always maintain the max length of the increasing subsequence.\\n      \\n      int lengthOfLIS(vector<int> nums){\\n        vector<int> incrLis;\\n        incrLis.push_back(nums[0]);\\n        for(int i=1; i < nums.size(); i++){\\n          int lastItem = incrList[incrLis.size()-1];\\n          if(nums[i] >= lastItem){\\n            incrLis.push_back(nums[i]);\\n          } else {\\n            int idx = nextGreaterItem(incrList, nums[i]);\\n            incrLis[idx] = nums[i];\\n          }\\n        }\\n        return incrLis.size();\\n      }\\n    \\n      // Perform Binary Search to get the next greater element\\n      int nextGreaterItem(vector<int> lis, int num){\\n        int left = 0, right = lis.size()-1;\\n        while(left < right) {\\n          int mid = left + (right - left) / 2;\\n          if(num >= lis[mid])\\n            left = mid + 1;\\n          else\\n            right = mid;\\n        }\\n        return left;\\n      }\\n    };\\nhope y\\'ll like it.\\n\\t",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n      int kIncreasing(int[] arr, int k) {\\n            int total = 0;\\n            for(int i=0; i < k; i++){\\n              vector<int> lis;\\n              for(int j=i; j < arr.size(); j = j+k)\\n                lis.push_back(arr[j]);\\n              total += lis.size() - lengthOfLIS(lis);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1641067,
                "title": "easy-problem-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint LIS (vector<int> &a, int l, int r, int mi = 1, int ma = 1e5) {\\n\\t\\tvector<int> lis;\\n\\t\\tfor (int j = l; j <= r; ++j)\\n\\t\\t\\tif (mi <= a[j] && a[j] <= ma) {\\n\\t\\t\\t\\tauto pos = upper_bound (lis.begin(), lis.end(), a[j]);\\n\\t\\t\\t\\tif (pos == lis.end())\\n\\t\\t\\t\\t\\tlis.emplace_back (a[j]);\\n\\t\\t\\t\\telse *pos = a[j];\\n\\t\\t\\t}\\n\\t\\treturn (lis.size());\\n\\t}\\n\\tint kIncreasing (vector<int> &a, int k) {\\n\\t\\tint n = a.size();\\n\\t\\tvector<vector<int>> v (k);\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tv[i % k].emplace_back (a[i]);\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 0; i < k; i ++)\\n\\t\\t\\tans += v[i].size() - LIS (v[i], 0, v[i].size() - 1);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint LIS (vector<int> &a, int l, int r, int mi = 1, int ma = 1e5) {\\n\\t\\tvector<int> lis;\\n\\t\\tfor (int j = l; j <= r; ++j)\\n\\t\\t\\tif (mi <= a[j] && a[j] <= ma) {\\n\\t\\t\\t\\tauto pos = upper_bound (lis.begin(), lis.end(), a[j]);\\n\\t\\t\\t\\tif (pos == lis.end())\\n\\t\\t\\t\\t\\tlis.emplace_back (a[j]);\\n\\t\\t\\t\\telse *pos = a[j];\\n\\t\\t\\t}\\n\\t\\treturn (lis.size());\\n\\t}\\n\\tint kIncreasing (vector<int> &a, int k) {\\n\\t\\tint n = a.size();\\n\\t\\tvector<vector<int>> v (k);\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tv[i % k].emplace_back (a[i]);\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 0; i < k; i ++)\\n\\t\\t\\tans += v[i].size() - LIS (v[i], 0, v[i].size() - 1);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640364,
                "title": "python3-lis",
                "content": "```\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        # min operations = length - LIS. \\n        # arr[i]..arr[i+k]..arr[i+2k]...\\n        # i 0->k-1\\n        # compute LIS: arr[i] >= arr[i-1], append; else, bisect_right insert and replace. \\n                \\n        res = 0\\n        \\n        for start in range(0, k):\\n            count, sub = 0, []\\n            for i in range(start, len(arr), k):\\n                count += 1\\n                if len(sub) == 0 or arr[i] >= sub[-1]:\\n                    sub.append(arr[i])\\n                else:\\n                    idx = bisect.bisect_right(sub, arr[i])\\n                    sub[idx] = arr[i]\\n            res += count - len(sub)\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        # min operations = length - LIS. \\n        # arr[i]..arr[i+k]..arr[i+2k]...\\n        # i 0->k-1\\n        # compute LIS: arr[i] >= arr[i-1], append; else, bisect_right insert and replace. \\n                \\n        res = 0\\n        \\n        for start in range(0, k):\\n            count, sub = 0, []\\n            for i in range(start, len(arr), k):\\n                count += 1\\n                if len(sub) == 0 or arr[i] >= sub[-1]:\\n                    sub.append(arr[i])\\n                else:\\n                    idx = bisect.bisect_right(sub, arr[i])\\n                    sub[idx] = arr[i]\\n            res += count - len(sub)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1639288,
                "title": "python3-find-longest-non-decreasing-subsequence-for-each-k-increasing-array",
                "content": "There are explanations as comments\\n```\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        retV = 0                                   # retV: return value\\n        # for each starting index i which is from 0 to k-1\\n        for i in range(k):                         # i: starting index\\n            lst = arr[i::k]                        # lst: each k-increasing array\\n            lis = lst[0:1]                         # lis: the build-up of the longest non-decreasing subsequence\\n            for el in lst[1:]:\\n\\t\\t\\t    # binary search for the build-up of the longest non-decreasing subsequence\\n                l,r = 0,len(lis)\\n                while l<r:\\n                    ind = (l+r)//2\\n                    if lis[ind]<=el:        l = ind+1\\n                    else:                   r = ind\\n                if l==len(lis):     lis += [el]\\n                else:               lis[l] = el\\n\\t\\t\\t# len(lst)-len(lis): minimum number of operations needed to make the (sub-)array non-decreasing\\n            retV += len(lst)-len(lis)\\n        return retV\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        retV = 0                                   # retV: return value\\n        # for each starting index i which is from 0 to k-1\\n        for i in range(k):                         # i: starting index\\n            lst = arr[i::k]                        # lst: each k-increasing array\\n            lis = lst[0:1]                         # lis: the build-up of the longest non-decreasing subsequence\\n            for el in lst[1:]:\\n\\t\\t\\t    # binary search for the build-up of the longest non-decreasing subsequence\\n                l,r = 0,len(lis)\\n                while l<r:\\n                    ind = (l+r)//2\\n                    if lis[ind]<=el:        l = ind+1\\n                    else:                   r = ind\\n                if l==len(lis):     lis += [el]\\n                else:               lis[l] = el\\n\\t\\t\\t# len(lst)-len(lis): minimum number of operations needed to make the (sub-)array non-decreasing\\n            retV += len(lst)-len(lis)\\n        return retV\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1639178,
                "title": "golang-solution",
                "content": "```\\nfunc kIncreasing(arr []int, k int) int {\\n    lenArr := len(arr)\\n    count := 0\\n    for i := 0; i < k; i++ {\\n        var subArr []int\\n        for j := i; j < lenArr; j += k {\\n            subArr = append(subArr, arr[j])\\n        }\\n        count += len(subArr) - longestIncreasingSubsequence(subArr)\\n    }\\n    return count\\n}\\n\\nfunc longestIncreasingSubsequence(arr []int) int {\\n    list := []int{arr[0]}\\n    for i := 1; i < len(arr); i++ {\\n        item := arr[i]\\n        index := binarySearch(list, item)\\n        if index == len(list)-1 {\\n            list = append(list, item)\\n        } else {\\n            list[index+1] = item\\n        }\\n    }\\n    return len(list)\\n}\\n\\nfunc binarySearch(arr []int, target int) int {\\n    l, r := 0, len(arr)-1\\n    for l < r {\\n        mid := l + (r-l+1)/2\\n        if arr[mid] <= target {\\n            l = mid\\n        } else {\\n            r = mid - 1\\n        }\\n    }\\n    if arr[l] > target {\\n\\t\\treturn -1\\n\\t}\\n\\treturn l\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunc kIncreasing(arr []int, k int) int {\\n    lenArr := len(arr)\\n    count := 0\\n    for i := 0; i < k; i++ {\\n        var subArr []int\\n        for j := i; j < lenArr; j += k {\\n            subArr = append(subArr, arr[j])\\n        }\\n        count += len(subArr) - longestIncreasingSubsequence(subArr)\\n    }\\n    return count\\n}\\n\\nfunc longestIncreasingSubsequence(arr []int) int {\\n    list := []int{arr[0]}\\n    for i := 1; i < len(arr); i++ {\\n        item := arr[i]\\n        index := binarySearch(list, item)\\n        if index == len(list)-1 {\\n            list = append(list, item)\\n        } else {\\n            list[index+1] = item\\n        }\\n    }\\n    return len(list)\\n}\\n\\nfunc binarySearch(arr []int, target int) int {\\n    l, r := 0, len(arr)-1\\n    for l < r {\\n        mid := l + (r-l+1)/2\\n        if arr[mid] <= target {\\n            l = mid\\n        } else {\\n            r = mid - 1\\n        }\\n    }\\n    if arr[l] > target {\\n\\t\\treturn -1\\n\\t}\\n\\treturn l\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1638788,
                "title": "c-upper-bound-lis-easy",
                "content": "int LIS(vector<int>& nums)\\n    {\\n        vector<int> v;\\n        v.push_back(nums[0]);\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(v.back()<=nums[i])\\n            {\\n                v.push_back(nums[i]);\\n            }\\n            else\\n            {\\n                int index= upper_bound(v.begin(),v.end(),nums[i])-v.begin();\\n                v[index]=nums[i];\\n            }\\n        }\\n        return v.size();\\n    }\\n    \\n    int kIncreasing(vector<int>& arr, int k) {\\n        \\n        \\n        int n=arr.size();\\n         vector<int> temp;\\n        int ans=0;\\n        for(int i=0;i<k;i++)\\n        {\\n          //  vector<int> temp;\\n            for(int j=i;j<n;j+=k)\\n            {\\n                temp.push_back(arr[j]);\\n            }\\n            int sz=temp.size();\\n            ans+=(sz-LIS(temp));\\n            temp.clear();\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "int LIS(vector<int>& nums)\\n    {\\n        vector<int> v;\\n        v.push_back(nums[0]);\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(v.back()<=nums[i])\\n            {\\n                v.push_back(nums[i]);\\n            }\\n            else\\n            {\\n                int index= upper_bound(v.begin(),v.end(),nums[i])-v.begin();\\n                v[index]=nums[i];\\n            }\\n        }\\n        return v.size();\\n    }\\n    \\n    int kIncreasing(vector<int>& arr, int k) {\\n        \\n        \\n        int n=arr.size();\\n         vector<int> temp;\\n        int ans=0;\\n        for(int i=0;i<k;i++)\\n        {\\n          //  vector<int> temp;\\n            for(int j=i;j<n;j+=k)\\n            {\\n                temp.push_back(arr[j]);\\n            }\\n            int sz=temp.size();\\n            ans+=(sz-LIS(temp));\\n            temp.clear();\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1638203,
                "title": "c-longest-increasing-subsequence-classic-dp",
                "content": "1-> Get k sequences.\\n2-> For each such sequence S_k, we must find the minimum number of changes to make S_k increasing(or equal)\\n3-> Step2 above: minimum number of changes = lengthOf(S_k) - lengthOf(LIS of S_k) \\n4-> Add this minimum number of changes to final answer.\\n\\nImplement LIS using TC = O(nlogn)\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int kIncreasing(vector<int>& arr, int K) {\\n        int n = arr.size();\\n        \\n        int changesToMake = 0;\\n\\n        for(int k=0;k<K;k++){\\n            vector<int> nums;\\n            for(int i=k;i<n;i+=K)\\n                nums.push_back(arr[i]);\\n            int lenOfLIS = LIS(nums);\\n            changesToMake += (nums.size() - lenOfLIS);\\n        }\\n\\n        return changesToMake;\\n    }\\n    \\n\\n    int LIS(vector<int>& nums){\\n        int n = nums.size();\\n        vector<int> lisEndingAt(n,1);\\n        \\n        map<int,int> candidates;\\n        candidates[nums[0]] = 1;\\n        \\n        for(int i=1;i<n;i++){\\n            if(candidates.count(nums[i]))\\n                candidates[nums[i]]+=1;\\n            else{\\n                auto iter = candidates.lower_bound(nums[i]);\\n                if(iter == candidates.begin())\\n                    candidates[nums[i]] = 1;\\n                else{\\n                    iter--;\\n                    candidates[nums[i]] = 1 + iter->second;    \\n                }\\n            }\\n            lisEndingAt[i] = candidates[nums[i]];\\n            auto iter = candidates.lower_bound(nums[i]);\\n            iter++;\\n            if(iter->second == candidates[nums[i]])\\n                candidates.erase(iter);\\n        }\\n        \\n        return *max_element(lisEndingAt.begin(), lisEndingAt.end());\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int kIncreasing(vector<int>& arr, int K) {\\n        int n = arr.size();\\n        \\n        int changesToMake = 0;\\n\\n        for(int k=0;k<K;k++){\\n            vector<int> nums;\\n            for(int i=k;i<n;i+=K)\\n                nums.push_back(arr[i]);\\n            int lenOfLIS = LIS(nums);\\n            changesToMake += (nums.size() - lenOfLIS);\\n        }\\n\\n        return changesToMake;\\n    }\\n    \\n\\n    int LIS(vector<int>& nums){\\n        int n = nums.size();\\n        vector<int> lisEndingAt(n,1);\\n        \\n        map<int,int> candidates;\\n        candidates[nums[0]] = 1;\\n        \\n        for(int i=1;i<n;i++){\\n            if(candidates.count(nums[i]))\\n                candidates[nums[i]]+=1;\\n            else{\\n                auto iter = candidates.lower_bound(nums[i]);\\n                if(iter == candidates.begin())\\n                    candidates[nums[i]] = 1;\\n                else{\\n                    iter--;\\n                    candidates[nums[i]] = 1 + iter->second;    \\n                }\\n            }\\n            lisEndingAt[i] = candidates[nums[i]];\\n            auto iter = candidates.lower_bound(nums[i]);\\n            iter++;\\n            if(iter->second == candidates[nums[i]])\\n                candidates.erase(iter);\\n        }\\n        \\n        return *max_element(lisEndingAt.begin(), lisEndingAt.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1638165,
                "title": "longest-non-decreasing-subsequence",
                "content": "```\\nclass Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        int n = arr.length;\\n        int [] seq = new int [(n-1)/k + 1];\\n        int res = 0;\\n        for(int i =0;i <Math.min(n, k); i++){\\n            int move = getLongestSub(i, k, arr, seq);\\n            res += move;\\n        }\\n        return res;\\n    }\\n    \\n    private int getLongestSub(int idx, int k, int []arr, int []seq){\\n        int l = 0;\\n        int cnt = 0;\\n        for(int i = idx; i<arr.length; i+= k){\\n            cnt++;\\n            l = getNewL(arr[i], seq, l);\\n        }\\n        return cnt-l;\\n    }\\n    \\n    private int getNewL(int num, int []seq, int l){\\n        int start =0;\\n        int end = l-1;\\n        int res = l;\\n        while(start <= end){\\n            int mid = start+(end-start)/2;\\n            if(seq[mid] <= num)\\n                start = mid+1;\\n            else{\\n                res = mid;\\n                end = mid-1;\\n            }\\n        }\\n        seq[res] = num;\\n        return Math.max(l, res+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        int n = arr.length;\\n        int [] seq = new int [(n-1)/k + 1];\\n        int res = 0;\\n        for(int i =0;i <Math.min(n, k); i++){\\n            int move = getLongestSub(i, k, arr, seq);\\n            res += move;\\n        }\\n        return res;\\n    }\\n    \\n    private int getLongestSub(int idx, int k, int []arr, int []seq){\\n        int l = 0;\\n        int cnt = 0;\\n        for(int i = idx; i<arr.length; i+= k){\\n            cnt++;\\n            l = getNewL(arr[i], seq, l);\\n        }\\n        return cnt-l;\\n    }\\n    \\n    private int getNewL(int num, int []seq, int l){\\n        int start =0;\\n        int end = l-1;\\n        int res = l;\\n        while(start <= end){\\n            int mid = start+(end-start)/2;\\n            if(seq[mid] <= num)\\n                start = mid+1;\\n            else{\\n                res = mid;\\n                end = mid-1;\\n            }\\n        }\\n        seq[res] = num;\\n        return Math.max(l, res+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1638113,
                "title": "not-a-good-question-for-interview",
                "content": "I was asked this question two years ago, how to solve it if I don\\'t know the actual question is to look for LIS?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1637334,
                "title": "minimum-operations-to-make-the-array-k-increasing-c-lis",
                "content": "class Solution {\\npublic:\\n    // Time Complexity of LIS=O(nlogn)\\n\\t\\n    int LIS(vector<int> &temp){\\n        int n = temp.size();\\n        \\n        vector<int> v;\\n        v.push_back(temp[0]);\\n        \\n        for(int i=1; i<n; i++){\\n            if(temp[i] >= v.back())   // If new element is >= last element of the vector then push it.\\n                v.push_back(temp[i]);\\n            else{\\n                int idx = upper_bound(v.begin(), v.end(), temp[i])-v.begin(); // Find the index of the smallest element which is greater then the new element.\\n                v[idx] = temp[i];   // Replace that index number with new element.\\n            }\\n        }\\n        \\n        return v.size();\\n    }\\n    \\n        \\n    int kIncreasing(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        int ans=0;\\n        \\n        // Traverse upto to k\\n        for(int i=0; i<k; i++){\\n            vector<int> temp;\\n            \\n            // Make subarray of kth-group\\n            for(int j=i; j<n; j+=k){\\n                temp.push_back(arr[j]);\\n            }\\n            \\n            // Find Longest increasing subsebsequence\\n            int curr = LIS(temp);\\n            \\n            ans += (temp.size()-curr);  // Add total LIS\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    // Time Complexity of LIS=O(nlogn)\\n\\t\\n    int LIS(vector<int> &temp){\\n        int n = temp.size();\\n        \\n        vector<int> v;\\n        v.push_back(temp[0]);\\n        \\n        for(int i=1; i<n; i++){\\n            if(temp[i] >= v.back())   // If new element is >= last element of the vector then push it.\\n                v.push_back(temp[i]);\\n            else{\\n                int idx = upper_bound(v.begin(), v.end(), temp[i])-v.begin(); // Find the index of the smallest element which is greater then the new element.\\n                v[idx] = temp[i];   // Replace that index number with new element.\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1637104,
                "title": "getting-tle-can-anyone-modify-this",
                "content": "class Solution {\\npublic:\\n    \\n    int LIS(vector<int>& arr){\\n       int n=arr.size();\\n       vector<int>dp(n,-1);\\n       dp[0]=1;\\n        \\n        \\n        for(int i=1;i<n;i++){\\n            dp[i]=1;\\n            for(int j=0;j<i;j++){\\n                if(arr[i]>=arr[j]){\\n                    dp[i]=max(1+dp[j],dp[i]);\\n                }\\n            }\\n        }\\n        \\n        int maxi=0;\\n        for(auto it:dp){\\n            maxi=max(maxi,it);\\n        }\\n        \\n        return (n-maxi);\\n        \\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n        \\n        \\n        int n=arr.size();\\n        int cnt=0;\\n        \\n        int ans=0;\\n        vector<vector<int> > group(k);\\n\\n        for(int i=0;i<k;i++){\\n             for(int j=i;j<n;j+=k){\\n                \\n                group[i].push_back(arr[j]);\\n                \\n            }\\n            \\n            \\n\\n        }\\n        \\n        for(auto &v : group) {\\n            ans += LIS(v);\\n        }\\n\\n        \\n        \\n        \\n        return ans;\\n       \\n        \\n \\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int LIS(vector<int>& arr){\\n       int n=arr.size();\\n       vector<int>dp(n,-1);\\n       dp[0]=1;\\n        \\n        \\n        for(int i=1;i<n;i++){\\n            dp[i]=1;\\n            for(int j=0;j<i;j++){\\n                if(arr[i]>=arr[j]){\\n                    dp[i]=max(1+dp[j],dp[i]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1636828,
                "title": "longest-increasing-subsequence-using-c",
                "content": "C# solution\\n\\n```\\npublic int KIncreasing(int[] arr, int k)\\n    {\\n        var res = 0;\\n        var subLists = new List<List<int>>();\\n        for(int i = 0; i< k; i++)\\n        {\\n            var newarr = new List<int>();\\n            for(int j= i; j< arr.Length; j+=k) newarr.Add(arr[j]);           \\n            subLists.Add(newarr);\\n        }\\n\\n        foreach(var sublist in subLists)\\n        {\\n            var longSub = new List<int>();\\n            for(int i=0; i< sublist.Count;++i)\\n            {\\n                var x = sublist[i];\\n                if(longSub.Count == 0 || x >= longSub.Last()) longSub.Add(x);\\n                else\\n                {\\n                    int idx = longSub.FindIndex(f => f > x);\\n                    longSub[idx] = x;\\n                }\\n            }            \\n            res+= sublist.Count - longSub.Count;\\n        }        \\n        return res;\\n    }\\n```\\n\\n![image](https://assets.leetcode.com/users/images/c388440a-aaf5-4c5a-a1ae-fe0aa25a892a_1639964002.36366.png)\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic int KIncreasing(int[] arr, int k)\\n    {\\n        var res = 0;\\n        var subLists = new List<List<int>>();\\n        for(int i = 0; i< k; i++)\\n        {\\n            var newarr = new List<int>();\\n            for(int j= i; j< arr.Length; j+=k) newarr.Add(arr[j]);           \\n            subLists.Add(newarr);\\n        }\\n\\n        foreach(var sublist in subLists)\\n        {\\n            var longSub = new List<int>();\\n            for(int i=0; i< sublist.Count;++i)\\n            {\\n                var x = sublist[i];\\n                if(longSub.Count == 0 || x >= longSub.Last()) longSub.Add(x);\\n                else\\n                {\\n                    int idx = longSub.FindIndex(f => f > x);\\n                    longSub[idx] = x;\\n                }\\n            }            \\n            res+= sublist.Count - longSub.Count;\\n        }        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1636599,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int KIncreasing(int[] arr, int k) {\\n        int r = 0;\\n        for (int i = 0; i < k; ++i) {\\n            r += LongestIncreasingSubsequence(arr, i, k);\\n        }\\n        \\n        return r;\\n    }\\n    \\n    public int LongestIncreasingSubsequence(int[] a, int s, int k) {\\n        List<int> sq = new List<int>() { a[s] };\\n        int tot = 1;\\n        for (int i = s + k; i < a.Length; i += k) {\\n            if (sq[sq.Count - 1] <= a[i]) {\\n                sq.Add(a[i]);\\n            } else {\\n                int j = FindNextLargest(sq, a[i]);\\n                sq[j] = a[i];\\n            }\\n            tot++;\\n        }\\n\\n        return tot - sq.Count;\\n    }\\n    \\n    public int FindNextLargest(List<int> ls, int cur) {\\n        int l = 0, r = ls.Count - 1;\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (ls[m] < cur) {\\n                l = m + 1;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        \\n        return ls[l] == cur ? l + 1 : l;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int KIncreasing(int[] arr, int k) {\\n        int r = 0;\\n        for (int i = 0; i < k; ++i) {\\n            r += LongestIncreasingSubsequence(arr, i, k);\\n        }\\n        \\n        return r;\\n    }\\n    \\n    public int LongestIncreasingSubsequence(int[] a, int s, int k) {\\n        List<int> sq = new List<int>() { a[s] };\\n        int tot = 1;\\n        for (int i = s + k; i < a.Length; i += k) {\\n            if (sq[sq.Count - 1] <= a[i]) {\\n                sq.Add(a[i]);\\n            } else {\\n                int j = FindNextLargest(sq, a[i]);\\n                sq[j] = a[i];\\n            }\\n            tot++;\\n        }\\n\\n        return tot - sq.Count;\\n    }\\n    \\n    public int FindNextLargest(List<int> ls, int cur) {\\n        int l = 0, r = ls.Count - 1;\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (ls[m] < cur) {\\n                l = m + 1;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        \\n        return ls[l] == cur ? l + 1 : l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636320,
                "title": "using-lis-in-nlogn-over-range-0-k-simple-and-intutive-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int ans=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            int n=0; // To count the number of element in a particular sequence.\\n            multiset<int>ms;  // basically we are trying to find LIS of non decreasing subsequence.\\n            for(int j=i;j<arr.size();j+=k)\\n            {\\n                n++;\\n                auto x= ms.upper_bound(arr[j]);\\n                if(x==ms.end()) /// out of the range so we have to insert element;\\n                ms.insert(arr[j]);\\n                else\\n                {\\n                    // it means it is pointing the the just greatest element in ms, so we can replace that element with curr element;\\n                    ms.erase(ms.find(*x));\\n                    ms.insert(arr[j]);\\n                }\\n            }\\n            \\n            ans+=(n-ms.size()); // ms.size() means Longest non decreasing subsequence, So if we want to make whole n longest non decreasing\\n            // subsequence we have to change n - ms.size() element into it.\\n                \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int ans=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            int n=0; // To count the number of element in a particular sequence.\\n            multiset<int>ms;  // basically we are trying to find LIS of non decreasing subsequence.\\n            for(int j=i;j<arr.size();j+=k)\\n            {\\n                n++;\\n                auto x= ms.upper_bound(arr[j]);\\n                if(x==ms.end()) /// out of the range so we have to insert element;\\n                ms.insert(arr[j]);\\n                else\\n                {\\n                    // it means it is pointing the the just greatest element in ms, so we can replace that element with curr element;\\n                    ms.erase(ms.find(*x));\\n                    ms.insert(arr[j]);\\n                }\\n            }\\n            \\n            ans+=(n-ms.size()); // ms.size() means Longest non decreasing subsequence, So if we want to make whole n longest non decreasing\\n            // subsequence we have to change n - ms.size() element into it.\\n                \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636197,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int bb(int fi, int la, int x, vector<int> &hh, vector<int> &ss) {\\n\\n    int mid;\\n    while(la > fi)\\n    {\\n        int mid = fi + (la - fi) / 2;\\n        if(hh[ss[mid]] > x)\\n            la = mid;\\n        else\\n            fi = mid + 1;\\n    }\\n    return fi; \\n    }\\n\\n    int ff( vector<int> &hh) {\\n\\n        int i, k, ind;\\n        int n=hh.size();\\n        vector<int> ss;\\n        for(int i=0;i<n+1;++i)ss.push_back(0);\\n        ind = 1;\\n        ss[1] = 0;\\n        for (i = 1; i < n; i++) {\\n\\n            if (hh[i] >= hh[ss[ind]]) {\\n\\n                ind++;\\n                ss[ind] = i; \\n\\n            }\\n            else {\\n                k = bb(1, ind, hh[i], hh,ss);\\n\\n                if (hh[ss[k]] >= hh[i]) { \\n                    ss[k] = i;\\n                }\\n            }\\n        }\\n        return ind;\\n    }\\n    int f(vector<int> &v){\\n        return v.size()-ff(v);\\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int ans = 0;\\n        int i=0;\\n        while(i<k) {\\n            vector<int> v;\\n            for(int j=i;j<arr.size();j=j+k){\\n                v.push_back(arr[j]);\\n            }\\n            ans = ans + f(v);\\n            v.clear();\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bb(int fi, int la, int x, vector<int> &hh, vector<int> &ss) {\\n\\n    int mid;\\n    while(la > fi)\\n    {\\n        int mid = fi + (la - fi) / 2;\\n        if(hh[ss[mid]] > x)\\n            la = mid;\\n        else\\n            fi = mid + 1;\\n    }\\n    return fi; \\n    }\\n\\n    int ff( vector<int> &hh) {\\n\\n        int i, k, ind;\\n        int n=hh.size();\\n        vector<int> ss;\\n        for(int i=0;i<n+1;++i)ss.push_back(0);\\n        ind = 1;\\n        ss[1] = 0;\\n        for (i = 1; i < n; i++) {\\n\\n            if (hh[i] >= hh[ss[ind]]) {\\n\\n                ind++;\\n                ss[ind] = i; \\n\\n            }\\n            else {\\n                k = bb(1, ind, hh[i], hh,ss);\\n\\n                if (hh[ss[k]] >= hh[i]) { \\n                    ss[k] = i;\\n                }\\n            }\\n        }\\n        return ind;\\n    }\\n    int f(vector<int> &v){\\n        return v.size()-ff(v);\\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int ans = 0;\\n        int i=0;\\n        while(i<k) {\\n            vector<int> v;\\n            for(int j=i;j<arr.size();j=j+k){\\n                v.push_back(arr[j]);\\n            }\\n            ans = ans + f(v);\\n            v.clear();\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636145,
                "title": "python-simplest-o-nlogn",
                "content": "```\\nfrom bisect import bisect_right\\n\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        d = [[arr[i]] for i in range(k)]\\n        for i in range(k,len(arr)):\\n            if d[i%k][-1] <= arr[i]:\\n                d[i%k].append(arr[i])\\n            else:\\n                pos = bisect_right(d[i%k],arr[i])\\n                d[i%k][pos] = arr[i]\\n        return len(arr) - sum([len(e) for e in d])      \\n```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_right\\n\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        d = [[arr[i]] for i in range(k)]\\n        for i in range(k,len(arr)):\\n            if d[i%k][-1] <= arr[i]:\\n                d[i%k].append(arr[i])\\n            else:\\n                pos = bisect_right(d[i%k],arr[i])\\n                d[i%k][pos] = arr[i]\\n        return len(arr) - sum([len(e) for e in d])      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636063,
                "title": "go-lis-longest-increasing-subsequence",
                "content": "For every sequence `i,i+k,i+2k,i+3k,...,i+nk`, we can find the longest increasing subsequence, marked as `m`, then the min times to make this sequence increasing is `len-m`. So this problem is converted to LIS problem.\\n```go\\nfunc kIncreasing(arr []int, k int) int {\\n\\tans := 0\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tsubarray := make([]int, 0)\\n\\t\\tfor j := i; j < len(arr); j += k {\\n\\t\\t\\tsubarray = append(subarray, arr[j])\\n\\t\\t}\\n\\t\\tans += len(subarray) - maxNonDecreaseSubarray(subarray)\\n\\t}\\n\\treturn ans\\n}\\n\\nfunc maxNonDecreaseSubarray(subarray []int) int {\\n\\tdp := make([]int, len(subarray))\\n\\tdp[0] = subarray[0]\\n\\tindex := 0\\n\\tfor i := 1; i < len(subarray); i++ {\\n\\t\\tif subarray[i] >= dp[index] {\\n\\t\\t\\tindex++\\n\\t\\t\\tdp[index] = subarray[i]\\n\\t\\t} else {\\n\\t\\t\\tdp[binarySearch(dp, 0, index, subarray[i])] = subarray[i]\\n\\t\\t}\\n\\t}\\n\\treturn index + 1\\n}\\n\\nfunc binarySearch(a []int, l, r int, t int) int {\\n\\tfor l <= r {\\n\\t\\tmid := l + (r-l)>>1\\n\\t\\tif a[mid] <= t {\\n\\t\\t\\tl = mid + 1\\n\\t\\t} else if a[mid] > t {\\n\\t\\t\\tr = mid - 1\\n\\t\\t}\\n\\t}\\n\\treturn l\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc kIncreasing(arr []int, k int) int {\\n\\tans := 0\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tsubarray := make([]int, 0)\\n\\t\\tfor j := i; j < len(arr); j += k {\\n\\t\\t\\tsubarray = append(subarray, arr[j])\\n\\t\\t}\\n\\t\\tans += len(subarray) - maxNonDecreaseSubarray(subarray)\\n\\t}\\n\\treturn ans\\n}\\n\\nfunc maxNonDecreaseSubarray(subarray []int) int {\\n\\tdp := make([]int, len(subarray))\\n\\tdp[0] = subarray[0]\\n\\tindex := 0\\n\\tfor i := 1; i < len(subarray); i++ {\\n\\t\\tif subarray[i] >= dp[index] {\\n\\t\\t\\tindex++\\n\\t\\t\\tdp[index] = subarray[i]\\n\\t\\t} else {\\n\\t\\t\\tdp[binarySearch(dp, 0, index, subarray[i])] = subarray[i]\\n\\t\\t}\\n\\t}\\n\\treturn index + 1\\n}\\n\\nfunc binarySearch(a []int, l, r int, t int) int {\\n\\tfor l <= r {\\n\\t\\tmid := l + (r-l)>>1\\n\\t\\tif a[mid] <= t {\\n\\t\\t\\tl = mid + 1\\n\\t\\t} else if a[mid] > t {\\n\\t\\t\\tr = mid - 1\\n\\t\\t}\\n\\t}\\n\\treturn l\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1635884,
                "title": "lis-using-set-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int n=arr.size(), ans=0;\\n        for(int i=0; i<k; i++){\\n            multiset<int> s;\\n            int cnt=0;\\n            for(int j=i; j<n; j+=k){\\n                cnt++;\\n                s.insert(arr[j]);\\n                auto itr=s.upper_bound(arr[j]);\\n                if(itr!=s.end()){\\n                    s.erase(itr);\\n                }\\n            }\\n            ans+=cnt-s.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int n=arr.size(), ans=0;\\n        for(int i=0; i<k; i++){\\n            multiset<int> s;\\n            int cnt=0;\\n            for(int j=i; j<n; j+=k){\\n                cnt++;\\n                s.insert(arr[j]);\\n                auto itr=s.upper_bound(arr[j]);\\n                if(itr!=s.end()){\\n                    s.erase(itr);\\n                }\\n            }\\n            ans+=cnt-s.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635875,
                "title": "golang-longest-non-dec-subsequence",
                "content": "plenty of explanation about, just gonna include my implementation. I\\'m not aware if goland has a upper bound equivalent method, so i just used the normal sort.SeachInts, adding 1 to the target, to search for the next greater element in `piles`. \\n\\nI was going by the LIS logic, but duplicates are accepted in longest non decreasing subsequence so we need to look for idx of next larger element, instead of idx of element equal to target for the case of strictly increasing subsequence. This kind of tripped me up.\\n\\n```\\nfunc kIncreasing(arr []int, k int) int {\\n    res := 0\\n    \\n    for i := 0; i<k; i++ {  // figure out start point\\n        res += dp(arr, k, i)\\n    }\\n    \\n    return res\\n}\\n\\n// patience sort, LIS technique\\nfunc dp(arr []int, k int, i int) int {\\n    piles := make([]int, 0)\\n    cnt := 0\\n    \\n    for i < len(arr) {\\n        idx := sort.SearchInts(piles, arr[i]+1)\\n        if idx == len(piles) {\\n            piles = append(piles, arr[i])\\n        } else {\\n            piles[idx] = arr[i]\\n        }\\n        cnt++\\n        i+=k\\n        \\n    }\\n\\n    return cnt - len(piles)\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunc kIncreasing(arr []int, k int) int {\\n    res := 0\\n    \\n    for i := 0; i<k; i++ {  // figure out start point\\n        res += dp(arr, k, i)\\n    }\\n    \\n    return res\\n}\\n\\n// patience sort, LIS technique\\nfunc dp(arr []int, k int, i int) int {\\n    piles := make([]int, 0)\\n    cnt := 0\\n    \\n    for i < len(arr) {\\n        idx := sort.SearchInts(piles, arr[i]+1)\\n        if idx == len(piles) {\\n            piles = append(piles, arr[i])\\n        } else {\\n            piles[idx] = arr[i]\\n        }\\n        cnt++\\n        i+=k\\n        \\n    }\\n\\n    return cnt - len(piles)\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1635870,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        \\n        int count=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            List<Integer> lst = new ArrayList<>();\\n            for(int j=i;j<arr.length;j+=k)\\n            {\\n                lst.add(arr[j]);\\n            }\\n            count +=(lst.size()-countLis(lst));\\n        }\\n        return count;\\n    }\\n    private int countLis(List<Integer> list)\\n     {\\n         List<Integer> newList = new ArrayList<>();\\n         for(int i=0;i<list.size();i++)\\n         {\\n             int x = list.get(i);\\n             if(newList.size()==0 || newList.get(newList.size()-1)<=x)\\n             {\\n                 newList.add(x);\\n             }\\n             else\\n             {\\n                 int index = binarySearch(newList, x);\\n                 newList.remove(index);\\n                 newList.add(index, x);\\n             }\\n         }\\n         return newList.size();\\n     }\\n                         \\n    private int binarySearch(List<Integer> list,int x)\\n     {\\n         int l=0,r=list.size()-1;\\n         while(l<r)\\n         {\\n             int mid = l+(r-l)/2;\\n             if(list.get(mid)<=x)\\n             {\\n                 l =mid+1;\\n             }\\n             else\\n             {\\n                 r= mid;\\n             }\\n         }\\n         return l;\\n     }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        \\n        int count=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            List<Integer> lst = new ArrayList<>();\\n            for(int j=i;j<arr.length;j+=k)\\n            {\\n                lst.add(arr[j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1635792,
                "title": "java-lis-modified-binary-search-easy-to-understand-and-detailed-explanation",
                "content": "Example 2:\\n\\nInput: arr = [4,1,5,2,6,2], k = 2\\nOutput: 0\\nExplanation:\\nThis is the same example as the one in the problem description.\\nHere, for every index i where 2 <= i <= 5, arr[i-2] <= arr[i].\\nSince the given array is already K-increasing, we do not need to perform any operations.\\n```\\nIntuition: .Consider the above example: here k distance apart numbers form two subsequences, which upon stored in a arraylist form a  contiguos set.\\n--- [4,5,2] & [1,2,2]\\n    \\n           .Now to find how many correction operations are required on each such contiguous subset we can apply longest increasing\\n           subsequence problems\\' approach, with just a minor upgrade that the duplicates will be allowed i.e. sequences need not to be \\n           strictly increasing. And this much elements donot need correction.\\n    \\n           .Finally we substract the number of elements which donot need correction from arr.length to get the minimum operation required.\\n            Any corrections, suggestions or optimizations to code are welcomed.:)\\n```\\n```\\n//Time complexity: O(k*(len*Log(len)), len is subseq.size();\\n//Auxiliary Space: O(len)\\nclass Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        int followRules = 0;\\n         int len = arr.length;\\n        for(int subAr = 0; subAr < k; subAr++){\\n             ArrayList<Integer> subseq = new ArrayList<>();\\n             for(int indx = subAr; indx<len; indx+=k){\\n                 subseq.add(arr[indx]);\\n             }\\n             followRules += lngstIncSubSeq(subseq); \\n        }\\n        int minOperations = len - followRules;\\n        return minOperations;\\n    }\\n    //It is not strictly increasing subsequence, duplicates are allowed\\n    private int lngstIncSubSeq(ArrayList<Integer>subseq){\\n       int len = subseq.size(), lisLen = 0;\\n        int dp[] = new int[len];\\n        for(int num : subseq){\\n            int insrtIndx = higher(dp, lisLen, num);\\n            if(lisLen == insrtIndx){\\n                lisLen++;\\n            }\\n            dp[insrtIndx] = num;\\n        }\\n        return lisLen;\\n    }\\n    //upper bound excluding num to allow duplicates\\n    private int higher(int arr[], int len, int num){\\n    \\tint left = 0, right = len-1, res = len;\\n    \\twhile(left <= right){\\n    \\t\\tint mid = (left + right) >> 1;\\n           //Also ignoring duplicates while finding upper bound. \\n    \\t\\tif(arr[mid] <= num){\\n    \\t\\t\\tleft = mid+1;\\n    \\t\\t}else{\\n    \\t\\t\\tres = mid;\\n    \\t\\t\\tright = mid-1;\\n    \\t\\t}\\n    \\t}\\n    \\treturn res;\\n    }\\n}\\n```\\nIf you found this post helpful then please like and comment to increase it\\'s reach. :)",
                "solutionTags": [],
                "code": "```\\nIntuition: .Consider the above example: here k distance apart numbers form two subsequences, which upon stored in a arraylist form a  contiguos set.\\n--- [4,5,2] & [1,2,2]\\n    \\n           .Now to find how many correction operations are required on each such contiguous subset we can apply longest increasing\\n           subsequence problems\\' approach, with just a minor upgrade that the duplicates will be allowed i.e. sequences need not to be \\n           strictly increasing. And this much elements donot need correction.\\n    \\n           .Finally we substract the number of elements which donot need correction from arr.length to get the minimum operation required.\\n            Any corrections, suggestions or optimizations to code are welcomed.:)\\n```\n```\\n//Time complexity: O(k*(len*Log(len)), len is subseq.size();\\n//Auxiliary Space: O(len)\\nclass Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        int followRules = 0;\\n         int len = arr.length;\\n        for(int subAr = 0; subAr < k; subAr++){\\n             ArrayList<Integer> subseq = new ArrayList<>();\\n             for(int indx = subAr; indx<len; indx+=k){\\n                 subseq.add(arr[indx]);\\n             }\\n             followRules += lngstIncSubSeq(subseq); \\n        }\\n        int minOperations = len - followRules;\\n        return minOperations;\\n    }\\n    //It is not strictly increasing subsequence, duplicates are allowed\\n    private int lngstIncSubSeq(ArrayList<Integer>subseq){\\n       int len = subseq.size(), lisLen = 0;\\n        int dp[] = new int[len];\\n        for(int num : subseq){\\n            int insrtIndx = higher(dp, lisLen, num);\\n            if(lisLen == insrtIndx){\\n                lisLen++;\\n            }\\n            dp[insrtIndx] = num;\\n        }\\n        return lisLen;\\n    }\\n    //upper bound excluding num to allow duplicates\\n    private int higher(int arr[], int len, int num){\\n    \\tint left = 0, right = len-1, res = len;\\n    \\twhile(left <= right){\\n    \\t\\tint mid = (left + right) >> 1;\\n           //Also ignoring duplicates while finding upper bound. \\n    \\t\\tif(arr[mid] <= num){\\n    \\t\\t\\tleft = mid+1;\\n    \\t\\t}else{\\n    \\t\\t\\tres = mid;\\n    \\t\\t\\tright = mid-1;\\n    \\t\\t}\\n    \\t}\\n    \\treturn res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635753,
                "title": "c-solution-using-multiset",
                "content": "```\\nclass Solution {\\npublic:\\n    int lis(vector<int>&v)\\n    {\\n        int n=v.size();\\n        multiset<int>s;\\n        for(int i=0;i<n;i++)\\n        {\\n            auto it=s.upper_bound(v[i]);\\n            if(it!=s.end())\\n            {\\n                s.erase(it);\\n            }\\n            s.insert(v[i]);\\n        }\\n        return n-s.size();\\n    }\\n    int kIncreasing(vector<int>& nums, int k) \\n    {\\n        int count=0;\\n        int n=nums.size();\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int>v;\\n            for(int j=i;j<n;j+=k)\\n            {\\n                v.push_back(nums[j]);\\n            }\\n            count+=lis(v);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lis(vector<int>&v)\\n    {\\n        int n=v.size();\\n        multiset<int>s;\\n        for(int i=0;i<n;i++)\\n        {\\n            auto it=s.upper_bound(v[i]);\\n            if(it!=s.end())\\n            {\\n                s.erase(it);\\n            }\\n            s.insert(v[i]);\\n        }\\n        return n-s.size();\\n    }\\n    int kIncreasing(vector<int>& nums, int k) \\n    {\\n        int count=0;\\n        int n=nums.size();\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int>v;\\n            for(int j=i;j<n;j+=k)\\n            {\\n                v.push_back(nums[j]);\\n            }\\n            count+=lis(v);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635557,
                "title": "longest-non-decreasing-subsequence",
                "content": "in this question we are given a array let say size 10  (0,1,2,3,4,5,6,7,8,9)( indicies of array) now if value of k is let say 3 then\\n\\n0 3 6 9\\n1 4 7\\n2 5 8\\n3 7 \\nthis 4 arrays we have to make non decreasing and this 4 arrays are independent from each other\\n\\nnow to make array non decreasing we use Longest non decreasing subseq (nlogn)   approach as if we find a LIS then the remaing element which is not in LIS we have to change it\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int LIS(vector<int> &arr)\\n    {\\n      \\n        int n=arr.size();\\n        vector<int> tail;\\n     \\n        tail.push_back(arr[0]);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(arr[i]>=tail[tail.size()-1])\\n            {\\n                tail.push_back(arr[i]);\\n            }\\n            else\\n            {\\n                auto upper=upper_bound(tail.begin(),tail.end(),arr[i]);\\n                \\n                int idx=upper-tail.begin();\\n                tail[idx]=arr[i];\\n            }   \\n        }\\n        \\n        \\n        return tail.size();\\n        \\n        \\n        \\n        \\n    }\\n    \\n    \\n    \\n    int kIncreasing(vector<int>& arr, int k) {\\n        \\n        int count=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> temp;\\n            for(int j=i;j<arr.size();j+=k)\\n            {\\n                temp.push_back(arr[j]);\\n            }\\n            int lis=LIS(temp);\\n            \\n            count=count+(temp.size()-lis);\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int LIS(vector<int> &arr)\\n    {\\n      \\n        int n=arr.size();\\n        vector<int> tail;\\n     \\n        tail.push_back(arr[0]);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(arr[i]>=tail[tail.size()-1])\\n            {\\n                tail.push_back(arr[i]);\\n            }\\n            else\\n            {\\n                auto upper=upper_bound(tail.begin(),tail.end(),arr[i]);\\n                \\n                int idx=upper-tail.begin();\\n                tail[idx]=arr[i];\\n            }   \\n        }\\n        \\n        \\n        return tail.size();\\n        \\n        \\n        \\n        \\n    }\\n    \\n    \\n    \\n    int kIncreasing(vector<int>& arr, int k) {\\n        \\n        int count=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> temp;\\n            for(int j=i;j<arr.size();j+=k)\\n            {\\n                temp.push_back(arr[j]);\\n            }\\n            int lis=LIS(temp);\\n            \\n            count=count+(temp.size()-lis);\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635397,
                "title": "longest-non-decreasing-subsequence-128-ms",
                "content": "```\\nint lis[100\\'000 + 1];\\n\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        lis[0] = 0;\\n        \\n        int ans = 0;\\n        for (int i = 0; i < k; ++i) {\\n            \\n            int lis_n = 1;\\n            \\n            int n = 0;\\n            for (int j = i; j < arr.size(); j += k) {\\n                n++;\\n                \\n                int &v = arr[j];\\n                \\n                auto it = upper_bound(lis, lis + lis_n, v);\\n                *it = v;\\n                if (it == lis + lis_n) {\\n                    lis_n++;\\n                }\\n            }\\n            ans += n - (lis_n - 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint lis[100\\'000 + 1];\\n\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        lis[0] = 0;\\n        \\n        int ans = 0;\\n        for (int i = 0; i < k; ++i) {\\n            \\n            int lis_n = 1;\\n            \\n            int n = 0;\\n            for (int j = i; j < arr.size(); j += k) {\\n                n++;\\n                \\n                int &v = arr[j];\\n                \\n                auto it = upper_bound(lis, lis + lis_n, v);\\n                *it = v;\\n                if (it == lis + lis_n) {\\n                    lis_n++;\\n                }\\n            }\\n            ans += n - (lis_n - 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635351,
                "title": "c-longest-non-decreasing-sequence-only-1-time",
                "content": "We have given k independent sequences and we have to find longest increasing sequence of all the sequences. Either we can divide input array in k sequences and find LIS for each of them or we can do it in one go.(in one for loop).\\n\\nTime complexity **o(n*log(n))**\\nSpace complexity **o(n)**\\n\\n\\nI have solved this problem by finding LIS of all sequences in one go.  check code given below and let me know if any further explanation is required .\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        \\n        \\n        int n=arr.size();\\n        int count=0;\\n        \\n        \\n        // vector to store elements in sorted order\\n        vector<int> t(n,0);\\n        \\n        // vector to store length of different sequences\\n        // i.e len[i] will have length of sequence of indices [i,i+k,i+2*k ...]\\n        vector<int> len(k,1);\\n        \\n        \\n        //set first elements of each sequence\\n        for(int i=0;i<k;i++)\\n            t[i]=arr[i];\\n        \\n        \\n        \\n    \\n        for(int i=k;i<n;i++)\\n        {\\n            // m is a sequence number\\n            int m=i%k;\\n            \\n            // if arr[i] is lesser than first element of sequence then assign it as first element of sequence\\n            if(t[m]>arr[i])\\n               t[m]=arr[i];\\n            // if arr[i] is greater or equal to last element of the sequence then assign it as a last element and increase length of a sequence\\n            else if(arr[i]>=t[k*(len[m]-1)+m])\\n                 t[k*(len[m]++)+m]=arr[i];\\n            // find the index of smallest element of sequence m which is larger than arr[i] and assign it there\\n            else\\n            {\\n                int l=0,r=len[i%k]-1;\\n                int ind=r;\\n                while(l<=r)\\n                {\\n                    int mid=(l+r)/2;\\n                    int in=mid*k+i%k;\\n                    if(t[in]>arr[i]){\\n                        ind=min(mid,ind);\\n                        r=mid-1;\\n                    }\\n                    else\\n                        l=mid+1;\\n                }\\n                t[ind*k+i%k]=arr[i];\\n            }\\n               \\n        }\\n        \\n        // sum up length of all sequences in count and return n-count\\n        for(int i:len)\\n            count+=i;\\n        \\n        \\n        \\n        return n-count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        \\n        \\n        int n=arr.size();\\n        int count=0;\\n        \\n        \\n        // vector to store elements in sorted order\\n        vector<int> t(n,0);\\n        \\n        // vector to store length of different sequences\\n        // i.e len[i] will have length of sequence of indices [i,i+k,i+2*k ...]\\n        vector<int> len(k,1);\\n        \\n        \\n        //set first elements of each sequence\\n        for(int i=0;i<k;i++)\\n            t[i]=arr[i];\\n        \\n        \\n        \\n    \\n        for(int i=k;i<n;i++)\\n        {\\n            // m is a sequence number\\n            int m=i%k;\\n            \\n            // if arr[i] is lesser than first element of sequence then assign it as first element of sequence\\n            if(t[m]>arr[i])\\n               t[m]=arr[i];\\n            // if arr[i] is greater or equal to last element of the sequence then assign it as a last element and increase length of a sequence\\n            else if(arr[i]>=t[k*(len[m]-1)+m])\\n                 t[k*(len[m]++)+m]=arr[i];\\n            // find the index of smallest element of sequence m which is larger than arr[i] and assign it there\\n            else\\n            {\\n                int l=0,r=len[i%k]-1;\\n                int ind=r;\\n                while(l<=r)\\n                {\\n                    int mid=(l+r)/2;\\n                    int in=mid*k+i%k;\\n                    if(t[in]>arr[i]){\\n                        ind=min(mid,ind);\\n                        r=mid-1;\\n                    }\\n                    else\\n                        l=mid+1;\\n                }\\n                t[ind*k+i%k]=arr[i];\\n            }\\n               \\n        }\\n        \\n        // sum up length of all sequences in count and return n-count\\n        for(int i:len)\\n            count+=i;\\n        \\n        \\n        \\n        return n-count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635339,
                "title": "java-longest-non-decreasing-subsequence",
                "content": "```\\nclass Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        int len = arr.length;\\n        int mod = len % k;\\n        int sum = 0;\\n        for(int i=0; i<k; i++)\\n        {\\n            int dpLen = len / k + (i < mod ? 1 : 0);\\n            int[] dp = new int[dpLen];\\n            int curLen = 0;\\n            for(int j=i; j<len; j+=k)\\n            {\\n                int index = binarySearch(dp, 0, curLen, arr[j]);\\n                dp[index] = arr[j];\\n                if(index == curLen)\\n                curLen++;\\n            }\\n            sum += (dpLen - curLen);\\n        }\\n        return sum;\\n    }\\n    \\n    private int binarySearch(int[] a, int fromIndex, int toIndex,\\n                                     int key) {\\n        int low = fromIndex;\\n        int high = toIndex - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) >>> 1;\\n            int midVal = a[mid];\\n\\n            if (midVal <= key)\\n                low = mid + 1;\\n            else if (midVal > key)\\n                high = mid - 1;\\n        }\\n        return low;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        int len = arr.length;\\n        int mod = len % k;\\n        int sum = 0;\\n        for(int i=0; i<k; i++)\\n        {\\n            int dpLen = len / k + (i < mod ? 1 : 0);\\n            int[] dp = new int[dpLen];\\n            int curLen = 0;\\n            for(int j=i; j<len; j+=k)\\n            {\\n                int index = binarySearch(dp, 0, curLen, arr[j]);\\n                dp[index] = arr[j];\\n                if(index == curLen)\\n                curLen++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1635306,
                "title": "fastest-c-solution-using-lis",
                "content": "```\\nclass Solution {\\npublic:\\nint LongestIncreasingSubsequenceLength(std::vector<int>& v)\\n{\\n    if (v.size() == 0) // boundary case\\n        return 0;\\n \\n    std::vector<int> tail(v.size(), 0);\\n    int length = 1; // always points empty slot in tail\\n \\n    tail[0] = v[0];\\n \\n    for (int i = 1; i < v.size(); i++) {\\n \\n        // Do binary search for the element in\\n        // the range from begin to begin + length\\n        auto b = tail.begin(), e = tail.begin() + length;\\n        auto it = upper_bound(b, e, v[i]);\\n \\n        // If not present change the tail element to v[i]\\n        if (it == tail.begin() + length)\\n            tail[length++] = v[i];\\n        else\\n            *it = v[i];\\n    }\\n \\n    return length;\\n}\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int op=0;\\n        vector<vector<int>>v(k+1);\\n        for(int i=0;i<n;i++){\\n            v[i%k].push_back(arr[i]);\\n        }\\n        int ans=0;\\n        for(int i=0;i<k;i++){\\n            int len=LongestIncreasingSubsequenceLength(v[i]);\\n            ans+=v[i].size()-len;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nint LongestIncreasingSubsequenceLength(std::vector<int>& v)\\n{\\n    if (v.size() == 0) // boundary case\\n        return 0;\\n \\n    std::vector<int> tail(v.size(), 0);\\n    int length = 1; // always points empty slot in tail\\n \\n    tail[0] = v[0];\\n \\n    for (int i = 1; i < v.size(); i++) {\\n \\n        // Do binary search for the element in\\n        // the range from begin to begin + length\\n        auto b = tail.begin(), e = tail.begin() + length;\\n        auto it = upper_bound(b, e, v[i]);\\n \\n        // If not present change the tail element to v[i]\\n        if (it == tail.begin() + length)\\n            tail[length++] = v[i];\\n        else\\n            *it = v[i];\\n    }\\n \\n    return length;\\n}\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int op=0;\\n        vector<vector<int>>v(k+1);\\n        for(int i=0;i<n;i++){\\n            v[i%k].push_back(arr[i]);\\n        }\\n        int ans=0;\\n        for(int i=0;i<k;i++){\\n            int len=LongestIncreasingSubsequenceLength(v[i]);\\n            ans+=v[i].size()-len;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635283,
                "title": "similar-to-longest-increasing-subsequence-explanation-c-code-well-commented",
                "content": "Observation: \\nThere array can be converted into k arrays and we have to ensure each of them is individually non-decreasing.\\n\\nIdea:\\nWe can find the longest subsequence that follows our condition and change the rest of the elements. So we find the length of the longest non decresing subsequence of that particular array out of the k arrays and subtract it from the size of that array.\\n\\nNote: \\nEach of the k arrays can be uniquely identified by the starting index which will be less than k. \\n\\nSize of our array starting at index i: 1 + (N-i-1)/k;\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int ans = 0;\\n        int n = arr.size();\\n        for(int i=0; i<k; i++) {\\n            int numElems = 1 + (n-i-1)/k; //Num of elements in the ith array\\n\\t\\t\\t//We don\\'t need to create the whole array, just the stating index i uniquely identifies it.\\n            ans+= numElems - longestNonDecreasing(arr, k, i);  \\n        }\\n        return ans;\\n    }\\n    \\n    int longestNonDecreasing(vector<int>& arr, int k, int start) {\\n        vector<int> sub;  //to store the longest non-decresing subsequence\\n        for(int i=start; i<arr.size(); i+=k) {  //jump k steps to simulate the array\\n            if(sub.empty() || sub[sub.size()-1] <= arr[i]) {\\n                sub.push_back(arr[i]);\\n            } else {   //find the first element greater than arr[i] and replace it with arr[i]\\n                int index = upper_bound(sub.begin(), sub.end(), arr[i]) - sub.begin();  \\n                sub[index] = arr[i];\\n            }\\n        }\\n        return sub.size();  //return the size of the longest non-decresing subsequnce.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int ans = 0;\\n        int n = arr.size();\\n        for(int i=0; i<k; i++) {\\n            int numElems = 1 + (n-i-1)/k; //Num of elements in the ith array\\n\\t\\t\\t//We don\\'t need to create the whole array, just the stating index i uniquely identifies it.\\n            ans+= numElems - longestNonDecreasing(arr, k, i);  \\n        }\\n        return ans;\\n    }\\n    \\n    int longestNonDecreasing(vector<int>& arr, int k, int start) {\\n        vector<int> sub;  //to store the longest non-decresing subsequence\\n        for(int i=start; i<arr.size(); i+=k) {  //jump k steps to simulate the array\\n            if(sub.empty() || sub[sub.size()-1] <= arr[i]) {\\n                sub.push_back(arr[i]);\\n            } else {   //find the first element greater than arr[i] and replace it with arr[i]\\n                int index = upper_bound(sub.begin(), sub.end(), arr[i]) - sub.begin();  \\n                sub[index] = arr[i];\\n            }\\n        }\\n        return sub.size();  //return the size of the longest non-decresing subsequnce.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635239,
                "title": "javascript-lis-with-upper-bound-401ms",
                "content": "```\\n////////////////////////////////////// Template ///////////////////////////////////////////////////\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            x < a[mid] ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nconst kIncreasing = (A, k) => {\\n    let n = A.length;\\n    let res = 0;\\n    let d = []; // get each kth array\\n    for (let start = 0; start < k; start++) {\\n        let re = [], i;\\n        for (i = start; i + k < n; i += k) re.push(A[i]);\\n        re.push(A[i])\\n        d.push(re);\\n    }\\n    for (const a of d) res += LIS(a);\\n    return n - res;\\n};\\n\\nconst LIS = (a) => {\\n    let bi = new Bisect(), dp = [], n = a.length;\\n    for (const x of a) {\\n        let idx = bi.bisect_right(dp, x);\\n        if (idx == n) {\\n            dp.push(x);\\n        } else {\\n            dp[idx] = x;\\n        }\\n    }\\n    return dp.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\n////////////////////////////////////// Template ///////////////////////////////////////////////////\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            x < a[mid] ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nconst kIncreasing = (A, k) => {\\n    let n = A.length;\\n    let res = 0;\\n    let d = []; // get each kth array\\n    for (let start = 0; start < k; start++) {\\n        let re = [], i;\\n        for (i = start; i + k < n; i += k) re.push(A[i]);\\n        re.push(A[i])\\n        d.push(re);\\n    }\\n    for (const a of d) res += LIS(a);\\n    return n - res;\\n};\\n\\nconst LIS = (a) => {\\n    let bi = new Bisect(), dp = [], n = a.length;\\n    for (const x of a) {\\n        let idx = bi.bisect_right(dp, x);\\n        if (idx == n) {\\n            dp.push(x);\\n        } else {\\n            dp[idx] = x;\\n        }\\n    }\\n    return dp.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1635216,
                "title": "python-easy-lis-solution",
                "content": "Longest Non-Decreasing Subsequence\\n```python3\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        \\n        def lis(nums):\\n            \\'\\'\\'\\n            Patience sort\\n            Time: O(NlogN)\\n            Space: O(N)\\n            \\'\\'\\'\\n            n = len(nums)\\n            if n <= 1:\\n                return n\\n            # num, pointer\\n            c = []\\n            size = 0\\n\\n            for x in nums:\\n\\t\\t\\t    # bisect as it is non-decreasing\\n                l = bisect.bisect_right(c, x)\\n                if l < size:\\n                    c[l] = x\\n                else:\\n                    c.append(x)\\n                    size = max(size, l+1)\\n\\n            return size\\n        \\n        ans = 0\\n        for i in range(k):\\n            sub = []\\n            for j in range(i, n, k):\\n                sub.append(arr[j])\\n            ans += len(sub) - lis(sub)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python3\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        \\n        def lis(nums):\\n            \\'\\'\\'\\n            Patience sort\\n            Time: O(NlogN)\\n            Space: O(N)\\n            \\'\\'\\'\\n            n = len(nums)\\n            if n <= 1:\\n                return n\\n            # num, pointer\\n            c = []\\n            size = 0\\n\\n            for x in nums:\\n\\t\\t\\t    # bisect as it is non-decreasing\\n                l = bisect.bisect_right(c, x)\\n                if l < size:\\n                    c[l] = x\\n                else:\\n                    c.append(x)\\n                    size = max(size, l+1)\\n\\n            return size\\n        \\n        ans = 0\\n        for i in range(k):\\n            sub = []\\n            for j in range(i, n, k):\\n                sub.append(arr[j])\\n            ans += len(sub) - lis(sub)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635215,
                "title": "c-8-liners-solution-with-lis-in-essence",
                "content": "```\\nint kIncreasing(vector<int>& arr, int k) \\n{\\n\\tint result=0,n=arr.size();\\n\\n\\tfor(int i=0;i<k;i++)\\n\\t{\\n\\t\\tvector<int> total; // LIS\\n\\t\\tfor(int j=i;j<n;j+=k)\\n\\t\\t\\tif(total.empty()||arr[j]>=total.back()) total.push_back(arr[j]); // push to last if arr[i] is non-decreasing\\n\\t\\t\\telse *upper_bound(total.begin(),total.end(),arr[j])=arr[j]; // else just replace an element in the non-decreasing array\\n\\n\\t\\tresult+=total.size();\\n\\t}\\n\\treturn n-result; // array length minus the non-overlapping LIS arrays length sum\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint kIncreasing(vector<int>& arr, int k) \\n{\\n\\tint result=0,n=arr.size();\\n\\n\\tfor(int i=0;i<k;i++)\\n\\t{\\n\\t\\tvector<int> total; // LIS\\n\\t\\tfor(int j=i;j<n;j+=k)\\n\\t\\t\\tif(total.empty()||arr[j]>=total.back()) total.push_back(arr[j]); // push to last if arr[i] is non-decreasing\\n\\t\\t\\telse *upper_bound(total.begin(),total.end(),arr[j])=arr[j]; // else just replace an element in the non-decreasing array\\n\\n\\t\\tresult+=total.size();\\n\\t}\\n\\treturn n-result; // array length minus the non-overlapping LIS arrays length sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1635212,
                "title": "java-advanced-longest-non-decreasing-subsequence",
                "content": "Please see No. 300 for explains.\\nHere we just need to execute it for several times\\nNote, it allows equal case here\\n```\\nclass Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        if (k >= arr.length) return 0;\\n        if (k == 1) return minOperations(arr);\\n        List<List<Integer>> buckets = new ArrayList<>();\\n        for (int i = 0; i < k; i++) buckets.add(new ArrayList<>());\\n        for (int i = 0; i < arr.length; i++) buckets.get(i % k).add(arr[i]);\\n        int res = 0;\\n        for (List<Integer> bucket : buckets) res += minOperations(bucket.stream().mapToInt(Integer::intValue).toArray());\\n        return res;\\n    }\\n    \\n    private int minOperations(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n        int[] dp = new int[nums.length];\\n        int size = 0;\\n        for (int num : nums) {\\n            int l = 0, r = size, m = 0;\\n            while (l < r) {\\n                m = l + (r - l) / 2;\\n                if (dp[m] <= num) l = m + 1;\\n                else r = m;\\n            }\\n            dp[l] = num;\\n            if (l == size) size++;\\n        }\\n        return nums.length - size;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        if (k >= arr.length) return 0;\\n        if (k == 1) return minOperations(arr);\\n        List<List<Integer>> buckets = new ArrayList<>();\\n        for (int i = 0; i < k; i++) buckets.add(new ArrayList<>());\\n        for (int i = 0; i < arr.length; i++) buckets.get(i % k).add(arr[i]);\\n        int res = 0;\\n        for (List<Integer> bucket : buckets) res += minOperations(bucket.stream().mapToInt(Integer::intValue).toArray());\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1635192,
                "title": "what-s-wrong-with-this-intuitive-solution",
                "content": "As title,\\n\\nI only could come up this brute force solution during the contest :(\\nI know it\\'s not optimal, just want to know why this idea is wrong?\\n\\nIdea: If the sequence is not matched, modify `arr[i]` or `arr[i+k]`, and find the min one.\\n\\nCode:\\n\\n    int min_mod(vector<int>& arr, int i, int k){\\n        if(i+k >= arr.size())\\n            return 0;\\n        if(arr[i] > arr[i+k]){\\n            // change arr[i]\\n            int tmp = arr[i];\\n            arr[i] = arr[i+k];\\n            int mod_i = 1 + min_mod(arr, i+k, k);\\n            arr[i] = tmp;\\n            \\n            // change arr[i+k]\\n            tmp = arr[i+k];\\n            arr[i+k] = arr[i];\\n            int mod_ik = 1 + min_mod(arr, i+k, k);\\n            arr[i+k] = tmp;\\n            return min(mod_i, mod_ik);\\n        }\\n        return min_mod(arr, i+k, k);\\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int ans = 0;\\n        for(int i = 0 ; i < k ; i++){\\n            ans += min_mod(arr, i, k);\\n        }\\n        return ans;\\n    }\\n\\nHowever, it couldn\\'t pass the following test case.\\n```\\nInput:\\n[12,6,12,6,14,2,13,17,3,8,11,7,4,11,18,8,8,3]\\n1\\nOutput:\\n8\\nExpected:\\n12\\n```\\n\\nCould any one tell me why?\\nThanks a lot!!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nInput:\\n[12,6,12,6,14,2,13,17,3,8,11,7,4,11,18,8,8,3]\\n1\\nOutput:\\n8\\nExpected:\\n12\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1635185,
                "title": "lis-with-binary-search-in-c",
                "content": "```\\n    int check(vector<int>& nums){        \\n        vector<int> lis;\\n        for(auto n : nums){\\n            auto it = upper_bound(lis.begin(), lis.end(), n);\\n            if(it == lis.end())\\n                lis.push_back(n);\\n            else if(n < *it)\\n                *it = n;\\n        }\\n        return nums.size() - lis.size();\\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int ret = 0;\\n        for(int i=0; i<k; ++i){\\n            vector<int> tmp;\\n            int j=i;\\n            while(j<arr.size()){\\n                tmp.push_back(arr[j]);\\n                j += k;\\n            }\\n            ret += check(tmp);\\n        }\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int check(vector<int>& nums){        \\n        vector<int> lis;\\n        for(auto n : nums){\\n            auto it = upper_bound(lis.begin(), lis.end(), n);\\n            if(it == lis.end())\\n                lis.push_back(n);\\n            else if(n < *it)\\n                *it = n;\\n        }\\n        return nums.size() - lis.size();\\n    }\\n    int kIncreasing(vector<int>& arr, int k) {\\n        int ret = 0;\\n        for(int i=0; i<k; ++i){\\n            vector<int> tmp;\\n            int j=i;\\n            while(j<arr.size()){\\n                tmp.push_back(arr[j]);\\n                j += k;\\n            }\\n            ret += check(tmp);\\n        }\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1635165,
                "title": "java-longest-increasing-subsequence",
                "content": "**Longest decreasing Subsequence**\\n[300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)\\nhere **lis** = longest increasing subsequence\\narr = [4, 1, 5, 2, 6, 2] is K-increasing for k = 2\\n1. find lis of arr with index [0, 2, 4,....]\\n\\tfind lis of arr with index [1, 3, 5,....] ... k times\\n2. we add all the length of all longest increasing subsequence\\n3. subract the length of array with cumulative lis sum\\n\\n```\\nint n=arr.length, res=0;\\nint dp[] = new int[n/k+5];\\nfor(int i=0; i<k; i++){\\n\\tint lis=0;\\n\\tArrays.fill(dp, 0);\\n\\tfor(int j=i; j<n; j+=k){ // increment in steps of k\\n\\t\\tint low = 0, high=lis;\\n\\t\\t// binary search\\n\\t\\twhile(low<high){\\n\\t\\t\\tint mid = (low + high) >> 1;\\n\\t\\t\\tif(arr[j] < dp[mid]){\\n\\t\\t\\t\\thigh = mid;\\n\\t\\t\\t} else low = mid + 1;\\n\\t\\t}\\n\\t\\tdp[low] = arr[j];\\n\\t\\tif(high == lis) lis++;                \\n\\t}\\n\\tres += lis;\\n}\\n// subract cumulative lis from length\\nreturn n-res;\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nint n=arr.length, res=0;\\nint dp[] = new int[n/k+5];\\nfor(int i=0; i<k; i++){\\n\\tint lis=0;\\n\\tArrays.fill(dp, 0);\\n\\tfor(int j=i; j<n; j+=k){ // increment in steps of k\\n\\t\\tint low = 0, high=lis;\\n\\t\\t// binary search\\n\\t\\twhile(low<high){\\n\\t\\t\\tint mid = (low + high) >> 1;\\n\\t\\t\\tif(arr[j] < dp[mid]){\\n\\t\\t\\t\\thigh = mid;\\n\\t\\t\\t} else low = mid + 1;\\n\\t\\t}\\n\\t\\tdp[low] = arr[j];\\n\\t\\tif(high == lis) lis++;                \\n\\t}\\n\\tres += lis;\\n}\\n// subract cumulative lis from length\\nreturn n-res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1635158,
                "title": "python-longest-increasing-subsequence",
                "content": "For the strict increasing subsequence, we use bisect_left instead of bisect_right.\\nFor this problem, we use bisect_right.\\n```\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        \\n        def operations(nums):\\n            sub = []\\n            for i, x in enumerate(nums):\\n                if len(sub) == 0 or sub[-1] <= x:\\n                    sub.append(x)\\n                else:\\n                    idx = bisect.bisect_right(sub, x)\\n                    sub[idx] = x\\n\\t\\t\\t# the number of operations = length of nums - length of the longest non-decreasing subsequence\\n            return len(nums) - len(sub)\\n        \\n        res = 0\\n\\t\\t# consider nums = [arr[0], arr[k],...]; nums = [arr[1], arr[1+k],...]\\n        for i in range(k):\\n            nums = []\\n            for j in range(i, len(arr), k):\\n                nums.append(arr[j])\\n            res += operations(nums)\\n        \\n        return res",
                "solutionTags": [
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "For the strict increasing subsequence, we use bisect_left instead of bisect_right.\\nFor this problem, we use bisect_right.\\n```\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        \\n        def operations(nums):\\n            sub = []\\n            for i, x in enumerate(nums):\\n                if len(sub) == 0 or sub[-1] <= x:\\n                    sub.append(x)\\n                else:\\n                    idx = bisect.bisect_right(sub, x)\\n                    sub[idx] = x\\n\\t\\t\\t# the number of operations = length of nums - length of the longest non-decreasing subsequence\\n            return len(nums) - len(sub)\\n        \\n        res = 0\\n\\t\\t# consider nums = [arr[0], arr[k],...]; nums = [arr[1], arr[1+k],...]\\n        for i in range(k):\\n            nums = []\\n            for j in range(i, len(arr), k):\\n                nums.append(arr[j])\\n            res += operations(nums)\\n        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1635138,
                "title": "easiest-c-using-lis",
                "content": "int lis(vector<int> const& a) {\\n    int n = a.size();\\n    const int INF = 1e9;\\n    vector<int> d(n+1, INF);\\n    d[0] = -INF;\\n\\n    for (int i = 0; i < n; i++) {\\n        int j = upper_bound(d.begin(), d.end(), a[i]) - d.begin();\\n        if (d[j-1] <= a[i] && a[i] < d[j])\\n            d[j] = a[i];\\n    }\\n\\n    int ans = 0;\\n    for (int i = 0; i <= n; i++) {\\n        if (d[i] < INF)\\n            ans = i;\\n    }\\n    return ans;\\n}\\nclass Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        \\n        int ans = 0;\\n        for (int i = 0; i < k; i += 1) {\\n            vector<int> v;\\n            for (int j = i; j < arr.size(); j += k)\\n                v.push_back(arr[j]);\\n            ans += v.size() - lis(v);\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int kIncreasing(vector<int>& arr, int k) {\\n        \\n        int ans = 0;\\n        for (int i = 0; i < k; i += 1) {\\n            vector<int> v;\\n            for (int j = i; j < arr.size(); j += k)\\n                v.push_back(arr[j]);\\n            ans += v.size() - lis(v);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1635114,
                "title": "python-sort-and-simple-patience-sort",
                "content": "# What\\'s all this then?\\n\\nHere\\'s the gist, when one finds any non-decreasing sequence Nsub in an input array Arr, the values left are the only ones that need to be changed to make the array non-decreasing, therefore if we take the length of Arr and subtract the length on NSub, we find the elements that need to be changed to make the array strictly non-decreasing. The length of this array can be found using patience sorting.\\n\\n```\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        newArr = [[] for i in range(k)] #Make our lives a little easier and split each into groups based on it\\'s k value\\n        for i, num in enumerate(arr):\\n            newArr[(i%k) - 1].append(num)\\n        def longestNonDecreasing(nums): #For each k group, find the longest nondecreasing sequence\\n            max = 0\\n            dp = []\\n            for i in range(len(nums)):\\n                idx = bisect_left(dp,nums[i])\\n                if idx < len(dp) and dp[idx] == nums[i]:\\n                    idx = bisect_left(dp,nums[i] + 1)\\n                if idx < len(dp):\\n                    dp[idx] = nums[i]\\n                else: dp.append(nums[i])\\n                if idx == max: max += 1\\n            return len(nums) - max\\n        return sum(longestNonDecreasing(nums) for nums in newArr)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        newArr = [[] for i in range(k)] #Make our lives a little easier and split each into groups based on it\\'s k value\\n        for i, num in enumerate(arr):\\n            newArr[(i%k) - 1].append(num)\\n        def longestNonDecreasing(nums): #For each k group, find the longest nondecreasing sequence\\n            max = 0\\n            dp = []\\n            for i in range(len(nums)):\\n                idx = bisect_left(dp,nums[i])\\n                if idx < len(dp) and dp[idx] == nums[i]:\\n                    idx = bisect_left(dp,nums[i] + 1)\\n                if idx < len(dp):\\n                    dp[idx] = nums[i]\\n                else: dp.append(nums[i])\\n                if idx == max: max += 1\\n            return len(nums) - max\\n        return sum(longestNonDecreasing(nums) for nums in newArr)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2025445,
                "content": [
                    {
                        "username": "JigglyyPuff",
                        "content": "` `def lis(i, prev, nums):\n            if i < 0:\n                return 0\n            notTake = lis(i-1, prev, nums)\n            take = 0\n            if prev == len(nums) or nums[i] < nums[prev]:\n                take = 1 + lis(i-1, i, nums)\n            return max(take, notTake)\n        ans = 0\n        for i in range(k):\n            nums = []\n            for j in range(i, len(arr), k):\n                nums.append(arr[j])\n            n = len(nums)\n            maxLIS = lis(n-1, n, nums)\n            ans +=  (n - maxLIS)\n        return ans.``\n\nCan someone tell me why this doesnt work?"
                    }
                ]
            }
        ]
    }
]