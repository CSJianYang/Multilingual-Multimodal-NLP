[
    {
        "title": "Range Sum of BST",
        "question_content": "Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high].\n&nbsp;\nExample 1:\n\nInput: root = [10,5,15,3,7,null,18], low = 7, high = 15\nOutput: 32\nExplanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.\n\nExample 2:\n\nInput: root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10\nOutput: 23\nExplanation: Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23.\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [1, 2 * 104].\n\t1 <= Node.val <= 105\n\t1 <= low <= high <= 105\n\tAll Node.val are unique.",
        "solutions": [
            {
                "id": 192019,
                "title": "java-python-3-3-similar-recursive-and-1-iterative-methods-w-comment-analysis",
                "content": "Three similar recursive and one iterative methods, choose one you like.\\n\\n**Method 1:**\\n```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) return 0; // base case.\\n        if (root.val < L) return rangeSumBST(root.right, L, R); // left branch excluded.\\n        if (root.val > R) return rangeSumBST(root.left, L, R); // right branch excluded.\\n        return root.val + rangeSumBST(root.right, L, R) + rangeSumBST(root.left, L, R); // count in both children.\\n    }\\n```\\n```\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        elif root.val < L:\\n            return self.rangeSumBST(root.right, L, R)\\n        elif root.val > R:\\n            return self.rangeSumBST(root.left, L, R)\\n        return root.val + self.rangeSumBST(root.left, L, R) + self.rangeSumBST(root.right, L, R)\\n```\\nThe following are two more similar recursive codes.\\n\\n**Method 2:**\\n```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) return 0; // base case.\\n        return (L <= root.val && root.val <= R ? root.val : 0) + rangeSumBST(root.right, L, R) + rangeSumBST(root.left, L, R);\\n    }\\n```\\n```\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        return self.rangeSumBST(root.left, L, R) + \\\\\\n                self.rangeSumBST(root.right, L, R) + \\\\\\n                (root.val if L <= root.val <= R else 0)\\n```\\n**Method 3:**\\n```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) { return 0; }\\n        int sum = 0;\\n        if (root.val > L) { sum += rangeSumBST(root.left, L, R); } // left child is a possible candidate.\\n        if (root.val < R) { sum += rangeSumBST(root.right, L, R); } // right child is a possible candidate.\\n        if (root.val >= L && root.val <= R) { sum += root.val; } // count root in.\\n        return sum;\\n    }\\n```\\n```\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        sum = 0\\n        if root.val > L:\\n            sum += self.rangeSumBST(root.left, L, R)\\n        if root.val < R:\\n            sum += self.rangeSumBST(root.right, L, R)\\n        if L <= root.val <= R:\\n            sum += root.val     \\n        return sum\\n```\\n\\n**Method 4: Iterative version**\\n```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        Stack<TreeNode> stk = new Stack<>();\\n        stk.push(root);\\n        int sum = 0;\\n        while (!stk.isEmpty()) {\\n            TreeNode n = stk.pop();\\n            if (n == null) { continue; }\\n            if (n.val > L) { stk.push(n.left); } // left child is a possible candidate.\\n            if (n.val < R) { stk.push(n.right); } // right child is a possible candidate.\\n            if (L <= n.val && n.val <= R) { sum += n.val; }\\n        }\\n        return sum;\\n    }\\n```\\n```\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        stk, sum = [root], 0\\n        while stk:\\n            node = stk.pop()\\n            if node:\\n                if node.val > L:\\n                    stk.append(node.left)    \\n                if node.val < R:\\n                    stk.append(node.right)\\n                if L <= node.val <= R:\\n                    sum += node.val    \\n        return sum\\n```\\n**Analysis:**\\n\\nAll 4 methods will DFS traverse all nodes in worst case, and if we count in the recursion trace space cost, the complexities are as follows:\\n\\n**Time: O(n), space: O(h)**, where `n` is the number of total nodes, `h` is the height of the tree..",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) return 0; // base case.\\n        if (root.val < L) return rangeSumBST(root.right, L, R); // left branch excluded.\\n        if (root.val > R) return rangeSumBST(root.left, L, R); // right branch excluded.\\n        return root.val + rangeSumBST(root.right, L, R) + rangeSumBST(root.left, L, R); // count in both children.\\n    }\\n```\n```\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        elif root.val < L:\\n            return self.rangeSumBST(root.right, L, R)\\n        elif root.val > R:\\n            return self.rangeSumBST(root.left, L, R)\\n        return root.val + self.rangeSumBST(root.left, L, R) + self.rangeSumBST(root.right, L, R)\\n```\n```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) return 0; // base case.\\n        return (L <= root.val && root.val <= R ? root.val : 0) + rangeSumBST(root.right, L, R) + rangeSumBST(root.left, L, R);\\n    }\\n```\n```\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        return self.rangeSumBST(root.left, L, R) + \\\\\\n                self.rangeSumBST(root.right, L, R) + \\\\\\n                (root.val if L <= root.val <= R else 0)\\n```\n```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) { return 0; }\\n        int sum = 0;\\n        if (root.val > L) { sum += rangeSumBST(root.left, L, R); } // left child is a possible candidate.\\n        if (root.val < R) { sum += rangeSumBST(root.right, L, R); } // right child is a possible candidate.\\n        if (root.val >= L && root.val <= R) { sum += root.val; } // count root in.\\n        return sum;\\n    }\\n```\n```\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        sum = 0\\n        if root.val > L:\\n            sum += self.rangeSumBST(root.left, L, R)\\n        if root.val < R:\\n            sum += self.rangeSumBST(root.right, L, R)\\n        if L <= root.val <= R:\\n            sum += root.val     \\n        return sum\\n```\n```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        Stack<TreeNode> stk = new Stack<>();\\n        stk.push(root);\\n        int sum = 0;\\n        while (!stk.isEmpty()) {\\n            TreeNode n = stk.pop();\\n            if (n == null) { continue; }\\n            if (n.val > L) { stk.push(n.left); } // left child is a possible candidate.\\n            if (n.val < R) { stk.push(n.right); } // right child is a possible candidate.\\n            if (L <= n.val && n.val <= R) { sum += n.val; }\\n        }\\n        return sum;\\n    }\\n```\n```\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        stk, sum = [root], 0\\n        while stk:\\n            node = stk.pop()\\n            if node:\\n                if node.val > L:\\n                    stk.append(node.left)    \\n                if node.val < R:\\n                    stk.append(node.right)\\n                if L <= node.val <= R:\\n                    sum += node.val    \\n        return sum\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 205181,
                "title": "java-4-lines-beats-100",
                "content": "```\\n public int rangeSumBST(TreeNode root, int L, int R) {\\n        if(root == null) return 0;\\n        if(root.val > R) return rangeSumBST(root.left, L, R);\\n        if(root.val < L) return rangeSumBST(root.right, L, R);\\n        return root.val + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);      \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int rangeSumBST(TreeNode root, int L, int R) {\\n        if(root == null) return 0;\\n        if(root.val > R) return rangeSumBST(root.left, L, R);\\n        if(root.val < L) return rangeSumBST(root.right, L, R);\\n        return root.val + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);      \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 596106,
                "title": "c-easy-explaination-step-by-step-100",
                "content": "```\\n/*I ll be giving as much details as possible as to what s going on in the recursion stack.\\nLets take the binary tree to be [10,5,15,3,7,null,18]\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t10\\n\\t\\t\\t\\t\\t\\t/\\\\\\n\\t\\t\\t\\t\\t  5  15\\n\\t\\t\\t\\t\\t /\\\\   \\\\\\n\\t\\t\\t       3  7   18\\ndo your inorder traversal as routine\\n                                                                      sum = 0\\n                    |   3      |  \\n                    |   5      |  \\n                    |   10     |  <-------inorder(root->left)\\n                    |__________|\\n                    we reach the NULL condition of the traversal\\n            as 3 has no left or right nodes a sum of 0 is passed to 3       3    <-\\n                                                                           /  \\\\    \\\\\\n                                                                         NULL  NULL 0\\n           3 is popped out of the stack ans analyzed\\n                    |          |  3\\n                    |   5      |  \\n                    |   10     |  <-------inorder(root->left)\\n                    |__________|\\n            but as 3 < 7 (L)\\n            sum value is not changed                                   sum=0\\n            then 7 is pushed into the stack\\n                    |   7      |  \\n                    |   5      |  \\n                    |   10     |  <-------inorder(root->right)\\n                    |__________|\\n            as 7 has no leaf nodes inorder(root->left) = NULL\\n                                   sum+=7(as 7 is in the range)       sum=7\\n                                   inorder(root->right) = NULL\\n                                   sum=7 is passed to the call stack\\n                    |          |  7\\n                    |   5      |  \\n                    |   10     |  <-------inorder(root->left)\\n                    |__________|\\n                Now as both the left and right nodes are visited 5 is analyzed.\\n                inorder(root->left) = 5\\n                But since 5 is not in the range sum value doesnt change.\\n                Now 5 is popped out of the stack.\\n                    |          |   5   \\n                    |          |  \\n                    |   10     |  <-------inorder(root->left)\\n                    |__________|\\n                    inorder(rot->right)  continues excecution.\\n                    |   18     |  \\n                    |   15     |  \\n                    |   10     |  <-------inorder(root->right)\\n                    |__________|\\n                    18 has no childeren thus sum=7 is passed on to the root.\\n                    18 is not in the range so sum doesnt change.\\n                    this process continues and 15 gets added to the sum giving sum=22\\n                    then 10 gets added  sum=32\\n                    */\\n     int sum=0;\\n    int inorder(TreeNode* root,int L,int R)\\n    {\\n        if(root){\\n        inorder(root->left,L,R);\\n        if(root->val>=L && root->val<=R)\\n            sum+=root->val;\\n        inorder(root->right,L,R);\\n        }\\n        return sum;\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(!root)return 0;\\n        return inorder(root,L,R);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*I ll be giving as much details as possible as to what s going on in the recursion stack.\\nLets take the binary tree to be [10,5,15,3,7,null,18]\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t10\\n\\t\\t\\t\\t\\t\\t/\\\\\\n\\t\\t\\t\\t\\t  5  15\\n\\t\\t\\t\\t\\t /\\\\   \\\\\\n\\t\\t\\t       3  7   18\\ndo your inorder traversal as routine\\n                                                                      sum = 0\\n                    |   3      |  \\n                    |   5      |  \\n                    |   10     |  <-------inorder(root->left)\\n                    |__________|\\n                    we reach the NULL condition of the traversal\\n            as 3 has no left or right nodes a sum of 0 is passed to 3       3    <-\\n                                                                           /  \\\\    \\\\\\n                                                                         NULL  NULL 0\\n           3 is popped out of the stack ans analyzed\\n                    |          |  3\\n                    |   5      |  \\n                    |   10     |  <-------inorder(root->left)\\n                    |__________|\\n            but as 3 < 7 (L)\\n            sum value is not changed                                   sum=0\\n            then 7 is pushed into the stack\\n                    |   7      |  \\n                    |   5      |  \\n                    |   10     |  <-------inorder(root->right)\\n                    |__________|\\n            as 7 has no leaf nodes inorder(root->left) = NULL\\n                                   sum+=7(as 7 is in the range)       sum=7\\n                                   inorder(root->right) = NULL\\n                                   sum=7 is passed to the call stack\\n                    |          |  7\\n                    |   5      |  \\n                    |   10     |  <-------inorder(root->left)\\n                    |__________|\\n                Now as both the left and right nodes are visited 5 is analyzed.\\n                inorder(root->left) = 5\\n                But since 5 is not in the range sum value doesnt change.\\n                Now 5 is popped out of the stack.\\n                    |          |   5   \\n                    |          |  \\n                    |   10     |  <-------inorder(root->left)\\n                    |__________|\\n                    inorder(rot->right)  continues excecution.\\n                    |   18     |  \\n                    |   15     |  \\n                    |   10     |  <-------inorder(root->right)\\n                    |__________|\\n                    18 has no childeren thus sum=7 is passed on to the root.\\n                    18 is not in the range so sum doesnt change.\\n                    this process continues and 15 gets added to the sum giving sum=22\\n                    then 10 gets added  sum=32\\n                    */\\n     int sum=0;\\n    int inorder(TreeNode* root,int L,int R)\\n    {\\n        if(root){\\n        inorder(root->left,L,R);\\n        if(root->val>=L && root->val<=R)\\n            sum+=root->val;\\n        inorder(root->right,L,R);\\n        }\\n        return sum;\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(!root)return 0;\\n        return inorder(root,L,R);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936480,
                "title": "python-simple-dfs-explained",
                "content": "One way to solve this problem is just iterate over our tree and for each element check if it is range or not. However here we are given, that out tree is `BST`, that is left subtree is always lesser than node lesser than right subtree. So, let us modify classical `dfs` a bit, where we traverse only nodes we need:\\n\\n1. Check value `node.val` and if it is in our range, add it to global sum.\\n2. We need to visit left subtree only if `node.val > low`, that is if `node.val < low`, it means, that all nodes in left subtree less than `node.val`, that is less than `low` as well.\\n3. Similarly, we visit right subtree only if `node.val < high`.\\n\\n**Complexity**: time complexity is `O(n)`, where `n` is nubmer of nodes in our tree, space complexity potentially `O(n)` as well. We can impove our estimations a bit and say, that time and space is `O(m)`, where `m` is number of nodes in our answer.\\n\\n```\\nclass Solution:\\n    def rangeSumBST(self, root, low, high):\\n        def dfs(node):\\n            if not node: return\\n            if low <= node.val <= high: self.out += node.val\\n            if node.val > low:  dfs(node.left)\\n            if node.val < high: dfs(node.right)\\n                \\n        self.out = 0\\n        dfs(root)\\n        return self.out\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root, low, high):\\n        def dfs(node):\\n            if not node: return\\n            if low <= node.val <= high: self.out += node.val\\n            if node.val > low:  dfs(node.left)\\n            if node.val < high: dfs(node.right)\\n                \\n        self.out = 0\\n        dfs(root)\\n        return self.out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 409173,
                "title": "clean-and-fast-94-4-line-python3-code",
                "content": "```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if root == None: return 0\\n        if root.val > R: return self.rangeSumBST(root.left,L,R)\\n        if root.val < L: return self.rangeSumBST(root.right,L,R)\\n        return root.val + self.rangeSumBST(root.left,L,R) + self.rangeSumBST(root.right,L,R)      \\n                   \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if root == None: return 0\\n        if root.val > R: return self.rangeSumBST(root.left,L,R)\\n        if root.val < L: return self.rangeSumBST(root.right,L,R)\\n        return root.val + self.rangeSumBST(root.left,L,R) + self.rangeSumBST(root.right,L,R)      \\n                   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628229,
                "title": "c-python-simple-solution-w-explanation-dfs-bfs-w-optimizations-o-1-morris",
                "content": "We are given a BST and range `[L, H]`. We need to return sum of all nodes between this range.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Simple DFS)***\\n\\nWe can perform a simple DFS traversal over the tree and if the current node\\'s value is within the range `[L, H]`, then we will add it to the final sum. The same process can be carried out recursively till whole tree is explored.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int H) {\\n        if(!root) return 0;\\n        return  (root -> val >= L && root -> val <= H ? root -> val : 0) +  // add root\\'s value if it lies within [L, H]\\n                rangeSumBST(root -> left, L, H) +   // recurse left\\n                rangeSumBST(root -> right, L, H);   // recurse right\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def rangeSumBST(self, root, L, H):\\n        if not root: return 0\\n        return  (root.val if root.val >= L and root.val <= H else 0) + \\\\\\n                self.rangeSumBST(root.left, L, H) + \\\\\\n                self.rangeSumBST(root.right, L, H)\\n```\\n\\n\\n***Time Complexity :*** <code>O(N)</code>, where `N` is the number of nodes in the given tree\\n***Space Complexity :*** `O(H)`, where `H` is the height of the tree. This is required for recursive stack. In case of skewed tree, this would be `O(N)`, while in case of balanced tree, this would be `O(logN)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (BST Optimized DFS)***\\n\\nIn the above solution, we aren\\'t taking the advantage of the fact that our given tree is a BST. We can reduce the search space in some cases by doing conditional recursion. \\n* If the root\\'s value is less than `L`, then it\\'s useless to further recurse the left sub-tree because we know that every node in left sub-tree will be less than `L` as well. **So iterate `root -> left` only when `root -> val > L`**\\n* Similarly, if root\\'s value is greater than `H`, we must not further recurse the right sub-tree. **So iterate `root -> right` only when `root -> val < H`**\\n\\nThe above two conditional checks help prune some recursive branches and thus optimize the solution slightly. Note that the time complexity still remains the same as the range can cover all nodes of BST.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int H) {\\n        if(!root) return 0;\\n        int ans = root -> val >= L && root -> val <= H ? root -> val : 0;\\n        if(root -> val > L) ans += rangeSumBST(root -> left, L, H);\\n        if(root -> val < H) ans += rangeSumBST(root -> right, L, H);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def rangeSumBST(self, root, L, H):\\n        if not root: return 0\\n        ans = root.val if root.val >= L and root.val <= H else 0\\n        if root.val > L: ans += self.rangeSumBST(root.left, L, H)\\n        if root.val < H: ans += self.rangeSumBST(root.right, L, H)\\n        return ans\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>, more specifically, this solution would only iterate the nodes which lie within the range `[L, H]`\\n***Space Complexity :*** `O(H)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (BST Optimized BFS)***\\n\\nThe same thing can be done using BFS traversal as well. Similar to above approach, we will only push a left or right child into queue if the root\\'s value is `> L` or `< H` respectively\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* T, int L, int H) {\\n        queue<TreeNode*> q;\\n        q.push(T);\\n        int sum = 0, v;\\n        while(size(q)) {\\n            T = q.front(); q.pop();\\n            v = T -> val;\\n            if(v >= L and v <= H)   sum += v;\\n            if(v > L && T -> left)  q.push(T -> left);\\n            if(v < H && T -> right) q.push(T -> right);\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def rangeSumBST(self, T, L, H):\\n        q, ans, v = deque([T]), 0, 0\\n        while q:\\n            T = q.popleft()\\n            v = T.val\\n            if v >= L and v <= H:  ans += v\\n            if v > L and T.left:   q.append(T.left)\\n            if v < H and T.right:  q.append(T.right)\\n        return ans\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>\\n***Space Complexity :*** `O(W)`, where `W` is the width of BST. In case of skewed tree, it will be `O(1)` and in case of balanced tree it will be `O(N/2) ~ O(N)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Morris Traversal)***\\n\\nWe can also use the Morris traversal (using the inorder version in this case) to optimze on space. I have also made some modification to prune further searches where we know that required node wont be found. You can read more on morris traversal **[here](https://leetcode.com/problems/binary-tree-inorder-traversal/solution/)** and **[here](https://stackoverflow.com/questions/5502916)**.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int H) {\\n        int ans = 0;\\n        while(root) \\n            if(root -> left && root -> val >= L) {\\n                auto pre = root -> left;  \\n                // finding predecessor of root\\n                while(pre -> right && pre -> val <= H) pre = pre -> right;\\n                // make root as right child of predecessor (temporary link)\\n                pre -> right = root;        // adding temporary link\\n                auto tmp = root;\\n                root = root -> left;                    \\n                tmp -> left = nullptr;      // avoiding inifinte loop\\n            }\\n\\t\\t\\telse {\\n                if(root -> val >= L && root -> val <= H) ans += root -> val;\\n                if(root -> val < H) root = root -> right;\\n                else break;\\n            }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nThe above version modifies the tree. The following can be used if tree modification is not allowed- \\n\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int H) {\\n        int ans = 0;\\n        while(root) \\n            if(root -> left && root -> val >= L) {\\n                auto pre = root -> left;  \\n                // find predecessor of root\\n                while(pre -> right && pre -> right != root)  pre = pre -> right;\\n                // make root as right child of predecessor (temporary link)\\n                if(!pre -> right) {\\n                    pre -> right = root;\\n                    root = root -> left;                    \\n                }\\n                else {                    \\n                    if(root -> val >= L && root -> val <= H) ans += root -> val;\\n                    pre -> right = nullptr;  // revert the changes - remove temporary link\\n                    root = root -> right;\\n                }\\n            } \\n\\t\\t\\telse {\\n                if(root -> val >= L && root -> val <= H) ans += root -> val;\\n                root = root -> right;\\n            }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nThe 1st version is optimized to prune redundant search wherever possible, but I guess the 2nd version only prunes left branches. If there\\'s a more optimized version of morris traversal that restores the tree as well, do comment below...\\n\\n***Time Complexity :*** <code>O(N)</code>\\n***Space Complexity :*** `O(1)`, only constant space is being used\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int H) {\\n        if(!root) return 0;\\n        return  (root -> val >= L && root -> val <= H ? root -> val : 0) +  // add root\\'s value if it lies within [L, H]\\n                rangeSumBST(root -> left, L, H) +   // recurse left\\n                rangeSumBST(root -> right, L, H);   // recurse right\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def rangeSumBST(self, root, L, H):\\n        if not root: return 0\\n        return  (root.val if root.val >= L and root.val <= H else 0) + \\\\\\n                self.rangeSumBST(root.left, L, H) + \\\\\\n                self.rangeSumBST(root.right, L, H)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int H) {\\n        if(!root) return 0;\\n        int ans = root -> val >= L && root -> val <= H ? root -> val : 0;\\n        if(root -> val > L) ans += rangeSumBST(root -> left, L, H);\\n        if(root -> val < H) ans += rangeSumBST(root -> right, L, H);\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def rangeSumBST(self, root, L, H):\\n        if not root: return 0\\n        ans = root.val if root.val >= L and root.val <= H else 0\\n        if root.val > L: ans += self.rangeSumBST(root.left, L, H)\\n        if root.val < H: ans += self.rangeSumBST(root.right, L, H)\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* T, int L, int H) {\\n        queue<TreeNode*> q;\\n        q.push(T);\\n        int sum = 0, v;\\n        while(size(q)) {\\n            T = q.front(); q.pop();\\n            v = T -> val;\\n            if(v >= L and v <= H)   sum += v;\\n            if(v > L && T -> left)  q.push(T -> left);\\n            if(v < H && T -> right) q.push(T -> right);\\n        }\\n        return sum;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def rangeSumBST(self, T, L, H):\\n        q, ans, v = deque([T]), 0, 0\\n        while q:\\n            T = q.popleft()\\n            v = T.val\\n            if v >= L and v <= H:  ans += v\\n            if v > L and T.left:   q.append(T.left)\\n            if v < H and T.right:  q.append(T.right)\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int H) {\\n        int ans = 0;\\n        while(root) \\n            if(root -> left && root -> val >= L) {\\n                auto pre = root -> left;  \\n                // finding predecessor of root\\n                while(pre -> right && pre -> val <= H) pre = pre -> right;\\n                // make root as right child of predecessor (temporary link)\\n                pre -> right = root;        // adding temporary link\\n                auto tmp = root;\\n                root = root -> left;                    \\n                tmp -> left = nullptr;      // avoiding inifinte loop\\n            }\\n\\t\\t\\telse {\\n                if(root -> val >= L && root -> val <= H) ans += root -> val;\\n                if(root -> val < H) root = root -> right;\\n                else break;\\n            }\\n        \\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int H) {\\n        int ans = 0;\\n        while(root) \\n            if(root -> left && root -> val >= L) {\\n                auto pre = root -> left;  \\n                // find predecessor of root\\n                while(pre -> right && pre -> right != root)  pre = pre -> right;\\n                // make root as right child of predecessor (temporary link)\\n                if(!pre -> right) {\\n                    pre -> right = root;\\n                    root = root -> left;                    \\n                }\\n                else {                    \\n                    if(root -> val >= L && root -> val <= H) ans += root -> val;\\n                    pre -> right = nullptr;  // revert the changes - remove temporary link\\n                    root = root -> right;\\n                }\\n            } \\n\\t\\t\\telse {\\n                if(root -> val >= L && root -> val <= H) ans += root -> val;\\n                root = root -> right;\\n            }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1127563,
                "title": "0ms-java-solution-faster-than-100",
                "content": "```java\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```java\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374212,
                "title": "javascript-solution",
                "content": "```\\nvar rangeSumBST = function(root, L, R) {\\n    var sum = 0;\\n    if (root == null) {\\n        return sum;\\n    }\\n\\n    if (root.val > L) {\\n        sum += rangeSumBST(root.left, L, R);\\n    }\\n    if (root.val <= R && root.val >= L) {\\n        sum += root.val;\\n    }\\n    if (root.val < R) {\\n        sum += rangeSumBST(root.right, L, R);    \\n    }    \\n    \\n    return sum;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rangeSumBST = function(root, L, R) {\\n    var sum = 0;\\n    if (root == null) {\\n        return sum;\\n    }\\n\\n    if (root.val > L) {\\n        sum += rangeSumBST(root.left, L, R);\\n    }\\n    if (root.val <= R && root.val >= L) {\\n        sum += root.val;\\n    }\\n    if (root.val < R) {\\n        sum += rangeSumBST(root.right, L, R);    \\n    }    \\n    \\n    return sum;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 498058,
                "title": "100-00-fast-in-memory-and-run-time-dfs-recursive-iterative-solution",
                "content": "Compare yourself, as the different ways are below: satisfied? \\nDon\\'t look at runtime, as this may change time to time on each submission. Have a look at optimized approach.\\n\\n-------\\nRuntime: 84 ms, faster than 98.75% of C++ online submissions for Range Sum of BST.\\nMemory Usage: 41.1 MB, less than 99.09% of C++ online submissions for Range Sum of BST.\\nIf root\\'s value is greater than L then move left, and if it\\'s value if less than R then move right.\\nTime Complexity: **O(N)**, where N is the number of nodes in the tree.\\nSpace Complexity: **O(H)**, where H is the height of the tree. i.e. **O(1)**\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int rangeSum(0);\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode* node = st.top(); st.pop();\\n            if(node->val>=L && node->val<=R) rangeSum+=node->val;\\n            if(node->val > L) {if(node->left) st.push(node->left);}\\n            if(node->val < R) {if(node->right) st.push(node->right);}\\n        }\\n        return rangeSum;\\n    }\\n};\\n```\\n\\n---------------\\nTime Complexity **O(n)** & Space Complexity **O(n)**\\nRuntime: 96 ms, faster than 95.88% of C++ online submissions for Range Sum of BST.\\nMemory Usage: 41.1 MB, less than 100.00% of C++ online submissions for Range Sum of BST.\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(!root) return 0;\\n        return ((root->val>=L && root->val<=R)? root->val : 0) + rangeSumBST(root->left,L,R) + rangeSumBST(root->right,L,R);\\n    }\\n};\\n```\\n\\n---------------\\nRuntime: 80 ms, faster than 92.88% of C++ online submissions for Range Sum of BST.\\nMemory Usage: 41.2 MB, less than 100.00% of C++ online submissions for Range Sum of BST.\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(!root) return 0;\\n    return ((root->val>=L && root->val<=R)? (root->val + rangeSumBST(root->left,L,R) + rangeSumBST(root->right,L,R)) : (root->val<L)? rangeSumBST(root->right,L,R): rangeSumBST(root->left,L,R));\\n    }\\n};\\n```\\n\\n--------------\\nRuntime: 92 ms, faster than 96.85% of C++ online submissions for Range Sum of BST.\\nMemory Usage: 41.2 MB, less than 89.09% of C++ online submissions for Range Sum of BST.\\n```\\nclass Solution {\\npublic:\\n    int helper(TreeNode* root, int L, int R, int rangeSum){\\n        if(!root) return 0;\\n        else if(root->val>=L && root->val<=R){\\n            rangeSum+=helper(root->left,L,R,0);\\n            rangeSum+=helper(root->right,L,R,0);\\n            return rangeSum + root->val;\\n        }else if(root->val > L){\\n            rangeSum+=helper(root->left,L,R,0);\\n            return rangeSum;\\n        }else if(root->val < R){\\n            rangeSum+=helper(root->right,L,R,0);\\n            return rangeSum;\\n        }\\n        return 0;\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        std::ios::sync_with_stdio(false);\\n        return helper(root,L,R,0);\\n    }\\n};\\n```\\n\\n-----------------\\nRuntime: 92 ms, faster than 96.92% of C++ online submissions for Range Sum of BST.\\nMemory Usage: 41.2 MB, less than 86.36% of C++ online submissions for Range Sum of BST.\\nSolution: **We traverse the tree using a depth first search. If node.val falls outside the range [L, R], (for example node.val < L), then we know that only the right branch could have nodes with value inside [L, R].**\\nTC: **O(n)**, SC: **O(n)**\\n```\\nclass Solution { // dfs\\nprivate:\\n    int rangeSum;\\npublic:\\n    void dfs(TreeNode* root, int L, int R){\\n        if(!root) return;\\n        if(root->val>=L && root->val<=R) rangeSum+=root->val;\\n        if(root->val > L) dfs(root->left,L,R);\\n        if(root->val < R) dfs(root->right,L,R);\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        rangeSum = 0;\\n        dfs(root,L,R);\\n        return rangeSum;\\n    }\\n};\\n```\\n\\n----------------------\\nRuntime: 148 ms, faster than 76.44% of C++ online submissions for Range Sum of BST.\\nMemory Usage: 41.2 MB, less than 88.18% of C++ online submissions for Range Sum of BST.\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, int &rangeSum, int L, int R, bool isDone){\\n        if(!root || isDone) return;\\n        dfs(root->left,rangeSum,L,R,false);\\n        if(root->val>=L && root->val<=R){\\n            rangeSum+=root->val;\\n            if(root->val==R) isDone = true;\\n        }\\n        dfs(root->right,rangeSum,L,R,false);\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int rangeSum(0);\\n        dfs(root,rangeSum,L,R,false);\\n        return rangeSum;\\n    }\\n};\\n```\\n\\n--------\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int rangeSum(0);\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode* node = st.top(); st.pop();\\n            if(node->val>=L && node->val<=R) rangeSum+=node->val;\\n            if(node->val > L) {if(node->left) st.push(node->left);}\\n            if(node->val < R) {if(node->right) st.push(node->right);}\\n        }\\n        return rangeSum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(!root) return 0;\\n        return ((root->val>=L && root->val<=R)? root->val : 0) + rangeSumBST(root->left,L,R) + rangeSumBST(root->right,L,R);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(!root) return 0;\\n    return ((root->val>=L && root->val<=R)? (root->val + rangeSumBST(root->left,L,R) + rangeSumBST(root->right,L,R)) : (root->val<L)? rangeSumBST(root->right,L,R): rangeSumBST(root->left,L,R));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(TreeNode* root, int L, int R, int rangeSum){\\n        if(!root) return 0;\\n        else if(root->val>=L && root->val<=R){\\n            rangeSum+=helper(root->left,L,R,0);\\n            rangeSum+=helper(root->right,L,R,0);\\n            return rangeSum + root->val;\\n        }else if(root->val > L){\\n            rangeSum+=helper(root->left,L,R,0);\\n            return rangeSum;\\n        }else if(root->val < R){\\n            rangeSum+=helper(root->right,L,R,0);\\n            return rangeSum;\\n        }\\n        return 0;\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        std::ios::sync_with_stdio(false);\\n        return helper(root,L,R,0);\\n    }\\n};\\n```\n```\\nclass Solution { // dfs\\nprivate:\\n    int rangeSum;\\npublic:\\n    void dfs(TreeNode* root, int L, int R){\\n        if(!root) return;\\n        if(root->val>=L && root->val<=R) rangeSum+=root->val;\\n        if(root->val > L) dfs(root->left,L,R);\\n        if(root->val < R) dfs(root->right,L,R);\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        rangeSum = 0;\\n        dfs(root,L,R);\\n        return rangeSum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, int &rangeSum, int L, int R, bool isDone){\\n        if(!root || isDone) return;\\n        dfs(root->left,rangeSum,L,R,false);\\n        if(root->val>=L && root->val<=R){\\n            rangeSum+=root->val;\\n            if(root->val==R) isDone = true;\\n        }\\n        dfs(root->right,rangeSum,L,R,false);\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int rangeSum(0);\\n        dfs(root,rangeSum,L,R,false);\\n        return rangeSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885368,
                "title": "python3-dfs-one-liner-recursive-iterative-explained",
                "content": "**One-liner**\\n```python\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        return 0 if not root else self.rangeSumBST(root.right,low,high) + self.rangeSumBST(root.left,low,high) + int(low<=root.val<=high) * root.val\\n```\\n\\n**Recursive 1** (more readable)\\n```python\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        \\n        if not root: \\n            return 0\\n        \\n        # When value is less than low, everything on it\\'s left doesn\\'t matter, \\n        # so only return the sum from its right children\\n        if root.val<low: \\n            return self.rangeSumBST(root.right,low,high)\\n        \\n        # Same thing for high.\\n        elif root.val>high: \\n            return self.rangeSumBST(root.left,low,high)\\n        \\n        # The current value is in the range, so return the sum of its left, right and own value\\n        else:\\n            return root.val + self.rangeSumBST(root.right,low,high) + self.rangeSumBST(root.left,low,high)\\n```\\n\\n**Recursive 2**\\n```python\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        res = 0\\n        def dfs(node):\\n            nonlocal res\\n            if not node: return\\n            \\n            # increase res only when the node value is in the range\\n            if low<=node.val<=high: res += node.val\\n            \\n            # The only time we don\\'t want to go left, is when the nodel value <= low.\\n            # Because it is a BST, and if the current value is aleady <= low, \\n            # there is no more hope!\\n            if node.val>low: dfs(node.left)\\n            \\n            # Same as above, but going right\\n            if node.val<high: dfs(node.right)\\n\\n        dfs(root)\\n        return res\\n```\\n\\n**Iterative** (same idea as Recursive 2)\\n```python\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        res = 0\\n        q = [root]\\n        while q:\\n            cur = q.pop()\\n            if cur:\\n                if low <= cur.val <= high:\\n                    res += cur.val\\n                if cur.val > low:\\n                    q.append(cur.left)\\n                if cur.val < high:\\n                    q.append(cur.right)\\n        return res\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        return 0 if not root else self.rangeSumBST(root.right,low,high) + self.rangeSumBST(root.left,low,high) + int(low<=root.val<=high) * root.val\\n```\n```python\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        \\n        if not root: \\n            return 0\\n        \\n        # When value is less than low, everything on it\\'s left doesn\\'t matter, \\n        # so only return the sum from its right children\\n        if root.val<low: \\n            return self.rangeSumBST(root.right,low,high)\\n        \\n        # Same thing for high.\\n        elif root.val>high: \\n            return self.rangeSumBST(root.left,low,high)\\n        \\n        # The current value is in the range, so return the sum of its left, right and own value\\n        else:\\n            return root.val + self.rangeSumBST(root.right,low,high) + self.rangeSumBST(root.left,low,high)\\n```\n```python\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        res = 0\\n        def dfs(node):\\n            nonlocal res\\n            if not node: return\\n            \\n            # increase res only when the node value is in the range\\n            if low<=node.val<=high: res += node.val\\n            \\n            # The only time we don\\'t want to go left, is when the nodel value <= low.\\n            # Because it is a BST, and if the current value is aleady <= low, \\n            # there is no more hope!\\n            if node.val>low: dfs(node.left)\\n            \\n            # Same as above, but going right\\n            if node.val<high: dfs(node.right)\\n\\n        dfs(root)\\n        return res\\n```\n```python\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        res = 0\\n        q = [root]\\n        while q:\\n            cur = q.pop()\\n            if cur:\\n                if low <= cur.val <= high:\\n                    res += cur.val\\n                if cur.val > low:\\n                    q.append(cur.left)\\n                if cur.val < high:\\n                    q.append(cur.right)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251711,
                "title": "cpp-beats-96-better-than-o-n-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n      \\n      if(!root) return 0;\\n      \\n      if(root->val >= L && root->val <= R){\\n        return root->val + rangeSumBST(root->left,L,R) + rangeSumBST(root->right,L,R);\\n      }else if(root->val < L){\\n        return rangeSumBST(root->right,L,R);\\n      }else {\\n        return rangeSumBST(root->left,L,R);\\n      }\\n    }\\n  \\n  \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n      \\n      if(!root) return 0;\\n      \\n      if(root->val >= L && root->val <= R){\\n        return root->val + rangeSumBST(root->left,L,R) + rangeSumBST(root->right,L,R);\\n      }else if(root->val < L){\\n        return rangeSumBST(root->right,L,R);\\n      }else {\\n        return rangeSumBST(root->left,L,R);\\n      }\\n    }\\n  \\n  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 192018,
                "title": "c-2-lines",
                "content": "Just doing regular tree traversal and adding values within [L, R]. Note that in the solution description, we are given BST, however, this solution  works for any binary tree.\\n\\nOf course, we can optimize a bit for the fact that this is BST. I checked the runtime and did not see any difference in the runtime. Both naive and optimized solution gave me 68 ms.\\n```\\nint rangeSumBST(TreeNode* root, int L, int R) {\\n  if (root == nullptr) return 0;\\n  return (root->val >= L && root->val <= R ? root->val : 0) +\\n    rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint rangeSumBST(TreeNode* root, int L, int R) {\\n  if (root == nullptr) return 0;\\n  return (root->val >= L && root->val <= R ? root->val : 0) +\\n    rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1627913,
                "title": "c-easy-to-solve-detailed-explanation-while-optimizing-approach",
                "content": "**Intuition:**\\nActually the question is pretty straightforward ,Basically the question maker is asking us to  add all the numbers in a BST with a certain range given for numbers like say range is given as  [Low,High]=[2,7] then we need to add all the values in BST with the numbers satisfying this range. So major people who thought of a solution will be either using  recursion ,DFS or BFS.\\n*Now, let\\'s talk about approach*\\n\\n**Algorithm:**\\nIn the following algorithm we will be discussing the solution of dfs approach .\\n1. let` sumofRange` be a variable that will be our final result . After this let\\'s declare a dfs helper function .\\n2. The base case will be when the tree is empty so we return null\\n3. we have to find the` sumofRange` so for that we need to add all the root values which satisfyes the condition that `node values should be more than low and less than high` .If this is true than add it to `sumofRange`\\n4. After this let\\'s dig the depth\\'s of the tree i.e Left childs and Right childs.\\n5. Now just call out the dfs helper function in the main function \\n\\n**Code:-**\\n```\\nclass Solution {\\npublic:\\n    int sumofRange;\\n    void dfs(TreeNode* root, int L, int R){\\n\\t\\t//Base case\\n        if(!root) return;\\n\\t\\t//If in range add \\n        if(root->val >= L && root->val <= R) sumofRange += root->val;\\n        //Digging the depths of the tree\\n\\t\\tif(root->val > L) dfs(root->left,L,R);\\n        if(root->val < R) dfs(root->right,L,R);\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        sumofRange = 0;\\n        dfs(root,L,R);\\n        return sumofRange;\\n    }\\n};\\n```\\n**Time Complexity:** *`O(n) [n=number of nodes]`*\\n**Space Complexity:** *`O(h) [h=height of tree] [Considering recursive calls]`*\\n\\n\\n**Space Optimized Approach:**\\nAfter exploring some other options, I found that we can actually optimize the space.\\nThe logic is almost same as we discussed in the above approach .The main difference is that we use a stack for storing the data of nodes . So everytime we can just peek and pop the last values that we entered\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int sumofRange(0);\\n        stack<TreeNode*> stack;\\n        stack.push(root);\\n        while(!stack.empty()){\\n            TreeNode* node = stack.top(); stack.pop();\\n            if(node->val>=L && node->val<=R) sumofRange+=node->val;\\n            if(node->val > L) {if(node->left) stack.push(node->left);}\\n            if(node->val < R) {if(node->right) stack.push(node->right);}\\n        }\\n        return sumofRange;\\n    }\\n};\\n```\\n\\n**Time Complexity:** *`O(n) [n=number of nodes]`*\\n**Space Complexity:** *`O(h) [h=height of the tree]`*\\n\\n\\n........*continuation from previous posts..\\nTill now in the Discovery of Dr.Cheems Ancient Ruins arc.. A sudden discovery of algorithm created a rift a humans mind who discovered this algos and from where this algo\\'s came. After some investigation they found out that there was certaing identity in ancient time known as Dr.Cheems Doge who was renowed for his intelligence. After inspecting a bit more they found out that at a certain place there was ancient ruins of his lab. The excavation of the ruins happened under a group of 5 great archeologists.A mysterious call came to seize the excavation but they didn\\'t stop. After some excavation the doors started vibrating and changed colors also a mysterious passcode panel came front...\\nTo be continued in the next post*.........\\n\\n**Feel free to comment and upvote :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumofRange;\\n    void dfs(TreeNode* root, int L, int R){\\n\\t\\t//Base case\\n        if(!root) return;\\n\\t\\t//If in range add \\n        if(root->val >= L && root->val <= R) sumofRange += root->val;\\n        //Digging the depths of the tree\\n\\t\\tif(root->val > L) dfs(root->left,L,R);\\n        if(root->val < R) dfs(root->right,L,R);\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        sumofRange = 0;\\n        dfs(root,L,R);\\n        return sumofRange;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int sumofRange(0);\\n        stack<TreeNode*> stack;\\n        stack.push(root);\\n        while(!stack.empty()){\\n            TreeNode* node = stack.top(); stack.pop();\\n            if(node->val>=L && node->val<=R) sumofRange+=node->val;\\n            if(node->val > L) {if(node->left) stack.push(node->left);}\\n            if(node->val < R) {if(node->right) stack.push(node->right);}\\n        }\\n        return sumofRange;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 349978,
                "title": "python-use-visualization-help-you-think-about-it",
                "content": "1. L = 7, R = 15, sum=32:\\n```\\n         *10\\n         /  \\\\\\n       *5    *15\\n       / \\\\     \\\\\\n      3   *7    18\\n```\\n\\t  \\n2.  L = 6, R = 10, sum=23 :\\n```\\n\\t            *10\\n               /    \\\\\\n              5      15\\n             / \\\\     / \\\\\\n            3   *7  13  18\\n           /   /\\n         1    *6\\n\\n```\\n```\\nclass Solution(object):\\n    def rangeSumBST(self, root, L, R):\\n        def dfs(node):\\n            if node:\\n                if L<= node.val <= R:\\n                    self.ans += node.val\\n                    #print(node.val)\\n                if node.val>L:\\n                    dfs(node.left)\\n                if node.val<R:\\n                    dfs(node.right)\\n        self.ans = 0\\n        dfs(root)\\n        return self.ans\\n\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n         *10\\n         /  \\\\\\n       *5    *15\\n       / \\\\     \\\\\\n      3   *7    18\\n```\n```\\n\\t            *10\\n               /    \\\\\\n              5      15\\n             / \\\\     / \\\\\\n            3   *7  13  18\\n           /   /\\n         1    *6\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 193702,
                "title": "javascript-2-solutions-easy-to-understand-beats-100",
                "content": "1. Sum while recursing through the tree\\n```\\nvar rangeSumBST = function(root, L, R) {\\n    // base case\\n    if(root == null) {\\n        return 0;\\n    }\\n    \\n    if(root.val > R) {\\n        return rangeSumBST(root.left, L, R);\\n    } else if(root.val < L) {\\n        return rangeSumBST(root.right, L, R);\\n    } else {\\n        return root.val + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);\\n    }\\n};\\n```\\n\\n2. Do inorder traversal to get all nodes on tree in order, and then sum all values >= L and <=R. This is less efficient than previous solution because we are traversing all nodes, but this can be easier to understand.\\n```\\nvar rangeSumBST = function(root, L, R) {\\n    var arr = [], sum=0;\\n    inorder(root, arr);\\n    \\n    for(var i=0; i<arr.length; i++) {\\n        if(arr[i] >= L && arr[i] <= R) {\\n            sum = sum + arr[i];\\n        }\\n    }\\n    \\n    return sum;\\n};\\n\\nvar inorder = function(root, arr) {\\n    if(root == null) {\\n        return;\\n    }\\n    \\n    inorder(root.left, arr);\\n    arr.push(root.val);\\n    inorder(root.right, arr);\\n \\n    return;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar rangeSumBST = function(root, L, R) {\\n    // base case\\n    if(root == null) {\\n        return 0;\\n    }\\n    \\n    if(root.val > R) {\\n        return rangeSumBST(root.left, L, R);\\n    } else if(root.val < L) {\\n        return rangeSumBST(root.right, L, R);\\n    } else {\\n        return root.val + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);\\n    }\\n};\\n```\n```\\nvar rangeSumBST = function(root, L, R) {\\n    var arr = [], sum=0;\\n    inorder(root, arr);\\n    \\n    for(var i=0; i<arr.length; i++) {\\n        if(arr[i] >= L && arr[i] <= R) {\\n            sum = sum + arr[i];\\n        }\\n    }\\n    \\n    return sum;\\n};\\n\\nvar inorder = function(root, arr) {\\n    if(root == null) {\\n        return;\\n    }\\n    \\n    inorder(root.left, arr);\\n    arr.push(root.val);\\n    inorder(root.right, arr);\\n \\n    return;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 193235,
                "title": "python3-easy-to-understand-inorder-traversal",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        return self.inorder(root, 0, L, R)\\n            \\n    def inorder(self, root, value, L, R):\\n        if root:\\n            value = self.inorder(root.left, value, L, R)\\n            if root.val >= L and root.val <= R:\\n                value += root.val\\n            value = self.inorder(root.right, value, L, R)\\n        \\n        return value\\n```\\n\\n**UPDATE**\\nWe may optimize this by setting the \\n```\\nif root.val >= L and root.val <= R:\\n``` \\nas\\n```\\nif root.val > R:\\n\\treturn value\\nelif root.val >= L:\\n\\tvalue += root.val\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        return self.inorder(root, 0, L, R)\\n            \\n    def inorder(self, root, value, L, R):\\n        if root:\\n            value = self.inorder(root.left, value, L, R)\\n            if root.val >= L and root.val <= R:\\n                value += root.val\\n            value = self.inorder(root.right, value, L, R)\\n        \\n        return value\\n```\n```\\nif root.val >= L and root.val <= R:\\n```\n```\\nif root.val > R:\\n\\treturn value\\nelif root.val >= L:\\n\\tvalue += root.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 320320,
                "title": "intuitive-javascript-solution",
                "content": "```\\n/**\\n * @param {TreeNode} root\\n * @param {number} L\\n * @param {number} R\\n * @return {number}\\n */\\nvar rangeSumBST = function(root, L, R) {\\n    // check if value is in the given range\\n    const isInBetween = val => val >= L && val <= R;\\n    // sum the value if it\\'s in the range\\n    const add = (val, sum) => isInBetween(val) ? sum += val : sum;\\n\\t// traverse through the nodes and sum the values in range\\n    const preorder =(root, sum) => {\\n        if (!root) return sum;\\n        return add(root.val, sum) + preorder(root.left, sum) + preorder(root.right, sum);\\n    } \\n    return preorder(root, 0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {TreeNode} root\\n * @param {number} L\\n * @param {number} R\\n * @return {number}\\n */\\nvar rangeSumBST = function(root, L, R) {\\n    // check if value is in the given range\\n    const isInBetween = val => val >= L && val <= R;\\n    // sum the value if it\\'s in the range\\n    const add = (val, sum) => isInBetween(val) ? sum += val : sum;\\n\\t// traverse through the nodes and sum the values in range\\n    const preorder =(root, sum) => {\\n        if (!root) return sum;\\n        return add(root.val, sum) + preorder(root.left, sum) + preorder(root.right, sum);\\n    } \\n    return preorder(root, 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2885382,
                "title": "python-c-java-dfs-bfs-binary-search-explained-bonus-one-liner",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs conditional traversal of a Binary Search Tree. Time complexity is linear: **O(N)**. Space complexity is logarithmic (for a balanced tree): **O(logN)**.\\n****\\n\\n**Comment.** Binary Search Tree (BST) is a type of binary tree for which the left (right) subtree of each node is also a BST with all values being less (greater) than the node\\'s value. This defines a recursive strategy to compute range sums, namely:\\n1. Take node\\'s value if it\\'s in range. \\n2. If node\\'s value is greater than the lower bound then search for valid values in the left subtree.\\n3. If node\\'s value is less than the upper bound then search for valid values in the right subtree.\\n\\n**Python #1.** DFS.\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        \\n        if not root : return 0\\n        \\n        s = root.val if low <= root.val <= high else 0\\n        if low  <= root.val : s += self.rangeSumBST(root.left,  low, high)\\n        if high >= root.val : s += self.rangeSumBST(root.right, low, high)\\n        \\n        return s\\n```\\n\\n**Python #2.** BFS.\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        dq, s = deque([root]), 0\\n        while dq:\\n            node = dq.popleft()\\n            if low  <= node.val <= high        : s += node.val\\n            if low  <= node.val and node.left  : dq.append(node.left)\\n            if high >= node.val and node.right : dq.append(node.right)\\n        return s\\n```\\n\\nThere is also a more expensive, however, interesting approach. \\n\\n**Python #3.** Collect values in order then binary search.\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        \\n        def inorder(n, v):\\n            if n: inorder(n.left, v), v.append(n.val), inorder(n.right, v)\\n        \\n        vals = []\\n        inorder(root, vals)\\n        \\n        return sum(vals[bisect_left(vals, low) : bisect_right(vals, high)])\\n```\\n\\n<iframe src=\"https://leetcode.com/playground/2RVvrN38/shared\" frameBorder=\"0\" width=\"800\" height=\"260\"></iframe>\\n\\n**\\u2705 YOU MADE IT TILL THE BONUS SECTION... YOUR GREAT EFFORT DESERVES UPVOTING THIS POST!**\\n\\n**Python.** DFS one-liner.\\n```\\nclass Solution:\\n    def rangeSumBST(self, r, l, h):\\n        \\n        return 0 if not r else (l <= r.val <= h) * r.val + \\\\\\n                               self.rangeSumBST(r.right, l, h) + \\\\\\n                               self.rangeSumBST(r.left,  l, h)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        \\n        if not root : return 0\\n        \\n        s = root.val if low <= root.val <= high else 0\\n        if low  <= root.val : s += self.rangeSumBST(root.left,  low, high)\\n        if high >= root.val : s += self.rangeSumBST(root.right, low, high)\\n        \\n        return s\\n```\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        dq, s = deque([root]), 0\\n        while dq:\\n            node = dq.popleft()\\n            if low  <= node.val <= high        : s += node.val\\n            if low  <= node.val and node.left  : dq.append(node.left)\\n            if high >= node.val and node.right : dq.append(node.right)\\n        return s\\n```\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        \\n        def inorder(n, v):\\n            if n: inorder(n.left, v), v.append(n.val), inorder(n.right, v)\\n        \\n        vals = []\\n        inorder(root, vals)\\n        \\n        return sum(vals[bisect_left(vals, low) : bisect_right(vals, high)])\\n```\n```\\nclass Solution:\\n    def rangeSumBST(self, r, l, h):\\n        \\n        return 0 if not r else (l <= r.val <= h) * r.val + \\\\\\n                               self.rangeSumBST(r.right, l, h) + \\\\\\n                               self.rangeSumBST(r.left,  l, h)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703641,
                "title": "python-2-elegant-solutions-recursive-and-iterative",
                "content": "```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        ## RC ##\\n        ## APPROACH : RECURSION ##\\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(H) ##\\n        \\n        def dfs(node):\\n            if not node: return 0\\n            if node.val < L: return dfs(node.right)\\n            elif node.val > R: return dfs(node.left)\\n            else: return dfs(node.left) + dfs(node.right) + node.val\\n        return dfs(root)\\n        \\n        ## APPROACH : ITERATIVE ##\\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(H) ##\\n        stack = [root]\\n        ans = 0\\n        while(stack):\\n            node = stack.pop()\\n            if node:\\n                if L <= node.val <= R: ans += node.val\\n                if L < node.val: stack.append(node.left)\\n                if R > node.val: stack.append(node.right)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        ## RC ##\\n        ## APPROACH : RECURSION ##\\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(H) ##\\n        \\n        def dfs(node):\\n            if not node: return 0\\n            if node.val < L: return dfs(node.right)\\n            elif node.val > R: return dfs(node.left)\\n            else: return dfs(node.left) + dfs(node.right) + node.val\\n        return dfs(root)\\n        \\n        ## APPROACH : ITERATIVE ##\\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(H) ##\\n        stack = [root]\\n        ans = 0\\n        while(stack):\\n            node = stack.pop()\\n            if node:\\n                if L <= node.val <= R: ans += node.val\\n                if L < node.val: stack.append(node.left)\\n                if R > node.val: stack.append(node.right)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 192011,
                "title": "c-recursion",
                "content": "    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(!root || L > R)\\n            return 0;\\n        \\n        if(root->val < L)\\n            return rangeSumBST(root->right, L, R);\\n        \\n        if(root->val > R)\\n            return rangeSumBST(root->left, L, R);\\n        \\n        return root->val + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n    }",
                "solutionTags": [],
                "code": "    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(!root || L > R)\\n            return 0;\\n        \\n        if(root->val < L)\\n            return rangeSumBST(root->right, L, R);\\n        \\n        if(root->val > R)\\n            return rangeSumBST(root->left, L, R);\\n        \\n        return root->val + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 480481,
                "title": "simple-recursive-solution-faster-than-96",
                "content": "```\\nconst rangeSumBST = (root, L, R) => {\\n    let sum = 0;\\n    const traverse = (root) => {\\n        if (root.val >= L && root.val <= R) sum += root.val;\\n        if (root.left !== null) traverse(root.left);\\n        if (root.right !== null) traverse(root.right);\\n    }\\n    traverse(root);\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nconst rangeSumBST = (root, L, R) => {\\n    let sum = 0;\\n    const traverse = (root) => {\\n        if (root.val >= L && root.val <= R) sum += root.val;\\n        if (root.left !== null) traverse(root.left);\\n        if (root.right !== null) traverse(root.right);\\n    }\\n    traverse(root);\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 192148,
                "title": "python-1-liner",
                "content": "```\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        return root and self.rangeSumBST(root.left, L, R) + self.rangeSumBST(root.right, L, R) + (L <= root.val <= R) * root.val or 0\\n```\\n* More readable\\n```\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        if not root: return 0\\n        l = self.rangeSumBST(root.left, L, R)\\n        r = self.rangeSumBST(root.right, L, R)\\n        return l + r + (L <= root.val <= R) * root.val\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        return root and self.rangeSumBST(root.left, L, R) + self.rangeSumBST(root.right, L, R) + (L <= root.val <= R) * root.val or 0\\n```\n```\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        if not root: return 0\\n        l = self.rangeSumBST(root.left, L, R)\\n        r = self.rangeSumBST(root.right, L, R)\\n        return l + r + (L <= root.val <= R) * root.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 192020,
                "title": "java-recursion",
                "content": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        if (root.val >= L && root.val <= R) {\\n            return root.val + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);\\n        } else if (root.val < L) {\\n            return rangeSumBST(root.right, L, R);\\n        } else {\\n            return rangeSumBST(root.left, L, R);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        if (root.val >= L && root.val <= R) {\\n            return root.val + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);\\n        } else if (root.val < L) {\\n            return rangeSumBST(root.right, L, R);\\n        } else {\\n            return rangeSumBST(root.left, L, R);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1097555,
                "title": "simple-easy-to-understand-java-0-ms-faster-than-100-00-using-dfs-clean-code-with-comment",
                "content": "```\\n\\nclass Solution {\\n    int sum;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        sum = 0;\\n        \\n        dfs(root, low, high);\\n        \\n        return sum;\\n    }\\n    private void dfs(TreeNode node, int low, int high){\\n        if(node == null) return;\\n        \\n        int currentVal = node.val;\\n        \\n        //add in sum, if its value in range\\n        if(currentVal >= low && currentVal <= high) sum += currentVal;\\n        \\n        //no need to check in left, if current val is less than low\\n        //As it given,this is BST, so in left there will lesser number\\n        if(currentVal >= low)\\n        dfs(node.left, low, high);\\n        \\n        //no need to check in right, if current val is greater that high\\n        if(currentVal <= high)\\n        dfs(node.right, low, high);\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    int sum;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        sum = 0;\\n        \\n        dfs(root, low, high);\\n        \\n        return sum;\\n    }\\n    private void dfs(TreeNode node, int low, int high){\\n        if(node == null) return;\\n        \\n        int currentVal = node.val;\\n        \\n        //add in sum, if its value in range\\n        if(currentVal >= low && currentVal <= high) sum += currentVal;\\n        \\n        //no need to check in left, if current val is less than low\\n        //As it given,this is BST, so in left there will lesser number\\n        if(currentVal >= low)\\n        dfs(node.left, low, high);\\n        \\n        //no need to check in right, if current val is greater that high\\n        if(currentVal <= high)\\n        dfs(node.right, low, high);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294243,
                "title": "python-beat-90-simple-solution",
                "content": "```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        elif root.val >= L and root.val <= R:\\n            return root.val + self.rangeSumBST(root.left, L, R) + self.rangeSumBST(root.right, L, R)\\n        elif root.val < L:\\n            return self.rangeSumBST(root.right, L, R)\\n        else:\\n            return self.rangeSumBST(root.left, L, R)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        elif root.val >= L and root.val <= R:\\n            return root.val + self.rangeSumBST(root.left, L, R) + self.rangeSumBST(root.right, L, R)\\n        elif root.val < L:\\n            return self.rangeSumBST(root.right, L, R)\\n        else:\\n            return self.rangeSumBST(root.left, L, R)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628107,
                "title": "java-dfs-bst-specific-0ms-can-merge-into-one-line",
                "content": "Original codes:\\n```\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null)\\n        \\treturn 0;\\n        int val = 0, left = 0, right = 0;\\n        if (root.val >= low && root.val <= high)\\n            val = root.val;\\n        if (root.val > low)\\n        \\tleft = rangeSumBST(root.left, low, high);\\n        if (root.val < high)\\n        \\tright = rangeSumBST(root.right, low, high);\\n        return val + left + right;\\n    }\\n```\\nOne line of codes (seperate to multiple lines for easy-understanding):\\n```\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n    \\treturn root == null ? 0 :\\n    \\t\\t   (root.val >= low && root.val <= high ? root.val : 0) +\\n    \\t\\t   (root.val > low  ? rangeSumBST(root.left,  low, high) : 0) + \\n    \\t\\t   (root.val < high ? rangeSumBST(root.right, low, high) : 0);\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null)\\n        \\treturn 0;\\n        int val = 0, left = 0, right = 0;\\n        if (root.val >= low && root.val <= high)\\n            val = root.val;\\n        if (root.val > low)\\n        \\tleft = rangeSumBST(root.left, low, high);\\n        if (root.val < high)\\n        \\tright = rangeSumBST(root.right, low, high);\\n        return val + left + right;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1213314,
                "title": "python-3-faster-than-99-54-simple-solution",
                "content": "````\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        if root:\\n            if root.val<low:\\n                return self.rangeSumBST(root.right,low,high)\\n            elif root.val>high:\\n                return self.rangeSumBST(root.left,low,high)\\n            return root.val + self.rangeSumBST(root.left,low,high) + self.rangeSumBST(root.right,low,high)\\n        else:\\n            return 0",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "````\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        if root:\\n            if root.val<low:\\n                return self.rangeSumBST(root.right,low,high)\\n            elif root.val>high:\\n                return self.rangeSumBST(root.left,low,high)\\n            return root.val + self.rangeSumBST(root.left,low,high) + self.rangeSumBST(root.right,low,high)\\n        else:\\n            return 0",
                "codeTag": "Java"
            },
            {
                "id": 339587,
                "title": "c-inorder-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    \\n    void inorder(TreeNode* root, int L, int R){\\n        if(root->left)inorder(root->left, L, R);\\n        if(root->val>=L && root->val<=R)sum+=root->val;\\n        if(root->right)inorder(root->right, L, R);\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        \\n        //SOLUCHAN STARTS HERE - DUN DUN DUN DUN \\n        inorder(root, L, R);\\n        return sum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    \\n    void inorder(TreeNode* root, int L, int R){\\n        if(root->left)inorder(root->left, L, R);\\n        if(root->val>=L && root->val<=R)sum+=root->val;\\n        if(root->right)inorder(root->right, L, R);\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        \\n        //SOLUCHAN STARTS HERE - DUN DUN DUN DUN \\n        inorder(root, L, R);\\n        return sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 193674,
                "title": "jave-easy-to-understand-2ms-solution-tree-pruning",
                "content": "```\\nclass Solution {\\n    int sum = 0;\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        helper(root, L, R);\\n        return sum;\\n    }\\n    \\n    public void helper(TreeNode root, int L, int R){\\n        if(root == null){\\n            return;\\n        }\\n        if(root.val <= R && root.val >= L){\\n            sum += root.val;\\n            helper(root.left, L, R);\\n            helper(root.right, L, R);\\n        }else if(root.val < L){\\n            helper(root.right, L, R); //no need to go left since the left branch must be smaller than L\\n        }else{ //root great than R\\n            helper(root.left, L, R); //no need to go right since the right branch must be larger than R\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int sum = 0;\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        helper(root, L, R);\\n        return sum;\\n    }\\n    \\n    public void helper(TreeNode root, int L, int R){\\n        if(root == null){\\n            return;\\n        }\\n        if(root.val <= R && root.val >= L){\\n            sum += root.val;\\n            helper(root.left, L, R);\\n            helper(root.right, L, R);\\n        }else if(root.val < L){\\n            helper(root.right, L, R); //no need to go left since the left branch must be smaller than L\\n        }else{ //root great than R\\n            helper(root.left, L, R); //no need to go right since the right branch must be larger than R\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 580124,
                "title": "javascript-simple-dfs-solution",
                "content": "Runtime: 148 ms, faster than 98.20% of JavaScript online submissions for Range Sum of BST.\\nMemory Usage: 66.8 MB, less than 100.00% of JavaScript online submissions for Range Sum of BST.\\n```\\nfunction rangeSumBST(root, l, r) {\\n  let sum = 0\\n  dfs(root)\\n  return sum\\n  \\n  function dfs(node) {\\n    if (!node) {\\n      return\\n    }\\n    \\n    if (node.val < l) {\\n      dfs(node.right)\\n      return\\n    }\\n    \\n    if (node.val > r) {\\n      dfs(node.left)\\n      return\\n    }\\n\\n    sum += node.val\\n    dfs(node.left)\\n    dfs(node.right)\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction rangeSumBST(root, l, r) {\\n  let sum = 0\\n  dfs(root)\\n  return sum\\n  \\n  function dfs(node) {\\n    if (!node) {\\n      return\\n    }\\n    \\n    if (node.val < l) {\\n      dfs(node.right)\\n      return\\n    }\\n    \\n    if (node.val > r) {\\n      dfs(node.left)\\n      return\\n    }\\n\\n    sum += node.val\\n    dfs(node.left)\\n    dfs(node.right)\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2886115,
                "title": "c-using-preorder-traversal-explained",
                "content": "# Intuition\\nAs we know we need to find the sum between the ranges , so very first thing that comes in our mind is to check all the nodes one by one any try out.... (Using Recursion Do the Traversal)\\n\\n# Approach\\n1. build a rescursive function to call check each node of BST\\n2. if my node current value lies under the given ranges then I\\'ll take that into my sum\\n3. Contuniue calling recursively untill the tree is not finished\\n4. Return the sum between ranges\\n\\n# Complexity\\n- **Time complexity: O(n)**  -> here n is number of nodes\\n\\n- **Space complexity: O(n)**  -> stack space of recursion\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void find(TreeNode* root,int low,int high,int& sum)\\n    {\\n        if(root==NULL) return;\\n\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n\\n        find(root->left,low,high,sum);\\n        find(root->right,low,high,sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n        int sum = 0;\\n        find(root,low,high,sum);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void find(TreeNode* root,int low,int high,int& sum)\\n    {\\n        if(root==NULL) return;\\n\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n\\n        find(root->left,low,high,sum);\\n        find(root->right,low,high,sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n        int sum = 0;\\n        find(root,low,high,sum);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724024,
                "title": "python-3-300ms-simple-dfs-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if root is None:\\n            return 0\\n        s=0\\n        if root.val>=low and root.val<=high:\\n            s=s+root.val\\n        s=s+self.rangeSumBST(root.left,low,high)\\n        s=s+self.rangeSumBST(root.right,low,high)\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if root is None:\\n            return 0\\n        s=0\\n        if root.val>=low and root.val<=high:\\n            s=s+root.val\\n        s=s+self.rangeSumBST(root.left,low,high)\\n        s=s+self.rangeSumBST(root.right,low,high)\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 192579,
                "title": "python-solution",
                "content": "DFS recursive:\\n```\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return\\n            if L <= root.val <= R:\\n                self.res += root.val\\n            if L <= root.val:\\n                dfs(root.left)\\n            if R >= root.val:\\n                dfs(root.right)\\n        self.res = 0\\n        dfs(root)\\n        return self.res\\n```\\nDFS iterative:\\n```\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        stack = [root]\\n        res = 0\\n        while stack:\\n            u = stack.pop()\\n            if L <= u.val <= R:\\n                res += u.val\\n            if u.left and u.val >= L:\\n                stack.append(u.left)\\n            if u.right and u.val <= R:\\n                stack.append(u.right)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return\\n            if L <= root.val <= R:\\n                self.res += root.val\\n            if L <= root.val:\\n                dfs(root.left)\\n            if R >= root.val:\\n                dfs(root.right)\\n        self.res = 0\\n        dfs(root)\\n        return self.res\\n```\n```\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        stack = [root]\\n        res = 0\\n        while stack:\\n            u = stack.pop()\\n            if L <= u.val <= R:\\n                res += u.val\\n            if u.left and u.val >= L:\\n                stack.append(u.left)\\n            if u.right and u.val <= R:\\n                stack.append(u.right)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886005,
                "title": "7th-december-daily-challenge-leetcode",
                "content": "# Intuition\\nMy Very First intuition to solve this approach was to traverse the tree in inorder manner, I did that and stored values of each Node in a seperate array and then traversed the array to sum up values following the given constraints.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBut then I made a little change in the Inorder Traversal Algorithm and rather than to store in another array I updated the sums variable(variable storing my answer) at that place and then simply returned the sums variable storing my anser.\\nNote: I defined a class variable sums to store my answer, so that I can update its value in a helper function findSum from inside the function.\\n\\nNote: The findSum function I used is simply a modified version of Inorder Traversal Function\\n\\nVote up if this Helps!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity is same as that of inorder traversal, that is O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIf we consider the size of the stack for function calls then O(h + 1) and one is added for sums variable, where h is the height of the tree.\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    sums = 0\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        def findSum(root):\\n            if root:\\n                findSum(root.left)\\n                if root.val <= high and root.val >= low:\\n                    self.sums += root.val\\n                findSum(root.right)\\n        findSum(root)\\n        \\n        return self.sums\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    sums = 0\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        def findSum(root):\\n            if root:\\n                findSum(root.left)\\n                if root.val <= high and root.val >= low:\\n                    self.sums += root.val\\n                findSum(root.right)\\n        findSum(root)\\n        \\n        return self.sums\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885406,
                "title": "python-3-6-lines-two-versions-w-explanation-t-m-98-92",
                "content": "A binary *search* tree is more than just a binary tree. For each node *node*, every node value in `node`\\'s left tree is less than `node.val`, and every node value in `node`\\'s right tree is greater than `node.val`.\\n\\nHere\\'s the plan:\\n- Traverse the tree recursively or iteratively, and at each node visited, return the sum of all qualifying node values in its two subtrees. However, for any `node`:\\n\\n- If `node.val` is less than `low`, then we know that each value in node\\'s left subtree is also less than `low`; if so, we do not need to traverse *node*\\'s left subtree.\\n- Likewise, If `node.val` is greater than `high`, then we know that each value in `node`\\'s right subtree is also greater than `high`; if so, we do not need to traverse `node`\\'s right subtree.\\n\\nHere is the recursive version\\n\\n```\\nclass Solution: \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n\\n        def dfs(node):\\n\\n            if not node: return 0\\n\\n            if node.val <  low: return dfs(node.right)\\n            if node.val > high: return dfs(node.left )\\n            \\n            return dfs(node.left ) + dfs(node.right) + node.val\\n\\n        return dfs(root)\\n```\\n[https://leetcode.com/problems/range-sum-of-bst/submissions/855830563/](http://)\\n\\n\\n\\nI could be wrong, but I think that, worst-case, time is *O*(*N*) and space is *O*(*N*).\\n\\nHere\\'s the iterative version:\\n\\n```\\nclass Solution: \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n\\n        ans, stack = 0, deque([root])\\n\\n        while stack:\\n            node = stack.pop()\\n            if not node: continue\\n\\n            if   node.val <  low: stack.append(node.right)\\n            elif node.val > high: stack.append(node.left )\\n            else:\\n                ans+= node.val\\n                stack.append(node.left )\\n                stack.append(node.right)\\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution: \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n\\n        def dfs(node):\\n\\n            if not node: return 0\\n\\n            if node.val <  low: return dfs(node.right)\\n            if node.val > high: return dfs(node.left )\\n            \\n            return dfs(node.left ) + dfs(node.right) + node.val\\n\\n        return dfs(root)\\n```\n```\\nclass Solution: \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n\\n        ans, stack = 0, deque([root])\\n\\n        while stack:\\n            node = stack.pop()\\n            if not node: continue\\n\\n            if   node.val <  low: stack.append(node.right)\\n            elif node.val > high: stack.append(node.left )\\n            else:\\n                ans+= node.val\\n                stack.append(node.left )\\n                stack.append(node.right)\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548320,
                "title": "c-solution-recursive-6-lines-easy-to-understand",
                "content": "**If the solution helps,please do consider upvoting it.**\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n        if(!root)\\n            return 0;\\n       if(root->val>high)\\n           return rangeSumBST(root->left,low,high);\\n        if(root->val<low)\\n            return rangeSumBST(root->right,low,high);\\n        return root->val +rangeSumBST(root->left,low,high) +rangeSumBST(root->right,low,high);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n        if(!root)\\n            return 0;\\n       if(root->val>high)\\n           return rangeSumBST(root->left,low,high);\\n        if(root->val<low)\\n            return rangeSumBST(root->right,low,high);\\n        return root->val +rangeSumBST(root->left,low,high) +rangeSumBST(root->right,low,high);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 535543,
                "title": "java-recursive-and-iterative",
                "content": "```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) return 0;\\n        if (root.val <= L) return rangeSumBST(root.right, L, R) + (root.val == L ? root.val : 0);\\n        if (root.val >= R) return rangeSumBST(root.left, L, R) + (root.val == R ? root.val : 0);\\n        return rangeSumBST(root.left, L, R) + root.val + rangeSumBST(root.right, L, R);\\n    }\\n```\\n\\n```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        Stack<TreeNode> st = new Stack<>();\\n        st.add(root);\\n        int sum = 0;\\n        while (!st.isEmpty()){\\n            TreeNode n = st.pop();\\n            if (n == null) continue;\\n            if (n.val >= L && n.val <= R) sum += n.val;\\n            if (n.val > L) st.push(n.left);\\n            if (n.val < R) st.push(n.right);\\n        }\\n        return sum;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) return 0;\\n        if (root.val <= L) return rangeSumBST(root.right, L, R) + (root.val == L ? root.val : 0);\\n        if (root.val >= R) return rangeSumBST(root.left, L, R) + (root.val == R ? root.val : 0);\\n        return rangeSumBST(root.left, L, R) + root.val + rangeSumBST(root.right, L, R);\\n    }\\n```\n```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        Stack<TreeNode> st = new Stack<>();\\n        st.add(root);\\n        int sum = 0;\\n        while (!st.isEmpty()){\\n            TreeNode n = st.pop();\\n            if (n == null) continue;\\n            if (n.val >= L && n.val <= R) sum += n.val;\\n            if (n.val > L) st.push(n.left);\\n            if (n.val < R) st.push(n.right);\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 480659,
                "title": "c-solution",
                "content": "```\\nint rangeSumBST(struct TreeNode* root, int L, int R){\\n    if (!root) {\\n        return 0;\\n    }\\n    if(root->val<L){\\n        return rangeSumBST(root->right, L, R);\\n    }\\n    if(root->val>R){\\n        return rangeSumBST(root->left, L, R);\\n    }\\n    return root->val + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint rangeSumBST(struct TreeNode* root, int L, int R){\\n    if (!root) {\\n        return 0;\\n    }\\n    if(root->val<L){\\n        return rangeSumBST(root->right, L, R);\\n    }\\n    if(root->val>R){\\n        return rangeSumBST(root->left, L, R);\\n    }\\n    return root->val + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2885975,
                "title": "easy-java-solution-using-recursion",
                "content": "\\n\\n```\\nclass Solution {\\n    int sum;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        sum = 0;\\n        rangeSum(root,low,high);\\n        return sum;\\n        \\n    }\\n        \\n    public void rangeSum(TreeNode root,int low,int high){\\n        \\n        if(root != null){\\n           \\n        if(low <= root.val && root.val <= high ){\\n            sum +=root.val;\\n        }\\n        if(low < root.val  )\\n            rangeSum(root.left,low,high);\\n\\n        if(root.val <= high )\\n            rangeSum(root.right,low,high);\\n        \\n        \\n    }\\n        \\n    }\\n}\\n```\\n## \\n## Please Upvote if it helped.\\n## Thanks",
                "solutionTags": [
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int sum;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        sum = 0;\\n        rangeSum(root,low,high);\\n        return sum;\\n        \\n    }\\n        \\n    public void rangeSum(TreeNode root,int low,int high){\\n        \\n        if(root != null){\\n           \\n        if(low <= root.val && root.val <= high ){\\n            sum +=root.val;\\n        }\\n        if(low < root.val  )\\n            rangeSum(root.left,low,high);\\n\\n        if(root.val <= high )\\n            rangeSum(root.right,low,high);\\n        \\n        \\n    }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885967,
                "title": "c-inorder-traversal-intuitive-approach",
                "content": "# Intuition\\nInorder traversal of BST returns nodes in sorted order.\\n\\n# Approach\\nWhile sorting nodes by using inorder traversal, we sum up all the nodes values lies between the range.\\n\\n# Complexity\\n- Time complexity: O(N) \\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    void inorder(TreeNode* node, int &low, int &high, int &sum)\\n    {\\n        if(!node) return;\\n        inorder(node->left, low, high, sum);\\n        if(node->val >= low && node->val <= high) sum += node->val;\\n        inorder(node->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n        int sum=0;\\n        inorder(root, low, high, sum);\\n        return sum;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    void inorder(TreeNode* node, int &low, int &high, int &sum)\\n    {\\n        if(!node) return;\\n        inorder(node->left, low, high, sum);\\n        if(node->val >= low && node->val <= high) sum += node->val;\\n        inorder(node->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n        int sum=0;\\n        inorder(root, low, high, sum);\\n        return sum;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1021676,
                "title": "python-easy-explanation-2-methods",
                "content": "```\\nPlatform: leetcode.com\\n938. Range Sum of BST\\nLink: https://leetcode.com/problems/range-sum-of-bst/\\nDifficulty: Easy\\nAuthor: hritik5102\\nDate: 17/1/2021\\nSubmission: https://leetcode.com/submissions/detail/444136335/\\n(Time, Space) Complexity : O(n), O(H)\\n\\nRange sum of BST \\n\\n1.  We can solve this problem using recursion and iteration \\n\\niteration                                  Recursion \\n1. implemented using loops                  1. implemented using function calls \\n2. Defined by the control variable          2. Defined by the parameter value in the stack\\nvalue  \\n3. iteration makes size of Code            3. Recursion decreses the size of code\\nbigger                                      \\n4. Loop ends when control variable          4. Recursion ends when base case are True\\nsatisfy the condition \\n5. Infinite loops uses CPU Cycle            5. Infinite Recursion cause stack overflow at particular point or might crash the system\\n6. Execution is faster                      6. Execution is slower\\n```\\n\\n# Method 01 \\n# Inorder traversal ( Left child , Node , Right child)\\n\\n**Disadvantage of using Inorder traversal method**\\n\\n1. Using this approach we are visiting at each node of the binary tree and we are not utilizing the benefit of binary tree.\\n\\n2. Time: O(n), space: O(h), where n is the number of total nodes, h is the height of the tree.\\n\\n\\n```\\nclass Solution:    \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        output = []\\n        if root==None:\\n            return 0\\n        self.inOrderTraversal(root,low,high,output)\\n        return sum(output) \\n    \\n    def inOrderTraversal(self, root,low,high,output):\\n        if root == None:\\n            return\\n\\t\\t\\n\\t\\t# Left \\n        self.inOrderTraversal(root.left, low,high,output)\\n\\t\\t\\n\\t\\t# Node \\n        if low <= root.val <= high:\\n            output.append(root.val)\\n\\t\\t\\t\\n\\t\\t# Right\\n        self.inOrderTraversal(root.right, low,high,output)\\n\\n```\\n\\nSo what we do when we search a particular number in a binary tree\\n\\nfirst we check if a number is less then a root, if yes then we search in left subtree else if it\\'s greater then we search in right subtree of root node\\n\\nsame here, we see \\n```\\n1. if low < root :\\n\\t\\t inOrderTraversal( root.left, low, high)\\n\\n2. if High > root :\\n\\t\\t inOrderTraversal( root.right, low, high)     \\n```\\n\\n# Method 02 \\n```\\nclass Solution:    \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        output = []\\n        if root==None:\\n            return 0\\n        self.inOrderTraversal(root,low,high,output)\\n        return sum(output) \\n    \\n    def inOrderTraversal(self, root,low,high,output):\\n        if root == None:\\n            return\\n\\t\\t\\t\\n\\t\\t# left \\n        if low<root.val:\\n            self.inOrderTraversal(root.left, low,high,output)\\n\\t\\t\\n\\t\\t# Node\\n        if low <= root.val <= high:\\n            output.append(root.val)\\n\\t\\t\\n\\t\\t# RIght \\n        if high>root.val:\\n            self.inOrderTraversal(root.right, low,high,output)\\n```\\n\\n# Method 03 \\n## Same Logic but reduction in line of code\\n```\\nclass Solution:    \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        total = 0\\n        if root==None:\\n            return 0\\n        if low <= root.val <= high:\\n            total +=root.val\\n        if low<root.val:\\n            total += self.rangeSumBST(root.left, low,high)\\n        if high>root.val:\\n            total += self.rangeSumBST(root.right, low,high)\\n        \\n        return total \\n```\\n\\n        \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nPlatform: leetcode.com\\n938. Range Sum of BST\\nLink: https://leetcode.com/problems/range-sum-of-bst/\\nDifficulty: Easy\\nAuthor: hritik5102\\nDate: 17/1/2021\\nSubmission: https://leetcode.com/submissions/detail/444136335/\\n(Time, Space) Complexity : O(n), O(H)\\n\\nRange sum of BST \\n\\n1.  We can solve this problem using recursion and iteration \\n\\niteration                                  Recursion \\n1. implemented using loops                  1. implemented using function calls \\n2. Defined by the control variable          2. Defined by the parameter value in the stack\\nvalue  \\n3. iteration makes size of Code            3. Recursion decreses the size of code\\nbigger                                      \\n4. Loop ends when control variable          4. Recursion ends when base case are True\\nsatisfy the condition \\n5. Infinite loops uses CPU Cycle            5. Infinite Recursion cause stack overflow at particular point or might crash the system\\n6. Execution is faster                      6. Execution is slower\\n```\n```\\nclass Solution:    \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        output = []\\n        if root==None:\\n            return 0\\n        self.inOrderTraversal(root,low,high,output)\\n        return sum(output) \\n    \\n    def inOrderTraversal(self, root,low,high,output):\\n        if root == None:\\n            return\\n\\t\\t\\n\\t\\t# Left \\n        self.inOrderTraversal(root.left, low,high,output)\\n\\t\\t\\n\\t\\t# Node \\n        if low <= root.val <= high:\\n            output.append(root.val)\\n\\t\\t\\t\\n\\t\\t# Right\\n        self.inOrderTraversal(root.right, low,high,output)\\n\\n```\n```\\n1. if low < root :\\n\\t\\t inOrderTraversal( root.left, low, high)\\n\\n2. if High > root :\\n\\t\\t inOrderTraversal( root.right, low, high)     \\n```\n```\\nclass Solution:    \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        output = []\\n        if root==None:\\n            return 0\\n        self.inOrderTraversal(root,low,high,output)\\n        return sum(output) \\n    \\n    def inOrderTraversal(self, root,low,high,output):\\n        if root == None:\\n            return\\n\\t\\t\\t\\n\\t\\t# left \\n        if low<root.val:\\n            self.inOrderTraversal(root.left, low,high,output)\\n\\t\\t\\n\\t\\t# Node\\n        if low <= root.val <= high:\\n            output.append(root.val)\\n\\t\\t\\n\\t\\t# RIght \\n        if high>root.val:\\n            self.inOrderTraversal(root.right, low,high,output)\\n```\n```\\nclass Solution:    \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        total = 0\\n        if root==None:\\n            return 0\\n        if low <= root.val <= high:\\n            total +=root.val\\n        if low<root.val:\\n            total += self.rangeSumBST(root.left, low,high)\\n        if high>root.val:\\n            total += self.rangeSumBST(root.right, low,high)\\n        \\n        return total \\n```",
                "codeTag": "Java"
            },
            {
                "id": 939761,
                "title": "java-dfs-bfs-with-explanation",
                "content": "**DFS**\\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null)\\n            return 0;\\n        int sum = root.val <= high && root.val >= low ? root.val : 0;\\n        int left = 0;\\n        int right = 0;\\n        if(root.left != null){\\n            left = rangeSumBST(root.left,low,high);\\n        } \\n        if(root.right != null){\\n            right = rangeSumBST(root.right, low, high);\\n        }\\n        return sum + left + right;\\n    }\\n}\\n```\\n**BFS**\\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null)\\n            return 0;\\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\\n        q.add(root); // add root node\\n        int sum = 0;\\n        while(!q.isEmpty()){\\n            int itr = q.size();\\n            while(itr > 0){\\n                TreeNode dummy = q.poll();\\n                sum += (dummy.val >= low && dummy.val <= high) ? dummy.val : 0;\\n                if(dummy.left != null)\\n                    q.add(dummy.left);\\n                if(dummy.right != null)\\n                    q.add(dummy.right);\\n                itr--;\\n            }\\n        }\\n\\t\\treturn sum;\\n\\t}\\n}\\n```\\n   \\n**PROBLEM OVERVIEW**\\nWe are essentially tasked with finding the sum of all nodes whose values are between the inclusive range [low,high].\\n\\n**SOLUTION ASSESSMENT**\\nThe first things that come to mind are any tree-traversla algorithms (I have an inclination to utilize DFS or BFS, and I will show both approaches)\\n\\n**PSEUDOCODE RECURSION DFS**\\n```\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n1. If(root == null) return 0;\\n2. sum = node.val if within [low,high] : 0;\\n3. int leftSum = rangeSum(node.left,low,high); //left node\\n4. int rightSum = rangeSum(node.right,low,high); //right node\\n5. return sum + leftSum + rightSum\\n}\\n```\\n\\nThe heart of this solution lies with the recursive calls in lines 3-4. It will essentially visit all the nodes in the left branch and* return the leftSum* and all the right nodes in the branch and return the rightSum. Finally, the answer will be the current node + left + right.\\n\\n**PSUEDOCODE ITERATIVE BFS**\\n```\\n1. if root is null return 0; // corner case\\n2. initialize Queue<TreeNode> q and int sum\\n3. add root to q\\n4. while q is not empty {\\n\\t5. itr = q.size() // this is because the current \"size\" is the # of elements in that row\\n\\t6. while itr > 0\\n\\t\\t7. get node from list and add to answer if sum is in range\\n\\t\\t8. add left and right nodes if they exist\\n}\\n9. return sum\\n```\\nIn the BFS solution, the current Queue of TreeNodes is read in FIFO order, so it maintains an order (not that it matters in this problem). \\nThe key steps lie in 5 and 7-8; for 5 regulates the number of iterations in that particular \"row\" of the tree, which is the current size of the Queue. Line 7-8 add the children of that current row in left -> order.\\n\\n**TIME COMPLEXITY**\\nThe code for both runs in O(n) time complexity because it always visits every node.\\nNOTE: even though BFS solution has nested while loops, they are only called a maximum of n times, where n is the number of nodes in the tree.\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null)\\n            return 0;\\n        int sum = root.val <= high && root.val >= low ? root.val : 0;\\n        int left = 0;\\n        int right = 0;\\n        if(root.left != null){\\n            left = rangeSumBST(root.left,low,high);\\n        } \\n        if(root.right != null){\\n            right = rangeSumBST(root.right, low, high);\\n        }\\n        return sum + left + right;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null)\\n            return 0;\\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\\n        q.add(root); // add root node\\n        int sum = 0;\\n        while(!q.isEmpty()){\\n            int itr = q.size();\\n            while(itr > 0){\\n                TreeNode dummy = q.poll();\\n                sum += (dummy.val >= low && dummy.val <= high) ? dummy.val : 0;\\n                if(dummy.left != null)\\n                    q.add(dummy.left);\\n                if(dummy.right != null)\\n                    q.add(dummy.right);\\n                itr--;\\n            }\\n        }\\n\\t\\treturn sum;\\n\\t}\\n}\\n```\n```\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n1. If(root == null) return 0;\\n2. sum = node.val if within [low,high] : 0;\\n3. int leftSum = rangeSum(node.left,low,high); //left node\\n4. int rightSum = rangeSum(node.right,low,high); //right node\\n5. return sum + leftSum + rightSum\\n}\\n```\n```\\n1. if root is null return 0; // corner case\\n2. initialize Queue<TreeNode> q and int sum\\n3. add root to q\\n4. while q is not empty {\\n\\t5. itr = q.size() // this is because the current \"size\" is the # of elements in that row\\n\\t6. while itr > 0\\n\\t\\t7. get node from list and add to answer if sum is in range\\n\\t\\t8. add left and right nodes if they exist\\n}\\n9. return sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584412,
                "title": "2-javascript-solutions",
                "content": "You need to return sum of values in range of numbers between L and R. Not between nodes of L and R\\n```\\nvar rangeSumBST = function(root, L, R, sum=0) {\\n    if(!root) return sum;\\n    if(root.val<=R && root.val>=L)\\n        sum += root.val;\\n    return sum + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);\\n};\\n\\nvar rangeSumBST = function(root, L, R, sum=0) {\\n    let stack = [root];\\n    while(stack.length){\\n        let node = stack.pop();\\n        sum+=node.val>=L &&node.val<=R ? node.val : 0;\\n        if(node.left)\\n            stack.push(node.left);\\n        if(node.right)\\n            stack.push(node.right);\\n    }\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar rangeSumBST = function(root, L, R, sum=0) {\\n    if(!root) return sum;\\n    if(root.val<=R && root.val>=L)\\n        sum += root.val;\\n    return sum + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);\\n};\\n\\nvar rangeSumBST = function(root, L, R, sum=0) {\\n    let stack = [root];\\n    while(stack.length){\\n        let node = stack.pop();\\n        sum+=node.val>=L &&node.val<=R ? node.val : 0;\\n        if(node.left)\\n            stack.push(node.left);\\n        if(node.right)\\n            stack.push(node.right);\\n    }\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 469046,
                "title": "c-easy-fast-and-understandable",
                "content": "```\\nRuntime: 144 ms, faster than 86.30% of C++ online submissions for Range Sum of BST.\\nMemory Usage: 41 MB, less than 100.00% of C++ online submissions for Range Sum of BST.\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int counter = 0;\\n        \\n        rangeSum(root, counter, L, R);\\n        \\n        return counter;\\n    }\\n    \\n    void rangeSum(TreeNode* root, int& counter, int L, int R){\\n        \\n        if(root->val >= L && root->val <= R){\\n            counter += root->val;\\n        }\\n        if(root->left != NULL){\\n            rangeSum(root->left, counter, L, R);\\n        }\\n        if(root->right != NULL){\\n            rangeSum(root->right, counter, L, R);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nRuntime: 144 ms, faster than 86.30% of C++ online submissions for Range Sum of BST.\\nMemory Usage: 41 MB, less than 100.00% of C++ online submissions for Range Sum of BST.\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int counter = 0;\\n        \\n        rangeSum(root, counter, L, R);\\n        \\n        return counter;\\n    }\\n    \\n    void rangeSum(TreeNode* root, int& counter, int L, int R){\\n        \\n        if(root->val >= L && root->val <= R){\\n            counter += root->val;\\n        }\\n        if(root->left != NULL){\\n            rangeSum(root->left, counter, L, R);\\n        }\\n        if(root->right != NULL){\\n            rangeSum(root->right, counter, L, R);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885654,
                "title": "java-runtime-0ms-faster-than-100-recursive-iterative-solutions",
                "content": "# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(N)\\n\\n# Approach\\nDepth-First Search\\n\\n# Code\\nRecursive Implementation \\n```\\nclass Solution {\\n    private int sum = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return sum;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (low < root.val) rangeSumBST(root.left, low, high);\\n        if (root.val < high) rangeSumBST(root.right, low, high);\\n        return sum;\\n    }\\n}\\n```\\n\\nIterative Implementation\\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum = 0;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n\\n        while (!stack.empty()) {\\n            TreeNode current = stack.pop();\\n            if (current == null) continue;\\n            if (current.val >= low && current.val <= high) sum += current.val;\\n            if (low < current.val) stack.push(current.left);\\n            if (current.val < high) stack.push(current.right);\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n![\\u0421\\u043D\\u0438\\u043C\\u043E\\u043A \\u044D\\u043A\\u0440\\u0430\\u043D\\u0430 2022-12-07 \\u0432 06.04.34.png](https://assets.leetcode.com/users/images/efd4433e-de08-4faa-ac6d-0e80535a2838_1670382321.6916676.png)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int sum = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return sum;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (low < root.val) rangeSumBST(root.left, low, high);\\n        if (root.val < high) rangeSumBST(root.right, low, high);\\n        return sum;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum = 0;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n\\n        while (!stack.empty()) {\\n            TreeNode current = stack.pop();\\n            if (current == null) continue;\\n            if (current.val >= low && current.val <= high) sum += current.val;\\n            if (low < current.val) stack.push(current.left);\\n            if (current.val < high) stack.push(current.right);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2361957,
                "title": "java-short-0ms-solution-faster-than-100",
                "content": "Runtime: 0 ms, faster than 100.00% of Java online submissions for Range Sum of BST.\\nMemory Usage: 67.1 MB, less than 42.28% of Java online submissions for Range Sum of BST.\\n```\\nclass Solution {\\n    int sum = 0;\\n    int lo = 0; // low\\n    int hi = 0; // and high\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        lo = low;\\n        hi = high;\\n        addSum(root);\\n        return sum;\\n    }\\n    \\n    void addSum(TreeNode root) {\\n        if (root == null) return;\\n        if (root.val >= lo && root.val <= hi) { // if the root value is in the range\\n            sum += root.val; // add to sum\\n            addSum(root.left); // left\\n            addSum(root.right); // right\\n        } else if (root.val < lo) addSum(root.right); // if the root value is too small\\n        else addSum(root.left); // if the root value is too big\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int sum = 0;\\n    int lo = 0; // low\\n    int hi = 0; // and high\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        lo = low;\\n        hi = high;\\n        addSum(root);\\n        return sum;\\n    }\\n    \\n    void addSum(TreeNode root) {\\n        if (root == null) return;\\n        if (root.val >= lo && root.val <= hi) { // if the root value is in the range\\n            sum += root.val; // add to sum\\n            addSum(root.left); // left\\n            addSum(root.right); // right\\n        } else if (root.val < lo) addSum(root.right); // if the root value is too small\\n        else addSum(root.left); // if the root value is too big\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628151,
                "title": "daily-leetcoding-challenge-14-december-2021",
                "content": "**Solution in c++**\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        \\n        if(!root) return 0;\\n        int sum = 0;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        return sum + rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);\\n\\n    }\\n};\\n```\\n**if you understand solution then dont forget to upvote**",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        \\n        if(!root) return 0;\\n        int sum = 0;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        return sum + rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227687,
                "title": "c-easy-to-understand-iterative-o-n-time-complexity",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)**\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root==NULL)\\n        return 0;\\n        int sum=0;\\n        if(root->val<=high&&root->val>=low)\\n        {\\n            sum+=root->val;\\n        }\\n        if(root->val>high)\\n        {\\n            sum+=rangeSumBST(root->left,low,high);\\n        }\\n        else if(root->val<low)\\n        {\\n            sum+=rangeSumBST(root->right,low,high);\\n        }\\n        else\\n        {\\n            sum+=rangeSumBST(root->right,low,high)+rangeSumBST(root->left,low,high);\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root==NULL)\\n        return 0;\\n        int sum=0;\\n        if(root->val<=high&&root->val>=low)\\n        {\\n            sum+=root->val;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 936934,
                "title": "c-python-in-order-bst-traverse",
                "content": "```\\nclass Solution { // DFS: in-order traverse\\npublic: // Time/Space Complexity: O(N); O(N)\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        vector<int> nums;\\n        dfs(root, nums);\\n        int ans = 0;\\n        for(auto e: nums) \\n            if(e >= low && e <=high) ans += e;\\n        return ans;\\n    }\\n    \\nprivate:\\n    void dfs(TreeNode* root, vector<int>& nums){\\n        if(!root) return;\\n        dfs(root->left, nums);\\n        nums.push_back(root->val);\\n        dfs(root->right, nums);\\n    }\\n};\\n```\\n\\nApproach 2(python)\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        \\n        def dfs(root):\\n            if root:\\n                dfs(root.left)\\n                nums.append(root.val)\\n                dfs(root.right)\\n        \\n        nums=[]\\n        dfs(root)\\n        running_sum = list(itertools.accumulate(nums))\\n        left = max(bisect.bisect_left(nums, low)-1, 0)\\n        right = min(bisect.bisect_left(nums, high), len(nums) - 1)                \\n        return running_sum[right] - running_sum[left]\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nclass Solution { // DFS: in-order traverse\\npublic: // Time/Space Complexity: O(N); O(N)\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        vector<int> nums;\\n        dfs(root, nums);\\n        int ans = 0;\\n        for(auto e: nums) \\n            if(e >= low && e <=high) ans += e;\\n        return ans;\\n    }\\n    \\nprivate:\\n    void dfs(TreeNode* root, vector<int>& nums){\\n        if(!root) return;\\n        dfs(root->left, nums);\\n        nums.push_back(root->val);\\n        dfs(root->right, nums);\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        \\n        def dfs(root):\\n            if root:\\n                dfs(root.left)\\n                nums.append(root.val)\\n                dfs(root.right)\\n        \\n        nums=[]\\n        dfs(root)\\n        running_sum = list(itertools.accumulate(nums))\\n        left = max(bisect.bisect_left(nums, low)-1, 0)\\n        right = min(bisect.bisect_left(nums, high), len(nums) - 1)                \\n        return running_sum[right] - running_sum[left]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 572265,
                "title": "js-fast-and-simple-solution",
                "content": "\\n\\n```js\\nvar rangeSumBST = function(root, L, R) {\\n    if(!root)return 0  \\n    let v = (root.val <= R && root.val >= L)? root.val : 0\\n    return v + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```js\\nvar rangeSumBST = function(root, L, R) {\\n    if(!root)return 0  \\n    let v = (root.val <= R && root.val >= L)? root.val : 0\\n    return v + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 284771,
                "title": "javascript-recursive-solution",
                "content": "```\\nconst rangeSumBST = (root, L, R) => {\\n\\tif (root === null) {\\n  \\t    return 0;\\n    }    \\n\\n    return (root.val >= L && root.val <= R ? root.val : 0) + rangeSumBST(root.left, L , R) + rangeSumBST(root.right, L , R);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nconst rangeSumBST = (root, L, R) => {\\n\\tif (root === null) {\\n  \\t    return 0;\\n    }    \\n\\n    return (root.val >= L && root.val <= R ? root.val : 0) + rangeSumBST(root.left, L , R) + rangeSumBST(root.right, L , R);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 213098,
                "title": "rust-recursive-solution",
                "content": "```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn range_sum_bst(root: Option<Rc<RefCell<TreeNode>>>, l: i32, r: i32) -> i32 {\\n        if let Some(root) = root {\\n            let mut sum = 0;\\n            if l <= root.borrow().val && root.borrow().val <=r {\\n                sum += root.borrow().val;\\n            }\\n            \\n            if l < root.borrow().val {\\n                sum += Self::range_sum_bst(root.borrow().left.clone(), l, r);\\n            }\\n            \\n            if r > root.borrow().val {\\n                sum += Self::range_sum_bst(root.borrow().right.clone(), l, r);\\n            }\\n            return sum;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn range_sum_bst(root: Option<Rc<RefCell<TreeNode>>>, l: i32, r: i32) -> i32 {\\n        if let Some(root) = root {\\n            let mut sum = 0;\\n            if l <= root.borrow().val && root.borrow().val <=r {\\n                sum += root.borrow().val;\\n            }\\n            \\n            if l < root.borrow().val {\\n                sum += Self::range_sum_bst(root.borrow().left.clone(), l, r);\\n            }\\n            \\n            if r > root.borrow().val {\\n                sum += Self::range_sum_bst(root.borrow().right.clone(), l, r);\\n            }\\n            return sum;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3459881,
                "title": "my-rangesumbst",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} low\\n * @param {number} high\\n * @return {number}\\n */\\nvar rangeSumBST = function(root, low, high) {\\n    let sum=0;\\n\\n    if(root){\\n        sum+=(root.val>=low&&root.val<=high)?root.val:0;\\n        sum+=rangeSumBST(root.left,low,high);\\n        sum+=rangeSumBST(root.right,low,high);\\n    }\\n    \\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} low\\n * @param {number} high\\n * @return {number}\\n */\\nvar rangeSumBST = function(root, low, high) {\\n    let sum=0;\\n\\n    if(root){\\n        sum+=(root.val>=low&&root.val<=high)?root.val:0;\\n        sum+=rangeSumBST(root.left,low,high);\\n        sum+=rangeSumBST(root.right,low,high);\\n    }\\n    \\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2887527,
                "title": "java-100-solution-range-sum-of-bst",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return sum;\\n        if(root.val>=low && root.val<=high)\\n            sum+=root.val;\\n        \\n        sum+=rangeSumBST(root.left,low,high);\\n        sum+=rangeSumBST(root.right,low,high);\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return sum;\\n        if(root.val>=low && root.val<=high)\\n            sum+=root.val;\\n        \\n        sum+=rangeSumBST(root.left,low,high);\\n        sum+=rangeSumBST(root.right,low,high);\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886299,
                "title": "python-97-84-faster-explained-line-by-line-recursive-solution",
                "content": "```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\t    s = 0 # answer is zero initially\\n\\t    if root: # if we have a root\\n\\t\\t    if low <= root.val <= high: # if in the right range\\n\\t\\t\\t    s += root.val \\n            # if the root is in the range [low, high]\\n\\t\\t    if low <= root.val: \\n\\t\\t\\t    s += self.rangeSumBST(root.left,low,high) # add nodes to the left sub tree\\n\\t\\t    if root.val <= high: \\n\\t\\t\\t    s += self.rangeSumBST(root.right,low,high) # add nodes to the right sub tree\\n\\t    return s\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\t    s = 0 # answer is zero initially\\n\\t    if root: # if we have a root\\n\\t\\t    if low <= root.val <= high: # if in the right range\\n\\t\\t\\t    s += root.val \\n            # if the root is in the range [low, high]\\n\\t\\t    if low <= root.val: \\n\\t\\t\\t    s += self.rangeSumBST(root.left,low,high) # add nodes to the left sub tree\\n\\t\\t    if root.val <= high: \\n\\t\\t\\t    s += self.rangeSumBST(root.right,low,high) # add nodes to the right sub tree\\n\\t    return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886158,
                "title": "easy-explained-recursion-optimized-2-line-code-cpp",
                "content": "# Approach\\nWe are doing regular tree traversal and adding values within [L, R]. Note that in the solution description, we are given BST, however, this solution works for any binary tree.\\n\\n# CPP Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic://Thanks to Bhalerao-2002\\nint rangeSumBST(TreeNode* root, int L, int R) {\\n  if (root == nullptr) return 0;//If tree is not Exist \\n  return (root->val >= L && root->val <= R ? root->val : 0) +\\n    rangeSumBST(root->left, L, R)/*For Left Side traversal of BST*/ + rangeSumBST(root->right, L, R)/*For Right Side traversal of BST*/;\\n}\\n};\\n```\\n# Upvote If it Helped :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic://Thanks to Bhalerao-2002\\nint rangeSumBST(TreeNode* root, int L, int R) {\\n  if (root == nullptr) return 0;//If tree is not Exist \\n  return (root->val >= L && root->val <= R ? root->val : 0) +\\n    rangeSumBST(root->left, L, R)/*For Left Side traversal of BST*/ + rangeSumBST(root->right, L, R)/*For Right Side traversal of BST*/;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885461,
                "title": "97-27-fast-javascript-very-easy-to-understand-solution",
                "content": "Visit my youtube! Thank you!\\nhttps://www.youtube.com/channel/UCkhEaNAOO8tig5NHqqxXIeg\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} low\\n * @param {number} high\\n * @return {number}\\n */\\nvar rangeSumBST = function(root, low, high) {\\n    let sum = 0;\\n\\n    let iterate = (node=root) =>{\\n        if(!node) return;\\n\\n        iterate(node.left)\\n\\n        if(node.val>=low && node.val<=high) sum += node.val;\\n\\n        iterate(node.right)\\n    }\\n\\n    iterate()\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} low\\n * @param {number} high\\n * @return {number}\\n */\\nvar rangeSumBST = function(root, low, high) {\\n    let sum = 0;\\n\\n    let iterate = (node=root) =>{\\n        if(!node) return;\\n\\n        iterate(node.left)\\n\\n        if(node.val>=low && node.val<=high) sum += node.val;\\n\\n        iterate(node.right)\\n    }\\n\\n    iterate()\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2885377,
                "title": "c-easy-to-understand-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Case-1** : If currVal is in range [>=low && <= high] \\n         Then **traverse both** the left and right subtree\\n\\n**Case-2 :** If [currVal <= low] \\nThen traverse only the right subtree\\n\\n**Case-3 :** If [currVal >= high]\\nThen traverse only the left subtree\\n        \\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* curr, int& low, int& high)\\n    {\\n        if (curr == NULL) return 0;\\n        \\n        int ans = 0;\\n        bool isInRange = false;\\n        if (curr->val >= low && curr->val <= high) \\n        {\\n            isInRange = true;\\n            ans += curr->val;\\n        }\\n        \\n        if (isInRange || (curr->val <= low)) ans += solve(curr->right, low, high);\\n        if (isInRange || (curr->val >= high)) ans += solve(curr->left, low, high);\\n        return ans;\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n        return solve(root, low, high);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* curr, int& low, int& high)\\n    {\\n        if (curr == NULL) return 0;\\n        \\n        int ans = 0;\\n        bool isInRange = false;\\n        if (curr->val >= low && curr->val <= high) \\n        {\\n            isInRange = true;\\n            ans += curr->val;\\n        }\\n        \\n        if (isInRange || (curr->val <= low)) ans += solve(curr->right, low, high);\\n        if (isInRange || (curr->val >= high)) ans += solve(curr->left, low, high);\\n        return ans;\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n        return solve(root, low, high);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508766,
                "title": "python-elegant-short-recursive-three-lines",
                "content": "\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if root is None:\\n            return 0\\n        return self.rangeSumBST(root.left, low, high) + \\\\\\n               self.rangeSumBST(root.right, low, high) + \\\\\\n               root.val * (low <= root.val <= high)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if root is None:\\n            return 0\\n        return self.rangeSumBST(root.left, low, high) + \\\\\\n               self.rangeSumBST(root.right, low, high) + \\\\\\n               root.val * (low <= root.val <= high)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2369507,
                "title": "c-two-solutions-recursion-and-queue",
                "content": "Apporach 1: \\nUsing Inorder Traversal\\n```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n       if(root==NULL)\\n        {\\n            return sum;\\n        }\\n        rangeSumBST(root->left,low,high);\\n         if(root->val>high){\\n            return sum;\\n        }\\n        if(root->val>=low&&root->val<=high)\\n        {\\n            sum=sum+root->val;\\n        }\\n       rangeSumBST(root->right,low,high);\\n        return sum;\\n    }\\n};\\n```\\n\\nApproach 2:\\nUsing Queue and property of BST:\\nExplaination :\\n1. Take a Queue data structure and push root to it;\\n2. If node->val is in the range then both the subtrees can be in the range so we w\\'ll add both left and right child : node->right and node->right to the queue.\\n3. If the node->val is lower than (low) ,the left subtree will also be smaller than (low) but there is a possibility that its right child can be in the range , so we\\'ll eliminate left subtree and add node->right to the queue.\\n4. If the node->val is greater than (high),the rightt subtree will also be greater than (low) ,but  there is a possibility that its leftt child can be in the range , so we\\'ll eliminate right subtree and add node->right to the queue.\\n**CODE**\\n```\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root==NULL)return 0;\\n    int sum =0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n          TreeNode* node=q.front();\\n            q.pop();\\n            if(node->val<low)\\n            {\\n                if(node->right!=NULL)q.push(node->right);\\n            }\\n            else if(node->val >high && node->left!=NULL){\\n                q.push(node->left);                \\n            }\\n            else if(node->val>=low && node->val <=high){\\n                sum+=(node->val);\\n                if(node->left!=NULL)q.push(node->left);\\n                if(node->right!=NULL)q.push(node->right);\\n            } \\n        }\\n        return sum;\\n    }\\n\\n```",
                "solutionTags": [
                    "Binary Search Tree",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n       if(root==NULL)\\n        {\\n            return sum;\\n        }\\n        rangeSumBST(root->left,low,high);\\n         if(root->val>high){\\n            return sum;\\n        }\\n        if(root->val>=low&&root->val<=high)\\n        {\\n            sum=sum+root->val;\\n        }\\n       rangeSumBST(root->right,low,high);\\n        return sum;\\n    }\\n};\\n```\n```\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root==NULL)return 0;\\n    int sum =0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n          TreeNode* node=q.front();\\n            q.pop();\\n            if(node->val<low)\\n            {\\n                if(node->right!=NULL)q.push(node->right);\\n            }\\n            else if(node->val >high && node->left!=NULL){\\n                q.push(node->left);                \\n            }\\n            else if(node->val>=low && node->val <=high){\\n                sum+=(node->val);\\n                if(node->left!=NULL)q.push(node->left);\\n                if(node->right!=NULL)q.push(node->right);\\n            } \\n        }\\n        return sum;\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1943473,
                "title": "python-recursive-memory-usage-less-than-93",
                "content": "Upvote if it was usefull for you \\uD83D\\uDE42\\n\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        suma = 0\\n        def search(node):\\n            nonlocal suma\\n            if node:\\n                if node.val <= high and node.val >=low:\\n                    suma+=node.val\\n                search(node.left)\\n                search(node.right)\\n        search(root)\\n        return(suma)",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "Upvote if it was usefull for you \\uD83D\\uDE42\\n\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        suma = 0\\n        def search(node):\\n            nonlocal suma\\n            if node:\\n                if node.val <= high and node.val >=low:\\n                    suma+=node.val\\n                search(node.left)\\n                search(node.right)\\n        search(root)\\n        return(suma)",
                "codeTag": "Java"
            },
            {
                "id": 1628957,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int res=0;\\n    void fun(TreeNode* root, int low, int high){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(root->val<low){\\n            fun(root->right,low, high);\\n        }\\n        if(root->val>=low && root->val<=high){\\n            res+=root->val;\\n            fun(root->left,low, high);\\n            fun(root->right,low, high);\\n        }\\n        if(root->val>high){\\n            fun(root->left,low, high);\\n        }\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        fun(root, low, high);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res=0;\\n    void fun(TreeNode* root, int low, int high){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(root->val<low){\\n            fun(root->right,low, high);\\n        }\\n        if(root->val>=low && root->val<=high){\\n            res+=root->val;\\n            fun(root->left,low, high);\\n            fun(root->right,low, high);\\n        }\\n        if(root->val>high){\\n            fun(root->left,low, high);\\n        }\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        fun(root, low, high);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628367,
                "title": "c-super-simple-and-easy-recursive-solution",
                "content": "We iterate through the entire tree.\\nFor every node, if its value is within the range, we add it to `res`.\\n```\\nclass Solution {\\npublic:\\n    void rec(TreeNode* root, int low, int high) {\\n        if (!root) return;\\n        if (root->val <= high && root->val >= low) res += root->val;\\n        rec(root->left, low, high);\\n        rec(root->right, low, high);\\n    }\\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        rec(root, low, high);\\n        return res;\\n    }\\n    \\nprivate:\\n    int res = 0;\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rec(TreeNode* root, int low, int high) {\\n        if (!root) return;\\n        if (root->val <= high && root->val >= low) res += root->val;\\n        rec(root->left, low, high);\\n        rec(root->right, low, high);\\n    }\\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        rec(root, low, high);\\n        return res;\\n    }\\n    \\nprivate:\\n    int res = 0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434547,
                "title": "c-solution-91-faster-recursion",
                "content": "\\t/**\\n\\t * Definition for a binary tree node.\\n\\t * struct TreeNode {\\n\\t *     int val;\\n\\t *     TreeNode *left;\\n\\t *     TreeNode *right;\\n\\t *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n\\t * };\\n\\t */\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint sum=0;\\n\\t\\tint rangeSumBST(TreeNode* root, int low, int high) {\\n\\t\\t\\tif(root==NULL){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tif(root->val >= low && root->val <= high){\\n\\t\\t\\t\\tsum+=root->val;\\n\\t\\t\\t}\\n\\t\\t\\trangeSumBST(root->left,low,high);\\n\\t\\t\\trangeSumBST(root->right,low,high);\\n\\n\\t\\t\\treturn sum;\\n\\n\\n\\t\\t}\\n\\n\\t};\\n\\t\\n**\\tPlease upvote if it helped. **",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint sum=0;\\n\\t\\tint rangeSumBST(TreeNode* root, int low, int high) {\\n\\t\\t\\tif(root==NULL){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1387035,
                "title": "easy-recursive-python3-solution-faster-than-99",
                "content": "```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        s = 0\\n        def explore(root, low, high):\\n            nonlocal s\\n            if low<=root.val<=high:\\n                s += root.val\\n            if root.left and low<root.val:\\n                explore(root.left, low, high)\\n            if root.right and high>=root.val:\\n                explore(root.right, low, high)\\n        explore(root, low, high)\\n        return s\\n\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        s = 0\\n        def explore(root, low, high):\\n            nonlocal s\\n            if low<=root.val<=high:\\n                s += root.val\\n            if root.left and low<root.val:\\n                explore(root.left, low, high)\\n            if root.right and high>=root.val:\\n                explore(root.right, low, high)\\n        explore(root, low, high)\\n        return s\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 1011277,
                "title": "rust-treenode-implementation-could-be-simplified",
                "content": "Current TreeNode in rust looks like that \\n```\\npub struct TreeNode {\\n   pub val: i32,\\n   pub left: Option<Rc<RefCell<TreeNode>>>,\\n   pub right: Option<Rc<RefCell<TreeNode>>>,\\n }\\n ```\\n But since each node in tree has only one owner it could be simplified to \\n ```\\npub struct TreeNode {\\n    pub val: i32,\\n    pub left: Option<Box<TreeNode>>,\\n    pub right: Option<Box<TreeNode>>,\\n}\\n```\\nHow does it help ?\\n1. It will work faster since we don\\'t do reference counting. So compared to current 12-20 ms we will get  better results for rust.\\n2. Code to build tree becomes simpler.\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\npub struct TreeNode {\\n   pub val: i32,\\n   pub left: Option<Rc<RefCell<TreeNode>>>,\\n   pub right: Option<Rc<RefCell<TreeNode>>>,\\n }\\n ```\n```\\npub struct TreeNode {\\n    pub val: i32,\\n    pub left: Option<Box<TreeNode>>,\\n    pub right: Option<Box<TreeNode>>,\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936564,
                "title": "simple-dfs-solution-java",
                "content": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int[] res = new int[1];\\n        dfs(root, low, high, res);\\n        return res[0];\\n    }\\n    private void dfs(TreeNode root, int low, int high, int[] sum){\\n        if(root == null) return;\\n        if(root.val <= high && root.val >= low) sum[0] += root.val;\\n        dfs(root.left, low, high, sum);\\n        dfs(root.right, low, high, sum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int[] res = new int[1];\\n        dfs(root, low, high, res);\\n        return res[0];\\n    }\\n    private void dfs(TreeNode root, int low, int high, int[] sum){\\n        if(root == null) return;\\n        if(root.val <= high && root.val >= low) sum[0] += root.val;\\n        dfs(root.left, low, high, sum);\\n        dfs(root.right, low, high, sum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936292,
                "title": "c-super-simple-recursive-easiest-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    void rec(TreeNode* root, int low, int high) {\\n        if (!root) return;\\n        if (root->val <= high && root->val >= low) res+=root->val;\\n        rec(root->left, low, high);\\n        rec(root->right, low, high);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        rec(root, low, high);\\n        return res;\\n    }\\n    \\nprivate:\\n    int res = 0;\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rec(TreeNode* root, int low, int high) {\\n        if (!root) return;\\n        if (root->val <= high && root->val >= low) res+=root->val;\\n        rec(root->left, low, high);\\n        rec(root->right, low, high);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        rec(root, low, high);\\n        return res;\\n    }\\n    \\nprivate:\\n    int res = 0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 838391,
                "title": "brute-force-solution-optimal-solution-in-c",
                "content": "Brute-force solution is quite obvious, simply DFS the tree and add the current node value aslong as its in range L<-->R\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nvoid dfs(struct TreeNode* root,int l,int r,int *res) {\\n    if(root->val <=r && root->val >=l) (*res)+=root->val;\\n    if(root->left) dfs(root->left,l,r,res);\\n    if(root->right)dfs(root->right,l,r,res);\\n}\\nint rangeSumBST(struct TreeNode* root, int L, int R){\\n    int res = 0;\\n    dfs(root,L,R,&res);\\n    return res;\\n}\\n```\\n\\na more optimal solution is to check if the current node value is not in range of L<--->R then check if its lower than L or higher than R,\\nif its higher than R we need to check the left subtree(lower value elements).\\nelse if its lower than L we need to check the right subtree(higher value elements).\\nthus we reduce the traversal time on the tree\\ncode :\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nvoid dfs(struct TreeNode* root,int l,int r,int *res) {\\n    if(root->val <=r && root->val >=l){\\n       (*res)+=root->val; \\n    if(root->left)  dfs(root->left,l,r,res);\\n    if(root->right) dfs(root->right,l,r,res);\\n    \\n    } \\n    else if(root->val>r) {\\n        if(root->left) dfs(root->left,l,r,res);\\n    }\\n    else if(root->val<l)if(root->right) dfs(root->right,l,r,res);\\n\\n}\\nint rangeSumBST(struct TreeNode* root, int L, int R){\\n    int res = 0;\\n    dfs(root,L,R,&res);\\n    return res;\\n}\\n```\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nvoid dfs(struct TreeNode* root,int l,int r,int *res) {\\n    if(root->val <=r && root->val >=l) (*res)+=root->val;\\n    if(root->left) dfs(root->left,l,r,res);\\n    if(root->right)dfs(root->right,l,r,res);\\n}\\nint rangeSumBST(struct TreeNode* root, int L, int R){\\n    int res = 0;\\n    dfs(root,L,R,&res);\\n    return res;\\n}\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nvoid dfs(struct TreeNode* root,int l,int r,int *res) {\\n    if(root->val <=r && root->val >=l){\\n       (*res)+=root->val; \\n    if(root->left)  dfs(root->left,l,r,res);\\n    if(root->right) dfs(root->right,l,r,res);\\n    \\n    } \\n    else if(root->val>r) {\\n        if(root->left) dfs(root->left,l,r,res);\\n    }\\n    else if(root->val<l)if(root->right) dfs(root->right,l,r,res);\\n\\n}\\nint rangeSumBST(struct TreeNode* root, int L, int R){\\n    int res = 0;\\n    dfs(root,L,R,&res);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 813295,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if(root == null) return 0;\\n        return ((root.val >= L && root.val <= R) ? root.val : 0) + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if(root == null) return 0;\\n        return ((root.val >= L && root.val <= R) ? root.val : 0) + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783846,
                "title": "c-optimized-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(root == NULL) return 0;\\n        if(root->val<L) return rangeSumBST(root->right,L,R);\\n        else if(root->val>R) return rangeSumBST(root->left,L,R);\\n\\n        int ans = root->val;\\n        ans+= rangeSumBST(root->left,L,R);\\n        ans+= rangeSumBST(root->right,L,R);      \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(root == NULL) return 0;\\n        if(root->val<L) return rangeSumBST(root->right,L,R);\\n        else if(root->val>R) return rangeSumBST(root->left,L,R);\\n\\n        int ans = root->val;\\n        ans+= rangeSumBST(root->left,L,R);\\n        ans+= rangeSumBST(root->right,L,R);      \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 770913,
                "title": "sweet-short-recursive-c-solution-97-21",
                "content": "```\\nclass Solution {\\npublic:\\n  int rangeSumBST(TreeNode* root, int L, int R) {\\n    if(!root) return 0;\\n\\t// to save time we will only go to the left when we are not sure what lies on the left\\n\\t// in simple words, if the current root->val == L then there is no need to go to the left\\n\\t// because it is guaranteed all the values would be smaller than L\\n\\t// similarly for right too\\n    return ((root->val > L) ? rangeSumBST(root->left, L, R) : 0) + \\n\\t\\t   ((root->val < R) ? rangeSumBST(root->right, L, R) : 0) + \\n\\t\\t   ((root->val <= R && root->val >= L) ? root->val : 0);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int rangeSumBST(TreeNode* root, int L, int R) {\\n    if(!root) return 0;\\n\\t// to save time we will only go to the left when we are not sure what lies on the left\\n\\t// in simple words, if the current root->val == L then there is no need to go to the left\\n\\t// because it is guaranteed all the values would be smaller than L\\n\\t// similarly for right too\\n    return ((root->val > L) ? rangeSumBST(root->left, L, R) : 0) + \\n\\t\\t   ((root->val < R) ? rangeSumBST(root->right, L, R) : 0) + \\n\\t\\t   ((root->val <= R && root->val >= L) ? root->val : 0);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 739437,
                "title": "javascript-dfs",
                "content": "```\\nvar rangeSumBST = function(root, L, R) {\\n  return dfs(root, L, R)\\n};\\n\\nfunction dfs(root, L, R, res = 0){\\n  if(!root) return 0;\\n  if(root.val >= L && root.val <= R ){\\n    res = root.val;\\n  }\\n  return res + dfs(root.left, L, R) + dfs(root.right, L, R)\\n}\\n```\\n\\nAnother DFS option:\\n\\n```\\nvar rangeSumBST = function(root, L, R) {\\n  return dfs(root, L, R)\\n};\\n\\nfunction dfs(root, L, R, res = {total : 0}){\\n  if(!root) return res;\\n  if(root.val >= L && root.val <= R ){\\n    res.total += root.val;\\n  }\\n  dfs(root.left, L, R, res)\\n  dfs(root.right, L, R, res)\\n  return res.total;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar rangeSumBST = function(root, L, R) {\\n  return dfs(root, L, R)\\n};\\n\\nfunction dfs(root, L, R, res = 0){\\n  if(!root) return 0;\\n  if(root.val >= L && root.val <= R ){\\n    res = root.val;\\n  }\\n  return res + dfs(root.left, L, R) + dfs(root.right, L, R)\\n}\\n```\n```\\nvar rangeSumBST = function(root, L, R) {\\n  return dfs(root, L, R)\\n};\\n\\nfunction dfs(root, L, R, res = {total : 0}){\\n  if(!root) return res;\\n  if(root.val >= L && root.val <= R ){\\n    res.total += root.val;\\n  }\\n  dfs(root.left, L, R, res)\\n  dfs(root.right, L, R, res)\\n  return res.total;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 515506,
                "title": "intuitive-python-solution",
                "content": "I saw some inorder solutions for python , but like any other recursion problem, I like to just break it down into two parts:\\ni) recursive part.\\nii) base case to terminate recursion.\\n\\nBase case is trivial:\\n```\\nif not root:\\n  return 0\\n```\\n\\nCase I\\n```\\nif root.val > R \\n\\tans = self.rangeSum(root.left, L,R)\\n```\\nCase II\\n```\\nif root.val < L:\\n\\tans = self.rangeSum(root.right, L, R)\\n```\\nCase III\\nwhen root value lies in between\\n```\\n\\tans = root.val + self.rangeSum(root.left, L, R) + self.rangeSum(root.right, L, R)\\n```\\n\\nFull code beats 98%\\n\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        total = 0\\n        if root.val > R:\\n            total = self.rangeSumBST(root.left, L, R)\\n        elif root.val < L :\\n            total = self.rangeSumBST(root.right, L, R)\\n        else:\\n            total = root.val + self.rangeSumBST(root.left, L, R) \\\\\\n            + self.rangeSumBST(root.right, L, R)\\n        return total\\n```\\n\\n\\n\\n\\t",
                "solutionTags": [],
                "code": "```\\nif not root:\\n  return 0\\n```\n```\\nif root.val > R \\n\\tans = self.rangeSum(root.left, L,R)\\n```\n```\\nif root.val < L:\\n\\tans = self.rangeSum(root.right, L, R)\\n```\n```\\n\\tans = root.val + self.rangeSum(root.left, L, R) + self.rangeSum(root.right, L, R)\\n```\n```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        total = 0\\n        if root.val > R:\\n            total = self.rangeSumBST(root.left, L, R)\\n        elif root.val < L :\\n            total = self.rangeSumBST(root.right, L, R)\\n        else:\\n            total = root.val + self.rangeSumBST(root.left, L, R) \\\\\\n            + self.rangeSumBST(root.right, L, R)\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500831,
                "title": "java-beats-100-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n    \\n        if(root==null)\\n        return 0;\\n    \\n        else if(L<=root.val&&root.val<=R)\\n        return rangeSumBST(root.left,L,R)+rangeSumBST(root.right,L,R)+root.val;\\n    \\n        else if(L>root.val)\\n        return rangeSumBST(root.right,L,R);\\n    \\n        else \\n        return rangeSumBST(root.left,L,R);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n    \\n        if(root==null)\\n        return 0;\\n    \\n        else if(L<=root.val&&root.val<=R)\\n        return rangeSumBST(root.left,L,R)+rangeSumBST(root.right,L,R)+root.val;\\n    \\n        else if(L>root.val)\\n        return rangeSumBST(root.right,L,R);\\n    \\n        else \\n        return rangeSumBST(root.left,L,R);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 384415,
                "title": "c-solution",
                "content": "```\\nint rangeSumBST(struct TreeNode* root, int L, int R){\\n    if (root == NULL)\\n        return 0;\\n    else if (root->val >= L && root->val <= R)\\n        return root->val + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n    else\\n        return rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint rangeSumBST(struct TreeNode* root, int L, int R){\\n    if (root == NULL)\\n        return 0;\\n    else if (root->val >= L && root->val <= R)\\n        return root->val + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n    else\\n        return rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 290385,
                "title": "c-short-solution",
                "content": "```\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(nullptr == root) return 0;\\n        int sum = 0;\\n        if(root->val >= L && root->val <= R) sum += root->val;\\n        if(root->val <= R) sum += rangeSumBST(root->right, L, R);\\n        if(root->val >= L) sum += rangeSumBST(root->left, L, R);\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(nullptr == root) return 0;\\n        int sum = 0;\\n        if(root->val >= L && root->val <= R) sum += root->val;\\n        if(root->val <= R) sum += rangeSumBST(root->right, L, R);\\n        if(root->val >= L) sum += rangeSumBST(root->left, L, R);\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 260017,
                "title": "swift",
                "content": "\\n```\\nclass Solution {\\n    func rangeSumBST(_ root: TreeNode?, _ L: Int, _ R: Int) -> Int {\\n        var sum = 0\\n        guard let node = root else { return sum }\\n        if L <= node.val &&  node.val <= R {\\n            sum += node.val\\n        }\\n        if L < node.val {\\n            sum = sum + rangeSumBST(node.left, L, R)\\n        }\\n        if node.val < R {\\n            sum = sum + rangeSumBST(node.right, L, R)\\n        }\\n\\n        return sum\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func rangeSumBST(_ root: TreeNode?, _ L: Int, _ R: Int) -> Int {\\n        var sum = 0\\n        guard let node = root else { return sum }\\n        if L <= node.val &&  node.val <= R {\\n            sum += node.val\\n        }\\n        if L < node.val {\\n            sum = sum + rangeSumBST(node.left, L, R)\\n        }\\n        if node.val < R {\\n            sum = sum + rangeSumBST(node.right, L, R)\\n        }\\n\\n        return sum\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 194047,
                "title": "medium-i-don-t-think-so",
                "content": "No way this is medium, all the test cases pass without even adding the early termination condition. \\n```\\n    public int rangeSumBST(TreeNode root, int l, int r) {\\n    \\tStack<TreeNode> s = new Stack<>();\\n    \\ts.add(root);\\n    \\tint sum = 0;\\n    \\twhile(!s.isEmpty()) {\\n    \\t\\tTreeNode n = s.pop();\\n    \\t\\tif(n != null) {\\n        \\t\\tif(n.val >= l && n.val <= r) {\\n        \\t\\t\\tsum += n.val;\\n        \\t\\t}\\n        \\t\\tif(n.val > l) s.add(n.left);\\n        \\t\\tif(n.val < r) s.add(n.right); \\n    \\t\\t}  \\t\\t\\n    \\t}\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int rangeSumBST(TreeNode root, int l, int r) {\\n    \\tStack<TreeNode> s = new Stack<>();\\n    \\ts.add(root);\\n    \\tint sum = 0;\\n    \\twhile(!s.isEmpty()) {\\n    \\t\\tTreeNode n = s.pop();\\n    \\t\\tif(n != null) {\\n        \\t\\tif(n.val >= l && n.val <= r) {\\n        \\t\\t\\tsum += n.val;\\n        \\t\\t}\\n        \\t\\tif(n.val > l) s.add(n.left);\\n        \\t\\tif(n.val < r) s.add(n.right); \\n    \\t\\t}  \\t\\t\\n    \\t}\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 192875,
                "title": "simple-recursive-c-code-beats-100",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if (root ==NULL){return 0;}\\n        else if (root->val > R)\\n            return rangeSumBST(root->left, L,R);\\n        else if (root->val < L)\\n            return rangeSumBST(root->right, L,R);\\n        else\\n            return root->val+rangeSumBST(root->left,L,root->val)+rangeSumBST(root->right, root->val,R);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if (root ==NULL){return 0;}\\n        else if (root->val > R)\\n            return rangeSumBST(root->left, L,R);\\n        else if (root->val < L)\\n            return rangeSumBST(root->right, L,R);\\n        else\\n            return root->val+rangeSumBST(root->left,L,root->val)+rangeSumBST(root->right, root->val,R);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994954,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int sum = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null) {\\n            return 0;\\n        }\\n        if(root.val >= low && root.val <= high) {\\n            sum += root.val;\\n        }\\n        if(root.val > low) {\\n            rangeSumBST(root.left, low, high);\\n        }\\n        if(root.val < high) {\\n            rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int sum = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null) {\\n            return 0;\\n        }\\n        if(root.val >= low && root.val <= high) {\\n            sum += root.val;\\n        }\\n        if(root.val > low) {\\n            rangeSumBST(root.left, low, high);\\n        }\\n        if(root.val < high) {\\n            rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923247,
                "title": "easy-java-solution-for-beginners-binary-tree-concept-no-bst",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum = 0;\\n\\n        if(root == null) {\\n            return 0;\\n        }\\n        if(root.val >= low && root.val <= high) {\\n            sum += root.val;\\n        }\\n        if(root.val > low) {\\n            sum += rangeSumBST(root.left, low, high);\\n        }\\n        if(root.val < high) {\\n            sum += rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum = 0;\\n\\n        if(root == null) {\\n            return 0;\\n        }\\n        if(root.val >= low && root.val <= high) {\\n            sum += root.val;\\n        }\\n        if(root.val > low) {\\n            sum += rangeSumBST(root.left, low, high);\\n        }\\n        if(root.val < high) {\\n            sum += rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013606,
                "title": "very-easy-to-understand-beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum=0; \\n        if(root==NULL) return 0;\\n\\n        int l=rangeSumBST(root->left,low,high);\\n        int r=rangeSumBST(root->right,low,high);\\n\\n        sum=l+r;\\n\\n        if(root->val >= low && root->val <= high){\\n            sum+=root->val;\\n        }\\n\\n        return sum;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum=0; \\n        if(root==NULL) return 0;\\n\\n        int l=rangeSumBST(root->left,low,high);\\n        int r=rangeSumBST(root->right,low,high);\\n\\n        sum=l+r;\\n\\n        if(root->val >= low && root->val <= high){\\n            sum+=root->val;\\n        }\\n\\n        return sum;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2892550,
                "title": "c-easy-4-lines-approach",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\t//time: O(less than total nodes) i.e bcz we are moving on nodes in range[low,high], space: O(height)\\n\\t\\tint rangeSumBST(TreeNode* root, int low, int high) {\\n\\t\\t\\tif(root == NULL) return 0;\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tif(root->val >= low && root->val <= high)  sum += root->val;\\n\\t\\t\\tif(root->val >= low)  sum += rangeSumBST(root->left, low, high); //travel on left child\\n\\t\\t\\tif(root->val <= high)   sum += rangeSumBST(root->right, low, high); //travel on right child\\n\\t\\t\\treturn sum;\\n\\t   }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t//time: O(less than total nodes) i.e bcz we are moving on nodes in range[low,high], space: O(height)\\n\\t\\tint rangeSumBST(TreeNode* root, int low, int high) {\\n\\t\\t\\tif(root == NULL) return 0;\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tif(root->val >= low && root->val <= high)  sum += root->val;\\n\\t\\t\\tif(root->val >= low)  sum += rangeSumBST(root->left, low, high); //travel on left child\\n\\t\\t\\tif(root->val <= high)   sum += rangeSumBST(root->right, low, high); //travel on right child\\n\\t\\t\\treturn sum;\\n\\t   }",
                "codeTag": "Java"
            },
            {
                "id": 2886868,
                "title": "simple-tree-traversal",
                "content": "# Code\\n```\\n=class Solution \\n{\\n    private:\\n        int sum=0;\\n\\n    public:\\n        void treeTraversal(TreeNode* root, int low, int high)\\n        {\\n            if(root)\\n            {\\n                treeTraversal(root->left, low, high);\\n\\n                if(root->val >= low && root->val <= high)\\n                {\\n                    sum += root->val;\\n                }\\n\\n                treeTraversal(root->right, low, high);\\n            }\\n        }\\n\\n        int rangeSumBST(TreeNode* root, int low, int high)\\n        {\\n            treeTraversal(root, low, high);\\n            return sum;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n=class Solution \\n{\\n    private:\\n        int sum=0;\\n\\n    public:\\n        void treeTraversal(TreeNode* root, int low, int high)\\n        {\\n            if(root)\\n            {\\n                treeTraversal(root->left, low, high);\\n\\n                if(root->val >= low && root->val <= high)\\n                {\\n                    sum += root->val;\\n                }\\n\\n                treeTraversal(root->right, low, high);\\n            }\\n        }\\n\\n        int rangeSumBST(TreeNode* root, int low, int high)\\n        {\\n            treeTraversal(root, low, high);\\n            return sum;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886354,
                "title": "java-easy-to-understand-solution",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(H), where H is the height of the tree\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int ans;\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        ans = 0;\\n        dfs(root, L, R);\\n        return ans;\\n    }\\n\\n    public void dfs(TreeNode node, int L, int R) {\\n        if (node != null) {\\n            if (L <= node.val && node.val <= R)\\n                ans += node.val;\\n            if (L < node.val)\\n                dfs(node.left, L, R);\\n            if (node.val < R)\\n                dfs(node.right, L, R);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ans;\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        ans = 0;\\n        dfs(root, L, R);\\n        return ans;\\n    }\\n\\n    public void dfs(TreeNode node, int L, int R) {\\n        if (node != null) {\\n            if (L <= node.val && node.val <= R)\\n                ans += node.val;\\n            if (L < node.val)\\n                dfs(node.left, L, R);\\n            if (node.val < R)\\n                dfs(node.right, L, R);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885832,
                "title": "java-solution-0ms-beats-100",
                "content": "\\n```\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root == null) return 0;\\n        if(root.val > high) return rangeSumBST(root.left, low, high);\\n        if(root.val < low) return rangeSumBST(root.right, low, high);\\n        return root.val + rangeSumBST(root.left, low,high) + rangeSumBST(root.right, low, high); \\n    }  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root == null) return 0;\\n        if(root.val > high) return rangeSumBST(root.left, low, high);\\n        if(root.val < low) return rangeSumBST(root.right, low, high);\\n        return root.val + rangeSumBST(root.left, low,high) + rangeSumBST(root.right, low, high); \\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885646,
                "title": "easy-and-faster-than-98-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSelf Explainatory Code.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHopeYou Understand!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$ for recursion stack space\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint sum = 0; // Initialised Sum\\n    void Traversal(TreeNode* root,int low,int high)\\n    {\\n        if(root==NULL) // If Node is NULL then we return \\n        return;\\n        Traversal(root->left,low,high); // To check for left Node\\n        if(root->val <= high && root->val >=low)sum+=root->val;// If value of node is in range then add to sum.\\n        Traversal(root->right,low,high); // To check for right Node\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr); // To make input output fast\\n        Traversal(root,low,high); //To Traverse in BST\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint sum = 0; // Initialised Sum\\n    void Traversal(TreeNode* root,int low,int high)\\n    {\\n        if(root==NULL) // If Node is NULL then we return \\n        return;\\n        Traversal(root->left,low,high); // To check for left Node\\n        if(root->val <= high && root->val >=low)sum+=root->val;// If value of node is in range then add to sum.\\n        Traversal(root->right,low,high); // To check for right Node\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr); // To make input output fast\\n        Traversal(root,low,high); //To Traverse in BST\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2349128,
                "title": "range-sum-of-bst-by-using-inorder",
                "content": "\\'\\'\\'\\n\\nclass Solution {\\npublic:\\n    void inorder(TreeNode*root, vector<int>&v){\\n        if(root==NULL) return ;\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right, v);\\n        \\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        vector<int>v;\\n        inorder(root, v);\\n        int sum=0;\\n        for(int i=0; i<v.size();i++){\\n            if(v[i]>=low  && v[i]<=high){\\n               sum+=v[i]; \\n            }\\n        }\\n        return sum;\\n    }\\n}; \\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void inorder(TreeNode*root, vector<int>&v){\\n        if(root==NULL) return ;\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right, v);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1903109,
                "title": "faster-than-100-solution-java-algorithm",
                "content": "hello Leetcoder, hope you are well\\n\\nYpu are reading this means you want to konw other apporach or you are stuck in this problem, so\\nLet me help you\\n\\n**Problem Understanding**\\nThis problem is saying basically you have a Binary Search Tree and a range [low, high], you have to traverse through the BST and find all nodes which lies between the range and calculate sum of those nodes.\\n\\nNow think about BST property : we will use the this property to calculate the sum between range [low, high].\\n\\t* \\tLeft child\\'s root.data  < root.data\\n\\t* \\tright child\\'s root.data > root.data\\n![image](https://assets.leetcode.com/users/images/0893e510-f313-49b9-80a3-08b1fe050737_1648806799.7505903.png)\\n\\n**According to the above rule we can say this**\\n```\\n\\troot.val < low \\n\\t\\tWe don\\'t have to traverse left sub-tree cause all left sub tree nodes values will be less than low that we don\\'t need\\n\\troot.val > high\\n\\t\\tWe  don\\'t need to traverse right sub-tree cause all right sub-tree nodes value will be greater than high that we don\\'t need\\n```\\n\\nNow how we calculate the sum?\\n\\n**Algorithum**\\n1. check base case : root == null ?\\n2. now element sub-trees based on above assumption.\\n3. if root.data lies between range[low, high], call for both left and right sub-tree and add current node value into sum\\n4. return this sum;\\n\\nTime complexity   T(n) = O(n)\\n\\n**Code**\\n\\n```\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root == null) return 0;\\n        \\n        if(root.val < low) { // discard the left sub-tree\\n            return rangeSumBST(root.right, low, high);\\n        }\\n        \\n        if(root.val > high) { //  discard the right sub-tree\\n            return rangeSumBST(root.left, low, high);\\n        }\\n        \\n        return rangeSumBST(root.left, low, high) + root.val + rangeSumBST(root.right, low, high);\\n    }\\n```\\n\\t\\t\\t\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n\\troot.val < low \\n\\t\\tWe don\\'t have to traverse left sub-tree cause all left sub tree nodes values will be less than low that we don\\'t need\\n\\troot.val > high\\n\\t\\tWe  don\\'t need to traverse right sub-tree cause all right sub-tree nodes value will be greater than high that we don\\'t need\\n```\n```\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root == null) return 0;\\n        \\n        if(root.val < low) { // discard the left sub-tree\\n            return rangeSumBST(root.right, low, high);\\n        }\\n        \\n        if(root.val > high) { //  discard the right sub-tree\\n            return rangeSumBST(root.left, low, high);\\n        }\\n        \\n        return rangeSumBST(root.left, low, high) + root.val + rangeSumBST(root.right, low, high);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1842871,
                "title": "recurisve-python-solution-with-comments",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def rangeSumBST(self, root, low, high):\\n        if not(root): return root\\n        # return nextNode(root, low, high, 0)\\n        return getsum(root, low, high, 0)\\n    \\n    \\n# Ordinary: Binary Tree Recursion;\\ndef nextNode(root, lo, hi, sumi):\\n    # base case;\\n    if not(root): return sumi\\n    # main case\\n    sumi = nextNode(root.left, lo, hi, sumi)\\n    if(root.val >= lo and root.val <= hi):\\n        sumi = sumi + root.val\\n    sumi = nextNode(root.right, lo, hi, sumi)\\n    return sumi\\n\\n\\n# Little More Optimized\\ndef getsum(root, lo, hi, res):\\n    if not root: \\n        return res\\n    if(root.val >= lo and root.val <= hi):\\n        res += root.val\\n    if(root.val > lo):                      # going left only when root\\'s value greater than low;\\n        res = getsum(root.left,lo,hi,res)\\n    if(root.val <= hi):                     # going right onyl when root\\'s value smaller than high;\\n        res = getsum(root.right,lo,hi,res)\\n    return res\\n            \\n        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def rangeSumBST(self, root, low, high):\\n        if not(root): return root\\n        # return nextNode(root, low, high, 0)\\n        return getsum(root, low, high, 0)\\n    \\n    \\n# Ordinary: Binary Tree Recursion;\\ndef nextNode(root, lo, hi, sumi):\\n    # base case;\\n    if not(root): return sumi\\n    # main case\\n    sumi = nextNode(root.left, lo, hi, sumi)\\n    if(root.val >= lo and root.val <= hi):\\n        sumi = sumi + root.val\\n    sumi = nextNode(root.right, lo, hi, sumi)\\n    return sumi\\n\\n\\n# Little More Optimized\\ndef getsum(root, lo, hi, res):\\n    if not root: \\n        return res\\n    if(root.val >= lo and root.val <= hi):\\n        res += root.val\\n    if(root.val > lo):                      # going left only when root\\'s value greater than low;\\n        res = getsum(root.left,lo,hi,res)\\n    if(root.val <= hi):                     # going right onyl when root\\'s value smaller than high;\\n        res = getsum(root.right,lo,hi,res)\\n    return res\\n            \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829411,
                "title": "scala-tailrec",
                "content": "```\\ndef rangeSumBST(root: TreeNode, low: Int, high: Int): Int = {\\n        import scala.util.control.TailCalls.{TailRec, done}\\n        def dfs(tn: TreeNode) : TailRec[Int] = tn match {\\n            case null => done(0)\\n            case n =>\\n                val t = if (low <= n.value && n.value <= high) n.value else 0\\n                for {\\n                    l <- dfs(n.left)\\n                    r <- dfs(n.right)\\n                } yield l + r + t\\n        }\\n        dfs(root).result\\n    }\\n```",
                "solutionTags": [
                    "Scala",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef rangeSumBST(root: TreeNode, low: Int, high: Int): Int = {\\n        import scala.util.control.TailCalls.{TailRec, done}\\n        def dfs(tn: TreeNode) : TailRec[Int] = tn match {\\n            case null => done(0)\\n            case n =>\\n                val t = if (low <= n.value && n.value <= high) n.value else 0\\n                for {\\n                    l <- dfs(n.left)\\n                    r <- dfs(n.right)\\n                } yield l + r + t\\n        }\\n        dfs(root).result\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1769566,
                "title": "c-recursion-easy",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint rangeSumBST(TreeNode* root, int low, int high) {\\n\\t\\t\\tif(root==NULL)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\tif(root->val > high)\\n\\t\\t\\t\\treturn rangeSumBST(root->left , low , high);\\n\\t\\t\\telse if(root->val < low)\\n\\t\\t\\t\\treturn rangeSumBST(root->right , low , high);\\n\\t\\t\\treturn root->val + rangeSumBST(root->left , low , high) + \\n\\t\\t\\t\\t   rangeSumBST(root->right , low , high);\\n\\t\\t}\\n\\t};\\n\\n\\tfeel free to ask your doubts :)\\n\\tand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint rangeSumBST(TreeNode* root, int low, int high) {\\n\\t\\t\\tif(root==NULL)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\tif(root->val > high)\\n\\t\\t\\t\\treturn rangeSumBST(root->left , low , high);\\n\\t\\t\\telse if(root->val < low)\\n\\t\\t\\t\\treturn rangeSumBST(root->right , low , high);\\n\\t\\t\\treturn root->val + rangeSumBST(root->left , low , high) + \\n\\t\\t\\t\\t   rangeSumBST(root->right , low , high);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1724362,
                "title": "python3-faster",
                "content": "```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if root is None:\\n            return 0\\n        summ=0\\n        if root.val>=low and root.val<=high:\\n            summ+=root.val\\n        summ=summ+self.rangeSumBST(root.left,low,high)\\n        summ=summ+self.rangeSumBST(root.right,low,high)\\n        return summ\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if root is None:\\n            return 0\\n        summ=0\\n        if root.val>=low and root.val<=high:\\n            summ+=root.val\\n        summ=summ+self.rangeSumBST(root.left,low,high)\\n        summ=summ+self.rangeSumBST(root.right,low,high)\\n        return summ\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682399,
                "title": "java-easy-recursion-o-n-0ms-faster-than-100-submission",
                "content": "```\\nclass Solution{\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n      if(root==null) return 0;\\n        if(root.val>low && root.val>high){\\n           return rangeSumBST(root.left,low,high);\\n        }else if(root.val<low && root.val<high){\\n            return rangeSumBST(root.right,low,high);\\n        }else{\\n            int l=rangeSumBST(root.left,low,high);\\n            int r=rangeSumBST(root.right,low,high);\\n            return l+r+root.val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n      if(root==null) return 0;\\n        if(root.val>low && root.val>high){\\n           return rangeSumBST(root.left,low,high);\\n        }else if(root.val<low && root.val<high){\\n            return rangeSumBST(root.right,low,high);\\n        }else{\\n            int l=rangeSumBST(root.left,low,high);\\n            int r=rangeSumBST(root.right,low,high);\\n            return l+r+root.val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629351,
                "title": "easy-to-understand-python-solution",
                "content": "```\\ndef rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\tif not root:                               # If the node does not exist or is null\\n\\t\\treturn 0                               # add a 0 value for that node\\n\\t\\n\\telif root.val >= low and root.val <= high: # If it exists and is in the inclusive range of low and high, return it\\'s val\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t       # and recurse into left and right branches\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\t\\t\\n\\t\\treturn root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)\\n\\t\\n\\telse:                                      # If it exists but is outside of the range, we still\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t       # recurse into left and right branches because a child node may be in range\\n\\t\\treturn self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)\\n```\\n\\n\\n\\nOptimized version:\\n\\n```\\ndef rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\tif not root:\\n\\t\\treturn 0\\n\\telif root.val >= low and root.val <= high:\\n\\t\\treturn root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)\\n\\t\\n\\telif root.val < low:                               # If the node is less than the low range,\\n\\t\\treturn self.rangeSumBST(root.right, low, high) # all left children will also be, so we only pursue right\\n\\t\\n\\telif root.val > high:                              # same principle here, but in the other direction\\n\\t\\treturn self.rangeSumBST(root.left, low, high)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\tif not root:                               # If the node does not exist or is null\\n\\t\\treturn 0                               # add a 0 value for that node\\n\\t\\n\\telif root.val >= low and root.val <= high: # If it exists and is in the inclusive range of low and high, return it\\'s val\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t       # and recurse into left and right branches\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\t\\t\\n\\t\\treturn root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)\\n\\t\\n\\telse:                                      # If it exists but is outside of the range, we still\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t       # recurse into left and right branches because a child node may be in range\\n\\t\\treturn self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)\\n```\n```\\ndef rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\tif not root:\\n\\t\\treturn 0\\n\\telif root.val >= low and root.val <= high:\\n\\t\\treturn root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)\\n\\t\\n\\telif root.val < low:                               # If the node is less than the low range,\\n\\t\\treturn self.rangeSumBST(root.right, low, high) # all left children will also be, so we only pursue right\\n\\t\\n\\telif root.val > high:                              # same principle here, but in the other direction\\n\\t\\treturn self.rangeSumBST(root.left, low, high)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1628460,
                "title": "c-99-faster-93-less-space-using-std-stack",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        uint32_t sum = 0;\\n        std::stack<TreeNode*> nodes_to_pass;\\n        nodes_to_pass.push(root);\\n        while(!nodes_to_pass.empty()) {\\n            TreeNode* current_node = nodes_to_pass.top();\\n            if (current_node->val >= low && current_node->val <= high) {\\n                sum += current_node->val;\\n            }\\n            nodes_to_pass.pop();\\n            if (current_node->left && current_node->val >= low) {\\n                nodes_to_pass.push(current_node->left);\\n            }\\n            if (current_node->right && current_node->val <= high) {\\n                nodes_to_pass.push(current_node->right);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        uint32_t sum = 0;\\n        std::stack<TreeNode*> nodes_to_pass;\\n        nodes_to_pass.push(root);\\n        while(!nodes_to_pass.empty()) {\\n            TreeNode* current_node = nodes_to_pass.top();\\n            if (current_node->val >= low && current_node->val <= high) {\\n                sum += current_node->val;\\n            }\\n            nodes_to_pass.pop();\\n            if (current_node->left && current_node->val >= low) {\\n                nodes_to_pass.push(current_node->left);\\n            }\\n            if (current_node->right && current_node->val <= high) {\\n                nodes_to_pass.push(current_node->right);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627963,
                "title": "python3-iterative-bfs-explained",
                "content": "We are using a queue to do the Breadth-First Search iteratively. For every node, we check whether the value is in the range. Children are added to the queue only if they can have nodes in the given range using the main property of the Binary Tree: greater nodes go to the right, smaller nodes to the left. That allows us to avoid useless passes through the tree.\\n\\nTime: **O(N)** - for the BFS\\nSpace: **O(logN)** - for the queue\\n\\nRuntime: 196 ms, faster than **94.28%** of Python3 online submissions for Range Sum of BST.\\nMemory Usage: 22.4 MB, less than **5.88%** of Python3 online submissions for Range Sum of BST.\\n\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], lo: int, hi: int) -> int:\\n        res = 0\\n        \\n        q = deque([root])\\n        while q:\\n            c = q.popleft()\\n            v, l, r = c.val, c.left, c.right\\n\\n            if lo <= v and v <= hi:\\n                res += v\\n                \\n            if l and (lo < v or v > hi):\\n                q.append(l)\\n                \\n            if r and (lo > v or v < hi):\\n                q.append(r)\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], lo: int, hi: int) -> int:\\n        res = 0\\n        \\n        q = deque([root])\\n        while q:\\n            c = q.popleft()\\n            v, l, r = c.val, c.left, c.right\\n\\n            if lo <= v and v <= hi:\\n                res += v\\n                \\n            if l and (lo < v or v > hi):\\n                q.append(l)\\n                \\n            if r and (lo > v or v < hi):\\n                q.append(r)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627949,
                "title": "easy-recursive-solution-in-c",
                "content": "\\n//smjh\\n\\n``` \\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        \\n      if(root == NULL) return 0;\\n        \\n       if(root->val > high){\\n           return rangeSumBST(root->left,low ,high);\\n       }\\n        else if(root->val <low){\\n            return rangeSumBST(root->right,low,high);\\n        }\\n        \\n        return root->val + rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n        \\n    }\\n\\t\\nDo upvote if you find it helpful",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "\\n//smjh\\n\\n``` \\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        \\n      if(root == NULL) return 0;\\n        \\n       if(root->val > high){\\n           return rangeSumBST(root->left,low ,high);\\n       }\\n        else if(root->val <low){\\n            return rangeSumBST(root->right,low,high);\\n        }\\n        \\n        return root->val + rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n        \\n    }\\n\\t\\nDo upvote if you find it helpful",
                "codeTag": "Unknown"
            },
            {
                "id": 1627797,
                "title": "python3-clean-7-lines-o-n-time-beats-94-28-o-n-space-dfs",
                "content": "Below is the code, please let me know if you have any questions!\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if not root: return 0\\n        res = root.val if low <= root.val <= high else 0\\n        if root.val <= low: return res + self.rangeSumBST(root.right, low, high)\\n        if root.val >= high: return res + self.rangeSumBST(root.left, low, high)\\n        return res + self.rangeSumBST(root.right, low, high) + self.rangeSumBST(root.left, low, high)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if not root: return 0\\n        res = root.val if low <= root.val <= high else 0\\n        if root.val <= low: return res + self.rangeSumBST(root.right, low, high)\\n        if root.val >= high: return res + self.rangeSumBST(root.left, low, high)\\n        return res + self.rangeSumBST(root.right, low, high) + self.rangeSumBST(root.left, low, high)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518247,
                "title": "c-recursive-solution",
                "content": "**Uncomment the commented part to see the recursive call pattern for better understanding.**\\n*Do upvote if you understand the solution : )*\\n\\n```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n      \\n      if(root == NULL) \\n      {\\n          // cout<<\" sum : \"<<sum<<endl;\\n          return sum;\\n      }\\n      // cout<<\"For value : \"<<root->val<<\" sum : \"<<sum<<endl;\\n\\n      if(root->val>=low && root->val<=high)\\n      {\\n          sum+=root->val;\\n          rangeSumBST(root->left,low,high);\\n          rangeSumBST(root->right,low,high);\\n      }\\n      else if (root->val < low)\\n      {\\n        rangeSumBST(root->right,low,high);\\n      }\\n      else\\n      {\\n        rangeSumBST(root->left,low,high);\\n      }\\n    return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n      \\n      if(root == NULL) \\n      {\\n          // cout<<\" sum : \"<<sum<<endl;\\n          return sum;\\n      }\\n      // cout<<\"For value : \"<<root->val<<\" sum : \"<<sum<<endl;\\n\\n      if(root->val>=low && root->val<=high)\\n      {\\n          sum+=root->val;\\n          rangeSumBST(root->left,low,high);\\n          rangeSumBST(root->right,low,high);\\n      }\\n      else if (root->val < low)\\n      {\\n        rangeSumBST(root->right,low,high);\\n      }\\n      else\\n      {\\n        rangeSumBST(root->left,low,high);\\n      }\\n    return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1324875,
                "title": "java-cpp-one-liner-soln-brute-force-and-java-clean-soln-using-bst",
                "content": "Java:\\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        \\n        return (root != null && root.val <= high && root.val >= low ? root.val : 0) + (root == null ? 0 : rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high));\\n    }\\n}\\n```\\ncpp:\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n        return (root != NULL && root->val <= high && root->val >= low ? root->val : 0) + (root == NULL ? 0 : rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high));\\n    }\\n};\\n```\\n\\nJava (clean code):\\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        \\n        if (root == null) return 0;\\n        \\n        if (root.val >= low && root.val <= high) {\\n            \\n            return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);\\n        }\\n        else if (root.val < low) {\\n            \\n            return rangeSumBST(root.right, low, high);\\n        }\\n        \\n        else {\\n            return rangeSumBST(root.left, low, high);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Binary Search",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        \\n        return (root != null && root.val <= high && root.val >= low ? root.val : 0) + (root == null ? 0 : rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high));\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n        return (root != NULL && root->val <= high && root->val >= low ? root->val : 0) + (root == NULL ? 0 : rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high));\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        \\n        if (root == null) return 0;\\n        \\n        if (root.val >= low && root.val <= high) {\\n            \\n            return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);\\n        }\\n        else if (root.val < low) {\\n            \\n            return rangeSumBST(root.right, low, high);\\n        }\\n        \\n        else {\\n            return rangeSumBST(root.left, low, high);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309553,
                "title": "100-faster-and-99-5-less-memory-consumption-c-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        \\n        if(root==NULL){\\n            return sum;\\n        }\\n       \\n        if(root->val>=low&&root->val<=high){\\n                sum+=root->val;\\n        }\\n        rangeSumBST(root->left,low, high);\\n        rangeSumBST(root->right,low, high);\\n        root->left=root->right=nullptr;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        \\n        if(root==NULL){\\n            return sum;\\n        }\\n       \\n        if(root->val>=low&&root->val<=high){\\n                sum+=root->val;\\n        }\\n        rangeSumBST(root->left,low, high);\\n        rangeSumBST(root->right,low, high);\\n        root->left=root->right=nullptr;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1298049,
                "title": "c-recursion-dfs-bst-property-usage",
                "content": "Some of the recent solutions that I\\'ve seen is missing important BST property in their codes. \\nHere is the code that uses BST property during traversing.\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(!root)\\n            return 0;\\n        if(root->val>=low and root->val<=high)\\n            return root->val+rangeSumBST(root->left,low,high)+rangeSumBST(root->right,low,high);\\n        else if(root->val<low)\\n            return rangeSumBST(root->right,low,high);\\n        else\\n            return rangeSumBST(root->left,low,high);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(!root)\\n            return 0;\\n        if(root->val>=low and root->val<=high)\\n            return root->val+rangeSumBST(root->left,low,high)+rangeSumBST(root->right,low,high);\\n        else if(root->val<low)\\n            return rangeSumBST(root->right,low,high);\\n        else\\n            return rangeSumBST(root->left,low,high);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1292484,
                "title": "3-line-code-lmaooooo-dfs",
                "content": "**I don\\'t think this code requires intiution but for beginner here is the brute force first approach all you need to calculate sum right? so what you could do is check if your root value is lie b/w the range just add it in your answer and call on your left and right childs and add their answer too return the answer**\\n\\n\\n**since it\\'s BST we can improve our logic check if your root->val is greater than high? if yes this means no need to call on right child it will never give you an answer so call on only left now check if root->val is less than low? if yes no need to call on left it won\\'t give you an answer so call on right only now if both the cases are not true it means your root value is lie  b/w range so add root->val in your answer and call on left and right simple that\\'s it bois/girls.......... don\\'t forget to upvote \\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(!root)return 0;\\n        if(root->val>high)return rangeSumBST(root->left, low,high);\\n        else if(root->val<low)return rangeSumBST(root->right,low,high);\\n        else return root->val + rangeSumBST(root->left, low,high) + rangeSumBST(root->right,low,high);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(!root)return 0;\\n        if(root->val>high)return rangeSumBST(root->left, low,high);\\n        else if(root->val<low)return rangeSumBST(root->right,low,high);\\n        else return root->val + rangeSumBST(root->left, low,high) + rangeSumBST(root->right,low,high);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248688,
                "title": "simple-recursive-java-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int ans=0;\\n        if(root==null)return ans;\\n        ans+=rangeSumBST(root.left,low,high);\\n        if(inRange(root.val,low,high))ans+=root.val;\\n        ans+=rangeSumBST(root.right,low,high);\\n        return ans;\\n    }\\n    public boolean inRange(int n,int low,int high)\\n    {\\n        return n>=low&&n<=high;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int ans=0;\\n        if(root==null)return ans;\\n        ans+=rangeSumBST(root.left,low,high);\\n        if(inRange(root.val,low,high))ans+=root.val;\\n        ans+=rangeSumBST(root.right,low,high);\\n        return ans;\\n    }\\n    public boolean inRange(int n,int low,int high)\\n    {\\n        return n>=low&&n<=high;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243988,
                "title": "c-better-than-o-n-clean",
                "content": "**if the current node value is not in the range  low and high  then you have decide if is it possible to go right   and left**\\n\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        \\n        if(root==NULL)\\n            return 0;\\n        if(root->val<=high and root->val>=low)\\n            return root->val + rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n        if(root->val>high)\\n            return  rangeSumBST(root->left,low,high);\\n        if(root->val<low)\\n            return rangeSumBST(root->right,low,high);    \\n        return 0;\\n        \\n    }",
                "solutionTags": [],
                "code": "**if the current node value is not in the range  low and high  then you have decide if is it possible to go right   and left**\\n\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        \\n        if(root==NULL)\\n            return 0;\\n        if(root->val<=high and root->val>=low)\\n            return root->val + rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n        if(root->val>high)\\n            return  rangeSumBST(root->left,low,high);\\n        if(root->val<low)\\n            return rangeSumBST(root->right,low,high);    \\n        return 0;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1219173,
                "title": "easy-java-recursion",
                "content": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null) return 0;\\n        int rootsum =0;\\n        int ls = rangeSumBST(root.left, low, high);\\n        int rs = rangeSumBST(root.right, low, high);\\n        if(root.val>= low && root.val <= high) rootsum = root.val;\\n        else rootsum = 0;\\n        int sum = ls+ rs+ rootsum;\\n        \\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null) return 0;\\n        int rootsum =0;\\n        int ls = rangeSumBST(root.left, low, high);\\n        int rs = rangeSumBST(root.right, low, high);\\n        if(root.val>= low && root.val <= high) rootsum = root.val;\\n        else rootsum = 0;\\n        int sum = ls+ rs+ rootsum;\\n        \\n        return sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1218050,
                "title": "use-of-the-fact-that-it-is-bst-explaination-beginner-90-fast",
                "content": "**JUST WANT TO GET IMPLEMENTATION JUMP TO CODE**\\n\\nBasic property of bst is that it contains its left child as smaller or equal to node and its right child greater to it,(the equal child can be kept any of the side).\\n\\n\\nin the given diagram \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t10\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t/   \\\\\\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t5          15\\n\\t\\t\\t\\t\\t\\t\\t   /  \\\\\\\\           \\\\\\\\\\n\\t\\t\\t\\t\\t\\t\\t 3       7           18\\nthe node value(10) is in given range therefore the possibilty of having a in-range value on both subtrees  is possible,\\ntherefore we take a extra memory(taking queue) and add both its child to it\\nQueue has 5,15 now .\\npicking 5(as of fifo).\\nnow 5 is smaller than the lower value but its right child can have a value greater to it which might be in  given range,so we eliminate the left subtree and add the right child of it to the queue.\\n\\nnow,queue become 15,7.\\nas 15 is in range we\"ll again add both of its child to queue.\\nand the process goes....\\nthe moment we get a node in given range we take the sum of it and add it to a variable.\\n\\n\\n**CODE**\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n          if(root==NULL)return 0;\\n        queue<TreeNode*>q;\\n        int res=0;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode*temp=q.front();\\n            q.pop();\\n            if(temp->val<low)\\n            {\\n                if(temp->right!=NULL)q.push(temp->right);\\n            }\\n            else if(temp->val>high)\\n            {\\n                if(temp->left!=NULL)q.push(temp->left);\\n            }\\n\\n            else if(temp->val>=low&&temp->val<=high)\\n            {\\n                res+=temp->val;\\n                if(temp->left!=NULL)q.push(temp->left);\\n                if(temp->right!=NULL)q.push(temp->right);   \\n            }\\n           \\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n```\\n\\n**HAPPY CODING!**\\n\\n\\n\\n\\n\\t\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n          if(root==NULL)return 0;\\n        queue<TreeNode*>q;\\n        int res=0;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode*temp=q.front();\\n            q.pop();\\n            if(temp->val<low)\\n            {\\n                if(temp->right!=NULL)q.push(temp->right);\\n            }\\n            else if(temp->val>high)\\n            {\\n                if(temp->left!=NULL)q.push(temp->left);\\n            }\\n\\n            else if(temp->val>=low&&temp->val<=high)\\n            {\\n                res+=temp->val;\\n                if(temp->left!=NULL)q.push(temp->left);\\n                if(temp->right!=NULL)q.push(temp->right);   \\n            }\\n           \\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159445,
                "title": "3-line-c-solution-without-creating-new-function",
                "content": "end to end recursive c++ solution.\\n\\n```\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root == NULL) return 0;\\n        \\n        if(root->val>=low && root->val<=high){\\n            return root->val + rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root == NULL) return 0;\\n        \\n        if(root->val>=low && root->val<=high){\\n            return root->val + rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1146310,
                "title": "javascript-stack-easy",
                "content": "```\\n\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} low\\n * @param {number} high\\n * @return {number}\\n */\\nvar rangeSumBST = function(root, low, high) {\\n    let stack = [root];\\n    let sum = 0;\\n    while(stack.length !== 0) {\\n        let currentNode = stack.pop();\\n        if (currentNode !== null) {\\n            if (currentNode.val >= low && currentNode.val <= high) {\\n                sum += currentNode.val;\\n            }\\n            // when current value is greater than low, we check the left node since the left node is always smaller than current node\\n            if (currentNode.val > low) {\\n                stack.push(currentNode.left);\\n            }\\n            if (currentNode.val < high) {\\n                stack.push(currentNode.right);\\n            }\\n        }\\n    }\\n    return sum;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} low\\n * @param {number} high\\n * @return {number}\\n */\\nvar rangeSumBST = function(root, low, high) {\\n    let stack = [root];\\n    let sum = 0;\\n    while(stack.length !== 0) {\\n        let currentNode = stack.pop();\\n        if (currentNode !== null) {\\n            if (currentNode.val >= low && currentNode.val <= high) {\\n                sum += currentNode.val;\\n            }\\n            // when current value is greater than low, we check the left node since the left node is always smaller than current node\\n            if (currentNode.val > low) {\\n                stack.push(currentNode.left);\\n            }\\n            if (currentNode.val < high) {\\n                stack.push(currentNode.right);\\n            }\\n        }\\n    }\\n    return sum;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1131662,
                "title": "simple-js-faster-than-95",
                "content": "```\\nconst rangeSumBST =(root, low, high)=> {\\n    let q = [];\\n    q.push(root);\\n    let sum =0;\\n    while(q.length){\\n        const temp = q.pop();\\n        if(temp.left) q.push(temp.left);\\n        if(temp.right) q.push(temp.right);\\n        sum = temp.val>=low && temp.val<=high ? sum+temp.val : sum;\\n    }\\n    return sum;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst rangeSumBST =(root, low, high)=> {\\n    let q = [];\\n    q.push(root);\\n    let sum =0;\\n    while(q.length){\\n        const temp = q.pop();\\n        if(temp.left) q.push(temp.left);\\n        if(temp.right) q.push(temp.right);\\n        sum = temp.val>=low && temp.val<=high ? sum+temp.val : sum;\\n    }\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1093153,
                "title": "c-solution-o-n-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode* node = q.front();\\n            q.pop();\\n            \\n            if(node == NULL)\\n                continue;\\n            if(node->val >= low && node->val <= high)\\n                sum += node->val;\\n            \\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode* node = q.front();\\n            q.pop();\\n            \\n            if(node == NULL)\\n                continue;\\n            if(node->val >= low && node->val <= high)\\n                sum += node->val;\\n            \\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937409,
                "title": "follow-up-question-for-interview-preparations",
                "content": "I see that many people got confused by the language of the question, but still this question seems easy.\\nIf this question were to appear in a interview, it will be a warm up question and then it will be slightly modified to add complexity.\\n\\nOne such question - How can we handle if there are multiple queries for getting range sum ? i.e. ```getRangeSumBST(int low, int high)``` is called again and again with different low, high values. \\nHow would you optimize? \\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```getRangeSumBST(int low, int high)```",
                "codeTag": "Unknown"
            },
            {
                "id": 936345,
                "title": "c-recursive-one-liner-solutions-explained-100-time-80-space",
                "content": "This is a rather straightfoward problem and we might easily solve it calling a helper `dfs` function to gradually go top-down, from node to node, to solve it.\\n\\nI preferred going for an extra bit of challenge and writing directly a recursive one-liner, ignoring the condition that it is a BST, since I found little value in potentially skipping a conditional every time we examine a node, whereas that would have costed much more code complexity.\\n\\nTo do so, I \"hid\" the result variable as a fourth optional parameter, defaulted to `0`.\\n\\nI will then return it when `root == NULL`, ie: we ended up out of the tree; otherwise, I will call recursively our `rangeSumBST` function on both the `left` and `right` branches, with a twist:\\n* the call to the `left` branch will keep increasing `res` with the value of the current `root->val`;\\n* the call to the `right` branch will every time reset `res` to `0` and compute a sub-sum from scratch.\\n\\nOnce all the recursive calls will be done, we I will have to just the result of `root->val` plus the sub-sum of everything to the left of it with the sub-sum of whatever is at the right of it :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high, int res = 0) {\\n        return root ? rangeSumBST(root->left, low, high, res + (root->val >= low && root->val <= high ? root->val : 0)) + rangeSumBST(root->right, low, high) : res;\\n    }\\n};\\n```\\n\\nAnd looking back to the one-liner I wrote in May, one that has some earlier stopping condition, I really struggle to find it worth in terms of extra performances, since it is one more check at each step.\\n\\nBasically at each iteration we update the upper and lower limit `low` and `high` as we go: going `left` will reduce potentially reduce `high`, while going `right` will have us check if we need to update `low`.\\n\\nAt the beginning of our code, we are not checking that `root` is not `NULL`, plus the new condition `low <= high`, meaning we already reached a part of the tree that does not matter to us.\\n\\nFor example, if we started with `low == 10` and `high == 20`, moving `left` after having it a node with value `9` or lower (and thus having updated `high` to that value) would not be meaningul, since by definition any value to its left needs to be smaller in a BST; similarly moving `right` after encountering anything `> 20` should have us halt right there.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        return root && low <= high ? (root->val >= low && root->val <= high ? root->val : 0) + rangeSumBST(root->left, low, min(high, root->val)) + rangeSumBST(root->right, max(root->val, low), high) : 0;\\n    }\\n};\\n```\\n\\nHybrid of the 2 approaches, using also [RedaKerouicha](https://leetcode.com/RedaKerouicha/)\\'s suggestion:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, const int low, const int high, const int res = 0) {\\n        return root && low <= high ? rangeSumBST(root->left, low, min(high, root->val), res + (root->val >= low && root->val <= high ? root->val : 0)) + rangeSumBST(root->right, max(root->val, low), high) : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high, int res = 0) {\\n        return root ? rangeSumBST(root->left, low, high, res + (root->val >= low && root->val <= high ? root->val : 0)) + rangeSumBST(root->right, low, high) : res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        return root && low <= high ? (root->val >= low && root->val <= high ? root->val : 0) + rangeSumBST(root->left, low, min(high, root->val)) + rangeSumBST(root->right, max(root->val, low), high) : 0;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, const int low, const int high, const int res = 0) {\\n        return root && low <= high ? rangeSumBST(root->left, low, min(high, root->val), res + (root->val >= low && root->val <= high ? root->val : 0)) + rangeSumBST(root->right, max(root->val, low), high) : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825233,
                "title": "recursive-solution-dfs-solution-with-one-trick-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    // recursive solution\\n\\t\\n\\t``\\n    //one simple trick you bcan use is that you can find the inorder of bst and add l to r all values\\n\\t``\\n\\t\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n         int ans = 0;\\n        dfs(root, L, R,ans);\\n        return ans;\\n    }\\n\\n    void dfs(TreeNode* node, int L, int R,int & ans) {\\n        if (node != NULL) {\\n            if (L <= node -> val && node ->  val <= R)\\n                ans += node -> val;\\n            if (L < node -> val)\\n                dfs(node -> left, L, R,ans);\\n            if (node ->  val < R)\\n                dfs(node -> right, L, R,ans);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // recursive solution\\n\\t\\n\\t``\\n    //one simple trick you bcan use is that you can find the inorder of bst and add l to r all values\\n\\t``\\n\\t\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n         int ans = 0;\\n        dfs(root, L, R,ans);\\n        return ans;\\n    }\\n\\n    void dfs(TreeNode* node, int L, int R,int & ans) {\\n        if (node != NULL) {\\n            if (L <= node -> val && node ->  val <= R)\\n                ans += node -> val;\\n            if (L < node -> val)\\n                dfs(node -> left, L, R,ans);\\n            if (node ->  val < R)\\n                dfs(node -> right, L, R,ans);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 637185,
                "title": "go-recursive",
                "content": "```go\\nfunc rangeSumBST(root *TreeNode, L int, R int) int {\\n    if root == nil {\\n        return 0\\n    }\\n    \\n    res := 0\\n    \\n    // Node is within range\\n    if root.Val >= L && root.Val <= R {\\n        res += root.Val\\n    }\\n    \\n    // Range is overlapped with left tree\\n    if root.Val > L {\\n        res += rangeSumBST(root.Left, L, R)\\n    }\\n    \\n    // Range is overlapped with right tree\\n    if root.Val < R {\\n        res += rangeSumBST(root.Right, L, R)\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc rangeSumBST(root *TreeNode, L int, R int) int {\\n    if root == nil {\\n        return 0\\n    }\\n    \\n    res := 0\\n    \\n    // Node is within range\\n    if root.Val >= L && root.Val <= R {\\n        res += root.Val\\n    }\\n    \\n    // Range is overlapped with left tree\\n    if root.Val > L {\\n        res += rangeSumBST(root.Left, L, R)\\n    }\\n    \\n    // Range is overlapped with right tree\\n    if root.Val < R {\\n        res += rangeSumBST(root.Right, L, R)\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 359598,
                "title": "scala-using-pattern-matching",
                "content": "```\\nobject Solution {\\n    def rangeSumBST(root: TreeNode, L: Int, R: Int): Int = root match {\\n        case r if r == null => \\n            0\\n        case r if r.value < L => \\n            rangeSumBST(r.right,L,R)\\n        case r if r.value > R => \\n            rangeSumBST(r.left,L,R)\\n        case r => \\n            r.value + rangeSumBST(r.right,L,R) + rangeSumBST(r.left,L,R)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n    def rangeSumBST(root: TreeNode, L: Int, R: Int): Int = root match {\\n        case r if r == null => \\n            0\\n        case r if r.value < L => \\n            rangeSumBST(r.right,L,R)\\n        case r if r.value > R => \\n            rangeSumBST(r.left,L,R)\\n        case r => \\n            r.value + rangeSumBST(r.right,L,R) + rangeSumBST(r.left,L,R)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 333717,
                "title": "c-one-liner",
                "content": "```\\nint rangeSumBST(TreeNode* root, int L, int R) {\\n\\treturn root ? (root->val >= L && root->val <= R ? root->val : 0) + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R) : 0;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint rangeSumBST(TreeNode* root, int L, int R) {\\n\\treturn root ? (root->val >= L && root->val <= R ? root->val : 0) + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R) : 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 299679,
                "title": "simple-java-solution-0ms-faster-than-100-solution",
                "content": "```\\nclass Solution {\\n    int ans=0;\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if(root == null) return -1;\\n        if(root.val >=L && root.val<=R) ans+= root.val;\\n        if(root.val>L) rangeSumBST(root.left, L, R);\\n        if(root.val<R) rangeSumBST(root.right, L, R);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ans=0;\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if(root == null) return -1;\\n        if(root.val >=L && root.val<=R) ans+= root.val;\\n        if(root.val>L) rangeSumBST(root.left, L, R);\\n        if(root.val<R) rangeSumBST(root.right, L, R);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296103,
                "title": "i-am-confused-on-how-to-represent-this-tree",
                "content": "so if we have \\n\\nroot = [10, 5, 15, 3, 7, null, 18], L = 7, R = 15\\n\\nShouldn\\'t the output be 37 because the tree would be represented this way\\n\\n                             10\\n\\t\\t\\t\\t\\t\\t\\t /  \\\\\\n\\t\\t\\t\\t\\t\\t   5    15\\n\\t\\t\\t\\t\\t\\t  /  \\\\    \\\\\\n\\t\\t\\t\\t\\t\\t 3\\t 7\\t 18\\n\\t\\t\\t\\t\\t\\t \\nIf the previous representation is the correct way, then the answer should be 37 because 7+5+10+15\\n\\nHow are they getting 32?\\n",
                "solutionTags": [],
                "code": "so if we have \\n\\nroot = [10, 5, 15, 3, 7, null, 18], L = 7, R = 15\\n\\nShouldn\\'t the output be 37 because the tree would be represented this way\\n\\n                             10\\n\\t\\t\\t\\t\\t\\t\\t /  \\\\\\n\\t\\t\\t\\t\\t\\t   5    15\\n\\t\\t\\t\\t\\t\\t  /  \\\\    \\\\\\n\\t\\t\\t\\t\\t\\t 3\\t 7\\t 18\\n\\t\\t\\t\\t\\t\\t \\nIf the previous representation is the correct way, then the answer should be 37 because 7+5+10+15\\n\\nHow are they getting 32?\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 284070,
                "title": "c-code-using-dfs",
                "content": "````\\n\\npublic int RangeSumBST(TreeNode root, int L, int R)\\n    {\\n        if(root == null) return 0;\\n        return ((root.val>=L && root.val<=R) ? root.val : 0)+\\n            RangeSumBST(root.left,L,R)+\\n        RangeSumBST(root.right,L,R);\\n    }\\n\\n// using a variable\\n\\npublic class Solution {\\n    private int sum = 0;\\n    public int RangeSumBST(TreeNode root, int L, int R)\\n    {\\n        if(root!=null)\\n        {\\n            RangeSumBST(root.left,L,R);\\n            sum+= (root.val>=L && root.val<=R) ? root.val : 0;\\n            RangeSumBST(root.right,L,R);\\n        }\\n        \\n        return sum;\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "````\\n\\npublic int RangeSumBST(TreeNode root, int L, int R)\\n    {\\n        if(root == null) return 0;\\n        return ((root.val>=L && root.val<=R) ? root.val : 0)+\\n            RangeSumBST(root.left,L,R)+\\n        RangeSumBST(root.right,L,R);\\n    }\\n\\n// using a variable\\n\\npublic class Solution {\\n    private int sum = 0;\\n    public int RangeSumBST(TreeNode root, int L, int R)\\n    {\\n        if(root!=null)\\n        {\\n            RangeSumBST(root.left,L,R);\\n            sum+= (root.val>=L && root.val<=R) ? root.val : 0;\\n            RangeSumBST(root.right,L,R);\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 196165,
                "title": "c-simple-bfs",
                "content": "```\\n public int RangeSumBST(TreeNode root, int L, int R) {\\n        \\n        var totalSum = 0;\\n\\n        var que = new Queue<TreeNode>();\\n        que.Enqueue(root);\\n\\n        while (que.Count() > 0)\\n        {\\n            root = que.Dequeue();\\n          if(root.val >= L && root.val <= R){\\n              totalSum += root.val;\\n          }\\n\\n            if (root.left != null)\\n            {\\n                que.Enqueue(root.left);\\n            }\\n            if (root.right != null)\\n            {\\n                que.Enqueue(root.right);\\n            }\\n        }\\n\\n        return totalSum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int RangeSumBST(TreeNode root, int L, int R) {\\n        \\n        var totalSum = 0;\\n\\n        var que = new Queue<TreeNode>();\\n        que.Enqueue(root);\\n\\n        while (que.Count() > 0)\\n        {\\n            root = que.Dequeue();\\n          if(root.val >= L && root.val <= R){\\n              totalSum += root.val;\\n          }\\n\\n            if (root.left != null)\\n            {\\n                que.Enqueue(root.left);\\n            }\\n            if (root.right != null)\\n            {\\n                que.Enqueue(root.right);\\n            }\\n        }\\n\\n        return totalSum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 192065,
                "title": "c-with-morris-inorder-traversal",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n   \\n    int inorderTraversal(TreeNode* root,int L, int R){\\n        int sum = 0;\\n        TreeNode *cur = root,*pre;\\n        while(cur!=nullptr){\\n            if(cur->left!=nullptr){\\n                pre = cur->left;\\n                while(pre->right!=nullptr && pre->right!=cur){\\n                    pre = pre->right;\\n                }\\n                if(pre->right==nullptr){\\n                    pre->right = cur;\\n                    cur = cur->left;\\n                }else{\\n                    if(cur->val>=L && cur->val<=R)\\n                        sum+=cur->val;\\n                    pre->right = nullptr;\\n                    cur = cur->right;\\n                }\\n            }else{\\n                if(cur->val>=L && cur->val<=R)\\n                        sum+=cur->val;\\n                cur = cur->right;\\n            }\\n        }\\n        return sum;\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(root==nullptr)\\n            return 0;\\n        return inorderTraversal(root,L,R);\\n    }\\n};\\n\\'\\'\\'\\nTime complexity: O(n)\\nSpace complexity: O(1)",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   \\n    int inorderTraversal(TreeNode* root,int L, int R){\\n        int sum = 0;\\n        TreeNode *cur = root,*pre;\\n        while(cur!=nullptr){\\n            if(cur->left!=nullptr){\\n                pre = cur->left;\\n                while(pre->right!=nullptr && pre->right!=cur){\\n                    pre = pre->right;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4004175,
                "title": "well-defined-full-explanation-c-solution-easy-to-understand",
                "content": "Solution is quite simple. Lets recall the properties of a Binary Search Tree.\\n\\nBinary Search Tree is a node-based binary tree data structure which has the following properties:\\n\\n1. The left subtree of a node contains only nodes with keys lesser than the node\\u2019s key.\\n2. The right subtree of a node contains only nodes with keys greater than the node\\u2019s key.\\n3. The left and right subtree each must also be a binary search tree.\\n\\nThe code I\\'ve provided is a recursive function for traversing a binary search tree (BST) in a modified form of Inorder Traversal. In a standard Inorder Traversal, you would visit nodes in ascending order. However, this function is modified to only visit nodes that fall within a specified range defined by low and high.\\n\\nHere\\'s how it works:\\n\\n1. If the current node\\'s value (root->val) is within the range [low, high], it includes the value of the current node in the sum and then recursively calls the function on both the left and right subtrees.\\n\\n2. If the current node\\'s value is less than low, it means that all values in the left subtree are also less than low, so it recursively calls the function on the right subtree only.\\n\\n3. If the current node\\'s value is greater than high, it means that all values in the right subtree are also greater than high, so it recursively calls the function on the left subtree only.\\n\\nThis approach efficiently eliminates the need to visit nodes that are guaranteed to be outside the specified range, making it a modified Inorder Traversal tailored for this specific problem.\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root == NULL)return 0;\\n        \\n        if(root->val >= low && root->val <= high){\\n            return root->val + rangeSumBST(root->left , low , high) + rangeSumBST(root->right , low , high);\\n        }\\n        \\n        //use property of BST that how elements are arranged.\\n        //if we have root value lessThan LOW then, discard the left part of the BST.\\n        if(root->val<low)\\n            return rangeSumBST(root->right , low , high);\\n        //if we have root value greaterThan HIGH then, discard the right part of the BST.\\n        return rangeSumBST(root->left , low , high);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root == NULL)return 0;\\n        \\n        if(root->val >= low && root->val <= high){\\n            return root->val + rangeSumBST(root->left , low , high) + rangeSumBST(root->right , low , high);\\n        }\\n        \\n        //use property of BST that how elements are arranged.\\n        //if we have root value lessThan LOW then, discard the left part of the BST.\\n        if(root->val<low)\\n            return rangeSumBST(root->right , low , high);\\n        //if we have root value greaterThan HIGH then, discard the right part of the BST.\\n        return rangeSumBST(root->left , low , high);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525288,
                "title": "solution",
                "content": "```C++ []\\nconst int ZERO = [](){\\n     ios_base::sync_with_stdio(false);\\n     cin.tie(nullptr);\\n     return 0;\\n}();\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root == nullptr) return 0;\\n\\n        if(root->val < low) root->left = nullptr;\\n        if(root->val > high) root->right = nullptr;\\n\\n        return (root->val >= low && root->val <=high ? root->val : 0) +rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if not root:\\n            return 0 \\n        elif root.val<low:\\n            return self.rangeSumBST(root.right,low,high) \\n        elif root.val>high:\\n            return self.rangeSumBST(root.left,low,high) \\n        return root.val + self.rangeSumBST(root.left,low,high)+self.rangeSumBST(root.right,low,high)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int ans = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        helper(root, low, high);\\n        return ans;\\n    }\\n    public void helper(TreeNode root, int low, int high) {\\n        if (root == null) return;\\n\\n        if (root.val > low) {\\n            helper(root.left, low, high);\\n        }\\n        if (root.val >= low && root.val <= high) {\\n            ans += root.val;\\n        }\\n        if (root.val < high) {\\n            helper(root.right, low, high);\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nconst int ZERO = [](){\\n     ios_base::sync_with_stdio(false);\\n     cin.tie(nullptr);\\n     return 0;\\n}();\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root == nullptr) return 0;\\n\\n        if(root->val < low) root->left = nullptr;\\n        if(root->val > high) root->right = nullptr;\\n\\n        return (root->val >= low && root->val <=high ? root->val : 0) +rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if not root:\\n            return 0 \\n        elif root.val<low:\\n            return self.rangeSumBST(root.right,low,high) \\n        elif root.val>high:\\n            return self.rangeSumBST(root.left,low,high) \\n        return root.val + self.rangeSumBST(root.left,low,high)+self.rangeSumBST(root.right,low,high)\\n```\n```Java []\\nclass Solution {\\n    public int ans = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        helper(root, low, high);\\n        return ans;\\n    }\\n    public void helper(TreeNode root, int low, int high) {\\n        if (root == null) return;\\n\\n        if (root.val > low) {\\n            helper(root.left, low, high);\\n        }\\n        if (root.val >= low && root.val <= high) {\\n            ans += root.val;\\n        }\\n        if (root.val < high) {\\n            helper(root.right, low, high);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395967,
                "title": "easy-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null) return 0;\\n        if(root.val>=low && root.val<=high){\\n            return root.val+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n        }else if(root.val<low){\\n            return rangeSumBST(root.right,low,high);\\n        }else{\\n            return rangeSumBST(root.left,low,high);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null) return 0;\\n        if(root.val>=low && root.val<=high){\\n            return root.val+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n        }else if(root.val<low){\\n            return rangeSumBST(root.right,low,high);\\n        }else{\\n            return rangeSumBST(root.left,low,high);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344324,
                "title": "python3-iterative-dfs-recursive-dfs-bfs",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterative DFS\\nRecursive DFS\\nBFS\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\n\\n                                                    #recursive DFS\\n        # a = []\\n        # def dfs(node):\\n        #     if not node:\\n        #         return\\n        #     if low <= node.val <= high:\\n        #         a.append(node.val)\\n        #     dfs(node.left)\\n        #     dfs(node.right)\\n        # dfs(root)\\n        # return sum(a)\\n\\n                                                            #DFS                                        \\n        stack = [(root, root.val)]\\n        a = 0\\n        while stack:\\n            node, val = stack.pop()\\n            if low <= val <= high:\\n                a += val\\n            if node.left:\\n                stack.append((node.left, node.left.val))\\n            if node.right:\\n                stack.append((node.right, node.right.val))\\n        return a\\n\\n                                                            #BSF\\n        \\n        # d = collections.deque([(root, root.val)])\\n        # a = 0\\n        # while d:\\n        #     node, val = d.popleft()\\n        #     if low <= val <= high:\\n        #         a += val\\n        #     if not ( node.left or node.right):\\n        #         continue\\n        #     if node.left:\\n        #         d.append((node.left, node.left.val))\\n        #     if node.right:\\n        #         d.append((node.right, node.right.val))\\n        # return a\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\n\\n                                                    #recursive DFS\\n        # a = []\\n        # def dfs(node):\\n        #     if not node:\\n        #         return\\n        #     if low <= node.val <= high:\\n        #         a.append(node.val)\\n        #     dfs(node.left)\\n        #     dfs(node.right)\\n        # dfs(root)\\n        # return sum(a)\\n\\n                                                            #DFS                                        \\n        stack = [(root, root.val)]\\n        a = 0\\n        while stack:\\n            node, val = stack.pop()\\n            if low <= val <= high:\\n                a += val\\n            if node.left:\\n                stack.append((node.left, node.left.val))\\n            if node.right:\\n                stack.append((node.right, node.right.val))\\n        return a\\n\\n                                                            #BSF\\n        \\n        # d = collections.deque([(root, root.val)])\\n        # a = 0\\n        # while d:\\n        #     node, val = d.popleft()\\n        #     if low <= val <= high:\\n        #         a += val\\n        #     if not ( node.left or node.right):\\n        #         continue\\n        #     if node.left:\\n        #         d.append((node.left, node.left.val))\\n        #     if node.right:\\n        #         d.append((node.right, node.right.val))\\n        # return a\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240199,
                "title": "storing-values-in-range-c-omar-kashif",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    First we store all the values (from the tree) that are in the range\\n    then we simply sum them up, and return the sum.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    void foo(TreeNode* root, int low, int high, vector<int>&a)\\n    {\\n        if(root==nullptr)\\n            return;\\n        if(root->val>=low && root->val<=high)\\n            a.push_back(root->val);\\n        if(root->right!=nullptr)\\n            foo(root->right,low,high,a);\\n        if(root->left!=nullptr)\\n            foo(root->left,low,high,a);\\n    }\\n\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        vector<int>v;\\n        foo(root,low,high,v);\\n        int n=v.size(), sum=0;\\n        for(int i=0;i<n;i++)\\n            sum+=v[i];\\n        return sum;\\n    }\\n    // Code by OK!\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    void foo(TreeNode* root, int low, int high, vector<int>&a)\\n    {\\n        if(root==nullptr)\\n            return;\\n        if(root->val>=low && root->val<=high)\\n            a.push_back(root->val);\\n        if(root->right!=nullptr)\\n            foo(root->right,low,high,a);\\n        if(root->left!=nullptr)\\n            foo(root->left,low,high,a);\\n    }\\n\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        vector<int>v;\\n        foo(root,low,high,v);\\n        int n=v.size(), sum=0;\\n        for(int i=0;i<n;i++)\\n            sum+=v[i];\\n        return sum;\\n    }\\n    // Code by OK!\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142790,
                "title": "range-path-sum-bst-optimal-and-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    int sum = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val <= high){\\n            rangeSumBST(root.left, low, high);\\n            sum += root.val;\\n            rangeSumBST(root.right, low, high);\\n        }\\n        else if(root.val>=high){\\n            rangeSumBST(root.left, low, high);\\n        } else {\\n            rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int sum = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val <= high){\\n            rangeSumBST(root.left, low, high);\\n            sum += root.val;\\n            rangeSumBST(root.right, low, high);\\n        }\\n        else if(root.val>=high){\\n            rangeSumBST(root.left, low, high);\\n        } else {\\n            rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888265,
                "title": "cpp-recursion-efficient-solution",
                "content": "# Approach\\nCheck if current node is betweeen [low, high] and recurse accordingly for the subtrees.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(!root) return 0;\\n    \\n        if(root->val < low) return rangeSumBST(root->right, low, high);\\n        // Only nodes in right Subtree are needed\\n\\n        else if(root->val > high) return rangeSumBST(root->left, low, high);\\n        // Only nodes in right Subtree are needed\\n\\n        else return root->val + rangeSumBST(root->right, low, high) + rangeSumBST(root->left, low, high);\\n        // Required nodes can be in both subtree + Add node->val\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(!root) return 0;\\n    \\n        if(root->val < low) return rangeSumBST(root->right, low, high);\\n        // Only nodes in right Subtree are needed\\n\\n        else if(root->val > high) return rangeSumBST(root->left, low, high);\\n        // Only nodes in right Subtree are needed\\n\\n        else return root->val + rangeSumBST(root->right, low, high) + rangeSumBST(root->left, low, high);\\n        // Required nodes can be in both subtree + Add node->val\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888217,
                "title": "simple-java-solution-0ms",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    private int sum = 0;\\n\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null) {\\n            return 0;\\n        }\\n        if(low <= root.val && root.val <= high) {\\n            sum += root.val;\\n        }\\n        if(root.val > low) {\\n            rangeSumBST(root.left, low, high);\\n        }\\n        if(root.val < high) {\\n            rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    private int sum = 0;\\n\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null) {\\n            return 0;\\n        }\\n        if(low <= root.val && root.val <= high) {\\n            sum += root.val;\\n        }\\n        if(root.val > low) {\\n            rangeSumBST(root.left, low, high);\\n        }\\n        if(root.val < high) {\\n            rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888145,
                "title": "938-range-sum-of-bst-java-0-ms-faster-than-100-00-using-dfs-clean-code-with-comment",
                "content": "If you like the solution then an Upvote would really be an O(n) decision :)\\n```\\nclass Solution {\\n    int sum;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        sum = 0;\\n        \\n        dfs(root, low, high);\\n        \\n        return sum;\\n    }\\n    private void dfs(TreeNode node, int low, int high){\\n        if(node == null) return;\\n        \\n        int currentVal = node.val;\\n        \\n        //add in sum, if its value in range\\n        if(currentVal >= low && currentVal <= high) sum += currentVal;\\n        \\n        //no need to check in left, if current val is less than low\\n        //As it given,this is BST, so in left there will lesser number\\n        if(currentVal >= low)\\n        dfs(node.left, low, high);\\n        \\n        //no need to check in right, if current val is greater that high\\n        if(currentVal <= high)\\n        dfs(node.right, low, high);\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    int sum;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        sum = 0;\\n        \\n        dfs(root, low, high);\\n        \\n        return sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2888105,
                "title": "java-simple-100-faster-solution",
                "content": "# Intuition\\nThink of it as a binary search... Just with one change that you\\'re not actually looking for a value but for a range of values.\\n\\n# Approach\\nJust follow the similar strategy as you would follow in case of Binary Search that is discard halves if your current node falls out of range.\\n\\n# Complexity\\n- Time complexity:\\nO(N) -> In worst case all your elements might fall in range\\n- Space complexity:\\nO(N) -> Recursive Stack Space\\n# Code\\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null) return 0;\\n\\n        if(root.val < low){   // if current node value is less than low than move it to greater side that is right side\\n            return rangeSumBST(root.right, low, high);\\n        }else if(root.val > high){  // if current node value is greater than high than move it to lower side that is left side\\n            return rangeSumBST(root.left, low, high);\\n        }else{  // if it\\'s in range add the current value and repeat for left and right subtree\\n            return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null) return 0;\\n\\n        if(root.val < low){   // if current node value is less than low than move it to greater side that is right side\\n            return rangeSumBST(root.right, low, high);\\n        }else if(root.val > high){  // if current node value is greater than high than move it to lower side that is left side\\n            return rangeSumBST(root.left, low, high);\\n        }else{  // if it\\'s in range add the current value and repeat for left and right subtree\\n            return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887794,
                "title": "how-do-i-replace-vecdeque-with-vec-allahu-s-greatest-warrior",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAdd them up\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nVist every node withing range and add them to sum before returnign sum\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```rs\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn range_sum_bst(root: Option<Rc<RefCell<TreeNode>>>, low: i32, high: i32) -> i32 {\\n        let mut stack: std::collections::VecDeque<Option<Rc<RefCell<TreeNode>>>> = std::collections::VecDeque::new();\\n        stack.push_back(root);\\n\\n        let mut sum:i32 = 0;\\n        while let Some(stack_object) = stack.pop_front() {\\n            let node = stack_object.as_ref().unwrap().replace(TreeNode::new(0));\\n            if node.val <= high && node.val >= low { \\n                sum += node.val; \\n            }\\n        \\n            if node.val > low && node.left.is_some() { stack.push_back(node.left); }\\n            if node.val < high && node.right.is_some() { stack.push_back(node.right); }\\n        }\\n        sum\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rs\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn range_sum_bst(root: Option<Rc<RefCell<TreeNode>>>, low: i32, high: i32) -> i32 {\\n        let mut stack: std::collections::VecDeque<Option<Rc<RefCell<TreeNode>>>> = std::collections::VecDeque::new();\\n        stack.push_back(root);\\n\\n        let mut sum:i32 = 0;\\n        while let Some(stack_object) = stack.pop_front() {\\n            let node = stack_object.as_ref().unwrap().replace(TreeNode::new(0));\\n            if node.val <= high && node.val >= low { \\n                sum += node.val; \\n            }\\n        \\n            if node.val > low && node.left.is_some() { stack.push_back(node.left); }\\n            if node.val < high && node.right.is_some() { stack.push_back(node.right); }\\n        }\\n        sum\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2887681,
                "title": "simple-c-solution-with-comments",
                "content": "# Intuition and Approach\\nWe traverse the tree using a depth first search. If root\\'s data falls inside the range` [low, high]`, then we will add root\\'s data in `sum` else we will traverse left branch and right branch until root is `NULL`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // sum will store the sum of values of all nodes with a value\\n    // in the inclusive range [low, high].\\n    int sum = 0;\\n\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        //Edge Case\\n        if(root==NULL){\\n            return 0;\\n        }\\n\\n        //Checking if the root\\'s data lies in the inclusive\\n        // range [low, high] if yes then add the value of \\n        //root\\'s data in sum\\n        if(root->val >= low && root->val <= high){\\n            sum += root->val;\\n        }\\n        //Calling left and right branch\\n        rangeSumBST(root->left,low,high);\\n        rangeSumBST(root->right,low,high);\\n        \\n        return sum;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity:O(n), where n is the number of nodes in the tree.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n), is a worst case space required by stack.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // sum will store the sum of values of all nodes with a value\\n    // in the inclusive range [low, high].\\n    int sum = 0;\\n\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        //Edge Case\\n        if(root==NULL){\\n            return 0;\\n        }\\n\\n        //Checking if the root\\'s data lies in the inclusive\\n        // range [low, high] if yes then add the value of \\n        //root\\'s data in sum\\n        if(root->val >= low && root->val <= high){\\n            sum += root->val;\\n        }\\n        //Calling left and right branch\\n        rangeSumBST(root->left,low,high);\\n        rangeSumBST(root->right,low,high);\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887668,
                "title": "extremely-easy-just-do-one-traversal-c",
                "content": "# Approach\\n- Do any type of binary tree traversal and store the node values.\\n- Iterate over the values and apply the conditions.\\n\\n(This approach is quite lengthy and this question can be done in traversing tree and applying conditions simultaneously.)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n   void preorder(TreeNode* root, vector<int>&v){\\n        if(root == NULL){\\n            return;\\n        }\\n        v.push_back(root->val);\\n        preorder(root->left,v);\\n        preorder(root->right,v);\\n    }\\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        vector<int> v;\\n        preorder(root,v);\\n        int ans=0;\\n        for(int i=0; i<v.size();i++){\\n            if(v[i]>=low && v[i]<=high) ans+=v[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n   void preorder(TreeNode* root, vector<int>&v){\\n        if(root == NULL){\\n            return;\\n        }\\n        v.push_back(root->val);\\n        preorder(root->left,v);\\n        preorder(root->right,v);\\n    }\\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        vector<int> v;\\n        preorder(root,v);\\n        int ans=0;\\n        for(int i=0; i<v.size();i++){\\n            if(v[i]>=low && v[i]<=high) ans+=v[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887584,
                "title": "easy-approach",
                "content": "# Intuition\\nFirst thought that must comes to mind must be to store inorder traversal in case of BST.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Storing inorder traversal \\n2.Then,from low to high range add the available values.\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void inorder(TreeNode* root,vector<int> &ans){\\n        if(root==NULL)\\n        return;\\n        inorder(root->left,ans);\\n       ans.push_back(root->val);\\n        inorder(root->right,ans);\\n        \\n    }\\n\\npublic:\\n\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n//            \\n//      // inorder ->sorted array\\n//     // from low to high elements hai \\n//      //or fir unka sum kralenge\\n            vector<int> ans;\\n            inorder(root,ans);\\n\\n        int sum = 0;\\n        \\n        for (int i : ans) {\\n            if (i >= low && i <= high)\\n            sum += i;\\n        }\\n        \\n        return sum;\\n            \\n    }\\n\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    void inorder(TreeNode* root,vector<int> &ans){\\n        if(root==NULL)\\n        return;\\n        inorder(root->left,ans);\\n       ans.push_back(root->val);\\n        inorder(root->right,ans);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2887479,
                "title": "simple-c-recursive",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int RangeSumBST(TreeNode root, int low, int high) {\\n        int sum = 0;\\n        if (root == null)\\n            return sum;\\n        if (root.val >= low && root.val <= high)\\n            sum += root.val;\\n        if (root.val > low)\\n            sum += RangeSumBST(root.left, low, high);\\n        if (root.val < high)\\n            sum += RangeSumBST(root.right, low, high);\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int RangeSumBST(TreeNode root, int low, int high) {\\n        int sum = 0;\\n        if (root == null)\\n            return sum;\\n        if (root.val >= low && root.val <= high)\\n            sum += root.val;\\n        if (root.val > low)\\n            sum += RangeSumBST(root.left, low, high);\\n        if (root.val < high)\\n            sum += RangeSumBST(root.right, low, high);\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887423,
                "title": "go-recursive-solution-beats-100-naive-and-optimal-solution-explained",
                "content": "1. Naive approach \\n\\nTraverse the entire tree, note the nodes that falls under the range, and add them all together. This is the simplest possible solution with O(N) time complexity and O(N) memory.\\n\\n```\\nfunc rangeSumBST(root *TreeNode, low int, high int) int {\\n        if root == nil {\\n                return 0\\n        }\\n        var sum = 0\\n        if root.Val >= low && root.Val <= high {\\n                sum += root.Val\\n        }\\n\\n        l := rangeSumBST(root.Left, low, high)\\n\\n        r := rangeSumBST(root.Right, low, high)\\n        return sum + l + r\\n}\\n```\\n\\n2. Optimal Solution\\n\\nNow, can we do better? **YES**.  There are plenty of **unneccesary** work in the previous solution. \\n\\nRemember, it\\'s a **Binary Search Tree**, meaning, the left node is guaranteed to have a smaller value than the root, and the right node is guaranteed to have a greater value than the root. \\n\\nWhy would we want to traverse the **LEFT** subtree if the **low >= root.Val**, similarly, why would we want to traverse the **RIGHT** subtree if **high <= root.Val**?\\n\\nWith these optimizations our avg. time complexity becomes O(logN) on average.\\n\\n```\\nfunc rangeSumBST(root *TreeNode, low int, high int) int {\\n        if root == nil {\\n                return 0\\n        }\\n\\n        var sum = 0\\n\\n        if root.Val >= low && root.Val <= high {\\n                sum += root.Val\\n        }\\n\\n        l := 0\\n        r := 0\\n\\n        if low <= root.Val {\\n                l = rangeSumBST(root.Left, low, high)\\n        }\\n\\n        if high >= root.Val {\\n                r = rangeSumBST(root.Right, low, high)\\n        }\\n\\n        return sum + l + r\\n}\\n```\\n",
                "solutionTags": [
                    "Go",
                    "Binary Search Tree"
                ],
                "code": "```\\nfunc rangeSumBST(root *TreeNode, low int, high int) int {\\n        if root == nil {\\n                return 0\\n        }\\n        var sum = 0\\n        if root.Val >= low && root.Val <= high {\\n                sum += root.Val\\n        }\\n\\n        l := rangeSumBST(root.Left, low, high)\\n\\n        r := rangeSumBST(root.Right, low, high)\\n        return sum + l + r\\n}\\n```\n```\\nfunc rangeSumBST(root *TreeNode, low int, high int) int {\\n        if root == nil {\\n                return 0\\n        }\\n\\n        var sum = 0\\n\\n        if root.Val >= low && root.Val <= high {\\n                sum += root.Val\\n        }\\n\\n        l := 0\\n        r := 0\\n\\n        if low <= root.Val {\\n                l = rangeSumBST(root.Left, low, high)\\n        }\\n\\n        if high >= root.Val {\\n                r = rangeSumBST(root.Right, low, high)\\n        }\\n\\n        return sum + l + r\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2887003,
                "title": "5-lines-very-easy-solution-using-normal-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\tdef rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n\\t\\treturn self.helper(root,0,L,R)\\n\\n\\tdef helper(self,node,res,L,R):\\n\\t\\tif not node:\\n\\t\\t\\treturn res\\n\\t\\tif node.val>=L and node.val<=R:\\n\\t\\t\\tres+=node.val\\n\\t\\tres=self.helper(node.left,res,L,R)\\n\\t\\tres=self.helper(node.right,res,L,R)\\n\\t\\treturn res\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n\\tdef rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n\\t\\treturn self.helper(root,0,L,R)\\n\\n\\tdef helper(self,node,res,L,R):\\n\\t\\tif not node:\\n\\t\\t\\treturn res\\n\\t\\tif node.val>=L and node.val<=R:\\n\\t\\t\\tres+=node.val\\n\\t\\tres=self.helper(node.left,res,L,R)\\n\\t\\tres=self.helper(node.right,res,L,R)\\n\\t\\treturn res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886533,
                "title": "easy-c-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(!root)\\n            return 0;\\n\\n        if(root->val < low)\\n            return rangeSumBST(root->right , low , high);\\n            \\n        if(root->val >high)\\n            return rangeSumBST(root->left , low , high);\\n        \\n        return root->val + rangeSumBST(root->left , low , high) + rangeSumBST(root->right , low , high);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(!root)\\n            return 0;\\n\\n        if(root->val < low)\\n            return rangeSumBST(root->right , low , high);\\n            \\n        if(root->val >high)\\n            return rangeSumBST(root->left , low , high);\\n        \\n        return root->val + rangeSumBST(root->left , low , high) + rangeSumBST(root->right , low , high);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886501,
                "title": "2-lines-hot-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null) return 0;\\n        return ((root.val>=low && root.val<=high)?root.val:0)+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null) return 0;\\n        return ((root.val>=low && root.val<=high)?root.val:0)+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886238,
                "title": "range-sum-of-bst-100ms-solution-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraversing with any order Traversal and Cheaking the Condition\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N) squeue tree:worst case\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n    stack<TreeNode*>st;\\n    st.push(root);\\n    int sum=0;\\n    while(!st.empty()){\\n        TreeNode* temp=st.top();\\n        st.pop();\\n        if(temp->val>=low && temp->val<=high) sum+=temp->val;\\n        if(temp->left!=NULL) st.push(temp->left);\\n        if(temp->right!=NULL) st.push(temp->right);\\n    }\\n    return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n    stack<TreeNode*>st;\\n    st.push(root);\\n    int sum=0;\\n    while(!st.empty()){\\n        TreeNode* temp=st.top();\\n        st.pop();\\n        if(temp->val>=low && temp->val<=high) sum+=temp->val;\\n        if(temp->left!=NULL) st.push(temp->left);\\n        if(temp->right!=NULL) st.push(temp->right);\\n    }\\n    return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886031,
                "title": "simple-dfs-solution-beats-90-python",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        res = []\\n        if not root:\\n            return 0\\n        def DFS(node):\\n            if node:\\n                if low <= node.val <= high :\\n                    res.append(node.val)\\n                DFS(node.left)\\n                DFS(node.right)\\n        DFS(root)\\n        return sum(res)\\n\\n```\\n\\n**Upvote if you like the solution.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        res = []\\n        if not root:\\n            return 0\\n        def DFS(node):\\n            if node:\\n                if low <= node.val <= high :\\n                    res.append(node.val)\\n                DFS(node.left)\\n                DFS(node.right)\\n        DFS(root)\\n        return sum(res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885741,
                "title": "simple-3-line-python-java-c-solution",
                "content": "# Intuition\\nA classical Recursion Problem similar to find height and depth of tree.\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if (root == NULL) return 0;\\n\\n        int child = rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);\\n        if (root->val >= low && root->val <= high){\\n            return root->val + child; \\n        }\\n        return child;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if (root == None): return 0\\n\\n        val = root.val if low <= root.val <= high else 0\\n\\n        return val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)\\n```\\n```Java []\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int val = (low <= root.val && root.val <= high) ? root.val: 0;\\n        return val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right,low, high);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if (root == NULL) return 0;\\n\\n        int child = rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);\\n        if (root->val >= low && root->val <= high){\\n            return root->val + child; \\n        }\\n        return child;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if (root == None): return 0\\n\\n        val = root.val if low <= root.val <= high else 0\\n\\n        return val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)\\n```\n```Java []\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int val = (low <= root.val && root.val <= high) ? root.val: 0;\\n        return val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right,low, high);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885585,
                "title": "3-approaches-faster-than-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Pre order Traversal : root -> left -> right\\n- Check if values of these nodes lie in given range \\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\n        if not root:\\n            return 0\\n        \\n        ans = 0\\n        if low <= root.val <= high:\\n            ans += root.val\\n        ans += self.rangeSumBST(root.left,low,high)\\n        ans += self.rangeSumBST(root.right,low,high)\\n\\n        return ans \\n        \\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\n        if not root:\\n            return 0 \\n        \\n        return (root.val if low <= root.val <= high else 0) + \\\\\\n                self.rangeSumBST(root.left,low,high) + \\\\\\n                self.rangeSumBST(root.right,low,high)\\n```\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- In a BST, value of left node < value of root < value of right node\\n- So, we will take advantage of the same. \\n- Add the value of left node only if root val > low, because, if root val < low then left nodes value will also be less. \\n- Add the value of right node only if root val < high , because, if root val > high then right nodes value will also be more.\\n- Doing this just to reduce the number of iterations \\n\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\n        # Taking advantage of BST\\n        if not root:\\n            return 0 \\n        \\n        ans = 0\\n        ans += root.val if low <= root.val <= high else 0 \\n        if root.val > low:\\n            ans += self.rangeSumBST(root.left,low,high)\\n        if root.val < high:\\n            ans += self.rangeSumBST(root.right,low,high)\\n        return ans\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\n        if not root:\\n            return 0\\n        \\n        ans = 0\\n        if low <= root.val <= high:\\n            ans += root.val\\n        ans += self.rangeSumBST(root.left,low,high)\\n        ans += self.rangeSumBST(root.right,low,high)\\n\\n        return ans \\n        \\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\n        if not root:\\n            return 0 \\n        \\n        return (root.val if low <= root.val <= high else 0) + \\\\\\n                self.rangeSumBST(root.left,low,high) + \\\\\\n                self.rangeSumBST(root.right,low,high)\\n```\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\n        # Taking advantage of BST\\n        if not root:\\n            return 0 \\n        \\n        ans = 0\\n        ans += root.val if low <= root.val <= high else 0 \\n        if root.val > low:\\n            ans += self.rangeSumBST(root.left,low,high)\\n        if root.val < high:\\n            ans += self.rangeSumBST(root.right,low,high)\\n        return ans\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885572,
                "title": "range-sum-easy-java-solution-o-n",
                "content": "# Intuition\\nWe can do traversal either (Pre , Post or IN) does\\'nt matter.\\n\\n# Approach\\nWe need to just check the current node lies in between low and high inclusive edge.\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(h)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int result = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n     if(root == null) \\n        return result;\\n        \\n        if(root.val == low || root.val == high || (root.val>low) && (root.val<high)){\\n            result+=root.val;\\n        }\\n        rangeSumBST(root.left, low, high);\\n        rangeSumBST(root.right, low, high);\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int result = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n     if(root == null) \\n        return result;\\n        \\n        if(root.val == low || root.val == high || (root.val>low) && (root.val<high)){\\n            result+=root.val;\\n        }\\n        rangeSumBST(root.left, low, high);\\n        rangeSumBST(root.right, low, high);\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885555,
                "title": "video-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nVisit all the nodes. Use one of the traversal methods. I used DFS (preOrder traversal) to solve the problem\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nhttps://youtu.be/ENL_c3n9BCU\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nThe Code below is a more optimized solution.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nvar rangeSumBST = function(root, low, high) {\\n    let sum = 0;\\n\\n    let dfs = function(node) {\\n        if (!node) return;\\n        if (node.val >= low && node.val <= high) sum += node.val;\\n        f(node.val > low) dfs(node.left); // value of nodes to the left sub tree is always less than the root node\\n        if(node.val < high) dfs(node.right); // value of nodes to the right sub tree is always greater than the root node\\n    }\\n    dfs(root);\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nvar rangeSumBST = function(root, low, high) {\\n    let sum = 0;\\n\\n    let dfs = function(node) {\\n        if (!node) return;\\n        if (node.val >= low && node.val <= high) sum += node.val;\\n        f(node.val > low) dfs(node.left); // value of nodes to the left sub tree is always less than the root node\\n        if(node.val < high) dfs(node.right); // value of nodes to the right sub tree is always greater than the root node\\n    }\\n    dfs(root);\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2885529,
                "title": "java-using-complete-tree-traversal",
                "content": "# Intuition\\nTraverse the entire tree, but add only those nodes whose values fall within the range.\\n\\n# Approach\\nDeclare a global variable \\'sum\\' to store the range sum.\\nTraverse the tree using DFS.\\nIn each recursion, check if the node value is in between high and low. If so, add node value to \\'sum\\'.\\nReturn \\'sum\\'.\\n\\n# Complexity\\n- Time complexity:\\nO(n) - where n is the total number of nodes in the tree\\n\\n- Space complexity:\\nAverage case - log(n) [stack space used by recursive calls]\\nWorst case - O(n) if the tree is completely skewed.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int sum;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        sum = 0;\\n        traverse(root, low, high);\\n        return sum;\\n    }\\n\\n    void traverse(TreeNode node, int low, int high){\\n        if(node == null){\\n            return;\\n        }\\n        if(node.val >= low && node.val <= high){\\n            sum += node.val;\\n        }\\n\\n        traverse(node.left, low, high);\\n        traverse(node.right, low, high);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int sum;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        sum = 0;\\n        traverse(root, low, high);\\n        return sum;\\n    }\\n\\n    void traverse(TreeNode node, int low, int high){\\n        if(node == null){\\n            return;\\n        }\\n        if(node.val >= low && node.val <= high){\\n            sum += node.val;\\n        }\\n\\n        traverse(node.left, low, high);\\n        traverse(node.right, low, high);\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564692,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1565457,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1566300,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1565640,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568256,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568153,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568258,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568194,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568158,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1708160,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1564692,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1565457,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1566300,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1565640,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568256,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568153,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568258,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568194,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568158,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1708160,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1569696,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1569538,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1750570,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1708348,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1708107,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1574985,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1574286,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1573324,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1572624,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1708189,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1884872,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1828371,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1808389,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1806120,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1793409,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1728241,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1710992,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1710160,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1709654,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1709386,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1709084,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1709076,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1708946,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1708852,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1708813,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1708734,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1708728,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1708719,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1708628,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1708620,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1708508,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            },
            {
                "id": 1708395,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            },
            {
                "id": 1708376,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            },
            {
                "id": 1708264,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            },
            {
                "id": 1708252,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            },
            {
                "id": 1708244,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            },
            {
                "id": 1708237,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            },
            {
                "id": 1708236,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            },
            {
                "id": 1708204,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            },
            {
                "id": 1708188,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            }
        ]
    },
    {
        "title": "Design a Stack With Increment Operation",
        "question_content": "<p>Design a stack that supports increment operations on its elements.</p>\n\n<p>Implement the <code>CustomStack</code> class:</p>\n\n<ul>\n\t<li><code>CustomStack(int maxSize)</code> Initializes the object with <code>maxSize</code> which is the maximum number of elements in the stack.</li>\n\t<li><code>void push(int x)</code> Adds <code>x</code> to the top of the stack if the stack has not reached the <code>maxSize</code>.</li>\n\t<li><code>int pop()</code> Pops and returns the top of the stack or <code>-1</code> if the stack is empty.</li>\n\t<li><code>void inc(int k, int val)</code> Increments the bottom <code>k</code> elements of the stack by <code>val</code>. If there are less than <code>k</code> elements in the stack, increment all the elements in the stack.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;CustomStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;increment&quot;,&quot;increment&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n<strong>Output</strong>\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\n<strong>Explanation</strong>\nCustomStack stk = new CustomStack(3); // Stack is Empty []\nstk.push(1);                          // stack becomes [1]\nstk.push(2);                          // stack becomes [1, 2]\nstk.pop();                            // return 2 --&gt; Return top of the stack 2, stack becomes [1]\nstk.push(2);                          // stack becomes [1, 2]\nstk.push(3);                          // stack becomes [1, 2, 3]\nstk.push(4);                          // stack still [1, 2, 3], Do not add another elements as size is 4\nstk.increment(5, 100);                // stack becomes [101, 102, 103]\nstk.increment(2, 100);                // stack becomes [201, 202, 103]\nstk.pop();                            // return 103 --&gt; Return top of the stack 103, stack becomes [201, 202]\nstk.pop();                            // return 202 --&gt; Return top of the stack 202, stack becomes [201]\nstk.pop();                            // return 201 --&gt; Return top of the stack 201, stack becomes []\nstk.pop();                            // return -1 --&gt; Stack is empty return -1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= maxSize, x, k &lt;= 1000</code></li>\n\t<li><code>0 &lt;= val &lt;= 100</code></li>\n\t<li>At most <code>1000</code> calls will be made to each method of <code>increment</code>, <code>push</code> and <code>pop</code> each separately.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 539716,
                "title": "java-c-python-lazy-increment-o-1",
                "content": "## **Explanation**\\nUse an additional array to record the increment value.\\n`inc[i]` means for all elements `stack[0] ~ stack[i]`,\\nwe should plus `inc[i]` when popped from the stack.\\nThen `inc[i-1]+=inc[i]`,\\nso that we can accumulate the increment `inc[i]`\\nfor the bottom elements and the following `pop`s.\\n<br>\\n\\n## **Complexity**\\nC++/Python, initialization is `O(1)` time & space.\\nJava, initialization is `O(N)` time & space.\\n(We cam use ArrayList, but shrug)\\n`push`, `pop`, `increment`, all O(1) time and space.\\n<br>\\n\\n**Java**\\n```java\\n    int n;\\n    int[] inc;\\n    Stack<Integer> stack;\\n    public CustomStack(int maxSize) {\\n        n = maxSize;\\n        inc = new int[n];\\n        stack = new Stack<>();\\n    }\\n\\n    public void push(int x) {\\n        if (stack.size() < n)\\n            stack.push(x);\\n    }\\n\\n    public int pop() {\\n        int i = stack.size() - 1;\\n        if (i < 0)\\n            return -1;\\n        if (i > 0)\\n            inc[i - 1] += inc[i];\\n        int res = stack.pop() + inc[i];\\n        inc[i] = 0;\\n        return res;\\n    }\\n\\n    public void increment(int k, int val) {\\n        int i = Math.min(k, stack.size()) - 1;\\n        if (i >= 0)\\n            inc[i] += val;\\n    }\\n```\\n**C++:**\\n```cpp\\n    vector<int> stack, inc;\\n    int n;\\n    CustomStack(int maxSize) {\\n        n = maxSize;\\n    }\\n\\n    void push(int x) {\\n        if (stack.size() == n) return;\\n        stack.push_back(x);\\n        inc.push_back(0);\\n    }\\n\\n    int pop() {\\n        int i = stack.size() - 1;\\n        if (i < 0) return -1;\\n        if (i > 0) inc[i - 1] += inc[i];\\n        int res = stack[i] + inc[i];\\n        stack.pop_back();\\n        inc.pop_back();\\n        return res;\\n    }\\n\\n    void increment(int k, int val) {\\n        int i = min(k, (int)stack.size()) - 1;\\n        if (i >= 0) inc[i] += val;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def __init__(self, maxSize):\\n        self.n = maxSize\\n        self.stack = []\\n        self.inc = []\\n\\n    def push(self, x):\\n        if len(self.inc) < self.n:\\n            self.stack.append(x)\\n            self.inc.append(0)\\n\\n    def pop(self):\\n        if not self.inc: return -1\\n        if len(self.inc) > 1:\\n            self.inc[-2] += self.inc[-1]\\n        return self.stack.pop() + self.inc.pop()\\n\\n    def increment(self, k, val):\\n        if self.inc:\\n            self.inc[min(k, len(self.inc)) - 1] += val\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    int n;\\n    int[] inc;\\n    Stack<Integer> stack;\\n    public CustomStack(int maxSize) {\\n        n = maxSize;\\n        inc = new int[n];\\n        stack = new Stack<>();\\n    }\\n\\n    public void push(int x) {\\n        if (stack.size() < n)\\n            stack.push(x);\\n    }\\n\\n    public int pop() {\\n        int i = stack.size() - 1;\\n        if (i < 0)\\n            return -1;\\n        if (i > 0)\\n            inc[i - 1] += inc[i];\\n        int res = stack.pop() + inc[i];\\n        inc[i] = 0;\\n        return res;\\n    }\\n\\n    public void increment(int k, int val) {\\n        int i = Math.min(k, stack.size()) - 1;\\n        if (i >= 0)\\n            inc[i] += val;\\n    }\\n```\n```cpp\\n    vector<int> stack, inc;\\n    int n;\\n    CustomStack(int maxSize) {\\n        n = maxSize;\\n    }\\n\\n    void push(int x) {\\n        if (stack.size() == n) return;\\n        stack.push_back(x);\\n        inc.push_back(0);\\n    }\\n\\n    int pop() {\\n        int i = stack.size() - 1;\\n        if (i < 0) return -1;\\n        if (i > 0) inc[i - 1] += inc[i];\\n        int res = stack[i] + inc[i];\\n        stack.pop_back();\\n        inc.pop_back();\\n        return res;\\n    }\\n\\n    void increment(int k, int val) {\\n        int i = min(k, (int)stack.size()) - 1;\\n        if (i >= 0) inc[i] += val;\\n    }\\n```\n```py\\n    def __init__(self, maxSize):\\n        self.n = maxSize\\n        self.stack = []\\n        self.inc = []\\n\\n    def push(self, x):\\n        if len(self.inc) < self.n:\\n            self.stack.append(x)\\n            self.inc.append(0)\\n\\n    def pop(self):\\n        if not self.inc: return -1\\n        if len(self.inc) > 1:\\n            self.inc[-2] += self.inc[-1]\\n        return self.stack.pop() + self.inc.pop()\\n\\n    def increment(self, k, val):\\n        if self.inc:\\n            self.inc[min(k, len(self.inc)) - 1] += val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 843182,
                "title": "lee215-s-solution-with-more-explanation",
                "content": "solution from: https://leetcode.com/problems/design-a-stack-with-increment-operation/discuss/539716/JavaC%2B%2BPython-Lazy-increment-O(1)\\n\\nIntuition: like lee215 says, \"Use an additional array to record the increment value.\\ninc[i] means for all elements stack[0] ~ stack[i],\\nwe should plus inc[i] when popped from the stack.\\nThen inc[i-1]+=inc[i],\\nso that we can accumulate the increment inc[i]\\nfor the bottom elements and the following pops.\"\\n\\nI would like to expand on his explanation a bit further and hand simulate a bit. Some key obsrvations:\\n- when we push we push to both inc and stack, so that at any point in time inc and stack have the same amount of elements. \\n- earlier we said that \"inc[i] means for all elements stack[0] ~ stack[i], we should plus inc[i] when popped from the stack\" -- let\\'s look at this idea a bit further. The key with this idea is easier to see with hand simulation:\\n\\nlet\\'s say we have a list of ops: push 5, push 3, push 1, inc 2 3, push 9, inc 4 -1\\n\\nafter the 1st inc our data looks like this:\\nstack: [5,3,1]\\ninc: [0,3,0]\\n\\ninc[1] encodes the knowledge that elements 0 thru 1 (inclusive) in the stack are incremented by 3. If we generalize this a bit, inc[i] encodes the knowledge that elements 0 thru i (inclusive) are incremented by the value at inc[i]. \\n\\nlet\\'s continue examining this idea. What does our data look like after the second inc?\\nstack: [5,3,1,9]\\ninc:[0,3,0,-1]\\n\\nso this is what our data looks like at the end of all of our operations stated above. we see that our second inc operation is now encoded in our inc array, since inc[3] = -1, which encodes the knowledge that elements 0 thru 3 (inclusive) are incremented by -1. Now observe that our two increment operations now \\'overlap\\' eachother. In the sense that inc[1] is applied to elements 0 thru 1 inclusive and inc[3] is applied to elements 0 thru 3 inclusive. Hence, elements 0 and 1 will have both increment operators applied to them. So for elements 0 and 1, we don\\'t just need to add 3 upon pop (we also need to -1). \\n\\nNow here\\'s the tricky part which requires somewhat of an intellectual leap to get to. observe that, for our inc array, only inc[-1] (the last element) accurately encodes what to increment by (and this is only accurate for stack[-1] at any given point in time). What this means concretely is that whatever inc[-1] is, if we have a pop operation from our stack, all we have to do is stack.pop()+inc.pop() in order to get the right value popped. \\n\\nLet\\'s come back to the example we had earlier:\\nstack: [5,3,1,9]\\ninc:[0,3,0,-1]\\n\\nStarting with our data like this, what if we perform a pop? Then we can do inc.pop()+stack.pop() which will yield 8. This is the correct output. However, what we do next is more important. Earlier we said that inc[3] encodes the value we want to add to elements 0 thru 3 (inclusive) of the stack. However at this point we\\'ve only added inc[3] to the 3rd element, so we don\\'t want to lose this knowledge before we\\'ve acted on all of it. So now that we\\'ve popped 3rd element, \\n\\ninc[3] encodes the value we want to add to elements 0 thru 3 (inclusive) of the stack -> inc[3] encodes the value we want to add to elements 0 thru 2 (inclusive) of the stack\\n\\nDo you understand how that leap was made? since i\\'ve already applied the increment operation to 3rd element, inc[3] no longer needs to encode that knowledge because it\\'s already been acted upon, so at that point inc[3] only encodes the knowledge that this is the value we want to add to elements 0 thru 2 (inclusive), instead of 0 thru 3. So how do we represent this in code? This next step requires a combination of ideas. If we think back to our representation, we said we want at any given point for our last element inc[-1] to have the accurate increment for stack[-1]. And also if we think back to our discussion earlier, we discussed overlap and how our algorithm needs to take into account that overlap. So the way we can do that is by taking inc[3]\\'s value and adding it to inc[2]. This represents the knowledge transition, from inc[3] encoding the value we want to add to elements 0 thru 3 of ths stack to inc[3] only encoding the value we want to add to elements 0 thru 2. So how do represent this knowledge transition? by moving inc[3]\\'s value into inc[2]. This is an exact move of our knowledge transition. \\n\\nSo then after that pop we look like this: \\nstack: [5,3,1]\\ninc:[0,3,-1]\\n\\nwhere inc[2] encodes that -1 should be added to stack elements 0 thru 2 (inclusive). This is in line with what we believe because we are keeping the information from inc[3] alive, as long as we haven\\'t fully acted upon the information. Also -1 is the correct value here because there is no overlap at this element. \\n\\nSo we pop again and end up looking like this:\\n\\nstack: [5,3]\\ninc:[0,2]\\n\\nNotice that we incorporate inc[2]\\'s value into inc[1]. This is because of the same reasoning as earlier, that inc[2] encodes value about elements 0 thru 2 (incl), and now that we\\'ve acted on element 2, we still need to encode the knowledge regarding elements 0 thru 1 (incl), so the way we do that is by bringing inc[2] into inc[1]. But notice that is how our overlap gets handled here. Now instead of increment elements 0 thru 1 by 3 (as our first increment operation suggests), we incorporate the second increment operation (since the ranges overlap), and we only increment the first 2 elements by exactly what is necessary. \\n```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize):\\n        self.n = maxSize\\n        self.stack = []\\n        self.inc = []\\n\\n    def push(self, x):\\n        if len(self.inc) < self.n:\\n            self.stack.append(x)\\n            self.inc.append(0)\\n\\n    def pop(self):\\n        if not self.inc: return -1\\n        if len(self.inc) > 1:\\n            self.inc[-2] += self.inc[-1]\\n        return self.stack.pop() + self.inc.pop()\\n\\n    def increment(self, k, val):\\n        if self.inc:\\n            self.inc[min(k, len(self.inc)) - 1] += val\\n        \\n\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize):\\n        self.n = maxSize\\n        self.stack = []\\n        self.inc = []\\n\\n    def push(self, x):\\n        if len(self.inc) < self.n:\\n            self.stack.append(x)\\n            self.inc.append(0)\\n\\n    def pop(self):\\n        if not self.inc: return -1\\n        if len(self.inc) > 1:\\n            self.inc[-2] += self.inc[-1]\\n        return self.stack.pop() + self.inc.pop()\\n\\n    def increment(self, k, val):\\n        if self.inc:\\n            self.inc[min(k, len(self.inc)) - 1] += val\\n        \\n\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539704,
                "title": "java-python-3-simple-codes-using-arraylist-list",
                "content": "```java\\n    private List<Integer> stk = new ArrayList<>();\\n    private int sz;\\n    public CustomStack(int maxSize) {\\n        sz = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if (stk.size() < sz) {\\n            stk.add(x);\\n        }\\n    }\\n    \\n    public int pop() {\\n        return stk.isEmpty() ? -1 : stk.remove(stk.size() - 1);\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for (int i = 0; i < k && i < stk.size(); ++i) {\\n            stk.set(i, stk.get(i) + val);            \\n        }\\n    }\\n```\\n```python\\n\\n    def __init__(self, maxSize: int):\\n        self.stk = []\\n        self.sz = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stk) < self.sz:\\n            self.stk.append(x)\\n\\n    def pop(self) -> int:\\n        return self.stk.pop() if self.stk else -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, len(self.stk))):\\n            self.stk[i] += val\\n```",
                "solutionTags": [],
                "code": "```java\\n    private List<Integer> stk = new ArrayList<>();\\n    private int sz;\\n    public CustomStack(int maxSize) {\\n        sz = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if (stk.size() < sz) {\\n            stk.add(x);\\n        }\\n    }\\n    \\n    public int pop() {\\n        return stk.isEmpty() ? -1 : stk.remove(stk.size() - 1);\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for (int i = 0; i < k && i < stk.size(); ++i) {\\n            stk.set(i, stk.get(i) + val);            \\n        }\\n    }\\n```\n```python\\n\\n    def __init__(self, maxSize: int):\\n        self.stk = []\\n        self.sz = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stk) < self.sz:\\n            self.stk.append(x)\\n\\n    def pop(self) -> int:\\n        return self.stk.pop() if self.stk else -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, len(self.stk))):\\n            self.stk[i] += val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1043433,
                "title": "java-4ms-99-faster",
                "content": "```\\nclass CustomStack {\\n\\tint[] stack;\\n    int size;\\n    int index;\\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];\\n        size = maxSize;\\n        index=0;\\n    }\\n\\n    public void push(int x) {\\n       if (index<size){\\n            stack[index++] = x;\\n        }\\n    }\\n\\n    public int pop() {\\n        if(index == 0) return -1;\\n        return stack[--index];\\n    }\\n\\n    public void increment(int k, int val) {\\n        if(stack.length == 0) return;\\n        for(int i = 0;i<k && i<stack.length;i++)\\n            stack[i] = stack[i] + val;\\n    }\\n    }\\n\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass CustomStack {\\n\\tint[] stack;\\n    int size;\\n    int index;\\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];\\n        size = maxSize;\\n        index=0;\\n    }\\n\\n    public void push(int x) {\\n       if (index<size){\\n            stack[index++] = x;\\n        }\\n    }\\n\\n    public int pop() {\\n        if(index == 0) return -1;\\n        return stack[--index];\\n    }\\n\\n    public void increment(int k, int val) {\\n        if(stack.length == 0) return;\\n        for(int i = 0;i<k && i<stack.length;i++)\\n            stack[i] = stack[i] + val;\\n    }\\n    }\\n\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1231589,
                "title": "c-easy-solution-beats-97-78",
                "content": "```\\nclass CustomStack {\\npublic:\\n    int max;\\n    vector<int> v;\\n    CustomStack(int maxSize) {\\n        max=maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(v.size()<max)\\n            v.push_back(x);\\n    }\\n    \\n    int pop() {\\n        if(v.size()==0)\\n            return -1;\\n        int x=v.back();\\n        v.pop_back();\\n        return x;\\n    }\\n    void increment(int k, int val) {\\n        int x=k;\\n        if(v.size()<k)\\n            x=v.size();\\n        for(int i=0;i<x;i++)\\n        {\\n            v[i]+=val;\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```\\nRuntime: 24 ms, faster than 97.78% of C++ online submissions for Design a Stack With Increment Operation.\\nMemory Usage: 20.9 MB, less than 96.99% of C++ online submissions for Design a Stack With Increment Operation.\\n\\n**Please upvote if this helps :)**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    int max;\\n    vector<int> v;\\n    CustomStack(int maxSize) {\\n        max=maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(v.size()<max)\\n            v.push_back(x);\\n    }\\n    \\n    int pop() {\\n        if(v.size()==0)\\n            return -1;\\n        int x=v.back();\\n        v.pop_back();\\n        return x;\\n    }\\n    void increment(int k, int val) {\\n        int x=k;\\n        if(v.size()<k)\\n            x=v.size();\\n        for(int i=0;i<x;i++)\\n        {\\n            v[i]+=val;\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 542205,
                "title": "python-prefix-sum-with-1-array",
                "content": "Prefix sum reference can be found [here](https://en.wikipedia.org/wiki/Prefix_sum/).\\n\\n```\\nclass CustomStack:\\n    def __init__(self, maxSize: int):\\n        self.size = maxSize\\n        self.stack = []\\n        \\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.size:\\n            self.stack.append([x, 0])\\n        \\n    def pop(self) -> int:\\n        if not self.stack:\\n            return -1\\n        \\n        res, inc = self.stack.pop()\\n        res += inc\\n        \\n        if self.stack:\\n            self.stack[-1][1] += inc\\n            \\n        return res\\n        \\n    def increment(self, k: int, val: int) -> None:\\n        if self.stack:\\n            self.stack[min(k, len(self.stack)) - 1][1] += val\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack:\\n    def __init__(self, maxSize: int):\\n        self.size = maxSize\\n        self.stack = []\\n        \\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.size:\\n            self.stack.append([x, 0])\\n        \\n    def pop(self) -> int:\\n        if not self.stack:\\n            return -1\\n        \\n        res, inc = self.stack.pop()\\n        res += inc\\n        \\n        if self.stack:\\n            self.stack[-1][1] += inc\\n            \\n        return res\\n        \\n    def increment(self, k: int, val: int) -> None:\\n        if self.stack:\\n            self.stack[min(k, len(self.stack)) - 1][1] += val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539971,
                "title": "java-clean-and-simple-array-solution",
                "content": "We keep the stack data in array and keep a cursor in another variable.\\n```\\nclass CustomStack {\\n    \\n    private int[] arr;\\n    private int   curr = -1;\\n\\n    public CustomStack(int maxSize) {\\n        this.arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n        if (curr+1 < arr.length) {\\n            arr[++curr] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        return curr < 0 ? curr : arr[curr--];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for (int i = 0; i < Math.min(k, curr+1); i++) {\\n            arr[i] += val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n    \\n    private int[] arr;\\n    private int   curr = -1;\\n\\n    public CustomStack(int maxSize) {\\n        this.arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n        if (curr+1 < arr.length) {\\n            arr[++curr] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        return curr < 0 ? curr : arr[curr--];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for (int i = 0; i < Math.min(k, curr+1); i++) {\\n            arr[i] += val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 938891,
                "title": "java-o-1-4ms-beat-98-12",
                "content": "```\\nclass CustomStack {\\n    private int index;\\n    private Deque<Integer> stack = new ArrayDeque<>();\\n    private int increment[]; // check the range of increment\\n    public CustomStack(int maxSize) {\\n        index = -1;\\n        increment = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n        if(stack.size() == increment.length)\\n            return;\\n        stack.push(x);\\n        index++;\\n    }\\n    \\n    public int pop() {\\n        if(index == -1)\\n            return -1;\\n        int ret = stack.pop();\\n        int incre = increment[index]; //get increment with index\\n        if(index > 0){\\n            increment[index - 1] += increment[index]; // go to previous one\\n        }\\n        increment[index] = 0; // set the current one to zero\\n        index--;\\n        return ret + incre;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        if(index == -1)\\n            return;\\n        if(stack.size() < k){\\n            increment[index] += val; // increment\\n        }\\n        else{\\n            increment[k - 1] += val; // increment\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack {\\n    private int index;\\n    private Deque<Integer> stack = new ArrayDeque<>();\\n    private int increment[]; // check the range of increment\\n    public CustomStack(int maxSize) {\\n        index = -1;\\n        increment = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n        if(stack.size() == increment.length)\\n            return;\\n        stack.push(x);\\n        index++;\\n    }\\n    \\n    public int pop() {\\n        if(index == -1)\\n            return -1;\\n        int ret = stack.pop();\\n        int incre = increment[index]; //get increment with index\\n        if(index > 0){\\n            increment[index - 1] += increment[index]; // go to previous one\\n        }\\n        increment[index] = 0; // set the current one to zero\\n        index--;\\n        return ret + incre;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        if(index == -1)\\n            return;\\n        if(stack.size() < k){\\n            increment[index] += val; // increment\\n        }\\n        else{\\n            increment[k - 1] += val; // increment\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933166,
                "title": "c-lazy-increment-with-explain",
                "content": "The idea of this problem is the lazy increment. It means when we pop a value from the stack, we will increment it. I used a map to save the top of elements that need to increase. So when we meet an element we will increase the value of this index\\n```\\nclass CustomStack {\\nprivate:\\n    unordered_map<int, int> map;\\n    stack<int> stack;\\n    int limit;\\npublic:\\n    CustomStack(int maxSize) {\\n        limit = maxSize;\\n    }\\n\\n    void push(int x) {\\n        if (stack.size() == limit) return;\\n        stack.push(x);\\n    }\\n\\n    int pop() {\\n        if (stack.empty()) return -1;\\n        int value = map[stack.size()]; //value we need to increase of this index\\n        map[stack.size()] = 0; // after we increase, value of this index will set to 0\\n        int top = stack.top(); \\n        stack.pop();\\n        map[stack.size()] += value; // If this index increase by value, so the bottom  of the index  will increase by value\\n        return top + value;\\n    }\\n\\n    void increment(int k, int val) {\\n        k = min(k, (int) stack.size()); // Sometime k bigger than stack.size() so we use stack.size()\\n        map[k] += val;\\n    }\\n};```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass CustomStack {\\nprivate:\\n    unordered_map<int, int> map;\\n    stack<int> stack;\\n    int limit;\\npublic:\\n    CustomStack(int maxSize) {\\n        limit = maxSize;\\n    }\\n\\n    void push(int x) {\\n        if (stack.size() == limit) return;\\n        stack.push(x);\\n    }\\n\\n    int pop() {\\n        if (stack.empty()) return -1;\\n        int value = map[stack.size()]; //value we need to increase of this index\\n        map[stack.size()] = 0; // after we increase, value of this index will set to 0\\n        int top = stack.top(); \\n        stack.pop();\\n        map[stack.size()] += value; // If this index increase by value, so the bottom  of the index  will increase by value\\n        return top + value;\\n    }\\n\\n    void increment(int k, int val) {\\n        k = min(k, (int) stack.size()); // Sometime k bigger than stack.size() so we use stack.size()\\n        map[k] += val;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 673734,
                "title": "c-o-1-solution",
                "content": "```\\nclass CustomStack {\\npublic:\\n    CustomStack(int maxSize) {\\n        SIZE = maxSize;\\n        inc = std::vector<int>(maxSize+1, 0);\\n    }\\n    \\n    void push(int x) {\\n        if(s.size() < SIZE) s.push(x);\\n    }\\n    \\n    int pop() {\\n        if(s.empty()) return -1;\\n        int v{s.top() + inc[s.size()]};\\n        inc[s.size()-1] += inc[s.size()], inc[s.size()] = 0, s.pop();\\n        return v;\\n    }\\n    \\n    void increment(int k, int val) {\\n        inc[min(k, (int)s.size())] += val;\\n    }\\n    \\n    int SIZE;\\n    std::stack<int> s;\\n    std::vector<int> inc;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\npublic:\\n    CustomStack(int maxSize) {\\n        SIZE = maxSize;\\n        inc = std::vector<int>(maxSize+1, 0);\\n    }\\n    \\n    void push(int x) {\\n        if(s.size() < SIZE) s.push(x);\\n    }\\n    \\n    int pop() {\\n        if(s.empty()) return -1;\\n        int v{s.top() + inc[s.size()]};\\n        inc[s.size()-1] += inc[s.size()], inc[s.size()] = 0, s.pop();\\n        return v;\\n    }\\n    \\n    void increment(int k, int val) {\\n        inc[min(k, (int)s.size())] += val;\\n    }\\n    \\n    int SIZE;\\n    std::stack<int> s;\\n    std::vector<int> inc;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539727,
                "title": "c-python3-simulation",
                "content": "Design a stack with the following operations:\\n\\n* `CustomStack(int maxSize)`: initialize the stack with `maxSize`\\n* `void push(int x)`: Adds `x` to the top of the stack if the size doesn\\'t reach `maxSize`\\n* `int pop()`: return the top of the stack and pop it, or return -1 when it is empty\\n* `void inc(int k, int val)`: increase the bottom `min(k, size)` elements of the stack by `val`\\n\\n# Explanation\\n\\nSince the constraints are small (`1 <= maxSize <= 1000`, at most 1000 calls), just simulate the whole process.\\n\\n# C++ Solution\\n\\n```cpp\\nclass CustomStack {\\n    int maxSize;\\n    vector<int> stk;\\npublic:\\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if (stk.size() < maxSize)\\n            stk.push_back(x);\\n    }\\n    \\n    int pop() {\\n        if (stk.size() > 0) {\\n            int x = stk.back();\\n            stk.pop_back();\\n            return x;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        for (int i = 0; i < min(k, (int) stk.size()); i++)\\n            stk[i] += val;\\n    }\\n};\\n```\\n\\n# python3 Solution\\n\\n```python\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.maxSize = maxSize\\n        self.stk = []\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stk) < self.maxSize:\\n            self.stk.append(x)\\n\\n    def pop(self) -> int:\\n        if len(self.stk) > 0:\\n            x = self.stk[-1];\\n            self.stk.pop()\\n            return x\\n        return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, len(self.stk))):\\n            self.stk[i] += val\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass CustomStack {\\n    int maxSize;\\n    vector<int> stk;\\npublic:\\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if (stk.size() < maxSize)\\n            stk.push_back(x);\\n    }\\n    \\n    int pop() {\\n        if (stk.size() > 0) {\\n            int x = stk.back();\\n            stk.pop_back();\\n            return x;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        for (int i = 0; i < min(k, (int) stk.size()); i++)\\n            stk[i] += val;\\n    }\\n};\\n```\n```python\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.maxSize = maxSize\\n        self.stk = []\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stk) < self.maxSize:\\n            self.stk.append(x)\\n\\n    def pop(self) -> int:\\n        if len(self.stk) > 0:\\n            x = self.stk[-1];\\n            self.stk.pop()\\n            return x\\n        return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, len(self.stk))):\\n            self.stk[i] += val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800767,
                "title": "python3-solution-stack",
                "content": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.maxLength = maxSize\\n        \\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxLength:\\n            self.stack.append(x)\\n        \\n    def pop(self) -> int:\\n        if len(self.stack) >0:\\n            return self.stack.pop()\\n        return -1\\n    \\n    def increment(self, k: int, val: int) -> None:\\n        n = min(k,len(self.stack))\\n        for i in range(n):\\n            self.stack[i] += val",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.maxLength = maxSize\\n        \\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxLength:\\n            self.stack.append(x)\\n        \\n    def pop(self) -> int:\\n        if len(self.stack) >0:\\n            return self.stack.pop()\\n        return -1\\n    \\n    def increment(self, k: int, val: int) -> None:\\n        n = min(k,len(self.stack))\\n        for i in range(n):\\n            self.stack[i] += val",
                "codeTag": "Java"
            },
            {
                "id": 637422,
                "title": "python-sol-by-update-just-in-time-90-w-hint",
                "content": "Pythonic sol by update just-in-time\\n\\n---\\n\\n**Hint**:\\n\\nRecall the technique of **update just-in-time**.\\n\\nHere, we design and implement a class, called **Entry**, with two member variables.\\nOne is for recording **element value**, the other is for **increment offset**.\\n\\nApply just-in-time update in **pop**() and **increment**() operation in order to reduce overhead and improve overall performance.\\n\\n---\\n\\n```\\nclass Entry:\\n    def __init__(self, value, offset ):\\n        \\n        self.value = value\\n        self.offset = offset\\n\\n        \\n    def __repr__(self):\\n        # override __repr__ to help programmer trace and debug\\n        msg = [ f\\'value = {self.value}\\', f\\'offset = {self.offset}\\', \\'---\\']\\n        return \\'\\\\n\\'.join( msg )\\n        \\n        \\n        \\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        \\n        self.stk = []\\n        self.size_limit = maxSize\\n\\n        \\n        \\n    def push(self, x: int) -> None:\\n\\n        \\n        if len(self.stk) < self.size_limit:\\n            \\n            # push new element when stack size is within limit\\n            self.stk.append( Entry( value = x, offset = 0) )\\n\\n\\n        \\n    def pop(self) -> int:\\n        \\n        if self.stk:\\n            \\n            # fetch and pop top element from stack\\n            top_element = self.stk.pop()\\n            \\n            if self.stk:\\n                # If stack is still non-empty, \\n                # propagate increment offset to lower level\\n                self.stk[-1].offset += top_element.offset\\n            \\n\\n            # compute result with increment offset\\n            return top_element.value + top_element.offset\\n        \\n        else:\\n            \\n            # stack is empty, directly return -1\\n            return -1\\n\\n        \\n        \\n    def increment(self, k: int, val: int) -> None:\\n        \\n\\n        if self.stk:\\n            \\n            # update offset at k-th element when stack is non-empty\\n            \\n            # adjust k if k is over stack size\\n            k = min( k, len(self.stk) )\\n            \\n            self.stk[k-1].offset += val\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Entry:\\n    def __init__(self, value, offset ):\\n        \\n        self.value = value\\n        self.offset = offset\\n\\n        \\n    def __repr__(self):\\n        # override __repr__ to help programmer trace and debug\\n        msg = [ f\\'value = {self.value}\\', f\\'offset = {self.offset}\\', \\'---\\']\\n        return \\'\\\\n\\'.join( msg )\\n        \\n        \\n        \\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        \\n        self.stk = []\\n        self.size_limit = maxSize\\n\\n        \\n        \\n    def push(self, x: int) -> None:\\n\\n        \\n        if len(self.stk) < self.size_limit:\\n            \\n            # push new element when stack size is within limit\\n            self.stk.append( Entry( value = x, offset = 0) )\\n\\n\\n        \\n    def pop(self) -> int:\\n        \\n        if self.stk:\\n            \\n            # fetch and pop top element from stack\\n            top_element = self.stk.pop()\\n            \\n            if self.stk:\\n                # If stack is still non-empty, \\n                # propagate increment offset to lower level\\n                self.stk[-1].offset += top_element.offset\\n            \\n\\n            # compute result with increment offset\\n            return top_element.value + top_element.offset\\n        \\n        else:\\n            \\n            # stack is empty, directly return -1\\n            return -1\\n\\n        \\n        \\n    def increment(self, k: int, val: int) -> None:\\n        \\n\\n        if self.stk:\\n            \\n            # update offset at k-th element when stack is non-empty\\n            \\n            # adjust k if k is over stack size\\n            k = min( k, len(self.stk) )\\n            \\n            self.stk[k-1].offset += val\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 539702,
                "title": "c-simple-stack-implementation",
                "content": "```csharp\\npublic class CustomStack \\n{\\n    private int[] maxSizeStack;\\n    private int maxSize;\\n    private int top;\\n\\n    public CustomStack(int maxSize) \\n    {\\n        maxSizeStack = new int[maxSize];\\n        this.maxSize = maxSize;\\n        top = -1;\\n    }\\n    \\n    public void Push(int x) \\n    {\\n        if(top == maxSize - 1)\\n        {\\n            return;\\n        }\\n        \\n        top++;\\n        maxSizeStack[top] = x;        \\n    }\\n    \\n    public int Pop() \\n    {\\n        if(top == -1)\\n        {\\n            return -1;\\n        }                \\n        \\n        int element = maxSizeStack[top];\\n        top--;\\n        return element;        \\n    }\\n    \\n    public void Increment(int k, int val) \\n    {\\n        for(int i = 0; i < k && i <= top; i++)\\n        {\\n            maxSizeStack[i] += val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class CustomStack \\n{\\n    private int[] maxSizeStack;\\n    private int maxSize;\\n    private int top;\\n\\n    public CustomStack(int maxSize) \\n    {\\n        maxSizeStack = new int[maxSize];\\n        this.maxSize = maxSize;\\n        top = -1;\\n    }\\n    \\n    public void Push(int x) \\n    {\\n        if(top == maxSize - 1)\\n        {\\n            return;\\n        }\\n        \\n        top++;\\n        maxSizeStack[top] = x;        \\n    }\\n    \\n    public int Pop() \\n    {\\n        if(top == -1)\\n        {\\n            return -1;\\n        }                \\n        \\n        int element = maxSizeStack[top];\\n        top--;\\n        return element;        \\n    }\\n    \\n    public void Increment(int k, int val) \\n    {\\n        for(int i = 0; i < k && i <= top; i++)\\n        {\\n            maxSizeStack[i] += val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2135820,
                "title": "c-vector-average-time-and-space",
                "content": "```\\npublic:\\n    int n;\\n    vector<int> s;\\n    CustomStack(int maxSize) {\\n        n=(maxSize);\\n    }\\n    \\n    void push(int x) {\\n        if(s.size()<n){\\n            s.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(s.size()==0)\\n            return -1;\\n        int temp = s.back();\\n        s.pop_back();\\n        return temp;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int i=0;\\n        while(k-- && i<s.size()){\\n            \\n            s[i]=s[i]+val;\\n            i++;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic:\\n    int n;\\n    vector<int> s;\\n    CustomStack(int maxSize) {\\n        n=(maxSize);\\n    }\\n    \\n    void push(int x) {\\n        if(s.size()<n){\\n            s.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(s.size()==0)\\n            return -1;\\n        int temp = s.back();\\n        s.pop_back();\\n        return temp;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int i=0;\\n        while(k-- && i<s.size()){\\n            \\n            s[i]=s[i]+val;\\n            i++;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1863073,
                "title": "java-90-faster-self-expalanatory",
                "content": "```\\nclass CustomStack {\\n    int size;\\n    Stack<Integer> st;\\n    int[] arr;\\n    boolean[] state;\\n    int curr;\\n    int idx;\\n    public CustomStack(int maxSize) {\\n        size = maxSize;\\n        st = new Stack<>();\\n        arr = new int[maxSize];\\n        state = new boolean[maxSize];\\n        curr = 0;\\n        idx = 0;\\n    }\\n    public void push(int x) {\\n        if(curr < size){\\n            st.push(x);\\n            arr[idx++] = x;\\n            curr++;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(st.isEmpty()) return -1;\\n        idx--;\\n        if(state[idx]){\\n            int res = arr[idx];\\n            arr[idx]=0;\\n            state[idx] = false;\\n            curr--;\\n            st.pop();\\n            return res;\\n        }else{\\n            curr--;\\n            arr[idx]=0;\\n            state[idx]=false;\\n            return st.pop();\\n        }\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i=0;i<k && i<arr.length;i++){\\n            arr[i]+=val;\\n            state[i] = true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack {\\n    int size;\\n    Stack<Integer> st;\\n    int[] arr;\\n    boolean[] state;\\n    int curr;\\n    int idx;\\n    public CustomStack(int maxSize) {\\n        size = maxSize;\\n        st = new Stack<>();\\n        arr = new int[maxSize];\\n        state = new boolean[maxSize];\\n        curr = 0;\\n        idx = 0;\\n    }\\n    public void push(int x) {\\n        if(curr < size){\\n            st.push(x);\\n            arr[idx++] = x;\\n            curr++;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(st.isEmpty()) return -1;\\n        idx--;\\n        if(state[idx]){\\n            int res = arr[idx];\\n            arr[idx]=0;\\n            state[idx] = false;\\n            curr--;\\n            st.pop();\\n            return res;\\n        }else{\\n            curr--;\\n            arr[idx]=0;\\n            state[idx]=false;\\n            return st.pop();\\n        }\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i=0;i<k && i<arr.length;i++){\\n            arr[i]+=val;\\n            state[i] = true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509474,
                "title": "java-two-solutions-o-n-and-o-1-easy-to-understand",
                "content": "I am trying to solve problems as if I am in a real interview with time limit. I just would like to share my code as a reference in case it might be useful to anyone. Below, in the same class, both solutions are implemented at the same time. \\n\\nI firstly implemented the basic solution with an array which takes O(k) time for the increment() method. The basic solution can be implemented by using an array or a linked list etc. \\n\\nThe second solution creates an extra array for the increment array. With this approach, both increment and pop methods have constant time complexity. It is a bit lengthy to explain this part here, but if you ask or if it is not clear, I would explain it. Please upvote my post if you find it useful. \\n\\n```\\nclass CustomStack { \\n    private int [] inc; \\n    private int [] stack;\\n    private int size;\\n    \\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];\\n        inc = new int[maxSize]; \\n        size = 0;\\n    }\\n    \\n    public void push(int x) {  \\n        if (size < stack.length) {\\n            stack[size++] = x;\\n        }     \\n    }\\n    \\n    public int pop (){\\n        if(size > 0) {\\n            return stack[--size];\\n        }\\n        return -1;\\n    }\\n    public void increment(int k, int val) { \\n        if (k > size) k = size; \\n        \\n        for (int i = 0; i < k; i++) {\\n            stack[i] += val; \\n        }\\n    }\\n    \\n\\t/* The second method - Constant time operations */\\n    public int popConstant() {        \\n        if(size > 0) {\\n            int top = stack[--size] + inc[size];\\n            if (size > 0) inc[size - 1] += inc[size];\\n            inc[size] = 0;\\n            return top;\\n        }\\n        return -1;\\n    }\\n    \\n    public void incrementConstant(int k, int val) {\\n        \\n        if (k > size) k = size;\\n        if (k > 0) inc[k - 1] += val; \\n    }        \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack { \\n    private int [] inc; \\n    private int [] stack;\\n    private int size;\\n    \\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];\\n        inc = new int[maxSize]; \\n        size = 0;\\n    }\\n    \\n    public void push(int x) {  \\n        if (size < stack.length) {\\n            stack[size++] = x;\\n        }     \\n    }\\n    \\n    public int pop (){\\n        if(size > 0) {\\n            return stack[--size];\\n        }\\n        return -1;\\n    }\\n    public void increment(int k, int val) { \\n        if (k > size) k = size; \\n        \\n        for (int i = 0; i < k; i++) {\\n            stack[i] += val; \\n        }\\n    }\\n    \\n\\t/* The second method - Constant time operations */\\n    public int popConstant() {        \\n        if(size > 0) {\\n            int top = stack[--size] + inc[size];\\n            if (size > 0) inc[size - 1] += inc[size];\\n            inc[size] = 0;\\n            return top;\\n        }\\n        return -1;\\n    }\\n    \\n    public void incrementConstant(int k, int val) {\\n        \\n        if (k > size) k = size;\\n        if (k > 0) inc[k - 1] += val; \\n    }        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1291158,
                "title": "beats-95-easy-python-constant-time-increment-operation",
                "content": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        \\n        self.maxsize = maxSize\\n        self.stack=[]\\n        self.inc = []\\n        \\n\\n    def push(self, x: int) -> None:\\n        \\n        if len(self.stack)< self.maxsize:\\n            self.stack.append(x)\\n            self.inc.append(0)\\n\\n    def pop(self) -> int:\\n        \\n        if not self.stack:\\n            return -1\\n        \\n        if len(self.inc)>1:\\n            self.inc[-2]+=self.inc[-1]\\n        \\n        return self.stack.pop()+self.inc.pop()\\n        \\n\\n    def increment(self, k: int, val: int) -> None:\\n        if self.inc:\\n            self.inc[min(k,len(self.inc))-1]+=val\\n\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        \\n        self.maxsize = maxSize\\n        self.stack=[]\\n        self.inc = []\\n        \\n\\n    def push(self, x: int) -> None:\\n        \\n        if len(self.stack)< self.maxsize:\\n            self.stack.append(x)\\n            self.inc.append(0)\\n\\n    def pop(self) -> int:\\n        \\n        if not self.stack:\\n            return -1\\n        \\n        if len(self.inc)>1:\\n            self.inc[-2]+=self.inc[-1]\\n        \\n        return self.stack.pop()+self.inc.pop()\\n        \\n\\n    def increment(self, k: int, val: int) -> None:\\n        if self.inc:\\n            self.inc[min(k,len(self.inc))-1]+=val\\n\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835519,
                "title": "easy-c-solution-beats-91",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nrepresent stack with an array\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nicrement the first k elements of the array by val\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass CustomStack {\\npublic:\\n    vector<int> st;\\n    int n;\\n    CustomStack(int maxSize) {\\n        n = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(st.size() < n){\\n            st.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(st.size() != 0){\\n            int x = st[st.size() - 1];\\n            st.pop_back();\\n            return x;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int a;\\n        if(k <= st.size()) a = k;\\n        else a = st.size();\\n        for(int i = 0; i < a;i++){\\n            st[i] += val;\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    vector<int> st;\\n    int n;\\n    CustomStack(int maxSize) {\\n        n = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(st.size() < n){\\n            st.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(st.size() != 0){\\n            int x = st[st.size() - 1];\\n            st.pop_back();\\n            return x;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int a;\\n        if(k <= st.size()) a = k;\\n        else a = st.size();\\n        for(int i = 0; i < a;i++){\\n            st[i] += val;\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340542,
                "title": "python-o-1-time-operation-complexity-easy-lazy-increment",
                "content": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.maxSize = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:  \\n            self.stack.append([x, 0])\\n    \\n    def pop(self) -> int:\\n        if self.stack:\\n            val, inc = self.stack.pop()\\n            if self.stack:\\n                self.stack[-1][1] += inc\\n            return val + inc\\n        return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if self.stack:\\n            self.stack[min(k-1, len(self.stack)-1)][1] += val\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.maxSize = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:  \\n            self.stack.append([x, 0])\\n    \\n    def pop(self) -> int:\\n        if self.stack:\\n            val, inc = self.stack.pop()\\n            if self.stack:\\n                self.stack[-1][1] += inc\\n            return val + inc\\n        return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if self.stack:\\n            self.stack[min(k-1, len(self.stack)-1)][1] += val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877537,
                "title": "best-c-solution-using-vector-beats-100",
                "content": "# Code\\n```\\nclass CustomStack {\\n    int size;\\n    vector<int> arr;\\npublic:\\n    CustomStack(int maxSize) {\\n       size = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(arr.size() < size)\\n            arr.push_back(x);\\n    }\\n    \\n    int pop() {\\n        if(arr.size() == 0)\\n            return -1;\\n        else{\\n            int res=arr.back();\\n            arr.pop_back();\\n            return res;\\n        }\\n        \\n    }\\n    \\n    void increment(int k, int val) {\\n        int x = k;\\n        if(arr.size() < k)\\n            x = arr.size();\\n        for(int i=0; i < x; i++){\\n            arr[i] += val;\\n        }\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack {\\n    int size;\\n    vector<int> arr;\\npublic:\\n    CustomStack(int maxSize) {\\n       size = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(arr.size() < size)\\n            arr.push_back(x);\\n    }\\n    \\n    int pop() {\\n        if(arr.size() == 0)\\n            return -1;\\n        else{\\n            int res=arr.back();\\n            arr.pop_back();\\n            return res;\\n        }\\n        \\n    }\\n    \\n    void increment(int k, int val) {\\n        int x = k;\\n        if(arr.size() < k)\\n            x = arr.size();\\n        for(int i=0; i < x; i++){\\n            arr[i] += val;\\n        }\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482633,
                "title": "simple-java-solution-using-2-stacks",
                "content": "Simple Java Solution using 2 stacks.\\n```\\nclass CustomStack {\\n\\n    int max= 0;\\n    Stack<Integer> s1= new Stack<>();\\n    \\n    public CustomStack(int maxSize) {\\n        max= maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if( s1.size() < max ){\\n            s1.push(x);\\n        }\\n    }\\n    \\n    public int pop() {\\n        \\n        if(s1.size() > 0){\\n            return s1.pop();\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n    \\n    public void increment(int k, int val) {\\n        Stack<Integer> s2= new Stack<>();\\n        \\n        while(!s1.isEmpty()){\\n            s2.push(s1.pop());\\n        }\\n        \\n        for(int i=0; i<k; i++){\\n            if(s2.size() == 0){\\n                break;\\n            }\\n            \\n            s1.push(s2.pop()+val);\\n        }\\n        \\n        while(s2.size() != 0){\\n            s1.push(s2.pop());\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack {\\n\\n    int max= 0;\\n    Stack<Integer> s1= new Stack<>();\\n    \\n    public CustomStack(int maxSize) {\\n        max= maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if( s1.size() < max ){\\n            s1.push(x);\\n        }\\n    }\\n    \\n    public int pop() {\\n        \\n        if(s1.size() > 0){\\n            return s1.pop();\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n    \\n    public void increment(int k, int val) {\\n        Stack<Integer> s2= new Stack<>();\\n        \\n        while(!s1.isEmpty()){\\n            s2.push(s1.pop());\\n        }\\n        \\n        for(int i=0; i<k; i++){\\n            if(s2.size() == 0){\\n                break;\\n            }\\n            \\n            s1.push(s2.pop()+val);\\n        }\\n        \\n        while(s2.size() != 0){\\n            s1.push(s2.pop());\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386914,
                "title": "c-using-lazy-array-o-1-for-each-querry",
                "content": "If you are aware of lazy propogation in segment tree than i did something same in the array \\n\\nMy Code:-\\n\\n```\\nclass CustomStack {\\npublic:\\n    vector<int> arr;\\n    vector<int> lazy;\\n    int sze;\\n    CustomStack(int maxSize) {\\n        sze = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(arr.size() < sze){\\n            arr.push_back(x);\\n            lazy.push_back(0);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(arr.size() == 0) return -1;\\n        int tp = arr.back() + lazy.back();\\n        arr.pop_back();\\n        if(arr.size() != 0) lazy[lazy.size()-2] += lazy.back();\\n        lazy.pop_back();\\n        return tp;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(arr.size() == 0) return;\\n        k = min(k, (int)arr.size());\\n        lazy[k-1] += val;\\n    }\\n};\\n```\\n\\nUpvoting will make me Happy BTW :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    vector<int> arr;\\n    vector<int> lazy;\\n    int sze;\\n    CustomStack(int maxSize) {\\n        sze = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(arr.size() < sze){\\n            arr.push_back(x);\\n            lazy.push_back(0);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(arr.size() == 0) return -1;\\n        int tp = arr.back() + lazy.back();\\n        arr.pop_back();\\n        if(arr.size() != 0) lazy[lazy.size()-2] += lazy.back();\\n        lazy.pop_back();\\n        return tp;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(arr.size() == 0) return;\\n        k = min(k, (int)arr.size());\\n        lazy[k-1] += val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385742,
                "title": "c-easy-approach-with-explanation",
                "content": "**time complexity :- O(1) for push and pop and O(n) for increment**\\n```\\nclass CustomStack {\\n    int *data;\\n    int nextIndex;\\n    int capacity;\\npublic:\\n    CustomStack(int maxSize) {\\n        data = new int[maxSize];\\n        nextIndex = 0;\\n        capacity = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(nextIndex == capacity){\\n            return;\\n        }\\n        data[nextIndex] = x;\\n        nextIndex++;\\n    }\\n    \\n    int pop() {\\n        if(nextIndex == 0){\\n            return -1;\\n        }\\n        int temp = data[nextIndex-1];\\n        nextIndex--;\\n        return temp;\\n    }\\n    \\n    void increment(int k, int val) {\\n\\t\\t//loop will run upto nextIndex if k >= nextIndex else runt upto k only\\n        int n = (k >= nextIndex) ? nextIndex : k;\\n        for(int i = 0; i < n; i++){\\n            data[i]  = data[i] + val;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack {\\n    int *data;\\n    int nextIndex;\\n    int capacity;\\npublic:\\n    CustomStack(int maxSize) {\\n        data = new int[maxSize];\\n        nextIndex = 0;\\n        capacity = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(nextIndex == capacity){\\n            return;\\n        }\\n        data[nextIndex] = x;\\n        nextIndex++;\\n    }\\n    \\n    int pop() {\\n        if(nextIndex == 0){\\n            return -1;\\n        }\\n        int temp = data[nextIndex-1];\\n        nextIndex--;\\n        return temp;\\n    }\\n    \\n    void increment(int k, int val) {\\n\\t\\t//loop will run upto nextIndex if k >= nextIndex else runt upto k only\\n        int n = (k >= nextIndex) ? nextIndex : k;\\n        for(int i = 0; i < n; i++){\\n            data[i]  = data[i] + val;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879712,
                "title": "easiest-approach-using-vectors-faster-than-others",
                "content": "```\\nclass CustomStack {\\n    int cap;\\n    vector<int> arr;\\npublic:\\n    CustomStack(int maxSize) {\\n       cap=maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(arr.size()<cap)\\n            arr.push_back(x);\\n        \\n    }\\n    \\n    int pop() {\\n        if(arr.size()==0)\\n            return -1;\\n        else{\\n            int res=arr.back();\\n            arr.pop_back();\\n            return res;\\n        }\\n        \\n    }\\n    \\n    void increment(int k, int val) {\\n      int x=k;\\n        if(arr.size()<k){\\n            x=arr.size();\\n        }\\n        for(int i=0;i<x;i++){\\n            arr[i]+=val;\\n        }\\n    }\\n};\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass CustomStack {\\n    int cap;\\n    vector<int> arr;\\npublic:\\n    CustomStack(int maxSize) {\\n       cap=maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(arr.size()<cap)\\n            arr.push_back(x);\\n        \\n    }\\n    \\n    int pop() {\\n        if(arr.size()==0)\\n            return -1;\\n        else{\\n            int res=arr.back();\\n            arr.pop_back();\\n            return res;\\n        }\\n        \\n    }\\n    \\n    void increment(int k, int val) {\\n      int x=k;\\n        if(arr.size()<k){\\n            x=arr.size();\\n        }\\n        for(int i=0;i<x;i++){\\n            arr[i]+=val;\\n        }\\n    }\\n};\\n\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1778364,
                "title": "easy-c-solution",
                "content": "```\\nclass CustomStack {\\npublic:\\n    vector<int>v;\\n    int limit;\\n    CustomStack(int maxSize) {\\n        v.clear();\\n        limit=maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(v.size()<limit) {\\n            v.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(v.size()>0) {\\n            int d=v.back();\\n            v.erase(v.begin()+v.size()-1);\\n            return d;\\n        }\\n        else {\\n            return -1;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        for(int i=0;i<min(int(v.size()),k);i++) {\\n            v[i]+=val;\\n        }\\n    }\\n};\\n```\\n***Please upvote if you\\'ve got any help from my code. Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    vector<int>v;\\n    int limit;\\n    CustomStack(int maxSize) {\\n        v.clear();\\n        limit=maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(v.size()<limit) {\\n            v.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(v.size()>0) {\\n            int d=v.back();\\n            v.erase(v.begin()+v.size()-1);\\n            return d;\\n        }\\n        else {\\n            return -1;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        for(int i=0;i<min(int(v.size()),k);i++) {\\n            v[i]+=val;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633403,
                "title": "using-deque-short-and-simple-code",
                "content": "```\\nclass CustomStack {\\npublic:\\n    deque<int> stk;\\n    int maxsize;\\n    CustomStack(int maxSize) {\\n        maxsize = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(stk.size() < maxsize ) stk.push_back(x);\\n    }\\n    \\n    int pop() {\\n        if(stk.empty()) return -1;\\n        int temp = stk.back();\\n        stk.pop_back();\\n        return temp;\\n    }\\n    \\n    void increment(int k, int val) {\\n        for(int i = 0; i < k && i < stk.size(); i++)\\n            stk[i] += val;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    deque<int> stk;\\n    int maxsize;\\n    CustomStack(int maxSize) {\\n        maxsize = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(stk.size() < maxsize ) stk.push_back(x);\\n    }\\n    \\n    int pop() {\\n        if(stk.empty()) return -1;\\n        int temp = stk.back();\\n        stk.pop_back();\\n        return temp;\\n    }\\n    \\n    void increment(int k, int val) {\\n        for(int i = 0; i < k && i < stk.size(); i++)\\n            stk[i] += val;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1036267,
                "title": "c-all-o-1-operations-using-hashing-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/design-a-stack-with-increment-operation/submissions/\\n    \\n    Push and pop are simple to do with O(1), problem is with increment operation\\n    that can take O(k) if done naively each time.\\n    To make that faster, we can use a hash table that can save the increment needed\\n    till elements of stack from position: 0 -> position\\n    Eg: if increment(2): then we can set hash_table[2] = value\\n    Now a check for incremented value can only be ensured with a pop operation\\n    in a stack, so we update the popped value. During pop, we check the additional\\n    value needed for the element with that index, it might happen that the current position\\n    is lesser than the position for which the increment update was done in hash table and\\n    hence the current position in hash table is not aware that it should have some increment\\n    amount. The optimization lies in this problem, if we simply look for the first updated\\n    value position in hash table after the current stack top position, O(max_size) worst case.\\n    So each time when we do a pop, we make sure to pass the value to its immediate left index\\n    and we do the same each time during a pop.\\n    This ensures that the index in hash table for any pop operation is always updated.\\n    \\n    Eg: Stack: 1, 2 \\n    Hash Table: \\n    \\n    inc(2, 100): Hash Table: <2, 100> // Notice how oonly index 2 is set and not index 1\\n    pop(): Stack: 1\\n        Hash Table: \\n            #Step 1: <1, 0> + <2, 100> = <1, 100> : Pass the increment value to lower index\\n            #Step 2: <2, 0>: Reset value for index which has passed\\n    \\n    TC: Push: O(1), Pop: O(1), increment: O(1)\\n    SC: O(max_size)\\n*/\\nclass CustomStack {\\n    int max_size = 0;\\n    vector<int> s;\\n    int top = 0;\\n    // This saves the increment value set for \\n    // till each position\\n    unordered_map<int, int> additional_val;\\npublic:\\n    CustomStack(int maxSize) {\\n        max_size = maxSize;\\n        s.resize(max_size);\\n    }\\n    \\n    void push(int x) {\\n        if (top < max_size)\\n            s[top++] = x;\\n    }\\n    \\n    int pop() {\\n        if (top <= 0)\\n            return -1;\\n        int increment_val = additional_val[top];\\n        // propagate the increment to lower indices, since all lower \\n        // position elements should also have component of this increment\\n        additional_val[top-1] += increment_val;\\n        // reset the increment for till this position caused\\n        // by incrment() for this position\\n        additional_val[top] = 0;\\n        return increment_val + s[--top];\\n    }\\n    \\n    void increment(int k, int val) {\\n        // find the effective K based on actual number of elements\\n        k = min(k, top);\\n        additional_val[k] += val;\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/design-a-stack-with-increment-operation/submissions/\\n    \\n    Push and pop are simple to do with O(1), problem is with increment operation\\n    that can take O(k) if done naively each time.\\n    To make that faster, we can use a hash table that can save the increment needed\\n    till elements of stack from position: 0 -> position\\n    Eg: if increment(2): then we can set hash_table[2] = value\\n    Now a check for incremented value can only be ensured with a pop operation\\n    in a stack, so we update the popped value. During pop, we check the additional\\n    value needed for the element with that index, it might happen that the current position\\n    is lesser than the position for which the increment update was done in hash table and\\n    hence the current position in hash table is not aware that it should have some increment\\n    amount. The optimization lies in this problem, if we simply look for the first updated\\n    value position in hash table after the current stack top position, O(max_size) worst case.\\n    So each time when we do a pop, we make sure to pass the value to its immediate left index\\n    and we do the same each time during a pop.\\n    This ensures that the index in hash table for any pop operation is always updated.\\n    \\n    Eg: Stack: 1, 2 \\n    Hash Table: \\n    \\n    inc(2, 100): Hash Table: <2, 100> // Notice how oonly index 2 is set and not index 1\\n    pop(): Stack: 1\\n        Hash Table: \\n            #Step 1: <1, 0> + <2, 100> = <1, 100> : Pass the increment value to lower index\\n            #Step 2: <2, 0>: Reset value for index which has passed\\n    \\n    TC: Push: O(1), Pop: O(1), increment: O(1)\\n    SC: O(max_size)\\n*/\\nclass CustomStack {\\n    int max_size = 0;\\n    vector<int> s;\\n    int top = 0;\\n    // This saves the increment value set for \\n    // till each position\\n    unordered_map<int, int> additional_val;\\npublic:\\n    CustomStack(int maxSize) {\\n        max_size = maxSize;\\n        s.resize(max_size);\\n    }\\n    \\n    void push(int x) {\\n        if (top < max_size)\\n            s[top++] = x;\\n    }\\n    \\n    int pop() {\\n        if (top <= 0)\\n            return -1;\\n        int increment_val = additional_val[top];\\n        // propagate the increment to lower indices, since all lower \\n        // position elements should also have component of this increment\\n        additional_val[top-1] += increment_val;\\n        // reset the increment for till this position caused\\n        // by incrment() for this position\\n        additional_val[top] = 0;\\n        return increment_val + s[--top];\\n    }\\n    \\n    void increment(int k, int val) {\\n        // find the effective K based on actual number of elements\\n        k = min(k, top);\\n        additional_val[k] += val;\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 799451,
                "title": "java-o-1-simple-solution-beats-100",
                "content": "Simple idea is to maintain two arrays for values and increments. Keep a counter to track the current `currInd`.  We lazily transfer the `inc` down the stack when `pop` takes place. \\n\\n- On a `push` just initialize the `currInd`. Note we just overwrite entries.\\n- On a `pop` transfer the `inc` value to `currInd-1`. This way we transfer `inc` to the bottom entries. Also the actual value in the stack is `val`+`inc` value.\\n- On an `increment` just update the `kth` index. \\n\\nSo if we see two increments for `(ind, val)` -> `(3,10)` and `(5,15)` we will maintain 15 and 10 at right indices. Once pop occurs at index 5 we will transfer 15 to index 4, and on subsequent pop the inc value becomes `10+15=25` at index 3.   \\n\\n```\\nclass CustomStack {\\n\\n    int currInd = -1;\\n    int valStack[];\\n    int incStack[];\\n    int maxLen;\\n    public CustomStack(int maxSize) {\\n        valStack = new int[maxSize];\\n        incStack = new int[maxSize];\\n        maxLen = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if (currInd+1 != maxLen) {\\n            valStack[currInd+1] = x;\\n            incStack[currInd+1] = 0;\\n            currInd++;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if (currInd == -1) {\\n            return -1;\\n        }\\n        int val = valStack[currInd]+incStack[currInd];\\n        if (currInd > 0) {\\n            incStack[currInd-1] += incStack[currInd];\\n        }\\n        currInd--;    \\n        return val;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        if (currInd == -1) {\\n            return;\\n        }\\n        int ind = Math.min(currInd, k-1);\\n        incStack[ind] += val;\\n    }\\n}\\n\\n```\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n\\n    int currInd = -1;\\n    int valStack[];\\n    int incStack[];\\n    int maxLen;\\n    public CustomStack(int maxSize) {\\n        valStack = new int[maxSize];\\n        incStack = new int[maxSize];\\n        maxLen = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if (currInd+1 != maxLen) {\\n            valStack[currInd+1] = x;\\n            incStack[currInd+1] = 0;\\n            currInd++;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if (currInd == -1) {\\n            return -1;\\n        }\\n        int val = valStack[currInd]+incStack[currInd];\\n        if (currInd > 0) {\\n            incStack[currInd-1] += incStack[currInd];\\n        }\\n        currInd--;    \\n        return val;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        if (currInd == -1) {\\n            return;\\n        }\\n        int ind = Math.min(currInd, k-1);\\n        incStack[ind] += val;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702716,
                "title": "simple-and-fast-python-solution",
                "content": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.maxSize = maxSize\\n        \\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:\\n            self.stack.append(x)\\n        \\n\\n    def pop(self) -> int:\\n        if len(self.stack) <= 0:\\n            return -1\\n        \\n        return self.stack.pop()\\n\\n    \\n    def increment(self, k: int, val: int) -> None:        \\n        end = min(k,len(self.stack))\\n        for i in range(0,end):\\n            self.stack[i] += val\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.maxSize = maxSize\\n        \\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:\\n            self.stack.append(x)\\n        \\n\\n    def pop(self) -> int:\\n        if len(self.stack) <= 0:\\n            return -1\\n        \\n        return self.stack.pop()\\n\\n    \\n    def increment(self, k: int, val: int) -> None:        \\n        end = min(k,len(self.stack))\\n        for i in range(0,end):\\n            self.stack[i] += val\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 590434,
                "title": "java-2-accepted-solutions-clear-explanation",
                "content": "ok lets do this!!\\nwe have to implement a stack where some operations are to be done-pop,push,increment etc!\\n\\nnote- i see many people using a stack to solve to solve this question!i am not going to do that because i feel that is absurd because you are already using predefined functions like push() and pop() ,which the question doesnt ask!\\nthe question asks us to implement a stack!\\ni am going to show two data structures that you can do to simulate the stack operations!\\n\\nAPPROACH 1-\\nUSING ARRAY!\\n\\n1>we take an array which we initialise with size as maaxSize\\n2>we also take an pointer initialy set to -1;\\n3>so that whenever underflow condition occurs we print -1\\n4>whenever we are popping we decrement the pointer by 1\\n\\nrest of it is pretty much self explanatory!\\n```\\nclass CustomStack {\\n    \\n    private int[] arr;\\n    private int   i = -1;\\n\\n    public CustomStack(int maxSize) {\\n        this.arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n        if (i+1 < arr.length) {\\n            arr[++i] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        return i < 0 ? i : arr[i--];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for (int j = 0; j < Math.min(k, i+1); j++) {\\n            arr[j] += val;\\n        }\\n    }\\n}\\n```\\n\\n\\n\\nAPPROACH 2-\\nUSING ARRAYLIST\\n\\n```\\nimport java.util.*;\\nclass CustomStack {\\n int n;\\n  List<Integer> s=new ArrayList<>()  ;\\n        \\n    public CustomStack(int maxSize) {\\n        n=maxSize;\\n       \\n    }\\n    \\n    public void push(int x) {\\n        if(s.size()<n)\\n        {\\n            s.add(x);\\n        }\\n    }\\n    \\n    public int pop() {\\n      if(s.size()!=0)\\n        return   s.remove(s.size()-1);\\n   \\n        else\\n        return -1;\\n    }\\n    \\n    public void increment(int k, int val) {\\n    for(int i=0;i<k && i<s.size();i++)\\n    {\\n        s.set(i,s.get(i)+val);\\n    }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n ```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass CustomStack {\\n    \\n    private int[] arr;\\n    private int   i = -1;\\n\\n    public CustomStack(int maxSize) {\\n        this.arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n        if (i+1 < arr.length) {\\n            arr[++i] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        return i < 0 ? i : arr[i--];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for (int j = 0; j < Math.min(k, i+1); j++) {\\n            arr[j] += val;\\n        }\\n    }\\n}\\n```\n```\\nimport java.util.*;\\nclass CustomStack {\\n int n;\\n  List<Integer> s=new ArrayList<>()  ;\\n        \\n    public CustomStack(int maxSize) {\\n        n=maxSize;\\n       \\n    }\\n    \\n    public void push(int x) {\\n        if(s.size()<n)\\n        {\\n            s.add(x);\\n        }\\n    }\\n    \\n    public int pop() {\\n      if(s.size()!=0)\\n        return   s.remove(s.size()-1);\\n   \\n        else\\n        return -1;\\n    }\\n    \\n    public void increment(int k, int val) {\\n    for(int i=0;i<k && i<s.size();i++)\\n    {\\n        s.set(i,s.get(i)+val);\\n    }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3887585,
                "title": "100-beats-easy-to-understand-beginner-friendly-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass CustomStack {\\n    int *arr;\\n    int top;\\n    int size;\\npublic:\\n    CustomStack(int maxSize) {\\n         size=maxSize;\\n        arr=new int [size];\\n        top=-1;\\n    }\\n    \\n    void push(int x) {\\n        if(top==size-1);\\n       else{ top=top+1;\\n        arr[top]=x;\\n       }\\n    }\\n    \\n    int pop() {\\n        if(top==-1)return -1;\\n        int ans=arr[top];\\n        top=top-1;\\n        return ans;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int peek=0;\\n        if(top+1<k){\\n            while(peek!=top+1){\\n                arr[peek]+=val;\\n                peek++;\\n            }\\n        }\\n        else{\\n            while(peek!=k){\\n                arr[peek]+=val;\\n                peek++;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack {\\n    int *arr;\\n    int top;\\n    int size;\\npublic:\\n    CustomStack(int maxSize) {\\n         size=maxSize;\\n        arr=new int [size];\\n        top=-1;\\n    }\\n    \\n    void push(int x) {\\n        if(top==size-1);\\n       else{ top=top+1;\\n        arr[top]=x;\\n       }\\n    }\\n    \\n    int pop() {\\n        if(top==-1)return -1;\\n        int ans=arr[top];\\n        top=top-1;\\n        return ans;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int peek=0;\\n        if(top+1<k){\\n            while(peek!=top+1){\\n                arr[peek]+=val;\\n                peek++;\\n            }\\n        }\\n        else{\\n            while(peek!=k){\\n                arr[peek]+=val;\\n                peek++;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885986,
                "title": "beginner-friendly-solution-runtime-100-beats-memory-94-beats-fully-explained",
                "content": "# Approach\\n\\nThe goal of this problem is to design a custom stack that supports various operations such as push, pop, and an increment operation for specific elements in the stack. We need to make sure we implement these operations efficiently within the given constraints.\\n\\n**Logic:**\\n\\n1. **Initialization:** The `CustomStack` class is initialized with a constructor that takes the `maxSize` as an argument and initializes an integer array named `stack` to store the elements. An integer variable `inc` is used to keep track of the current index to which an element will be pushed.\\n\\n2. **Push Operation:** The `push` operation takes an integer `x` as an argument. If the value of `inc` (the current index) is less than the length of the `stack` array, it means there is space to push an element. So, the value `x` is added to the `stack` array at the index `inc`, and then `inc` is incremented.\\n\\n3. **Pop Operation:** The `pop` operation doesn\\'t need any arguments. It first checks if the value of `inc` is greater than 0, indicating that there are elements in the stack. If so, it decrements `inc` to point to the last pushed element and stores that element in the `last` variable. Then, the value at the index `inc` is reset to 0 (indicating an empty slot). Finally, the `last` element is returned.\\n\\n4. **Increment Operation:** The `increment` operation takes two arguments: `k` and `val`. This operation is used to increment the bottom `k` elements of the stack by `val`. The idea here is to loop through the first `k` elements of the `stack` array (or all elements if there are fewer than `k` elements) and add `val` to each of them.\\n\\n**Explanation:**\\n\\n- The `push` operation is quite straightforward. It adds an element to the stack if there\\'s space available.\\n\\n- The `pop` operation retrieves the last pushed element (if available) and also clears that slot in the stack.\\n\\n- The `increment` operation modifies the bottom `k` elements by adding `val`. The loop ensures that we only modify existing elements within the range of the stack.\\n\\nOverall, this approach uses an integer array as the main data structure to simulate the stack behavior. The use of the `inc` variable keeps track of the current index to manage elements effectively. The logic is designed to accommodate the constraints and requirements of the problem statement.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(maxSize)$$\\n\\n# Code\\n```\\nclass CustomStack {\\n    int[] stack;\\n    int inc;\\n\\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n       if(inc < stack.length) {\\n           stack[inc++] = x;\\n       } \\n    }\\n    \\n    public int pop() {\\n        int last = -1;\\n        if(inc > 0) {\\n            last = stack[--inc];\\n            stack[inc] = 0;\\n        }\\n        return last;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int limit = inc > k ? k : inc;\\n        for(int i = 0; i < limit; i++) {\\n            stack[i] += val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Array",
                    "Stack",
                    "Design"
                ],
                "code": "```\\nclass CustomStack {\\n    int[] stack;\\n    int inc;\\n\\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n       if(inc < stack.length) {\\n           stack[inc++] = x;\\n       } \\n    }\\n    \\n    public int pop() {\\n        int last = -1;\\n        if(inc > 0) {\\n            last = stack[--inc];\\n            stack[inc] = 0;\\n        }\\n        return last;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int limit = inc > k ? k : inc;\\n        for(int i = 0; i < limit; i++) {\\n            stack[i] += val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782186,
                "title": "python-98-18-faster-easy-o-solution",
                "content": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack=[]\\n        self.n=maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack)<self.n:\\n            self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        if len(self.stack)==0:\\n            return -1\\n        return self.stack.pop()\\n\\n    def increment(self, k: int, val: int) -> None:\\n        l=len(self.stack)\\n        for i in range(l):\\n            if i==k:\\n                break\\n            self.stack[i]+=val\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack=[]\\n        self.n=maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack)<self.n:\\n            self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        if len(self.stack)==0:\\n            return -1\\n        return self.stack.pop()\\n\\n    def increment(self, k: int, val: int) -> None:\\n        l=len(self.stack)\\n        for i in range(l):\\n            if i==k:\\n                break\\n            self.stack[i]+=val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456461,
                "title": "design-a-stack-with-increment-operation-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass CustomStack {\\npublic:\\n    vector<int> st;\\n    int n;\\n    CustomStack(int maxSize) {\\n        n = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(st.size()<n)\\n        {\\n            st.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(st.size()>0)\\n        {\\n            int popped = st[st.size()-1];\\n            st.erase(st.begin()+st.size()-1);\\n            return popped;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(k>st.size())\\n        {\\n            for(int i=0 ; i<st.size() ; i++)\\n            {\\n                st[i] += val;\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0 ; i<k ; i++)\\n            {\\n                st[i] += val;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/8c633a21-6464-4048-b3f4-a8c7af621f87_1682612493.9823296.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    vector<int> st;\\n    int n;\\n    CustomStack(int maxSize) {\\n        n = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(st.size()<n)\\n        {\\n            st.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(st.size()>0)\\n        {\\n            int popped = st[st.size()-1];\\n            st.erase(st.begin()+st.size()-1);\\n            return popped;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(k>st.size())\\n        {\\n            for(int i=0 ; i<st.size() ; i++)\\n            {\\n                st[i] += val;\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0 ; i<k ; i++)\\n            {\\n                st[i] += val;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117997,
                "title": "c-solution",
                "content": "```\\nclass CustomStack {\\npublic:\\n    vector<int> arr;\\n    int sz;\\n    \\n    CustomStack(int maxSize) {\\n        sz= maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(arr.size()<sz) arr.push_back(x);\\n    }\\n    \\n    int pop() {\\n        if(arr.size()==0)return -1;\\n        int ans= arr.back();\\n        arr.pop_back();\\n        return ans;\\n    }\\n    \\n    void increment(int k, int val) {\\n        k= min(k,(int)arr.size());\\n        for(int i=0;i<k;i++) arr[i]+= val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    vector<int> arr;\\n    int sz;\\n    \\n    CustomStack(int maxSize) {\\n        sz= maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(arr.size()<sz) arr.push_back(x);\\n    }\\n    \\n    int pop() {\\n        if(arr.size()==0)return -1;\\n        int ans= arr.back();\\n        arr.pop_back();\\n        return ans;\\n    }\\n    \\n    void increment(int k, int val) {\\n        k= min(k,(int)arr.size());\\n        for(int i=0;i<k;i++) arr[i]+= val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117089,
                "title": "c-using-2-stacks",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass CustomStack {\\n    stack<int> s;\\n    stack<int> ss;\\n    int maxsize;\\npublic:\\n    CustomStack(int maxsize) {\\n        this -> maxsize = maxsize;\\n    }\\n    \\n    void push(int x) {\\n        if(s.size() < maxsize) {\\n            s.push(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(s.empty()) return -1;\\n        int t = s.top();\\n        s.pop();\\n        return t;\\n    }\\n    \\n    void increment(int k, int val) {\\n        while(s.size() > k) {\\n            ss.push(s.top());\\n            s.pop();\\n        }\\n        while(s.size()) {\\n            s.top() += val;\\n            ss.push(s.top());\\n            s.pop();\\n        }\\n        while(ss.size()) {\\n            s.push(ss.top());\\n            ss.pop();\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass CustomStack {\\n    stack<int> s;\\n    stack<int> ss;\\n    int maxsize;\\npublic:\\n    CustomStack(int maxsize) {\\n        this -> maxsize = maxsize;\\n    }\\n    \\n    void push(int x) {\\n        if(s.size() < maxsize) {\\n            s.push(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(s.empty()) return -1;\\n        int t = s.top();\\n        s.pop();\\n        return t;\\n    }\\n    \\n    void increment(int k, int val) {\\n        while(s.size() > k) {\\n            ss.push(s.top());\\n            s.pop();\\n        }\\n        while(s.size()) {\\n            s.top() += val;\\n            ss.push(s.top());\\n            s.pop();\\n        }\\n        while(ss.size()) {\\n            s.push(ss.top());\\n            ss.pop();\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036366,
                "title": "simple-array-solution",
                "content": "\\n# Code\\n```\\nclass CustomStack {\\n    int capacity,top_index,count=0;\\n    int arr[1000];\\npublic:\\n    CustomStack(int maxSize) {\\n        capacity=maxSize;\\n        top_index=-1;\\n        arr[maxSize];\\n    }\\n    \\n    void push(int x) {\\n        if(count < capacity){\\n            top_index++;\\n            if(top_index <capacity){\\n                arr[top_index]=x;\\n                count++;\\n            }\\n        }\\n    }\\n    \\n    int pop() {\\n        if(top_index == -1) return -1;\\n        count--;\\n        return arr[top_index--];\\n        \\n    }\\n    \\n    void increment(int k, int val) {\\n        int i=0;\\n        if(k>=count){\\n            while(i<=top_index){\\n                arr[i] += val;\\n                i++;\\n            }\\n        }\\n        else{\\n            while(i<k){\\n                arr[i] += val;\\n                i++;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass CustomStack {\\n    int capacity,top_index,count=0;\\n    int arr[1000];\\npublic:\\n    CustomStack(int maxSize) {\\n        capacity=maxSize;\\n        top_index=-1;\\n        arr[maxSize];\\n    }\\n    \\n    void push(int x) {\\n        if(count < capacity){\\n            top_index++;\\n            if(top_index <capacity){\\n                arr[top_index]=x;\\n                count++;\\n            }\\n        }\\n    }\\n    \\n    int pop() {\\n        if(top_index == -1) return -1;\\n        count--;\\n        return arr[top_index--];\\n        \\n    }\\n    \\n    void increment(int k, int val) {\\n        int i=0;\\n        if(k>=count){\\n            while(i<=top_index){\\n                arr[i] += val;\\n                i++;\\n            }\\n        }\\n        else{\\n            while(i<k){\\n                arr[i] += val;\\n                i++;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979569,
                "title": "java-100-faster-solution-4ms-easy-to-understand",
                "content": "# Intuition\\nSince a fixed size stack is to be implemented, we will use an Array.\\n# Approach\\nCreate an array of size maxSize in the constructor function and store the top and maxSize of the stack in a variable.\\n\\n# Complexity\\n- Time complexity:\\npush: $$O(1)$$\\npop: $$O(1)$$\\nincrement: $$O(k)$$\\n\\n- Space complexity: $$O(k)$$\\n\\n# Code\\n```\\nclass CustomStack {\\n    int[] arr;\\n    int top;\\n    int maxSize;\\n\\n    public CustomStack(int maxSize) {\\n        arr = new int[maxSize];\\n        top = -1;\\n        this.maxSize = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(top < maxSize-1) {\\n            arr[++top] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(top == -1){\\n            return -1;\\n        }\\n        return arr[top--];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int margin = (int)Math.min(k, arr.length);\\n        for (int i=0; i<margin; i++) {\\n            arr[i]+=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack {\\n    int[] arr;\\n    int top;\\n    int maxSize;\\n\\n    public CustomStack(int maxSize) {\\n        arr = new int[maxSize];\\n        top = -1;\\n        this.maxSize = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(top < maxSize-1) {\\n            arr[++top] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(top == -1){\\n            return -1;\\n        }\\n        return arr[top--];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int margin = (int)Math.min(k, arr.length);\\n        for (int i=0; i<margin; i++) {\\n            arr[i]+=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846669,
                "title": "javascript-soultion-using-array",
                "content": "# Code\\n```\\nclass CustomStack {\\n  constructor (maxSize) {\\n    this.elements = [];\\n    this.maxSize = maxSize;\\n  }\\n\\n  // Time O(1)\\n  // Space O(1)\\n  push(x) {\\n    if (this.elements.length < this.maxSize) {\\n      this.elements.push(x);\\n    }\\n  }\\n \\n  // Time O(1)\\n  // Space O(1)   \\n  pop() {\\n    if (this.elements.length > 0) {\\n      return this.elements.pop();\\n    } else {\\n      return -1;\\n    }\\n  }\\n    \\n  // Time O(k) - where k is the number of elements to increment \\n  // Space O(1)\\n  increment(k, val) {\\n    if (this.elements.length < k) {\\n      for (let i = 0; i < this.elements.length; i++) {\\n        this.elements[i] += val;\\n      }\\n    } else {\\n      for (let i = 0; i < k; i++) {\\n        this.elements[i] += val;\\n      }\\n    }\\n  }\\n}\\n    \\n    \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass CustomStack {\\n  constructor (maxSize) {\\n    this.elements = [];\\n    this.maxSize = maxSize;\\n  }\\n\\n  // Time O(1)\\n  // Space O(1)\\n  push(x) {\\n    if (this.elements.length < this.maxSize) {\\n      this.elements.push(x);\\n    }\\n  }\\n \\n  // Time O(1)\\n  // Space O(1)   \\n  pop() {\\n    if (this.elements.length > 0) {\\n      return this.elements.pop();\\n    } else {\\n      return -1;\\n    }\\n  }\\n    \\n  // Time O(k) - where k is the number of elements to increment \\n  // Space O(1)\\n  increment(k, val) {\\n    if (this.elements.length < k) {\\n      for (let i = 0; i < this.elements.length; i++) {\\n        this.elements[i] += val;\\n      }\\n    } else {\\n      for (let i = 0; i < k; i++) {\\n        this.elements[i] += val;\\n      }\\n    }\\n  }\\n}\\n    \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808144,
                "title": "java-o-k-increment-array-easy-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n - Since, array provides the functionality of random access, which is performed in $$O(1)$$ time, we can easily implement the ```push()```, ```pop()``` functions in $$O(1)$$.\\n - Though ```increment()``` will take $$O(k)$$ because we have to traverse first k elements *(if k < list.length)* in order to increment them.\\n - Maintaining ```idx``` becomes important since indices from ```0``` to ```idx``` represent the actual **stack**.\\n \\n# Complexity\\n- Time complexity: **O(k)** - For ```increment()``` function.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(maxSize)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$Kindly$$ $$upvote$$ $$if$$ $$you$$ $$understood$$ $$the$$ $$solution.. :)$$\\n\\n# Code\\n```\\nclass CustomStack {\\n\\n    int[] list;\\n    int idx;\\n    public CustomStack(int maxSize) {\\n        list = new int[maxSize];\\n        idx=-1;\\n    }\\n    \\n    public void push(int x) {\\n        if(idx < list.length-1) list[++idx]=x;\\n    }\\n    \\n    public int pop() {\\n        if(idx == -1) return -1;\\n        return list[idx--];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int count = k > list.length? list.length : k;\\n        while(count-- > 0) list[count] += val;\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "```push()```\n```pop()```\n```increment()```\n```idx```\n```0```\n```idx```\n```increment()```\n```\\nclass CustomStack {\\n\\n    int[] list;\\n    int idx;\\n    public CustomStack(int maxSize) {\\n        list = new int[maxSize];\\n        idx=-1;\\n    }\\n    \\n    public void push(int x) {\\n        if(idx < list.length-1) list[++idx]=x;\\n    }\\n    \\n    public int pop() {\\n        if(idx == -1) return -1;\\n        return list[idx--];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int count = k > list.length? list.length : k;\\n        while(count-- > 0) list[count] += val;\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558408,
                "title": "unique-implementation-java-easy-to-understand-using-two-arrays",
                "content": "```\\nclass CustomStack {\\n    int[] st;\\n    int[] inc;\\n    \\n    int ms=0;\\n    \\n    int top=1;\\n\\n    public CustomStack(int maxSize) {\\n        st=new int[maxSize+1];\\n        inc=new int[maxSize+1];\\n        ms=maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(top>ms)\\n            return;\\n        st[top++]=x;\\n    }\\n    \\n    public int pop() {\\n        if(top==1)\\n            return -1;\\n        int offset=inc[top-1];\\n        inc[top-1]=0;\\n        inc[top-2]+=offset;\\n        \\n        return st[--top]+offset;\\n        \\n    }\\n    \\n    public void increment(int k, int val) {\\n        inc[0]+=-val;\\n        inc[(int)Math.min(k,top-1)]+=val;\\n    }\\n}\\n```\\n\\nDo upvote if you like my approach, Also comment if any doubt ! :)",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass CustomStack {\\n    int[] st;\\n    int[] inc;\\n    \\n    int ms=0;\\n    \\n    int top=1;\\n\\n    public CustomStack(int maxSize) {\\n        st=new int[maxSize+1];\\n        inc=new int[maxSize+1];\\n        ms=maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(top>ms)\\n            return;\\n        st[top++]=x;\\n    }\\n    \\n    public int pop() {\\n        if(top==1)\\n            return -1;\\n        int offset=inc[top-1];\\n        inc[top-1]=0;\\n        inc[top-2]+=offset;\\n        \\n        return st[--top]+offset;\\n        \\n    }\\n    \\n    public void increment(int k, int val) {\\n        inc[0]+=-val;\\n        inc[(int)Math.min(k,top-1)]+=val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982092,
                "title": "easiest-sol-out-there-push-pop-o-1-increment-o-min-size-k",
                "content": "```\\nclass CustomStack {\\n    vector<int> s;\\n    int k;\\npublic:\\n    CustomStack(int maxSize):s(maxSize){\\n        k=-1;\\n    }\\n    \\n    void push(int x) {\\n        if(k+1>=s.size())return;\\n        s[++k]=x;\\n    }\\n    \\n    int pop() {\\n        if(k>=0)\\n            return s[k--];\\n        else \\n            return -1;\\n    }\\n    \\n    void increment(int kth, int val) {\\n        if(kth>k)\\n            for(auto &i:s)i+=val;\\n        \\n        else{\\n            int i=0;\\n            while(kth--)\\n                s[i++]+=val;\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n    vector<int> s;\\n    int k;\\npublic:\\n    CustomStack(int maxSize):s(maxSize){\\n        k=-1;\\n    }\\n    \\n    void push(int x) {\\n        if(k+1>=s.size())return;\\n        s[++k]=x;\\n    }\\n    \\n    int pop() {\\n        if(k>=0)\\n            return s[k--];\\n        else \\n            return -1;\\n    }\\n    \\n    void increment(int kth, int val) {\\n        if(kth>k)\\n            for(auto &i:s)i+=val;\\n        \\n        else{\\n            int i=0;\\n            while(kth--)\\n                s[i++]+=val;\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906381,
                "title": "java-easy-to-understand-solution-o-1",
                "content": "```\\nclass CustomStack {\\n    \\n    int value[];\\n    int increment[];\\n    int index;\\n    \\n\\n    public CustomStack(int maxSize) {\\n        value = new int[maxSize];\\n        increment = new int[maxSize];\\n        index=-1;\\n    }\\n    \\n    public void push(int x) {\\n        if(index+1 == value.length){\\n            return;\\n        }\\n        index++;\\n        value[index] = x;\\n        increment[index]=0;\\n    }\\n    \\n    public int pop() {\\n        if(index==-1){\\n            return -1;\\n        }\\n        int x = value[index];\\n        int inc = increment[index];\\n        index--;\\n        if(index>=0){\\n            increment[index]+=inc;\\n        }\\n        \\n        return x+inc;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int ind = Math.min(k-1 , index);\\n        if(index>=0){\\n            increment[ind]+=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack {\\n    \\n    int value[];\\n    int increment[];\\n    int index;\\n    \\n\\n    public CustomStack(int maxSize) {\\n        value = new int[maxSize];\\n        increment = new int[maxSize];\\n        index=-1;\\n    }\\n    \\n    public void push(int x) {\\n        if(index+1 == value.length){\\n            return;\\n        }\\n        index++;\\n        value[index] = x;\\n        increment[index]=0;\\n    }\\n    \\n    public int pop() {\\n        if(index==-1){\\n            return -1;\\n        }\\n        int x = value[index];\\n        int inc = increment[index];\\n        index--;\\n        if(index>=0){\\n            increment[index]+=inc;\\n        }\\n        \\n        return x+inc;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int ind = Math.min(k-1 , index);\\n        if(index>=0){\\n            increment[ind]+=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531200,
                "title": "c-solution-using-vector-pair",
                "content": "```\\nclass CustomStack {\\n    int maxSize;\\n    vector<pair<int,int>> stack;\\npublic:\\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(stack.size() == maxSize) return;\\n        stack.push_back({x,0});\\n    }\\n    \\n    int pop() {\\n        if(stack.empty()) return -1;\\n        auto [a,b] = stack.back(); stack.pop_back();\\n        if(!stack.empty()) stack.back().second += b;\\n        return a+b;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(stack.empty()) return;\\n        stack[min(int(stack.size()-1), k-1)].second += val;\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n ```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass CustomStack {\\n    int maxSize;\\n    vector<pair<int,int>> stack;\\npublic:\\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(stack.size() == maxSize) return;\\n        stack.push_back({x,0});\\n    }\\n    \\n    int pop() {\\n        if(stack.empty()) return -1;\\n        auto [a,b] = stack.back(); stack.pop_back();\\n        if(!stack.empty()) stack.back().second += b;\\n        return a+b;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(stack.empty()) return;\\n        stack[min(int(stack.size()-1), k-1)].second += val;\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1464802,
                "title": "java-easy-solution-beats-96-5-users-runtime-4ms",
                "content": "```\\nclass CustomStack {\\n\\n    int arr[];\\n    int top;\\n    public CustomStack(int maxSize) {\\n  \\n        arr=new int[maxSize];\\n        top=0;\\n    }\\n    \\n    public void push(int x) {\\n        \\n        if(top==arr.length)\\n        { return;\\n        }\\n        else\\n        {  \\n            arr[top]=x;\\n            top++;\\n        }\\n    }\\n    \\n    public int pop() {\\n       \\n        if(top==0)\\n        {\\n            return -1;\\n        }\\n      else\\n      {top--;\\n       int ele=arr[top];\\n       return ele;\\n      }\\n  }\\n    \\n    public void increment(int k, int val) {\\n        int i;\\n        if(k>arr.length)\\n        {\\n        for(i=0;i<arr.length;i++)\\n        {  \\n            arr[i]+=val;\\n            }\\n        }   \\n        else\\n        {\\n            for(i=0;i<k;i++)\\n        { \\n            arr[i]+=val;\\n        }\\n       \\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n\\n    int arr[];\\n    int top;\\n    public CustomStack(int maxSize) {\\n  \\n        arr=new int[maxSize];\\n        top=0;\\n    }\\n    \\n    public void push(int x) {\\n        \\n        if(top==arr.length)\\n        { return;\\n        }\\n        else\\n        {  \\n            arr[top]=x;\\n            top++;\\n        }\\n    }\\n    \\n    public int pop() {\\n       \\n        if(top==0)\\n        {\\n            return -1;\\n        }\\n      else\\n      {top--;\\n       int ele=arr[top];\\n       return ele;\\n      }\\n  }\\n    \\n    public void increment(int k, int val) {\\n        int i;\\n        if(k>arr.length)\\n        {\\n        for(i=0;i<arr.length;i++)\\n        {  \\n            arr[i]+=val;\\n            }\\n        }   \\n        else\\n        {\\n            for(i=0;i<k;i++)\\n        { \\n            arr[i]+=val;\\n        }\\n       \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1252019,
                "title": "python-using-list",
                "content": "```python\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.maxSize = maxSize\\n        self.stack = []\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:\\n            self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        return self.stack.pop() if self.stack else -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, len(self.stack))):\\n            self.stack[i] += val\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.maxSize = maxSize\\n        self.stack = []\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:\\n            self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        return self.stack.pop() if self.stack else -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, len(self.stack))):\\n            self.stack[i] += val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246010,
                "title": "java-using-array-easy-to-understand-beginner-friendly",
                "content": "```\\nclass CustomStack {\\n\\n    int stackArr[];\\n    \\n    int top;\\n    public CustomStack(int maxSize) {\\n        \\n        stackArr = new int[maxSize];\\n        top = -1;\\n    }\\n    \\n    public void push(int x) {\\n        \\n        if(top != stackArr.length -1)\\n        {\\n            top++;\\n            stackArr[top] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        \\n        if(top == -1)\\n            return -1;\\n        \\n        int ele = stackArr[top];\\n        top--;\\n        return ele;\\n            \\n    }\\n    \\n    public void increment(int k, int val) {\\n        int size = top +1;\\n       \\n        for(int level = 0 ; level < k ;level++)\\n        {\\n            \\n            if(level > top)\\n                break;\\n            \\n            stackArr[level] += val;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack {\\n\\n    int stackArr[];\\n    \\n    int top;\\n    public CustomStack(int maxSize) {\\n        \\n        stackArr = new int[maxSize];\\n        top = -1;\\n    }\\n    \\n    public void push(int x) {\\n        \\n        if(top != stackArr.length -1)\\n        {\\n            top++;\\n            stackArr[top] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        \\n        if(top == -1)\\n            return -1;\\n        \\n        int ele = stackArr[top];\\n        top--;\\n        return ele;\\n            \\n    }\\n    \\n    public void increment(int k, int val) {\\n        int size = top +1;\\n       \\n        for(int level = 0 ; level < k ;level++)\\n        {\\n            \\n            if(level > top)\\n                break;\\n            \\n            stackArr[level] += val;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171434,
                "title": "c-implementing-stack-using-array",
                "content": "```\\nclass CustomStack \\n{\\npublic:\\n    int arr[1000];\\n    int count = 0;\\n    int size = 0;\\n    \\n    CustomStack(int maxSize) \\n    {\\n        size = maxSize;\\n    }\\n    \\n    void push(int x) \\n    {\\n        if ( count < size ) \\n            arr[count++] = x;        \\n    }\\n    \\n    int pop() \\n    {\\n        if ( count > 0 )\\n            return arr[--count]; \\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) \\n    {\\n        for ( int i=0; i<min(k,count); i++) \\n            arr[i] += val;\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass CustomStack \\n{\\npublic:\\n    int arr[1000];\\n    int count = 0;\\n    int size = 0;\\n    \\n    CustomStack(int maxSize) \\n    {\\n        size = maxSize;\\n    }\\n    \\n    void push(int x) \\n    {\\n        if ( count < size ) \\n            arr[count++] = x;        \\n    }\\n    \\n    int pop() \\n    {\\n        if ( count > 0 )\\n            return arr[--count]; \\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) \\n    {\\n        for ( int i=0; i<min(k,count); i++) \\n            arr[i] += val;\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654733,
                "title": "java-solution-with-100-space-complexity-easy-to-understand",
                "content": "Here we have to keep track of no of elements in stack so i have used count variable which gives no of elements in stack at current time.\\n\\nAnd size variable will be used to check the maximum size of stack.\\n\\n```\\nclass CustomStack {\\n    Stack<Integer> stack;\\n    int size;\\n    int count = 0;\\n    \\n    public CustomStack(int maxSize) {\\n        stack = new Stack<>();\\n        this.size = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(count < size) {\\n            stack.push(x);\\n            count++;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(stack.empty())\\n            return -1;\\n        else {\\n            count--;\\n            return stack.pop();\\n        }\\n    }\\n    \\n    public void increment(int k, int val) {\\n\\t\\n\\t// If total no of elements is less than k then we have to increment all elements of stack.\\n\\t// else we have to increment from i=0 to i=k which are last k bottom elements of stack.\\n        if(count < k) {\\n            for(int i=0; i<count; i++) {\\n                stack.set(i, stack.get(i)+val);\\n            }\\n        } else {\\n            for(int i=0; i<k; i++)\\n                stack.set(i, stack.get(i)+val);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack {\\n    Stack<Integer> stack;\\n    int size;\\n    int count = 0;\\n    \\n    public CustomStack(int maxSize) {\\n        stack = new Stack<>();\\n        this.size = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(count < size) {\\n            stack.push(x);\\n            count++;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(stack.empty())\\n            return -1;\\n        else {\\n            count--;\\n            return stack.pop();\\n        }\\n    }\\n    \\n    public void increment(int k, int val) {\\n\\t\\n\\t// If total no of elements is less than k then we have to increment all elements of stack.\\n\\t// else we have to increment from i=0 to i=k which are last k bottom elements of stack.\\n        if(count < k) {\\n            for(int i=0; i<count; i++) {\\n                stack.set(i, stack.get(i)+val);\\n            }\\n        } else {\\n            for(int i=0; i<k; i++)\\n                stack.set(i, stack.get(i)+val);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 617516,
                "title": "java-solution-using-arra-100-of-memory",
                "content": "Easy to undertand \\n```\\nclass CustomStack {\\n\\t\\t\\n\\t\\tprivate int[] customStack;\\n\\t\\tprivate int position;\\n\\t\\t\\n\\t    public CustomStack(int maxSize) {\\n\\t        customStack = new int[maxSize];\\n\\t        position = 0;\\n\\t    }\\n\\t    \\n\\t    public void push(int x) {\\n\\t        if(position < customStack.length) {\\n\\t        \\tcustomStack[position] = x;\\n\\t        \\tposition++;\\n\\t        }\\n\\t    }\\n\\t    \\n\\t    public int pop() {\\n\\t    \\tint val = -1;\\n\\t    \\tif(position > 0) {\\n                position--;\\n\\t    \\t\\tval = customStack[position];\\n\\t    \\t\\tcustomStack[position] = 0;\\t    \\t\\t\\n\\t    \\t}\\n\\t    \\treturn val;\\n\\t    }\\n\\t    \\n\\t    public void increment(int k, int val) {\\n\\t        int i = 0;\\n\\t        while(i< Math.min(k, customStack.length)) {\\n\\t        \\tcustomStack[i++] += val;\\n\\t        }\\n\\t    }\\n\\t}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack {\\n\\t\\t\\n\\t\\tprivate int[] customStack;\\n\\t\\tprivate int position;\\n\\t\\t\\n\\t    public CustomStack(int maxSize) {\\n\\t        customStack = new int[maxSize];\\n\\t        position = 0;\\n\\t    }\\n\\t    \\n\\t    public void push(int x) {\\n\\t        if(position < customStack.length) {\\n\\t        \\tcustomStack[position] = x;\\n\\t        \\tposition++;\\n\\t        }\\n\\t    }\\n\\t    \\n\\t    public int pop() {\\n\\t    \\tint val = -1;\\n\\t    \\tif(position > 0) {\\n                position--;\\n\\t    \\t\\tval = customStack[position];\\n\\t    \\t\\tcustomStack[position] = 0;\\t    \\t\\t\\n\\t    \\t}\\n\\t    \\treturn val;\\n\\t    }\\n\\t    \\n\\t    public void increment(int k, int val) {\\n\\t        int i = 0;\\n\\t        while(i< Math.min(k, customStack.length)) {\\n\\t        \\tcustomStack[i++] += val;\\n\\t        }\\n\\t    }\\n\\t}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 578190,
                "title": "javascript-solution-with-array-as-stack",
                "content": "```\\n/**\\n * @param {number} maxSize\\n */\\nvar CustomStack = function (maxSize) {\\n  // set max size\\n  this.maxSize = maxSize;\\n\\n  // set initial size\\n  this.size = 0;\\n\\n  // stack\\n  this.stack = [];\\n};\\n\\n/**\\n * @param {number} x\\n * @return {void}\\n */\\nCustomStack.prototype.push = function (x) {\\n  // make sure we\\'re not at max size\\n  if (this.size !== this.maxSize) {\\n    // push as normal\\n    this.stack.push(x);\\n    // increment size\\n    this.size++;\\n  }\\n};\\n\\n/**\\n * @return {number}\\n */\\nCustomStack.prototype.pop = function () {\\n  // check if empty to return -1\\n  if (this.size === 0) {\\n    return -1;\\n  } else {\\n    // decrement size and return pop()\\n    this.size--;\\n    return this.stack.pop();\\n  }\\n};\\n\\n/**\\n * @param {number} k\\n * @param {number} val\\n * @return {void}\\n */\\nCustomStack.prototype.increment = function (k, val) {\\n  // iterate from 0 to k (or size since thats as far we can go)\\n  for (let i = 0; i < Math.min(k, this.size); i++) {\\n    // increment at this index\\n    this.stack[i] += val;\\n  }\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} maxSize\\n */\\nvar CustomStack = function (maxSize) {\\n  // set max size\\n  this.maxSize = maxSize;\\n\\n  // set initial size\\n  this.size = 0;\\n\\n  // stack\\n  this.stack = [];\\n};\\n\\n/**\\n * @param {number} x\\n * @return {void}\\n */\\nCustomStack.prototype.push = function (x) {\\n  // make sure we\\'re not at max size\\n  if (this.size !== this.maxSize) {\\n    // push as normal\\n    this.stack.push(x);\\n    // increment size\\n    this.size++;\\n  }\\n};\\n\\n/**\\n * @return {number}\\n */\\nCustomStack.prototype.pop = function () {\\n  // check if empty to return -1\\n  if (this.size === 0) {\\n    return -1;\\n  } else {\\n    // decrement size and return pop()\\n    this.size--;\\n    return this.stack.pop();\\n  }\\n};\\n\\n/**\\n * @param {number} k\\n * @param {number} val\\n * @return {void}\\n */\\nCustomStack.prototype.increment = function (k, val) {\\n  // iterate from 0 to k (or size since thats as far we can go)\\n  for (let i = 0; i < Math.min(k, this.size); i++) {\\n    // increment at this index\\n    this.stack[i] += val;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 555419,
                "title": "java-lazy-increment-push-pop-increment-o-1-5ms",
                "content": "```\\nclass CustomStack {\\n    private int[] arr;\\n    private int[] val;\\n    private int index;\\n    private int maxSize;\\n    public CustomStack(int maxSize) {\\n        this.maxSize=maxSize;\\n        arr=new int[maxSize];\\n        val=new int[maxSize];\\n        index=0;\\n    }\\n\\n    public void push(int x) {\\n        if(index==maxSize)\\n            return;\\n        arr[index]=x;\\n        index++;\\n    }\\n\\n    public int pop() {\\n        if(index==0)return -1;\\n        \\n        \\n        index--;\\n        \\n        if(val[index]==0){\\n            return arr[index];\\n        }else{\\n            int ans=arr[index]+val[index];\\n            if(index>0)\\n                val[index-1]+=val[index];\\n            val[index]=0;\\n            return ans;\\n        }\\n        \\n    }\\n\\n    public void increment(int k, int val) {\\n        if(index==0)\\n            return;\\n        if(k>index-1) {\\n            this.val[index-1] += val;\\n            return;\\n        }\\n        this.val[k-1]+=val;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n    private int[] arr;\\n    private int[] val;\\n    private int index;\\n    private int maxSize;\\n    public CustomStack(int maxSize) {\\n        this.maxSize=maxSize;\\n        arr=new int[maxSize];\\n        val=new int[maxSize];\\n        index=0;\\n    }\\n\\n    public void push(int x) {\\n        if(index==maxSize)\\n            return;\\n        arr[index]=x;\\n        index++;\\n    }\\n\\n    public int pop() {\\n        if(index==0)return -1;\\n        \\n        \\n        index--;\\n        \\n        if(val[index]==0){\\n            return arr[index];\\n        }else{\\n            int ans=arr[index]+val[index];\\n            if(index>0)\\n                val[index-1]+=val[index];\\n            val[index]=0;\\n            return ans;\\n        }\\n        \\n    }\\n\\n    public void increment(int k, int val) {\\n        if(index==0)\\n            return;\\n        if(k>index-1) {\\n            this.val[index-1] += val;\\n            return;\\n        }\\n        this.val[k-1]+=val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 540579,
                "title": "java-use-array-only-no-stack-all-o-1",
                "content": "All O(1) solution.\\n```java\\nclass CustomStack {\\n    int[] arr; // value\\n    int[] inc; // increment\\n    int index = -1;\\n    public CustomStack(int maxSize) {\\n        arr = new int[maxSize];\\n        inc = new int[maxSize];\\n    }\\n\\n    // O(1)\\n    public void push(int x) {\\n        if (index >= arr.length - 1) {\\n            return;\\n        }\\n        arr[++index] = x;\\n    }\\n\\n    // O(1)\\n    public int pop() {\\n        if (index < 0) {\\n            return -1;\\n        }\\n        if (index > 0) {\\n            inc[index - 1] += inc[index];\\n        }\\n        int val = arr[index] + inc[index];\\n        inc[index--] = 0;\\n        return val;\\n    }\\n\\n    // O(1)\\n    public void increment(int k, int val) {\\n        if (index < 0) {\\n            return;\\n        }\\n\\n        int i = Math.min(k, index + 1) - 1;\\n        if (i >= 0) {\\n            inc[i] += val;\\n        }\\n    }\\n}\\n```\\nBelow solution is easy to understand, but O(n) for increment.\\n```java\\npublic class CustomStack {\\n    int[] arr;\\n    int index = -1;\\n    public CustomStack(int maxSize) {\\n        arr = new int[maxSize];\\n    }\\n\\n    // O(1)\\n    public void push(int x) {\\n        if (index >= arr.length - 1) {\\n            return;\\n        }\\n        arr[++index] = x;\\n    }\\n\\n    // O(1)\\n    public int pop() {\\n        if (index < 0) {\\n            return -1;\\n        }\\n        return arr[index--];\\n    }\\n\\n    // O(n)\\n    public void increment(int k, int val) {\\n        if (index < 0) {\\n            return;\\n        }\\n        for (int i = 0; i < Math.min(k, index + 1); i++) {\\n            arr[i] += val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass CustomStack {\\n    int[] arr; // value\\n    int[] inc; // increment\\n    int index = -1;\\n    public CustomStack(int maxSize) {\\n        arr = new int[maxSize];\\n        inc = new int[maxSize];\\n    }\\n\\n    // O(1)\\n    public void push(int x) {\\n        if (index >= arr.length - 1) {\\n            return;\\n        }\\n        arr[++index] = x;\\n    }\\n\\n    // O(1)\\n    public int pop() {\\n        if (index < 0) {\\n            return -1;\\n        }\\n        if (index > 0) {\\n            inc[index - 1] += inc[index];\\n        }\\n        int val = arr[index] + inc[index];\\n        inc[index--] = 0;\\n        return val;\\n    }\\n\\n    // O(1)\\n    public void increment(int k, int val) {\\n        if (index < 0) {\\n            return;\\n        }\\n\\n        int i = Math.min(k, index + 1) - 1;\\n        if (i >= 0) {\\n            inc[i] += val;\\n        }\\n    }\\n}\\n```\n```java\\npublic class CustomStack {\\n    int[] arr;\\n    int index = -1;\\n    public CustomStack(int maxSize) {\\n        arr = new int[maxSize];\\n    }\\n\\n    // O(1)\\n    public void push(int x) {\\n        if (index >= arr.length - 1) {\\n            return;\\n        }\\n        arr[++index] = x;\\n    }\\n\\n    // O(1)\\n    public int pop() {\\n        if (index < 0) {\\n            return -1;\\n        }\\n        return arr[index--];\\n    }\\n\\n    // O(n)\\n    public void increment(int k, int val) {\\n        if (index < 0) {\\n            return;\\n        }\\n        for (int i = 0; i < Math.min(k, index + 1); i++) {\\n            arr[i] += val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 540166,
                "title": "javascript-lazy-increment-o-1-busy-increment-o-n",
                "content": "### Lazy increment\\n- Time Complexity: O(1)\\n- Space Complexity; O(N)\\n```JavaScript\\n/**\\n * @param {number} maxSize\\n */\\nvar CustomStack = function(maxSize) {\\n    this.stack = [];\\n    this.inc = new Array(maxSize).fill(0);\\n    this.size = maxSize;\\n};\\n\\n/** \\n * @param {number} x\\n * @return {void}\\n */\\nCustomStack.prototype.push = function(x) {\\n    if (this.stack.length < this.size) {\\n        this.stack.push(x);\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nCustomStack.prototype.pop = function() {\\n    if (this.stack.length) {\\n        const idx = this.stack.length - 1;\\n        const inc = this.inc[idx];\\n        if (idx - 1 >= 0) this.inc[idx - 1] += inc;\\n        this.inc[idx] = 0;\\n        return this.stack.pop() + inc;\\n    } else {\\n        return -1;\\n    }\\n};\\n\\n/** \\n * @param {number} k \\n * @param {number} val\\n * @return {void}\\n */\\nCustomStack.prototype.increment = function(k, val) {\\n    const idx = Math.min(k, this.stack.length ) - 1;\\n    this.inc[idx] += val;\\n};\\n```\\n\\n### Busy increment\\n- Time Complexity: O(N)\\n- Space Complexity; O(1) `it does not require extra space`\\n```JavaScript\\n/**\\n * @param {number} maxSize\\n */\\nvar CustomStack = function(maxSize) {\\n    this.stack = [];\\n    this.size = maxSize;\\n};\\n\\n/** \\n * @param {number} x\\n * @return {void}\\n */\\nCustomStack.prototype.push = function(x) {\\n    if (this.stack.length < this.size) {\\n        this.stack.push(x);\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nCustomStack.prototype.pop = function() {\\n    if (this.stack.length) {\\n        return this.stack.pop();\\n    } else {\\n        return -1;\\n    }\\n};\\n\\n/** \\n * @param {number} k \\n * @param {number} val\\n * @return {void}\\n */\\nCustomStack.prototype.increment = function(k, val) {\\n    for (let i = 0; i < Math.min(this.stack.length, k); i++) {\\n        this.stack[i] += val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JavaScript\\n/**\\n * @param {number} maxSize\\n */\\nvar CustomStack = function(maxSize) {\\n    this.stack = [];\\n    this.inc = new Array(maxSize).fill(0);\\n    this.size = maxSize;\\n};\\n\\n/** \\n * @param {number} x\\n * @return {void}\\n */\\nCustomStack.prototype.push = function(x) {\\n    if (this.stack.length < this.size) {\\n        this.stack.push(x);\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nCustomStack.prototype.pop = function() {\\n    if (this.stack.length) {\\n        const idx = this.stack.length - 1;\\n        const inc = this.inc[idx];\\n        if (idx - 1 >= 0) this.inc[idx - 1] += inc;\\n        this.inc[idx] = 0;\\n        return this.stack.pop() + inc;\\n    } else {\\n        return -1;\\n    }\\n};\\n\\n/** \\n * @param {number} k \\n * @param {number} val\\n * @return {void}\\n */\\nCustomStack.prototype.increment = function(k, val) {\\n    const idx = Math.min(k, this.stack.length ) - 1;\\n    this.inc[idx] += val;\\n};\\n```\n```JavaScript\\n/**\\n * @param {number} maxSize\\n */\\nvar CustomStack = function(maxSize) {\\n    this.stack = [];\\n    this.size = maxSize;\\n};\\n\\n/** \\n * @param {number} x\\n * @return {void}\\n */\\nCustomStack.prototype.push = function(x) {\\n    if (this.stack.length < this.size) {\\n        this.stack.push(x);\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nCustomStack.prototype.pop = function() {\\n    if (this.stack.length) {\\n        return this.stack.pop();\\n    } else {\\n        return -1;\\n    }\\n};\\n\\n/** \\n * @param {number} k \\n * @param {number} val\\n * @return {void}\\n */\\nCustomStack.prototype.increment = function(k, val) {\\n    for (let i = 0; i < Math.min(this.stack.length, k); i++) {\\n        this.stack[i] += val;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 539892,
                "title": "simple-solution-in-c",
                "content": "/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n \\n class CustomStack {\\n \\nprivate:\\n\\n    int maxi;\\n    int size;\\n    int s[1005];\\npublic:\\n\\n    CustomStack(int maxSize) {\\n        maxi=maxSize;\\n        size=0;\\n    }\\n    \\n    void push(int x) {\\n        if(size<maxi){\\n            s[size]=x;\\n            size++;           \\n        }\\n    }\\n    \\n    int pop() {\\n        if(size>0){\\n            size--;\\n            return s[size];\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        k=min(k,size+1);\\n        for(int i=0;i<k;i++){\\n            s[i]+=val;\\n        }\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n \\n class CustomStack {\\n \\nprivate:\\n\\n    int maxi;\\n    int size;\\n    int s[1005];\\npublic:\\n\\n    CustomStack(int maxSize) {\\n        maxi=maxSize;\\n        size=0;\\n    }\\n    \\n    void push(int x) {\\n        if(size<maxi){\\n            s[size]=x;\\n            size++;           \\n        }\\n    }\\n    \\n    int pop() {\\n        if(size>0){\\n            size--;\\n            return s[size];\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        k=min(k,size+1);\\n        for(int i=0;i<k;i++){\\n            s[i]+=val;\\n        }\\n    }\\n};\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 539773,
                "title": "java-using-stack",
                "content": "```\\nclass CustomStack {\\n    \\n    int maxSize;\\n    Stack<Integer> st;\\n\\n    public CustomStack(int maxSize) {\\n        this.st = new Stack<Integer>();\\n        this.maxSize = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(st.size()>=maxSize)return;\\n        st.push(x);\\n    }\\n    \\n    public int pop() {\\n        if(st.isEmpty())return -1;\\n        return st.pop();\\n    }\\n    \\n    public void increment(int k, int val) {\\n        Stack<Integer> util = new Stack<Integer>();\\n        int pass = st.size()-k;\\n        while(!st.isEmpty()){\\n            if(pass>0){\\n                pass--;\\n                util.push(st.pop());\\n            }else{\\n                int tmp = st.pop() + val;\\n                util.push(tmp);\\n            }\\n        }\\n        while(!util.isEmpty())st.push(util.pop());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack {\\n    \\n    int maxSize;\\n    Stack<Integer> st;\\n\\n    public CustomStack(int maxSize) {\\n        this.st = new Stack<Integer>();\\n        this.maxSize = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(st.size()>=maxSize)return;\\n        st.push(x);\\n    }\\n    \\n    public int pop() {\\n        if(st.isEmpty())return -1;\\n        return st.pop();\\n    }\\n    \\n    public void increment(int k, int val) {\\n        Stack<Integer> util = new Stack<Integer>();\\n        int pass = st.size()-k;\\n        while(!st.isEmpty()){\\n            if(pass>0){\\n                pass--;\\n                util.push(st.pop());\\n            }else{\\n                int tmp = st.pop() + val;\\n                util.push(tmp);\\n            }\\n        }\\n        while(!util.isEmpty())st.push(util.pop());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539755,
                "title": "python-cocnstant-solution",
                "content": "```\\nclass CustomStack:\\n    def __init__(self, maxSize: int):\\n        self.a = []\\n        self.msize = maxSize\\n        \\n    def push(self, x: int) -> None:\\n        if len(self.a) < self.msize:\\n            self.a.append([x, 0])\\n            \\n\\n    def pop(self) -> int:\\n        if not self.a: return -1\\n        ret, inc = self.a[-1]\\n        del self.a[-1]\\n        if self.a: self.a[-1][1] += inc\\n        return ret + inc\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if k == 0 or not self.a: return\\n        if k > len(self.a): k = len(self.a)\\n        self.a[k-1][1] += val \\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack:\\n    def __init__(self, maxSize: int):\\n        self.a = []\\n        self.msize = maxSize\\n        \\n    def push(self, x: int) -> None:\\n        if len(self.a) < self.msize:\\n            self.a.append([x, 0])\\n            \\n\\n    def pop(self) -> int:\\n        if not self.a: return -1\\n        ret, inc = self.a[-1]\\n        del self.a[-1]\\n        if self.a: self.a[-1][1] += inc\\n        return ret + inc\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if k == 0 or not self.a: return\\n        if k > len(self.a): k = len(self.a)\\n        self.a[k-1][1] += val \\n```",
                "codeTag": "Java"
            },
            {
                "id": 539730,
                "title": "java-using-linknode",
                "content": "```\\nclass CustomStack {\\n\\n    LinkNode head = null;\\n    int maxSize;\\n    int currentSize;\\n    \\n    public CustomStack(int maxSize) {\\n        this.maxSize = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(currentSize<maxSize) {\\n            if(head == null) {\\n                head = new LinkNode(x);\\n            } else {\\n                LinkNode node = new LinkNode(x);\\n                node.next = head;\\n                head = node;\\n            }\\n            currentSize++;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(currentSize == 0) return -1;\\n        int result = head.val;\\n        head = head.next;\\n        currentSize--;\\n        return result;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        if(currentSize != 0) {\\n            LinkNode frontNode = head;\\n            for(int i=0;i<k && frontNode != null;i++) {\\n                frontNode = frontNode.next;\\n            }\\n            LinkNode backNode = head;\\n            while(frontNode != null) {\\n                backNode = backNode.next;\\n                frontNode = frontNode.next;\\n            }\\n            while(backNode!=null) {\\n                backNode.val += val;\\n                backNode = backNode.next;\\n            }\\n        }\\n    }\\n}\\n\\nclass LinkNode {\\n    int val;\\n    LinkNode next;\\n    LinkNode(int val) {\\n        this.val = val;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n\\n    LinkNode head = null;\\n    int maxSize;\\n    int currentSize;\\n    \\n    public CustomStack(int maxSize) {\\n        this.maxSize = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(currentSize<maxSize) {\\n            if(head == null) {\\n                head = new LinkNode(x);\\n            } else {\\n                LinkNode node = new LinkNode(x);\\n                node.next = head;\\n                head = node;\\n            }\\n            currentSize++;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(currentSize == 0) return -1;\\n        int result = head.val;\\n        head = head.next;\\n        currentSize--;\\n        return result;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        if(currentSize != 0) {\\n            LinkNode frontNode = head;\\n            for(int i=0;i<k && frontNode != null;i++) {\\n                frontNode = frontNode.next;\\n            }\\n            LinkNode backNode = head;\\n            while(frontNode != null) {\\n                backNode = backNode.next;\\n                frontNode = frontNode.next;\\n            }\\n            while(backNode!=null) {\\n                backNode.val += val;\\n                backNode = backNode.next;\\n            }\\n        }\\n    }\\n}\\n\\nclass LinkNode {\\n    int val;\\n    LinkNode next;\\n    LinkNode(int val) {\\n        this.val = val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539682,
                "title": "c-use-deque",
                "content": "```cpp\\nclass CustomStack {\\npublic:\\n    // Space Complexity: O(n)\\n    deque<int> dq;\\n    int n;\\n    \\n    CustomStack(int maxSize) {\\n        // Time Complexity: O(1)\\n        n = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        // Time Complexity: O(1)\\n        if (dq.size() == n) return;\\n        dq.push_back(x);\\n    }\\n    \\n    int pop() {\\n        // Time Complexity: O(1)\\n        if (dq.empty()) return -1;\\n        int x = dq.back();\\n        dq.pop_back();\\n        return x;\\n    }\\n    \\n    void increment(int k, int val) {\\n        // Time Complexity: O(k)\\n        for (auto it = dq.begin(); it != (k > dq.size() ? dq.end() : dq.begin() + k); ++it)\\n            *it += val;\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n ```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```cpp\\nclass CustomStack {\\npublic:\\n    // Space Complexity: O(n)\\n    deque<int> dq;\\n    int n;\\n    \\n    CustomStack(int maxSize) {\\n        // Time Complexity: O(1)\\n        n = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        // Time Complexity: O(1)\\n        if (dq.size() == n) return;\\n        dq.push_back(x);\\n    }\\n    \\n    int pop() {\\n        // Time Complexity: O(1)\\n        if (dq.empty()) return -1;\\n        int x = dq.back();\\n        dq.pop_back();\\n        return x;\\n    }\\n    \\n    void increment(int k, int val) {\\n        // Time Complexity: O(k)\\n        for (auto it = dq.begin(); it != (k > dq.size() ? dq.end() : dq.begin() + k); ++it)\\n            *it += val;\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3972261,
                "title": "implementing-a-custom-stack-by-using-stack-ds",
                "content": "# Intuition\\nThe problem description is quite simple and requires implementing a **Stack DS** (data structure), that follows LIFO-schema.\\n\\n# Approach\\n1. inside `__init__` method store `maxSize` and `stack`\\n2. implement `push` and `pop` methods as regular stack methods\\n3. implement `increment` method, that increments in the range of `k` at each step current value by `val` \\n\\n# Complexity\\n- Time complexity: **O(n)** because of iterating inside `increment`\\n\\n- Space complexity: **O(k)** because of storing **exactly** `k`- elements\\n\\n# Code\\n```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.maxSize = maxSize\\n        self.stack = []        \\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:\\n            self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        return self.stack.pop() if self.stack else -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        j = min(k, len(self.stack))\\n\\n        for i in range(j):\\n            self.stack[i] += val\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.maxSize = maxSize\\n        self.stack = []        \\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:\\n            self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        return self.stack.pop() if self.stack else -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        j = min(k, len(self.stack))\\n\\n        for i in range(j):\\n            self.stack[i] += val\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647046,
                "title": "c-solution-to-design-a-stack-with-increment-operation-leetcode",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\npush(): O(1)\\npop(): O(1)\\nincrement(): O(k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(maxSize)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass CustomStack {\\npublic:\\n    int maxSize;\\n    stack<int> st;\\n    CustomStack(int maxSize) {\\n        this->maxSize=maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if((int)st.size()<maxSize)\\n        {\\n            st.push(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(!st.empty())\\n        {\\n            int ans=st.top();\\n            st.pop();\\n            return ans;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        stack<int> temp;\\n        int count=0;\\n        for(int i=0;!st.empty();i++)\\n        {\\n            temp.push(st.top());\\n            st.pop();\\n        }\\n        for(int i=0;i<k && !temp.empty();i++)\\n        {\\n            count++;\\n            st.push(temp.top()+val);\\n            temp.pop();\\n        }\\n        while(!temp.empty())\\n        {\\n            st.push(temp.top());\\n            temp.pop();\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    int maxSize;\\n    stack<int> st;\\n    CustomStack(int maxSize) {\\n        this->maxSize=maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if((int)st.size()<maxSize)\\n        {\\n            st.push(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(!st.empty())\\n        {\\n            int ans=st.top();\\n            st.pop();\\n            return ans;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        stack<int> temp;\\n        int count=0;\\n        for(int i=0;!st.empty();i++)\\n        {\\n            temp.push(st.top());\\n            st.pop();\\n        }\\n        for(int i=0;i<k && !temp.empty();i++)\\n        {\\n            count++;\\n            st.push(temp.top()+val);\\n            temp.pop();\\n        }\\n        while(!temp.empty())\\n        {\\n            st.push(temp.top());\\n            temp.pop();\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578936,
                "title": "beginners-approach",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass CustomStack {\\n    private int[] stack;\\n    private int currIndex;\\n    int maxSize;\\n    public CustomStack(int maxSize) {\\n        this.currIndex=0;\\n        this.stack= new int[maxSize];\\n        this.maxSize= maxSize;\\n        \\n    }\\n    \\n    public void push(int x) {\\n        if(currIndex< maxSize) stack[currIndex++]=x;\\n        \\n    }\\n    \\n    public int pop() {\\n        if(currIndex ==0) return -1;\\n        else return stack[--currIndex];\\n        \\n    }\\n    \\n    public void increment(int k, int val) {\\n        int n= Math.min(currIndex, k);\\n        for(int i=0;i<n;i++){\\n            stack[i]+=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack {\\n    private int[] stack;\\n    private int currIndex;\\n    int maxSize;\\n    public CustomStack(int maxSize) {\\n        this.currIndex=0;\\n        this.stack= new int[maxSize];\\n        this.maxSize= maxSize;\\n        \\n    }\\n    \\n    public void push(int x) {\\n        if(currIndex< maxSize) stack[currIndex++]=x;\\n        \\n    }\\n    \\n    public int pop() {\\n        if(currIndex ==0) return -1;\\n        else return stack[--currIndex];\\n        \\n    }\\n    \\n    public void increment(int k, int val) {\\n        int n= Math.min(currIndex, k);\\n        for(int i=0;i<n;i++){\\n            stack[i]+=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548414,
                "title": "c-easy-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass CustomStack {\\npublic:\\n    vector<int> st;\\n    int ms ;\\n    int curr;\\n    CustomStack(int maxSize) {\\n        ms = maxSize;\\n        st.resize(ms,-1);\\n        curr = 0;\\n    }\\n    \\n    void push(int x) {\\n        if(curr == ms){\\n            return;\\n        }\\n\\n        st[curr] = x;\\n        // cout << curr << endl;\\n        curr++;\\n    }\\n    \\n    int pop() {\\n        if(curr == 0){\\n            return -1;\\n        }\\n        // cout << curr << endl;\\n\\n        int k = st[curr-1];\\n        st[curr-1] = -1;\\n        curr--;\\n        return k;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int n = min(curr,k);\\n        for(int i=0;i<n;i++){\\n            st[i] += val;\\n        }\\n        return;\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    vector<int> st;\\n    int ms ;\\n    int curr;\\n    CustomStack(int maxSize) {\\n        ms = maxSize;\\n        st.resize(ms,-1);\\n        curr = 0;\\n    }\\n    \\n    void push(int x) {\\n        if(curr == ms){\\n            return;\\n        }\\n\\n        st[curr] = x;\\n        // cout << curr << endl;\\n        curr++;\\n    }\\n    \\n    int pop() {\\n        if(curr == 0){\\n            return -1;\\n        }\\n        // cout << curr << endl;\\n\\n        int k = st[curr-1];\\n        st[curr-1] = -1;\\n        curr--;\\n        return k;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int n = min(curr,k);\\n        for(int i=0;i<n;i++){\\n            st[i] += val;\\n        }\\n        return;\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3276947,
                "title": "java-easy-optimized-explained",
                "content": "# Intuition\\nHere, we will be using **Array** for better optimization. We will create a array of given maxSize and we will keep a **Ptr** to update our values in array. Based on two conditon of k we will update the values in array.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass CustomStack {\\n    int[] data;\\n    int ptr=0;\\n    int max;\\n    public CustomStack(int maxSize) {\\n        this.data =new int[maxSize];\\n        this.max=maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(ptr==data.length) return;\\n        data[ptr++]=x;\\n    }\\n    \\n    public int pop() {\\n        if(ptr==0){\\n            return -1;\\n        }\\n        return data[--ptr];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        if(k>ptr){\\n            for(int i=0 ;i<max ; i++){\\n                data[i]=data[i]+val;\\n            }\\n        }else{\\n            for(int i=0; i<k ;i++){\\n                data[i]=data[i]+val;\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack",
                    "Design"
                ],
                "code": "```\\nclass CustomStack {\\n    int[] data;\\n    int ptr=0;\\n    int max;\\n    public CustomStack(int maxSize) {\\n        this.data =new int[maxSize];\\n        this.max=maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(ptr==data.length) return;\\n        data[ptr++]=x;\\n    }\\n    \\n    public int pop() {\\n        if(ptr==0){\\n            return -1;\\n        }\\n        return data[--ptr];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        if(k>ptr){\\n            for(int i=0 ;i<max ; i++){\\n                data[i]=data[i]+val;\\n            }\\n        }else{\\n            for(int i=0; i<k ;i++){\\n                data[i]=data[i]+val;\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089313,
                "title": "stack-with-top-and-maxsize",
                "content": "# Upvote it :)\\n```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.arr = []\\n        self.m = maxSize\\n        self.top = -1\\n\\n    def push(self, x: int) -> None:\\n        if self.top < self.m - 1:\\n            self.arr.append(x)\\n            self.top += 1\\n\\n    def pop(self) -> int:\\n        if self.top == -1: return -1\\n        self.top -= 1\\n        return(self.arr.pop(-1))\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, self.top + 1)): self.arr[i] += val\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.arr = []\\n        self.m = maxSize\\n        self.top = -1\\n\\n    def push(self, x: int) -> None:\\n        if self.top < self.m - 1:\\n            self.arr.append(x)\\n            self.top += 1\\n\\n    def pop(self) -> int:\\n        if self.top == -1: return -1\\n        self.top -= 1\\n        return(self.arr.pop(-1))\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, self.top + 1)): self.arr[i] += val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053991,
                "title": "c-two-stack-solution",
                "content": "\\n### Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass CustomStack {\\npublic:\\n    stack<int> st;\\n    int size;\\n\\n    CustomStack(int maxSize) {\\n        size = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(st.size() == size) return;\\n        st.push(x);\\n    }\\n    \\n    int pop() {\\n        if(st.size() == 0) return -1;\\n        int val = st.top();\\n        st.pop();\\n        return val;\\n    }\\n    \\n    void increment(int k, int val) {. // Time Complexity -> O(st.size())\\n        stack<int> st0;\\n        while(!st.empty()) {\\n            st0.push(st.top());\\n            st.pop();\\n        }\\n        while(!st0.empty() && k--) {\\n            st.push(st0.top() + val);\\n            st0.pop();\\n        }\\n        while(!st0.empty()) {\\n            st.push(st0.top());\\n            st0.pop();\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    stack<int> st;\\n    int size;\\n\\n    CustomStack(int maxSize) {\\n        size = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(st.size() == size) return;\\n        st.push(x);\\n    }\\n    \\n    int pop() {\\n        if(st.size() == 0) return -1;\\n        int val = st.top();\\n        st.pop();\\n        return val;\\n    }\\n    \\n    void increment(int k, int val) {. // Time Complexity -> O(st.size())\\n        stack<int> st0;\\n        while(!st.empty()) {\\n            st0.push(st.top());\\n            st.pop();\\n        }\\n        while(!st0.empty() && k--) {\\n            st.push(st0.top() + val);\\n            st0.pop();\\n        }\\n        while(!st0.empty()) {\\n            st.push(st0.top());\\n            st0.pop();\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008786,
                "title": "very-easy-to-understand-solution-with-a-details",
                "content": "### Intuition\\n- First of all I think I need array and one varieble that equal max size. So I assigned `self.arr` equal empty and `self.max` inside `__init__ `function.\\n\\n### Approach\\n- To solve this problem we only need to write a few lines.\\n    1. Inside `push` function we need to append a new variable to our `self.arr` but we must check `length` of our array because we can capable to add `self.max` elements. So our `push` function can be this kind of:\\n        ```\\n        if len(self.arr)<self.max: self.arr.append(x)\\n        ```\\n    2. Inside `pop` function we need to `pop` an element from the array and before doing that we need to know there is an element inside our array. Instead of checking there is an element in array we can simply use `try` and `except` function for this purpose. So our `pop` function can be this kind of:\\n        ```\\n        try: return self.arr.pop()\\n        except: return -1\\n        ```\\n    3. Inside last `increment` function we need to increment `self.arr[0]` to `self.arr[k]` or `self.arr[-1]` because if length of arr id less thank k we need to stop our loop on the last element of the array. That means we need to identify `minimum` these two of them and then we need to use for loop to increment every single element that we need to increment. So our `increment` function can be this kind of:\\n        ```\\n        for i in range(min(k, len(self.arr))): self.arr[i]+=val\\n        ```\\n### Code\\n```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.arr = []\\n        self.max = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.arr)<self.max: self.arr.append(x)\\n\\n    def pop(self) -> int:\\n        try: return self.arr.pop()\\n        except: return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, len(self.arr))): self.arr[i]+=val\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        if len(self.arr)<self.max: self.arr.append(x)\\n        ```\n```\\n        try: return self.arr.pop()\\n        except: return -1\\n        ```\n```\\n        for i in range(min(k, len(self.arr))): self.arr[i]+=val\\n        ```\n```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.arr = []\\n        self.max = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.arr)<self.max: self.arr.append(x)\\n\\n    def pop(self) -> int:\\n        try: return self.arr.pop()\\n        except: return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, len(self.arr))): self.arr[i]+=val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882609,
                "title": "100-runtime-beats-96-memory-beats-java",
                "content": "- 34/34 cases passed (4 ms)\\n- Your runtime beats 100 % of java submissions\\n- Your memory usage beats 96.05 % of java submissions (42.8 MB)\\n\\n# Code\\n```\\nclass CustomStack {\\n\\n    int[] out;\\n    int i=-1,z;\\n\\n    public CustomStack(int maxSize) {\\n        out=new int[maxSize];\\n        z=maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(i<z-1)\\n            out[++i]=x;\\n    }\\n    \\n    public int pop() {\\n        if(i>-1)\\n            return out[i--];\\n        return -1;\\n        \\n    }\\n    \\n    public void increment(int k, int val) {\\n\\n        for(int j=0;j<(k>i?i+1:k);j++)\\n            out[j]+=val;\\n        \\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack {\\n\\n    int[] out;\\n    int i=-1,z;\\n\\n    public CustomStack(int maxSize) {\\n        out=new int[maxSize];\\n        z=maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(i<z-1)\\n            out[++i]=x;\\n    }\\n    \\n    public int pop() {\\n        if(i>-1)\\n            return out[i--];\\n        return -1;\\n        \\n    }\\n    \\n    public void increment(int k, int val) {\\n\\n        for(int j=0;j<(k>i?i+1:k);j++)\\n            out[j]+=val;\\n        \\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598190,
                "title": "easy-java-code-damn-easy",
                "content": "```\\n// code by- SATYARTH \\n// upvote if u like my code\\nclass CustomStack {\\n    int stackArray[];   // stack using array\\n    int top;            // top pointer\\n\\n    public CustomStack(int maxSize) { // constructor will help to initialize the array and top pointer\\n        stackArray=new int[maxSize];\\n        \\n        top=-1;         // as index starts from 0, so we will point the stackArray from -1\\n    }\\n    \\n    public void push(int x) {\\n        // overflow condition : means u can\\'t add more elements to it \\n        if(top == (stackArray.length-1)){\\n            return; \\n        }\\n        \\n       else{\\n           top+=1;   // each time we have to update the pointer to add the element at the top\\n           stackArray[top]=x;  // add the element at the top \\n       }\\n        \\n        \\n    }\\n    \\n    public int pop() { \\n        // underflow condition : means stack is empty \\n        if(top== -1){\\n            return -1;\\n        }\\n        \\n        int del=stackArray[top]; // storing the top value of stack \\n        \\n        top--; // reducing the top pointer to next top element after deletion \\n        \\n        return del;     \\n        \\n    }\\n    \\n    public void increment(int k, int val) {\\n        \\n     // the following block can be optimised :- but its simple to understand and my code works with stack property,not with array operations i.e.  top to bottom \\n        \\n        // first check :if k is greater the stack size \\n        if((top+1)<k ){\\n            int temp=top;  // storing top in temporary variable so that top won\\'t be affected\\n            while(temp!=-1){\\n                stackArray[temp]+=val;\\n                temp--;\\n            }\\n            \\n        }\\n        // second : if stack size is greater than k\\n        else{\\n            \\n            int temp=top -((top+1)-k);  \\n            //ex:- stack size = 5 then top = 4 and let k=3 then elements to be increased from index 2 to 0\\n            // temp = 4 - ((4+1)-3) = 4-2=2 , see we reached at 2 , now decrease temp and update the value \\n            \\n            while(temp!=-1){\\n                stackArray[temp]+=val;\\n                temp--;\\n            }\\n        }\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "```\\n// code by- SATYARTH \\n// upvote if u like my code\\nclass CustomStack {\\n    int stackArray[];   // stack using array\\n    int top;            // top pointer\\n\\n    public CustomStack(int maxSize) { // constructor will help to initialize the array and top pointer\\n        stackArray=new int[maxSize];\\n        \\n        top=-1;         // as index starts from 0, so we will point the stackArray from -1\\n    }\\n    \\n    public void push(int x) {\\n        // overflow condition : means u can\\'t add more elements to it \\n        if(top == (stackArray.length-1)){\\n            return; \\n        }\\n        \\n       else{\\n           top+=1;   // each time we have to update the pointer to add the element at the top\\n           stackArray[top]=x;  // add the element at the top \\n       }\\n        \\n        \\n    }\\n    \\n    public int pop() { \\n        // underflow condition : means stack is empty \\n        if(top== -1){\\n            return -1;\\n        }\\n        \\n        int del=stackArray[top]; // storing the top value of stack \\n        \\n        top--; // reducing the top pointer to next top element after deletion \\n        \\n        return del;     \\n        \\n    }\\n    \\n    public void increment(int k, int val) {\\n        \\n     // the following block can be optimised :- but its simple to understand and my code works with stack property,not with array operations i.e.  top to bottom \\n        \\n        // first check :if k is greater the stack size \\n        if((top+1)<k ){\\n            int temp=top;  // storing top in temporary variable so that top won\\'t be affected\\n            while(temp!=-1){\\n                stackArray[temp]+=val;\\n                temp--;\\n            }\\n            \\n        }\\n        // second : if stack size is greater than k\\n        else{\\n            \\n            int temp=top -((top+1)-k);  \\n            //ex:- stack size = 5 then top = 4 and let k=3 then elements to be increased from index 2 to 0\\n            // temp = 4 - ((4+1)-3) = 4-2=2 , see we reached at 2 , now decrease temp and update the value \\n            \\n            while(temp!=-1){\\n                stackArray[temp]+=val;\\n                temp--;\\n            }\\n        }\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574383,
                "title": "simple-array-implementation",
                "content": "```\\nclass CustomStack {\\n    int arr[], top =-1, maxSize ;    \\n    public CustomStack(int maxSize) {\\n        this.maxSize = maxSize;\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {        \\n        if(top< maxSize-1)\\n            arr[++top] = x;\\n    }\\n    \\n    public int pop() {\\n        if(top!= -1){\\n            int val = arr[top--];            \\n            return val;\\n        }\\n        return -1;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        \\n        if(top!= -1){\\n            if( k <= top){\\n                for(int i=0;i<k;++i)  arr[i]+= val;\\n            }\\n            else{\\n                for(int i=0;i<=top;++i)  arr[i]+= val;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack",
                    "Design"
                ],
                "code": "```\\nclass CustomStack {\\n    int arr[], top =-1, maxSize ;    \\n    public CustomStack(int maxSize) {\\n        this.maxSize = maxSize;\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {        \\n        if(top< maxSize-1)\\n            arr[++top] = x;\\n    }\\n    \\n    public int pop() {\\n        if(top!= -1){\\n            int val = arr[top--];            \\n            return val;\\n        }\\n        return -1;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        \\n        if(top!= -1){\\n            if( k <= top){\\n                for(int i=0;i<k;++i)  arr[i]+= val;\\n            }\\n            else{\\n                for(int i=0;i<=top;++i)  arr[i]+= val;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2407992,
                "title": "c-easy-approach-using-dynamic-array-stack",
                "content": "```\\nclass CustomStack {\\npublic:\\n    int *arr;\\n    int size;\\n    int csize;\\n    CustomStack(int maxSize) {\\n       size=maxSize;\\n        arr=new int[size];\\n        csize=-1;\\n    }\\n    \\n    void push(int x) {\\n        if(csize<size-1)\\n        {   csize++;\\n           arr[csize]=x;\\n            \\n        }\\n    }\\n    \\n    int pop() {\\n        if(csize==-1)\\n        {\\n            return -1;\\n        }\\n        return arr[csize--];\\n    }\\n    \\n    void increment(int k, int val) {\\n        for(int i=0;i<k&&i<=csize;i++)\\n        {\\n            arr[i]=arr[i]+val;\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    int *arr;\\n    int size;\\n    int csize;\\n    CustomStack(int maxSize) {\\n       size=maxSize;\\n        arr=new int[size];\\n        csize=-1;\\n    }\\n    \\n    void push(int x) {\\n        if(csize<size-1)\\n        {   csize++;\\n           arr[csize]=x;\\n            \\n        }\\n    }\\n    \\n    int pop() {\\n        if(csize==-1)\\n        {\\n            return -1;\\n        }\\n        return arr[csize--];\\n    }\\n    \\n    void increment(int k, int val) {\\n        for(int i=0;i<k&&i<=csize;i++)\\n        {\\n            arr[i]=arr[i]+val;\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366157,
                "title": "java-array-implementation",
                "content": "```\\nclass CustomStack {\\n    int cap;\\n    int[] arr;\\n    int head;\\n    public CustomStack(int maxSize) {\\n        this.cap=maxSize;\\n        this.arr=new int[maxSize];\\n        this.head=-1;\\n    }\\n    \\n    public void push(int x) {\\n        if(this.head==cap-1) return;\\n        this.head++;\\n        this.arr[this.head]=x;\\n    }\\n    \\n    public int pop() {\\n        if(this.head==-1) return -1;\\n        int res=this.arr[this.head];\\n        this.head--;\\n        return res;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i=0; i<Math.min(cap,k); i++){\\n            this.arr[i]+=val;\\n        }\\n        \\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n    int cap;\\n    int[] arr;\\n    int head;\\n    public CustomStack(int maxSize) {\\n        this.cap=maxSize;\\n        this.arr=new int[maxSize];\\n        this.head=-1;\\n    }\\n    \\n    public void push(int x) {\\n        if(this.head==cap-1) return;\\n        this.head++;\\n        this.arr[this.head]=x;\\n    }\\n    \\n    public int pop() {\\n        if(this.head==-1) return -1;\\n        int res=this.arr[this.head];\\n        this.head--;\\n        return res;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i=0; i<Math.min(cap,k); i++){\\n            this.arr[i]+=val;\\n        }\\n        \\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323949,
                "title": "c-solution-easy-to-understand-list",
                "content": "```C#\\npublic class CustomStack {\\n    private readonly List<int> _l;\\n    private readonly int _maxSize;\\n    \\n    private int _size = 0;\\n    public CustomStack(int maxSize) {\\n        this._l = new (capacity: maxSize);\\n        this._maxSize = maxSize;\\n    }\\n    \\n    public void Push(int x) {\\n        if (this._size < this._maxSize) {\\n            this._l.Insert(this._size, x);\\n            this._size++;\\n        }\\n    }\\n    \\n    public int Pop() {\\n        if (this._size == 0) return -1;\\n        \\n        this._size--;\\n        return this._l[this._size];\\n    }\\n    \\n    public void Increment(int k, int val) {\\n        int end = Math.Min(this._size, k);\\n        for (int i = 0; i < end; i++) this._l[i] += val;\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.Push(x);\\n * int param_2 = obj.Pop();\\n * obj.Increment(k,val);\\n */\\n ```",
                "solutionTags": [],
                "code": "```C#\\npublic class CustomStack {\\n    private readonly List<int> _l;\\n    private readonly int _maxSize;\\n    \\n    private int _size = 0;\\n    public CustomStack(int maxSize) {\\n        this._l = new (capacity: maxSize);\\n        this._maxSize = maxSize;\\n    }\\n    \\n    public void Push(int x) {\\n        if (this._size < this._maxSize) {\\n            this._l.Insert(this._size, x);\\n            this._size++;\\n        }\\n    }\\n    \\n    public int Pop() {\\n        if (this._size == 0) return -1;\\n        \\n        this._size--;\\n        return this._l[this._size];\\n    }\\n    \\n    public void Increment(int k, int val) {\\n        int end = Math.Min(this._size, k);\\n        for (int i = 0; i < end; i++) this._l[i] += val;\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.Push(x);\\n * int param_2 = obj.Pop();\\n * obj.Increment(k,val);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2312741,
                "title": "c-stack-medium-beginner-friendly",
                "content": "class CustomStack {\\npublic:\\n    int max;\\n    vector<int>v;\\n    CustomStack(int maxSize) {\\n        max=maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(v.size()<max){\\n            v.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(v.size()==0){\\n            return -1;\\n        }\\n        int x=v.back();\\n        v.pop_back();\\n        return x;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int x=k;\\n        if(v.size()<k){\\n            x=v.size();\\n        }\\n        for(int i=0;i<x;i++){\\n            v[i]+=val;\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n \\n if it helps plz dont forget to upvote it :)",
                "solutionTags": [
                    "Array",
                    "Stack"
                ],
                "code": "class CustomStack {\\npublic:\\n    int max;\\n    vector<int>v;\\n    CustomStack(int maxSize) {\\n        max=maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(v.size()<max){\\n            v.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(v.size()==0){\\n            return -1;\\n        }\\n        int x=v.back();\\n        v.pop_back();\\n        return x;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int x=k;\\n        if(v.size()<k){\\n            x=v.size();\\n        }\\n        for(int i=0;i<x;i++){\\n            v[i]+=val;\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n \\n if it helps plz dont forget to upvote it :)",
                "codeTag": "Java"
            },
            {
                "id": 2296300,
                "title": "java-stack-easy-explanation-with-comments",
                "content": "```\\nclass CustomStack {\\n\\n    // Make value array where we can push and pop value.\\n    int value[];\\n    // Make increment array to implememt our logic.\\n    int increment[];\\n    // Index use to store element.\\n    int index;\\n    public CustomStack(int maxSize) {\\n        // Initailize it to max Size.\\n        value = new int[maxSize];\\n        // Initailize it to max Size.\\n        increment = new int[maxSize];\\n        //At first make index point to -1.\\n        index = -1;\\n    }\\n    \\n    public void push(int x) {\\n        // Before pushing first check if it is already filled completely just simply return.\\n        if(index + 1 == value.length)\\n        {\\n            return;\\n        }\\n        index++;\\n        value[index] = x;\\n        //It shows incrememt regarding this value is equal to zero.\\n        increment[index] = 0;\\n        \\n        \\n        \\n    }\\n    \\n    public int pop() {\\n        //Before popping check if stack is already empty.\\n        if(index == -1)\\n        {\\n            return index;\\n        }\\n        // Here we are storing the popped value.\\n        int x = value[index];\\n        // Here we are storing the corresponding increment of popped value.\\n        int increased = increment[index];\\n        // And we decrease index value.\\n        index--;\\n        \\n//     | 4  | \\n//     | 3  |\\n//     | 2  |\\n//     | 1  |\\n//     |____|\\n\\n// Increment of (4,100)\\n\\n//4    |100 |\\n//3    | 0  |\\n//2    | 0  |\\n//1    | 0  |\\n//     |____|\\n        \\n        //When we pop element from stack we will shift it inc val to below ele\\n        \\n// 4   |100 |\\n// 3   |100 |\\n// 2   | 0  |\\n// 1   | 0  |\\n//     |____|\\n        \\n        // It will continue until 1.\\n        \\n        if(index>=0)\\n        {\\n            increment[index]+=increased;\\n        }\\n        // Now return popped element + increased value;\\n        return x + increased;\\n    }\\n    \\n    public void increment(int k, int val) {\\n       \\n        // If k = 4 we need to put increme red val on 3 because of 0 based indexing.\\n        // Lets suppose if k = 5 but we have only 3 elements so we will take 3\\n        \\n        int ind = Math.min(k-1,index);\\n        //If index is -1 and k - 1 = 0.It will take index as min val which is -1.\\n        //But -1 is not a valid index.So we have to check is there any element present in             stack or not\\n        \\n        if(index >=0)\\n        {\\n            //Update increment array value.\\n            increment[ind]+=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack {\\n\\n    // Make value array where we can push and pop value.\\n    int value[];\\n    // Make increment array to implememt our logic.\\n    int increment[];\\n    // Index use to store element.\\n    int index;\\n    public CustomStack(int maxSize) {\\n        // Initailize it to max Size.\\n        value = new int[maxSize];\\n        // Initailize it to max Size.\\n        increment = new int[maxSize];\\n        //At first make index point to -1.\\n        index = -1;\\n    }\\n    \\n    public void push(int x) {\\n        // Before pushing first check if it is already filled completely just simply return.\\n        if(index + 1 == value.length)\\n        {\\n            return;\\n        }\\n        index++;\\n        value[index] = x;\\n        //It shows incrememt regarding this value is equal to zero.\\n        increment[index] = 0;\\n        \\n        \\n        \\n    }\\n    \\n    public int pop() {\\n        //Before popping check if stack is already empty.\\n        if(index == -1)\\n        {\\n            return index;\\n        }\\n        // Here we are storing the popped value.\\n        int x = value[index];\\n        // Here we are storing the corresponding increment of popped value.\\n        int increased = increment[index];\\n        // And we decrease index value.\\n        index--;\\n        \\n//     | 4  | \\n//     | 3  |\\n//     | 2  |\\n//     | 1  |\\n//     |____|\\n\\n// Increment of (4,100)\\n\\n//4    |100 |\\n//3    | 0  |\\n//2    | 0  |\\n//1    | 0  |\\n//     |____|\\n        \\n        //When we pop element from stack we will shift it inc val to below ele\\n        \\n// 4   |100 |\\n// 3   |100 |\\n// 2   | 0  |\\n// 1   | 0  |\\n//     |____|\\n        \\n        // It will continue until 1.\\n        \\n        if(index>=0)\\n        {\\n            increment[index]+=increased;\\n        }\\n        // Now return popped element + increased value;\\n        return x + increased;\\n    }\\n    \\n    public void increment(int k, int val) {\\n       \\n        // If k = 4 we need to put increme red val on 3 because of 0 based indexing.\\n        // Lets suppose if k = 5 but we have only 3 elements so we will take 3\\n        \\n        int ind = Math.min(k-1,index);\\n        //If index is -1 and k - 1 = 0.It will take index as min val which is -1.\\n        //But -1 is not a valid index.So we have to check is there any element present in             stack or not\\n        \\n        if(index >=0)\\n        {\\n            //Update increment array value.\\n            increment[ind]+=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230083,
                "title": "c-o-1-all-operations-small-easy-code",
                "content": "```\\nclass CustomStack {\\npublic:\\n    stack<int> s;\\n    vector<int> add;\\n    \\n    CustomStack(int maxSize) {\\n        add.resize(maxSize, 0);\\n    }\\n    \\n    void push(int x) {\\n        if ((int)s.size() == (int)add.size()) return;\\n        s.push(x);\\n    }\\n    \\n    int pop() {\\n        if (s.empty()) return -1;\\n        int sze = s.size();\\n        int res = s.top() + add[sze - 1];\\n        if (sze >= 2) {\\n            add[sze - 2] += add[sze - 1];\\n        }\\n        add[sze - 1] = 0;\\n        s.pop();\\n        return res;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if (s.empty()) return;\\n        int sze = s.size();\\n        add[min(sze, k) - 1] += val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    stack<int> s;\\n    vector<int> add;\\n    \\n    CustomStack(int maxSize) {\\n        add.resize(maxSize, 0);\\n    }\\n    \\n    void push(int x) {\\n        if ((int)s.size() == (int)add.size()) return;\\n        s.push(x);\\n    }\\n    \\n    int pop() {\\n        if (s.empty()) return -1;\\n        int sze = s.size();\\n        int res = s.top() + add[sze - 1];\\n        if (sze >= 2) {\\n            add[sze - 2] += add[sze - 1];\\n        }\\n        add[sze - 1] = 0;\\n        s.pop();\\n        return res;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if (s.empty()) return;\\n        int sze = s.size();\\n        add[min(sze, k) - 1] += val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186251,
                "title": "python-o-1-on-all-operations-by-lazy",
                "content": "I feel there is a point of design when it comes to increment as it can be realized in O(1) instead of O(k) just by adding another list.\\n\\nSince in a stack, we will only access the top element, the increment to the below elements can be delayed until needed.\\n\\nWe keep a additional list to keep track of increment needed at exactly this index AND below. When the element is popped, calculate the increment on the fly and pass on the increment.\\n\\n```\\nclass CustomStack:\\n    def __init__(self, maxSize: int):\\n        self.l = 0\\n        self.data = [0] * maxSize\\n        self.maxSize = maxSize\\n        self.inc = [0] * maxSize\\n\\n    def push(self, x: int) -> None:\\n        if self.l >= self.maxSize:\\n            return\\n        \\n        self.data[self.l] = x\\n        self.inc[self.l] = 0\\n        self.l += 1\\n\\n    def pop(self) -> int:\\n        if self.l <= 0:\\n            return -1\\n        self.l -= 1\\n        inc = self.inc[self.l]\\n        if self.l - 1 >= 0:\\n            self.inc[self.l - 1] += inc\\n        return self.data[self.l] + inc\\n\\n    def increment(self, k: int, val: int) -> None:\\n        self.inc[min(k, self.l)-1] += val\\n```\\nIt doesn\\'t end up fast on the test case pool probably due to its overhead of additional list. However complexity wise, it\\'s a non-trivial difference.",
                "solutionTags": [],
                "code": "```\\nclass CustomStack:\\n    def __init__(self, maxSize: int):\\n        self.l = 0\\n        self.data = [0] * maxSize\\n        self.maxSize = maxSize\\n        self.inc = [0] * maxSize\\n\\n    def push(self, x: int) -> None:\\n        if self.l >= self.maxSize:\\n            return\\n        \\n        self.data[self.l] = x\\n        self.inc[self.l] = 0\\n        self.l += 1\\n\\n    def pop(self) -> int:\\n        if self.l <= 0:\\n            return -1\\n        self.l -= 1\\n        inc = self.inc[self.l]\\n        if self.l - 1 >= 0:\\n            self.inc[self.l - 1] += inc\\n        return self.data[self.l] + inc\\n\\n    def increment(self, k: int, val: int) -> None:\\n        self.inc[min(k, self.l)-1] += val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078665,
                "title": "simple-straight-forward-approach",
                "content": "Solution time is O(n) or O(k) depending upon test cases.\\n\\n```\\nclass CustomStack:\\n    # Solution O(k) or O(n).\\n    def __init__(self, maxSize: int):\\n        self.n = maxSize\\n        self.stack = []\\n        self.inc = []\\n\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.n:\\n            self.stack.append(x)\\n            self.inc.append(0) \\n        \\n    def pop(self) -> int:\\n        if len(self.inc) == 0:\\n            return -1\\n        else:\\n            return self.stack.pop() + self.inc.pop()\\n        \\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k,len(self.inc))):\\n            self.inc[i] += val\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack:\\n    # Solution O(k) or O(n).\\n    def __init__(self, maxSize: int):\\n        self.n = maxSize\\n        self.stack = []\\n        self.inc = []\\n\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.n:\\n            self.stack.append(x)\\n            self.inc.append(0) \\n        \\n    def pop(self) -> int:\\n        if len(self.inc) == 0:\\n            return -1\\n        else:\\n            return self.stack.pop() + self.inc.pop()\\n        \\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k,len(self.inc))):\\n            self.inc[i] += val\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043741,
                "title": "java-design",
                "content": "```\\nclass CustomStack {\\n    int size;\\n    int[] arr;\\n    int top;\\n    \\n    public CustomStack(int maxSize) {\\n        this.size = maxSize;\\n        this.arr = new int[maxSize];\\n        this.top = -1;\\n    }\\n    \\n    public void push(int x) {\\n        if(size - top > 1) {\\n            top++;\\n            arr[top] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if (top != -1) {\\n            int topElement = arr[top];\\n            top--;\\n            return topElement;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int num = Math.min(k, size);\\n        \\n        for(int i = 0; i < num; i++) {\\n            arr[i] = arr[i] + val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack {\\n    int size;\\n    int[] arr;\\n    int top;\\n    \\n    public CustomStack(int maxSize) {\\n        this.size = maxSize;\\n        this.arr = new int[maxSize];\\n        this.top = -1;\\n    }\\n    \\n    public void push(int x) {\\n        if(size - top > 1) {\\n            top++;\\n            arr[top] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if (top != -1) {\\n            int topElement = arr[top];\\n            top--;\\n            return topElement;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int num = Math.min(k, size);\\n        \\n        for(int i = 0; i < num; i++) {\\n            arr[i] = arr[i] + val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996567,
                "title": "using-vector-c-solution-easy-solution",
                "content": "\\tclass CustomStack {\\n\\tprivate:\\n    vector<int> vec;\\n    int top;\\n\\tpublic:\\n    CustomStack(int maxSize) {\\n        vec.resize(maxSize);\\n        top = -1;\\n    }\\n    \\n    void push(int x) {\\n        if(top+1 == vec.size())\\n            return;\\n        else {\\n            top++;\\n            vec[top] = x;\\n        }\\n    }\\n    \\n    int pop() {\\n        if(top == -1)\\n            return -1;\\n        else {\\n            int temp = vec[top];\\n            top--;\\n            return temp;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(top >= k - 1) {\\n            for(int i = 0; i< k ; i++) \\n                vec[i] += val;\\n        }\\n        else {\\n            for(int i = 0; i<= top ;i++)\\n                vec[i] += val;\\n        }\\n    }\\n\\t};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tclass CustomStack {\\n\\tprivate:\\n    vector<int> vec;\\n    int top;\\n\\tpublic:\\n    CustomStack(int maxSize) {\\n        vec.resize(maxSize);\\n        top = -1;\\n    }\\n    \\n    void push(int x) {\\n        if(top+1 == vec.size())\\n            return;\\n        else {\\n            top++;\\n            vec[top] = x;\\n        }\\n    }\\n    \\n    int pop() {\\n        if(top == -1)\\n            return -1;\\n        else {\\n            int temp = vec[top];\\n            top--;\\n            return temp;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(top >= k - 1) {\\n            for(int i = 0; i< k ; i++) \\n                vec[i] += val;\\n        }\\n        else {\\n            for(int i = 0; i<= top ;i++)\\n                vec[i] += val;\\n        }\\n    }\\n\\t};\\n",
                "codeTag": "Java"
            },
            {
                "id": 1939266,
                "title": "design-a-stack-with-increment-operation",
                "content": "class CustomStack {\\n   \\n    private int [] arr;\\n    private int n;\\n    private int idx;\\n    public CustomStack(int maxSize) {\\n         n = maxSize;\\n         idx = 0;\\n         arr = new int [n];\\n    }\\n    \\n    public void push(int x) {\\n        \\n        if(idx<n){\\n            arr[idx++] = x;\\n        }\\n        \\n    }\\n    \\n    public int pop() {\\n    \\n        if(idx==0) return -1;\\n        return arr[--idx];\\n    }\\n    \\n    public void increment(int k, int val) {\\n    \\n        if(idx>=k){\\n            int i = 0;\\n            while(i<k){\\n                arr[i] += val;\\n                i++;\\n            }\\n        }else{\\n            int i = 0;\\n            while(i<idx){\\n                arr[i] += val;\\n                i++;\\n            }\\n        }\\n    }\\n}\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "class CustomStack {\\n   \\n    private int [] arr;\\n    private int n;\\n    private int idx;\\n    public CustomStack(int maxSize) {\\n         n = maxSize;\\n         idx = 0;\\n         arr = new int [n];\\n    }\\n    \\n    public void push(int x) {\\n        \\n        if(idx<n){\\n            arr[idx++] = x;\\n        }\\n        \\n    }\\n    \\n    public int pop() {\\n    \\n        if(idx==0) return -1;\\n        return arr[--idx];\\n    }\\n    \\n    public void increment(int k, int val) {\\n    \\n        if(idx>=k){\\n            int i = 0;\\n            while(i<k){\\n                arr[i] += val;\\n                i++;\\n            }\\n        }else{\\n            int i = 0;\\n            while(i<idx){\\n                arr[i] += val;\\n                i++;\\n            }\\n        }\\n    }\\n}\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1930744,
                "title": "java-solution",
                "content": "```\\nclass CustomStack {\\n    int[] stack;\\n    int top;\\n    int size;\\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];    \\n        top = -1;\\n        size = maxSize;\\n    }\\n    \\n    public void push(int x) {     \\n        if (top >= size-1) return;\\n        stack[++top] = x;\\n    }\\n    \\n    public int pop() {\\n        if(top<0) return -1;\\n        int x = stack[top--];\\n        return x;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i=0;i<k && i<size && i<=top;i++) {  \\n            \\n            stack[i] +=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n    int[] stack;\\n    int top;\\n    int size;\\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];    \\n        top = -1;\\n        size = maxSize;\\n    }\\n    \\n    public void push(int x) {     \\n        if (top >= size-1) return;\\n        stack[++top] = x;\\n    }\\n    \\n    public int pop() {\\n        if(top<0) return -1;\\n        int x = stack[top--];\\n        return x;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i=0;i<k && i<size && i<=top;i++) {  \\n            \\n            stack[i] +=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1918686,
                "title": "1381-design-a-stack-with-increment-operation",
                "content": "```\\nclass CustomStack {\\n    int count,k;\\n    stack<int>st;\\n    stack<int>st1;\\npublic:\\n    CustomStack(int maxSize) {\\n        k=maxSize;\\n        count=0;\\n    }\\n    \\n    void push(int x){\\n        if(count>=k)\\n        {\\n        }\\n        else{\\n        count++;\\n        st.push(x);\\n        }\\n    }\\n    int pop() {\\n        if(count==0)\\n            return -1;\\n        int x=st.top();\\n        st.pop();\\n        count--;\\n        return x;\\n    }\\n    void increment(int k, int val) {\\n        if(k>st.size()){\\n            while(!st.empty()){\\n                int x=st.top()+val;\\n                st.pop();\\n                st1.push(x);\\n            }\\n              while(!st1.empty()){\\n                int x=st1.top();\\n                st1.pop();\\n                st.push(x);\\n            }\\n        }\\n        else{\\n            while(!st.empty()){\\n            if(k>=st.size()){\\n                 int x=st.top()+val;\\n                 st.pop();\\n                st1.push(x);\\n            }\\n            else{\\n                int x=st.top();\\n                st.pop();\\n                st1.push(x);\\n            }\\n        }\\n            while(!st1.empty()){\\n                int x=st1.top();\\n                cout<<x<<endl;\\n                st1.pop();\\n                st.push(x);\\n            }\\n      }\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n    int count,k;\\n    stack<int>st;\\n    stack<int>st1;\\npublic:\\n    CustomStack(int maxSize) {\\n        k=maxSize;\\n        count=0;\\n    }\\n    \\n    void push(int x){\\n        if(count>=k)\\n        {\\n        }\\n        else{\\n        count++;\\n        st.push(x);\\n        }\\n    }\\n    int pop() {\\n        if(count==0)\\n            return -1;\\n        int x=st.top();\\n        st.pop();\\n        count--;\\n        return x;\\n    }\\n    void increment(int k, int val) {\\n        if(k>st.size()){\\n            while(!st.empty()){\\n                int x=st.top()+val;\\n                st.pop();\\n                st1.push(x);\\n            }\\n              while(!st1.empty()){\\n                int x=st1.top();\\n                st1.pop();\\n                st.push(x);\\n            }\\n        }\\n        else{\\n            while(!st.empty()){\\n            if(k>=st.size()){\\n                 int x=st.top()+val;\\n                 st.pop();\\n                st1.push(x);\\n            }\\n            else{\\n                int x=st.top();\\n                st.pop();\\n                st1.push(x);\\n            }\\n        }\\n            while(!st1.empty()){\\n                int x=st1.top();\\n                cout<<x<<endl;\\n                st1.pop();\\n                st.push(x);\\n            }\\n      }\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1793874,
                "title": "python-o-1-increment-solution-explained-with-examples",
                "content": "I read a lot of solutions in discussions but none of them explained it, so here is my code with explaination.\\nThe logic is explained in comments:\\n```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.maxSize = maxSize\\n        self.stack = []\\n        self.increments = []\\n\\n    # Simple to understand\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:\\n            self.stack.append(x)\\n            self.increments.append(0)\\n\\n\\n    def pop(self) -> int:\\n        if self.stack:\\n\\n            # Say increments is: [0,0,0,5,0,0,0,9]\\n            # This means increment the first four elements by 5 and also the first eight element by 9\\n            # Since 9 is present only once but it affetcs all the elements before it\\n            # Hence we\\'ll pop and increment the new last element by 9, now the effect of 9 will still carry on\\n            lastIncrement = self.increments.pop()\\n            \\n            # This if handles the case to retain 9\\'s effect on previous elements\\n            # After this new increments will be: [0,0,0,5,0,0,9]\\n            if self.increments:\\n                self.increments[-1] += lastIncrement\\n            \\n            # And now we can simply pop the last element, add the last increment and return it\\n            return self.stack.pop() + lastIncrement\\n        \\n        return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if self.stack:\\n            # Make the last element += val \\n            # So when we pop them this will increment all the elements of the stack\\n            if k >= len(self.stack):\\n                self.increments[-1] += val\\n            \\n            # Make last element of the fist k elements += val\\n            # So when we pop them this will increment only the first k elements\\n            else:\\n                self.increments[k-1] += val\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.maxSize = maxSize\\n        self.stack = []\\n        self.increments = []\\n\\n    # Simple to understand\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:\\n            self.stack.append(x)\\n            self.increments.append(0)\\n\\n\\n    def pop(self) -> int:\\n        if self.stack:\\n\\n            # Say increments is: [0,0,0,5,0,0,0,9]\\n            # This means increment the first four elements by 5 and also the first eight element by 9\\n            # Since 9 is present only once but it affetcs all the elements before it\\n            # Hence we\\'ll pop and increment the new last element by 9, now the effect of 9 will still carry on\\n            lastIncrement = self.increments.pop()\\n            \\n            # This if handles the case to retain 9\\'s effect on previous elements\\n            # After this new increments will be: [0,0,0,5,0,0,9]\\n            if self.increments:\\n                self.increments[-1] += lastIncrement\\n            \\n            # And now we can simply pop the last element, add the last increment and return it\\n            return self.stack.pop() + lastIncrement\\n        \\n        return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if self.stack:\\n            # Make the last element += val \\n            # So when we pop them this will increment all the elements of the stack\\n            if k >= len(self.stack):\\n                self.increments[-1] += val\\n            \\n            # Make last element of the fist k elements += val\\n            # So when we pop them this will increment only the first k elements\\n            else:\\n                self.increments[k-1] += val\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784658,
                "title": "java-simple-o-1-100-solution",
                "content": "```java\\nclass CustomStack {\\n    private int[] stack;\\n    private int[] increment;\\n    private int size;\\n    \\n    public CustomStack(int maxSize) {\\n        this.stack = new int[maxSize];\\n        this.increment = new int[maxSize];\\n        this.size = 0;\\n    }\\n    \\n    public void push(int x) {\\n        if(this.size < this.stack.length)\\n            this.stack[this.size++] = x;\\n    }\\n    \\n    public int pop() {\\n        if(this.size < 1)\\n            return -1;\\n        \\n        if(--this.size > 0)\\n            this.increment[this.size - 1] += this.increment[this.size];\\n        \\n        int result = this.stack[this.size] + this.increment[this.size];\\n        \\n        this.increment[this.size] = 0;\\n        \\n        return result;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int i = Math.min(k, this.size) - 1;\\n        \\n        if(i > -1)\\n            this.increment[i] += val;\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [],
                "code": "```java\\nclass CustomStack {\\n    private int[] stack;\\n    private int[] increment;\\n    private int size;\\n    \\n    public CustomStack(int maxSize) {\\n        this.stack = new int[maxSize];\\n        this.increment = new int[maxSize];\\n        this.size = 0;\\n    }\\n    \\n    public void push(int x) {\\n        if(this.size < this.stack.length)\\n            this.stack[this.size++] = x;\\n    }\\n    \\n    public int pop() {\\n        if(this.size < 1)\\n            return -1;\\n        \\n        if(--this.size > 0)\\n            this.increment[this.size - 1] += this.increment[this.size];\\n        \\n        int result = this.stack[this.size] + this.increment[this.size];\\n        \\n        this.increment[this.size] = 0;\\n        \\n        return result;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int i = Math.min(k, this.size) - 1;\\n        \\n        if(i > -1)\\n            this.increment[i] += val;\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760887,
                "title": "c-array-without-using-stack",
                "content": "**Upvote if my solution is helpful to you**\\n```C++\\nclass CustomStack\\n{\\npublic:\\n    int Size;\\n    vector<int> stack;\\n    CustomStack(int maxSize)\\n    {\\n        Size = maxSize;\\n    }\\n\\n    void push(int x)\\n    {\\n        if (stack.size() < Size)\\n        {\\n            stack.push_back(x);\\n        }\\n    }\\n\\n    int pop()\\n    {\\n        if (!stack.empty())\\n        {\\n            int x = stack.back();\\n            stack.pop_back();\\n            return x;\\n        }\\n        return -1;\\n    }\\n\\n    void increment(int k, int val)\\n    {\\n        int n = stack.size();\\n        for (int i = 0; i < min(k, n); i++)\\n        {\\n            stack[i] += val;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```C++\\nclass CustomStack\\n{\\npublic:\\n    int Size;\\n    vector<int> stack;\\n    CustomStack(int maxSize)\\n    {\\n        Size = maxSize;\\n    }\\n\\n    void push(int x)\\n    {\\n        if (stack.size() < Size)\\n        {\\n            stack.push_back(x);\\n        }\\n    }\\n\\n    int pop()\\n    {\\n        if (!stack.empty())\\n        {\\n            int x = stack.back();\\n            stack.pop_back();\\n            return x;\\n        }\\n        return -1;\\n    }\\n\\n    void increment(int k, int val)\\n    {\\n        int n = stack.size();\\n        for (int i = 0; i < min(k, n); i++)\\n        {\\n            stack[i] += val;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740899,
                "title": "java-solution-using-array-stack-for-increment-and-global-pointer-capacity",
                "content": "```\\nclass CustomStack {\\n    private int[] stack;\\n    private int capacity;\\n    private int top = -1;\\n\\n    public CustomStack(int maxSize) {\\n           this.capacity = maxSize;\\n           stack = new int[this.capacity];\\n    }\\n    \\n    public void push(int x) {\\n       if(top+1 == this.capacity)\\n           return;\\n        \\n       stack[++top] = x;\\n        \\n    }\\n    \\n    public int pop() {\\n        if(top < 0)\\n            return -1;\\n        \\n        int val;\\n        val = stack[top];\\n        \\n        //for garbage collection\\n        stack[top--] = Integer.MIN_VALUE;\\n        \\n        return val;\\n        \\n    }\\n    \\n    public void increment(int k, int val) {\\n        Stack<Integer> inc = new Stack<>();\\n        \\n        while(top+1 > k && top > -1){\\n            inc.push(stack[top--]);\\n        }\\n        \\n        while(top > -1){\\n            int data = stack[top--];\\n            inc.push(data+val);\\n        }\\n        \\n        while(!inc.isEmpty()){\\n            stack[++top] = inc.pop();\\n        }\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass CustomStack {\\n    private int[] stack;\\n    private int capacity;\\n    private int top = -1;\\n\\n    public CustomStack(int maxSize) {\\n           this.capacity = maxSize;\\n           stack = new int[this.capacity];\\n    }\\n    \\n    public void push(int x) {\\n       if(top+1 == this.capacity)\\n           return;\\n        \\n       stack[++top] = x;\\n        \\n    }\\n    \\n    public int pop() {\\n        if(top < 0)\\n            return -1;\\n        \\n        int val;\\n        val = stack[top];\\n        \\n        //for garbage collection\\n        stack[top--] = Integer.MIN_VALUE;\\n        \\n        return val;\\n        \\n    }\\n    \\n    public void increment(int k, int val) {\\n        Stack<Integer> inc = new Stack<>();\\n        \\n        while(top+1 > k && top > -1){\\n            inc.push(stack[top--]);\\n        }\\n        \\n        while(top > -1){\\n            int data = stack[top--];\\n            inc.push(data+val);\\n        }\\n        \\n        while(!inc.isEmpty()){\\n            stack[++top] = inc.pop();\\n        }\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 1714966,
                "title": "java-one-array-o-1-finite-difference-prefix-sum",
                "content": "Intsead of storing the original value of each element in the stack, we store the difference between each element and its previous one, except for the bottom of the stack - we just store its original value. Let\\'s call this stack ```difference``` to distinguish it from the ```CustomStack``` the question told us to implement. ```difference[k] = CustomStack[k] - CustomStack[k-1]``` for all ```k > 0```, and ```difference[0] = CustomStack[0]```. \\n\\nWe also keep track of the top value of the ```CustomStack```. When we push an element to the ```CustomStack```, we update the value of the top element, and put the difference between the old top element and the new top element in the ```difference``` stack. When we pop an element, the new top element will be ```the old top element - top of the difference stack```.\\n\\nThen how do we implement ```inc()```? Surely, we should increment the bottom of the ```difference``` stack by ```val``` since it is supposed to be also the bottom of the ```CustomStack```. However, since we increment the bottom k elements of the ```CustomStack``` simultaneously, the difference between each of the bottom k elements won\\'t change at all! We only need to take care of ```stack[k]```. Since ```CustomStack[k - 1]``` increases by ```val``` and ```CustomStack[k]``` remains the same, ```difference[k]``` should decrease by ```val```.\\n```\\nclass CustomStack {\\n    int[] difference;\\n    int size;\\n    int top;\\n\\n    public CustomStack(int maxSize) {\\n        difference = new int[maxSize];\\n        size = 0;\\n        top = 0;\\n    }\\n    \\n    public void push(int x) {\\n        if(size < difference.length){\\n            difference[size] = x - top;\\n            top = x;\\n            size++;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(size == 0){\\n            return -1;\\n        }\\n        int old = top;\\n        top -= difference[size - 1];\\n        size--;\\n        return old;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        difference[0] += val;\\n        if(k < size){\\n            difference[k] -= val;\\n        }\\n        else{\\n            top += val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```difference```\n```CustomStack```\n```difference[k] = CustomStack[k] - CustomStack[k-1]```\n```k > 0```\n```difference[0] = CustomStack[0]```\n```CustomStack```\n```CustomStack```\n```difference```\n```the old top element - top of the difference stack```\n```inc()```\n```difference```\n```val```\n```CustomStack```\n```CustomStack```\n```stack[k]```\n```CustomStack[k - 1]```\n```val```\n```CustomStack[k]```\n```difference[k]```\n```val```\n```\\nclass CustomStack {\\n    int[] difference;\\n    int size;\\n    int top;\\n\\n    public CustomStack(int maxSize) {\\n        difference = new int[maxSize];\\n        size = 0;\\n        top = 0;\\n    }\\n    \\n    public void push(int x) {\\n        if(size < difference.length){\\n            difference[size] = x - top;\\n            top = x;\\n            size++;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(size == 0){\\n            return -1;\\n        }\\n        int old = top;\\n        top -= difference[size - 1];\\n        size--;\\n        return old;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        difference[0] += val;\\n        if(k < size){\\n            difference[k] -= val;\\n        }\\n        else{\\n            top += val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1655050,
                "title": "easy-implementation-than-lee215-java",
                "content": "int n;\\n    int[] inc;\\n    Stack<Integer> stack;\\n    public CustomStack(int maxSize) {\\n        n = maxSize;\\n        inc = new int[n+1];\\n        stack = new Stack<>();\\n    }\\n\\n    public void push(int x) {\\n        if (stack.size() < n)\\n            stack.push(x);\\n    }\\n\\n    public int pop() {\\n        int i = stack.size();\\n        if (i <= 0) return -1;\\n    \\n        inc[i - 1] += inc[i];\\n        int res = stack.pop() + inc[i];\\n        inc[i] = 0;\\n        return res;\\n    }\\n\\n    public void increment(int k, int val) {\\n            int i = Math.min(k, stack.size()) ;\\n            inc[i] += val;\\n    }",
                "solutionTags": [],
                "code": "int n;\\n    int[] inc;\\n    Stack<Integer> stack;\\n    public CustomStack(int maxSize) {\\n        n = maxSize;\\n        inc = new int[n+1];\\n        stack = new Stack<>();\\n    }\\n\\n    public void push(int x) {\\n        if (stack.size() < n)\\n            stack.push(x);\\n    }\\n\\n    public int pop() {\\n        int i = stack.size();\\n        if (i <= 0) return -1;\\n    \\n        inc[i - 1] += inc[i];\\n        int res = stack.pop() + inc[i];\\n        inc[i] = 0;\\n        return res;\\n    }\\n\\n    public void increment(int k, int val) {\\n            int i = Math.min(k, stack.size()) ;\\n            inc[i] += val;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1607780,
                "title": "java-easy",
                "content": "```\\nclass CustomStack {\\n\\n    int maxSize =0;\\n    int curr_size;\\n    int  arr[];        \\n    public CustomStack(int _maxSize) {\\n        maxSize =_maxSize;\\n        curr_size =0;\\n        arr = new int[maxSize];\\n       \\n    }\\n    \\n    public void push(int x) {\\n       \\n        if(curr_size < maxSize ){\\n             arr[curr_size++] =x;\\n        }\\n         \\n    }\\n    \\n    public int pop() {\\n        if(curr_size < 1) return  -1;\\n        return  arr[--curr_size];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        \\n        k= Math.min(k,curr_size);\\n        \\n        for(int  i = 0 ; i < k;i++){\\n            arr[i]= arr[i]+val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack {\\n\\n    int maxSize =0;\\n    int curr_size;\\n    int  arr[];        \\n    public CustomStack(int _maxSize) {\\n        maxSize =_maxSize;\\n        curr_size =0;\\n        arr = new int[maxSize];\\n       \\n    }\\n    \\n    public void push(int x) {\\n       \\n        if(curr_size < maxSize ){\\n             arr[curr_size++] =x;\\n        }\\n         \\n    }\\n    \\n    public int pop() {\\n        if(curr_size < 1) return  -1;\\n        return  arr[--curr_size];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        \\n        k= Math.min(k,curr_size);\\n        \\n        for(int  i = 0 ; i < k;i++){\\n            arr[i]= arr[i]+val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604651,
                "title": "java-increment-only-during-pop-operation-o-1-time-o-2n-space",
                "content": "```\\nclass CustomStack {\\n    int[] stack;\\n    int[] extra;\\n    int tos;\\n\\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];\\n        extra = new int[maxSize];\\n        tos = 0;\\n    }\\n    \\n    public void push(int x) {\\n        if (tos < stack.length) {\\n            stack[tos++] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        var result = -1;\\n        if (tos > 0) {\\n            tos--;\\n            result = stack[tos] + extra[tos];\\n            if (tos > 0) {\\n                extra[tos-1] += extra[tos];\\n            }\\n            extra[tos] = 0;\\n        }\\n        return result;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        k = Math.min(tos, k);\\n        if (k > 0) {\\n            extra[k-1] += val;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack {\\n    int[] stack;\\n    int[] extra;\\n    int tos;\\n\\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];\\n        extra = new int[maxSize];\\n        tos = 0;\\n    }\\n    \\n    public void push(int x) {\\n        if (tos < stack.length) {\\n            stack[tos++] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        var result = -1;\\n        if (tos > 0) {\\n            tos--;\\n            result = stack[tos] + extra[tos];\\n            if (tos > 0) {\\n                extra[tos-1] += extra[tos];\\n            }\\n            extra[tos] = 0;\\n        }\\n        return result;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        k = Math.min(tos, k);\\n        if (k > 0) {\\n            extra[k-1] += val;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603438,
                "title": "cleanest-java-stack-solution-o-1",
                "content": "We can use a Stack to hold numbers, which is easy. The trick is how do we maintain the incremented values on each k? Using an array [0, 1, ..., maxSize] will denote that arr[i] represents the increment applied to all element from stack[0, ..., i] or from the bottom element to the ith element. Using an array is best because we can access the increment k from any position or index in O(1) time.\\n\\nHow to handle increment(k, val) ?\\nWe can simply increment arr[k] += val, this way even if increment(k, val) is called repeatedly with the same k, the amount is always added up. The only case to be aware of is whether or not ```K > stack.size()``` because this may cause an index out of bounds exception.\\n\\nHow to handle pop?\\nFor the case where stack is empty, return -1.\\nOtherwise get the increment amount we must apply to the popped value, by calling ```int amount = arr[stack.size()]```. This access provides the amount to increment for the popped value and all values below it in the stack. Then erase the increment being applied to the popped value from the arr like so: ```arr[stack.size()] = 0```. Finally, we want to maintain that increment for all items in the stack so we add it to the previous index ```arr[stack.size() - 1] += amount```. Finally just ```stack.pop() + amount``` to get the next value incremented.\\n\\nThe only edge case to worry about is when k > maxSize which would be out of bounds.\\n```\\nclass CustomStack {\\n    \\n    Stack<Integer> stack = new Stack<>();\\n    int[] additions;\\n    int maxSize;\\n    \\n    public CustomStack(int maxSize) {\\n        this.maxSize = maxSize;\\n        this.additions = new int[maxSize + 1];\\n    }\\n    \\n    public void push(int x) {\\n        // edge case: stack is full at maxSize\\n        if (stack.size() == maxSize)\\n            return;\\n        // push val into stack\\n        stack.push(x);\\n    }\\n    \\n    public int pop() {\\n        // edge case: stack is empty\\n        if (stack.isEmpty())\\n            return -1;\\n        \\n        // get addition amount for next num and erase it from arr\\n        int amount = additions[stack.size()];\\n        additions[stack.size()] = 0;\\n        \\n        // add amount to item below next val\\n        additions[stack.size() - 1] += amount;\\n        \\n        return stack.pop() + amount;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        // add val to kth index\\n        additions[Math.min(k, stack.size())] += val;\\n    }\\n}```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```K > stack.size()```\n```int amount = arr[stack.size()]```\n```arr[stack.size()] = 0```\n```arr[stack.size() - 1] += amount```\n```stack.pop() + amount```\n```\\nclass CustomStack {\\n    \\n    Stack<Integer> stack = new Stack<>();\\n    int[] additions;\\n    int maxSize;\\n    \\n    public CustomStack(int maxSize) {\\n        this.maxSize = maxSize;\\n        this.additions = new int[maxSize + 1];\\n    }\\n    \\n    public void push(int x) {\\n        // edge case: stack is full at maxSize\\n        if (stack.size() == maxSize)\\n            return;\\n        // push val into stack\\n        stack.push(x);\\n    }\\n    \\n    public int pop() {\\n        // edge case: stack is empty\\n        if (stack.isEmpty())\\n            return -1;\\n        \\n        // get addition amount for next num and erase it from arr\\n        int amount = additions[stack.size()];\\n        additions[stack.size()] = 0;\\n        \\n        // add amount to item below next val\\n        additions[stack.size() - 1] += amount;\\n        \\n        return stack.pop() + amount;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        // add val to kth index\\n        additions[Math.min(k, stack.size())] += val;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1564441,
                "title": "c-easy-using-vector",
                "content": "class CustomStack {\\npublic:\\n    vector<int> st;\\n    int top;\\n    int maxS;\\n    CustomStack(int maxSize) : st(maxSize){\\n        top = 0;\\n        maxS = maxSize;\\n       \\n    }\\n    \\n    void push(int x) {\\n      \\n        if(top < maxS)\\n        {\\n            st[top] = x;\\n            top++;\\n        }\\n        \\n    }\\n    \\n    int pop() {\\n        \\n        int res = -1;\\n        if(top > 0)\\n        {\\n            res = st[top-1];\\n            top--;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    void increment(int k, int val) {\\n        \\n       for(int i = 0; i < k && i < top; i++)\\n       {\\n           st[i] = st[i] + val;\\n       }\\n        \\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */",
                "solutionTags": [],
                "code": "class CustomStack {\\npublic:\\n    vector<int> st;\\n    int top;\\n    int maxS;\\n    CustomStack(int maxSize) : st(maxSize){\\n        top = 0;\\n        maxS = maxSize;\\n       \\n    }\\n    \\n    void push(int x) {\\n      \\n        if(top < maxS)\\n        {\\n            st[top] = x;\\n            top++;\\n        }\\n        \\n    }\\n    \\n    int pop() {\\n        \\n        int res = -1;\\n        if(top > 0)\\n        {\\n            res = st[top-1];\\n            top--;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    void increment(int k, int val) {\\n        \\n       for(int i = 0; i < k && i < top; i++)\\n       {\\n           st[i] = st[i] + val;\\n       }\\n        \\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1550514,
                "title": "using-just-an-array",
                "content": "```\\nclass CustomStack {\\npublic:\\n    int pos;\\n    int size;\\n    int arr[1001]={};\\n    \\n    CustomStack(int maxSize) {\\n        size = maxSize;\\n        arr[0] = -1;\\n        pos = 0;\\n    }\\n    \\n    void push(int x) {\\n        //cout << x << \\' \\' << pos << \\'\\\\n\\';\\n        if(pos < size){arr[++pos] = x;}\\n    }\\n    \\n    int pop() {\\n        //cout << pos << \\' \\' << arr[pos] << \\'\\\\n\\';\\n        if(pos>0){return arr[pos--];}\\n        else{return arr[pos];}\\n    }\\n    \\n    void increment(int k, int val) {\\n        int i;        \\n        for(i=1; i<=k && i<=pos; i++){arr[i]+=val;}\\n        //cout << pos << \\' \\' << val << \\' \\' << arr[pos] << \\'\\\\n\\';\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\npublic:\\n    int pos;\\n    int size;\\n    int arr[1001]={};\\n    \\n    CustomStack(int maxSize) {\\n        size = maxSize;\\n        arr[0] = -1;\\n        pos = 0;\\n    }\\n    \\n    void push(int x) {\\n        //cout << x << \\' \\' << pos << \\'\\\\n\\';\\n        if(pos < size){arr[++pos] = x;}\\n    }\\n    \\n    int pop() {\\n        //cout << pos << \\' \\' << arr[pos] << \\'\\\\n\\';\\n        if(pos>0){return arr[pos--];}\\n        else{return arr[pos];}\\n    }\\n    \\n    void increment(int k, int val) {\\n        int i;        \\n        for(i=1; i<=k && i<=pos; i++){arr[i]+=val;}\\n        //cout << pos << \\' \\' << val << \\' \\' << arr[pos] << \\'\\\\n\\';\\n    }\\n};",
                "codeTag": "C++"
            },
            {
                "id": 1546807,
                "title": "python-soluion",
                "content": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.maxSize = maxSize\\n        self.stack = []\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:\\n            self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        if len(self.stack) > 0:\\n            return self.stack.pop()\\n        else:\\n            return -1\\n        \\n    def increment(self, k: int, val: int) -> None:\\n        if k > len(self.stack):\\n            k = len(self.stack)\\n        for i in range(0, k):\\n            self.stack[i] += val\\n\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.maxSize = maxSize\\n        self.stack = []\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:\\n            self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        if len(self.stack) > 0:\\n            return self.stack.pop()\\n        else:\\n            return -1\\n        \\n    def increment(self, k: int, val: int) -> None:\\n        if k > len(self.stack):\\n            k = len(self.stack)\\n        for i in range(0, k):\\n            self.stack[i] += val\\n\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1544173,
                "title": "easy-understandable-java-code-using-array",
                "content": "```\\nclass CustomStack {\\n    private int arr[];\\n    private int top, size;\\n    public CustomStack(int maxSize) {\\n        arr = new int[maxSize];\\n        top = -1;\\n    }\\n    \\n    public void push(int x) {\\n        if(top < arr.length-1) {\\n            arr[++top] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(top != -1) {\\n            return arr[top--];\\n        }\\n        return -1;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i = 0; i < k && i < arr.length; i++) {\\n            arr[i] += val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass CustomStack {\\n    private int arr[];\\n    private int top, size;\\n    public CustomStack(int maxSize) {\\n        arr = new int[maxSize];\\n        top = -1;\\n    }\\n    \\n    public void push(int x) {\\n        if(top < arr.length-1) {\\n            arr[++top] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(top != -1) {\\n            return arr[top--];\\n        }\\n        return -1;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i = 0; i < k && i < arr.length; i++) {\\n            arr[i] += val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538549,
                "title": "java-solution-using-array",
                "content": "class CustomStack {\\n\\n    int top = -1;\\n    int[] arr;\\n    \\n    public CustomStack(int maxSize) {\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n        if(top<arr.length-1)\\n        arr[++top]=x; \\n    }\\n    \\n    public int pop() {\\n        if(top == -1)\\n            return -1;\\n        int value = arr[top];\\n        arr[top] = Integer.MIN_VALUE;\\n        top--;\\n        return value;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int increment = -1;\\n        if(k-1<top)\\n          increment=k-1;  \\n        else\\n          increment=top;           \\n        for(int i=0;i<=increment;i++)\\n            arr[i]+=val;         \\n    }\\n}",
                "solutionTags": [],
                "code": "class CustomStack {\\n\\n    int top = -1;\\n    int[] arr;\\n    \\n    public CustomStack(int maxSize) {\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n        if(top<arr.length-1)\\n        arr[++top]=x; \\n    }\\n    \\n    public int pop() {\\n        if(top == -1)\\n            return -1;\\n        int value = arr[top];\\n        arr[top] = Integer.MIN_VALUE;\\n        top--;\\n        return value;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int increment = -1;\\n        if(k-1<top)\\n          increment=k-1;  \\n        else\\n          increment=top;           \\n        for(int i=0;i<=increment;i++)\\n            arr[i]+=val;         \\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1479010,
                "title": "c-24ms-98-simple-solution",
                "content": "Runtime: 24 ms, faster than 98.16% of C++ online submissions for Design a Stack With Increment Operation.\\nMemory Usage: 21 MB, less than 75.46% of C++ online submissions for Design a Stack With Increment Operation.\\n```\\nclass CustomStack {\\npublic:\\n  int i, mi;\\n  vector<int> s;\\n  \\n  CustomStack(int maxSize) {\\n    i = -1, mi = maxSize - 1;\\n    s.resize(maxSize);\\n  }\\n    \\n  void push(int x) {\\n    if(i != mi) s[++i] = x;  \\n  }\\n    \\n  int pop() {\\n    return i != -1 ? s[i--] : -1;      \\n  }\\n    \\n  void increment(int k, int val) {\\n    k = min(k, i + 1);\\n    while(--k >= 0) s[k] += val;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n  int i, mi;\\n  vector<int> s;\\n  \\n  CustomStack(int maxSize) {\\n    i = -1, mi = maxSize - 1;\\n    s.resize(maxSize);\\n  }\\n    \\n  void push(int x) {\\n    if(i != mi) s[++i] = x;  \\n  }\\n    \\n  int pop() {\\n    return i != -1 ? s[i--] : -1;      \\n  }\\n    \\n  void increment(int k, int val) {\\n    k = min(k, i + 1);\\n    while(--k >= 0) s[k] += val;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441406,
                "title": "c-o-1-time-o-maxsize-space",
                "content": "```\\nclass CustomStack {\\npublic:\\n    vector<pair<int, int>> stk;\\n    int capacity, top;\\n    \\n    CustomStack(int maxSize) : \\n        capacity(maxSize), top(-1), stk(maxSize) {}\\n    \\n    void push(int x) {\\n        if (top == capacity - 1)\\n            return;\\n        top++;\\n        stk[top].first = x;\\n        stk[top].second = 0;\\n    }\\n    \\n    int pop() {\\n        if (top == -1)\\n            return -1;\\n        if (top != 0)\\n            stk[top - 1].second += stk[top].second;\\n        int val = stk[top].first + stk[top].second;\\n        top--;\\n        return val;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if (k <= 0 || top == -1)\\n            return;\\n        stk[min(k - 1, top)].second += val;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\npublic:\\n    vector<pair<int, int>> stk;\\n    int capacity, top;\\n    \\n    CustomStack(int maxSize) : \\n        capacity(maxSize), top(-1), stk(maxSize) {}\\n    \\n    void push(int x) {\\n        if (top == capacity - 1)\\n            return;\\n        top++;\\n        stk[top].first = x;\\n        stk[top].second = 0;\\n    }\\n    \\n    int pop() {\\n        if (top == -1)\\n            return -1;\\n        if (top != 0)\\n            stk[top - 1].second += stk[top].second;\\n        int val = stk[top].first + stk[top].second;\\n        top--;\\n        return val;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if (k <= 0 || top == -1)\\n            return;\\n        stk[min(k - 1, top)].second += val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407529,
                "title": "c-solution",
                "content": "```\\nclass CustomStack {\\npublic:\\n    vector<int> incr,vec;\\n    int top = -1;\\n    CustomStack(int maxSize) {\\n        vector<int> temp(maxSize,0);\\n        incr = vec = temp;\\n    }\\n    \\n    void push(int x) {\\n        if(top != vec.size()-1)\\n        {\\n            top++;\\n            vec[top] = x;\\n        }\\n    }\\n    \\n    int pop() {\\n        if(top != -1)\\n        {\\n            int incrVal = incr[top];\\n            if(top != 0)\\n            {\\n                incr[top-1] += incr[top];\\n            }\\n            incr[top] = 0;\\n            top--;\\n            return incrVal+vec[top+1];\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(top == -1)\\n        {\\n            return;\\n        }\\n        if(k > top)\\n        {\\n            incr[top] += val;\\n        }else{\\n            incr[k-1] += val;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    vector<int> incr,vec;\\n    int top = -1;\\n    CustomStack(int maxSize) {\\n        vector<int> temp(maxSize,0);\\n        incr = vec = temp;\\n    }\\n    \\n    void push(int x) {\\n        if(top != vec.size()-1)\\n        {\\n            top++;\\n            vec[top] = x;\\n        }\\n    }\\n    \\n    int pop() {\\n        if(top != -1)\\n        {\\n            int incrVal = incr[top];\\n            if(top != 0)\\n            {\\n                incr[top-1] += incr[top];\\n            }\\n            incr[top] = 0;\\n            top--;\\n            return incrVal+vec[top+1];\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(top == -1)\\n        {\\n            return;\\n        }\\n        if(k > top)\\n        {\\n            incr[top] += val;\\n        }else{\\n            incr[k-1] += val;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395643,
                "title": "javascript-solution",
                "content": "```\\nvar CustomStack = function(maxSize) {\\n    this.arr = [];\\n    this.maxSize = maxSize;\\n};\\n\\n\\nCustomStack.prototype.push = function(x) {\\n    if (this.arr.length === this.maxSize) return;\\n    this.arr.push(x);\\n};\\n\\n\\nCustomStack.prototype.pop = function() {\\n    if (this.arr.length === 0) return -1;\\n    return this.arr.pop();\\n};\\n\\n\\nCustomStack.prototype.increment = function(k, val) {\\n    let index = 0;\\n    \\n    for (let i = 0; i < Math.min(this.maxSize, k); i++) {\\n        this.arr[i] += val;\\n    }    \\n};\\n ```",
                "solutionTags": [],
                "code": "```\\nvar CustomStack = function(maxSize) {\\n    this.arr = [];\\n    this.maxSize = maxSize;\\n};\\n\\n\\nCustomStack.prototype.push = function(x) {\\n    if (this.arr.length === this.maxSize) return;\\n    this.arr.push(x);\\n};\\n\\n\\nCustomStack.prototype.pop = function() {\\n    if (this.arr.length === 0) return -1;\\n    return this.arr.pop();\\n};\\n\\n\\nCustomStack.prototype.increment = function(k, val) {\\n    let index = 0;\\n    \\n    for (let i = 0; i < Math.min(this.maxSize, k); i++) {\\n        this.arr[i] += val;\\n    }    \\n};\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1382871,
                "title": "c-fastest-runtime-20-ms-faster-than-100-00-of-c-online-submissions",
                "content": "class CustomStack {\\n    int * ar,i = -1,n;\\npublic:\\n    CustomStack(int maxSize) {\\n        ar = new int[maxSize];\\n        n = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(i != n-1)\\n        {\\n            ar[++i] = x;\\n        }\\n    }\\n    \\n    int pop() {\\n        if(i == -1)\\n            return i;\\n        return ar[i--];\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(i < k-1)\\n        {\\n            for(int j = 0 ; j <=i;j++)\\n                ar[j] += val;\\n        }\\n        else\\n        {\\n            for(int j = 0 ; j <k;j++)\\n                ar[j] += val; \\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class CustomStack {\\n    int * ar,i = -1,n;\\npublic:\\n    CustomStack(int maxSize) {\\n        ar = new int[maxSize];\\n        n = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(i != n-1)\\n        {\\n            ar[++i] = x;\\n        }\\n    }\\n    \\n    int pop() {\\n        if(i == -1)\\n            return i;\\n        return ar[i--];\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(i < k-1)\\n        {\\n            for(int j = 0 ; j <=i;j++)\\n                ar[j] += val;\\n        }\\n        else\\n        {\\n            for(int j = 0 ; j <k;j++)\\n                ar[j] += val; \\n        }\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1373623,
                "title": "java-easy-to-understand-solution-array-to-represent-the-stack",
                "content": "My `JAVA` solution using an array to represent the stack.\\n\\n`Adding` elements to the stack : \\n* We add elements in our stack array from left to right (index 0 to MAX - 1).\\n* Here index is the leftmost free position in stack array.\\n\\n`Removing` elements from the stack : \\n* We remove elements from our stack array from right to left (index MAX - 1 to 0).\\n* Here index is the rightmost element in stack array.\\n\\n`Increment` elements last k elements by value :\\n* So we have to add value to the elements from index 0 to endPosition.\\n* `endPosition =  Math.min(k - 1, index - 1).`\\n* Add value to endPosition(it will mean that we have to add value from index 0 to endPosition).\\n* Now during removal of an element from stack array, we pass this removed index value to the previous element in stack.\\n\\n```\\nclass CustomStack {\\n    int[] stack;\\n    int[] increment;\\n    int MAX;\\n    int index = 0;\\n    public CustomStack(int maxSize) {\\n        MAX = maxSize;\\n        stack = new int[MAX];\\n        increment = new int[MAX];\\n    }\\n    \\n    public void push(int x) {\\n        if (index == MAX) {\\n            return;\\n        }\\n        stack[index] = x;\\n        index++;\\n    }\\n    \\n    public int pop() {\\n        if (index == 0) {\\n            return -1;\\n        }\\n        if (index > 1) {\\n            increment[index - 2] += increment[index - 1];\\n        }\\n        index--;\\n        int sum = stack[index] + increment[index];\\n        increment[index] = 0;\\n        return sum;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        if (index == 0) {\\n            return;\\n        }\\n        int endPosition = Math.min(k - 1, index - 1);\\n        increment[endPosition] += val;\\n    }\\n}\\n\\n/*\\n\\n\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```\\n\\nIf you like the solution, please Upvote \\uD83D\\uDC4D!!\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n    int[] stack;\\n    int[] increment;\\n    int MAX;\\n    int index = 0;\\n    public CustomStack(int maxSize) {\\n        MAX = maxSize;\\n        stack = new int[MAX];\\n        increment = new int[MAX];\\n    }\\n    \\n    public void push(int x) {\\n        if (index == MAX) {\\n            return;\\n        }\\n        stack[index] = x;\\n        index++;\\n    }\\n    \\n    public int pop() {\\n        if (index == 0) {\\n            return -1;\\n        }\\n        if (index > 1) {\\n            increment[index - 2] += increment[index - 1];\\n        }\\n        index--;\\n        int sum = stack[index] + increment[index];\\n        increment[index] = 0;\\n        return sum;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        if (index == 0) {\\n            return;\\n        }\\n        int endPosition = Math.min(k - 1, index - 1);\\n        increment[endPosition] += val;\\n    }\\n}\\n\\n/*\\n\\n\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363388,
                "title": "my-java-answer",
                "content": "\\n    int cusMaxSize = 0;\\n    Stack<Integer> stack = new Stack<Integer>();\\n    public CustomStack(int maxSize) {\\n        cusMaxSize = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(stack.size() < cusMaxSize){\\n            stack.push(x);\\n        }\\n    }\\n    \\n    public int pop() {\\n        return stack.isEmpty() ? -1 : stack.pop();\\n    }\\n    \\n    public void increment(int k, int val) {\\n        Stack<Integer> holder = new Stack<Integer>();\\n        int addLimit = k > cusMaxSize ? cusMaxSize : k;\\n        \\n        int ctr=stack.size();\\n        while(!stack.isEmpty()){\\n            holder.push(stack.pop() + (ctr <= addLimit ? val : 0));    \\n            ctr--;\\n        }\\n        \\n        while(!holder.isEmpty()){\\n            stack.push(holder.pop());\\n        }\\n        \\n    }\\n",
                "solutionTags": [],
                "code": "\\n    int cusMaxSize = 0;\\n    Stack<Integer> stack = new Stack<Integer>();\\n    public CustomStack(int maxSize) {\\n        cusMaxSize = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(stack.size() < cusMaxSize){\\n            stack.push(x);\\n        }\\n    }\\n    \\n    public int pop() {\\n        return stack.isEmpty() ? -1 : stack.pop();\\n    }\\n    \\n    public void increment(int k, int val) {\\n        Stack<Integer> holder = new Stack<Integer>();\\n        int addLimit = k > cusMaxSize ? cusMaxSize : k;\\n        \\n        int ctr=stack.size();\\n        while(!stack.isEmpty()){\\n            holder.push(stack.pop() + (ctr <= addLimit ? val : 0));    \\n            ctr--;\\n        }\\n        \\n        while(!holder.isEmpty()){\\n            stack.push(holder.pop());\\n        }\\n        \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1363137,
                "title": "stack-implementation-using-array-easy-solution",
                "content": "```\\nclass CustomStack {\\npublic:\\n    int arr[1000];\\n    int top = 0;\\n    int max = 0;\\n    CustomStack(int maxSize) {\\n        max = maxSize; \\n    }\\n    \\n    void push(int x) {\\n        if(top<max)\\n        {\\n            arr[top] = x;\\n            top = top+1;\\n            \\n           \\n        }\\n        \\n    }\\n    \\n    int pop() {\\n       if(top>0)\\n       {\\n           top = top-1;\\n           return arr[top];\\n       }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(k<top)\\n        {\\n            for(int i=0;i<k;i++)\\n            {\\n                arr[i] = arr[i]+val;\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<top;i++)\\n            {\\n                arr[i] = arr[i]+val;\\n            }\\n        }\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    int arr[1000];\\n    int top = 0;\\n    int max = 0;\\n    CustomStack(int maxSize) {\\n        max = maxSize; \\n    }\\n    \\n    void push(int x) {\\n        if(top<max)\\n        {\\n            arr[top] = x;\\n            top = top+1;\\n            \\n           \\n        }\\n        \\n    }\\n    \\n    int pop() {\\n       if(top>0)\\n       {\\n           top = top-1;\\n           return arr[top];\\n       }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(k<top)\\n        {\\n            for(int i=0;i<k;i++)\\n            {\\n                arr[i] = arr[i]+val;\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<top;i++)\\n            {\\n                arr[i] = arr[i]+val;\\n            }\\n        }\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 1330699,
                "title": "c-easy-to-understand-array",
                "content": "```\\nclass CustomStack {\\npublic:\\n    int max = 0;\\n    int arr[1000];\\n    int top=0;\\n    CustomStack(int maxSize) {\\n        max = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(top<max)\\n        {\\n            arr[top]=x;\\n            top++;\\n        }\\n    }\\n    \\n    int pop() {\\n        if(top>0)\\n        {\\n            int ret = arr[--top];\\n            arr[top]=0;\\n            return ret;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(top>k)\\n        {\\n            for(int i=0;i<k;i++)\\n            {\\n                arr[i] += val;\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<top;i++)\\n            {\\n                arr[i] +=val;\\n            }\\n        }\\n    }\\n};\\n```\\nPlease upto if you find it useful.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    int max = 0;\\n    int arr[1000];\\n    int top=0;\\n    CustomStack(int maxSize) {\\n        max = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(top<max)\\n        {\\n            arr[top]=x;\\n            top++;\\n        }\\n    }\\n    \\n    int pop() {\\n        if(top>0)\\n        {\\n            int ret = arr[--top];\\n            arr[top]=0;\\n            return ret;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(top>k)\\n        {\\n            for(int i=0;i<k;i++)\\n            {\\n                arr[i] += val;\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<top;i++)\\n            {\\n                arr[i] +=val;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265421,
                "title": "python3-very-easy-to-understand-o-1-faster-than-94",
                "content": "Just add a pair and update accordingly. For the preceding indices, add the val to previous when you pop. \\n```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.max=maxSize\\n        self.ini=0\\n        self.stack=[]\\n\\n    def push(self, x: int) -> None:\\n        if self.ini<self.max:\\n            self.stack.append([x,0])\\n            self.ini+=1\\n    def pop(self) -> int:\\n        if not self.stack:\\n            return -1\\n        k=self.stack.pop()\\n        if len(self.stack)>0:\\n            self.stack[-1][1]+=k[1]\\n        self.ini-=1\\n        return k[0]+k[1]\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if self.stack:\\n            self.stack[min(len(self.stack)-1,k-1)][1]+=val\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.max=maxSize\\n        self.ini=0\\n        self.stack=[]\\n\\n    def push(self, x: int) -> None:\\n        if self.ini<self.max:\\n            self.stack.append([x,0])\\n            self.ini+=1\\n    def pop(self) -> int:\\n        if not self.stack:\\n            return -1\\n        k=self.stack.pop()\\n        if len(self.stack)>0:\\n            self.stack[-1][1]+=k[1]\\n        self.ini-=1\\n        return k[0]+k[1]\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if self.stack:\\n            self.stack[min(len(self.stack)-1,k-1)][1]+=val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263425,
                "title": "java-ac-solution",
                "content": "```\\nclass CustomStack {\\n    ArrayList<Integer> stack = new ArrayList();\\n    int max=0;\\n    public CustomStack(int maxSize) {\\n        max = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(stack.size() < max){\\n            stack.add(x);\\n        }\\n    }\\n    \\n    public int pop() {\\n        return stack.size() == 0 ? -1 : stack.remove(stack.size()-1);\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i = 0;i < stack.size() && i < k;i++){\\n            stack.set(i,stack.get(i)+val);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack {\\n    ArrayList<Integer> stack = new ArrayList();\\n    int max=0;\\n    public CustomStack(int maxSize) {\\n        max = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(stack.size() < max){\\n            stack.add(x);\\n        }\\n    }\\n    \\n    public int pop() {\\n        return stack.size() == 0 ? -1 : stack.remove(stack.size()-1);\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i = 0;i < stack.size() && i < k;i++){\\n            stack.set(i,stack.get(i)+val);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258510,
                "title": "c-solution-in-o-1-time",
                "content": "```\\nclass CustomStack {\\npublic:\\n    vector<int> original_val_;\\n    vector<int> inc_val_;\\n    int size_;\\n    \\n    \\n    CustomStack(int maxSize) {\\n        size_ = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(original_val_.size() == size_) return;\\n        \\n        original_val_.push_back(x);\\n        inc_val_.push_back(0);\\n}\\n    \\n    int pop() {\\n        if(original_val_.empty()) return -1;\\n        \\n        int last = original_val_.back() + inc_val_.back();\\n        \\n        //Transfer to previous\\n        if(original_val_.size() > 1){\\n            inc_val_[inc_val_.size() -2] += inc_val_.back();\\n        }\\n        //pop\\n        original_val_.pop_back();\\n        inc_val_.pop_back();\\n        \\n        return last;\\n        \\n    }\\n    \\n    void increment(int k, int val) {\\n        \\n        int n = original_val_.size();\\n        \\n        if(n==0) return;\\n        inc_val_[min(k,n)-1] +=val;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\npublic:\\n    vector<int> original_val_;\\n    vector<int> inc_val_;\\n    int size_;\\n    \\n    \\n    CustomStack(int maxSize) {\\n        size_ = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(original_val_.size() == size_) return;\\n        \\n        original_val_.push_back(x);\\n        inc_val_.push_back(0);\\n}\\n    \\n    int pop() {\\n        if(original_val_.empty()) return -1;\\n        \\n        int last = original_val_.back() + inc_val_.back();\\n        \\n        //Transfer to previous\\n        if(original_val_.size() > 1){\\n            inc_val_[inc_val_.size() -2] += inc_val_.back();\\n        }\\n        //pop\\n        original_val_.pop_back();\\n        inc_val_.pop_back();\\n        \\n        return last;\\n        \\n    }\\n    \\n    void increment(int k, int val) {\\n        \\n        int n = original_val_.size();\\n        \\n        if(n==0) return;\\n        inc_val_[min(k,n)-1] +=val;\\n        \\n        \\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1258465,
                "title": "c-solution",
                "content": "```\\nclass CustomStack {\\npublic:\\n    vector<int> custom_Stack_;\\n    int size_;\\n    CustomStack(int maxSize) {\\n        size_ = maxSize;\\n    }\\n    //O(1)\\n    void push(int x) {\\n        if(custom_Stack_.size() == size_) return ;\\n        else custom_Stack_.push_back(x);\\n    }\\n    //O(1)\\n    int pop() {\\n        if(custom_Stack_.empty()) return -1;\\n        \\n        int last = custom_Stack_.back();\\n        custom_Stack_.pop_back();\\n        return last;\\n        }\\n    //O(k)\\n    void increment(int k, int val) {\\n        int n = custom_Stack_.size();\\n        for(int i = 0; i < min(n,k); i++){\\n            custom_Stack_[i]+=val;\\n        }\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\npublic:\\n    vector<int> custom_Stack_;\\n    int size_;\\n    CustomStack(int maxSize) {\\n        size_ = maxSize;\\n    }\\n    //O(1)\\n    void push(int x) {\\n        if(custom_Stack_.size() == size_) return ;\\n        else custom_Stack_.push_back(x);\\n    }\\n    //O(1)\\n    int pop() {\\n        if(custom_Stack_.empty()) return -1;\\n        \\n        int last = custom_Stack_.back();\\n        custom_Stack_.pop_back();\\n        return last;\\n        }\\n    //O(k)\\n    void increment(int k, int val) {\\n        int n = custom_Stack_.size();\\n        for(int i = 0; i < min(n,k); i++){\\n            custom_Stack_[i]+=val;\\n        }\\n        \\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1257648,
                "title": "python3-solution-using-lazy-update",
                "content": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack=[]\\n        self.size=maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack)<self.size:\\n            self.stack.append([x,0]) # second value contain lazy update\\n\\n    def pop(self) -> int:\\n        if len(self.stack)>0:\\n            x=self.stack.pop()\\n            if len(self.stack)>0:\\n                self.stack[-1][1]+=x[1] # propagate lazy update to below elements\\n            return x[0]+x[1] # return updated value\\n        else:\\n            return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if len(self.stack)>0:\\n            self.stack[min(k-1,len(self.stack)-1)][1]+=val  # pile up lazy update\\n\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack=[]\\n        self.size=maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack)<self.size:\\n            self.stack.append([x,0]) # second value contain lazy update\\n\\n    def pop(self) -> int:\\n        if len(self.stack)>0:\\n            x=self.stack.pop()\\n            if len(self.stack)>0:\\n                self.stack[-1][1]+=x[1] # propagate lazy update to below elements\\n            return x[0]+x[1] # return updated value\\n        else:\\n            return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if len(self.stack)>0:\\n            self.stack[min(k-1,len(self.stack)-1)][1]+=val  # pile up lazy update\\n\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248210,
                "title": "c-solution-using-one-vector",
                "content": "```\\nclass CustomStack {\\npublic:\\n    vector<pair<int,int> >st;\\n    int size;\\n    int top=0;\\n    CustomStack(int maxSize)\\n    {\\n        size=maxSize;\\n        st.resize(size+1,make_pair(0,0));\\n    }\\n    \\n    void push(int x)\\n    {\\n        if(top<size)\\n        {\\n            st[++top]=make_pair(x,0);    \\n            \\n        }\\n    }\\n    \\n    int pop()\\n    {\\n        if(top!=0)\\n        {\\n          int x=st[top].first;\\n          int y=st[top].second;\\n          x+=y;\\n          top--;\\n          st[top].second+=y;\\n          return x;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val)\\n    {\\n        int in=top;\\n         if(top>=k)\\n         {\\n             in=k;\\n         }\\n         else\\n         {\\n            in=top; \\n         }\\n        st[in].second+=val;\\n    }\\n};\\n\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\npublic:\\n    vector<pair<int,int> >st;\\n    int size;\\n    int top=0;\\n    CustomStack(int maxSize)\\n    {\\n        size=maxSize;\\n        st.resize(size+1,make_pair(0,0));\\n    }\\n    \\n    void push(int x)\\n    {\\n        if(top<size)\\n        {\\n            st[++top]=make_pair(x,0);    \\n            \\n        }\\n    }\\n    \\n    int pop()\\n    {\\n        if(top!=0)\\n        {\\n          int x=st[top].first;\\n          int y=st[top].second;\\n          x+=y;\\n          top--;\\n          st[top].second+=y;\\n          return x;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val)\\n    {\\n        int in=top;\\n         if(top>=k)\\n         {\\n             in=k;\\n         }\\n         else\\n         {\\n            in=top; \\n         }\\n        st[in].second+=val;\\n    }\\n};\\n\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226320,
                "title": "java-with-own-custom-stack",
                "content": "```\\nclass CustomStack {\\n    \\n\\tprivate int[] stack;\\n\\tprivate int i;\\n\\n\\tpublic CustomStack(int maxSize) {\\n\\t\\tstack = new int[maxSize];\\n\\t\\ti = 0;\\n\\t}\\n\\n\\tpublic void push(int x) {\\n\\t\\tif (i < stack.length) {\\n\\t\\t\\tstack[i++] = x;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int pop() {\\n\\t\\tif (i > 0) {\\n\\t\\t\\treturn stack[--i];\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic void increment(int k, int val) {\\n\\t\\tfor (int j = 0; j < k && j < i; j++) {\\n\\t\\t\\tstack[j] = stack[j] + val;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack {\\n    \\n\\tprivate int[] stack;\\n\\tprivate int i;\\n\\n\\tpublic CustomStack(int maxSize) {\\n\\t\\tstack = new int[maxSize];\\n\\t\\ti = 0;\\n\\t}\\n\\n\\tpublic void push(int x) {\\n\\t\\tif (i < stack.length) {\\n\\t\\t\\tstack[i++] = x;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int pop() {\\n\\t\\tif (i > 0) {\\n\\t\\t\\treturn stack[--i];\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic void increment(int k, int val) {\\n\\t\\tfor (int j = 0; j < k && j < i; j++) {\\n\\t\\t\\tstack[j] = stack[j] + val;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1205393,
                "title": "java-simple-solution-using-arraylist",
                "content": "```\\nclass CustomStack {\\n\\n    List<Integer>stack;\\n    int sizz;\\n    public CustomStack(int maxSize) {\\n        stack = new ArrayList<>(maxSize);\\n        sizz = maxSize ;\\n    }\\n    \\n    public void push(int x) {\\n        if(stack.size() < sizz) stack.add(x);\\n    }\\n    \\n    public int pop() {\\n        if(stack.isEmpty()) return -1;\\n        else return stack.remove(stack.size()-1);\\n    }\\n    \\n    public void increment(int k, int val) {\\n      for(int i = 0; i < k && i < stack.size() ;++i )\\n          stack.set(i, stack.get(i) + val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n\\n    List<Integer>stack;\\n    int sizz;\\n    public CustomStack(int maxSize) {\\n        stack = new ArrayList<>(maxSize);\\n        sizz = maxSize ;\\n    }\\n    \\n    public void push(int x) {\\n        if(stack.size() < sizz) stack.add(x);\\n    }\\n    \\n    public int pop() {\\n        if(stack.isEmpty()) return -1;\\n        else return stack.remove(stack.size()-1);\\n    }\\n    \\n    public void increment(int k, int val) {\\n      for(int i = 0; i < k && i < stack.size() ;++i )\\n          stack.set(i, stack.get(i) + val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184211,
                "title": "java-runtime-faster-than-98-using-array",
                "content": "```\\nclass CustomStack {\\n\\n    private int[] stack;\\n    private int stackHead;\\n    public CustomStack(int maxSize) {\\n        this.stack = new int[maxSize];\\n        this.stackHead = -1;\\n    }\\n    \\n    public void push(int x) {\\n        \\n        if(stackHead+1 < stack.length){\\n            stackHead++;\\n            stack[stackHead] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(stackHead == -1){\\n            return stackHead;\\n        }\\n        int val = stack[stackHead];\\n        stackHead--;\\n        return val;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i=0; i<=stackHead && i<k; i++){\\n            stack[i] +=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```\\n\\nSugessions are always welcome..",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack {\\n\\n    private int[] stack;\\n    private int stackHead;\\n    public CustomStack(int maxSize) {\\n        this.stack = new int[maxSize];\\n        this.stackHead = -1;\\n    }\\n    \\n    public void push(int x) {\\n        \\n        if(stackHead+1 < stack.length){\\n            stackHead++;\\n            stack[stackHead] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(stackHead == -1){\\n            return stackHead;\\n        }\\n        int val = stack[stackHead];\\n        stackHead--;\\n        return val;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i=0; i<=stackHead && i<k; i++){\\n            stack[i] +=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1173491,
                "title": "got-the-tc-down-from-o-k-every-increment-down-to-o-1",
                "content": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.arr = []\\n        self.cap = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.arr) == self.cap:\\n            return -1\\n        else:\\n            self.arr.append([x, 0])\\n\\n    def pop(self) -> int:\\n        if self.arr:\\n            val, inc = self.arr.pop()\\n            if self.arr:\\n                self.arr[-1][-1] += inc\\n            return val + inc\\n        return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if len(self.arr) == 0:\\n            return\\n        self.arr[min(k, len(self.arr)) - 1][-1] += val\\n\\n\\n```\\n\\n\\nBrute force solution\\n```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.arr = []\\n        self.cap = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.arr) == self.cap:\\n            return -1\\n        else:\\n            self.arr.append(x)\\n\\n    def pop(self) -> int:\\n        if self.arr:\\n            return self.arr.pop()\\n        return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, len(self.arr))):\\n            self.arr[i] += val\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.arr = []\\n        self.cap = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.arr) == self.cap:\\n            return -1\\n        else:\\n            self.arr.append([x, 0])\\n\\n    def pop(self) -> int:\\n        if self.arr:\\n            val, inc = self.arr.pop()\\n            if self.arr:\\n                self.arr[-1][-1] += inc\\n            return val + inc\\n        return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if len(self.arr) == 0:\\n            return\\n        self.arr[min(k, len(self.arr)) - 1][-1] += val\\n\\n\\n```\n```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.arr = []\\n        self.cap = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.arr) == self.cap:\\n            return -1\\n        else:\\n            self.arr.append(x)\\n\\n    def pop(self) -> int:\\n        if self.arr:\\n            return self.arr.pop()\\n        return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, len(self.arr))):\\n            self.arr[i] += val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162969,
                "title": "basic-and-optimal-solution-python",
                "content": "**Optimal solution:**\\n```\\ndef __init__(self, maxSize):\\n\\tself.s = []\\n\\tself.n = maxSize\\n\\tself.inc = []\\n\\ndef push(self, x):\\n\\tif len(self.s) < self.n:\\n\\t\\tself.s.append(x)\\n\\t\\tself.inc.append(0)\\n\\ndef pop(self):\\n\\tif not self.s:\\n\\t\\treturn -1\\n\\tif len(self.s) > 1:\\n\\t\\tself.inc[-2] += self.inc[-1]\\n\\treturn self.s.pop() + self.inc.pop()\\n\\ndef increment(self, k, val):\\n\\tif self.s:\\n\\t\\tif k < len(self.s):\\n\\t\\t\\tself.inc[k - 1] += val\\n\\t\\telse:\\n\\t\\t\\tself.inc[-1] += val\\n```\\n\\n**Basic solution:**\\n```\\ndef __init__(self, maxSize):\\n\\tself.s = []\\n\\tself.n = maxSize\\n\\ndef push(self, x):\\n\\tif len(self.s) < self.n:\\n\\t\\tself.s.append(x)\\n\\ndef pop(self):\\n\\treturn self.s.pop() if self.s else -1\\n\\ndef increment(self, k, val):\\n\\tn = min(k, len(self.s))\\n\\tfor i in range(n):\\n\\t\\tself.s[i] += val\\n```",
                "solutionTags": [],
                "code": "```\\ndef __init__(self, maxSize):\\n\\tself.s = []\\n\\tself.n = maxSize\\n\\tself.inc = []\\n\\ndef push(self, x):\\n\\tif len(self.s) < self.n:\\n\\t\\tself.s.append(x)\\n\\t\\tself.inc.append(0)\\n\\ndef pop(self):\\n\\tif not self.s:\\n\\t\\treturn -1\\n\\tif len(self.s) > 1:\\n\\t\\tself.inc[-2] += self.inc[-1]\\n\\treturn self.s.pop() + self.inc.pop()\\n\\ndef increment(self, k, val):\\n\\tif self.s:\\n\\t\\tif k < len(self.s):\\n\\t\\t\\tself.inc[k - 1] += val\\n\\t\\telse:\\n\\t\\t\\tself.inc[-1] += val\\n```\n```\\ndef __init__(self, maxSize):\\n\\tself.s = []\\n\\tself.n = maxSize\\n\\ndef push(self, x):\\n\\tif len(self.s) < self.n:\\n\\t\\tself.s.append(x)\\n\\ndef pop(self):\\n\\treturn self.s.pop() if self.s else -1\\n\\ndef increment(self, k, val):\\n\\tn = min(k, len(self.s))\\n\\tfor i in range(n):\\n\\t\\tself.s[i] += val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1159636,
                "title": "python3-simple-efficient-solution",
                "content": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.maxSize = maxSize\\n    def push(self, x: int) -> None:\\n        if len(self.stack)<self.maxSize:\\n            self.stack.append(x)\\n    def pop(self) -> int:\\n        if len(self.stack):\\n            return self.stack.pop()\\n        return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if len(self.stack):\\n            for i in range(min(k,len(self.stack))):\\n                self.stack[i]+=val\\n\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)",
                "solutionTags": [],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.maxSize = maxSize\\n    def push(self, x: int) -> None:\\n        if len(self.stack)<self.maxSize:\\n            self.stack.append(x)\\n    def pop(self) -> int:\\n        if len(self.stack):\\n            return self.stack.pop()\\n        return -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if len(self.stack):\\n            for i in range(min(k,len(self.stack))):\\n                self.stack[i]+=val\\n\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)",
                "codeTag": "Java"
            },
            {
                "id": 1137268,
                "title": "java-easy-solution-stack-basics",
                "content": "```\\nclass CustomStack {\\n   int top=0;\\n   int size=0;\\n   int arr[]=null;\\n    public CustomStack(int maxSize) {\\n        size=maxSize;\\n        arr=new int[maxSize];\\n        \\n    }\\n    \\n    public void push(int x) {\\n        if(top<size){\\n          arr[top]=x;\\n          top++;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(top==0) return -1;\\n      return arr[--top];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i=0;i<k;i++){\\n          if(i<top){\\n            arr[i]=arr[i]+val;\\n          }\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n   int top=0;\\n   int size=0;\\n   int arr[]=null;\\n    public CustomStack(int maxSize) {\\n        size=maxSize;\\n        arr=new int[maxSize];\\n        \\n    }\\n    \\n    public void push(int x) {\\n        if(top<size){\\n          arr[top]=x;\\n          top++;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if(top==0) return -1;\\n      return arr[--top];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i=0;i<k;i++){\\n          if(i<top){\\n            arr[i]=arr[i]+val;\\n          }\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131752,
                "title": "java-easy-solution",
                "content": "```\\nclass CustomStack {\\n    int size = 0,top=0;\\n   int[] arr = null;\\n    public CustomStack(int maxSize) {\\n        arr=new int[maxSize];\\n        size=maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(top<size){\\n            //++top;\\n            arr[top++]=x;\\n           \\n        }\\n        \\n    }\\n    \\n    public int pop() {\\n        if(top==0) return -1;\\n        \\n        return arr[--top];\\n            \\n        \\n    }\\n    \\n    public void increment(int k, int val) {\\n        int curr=0;\\n        if(arr.length==0) return;\\n        while(curr<k && curr<arr.length){\\n            arr[curr]+=val;\\n            curr++;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n    int size = 0,top=0;\\n   int[] arr = null;\\n    public CustomStack(int maxSize) {\\n        arr=new int[maxSize];\\n        size=maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        if(top<size){\\n            //++top;\\n            arr[top++]=x;\\n           \\n        }\\n        \\n    }\\n    \\n    public int pop() {\\n        if(top==0) return -1;\\n        \\n        return arr[--top];\\n            \\n        \\n    }\\n    \\n    public void increment(int k, int val) {\\n        int curr=0;\\n        if(arr.length==0) return;\\n        while(curr<k && curr<arr.length){\\n            arr[curr]+=val;\\n            curr++;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124169,
                "title": "my-simple-python-solution",
                "content": "\\'\\'\\'\\n\\t\\n\\tclass CustomStack:\\n\\n\\t\\tdef __init__(self, maxSize: int):\\n\\t\\t\\tself.maxSize = maxSize\\n\\t\\t\\tself.stack = []\\n\\n\\t\\tdef push(self, x: int) -> None:\\n\\t\\t\\tif len(self.stack) < self.maxSize:\\n\\t\\t\\t\\tself.stack.append(x)\\n\\n\\t\\tdef pop(self) -> int:\\n\\t\\t\\tif len(self.stack) > 0:\\n\\t\\t\\t\\tthing_to_return = self.stack[-1]\\n\\t\\t\\t\\tself.stack.pop()\\n\\t\\t\\t\\treturn thing_to_return\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn -1\\n\\n\\t\\tdef increment(self, k: int, val: int) -> None:  # for first k items + val to them\\n\\t\\t\\tif k > len(self.stack):\\n\\t\\t\\t\\tk = len(self.stack)  # if k > than make k the same, it will increment all in stack but won\\'t go out of range\\n\\n\\t\\t\\tfor i in range(0, k):\\n\\t\\t\\t\\tself.stack[i] += val\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\t\\n\\tclass CustomStack:\\n\\n\\t\\tdef __init__(self, maxSize: int):\\n\\t\\t\\tself.maxSize = maxSize\\n\\t\\t\\tself.stack = []\\n\\n\\t\\tdef push(self, x: int) -> None:\\n\\t\\t\\tif len(self.stack) < self.maxSize:\\n\\t\\t\\t\\tself.stack.append(x)\\n\\n\\t\\tdef pop(self) -> int:\\n\\t\\t\\tif len(self.stack) > 0:\\n\\t\\t\\t\\tthing_to_return = self.stack[-1]\\n\\t\\t\\t\\tself.stack.pop()\\n\\t\\t\\t\\treturn thing_to_return\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn -1\\n\\n\\t\\tdef increment(self, k: int, val: int) -> None:  # for first k items + val to them\\n\\t\\t\\tif k > len(self.stack):\\n\\t\\t\\t\\tk = len(self.stack)  # if k > than make k the same, it will increment all in stack but won\\'t go out of range\\n\\n\\t\\t\\tfor i in range(0, k):\\n\\t\\t\\t\\tself.stack[i] += val\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1103612,
                "title": "swift-100ms-beats-100-easy-solution",
                "content": "```swift\\n// in the worst scenarios, we are calling storage.count which is an O(n) operation\\n// you could argue if that is constant, given that we know `maxSize`\\nfinal class CustomStack {\\n    \\n    private let maxSize: Int\\n    private var _storage: [Int]\\n\\n    init(_ maxSize: Int) {\\n        self.maxSize = maxSize\\n        _storage = []\\n        _storage.reserveCapacity(maxSize)\\n    }\\n    // O(n) where n = maxSize\\n    func push(_ x: Int) {\\n        guard _storage.count < maxSize else { return }\\n        _storage.append(x)\\n    }\\n    // O(1)\\n    func pop() -> Int {\\n        guard let popped = _storage.popLast() else { return -1 }\\n        return popped\\n    }\\n    // O(n) where n = maxSize \\n    func increment(_ k: Int, _ val: Int) {\\n        let K = min(k, _storage.count)\\n        for i in 0..<K {\\n            _storage[i] += val\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\n// in the worst scenarios, we are calling storage.count which is an O(n) operation\\n// you could argue if that is constant, given that we know `maxSize`\\nfinal class CustomStack {\\n    \\n    private let maxSize: Int\\n    private var _storage: [Int]\\n\\n    init(_ maxSize: Int) {\\n        self.maxSize = maxSize\\n        _storage = []\\n        _storage.reserveCapacity(maxSize)\\n    }\\n    // O(n) where n = maxSize\\n    func push(_ x: Int) {\\n        guard _storage.count < maxSize else { return }\\n        _storage.append(x)\\n    }\\n    // O(1)\\n    func pop() -> Int {\\n        guard let popped = _storage.popLast() else { return -1 }\\n        return popped\\n    }\\n    // O(n) where n = maxSize \\n    func increment(_ k: Int, _ val: Int) {\\n        let K = min(k, _storage.count)\\n        for i in 0..<K {\\n            _storage[i] += val\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050030,
                "title": "simple-java-easy-understanding",
                "content": "```\\nclass CustomStack {\\n\\tint[] stack;\\n    int index;\\n   \\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];\\n        index=0;\\n    }\\n\\n    public void push(int x) {\\n       if (index<stack.length){\\n            stack[index++] = x;\\n        }\\n    }\\n\\n    public int pop() {\\n        if(index == 0) return -1;\\n        return stack[--index];\\n    }\\n\\n    public void increment(int k, int val) {\\n        if(index == 0) return;\\n        for(int i = 0; i<k && i<index;i++)\\n            stack[i] = stack[i] + val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass CustomStack {\\n\\tint[] stack;\\n    int index;\\n   \\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];\\n        index=0;\\n    }\\n\\n    public void push(int x) {\\n       if (index<stack.length){\\n            stack[index++] = x;\\n        }\\n    }\\n\\n    public int pop() {\\n        if(index == 0) return -1;\\n        return stack[--index];\\n    }\\n\\n    public void increment(int k, int val) {\\n        if(index == 0) return;\\n        for(int i = 0; i<k && i<index;i++)\\n            stack[i] = stack[i] + val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1049998,
                "title": "c-o-1",
                "content": "```\\nclass CustomStack {\\nprivate:\\n    vector<int>stack,inc;\\n    int n;\\npublic:\\n    CustomStack(int maxSize):n(maxSize) {\\n        \\n    }\\n    \\n    void push(int x) {\\n        if(n==stack.size())\\n            return;\\n        stack.push_back(x);\\n        inc.push_back(0);\\n    }\\n    \\n    int pop() {\\n        int i=stack.size()-1;\\n        if(i<0)\\n        {\\n            return -1;\\n        }\\n        if(i>0)\\n        {\\n            inc[i-1]+=inc[i];\\n        }\\n        int res=stack[i]+inc[i];\\n        stack.pop_back();\\n        inc.pop_back();\\n        return res;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int i = min(k, (int)stack.size())-1;\\n        if(i>=0)\\n        {\\n            inc[i]+=val;\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\nprivate:\\n    vector<int>stack,inc;\\n    int n;\\npublic:\\n    CustomStack(int maxSize):n(maxSize) {\\n        \\n    }\\n    \\n    void push(int x) {\\n        if(n==stack.size())\\n            return;\\n        stack.push_back(x);\\n        inc.push_back(0);\\n    }\\n    \\n    int pop() {\\n        int i=stack.size()-1;\\n        if(i<0)\\n        {\\n            return -1;\\n        }\\n        if(i>0)\\n        {\\n            inc[i-1]+=inc[i];\\n        }\\n        int res=stack[i]+inc[i];\\n        stack.pop_back();\\n        inc.pop_back();\\n        return res;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int i = min(k, (int)stack.size())-1;\\n        if(i>=0)\\n        {\\n            inc[i]+=val;\\n        }\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1042120,
                "title": "python-3-lazy-increment-w-o-extra-array",
                "content": "A lazy increment approach, without using another \"shadow\" array/list to keep track of increments.\\nBecause in some cases that would be a waste of memory when the stack size is huge.\\nInstead, only use a dictionay to record increment events.\\n\\n```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self._max_size = maxSize\\n        self._data = []\\n        self._curr_incr = 0\\n        self._incr_dict = defaultdict(int)\\n        \\n\\n    def push(self, x: int) -> None:\\n        if len(self._data) == self._max_size:\\n            return\\n        if self._curr_incr != 0:\\n            self._incr_dict[len(self._data)] += self._curr_incr\\n            self._curr_incr = 0\\n        self._data.append(x)\\n\\n    def pop(self) -> int:\\n        if not self._data:\\n            return -1\\n        curr_size = len(self._data)\\n        if curr_size in self._incr_dict:\\n            self._curr_incr += self._incr_dict[curr_size]\\n            del self._incr_dict[curr_size]\\n        res = self._data.pop() + self._curr_incr\\n        if not self._data:\\n            self._curr_incr = 0\\n        return res\\n\\n    def increment(self, k: int, val: int) -> None:\\n        k = min(k, len(self._data))\\n        if k == 0:\\n            return\\n        self._incr_dict[k] += val\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self._max_size = maxSize\\n        self._data = []\\n        self._curr_incr = 0\\n        self._incr_dict = defaultdict(int)\\n        \\n\\n    def push(self, x: int) -> None:\\n        if len(self._data) == self._max_size:\\n            return\\n        if self._curr_incr != 0:\\n            self._incr_dict[len(self._data)] += self._curr_incr\\n            self._curr_incr = 0\\n        self._data.append(x)\\n\\n    def pop(self) -> int:\\n        if not self._data:\\n            return -1\\n        curr_size = len(self._data)\\n        if curr_size in self._incr_dict:\\n            self._curr_incr += self._incr_dict[curr_size]\\n            del self._incr_dict[curr_size]\\n        res = self._data.pop() + self._curr_incr\\n        if not self._data:\\n            self._curr_incr = 0\\n        return res\\n\\n    def increment(self, k: int, val: int) -> None:\\n        k = min(k, len(self._data))\\n        if k == 0:\\n            return\\n        self._incr_dict[k] += val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1020986,
                "title": "python3-simple-solution",
                "content": "```\\nclass CustomStack:\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.size = maxSize \\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.size:\\n            self.stack.append(x)\\n    def pop(self) -> int:\\n        if self.stack:\\n            return self.stack.pop()\\n        else:\\n            return -1\\n    def increment(self, k: int, val: int) -> None:\\n        for i,j in enumerate(self.stack[:k]):\\n            self.stack[i] += val\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass CustomStack:\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.size = maxSize \\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.size:\\n            self.stack.append(x)\\n    def pop(self) -> int:\\n        if self.stack:\\n            return self.stack.pop()\\n        else:\\n            return -1\\n    def increment(self, k: int, val: int) -> None:\\n        for i,j in enumerate(self.stack[:k]):\\n            self.stack[i] += val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999867,
                "title": "c-o-1-solution-faster-than-97",
                "content": "```\\nclass CustomStack {\\npublic:\\n    \\n    vector<int>incr;\\n    vector<int>st;\\n    int i = -1;\\n    CustomStack(int N) {\\n        incr.resize(N);\\n        fill(incr.begin(),incr.end(),0);\\n        st.resize(N);\\n        fill(st.begin(),st.end(),0);\\n    }\\n    \\n    void push(int x) {\\n        int y = st.size() -1;\\n        if (i < y){\\n            st[++i] = x;\\n        }\\n    }\\n    \\n    int pop() {\\n        if(i<0)return -1;\\n        int x = st[i] + incr[i];\\n\\t\\t//incr works like reverse prefix sum. As pop operations are called, incr[i] keeps attaining its correct value\\n        if(i>0)\\n        \\tincr[i-1] += incr[i];\\n        incr[i]=0;\\n        i--;\\n        return x;\\n    }\\n    \\n    void increment(int k, int val) {\\n        k = min(k-1,i);\\n        if(k>=0)\\n        \\tincr[k]+=val;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\npublic:\\n    \\n    vector<int>incr;\\n    vector<int>st;\\n    int i = -1;\\n    CustomStack(int N) {\\n        incr.resize(N);\\n        fill(incr.begin(),incr.end(),0);\\n        st.resize(N);\\n        fill(st.begin(),st.end(),0);\\n    }\\n    \\n    void push(int x) {\\n        int y = st.size() -1;\\n        if (i < y){\\n            st[++i] = x;\\n        }\\n    }\\n    \\n    int pop() {\\n        if(i<0)return -1;\\n        int x = st[i] + incr[i];\\n\\t\\t//incr works like reverse prefix sum. As pop operations are called, incr[i] keeps attaining its correct value\\n        if(i>0)\\n        \\tincr[i-1] += incr[i];\\n        incr[i]=0;\\n        i--;\\n        return x;\\n    }\\n    \\n    void increment(int k, int val) {\\n        k = min(k-1,i);\\n        if(k>=0)\\n        \\tincr[k]+=val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 977212,
                "title": "javascript-solution-o-1-all-methods",
                "content": "Time complexity: O(1) for push, pop, increment.\\nSpace complexity: O(N)\\n```\\n/**\\n * @param {number} maxSize\\n */\\nvar CustomStack = function(maxSize) {\\n    this.maxSize = maxSize;\\n    this.stack = [];\\n    this.incrementDP = new Array(maxSize);\\n    this.incrementDP.fill(0);\\n};\\n\\n/** \\n * @param {number} x\\n * @return {void}\\n */\\nCustomStack.prototype.push = function(x) {\\n    if (this.stack.length < this.maxSize) {\\n      this.stack.push(x);\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nCustomStack.prototype.pop = function() {\\n    if (!this.stack.length) return -1;\\n    let result = this.stack.pop();\\n    const length = this.stack.length;\\n    if (this.incrementDP[length]) {\\n      result += this.incrementDP[length];\\n      if (length > 0) {\\n        this.incrementDP[length - 1] += this.incrementDP[length]\\n      }\\n      this.incrementDP[length] = 0;\\n    }\\n    return result;\\n};\\n\\n/** \\n * @param {number} k \\n * @param {number} val\\n * @return {void}\\n */\\nCustomStack.prototype.increment = function(k, val) {\\n    const t = Math.min(k, this.stack.length);\\n    this.incrementDP[t - 1] += val;\\n};\\n\\n/** \\n * Your CustomStack object will be instantiated and called as such:\\n * var obj = new CustomStack(maxSize)\\n * obj.push(x)\\n * var param_2 = obj.pop()\\n * obj.increment(k,val)\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} maxSize\\n */\\nvar CustomStack = function(maxSize) {\\n    this.maxSize = maxSize;\\n    this.stack = [];\\n    this.incrementDP = new Array(maxSize);\\n    this.incrementDP.fill(0);\\n};\\n\\n/** \\n * @param {number} x\\n * @return {void}\\n */\\nCustomStack.prototype.push = function(x) {\\n    if (this.stack.length < this.maxSize) {\\n      this.stack.push(x);\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nCustomStack.prototype.pop = function() {\\n    if (!this.stack.length) return -1;\\n    let result = this.stack.pop();\\n    const length = this.stack.length;\\n    if (this.incrementDP[length]) {\\n      result += this.incrementDP[length];\\n      if (length > 0) {\\n        this.incrementDP[length - 1] += this.incrementDP[length]\\n      }\\n      this.incrementDP[length] = 0;\\n    }\\n    return result;\\n};\\n\\n/** \\n * @param {number} k \\n * @param {number} val\\n * @return {void}\\n */\\nCustomStack.prototype.increment = function(k, val) {\\n    const t = Math.min(k, this.stack.length);\\n    this.incrementDP[t - 1] += val;\\n};\\n\\n/** \\n * Your CustomStack object will be instantiated and called as such:\\n * var obj = new CustomStack(maxSize)\\n * obj.push(x)\\n * var param_2 = obj.pop()\\n * obj.increment(k,val)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 945413,
                "title": "java-solution",
                "content": "```\\nclass CustomStack {\\n    private int[] array;\\n    private int size;\\n\\n    public CustomStack(int maxSize) {\\n        this.array = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n        if (size < array.length) {\\n            array[size++] = x;            \\n        }\\n    }\\n    \\n    public int pop() {\\n        return size > 0 ? array[--size] : -1;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i = 0 ; i < Math.min(k, size) ; i++) {\\n            array[i] += val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n    private int[] array;\\n    private int size;\\n\\n    public CustomStack(int maxSize) {\\n        this.array = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n        if (size < array.length) {\\n            array[size++] = x;            \\n        }\\n    }\\n    \\n    public int pop() {\\n        return size > 0 ? array[--size] : -1;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        for(int i = 0 ; i < Math.min(k, size) ; i++) {\\n            array[i] += val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894044,
                "title": "java-3ms-100-faster-o-1-timecomplexity",
                "content": "```\\n    int[] increments;\\n    int[] stack;\\n    int stackIndex = -1;\\n\\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];\\n        increments = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n        if (stackIndex < stack.length -1)\\n        {\\n            stack[++stackIndex] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if (stackIndex < 0) return -1;\\n        int x = stack[stackIndex] + increments[stackIndex];\\n        if (stackIndex > 0)\\n        {\\n            increments[stackIndex -1] = increments[stackIndex -1] + increments[stackIndex];\\n        }\\n         increments[stackIndex] = 0;\\n        stackIndex--;\\n         return x;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        k = Math.min(k -1,stackIndex);\\n        if (k >=0)\\n        increments[k] += val;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int[] increments;\\n    int[] stack;\\n    int stackIndex = -1;\\n\\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];\\n        increments = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n        if (stackIndex < stack.length -1)\\n        {\\n            stack[++stackIndex] = x;\\n        }\\n    }\\n    \\n    public int pop() {\\n        if (stackIndex < 0) return -1;\\n        int x = stack[stackIndex] + increments[stackIndex];\\n        if (stackIndex > 0)\\n        {\\n            increments[stackIndex -1] = increments[stackIndex -1] + increments[stackIndex];\\n        }\\n         increments[stackIndex] = 0;\\n        stackIndex--;\\n         return x;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        k = Math.min(k -1,stackIndex);\\n        if (k >=0)\\n        increments[k] += val;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 884037,
                "title": "o-1-time-and-o-n-space",
                "content": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        \\n        \\n        self.stack = [-float(\\'inf\\')] * maxSize\\n        self.count = 0\\n        self.maxsize = maxSize\\n        \\n\\n    def push(self, x: int) -> None:\\n        \\n        \\n        if(self.count < self.maxsize ):\\n            self.stack[self.count] = x\\n            self.count +=1\\n        \\n\\n    def pop(self) -> int:\\n        \\n    \\n        if(self.count - 1 >= 0):\\n            \\n            el = self.stack[self.count-1]\\n            self.count -=1\\n            \\n            return el\\n        \\n        return -1\\n            \\n        \\n\\n    def increment(self, k: int, val: int) -> None:\\n        \\n        for i in range(min(k,self.count)):\\n            self.stack[i] += val\\n        \\n\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        \\n        \\n        self.stack = [-float(\\'inf\\')] * maxSize\\n        self.count = 0\\n        self.maxsize = maxSize\\n        \\n\\n    def push(self, x: int) -> None:\\n        \\n        \\n        if(self.count < self.maxsize ):\\n            self.stack[self.count] = x\\n            self.count +=1\\n        \\n\\n    def pop(self) -> int:\\n        \\n    \\n        if(self.count - 1 >= 0):\\n            \\n            el = self.stack[self.count-1]\\n            self.count -=1\\n            \\n            return el\\n        \\n        return -1\\n            \\n        \\n\\n    def increment(self, k: int, val: int) -> None:\\n        \\n        for i in range(min(k,self.count)):\\n            self.stack[i] += val\\n        \\n\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881547,
                "title": "python3-customstack-design-with-o-1-operation-time-o-n-space",
                "content": "```\\nclass CustomStack:\\n    def __init__(self, maxSize: int):\\n        self.increament_at = collections.defaultdict(lambda: 0)\\n        self.stack = []\\n        self.max_size = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.max_size:\\n            self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        if not self.stack:\\n            return -1\\n    \\n        tmp = self.increament_at[len(self.stack) - 1]\\n        self.increament_at[len(self.stack) - 2] += tmp\\n        self.increament_at[len(self.stack) - 1] = 0\\n        return self.stack.pop() + tmp\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if len(self.stack) < k:\\n            self.increament_at[len(self.stack) - 1] += val\\n        else:\\n            self.increament_at[k-1] += val\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass CustomStack:\\n    def __init__(self, maxSize: int):\\n        self.increament_at = collections.defaultdict(lambda: 0)\\n        self.stack = []\\n        self.max_size = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.max_size:\\n            self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        if not self.stack:\\n            return -1\\n    \\n        tmp = self.increament_at[len(self.stack) - 1]\\n        self.increament_at[len(self.stack) - 2] += tmp\\n        self.increament_at[len(self.stack) - 1] = 0\\n        return self.stack.pop() + tmp\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if len(self.stack) < k:\\n            self.increament_at[len(self.stack) - 1] += val\\n        else:\\n            self.increament_at[k-1] += val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 862963,
                "title": "straightforward-double-linkedlist",
                "content": "```\\nclass CustomStack {\\n    \\n    ListNode head;\\n    ListNode tail;\\n    int size;\\n    int max;\\n\\n    public CustomStack(int maxSize) {\\n        \\n        head = new ListNode(-1);\\n        tail = new ListNode(-1);\\n        head.next = tail;\\n        tail.prev = head;\\n        size = 0;\\n        max = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        \\n        if(size == max) return;\\n        \\n        ListNode first = head.next;\\n        ListNode pushed_in = new ListNode(x);\\n        head.next = pushed_in;\\n        pushed_in.next = first;\\n        first.prev = pushed_in;\\n        pushed_in.prev = head;\\n        size++;\\n    }\\n    \\n    public int pop() {\\n        \\n        if(size == 0)   return -1;\\n        ListNode first = head.next;\\n        ListNode second = first.next;\\n        head.next = second;\\n        second.prev = head;\\n        size--;\\n        \\n        return first.val;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        \\n        ListNode curr = tail.prev;\\n        int i = 0;\\n        while(curr != head && i < Math.min(k, size))\\n        {\\n            curr.addVal(val);\\n            curr = curr.prev;\\n            i++;\\n        }\\n    }\\n}\\n\\nclass ListNode {\\n    \\n    int val;\\n    ListNode prev;\\n    ListNode next;\\n    \\n    public ListNode(int val) {\\n        \\n        this.val = val;\\n        this.prev = null;\\n        this.next = null;\\n    }\\n    \\n    public void addVal(int increment) {\\n        \\n        this.val += increment;\\n    } \\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n    \\n    ListNode head;\\n    ListNode tail;\\n    int size;\\n    int max;\\n\\n    public CustomStack(int maxSize) {\\n        \\n        head = new ListNode(-1);\\n        tail = new ListNode(-1);\\n        head.next = tail;\\n        tail.prev = head;\\n        size = 0;\\n        max = maxSize;\\n    }\\n    \\n    public void push(int x) {\\n        \\n        if(size == max) return;\\n        \\n        ListNode first = head.next;\\n        ListNode pushed_in = new ListNode(x);\\n        head.next = pushed_in;\\n        pushed_in.next = first;\\n        first.prev = pushed_in;\\n        pushed_in.prev = head;\\n        size++;\\n    }\\n    \\n    public int pop() {\\n        \\n        if(size == 0)   return -1;\\n        ListNode first = head.next;\\n        ListNode second = first.next;\\n        head.next = second;\\n        second.prev = head;\\n        size--;\\n        \\n        return first.val;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        \\n        ListNode curr = tail.prev;\\n        int i = 0;\\n        while(curr != head && i < Math.min(k, size))\\n        {\\n            curr.addVal(val);\\n            curr = curr.prev;\\n            i++;\\n        }\\n    }\\n}\\n\\nclass ListNode {\\n    \\n    int val;\\n    ListNode prev;\\n    ListNode next;\\n    \\n    public ListNode(int val) {\\n        \\n        this.val = val;\\n        this.prev = null;\\n        this.next = null;\\n    }\\n    \\n    public void addVal(int increment) {\\n        \\n        this.val += increment;\\n    } \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827087,
                "title": "ruby-all-ops-o-1-100",
                "content": "If we update the corresponging elements in stacks whenever increment(k, val) methos is call, thats gonna take O(k) time. Instead we can keep a hashmap of index k with the value it needs to increment with bottom k stack elements. This value can be added to the stack element whenever it is popped out. and the same valy can be propagated to lower elements\\n\\n```\\nclass CustomStack\\n    \\n    attr_accessor :stack, :hash, :max_size\\n=begin\\n    :type max_size: Integer\\n=end\\n    def initialize(max_size)\\n        self.stack = []\\n        self.hash = Hash.new(0)\\n        self.max_size = max_size\\n    end\\n\\n\\n=begin\\n    :type x: Integer\\n    :rtype: Void\\n=end\\n    def push(x)\\n        if stack.size < max_size\\n            stack.push(x)\\n        end\\n    end\\n\\n\\n=begin\\n    :rtype: Integer\\n=end\\n    def pop()\\n        if stack.empty?\\n            return -1\\n        else\\n            increment_val = 0\\n            if hash[stack.size] > 0\\n                increment_val += hash[stack.size]\\n                hash.delete(stack.size)\\n                hash[stack.size-1] += increment_val\\n            end\\n            stack.pop + increment_val\\n        end\\n    end\\n\\n\\n=begin\\n    :type k: Integer\\n    :type val: Integer\\n    :rtype: Void\\n=end\\n    def increment(k, val)\\n        return if stack.empty?\\n        k = [k, stack.size].min\\n        hash[k] += val\\n    end\\n\\n\\nend\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack.new(max_size)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k, val)\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack\\n    \\n    attr_accessor :stack, :hash, :max_size\\n=begin\\n    :type max_size: Integer\\n=end\\n    def initialize(max_size)\\n        self.stack = []\\n        self.hash = Hash.new(0)\\n        self.max_size = max_size\\n    end\\n\\n\\n=begin\\n    :type x: Integer\\n    :rtype: Void\\n=end\\n    def push(x)\\n        if stack.size < max_size\\n            stack.push(x)\\n        end\\n    end\\n\\n\\n=begin\\n    :rtype: Integer\\n=end\\n    def pop()\\n        if stack.empty?\\n            return -1\\n        else\\n            increment_val = 0\\n            if hash[stack.size] > 0\\n                increment_val += hash[stack.size]\\n                hash.delete(stack.size)\\n                hash[stack.size-1] += increment_val\\n            end\\n            stack.pop + increment_val\\n        end\\n    end\\n\\n\\n=begin\\n    :type k: Integer\\n    :type val: Integer\\n    :rtype: Void\\n=end\\n    def increment(k, val)\\n        return if stack.empty?\\n        k = [k, stack.size].min\\n        hash[k] += val\\n    end\\n\\n\\nend\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack.new(max_size)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k, val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826026,
                "title": "c-all-operations-in-o-1-100",
                "content": "\\n\\nclass CustomStack {\\n\\n\\n\\npublic:\\n\\n\\t// value at top and amount by how much it should be incremented\\n    \\n\\tvector<pair<int,int>> st;\\n    \\n    int maxSize;\\n    \\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(st.size()==maxSize){\\n            return;\\n        }\\n        st.push_back({x,0});\\n    }\\n    \\n    int pop() {\\n        if(st.size()==0)\\n            return -1;\\n        int size = st.size();\\n        if(size!=1){\\n            st[size-2].second += st[size-1].second;\\n        }\\n        int val =  st[size-1].first+st[size-1].second;\\n        st.pop_back();\\n        return val;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(st.size()==0){\\n            return;\\n        }\\n        if(st.size()>=k){\\n            st[k-1].second+=val;\\n        }else{\\n            st[st.size()-1].second+=val;\\n        }\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "\\n\\nclass CustomStack {\\n\\n\\n\\npublic:\\n\\n\\t// value at top and amount by how much it should be incremented\\n    \\n\\tvector<pair<int,int>> st;\\n    \\n    int maxSize;\\n    \\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(st.size()==maxSize){\\n            return;\\n        }\\n        st.push_back({x,0});\\n    }\\n    \\n    int pop() {\\n        if(st.size()==0)\\n            return -1;\\n        int size = st.size();\\n        if(size!=1){\\n            st[size-2].second += st[size-1].second;\\n        }\\n        int val =  st[size-1].first+st[size-1].second;\\n        st.pop_back();\\n        return val;\\n    }\\n    \\n    void increment(int k, int val) {\\n        if(st.size()==0){\\n            return;\\n        }\\n        if(st.size()>=k){\\n            st[k-1].second+=val;\\n        }else{\\n            st[st.size()-1].second+=val;\\n        }\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 803496,
                "title": "ultra-simple-cpp-solution-suggestion-for-optimization-are-welcomed",
                "content": "Runtime: 600 ms, faster than 5.38% of C++ online submissions\\nMemory Usage: 21.1 MB, less than 63.83% of C++ online submissions\\n\\n```\\nclass CustomStack {\\npublic:\\n    vector<int> v;\\n    int size=0;\\n    CustomStack(int maxSize) {\\n        \\n        size=maxSize;\\n        v.reserve(maxSize);\\n    }\\n    \\n    void push(int x) {\\n        \\n        if(v.size()<size)\\n            v.push_back(x);\\n    }\\n    \\n    int pop() {\\n        \\n        if(v.size()==0)\\n            return -1;\\n        else\\n        {\\n            int temp=v[v.size()-1];\\n            v.pop_back();\\n            return temp;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        \\n        for(int i=0;i<v.size()&&k-->0;i++)\\n            v[i]+=val;\\n        }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass CustomStack {\\npublic:\\n    vector<int> v;\\n    int size=0;\\n    CustomStack(int maxSize) {\\n        \\n        size=maxSize;\\n        v.reserve(maxSize);\\n    }\\n    \\n    void push(int x) {\\n        \\n        if(v.size()<size)\\n            v.push_back(x);\\n    }\\n    \\n    int pop() {\\n        \\n        if(v.size()==0)\\n            return -1;\\n        else\\n        {\\n            int temp=v[v.size()-1];\\n            v.pop_back();\\n            return temp;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        \\n        for(int i=0;i<v.size()&&k-->0;i++)\\n            v[i]+=val;\\n        }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 792756,
                "title": "simple-easy-solution-by-python-3",
                "content": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.maxSize = maxSize\\n        self.stack = []\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:\\n            self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        return self.stack.pop() if self.stack else -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, len(self.stack))):\\n            self.stack[i] += val\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.maxSize = maxSize\\n        self.stack = []\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.maxSize:\\n            self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        return self.stack.pop() if self.stack else -1\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, len(self.stack))):\\n            self.stack[i] += val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780735,
                "title": "java-5-ms-faster-than-91-04",
                "content": "```\\nclass CustomStack {\\n\\n    int []arr;\\n    int maxSize;\\n    int count;\\n    public CustomStack(int mSize) {\\n        maxSize = mSize;\\n        count = 0;\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int a) {\\n        if(maxSize > count){\\n           arr[count++] = a; \\n        }\\n    }\\n    \\n    public int pop() {\\n        if(count > 0) {\\n            \\n            return arr[--count];\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        \\n        int m = Math.min(k, count);\\n        \\n        for(int i=0; i<m; i++){\\n            arr[i]+=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n\\n    int []arr;\\n    int maxSize;\\n    int count;\\n    public CustomStack(int mSize) {\\n        maxSize = mSize;\\n        count = 0;\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int a) {\\n        if(maxSize > count){\\n           arr[count++] = a; \\n        }\\n    }\\n    \\n    public int pop() {\\n        if(count > 0) {\\n            \\n            return arr[--count];\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        \\n        int m = Math.min(k, count);\\n        \\n        for(int i=0; i<m; i++){\\n            arr[i]+=val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769917,
                "title": "c-simple-solution",
                "content": "```\\nclass CustomStack {\\npublic:\\n    int * m_array;\\n    int m_maxSize;\\n    int m_count;\\n    \\n    CustomStack(int maxSize) : \\n        m_array(new int[maxSize]),\\n        m_maxSize(maxSize),\\n        m_count(0) {\\n        \\n    }\\n    \\n    void push(int x) {\\n        if (m_count < m_maxSize) {\\n            m_array[m_count++] = x;\\n        }\\n    }\\n    \\n    int pop() {\\n        int ret = -1;\\n        if (m_count > 0) {\\n            ret = m_array[--m_count];\\n        }\\n        return ret;\\n    }\\n    \\n    void increment(int k, int val) {\\n        const int upperBound = min(m_count, k);\\n        for (int i = 0; i < upperBound; ++i) {\\n            m_array[i] += val;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\npublic:\\n    int * m_array;\\n    int m_maxSize;\\n    int m_count;\\n    \\n    CustomStack(int maxSize) : \\n        m_array(new int[maxSize]),\\n        m_maxSize(maxSize),\\n        m_count(0) {\\n        \\n    }\\n    \\n    void push(int x) {\\n        if (m_count < m_maxSize) {\\n            m_array[m_count++] = x;\\n        }\\n    }\\n    \\n    int pop() {\\n        int ret = -1;\\n        if (m_count > 0) {\\n            ret = m_array[--m_count];\\n        }\\n        return ret;\\n    }\\n    \\n    void increment(int k, int val) {\\n        const int upperBound = min(m_count, k);\\n        for (int i = 0; i < upperBound; ++i) {\\n            m_array[i] += val;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750827,
                "title": "simple-java-solution",
                "content": "class CustomStack {\\n    int stack[];\\n    int msize = 0;\\n    int ind;\\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];``\\n        msize = maxSize;\\n        ind = -1;\\n    }\\n    \\n    public void push(int x) {\\n        if(ind < msize-1)\\n            stack[++ind] = x;\\n    }\\n    \\n    public int pop() {\\n        if(ind == -1){\\n            return -1;\\n        }\\n        return stack[ind--];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        ind++;\\n        int n = ind > k ? k:ind;\\n        for(int i=0;i<n;i++){\\n            stack[i] = stack[i]+val;\\n        }\\n        \\n        ind--;\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */",
                "solutionTags": [],
                "code": "class CustomStack {\\n    int stack[];\\n    int msize = 0;\\n    int ind;\\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];``\\n        msize = maxSize;\\n        ind = -1;\\n    }\\n    \\n    public void push(int x) {\\n        if(ind < msize-1)\\n            stack[++ind] = x;\\n    }\\n    \\n    public int pop() {\\n        if(ind == -1){\\n            return -1;\\n        }\\n        return stack[ind--];\\n    }\\n    \\n    public void increment(int k, int val) {\\n        ind++;\\n        int n = ind > k ? k:ind;\\n        for(int i=0;i<n;i++){\\n            stack[i] = stack[i]+val;\\n        }\\n        \\n        ind--;\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 726494,
                "title": "c-easiest-explained-solution-with-stack-for-beginners",
                "content": "```\\nclass CustomStack {\\n    int size;\\n    stack<int> st;\\npublic:\\n    CustomStack(int maxSize) {\\n        size=maxSize;  //initializing the size of the stack\\n    }\\n    void push(int x) {\\n        if(st.size()!=size)  //push down the element if the size of stack is less than maxsize\\n        {\\n            st.push(x);   \\n        }            \\n    }\\n    \\n    int pop() {\\n        if(st.size()==0) return -1;  //if stack size is zero then return -1\\n        int temp=st.top();  //storing top element of the stack, for returning later\\n        st.pop();  //delete the top element\\n        return temp;  //return the top element, which we saved earlier\\n    }\\n    \\n    void increment(int k, int val) {\\n        stack <int> temp_stk;  //temporary stack for incrementing the bottom k elements\\n        \\n        while(!st.empty())  //firstly, push all elements of the stack into temporary stack \\n        {\\n            temp_stk.push(st.top());\\n            st.pop();\\n        }\\n        \\n        while(k-- && !temp_stk.empty())  //now if k>0 and any value exist in temporary stack then push it\\'s top element by incrementing the value by val.\\n        {\\n            int temp = temp_stk.top() + val;\\n            st.push(temp);\\n            temp_stk.pop();  // delete the top element of the temporary stack\\n        }\\n        \\n        if(!temp_stk.empty())  //if there exist any element means k become 0, so we will add all remaining elements as it is.\\n        {\\n            while(!temp_stk.empty())\\n            {\\n                int temp = temp_stk.top();\\n                st.push(temp);\\n                temp_stk.pop();\\n            }\\n        }\\n    }\\n};\\n```\\n**For such explained solution don\\'t forget to upvote!!!**",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\n    int size;\\n    stack<int> st;\\npublic:\\n    CustomStack(int maxSize) {\\n        size=maxSize;  //initializing the size of the stack\\n    }\\n    void push(int x) {\\n        if(st.size()!=size)  //push down the element if the size of stack is less than maxsize\\n        {\\n            st.push(x);   \\n        }            \\n    }\\n    \\n    int pop() {\\n        if(st.size()==0) return -1;  //if stack size is zero then return -1\\n        int temp=st.top();  //storing top element of the stack, for returning later\\n        st.pop();  //delete the top element\\n        return temp;  //return the top element, which we saved earlier\\n    }\\n    \\n    void increment(int k, int val) {\\n        stack <int> temp_stk;  //temporary stack for incrementing the bottom k elements\\n        \\n        while(!st.empty())  //firstly, push all elements of the stack into temporary stack \\n        {\\n            temp_stk.push(st.top());\\n            st.pop();\\n        }\\n        \\n        while(k-- && !temp_stk.empty())  //now if k>0 and any value exist in temporary stack then push it\\'s top element by incrementing the value by val.\\n        {\\n            int temp = temp_stk.top() + val;\\n            st.push(temp);\\n            temp_stk.pop();  // delete the top element of the temporary stack\\n        }\\n        \\n        if(!temp_stk.empty())  //if there exist any element means k become 0, so we will add all remaining elements as it is.\\n        {\\n            while(!temp_stk.empty())\\n            {\\n                int temp = temp_stk.top();\\n                st.push(temp);\\n                temp_stk.pop();\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724217,
                "title": "java",
                "content": "```\\nclass CustomStack {\\n    int length;\\n    int stack[];\\n    public CustomStack(int maxSize) {\\n        this.length = -1;\\n        stack = new int[maxSize];\\n    }\\n    public void push(int x) {\\n        if(length < maxSize-1) {\\n            length++;\\n            stack[length] = x;\\n        }\\n        return;\\n    }\\n    public int pop() {\\n        if(length > -1) {\\n            int pop = stack[length];\\n            length--;\\n            return pop;\\n        }\\n        return -1;\\n    }\\n    public void increment(int k, int val) {\\n        if(k > stack.length) {\\n            for(int i = 0; i < stack.length; i++) {\\n                stack[i] += val;\\n            }\\n        } else {\\n            for(int i = k-1; i >= 0; i--) {\\n                stack[i] += val;\\n            }\\n        }   \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomStack {\\n    int length;\\n    int stack[];\\n    public CustomStack(int maxSize) {\\n        this.length = -1;\\n        stack = new int[maxSize];\\n    }\\n    public void push(int x) {\\n        if(length < maxSize-1) {\\n            length++;\\n            stack[length] = x;\\n        }\\n        return;\\n    }\\n    public int pop() {\\n        if(length > -1) {\\n            int pop = stack[length];\\n            length--;\\n            return pop;\\n        }\\n        return -1;\\n    }\\n    public void increment(int k, int val) {\\n        if(k > stack.length) {\\n            for(int i = 0; i < stack.length; i++) {\\n                stack[i] += val;\\n            }\\n        } else {\\n            for(int i = k-1; i >= 0; i--) {\\n                stack[i] += val;\\n            }\\n        }   \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712561,
                "title": "python-3-o-1-single-stack-with-successive-differences",
                "content": "Here\\'s my personal solution to this problem. This uses a single stack rather than two, as some other solutions presented, and all operations are O(1).\\n\\nThe idea of this algorithm is to keep the top-most value of the stack exact, then keep only successive differences with their next values in the lower values.\\n\\nHere\\'s an example:\\n\\n* `my_stack.push(5)`: `my_stack.stack == [5]`\\n* `my_stack.push(3)`: `my_stack.stack == [2, 3]`. Here, `5 = 3 + 2`.\\n* `my_stack.push(7)`: `my_stack.stack == [2, -4, 7]`. Here, `3 = 7 + (-4)`.\\n\\nWith this approach, we only have to increase the `k`-th value of the stack to increment all values between `0` and `k`, because the difference will be kept down when popping the values.\\n\\nHere\\'s the implementation:\\n\\n```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.max_size = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) >= self.max_size:\\n            return\\n\\t\\t# Update the previous last value to become the difference with the new last value.\\n        if self.stack:\\n            self.stack[-1] -= x\\n        self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        if not self.stack:\\n            return -1\\n        val = self.stack.pop()\\n\\t\\t# Update the new last value by adding the popped value to retrieve its real value.\\n        if self.stack:\\n            self.stack[-1] += val\\n        return val\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if self.stack:\\n            self.stack[min(k - 1, len(self.stack) - 1)] += val\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.max_size = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) >= self.max_size:\\n            return\\n\\t\\t# Update the previous last value to become the difference with the new last value.\\n        if self.stack:\\n            self.stack[-1] -= x\\n        self.stack.append(x)\\n\\n    def pop(self) -> int:\\n        if not self.stack:\\n            return -1\\n        val = self.stack.pop()\\n\\t\\t# Update the new last value by adding the popped value to retrieve its real value.\\n        if self.stack:\\n            self.stack[-1] += val\\n        return val\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if self.stack:\\n            self.stack[min(k - 1, len(self.stack) - 1)] += val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 710036,
                "title": "python-3-solution-faster-than-99-7",
                "content": "```\\ndef __init__(self, maxSize: int):\\n\\tself.stack = []\\n\\tself.size, self.limit = 0, maxSize\\n\\n\\ndef push(self, x: int) -> None:\\n\\tif self.size==self.limit:\\n\\t\\treturn\\n\\tself.stack.append([x, 0])\\n\\tself.size+=1\\n\\ndef pop(self) -> int:\\n\\tif self.size==0:\\n\\t\\treturn -1\\n\\n\\tpopped, increment = self.stack.pop()\\n\\tself.size-=1\\n\\tif self.size:\\n\\t\\tself.stack[-1][1] +=increment\\n\\n\\treturn popped+increment\\n\\ndef increment(self, k: int, val: int) -> None:\\n\\n\\tk = min(self.size, k)\\n\\tif k:\\n\\t\\tself.stack[k-1][1] +=val\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef __init__(self, maxSize: int):\\n\\tself.stack = []\\n\\tself.size, self.limit = 0, maxSize\\n\\n\\ndef push(self, x: int) -> None:\\n\\tif self.size==self.limit:\\n\\t\\treturn\\n\\tself.stack.append([x, 0])\\n\\tself.size+=1\\n\\ndef pop(self) -> int:\\n\\tif self.size==0:\\n\\t\\treturn -1\\n\\n\\tpopped, increment = self.stack.pop()\\n\\tself.size-=1\\n\\tif self.size:\\n\\t\\tself.stack[-1][1] +=increment\\n\\n\\treturn popped+increment\\n\\ndef increment(self, k: int, val: int) -> None:\\n\\n\\tk = min(self.size, k)\\n\\tif k:\\n\\t\\tself.stack[k-1][1] +=val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 702921,
                "title": "python-3-lazy-increment-o-1-for-all-operations",
                "content": "In stack, we store the exact value `x`, and the addition value `dx` from the increment operation.\\n- Everytime when we `pop()`, the current top-of-stack would \"inherit\" the `dx` of the previous top-of-stack.\\n- Everytime when we `increment()`, we add that addition value to the `dx` for the correct index.\\n\\n```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.size = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.size:\\n            self.stack.append([x, 0])\\n\\n    def pop(self) -> int:\\n        if not self.stack:\\n            return -1\\n        x, dx = self.stack.pop()\\n        if self.stack:\\n            self.stack[-1][-1] += dx\\n        return x + dx\\n        \\n    def increment(self, k: int, val: int) -> None:\\n        if self.stack:\\n            index = min(len(self.stack), k) - 1\\n            self.stack[index][-1] += val\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.stack = []\\n        self.size = maxSize\\n\\n    def push(self, x: int) -> None:\\n        if len(self.stack) < self.size:\\n            self.stack.append([x, 0])\\n\\n    def pop(self) -> int:\\n        if not self.stack:\\n            return -1\\n        x, dx = self.stack.pop()\\n        if self.stack:\\n            self.stack[-1][-1] += dx\\n        return x + dx\\n        \\n    def increment(self, k: int, val: int) -> None:\\n        if self.stack:\\n            index = min(len(self.stack), k) - 1\\n            self.stack[index][-1] += val\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702552,
                "title": "c-very-simple-using-vectors",
                "content": "```\\n vector<int> vec;\\n    int max_size;\\n    CustomStack(int maxSize) {\\n        max_size = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(vec.size() < max_size)\\n            vec.push_back(x);\\n    }\\n    \\n    int pop() {\\n        int val= -1;\\n        if(vec.size()>0)\\n        {\\n            val = vec[vec.size()-1];\\n            vec.erase(vec.begin()+vec.size()-1);\\n        }\\n        return val;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int increment_count;\\n        increment_count = (k>=vec.size()? vec.size() : k);\\n        for(int i=0; i<increment_count; i++)\\n            vec[i] = vec[i]+val;\\n    }\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n vector<int> vec;\\n    int max_size;\\n    CustomStack(int maxSize) {\\n        max_size = maxSize;\\n    }\\n    \\n    void push(int x) {\\n        if(vec.size() < max_size)\\n            vec.push_back(x);\\n    }\\n    \\n    int pop() {\\n        int val= -1;\\n        if(vec.size()>0)\\n        {\\n            val = vec[vec.size()-1];\\n            vec.erase(vec.begin()+vec.size()-1);\\n        }\\n        return val;\\n    }\\n    \\n    void increment(int k, int val) {\\n        int increment_count;\\n        increment_count = (k>=vec.size()? vec.size() : k);\\n        for(int i=0; i<increment_count; i++)\\n            vec[i] = vec[i]+val;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 614410,
                "title": "cpp-simple-easy-list-solution",
                "content": "```\\nclass CustomStack {\\npublic:\\n    int c=0;\\n    list<int> l;\\n    CustomStack(int maxSize) {\\n        c=maxSize;\\n        l.clear();\\n    }\\n    \\n    void push(int x) {\\n        if(l.size()<c){\\n            l.push_front(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(!l.empty()){\\n            int x=l.front();\\n            l.pop_front();\\n            return x;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        auto x=l.rbegin();\\n        while(x!=l.rend()&&k>0){\\n            *x+=val;\\n            x++;\\n            k--;\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomStack {\\npublic:\\n    int c=0;\\n    list<int> l;\\n    CustomStack(int maxSize) {\\n        c=maxSize;\\n        l.clear();\\n    }\\n    \\n    void push(int x) {\\n        if(l.size()<c){\\n            l.push_front(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(!l.empty()){\\n            int x=l.front();\\n            l.pop_front();\\n            return x;\\n        }\\n        return -1;\\n    }\\n    \\n    void increment(int k, int val) {\\n        auto x=l.rbegin();\\n        while(x!=l.rend()&&k>0){\\n            *x+=val;\\n            x++;\\n            k--;\\n        }\\n    }\\n};\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack* obj = new CustomStack(maxSize);\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * obj->increment(k,val);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570462,
                "title": "c-o-1-push-pop-and-increment-using-two-arrays",
                "content": "In this approach I used two arrays each of size maxSize. One stores the values the other one stores the increments at the k\\'th number.\\nThis approach can be further optimized by using a linked list instead of an array. Especially in scenarios where maxSize is much larger \\nthan the actual number of elements being on the stack a performance boost will be notable.\\n\\n```\\npublic class CustomStack {\\n    private int[] _arr;\\n    private int[] _inc;\\n    private int _count;\\n    \\n    public CustomStack(int maxSize) {\\n        _arr = new int[maxSize];\\n        _inc = new int[maxSize];\\n    }\\n    \\n    public void Push(int x) {\\n        if (_count >= _arr.Length)\\n            return;\\n        _arr[_count++] = x;\\n    }\\n    \\n    public int Pop() {\\n        if (_count == 0)\\n            return -1;\\n        \\n        var inc = _inc[--_count];\\n        if (_count - 1 >= 0) _inc[_count - 1] += _inc[_count];\\n        _inc[_count] = 0;\\n        \\n        return _arr[_count] + inc;\\n    }\\n    \\n    public void Increment(int k, int val) {\\n        if (k == 0 || _count == 0) return;\\n        _inc[Math.Min(k, _count) - 1] += val;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class CustomStack {\\n    private int[] _arr;\\n    private int[] _inc;\\n    private int _count;\\n    \\n    public CustomStack(int maxSize) {\\n        _arr = new int[maxSize];\\n        _inc = new int[maxSize];\\n    }\\n    \\n    public void Push(int x) {\\n        if (_count >= _arr.Length)\\n            return;\\n        _arr[_count++] = x;\\n    }\\n    \\n    public int Pop() {\\n        if (_count == 0)\\n            return -1;\\n        \\n        var inc = _inc[--_count];\\n        if (_count - 1 >= 0) _inc[_count - 1] += _inc[_count];\\n        _inc[_count] = 0;\\n        \\n        return _arr[_count] + inc;\\n    }\\n    \\n    public void Increment(int k, int val) {\\n        if (k == 0 || _count == 0) return;\\n        _inc[Math.Min(k, _count) - 1] += val;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557241,
                "title": "javascript-without-push-or-pop",
                "content": "I saw a few JavaScript solutions that were using .pop() and .push(). While they are available methods that really doesn\\'t show that someone in JavaScript actually knows how .push() and .pop() work. \\n\\nWhen you attempt to write a solution without those functions you\\'ll learn more about how arrays work behind the scenes:\\n\\nHere\\'s more info:\\nhttps://stackoverflow.com/questions/27386264/how-does-the-javascript-array-push-code-work-internally\\n\\nYou\\'ll note that when I add an element in .push(), I\\'m not having to adjust the .length property. Whereas when I delete an element manually I must update it. Run this in debug mode in your IDE to see why and what happens ;) It is rather interesting.\\n\\n```\\nvar CustomStack = function(maxSize) {\\n    this.maxSize = maxSize;\\n    this.stack = [];\\n};\\n\\n/**\\n * @param {number} x\\n * @return {void}\\n */\\nCustomStack.prototype.push = function(x) {\\n    if(this.stack.length < this.maxSize) {\\n        this.stack[this.stack.length] = x;\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nCustomStack.prototype.pop = function() {\\n    if(this.stack.length > 0) {\\n        const retVal = this.stack[this.stack.length - 1];\\n        delete this.stack[this.stack.length - 1];\\n        this.stack.length = this.stack.length - 1;\\n        return retVal;\\n    } else {\\n        return -1;\\n    }\\n};\\n\\n/**\\n * @param {number} k\\n * @param {number} val\\n * @return {void}\\n */\\nCustomStack.prototype.increment = function(k, val) {\\n    for(let i = 0; i < k; i++) {\\n        if(this.stack[i]) this.stack[i] = this.stack[i] + val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar CustomStack = function(maxSize) {\\n    this.maxSize = maxSize;\\n    this.stack = [];\\n};\\n\\n/**\\n * @param {number} x\\n * @return {void}\\n */\\nCustomStack.prototype.push = function(x) {\\n    if(this.stack.length < this.maxSize) {\\n        this.stack[this.stack.length] = x;\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nCustomStack.prototype.pop = function() {\\n    if(this.stack.length > 0) {\\n        const retVal = this.stack[this.stack.length - 1];\\n        delete this.stack[this.stack.length - 1];\\n        this.stack.length = this.stack.length - 1;\\n        return retVal;\\n    } else {\\n        return -1;\\n    }\\n};\\n\\n/**\\n * @param {number} k\\n * @param {number} val\\n * @return {void}\\n */\\nCustomStack.prototype.increment = function(k, val) {\\n    for(let i = 0; i < k; i++) {\\n        if(this.stack[i]) this.stack[i] = this.stack[i] + val;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1701366,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Too easy for a medium?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "[@sogs](/sogs)  it is not hard to came up with idea, but O(n) is still best solution(in both time execution and memory usage) because of narrow range of operations"
                    },
                    {
                        "username": "sogs",
                        "content": "[@matthewjiao](/matthewjiao) how would you do it in 0(1) time\\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Brute force is easy, but non-optimal. There are some clever approaches to get O(1) time on the increment operation with lazy increments.\\nAlthough the test cases here are too small to make a difference, you\\'d probably want a more efficient \\'range update\\' in an interview."
                    },
                    {
                        "username": "Geetesh_Pandey",
                        "content": "yes\\n"
                    },
                    {
                        "username": "vivek2299",
                        "content": "//Java Solution\\nclass CustomStack\\n {\\n    private int [] arr;\\n    private int top = -1; \\n    public CustomStack(int maxSize) \\n    {\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x)\\n    {\\n        if(top == arr.length - 1)\\n        {}\\n        else\\n        {\\n            arr[++top] = x;\\n        }\\n    }\\n    \\n    public int pop() \\n    {\\n        if(top == -1)\\n            return -1;\\n        int val = arr[top];\\n        top--;\\n        return val;\\n    }\\n    \\n    public void increment(int k, int val) \\n    {\\n        if(k >= top+1)\\n        {\\n            for(int i=0; i<top+1; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n        else\\n        {\\n            for(int i=0; i<k; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */"
                    },
                    {
                        "username": "waz007",
                        "content": "The question should add a constraint that increment must be an O(1) operation."
                    },
                    {
                        "username": "farhandazzler1999",
                        "content": "Please upvote this ...!!! follow @farhandazzler\\nclass CustomStack {\\nprivate:\\n    int maxSize;\\n    vector<int> stack;\\n    \\npublic:\\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n        \\n    }\\n    \\n    void push(int x) {\\n        if (stack.size() < maxSize) {\\n            stack.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if (stack.empty()) {\\n            return -1;\\n        } else {\\n            int temp = stack.back();\\n            stack.pop_back();\\n            return temp;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        int minK = min(k, static_cast<int>(stack.size()));\\n        for (int i = 0; i < minK; i++) {\\n            stack[i] += val;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "bfay",
                        "content": "This is literally just \"implement a stack with a trivial and useless modification\". Not a great problem."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Brute force is easy, the optimal approach is easy to implement, hard to think of!"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "I couldnot understood this problem!"
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Any better approach other than O(k*k)?Hard to predict in O(k) :)"
                    }
                ]
            },
            {
                "id": 1757638,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Too easy for a medium?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "[@sogs](/sogs)  it is not hard to came up with idea, but O(n) is still best solution(in both time execution and memory usage) because of narrow range of operations"
                    },
                    {
                        "username": "sogs",
                        "content": "[@matthewjiao](/matthewjiao) how would you do it in 0(1) time\\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Brute force is easy, but non-optimal. There are some clever approaches to get O(1) time on the increment operation with lazy increments.\\nAlthough the test cases here are too small to make a difference, you\\'d probably want a more efficient \\'range update\\' in an interview."
                    },
                    {
                        "username": "Geetesh_Pandey",
                        "content": "yes\\n"
                    },
                    {
                        "username": "vivek2299",
                        "content": "//Java Solution\\nclass CustomStack\\n {\\n    private int [] arr;\\n    private int top = -1; \\n    public CustomStack(int maxSize) \\n    {\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x)\\n    {\\n        if(top == arr.length - 1)\\n        {}\\n        else\\n        {\\n            arr[++top] = x;\\n        }\\n    }\\n    \\n    public int pop() \\n    {\\n        if(top == -1)\\n            return -1;\\n        int val = arr[top];\\n        top--;\\n        return val;\\n    }\\n    \\n    public void increment(int k, int val) \\n    {\\n        if(k >= top+1)\\n        {\\n            for(int i=0; i<top+1; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n        else\\n        {\\n            for(int i=0; i<k; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */"
                    },
                    {
                        "username": "waz007",
                        "content": "The question should add a constraint that increment must be an O(1) operation."
                    },
                    {
                        "username": "farhandazzler1999",
                        "content": "Please upvote this ...!!! follow @farhandazzler\\nclass CustomStack {\\nprivate:\\n    int maxSize;\\n    vector<int> stack;\\n    \\npublic:\\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n        \\n    }\\n    \\n    void push(int x) {\\n        if (stack.size() < maxSize) {\\n            stack.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if (stack.empty()) {\\n            return -1;\\n        } else {\\n            int temp = stack.back();\\n            stack.pop_back();\\n            return temp;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        int minK = min(k, static_cast<int>(stack.size()));\\n        for (int i = 0; i < minK; i++) {\\n            stack[i] += val;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "bfay",
                        "content": "This is literally just \"implement a stack with a trivial and useless modification\". Not a great problem."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Brute force is easy, the optimal approach is easy to implement, hard to think of!"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "I couldnot understood this problem!"
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Any better approach other than O(k*k)?Hard to predict in O(k) :)"
                    }
                ]
            },
            {
                "id": 2074888,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Too easy for a medium?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "[@sogs](/sogs)  it is not hard to came up with idea, but O(n) is still best solution(in both time execution and memory usage) because of narrow range of operations"
                    },
                    {
                        "username": "sogs",
                        "content": "[@matthewjiao](/matthewjiao) how would you do it in 0(1) time\\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Brute force is easy, but non-optimal. There are some clever approaches to get O(1) time on the increment operation with lazy increments.\\nAlthough the test cases here are too small to make a difference, you\\'d probably want a more efficient \\'range update\\' in an interview."
                    },
                    {
                        "username": "Geetesh_Pandey",
                        "content": "yes\\n"
                    },
                    {
                        "username": "vivek2299",
                        "content": "//Java Solution\\nclass CustomStack\\n {\\n    private int [] arr;\\n    private int top = -1; \\n    public CustomStack(int maxSize) \\n    {\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x)\\n    {\\n        if(top == arr.length - 1)\\n        {}\\n        else\\n        {\\n            arr[++top] = x;\\n        }\\n    }\\n    \\n    public int pop() \\n    {\\n        if(top == -1)\\n            return -1;\\n        int val = arr[top];\\n        top--;\\n        return val;\\n    }\\n    \\n    public void increment(int k, int val) \\n    {\\n        if(k >= top+1)\\n        {\\n            for(int i=0; i<top+1; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n        else\\n        {\\n            for(int i=0; i<k; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */"
                    },
                    {
                        "username": "waz007",
                        "content": "The question should add a constraint that increment must be an O(1) operation."
                    },
                    {
                        "username": "farhandazzler1999",
                        "content": "Please upvote this ...!!! follow @farhandazzler\\nclass CustomStack {\\nprivate:\\n    int maxSize;\\n    vector<int> stack;\\n    \\npublic:\\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n        \\n    }\\n    \\n    void push(int x) {\\n        if (stack.size() < maxSize) {\\n            stack.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if (stack.empty()) {\\n            return -1;\\n        } else {\\n            int temp = stack.back();\\n            stack.pop_back();\\n            return temp;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        int minK = min(k, static_cast<int>(stack.size()));\\n        for (int i = 0; i < minK; i++) {\\n            stack[i] += val;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "bfay",
                        "content": "This is literally just \"implement a stack with a trivial and useless modification\". Not a great problem."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Brute force is easy, the optimal approach is easy to implement, hard to think of!"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "I couldnot understood this problem!"
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Any better approach other than O(k*k)?Hard to predict in O(k) :)"
                    }
                ]
            },
            {
                "id": 2071928,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Too easy for a medium?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "[@sogs](/sogs)  it is not hard to came up with idea, but O(n) is still best solution(in both time execution and memory usage) because of narrow range of operations"
                    },
                    {
                        "username": "sogs",
                        "content": "[@matthewjiao](/matthewjiao) how would you do it in 0(1) time\\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Brute force is easy, but non-optimal. There are some clever approaches to get O(1) time on the increment operation with lazy increments.\\nAlthough the test cases here are too small to make a difference, you\\'d probably want a more efficient \\'range update\\' in an interview."
                    },
                    {
                        "username": "Geetesh_Pandey",
                        "content": "yes\\n"
                    },
                    {
                        "username": "vivek2299",
                        "content": "//Java Solution\\nclass CustomStack\\n {\\n    private int [] arr;\\n    private int top = -1; \\n    public CustomStack(int maxSize) \\n    {\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x)\\n    {\\n        if(top == arr.length - 1)\\n        {}\\n        else\\n        {\\n            arr[++top] = x;\\n        }\\n    }\\n    \\n    public int pop() \\n    {\\n        if(top == -1)\\n            return -1;\\n        int val = arr[top];\\n        top--;\\n        return val;\\n    }\\n    \\n    public void increment(int k, int val) \\n    {\\n        if(k >= top+1)\\n        {\\n            for(int i=0; i<top+1; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n        else\\n        {\\n            for(int i=0; i<k; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */"
                    },
                    {
                        "username": "waz007",
                        "content": "The question should add a constraint that increment must be an O(1) operation."
                    },
                    {
                        "username": "farhandazzler1999",
                        "content": "Please upvote this ...!!! follow @farhandazzler\\nclass CustomStack {\\nprivate:\\n    int maxSize;\\n    vector<int> stack;\\n    \\npublic:\\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n        \\n    }\\n    \\n    void push(int x) {\\n        if (stack.size() < maxSize) {\\n            stack.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if (stack.empty()) {\\n            return -1;\\n        } else {\\n            int temp = stack.back();\\n            stack.pop_back();\\n            return temp;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        int minK = min(k, static_cast<int>(stack.size()));\\n        for (int i = 0; i < minK; i++) {\\n            stack[i] += val;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "bfay",
                        "content": "This is literally just \"implement a stack with a trivial and useless modification\". Not a great problem."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Brute force is easy, the optimal approach is easy to implement, hard to think of!"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "I couldnot understood this problem!"
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Any better approach other than O(k*k)?Hard to predict in O(k) :)"
                    }
                ]
            },
            {
                "id": 2038633,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Too easy for a medium?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "[@sogs](/sogs)  it is not hard to came up with idea, but O(n) is still best solution(in both time execution and memory usage) because of narrow range of operations"
                    },
                    {
                        "username": "sogs",
                        "content": "[@matthewjiao](/matthewjiao) how would you do it in 0(1) time\\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Brute force is easy, but non-optimal. There are some clever approaches to get O(1) time on the increment operation with lazy increments.\\nAlthough the test cases here are too small to make a difference, you\\'d probably want a more efficient \\'range update\\' in an interview."
                    },
                    {
                        "username": "Geetesh_Pandey",
                        "content": "yes\\n"
                    },
                    {
                        "username": "vivek2299",
                        "content": "//Java Solution\\nclass CustomStack\\n {\\n    private int [] arr;\\n    private int top = -1; \\n    public CustomStack(int maxSize) \\n    {\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x)\\n    {\\n        if(top == arr.length - 1)\\n        {}\\n        else\\n        {\\n            arr[++top] = x;\\n        }\\n    }\\n    \\n    public int pop() \\n    {\\n        if(top == -1)\\n            return -1;\\n        int val = arr[top];\\n        top--;\\n        return val;\\n    }\\n    \\n    public void increment(int k, int val) \\n    {\\n        if(k >= top+1)\\n        {\\n            for(int i=0; i<top+1; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n        else\\n        {\\n            for(int i=0; i<k; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */"
                    },
                    {
                        "username": "waz007",
                        "content": "The question should add a constraint that increment must be an O(1) operation."
                    },
                    {
                        "username": "farhandazzler1999",
                        "content": "Please upvote this ...!!! follow @farhandazzler\\nclass CustomStack {\\nprivate:\\n    int maxSize;\\n    vector<int> stack;\\n    \\npublic:\\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n        \\n    }\\n    \\n    void push(int x) {\\n        if (stack.size() < maxSize) {\\n            stack.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if (stack.empty()) {\\n            return -1;\\n        } else {\\n            int temp = stack.back();\\n            stack.pop_back();\\n            return temp;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        int minK = min(k, static_cast<int>(stack.size()));\\n        for (int i = 0; i < minK; i++) {\\n            stack[i] += val;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "bfay",
                        "content": "This is literally just \"implement a stack with a trivial and useless modification\". Not a great problem."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Brute force is easy, the optimal approach is easy to implement, hard to think of!"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "I couldnot understood this problem!"
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Any better approach other than O(k*k)?Hard to predict in O(k) :)"
                    }
                ]
            },
            {
                "id": 1995614,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Too easy for a medium?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "[@sogs](/sogs)  it is not hard to came up with idea, but O(n) is still best solution(in both time execution and memory usage) because of narrow range of operations"
                    },
                    {
                        "username": "sogs",
                        "content": "[@matthewjiao](/matthewjiao) how would you do it in 0(1) time\\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Brute force is easy, but non-optimal. There are some clever approaches to get O(1) time on the increment operation with lazy increments.\\nAlthough the test cases here are too small to make a difference, you\\'d probably want a more efficient \\'range update\\' in an interview."
                    },
                    {
                        "username": "Geetesh_Pandey",
                        "content": "yes\\n"
                    },
                    {
                        "username": "vivek2299",
                        "content": "//Java Solution\\nclass CustomStack\\n {\\n    private int [] arr;\\n    private int top = -1; \\n    public CustomStack(int maxSize) \\n    {\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x)\\n    {\\n        if(top == arr.length - 1)\\n        {}\\n        else\\n        {\\n            arr[++top] = x;\\n        }\\n    }\\n    \\n    public int pop() \\n    {\\n        if(top == -1)\\n            return -1;\\n        int val = arr[top];\\n        top--;\\n        return val;\\n    }\\n    \\n    public void increment(int k, int val) \\n    {\\n        if(k >= top+1)\\n        {\\n            for(int i=0; i<top+1; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n        else\\n        {\\n            for(int i=0; i<k; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */"
                    },
                    {
                        "username": "waz007",
                        "content": "The question should add a constraint that increment must be an O(1) operation."
                    },
                    {
                        "username": "farhandazzler1999",
                        "content": "Please upvote this ...!!! follow @farhandazzler\\nclass CustomStack {\\nprivate:\\n    int maxSize;\\n    vector<int> stack;\\n    \\npublic:\\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n        \\n    }\\n    \\n    void push(int x) {\\n        if (stack.size() < maxSize) {\\n            stack.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if (stack.empty()) {\\n            return -1;\\n        } else {\\n            int temp = stack.back();\\n            stack.pop_back();\\n            return temp;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        int minK = min(k, static_cast<int>(stack.size()));\\n        for (int i = 0; i < minK; i++) {\\n            stack[i] += val;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "bfay",
                        "content": "This is literally just \"implement a stack with a trivial and useless modification\". Not a great problem."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Brute force is easy, the optimal approach is easy to implement, hard to think of!"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "I couldnot understood this problem!"
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Any better approach other than O(k*k)?Hard to predict in O(k) :)"
                    }
                ]
            },
            {
                "id": 1868989,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Too easy for a medium?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "[@sogs](/sogs)  it is not hard to came up with idea, but O(n) is still best solution(in both time execution and memory usage) because of narrow range of operations"
                    },
                    {
                        "username": "sogs",
                        "content": "[@matthewjiao](/matthewjiao) how would you do it in 0(1) time\\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Brute force is easy, but non-optimal. There are some clever approaches to get O(1) time on the increment operation with lazy increments.\\nAlthough the test cases here are too small to make a difference, you\\'d probably want a more efficient \\'range update\\' in an interview."
                    },
                    {
                        "username": "Geetesh_Pandey",
                        "content": "yes\\n"
                    },
                    {
                        "username": "vivek2299",
                        "content": "//Java Solution\\nclass CustomStack\\n {\\n    private int [] arr;\\n    private int top = -1; \\n    public CustomStack(int maxSize) \\n    {\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x)\\n    {\\n        if(top == arr.length - 1)\\n        {}\\n        else\\n        {\\n            arr[++top] = x;\\n        }\\n    }\\n    \\n    public int pop() \\n    {\\n        if(top == -1)\\n            return -1;\\n        int val = arr[top];\\n        top--;\\n        return val;\\n    }\\n    \\n    public void increment(int k, int val) \\n    {\\n        if(k >= top+1)\\n        {\\n            for(int i=0; i<top+1; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n        else\\n        {\\n            for(int i=0; i<k; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */"
                    },
                    {
                        "username": "waz007",
                        "content": "The question should add a constraint that increment must be an O(1) operation."
                    },
                    {
                        "username": "farhandazzler1999",
                        "content": "Please upvote this ...!!! follow @farhandazzler\\nclass CustomStack {\\nprivate:\\n    int maxSize;\\n    vector<int> stack;\\n    \\npublic:\\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n        \\n    }\\n    \\n    void push(int x) {\\n        if (stack.size() < maxSize) {\\n            stack.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if (stack.empty()) {\\n            return -1;\\n        } else {\\n            int temp = stack.back();\\n            stack.pop_back();\\n            return temp;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        int minK = min(k, static_cast<int>(stack.size()));\\n        for (int i = 0; i < minK; i++) {\\n            stack[i] += val;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "bfay",
                        "content": "This is literally just \"implement a stack with a trivial and useless modification\". Not a great problem."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Brute force is easy, the optimal approach is easy to implement, hard to think of!"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "I couldnot understood this problem!"
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Any better approach other than O(k*k)?Hard to predict in O(k) :)"
                    }
                ]
            },
            {
                "id": 1827825,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Too easy for a medium?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "[@sogs](/sogs)  it is not hard to came up with idea, but O(n) is still best solution(in both time execution and memory usage) because of narrow range of operations"
                    },
                    {
                        "username": "sogs",
                        "content": "[@matthewjiao](/matthewjiao) how would you do it in 0(1) time\\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Brute force is easy, but non-optimal. There are some clever approaches to get O(1) time on the increment operation with lazy increments.\\nAlthough the test cases here are too small to make a difference, you\\'d probably want a more efficient \\'range update\\' in an interview."
                    },
                    {
                        "username": "Geetesh_Pandey",
                        "content": "yes\\n"
                    },
                    {
                        "username": "vivek2299",
                        "content": "//Java Solution\\nclass CustomStack\\n {\\n    private int [] arr;\\n    private int top = -1; \\n    public CustomStack(int maxSize) \\n    {\\n        arr = new int[maxSize];\\n    }\\n    \\n    public void push(int x)\\n    {\\n        if(top == arr.length - 1)\\n        {}\\n        else\\n        {\\n            arr[++top] = x;\\n        }\\n    }\\n    \\n    public int pop() \\n    {\\n        if(top == -1)\\n            return -1;\\n        int val = arr[top];\\n        top--;\\n        return val;\\n    }\\n    \\n    public void increment(int k, int val) \\n    {\\n        if(k >= top+1)\\n        {\\n            for(int i=0; i<top+1; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n        else\\n        {\\n            for(int i=0; i<k; i++)\\n                arr[i] = arr[i] + val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */"
                    },
                    {
                        "username": "waz007",
                        "content": "The question should add a constraint that increment must be an O(1) operation."
                    },
                    {
                        "username": "farhandazzler1999",
                        "content": "Please upvote this ...!!! follow @farhandazzler\\nclass CustomStack {\\nprivate:\\n    int maxSize;\\n    vector<int> stack;\\n    \\npublic:\\n    CustomStack(int maxSize) {\\n        this->maxSize = maxSize;\\n        \\n    }\\n    \\n    void push(int x) {\\n        if (stack.size() < maxSize) {\\n            stack.push_back(x);\\n        }\\n    }\\n    \\n    int pop() {\\n        if (stack.empty()) {\\n            return -1;\\n        } else {\\n            int temp = stack.back();\\n            stack.pop_back();\\n            return temp;\\n        }\\n    }\\n    \\n    void increment(int k, int val) {\\n        int minK = min(k, static_cast<int>(stack.size()));\\n        for (int i = 0; i < minK; i++) {\\n            stack[i] += val;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "bfay",
                        "content": "This is literally just \"implement a stack with a trivial and useless modification\". Not a great problem."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Brute force is easy, the optimal approach is easy to implement, hard to think of!"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "I couldnot understood this problem!"
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Any better approach other than O(k*k)?Hard to predict in O(k) :)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Longest Nice Substring",
        "question_content": "<p>A string <code>s</code> is <strong>nice</strong> if, for every letter of the alphabet that <code>s</code> contains, it appears <strong>both</strong> in uppercase and lowercase. For example, <code>&quot;abABB&quot;</code> is nice because <code>&#39;A&#39;</code> and <code>&#39;a&#39;</code> appear, and <code>&#39;B&#39;</code> and <code>&#39;b&#39;</code> appear. However, <code>&quot;abA&quot;</code> is not because <code>&#39;b&#39;</code> appears, but <code>&#39;B&#39;</code> does not.</p>\n\n<p>Given a string <code>s</code>, return <em>the longest <strong>substring</strong> of <code>s</code> that is <strong>nice</strong>. If there are multiple, return the substring of the <strong>earliest</strong> occurrence. If there are none, return an empty string</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;YazaAay&quot;\n<strong>Output:</strong> &quot;aAa&quot;\n<strong>Explanation: </strong>&quot;aAa&quot; is a nice string because &#39;A/a&#39; is the only letter of the alphabet in s, and both &#39;A&#39; and &#39;a&#39; appear.\n&quot;aAa&quot; is the longest nice substring.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;Bb&quot;\n<strong>Output:</strong> &quot;Bb&quot;\n<strong>Explanation:</strong> &quot;Bb&quot; is a nice string because both &#39;B&#39; and &#39;b&#39; appear. The whole string is a substring.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;c&quot;\n<strong>Output:</strong> &quot;&quot;\n<strong>Explanation:</strong> There are no nice substrings.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> consists of uppercase and lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1074589,
                "title": "java-straightforward-divide-and-conquer",
                "content": "```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        if (s.length() < 2) return \"\";\\n        char[] arr = s.toCharArray();\\n        Set<Character> set = new HashSet<>();\\n        for (char c: arr) set.add(c);\\n        for (int i = 0; i < arr.length; i++) {\\n            char c = arr[i];\\n            if (set.contains(Character.toUpperCase(c)) && set.contains(Character.toLowerCase(c))) continue;\\n            String sub1 = longestNiceSubstring(s.substring(0, i));\\n            String sub2 = longestNiceSubstring(s.substring(i+1));\\n            return sub1.length() >= sub2.length() ? sub1 : sub2;\\n        }\\n        return s; \\n    }\\n}\\n\\n```\\nI think the time complexity is `O(nlogn)`, please correct me if wrong!\\n- 1st round, we have 1 string of length n\\n- 2nd round, 2 strings with sum length of n\\n- 3rd round, 4 strings with sum length  of n\\n- ...\\n \\nSo, there could be `logn` rounds in total, and overall complexity is `O(nlogn)`\\nAs @lenchen1112 pointed out, the # of rounds is bound to 26, so this should be `O(n)`",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        if (s.length() < 2) return \"\";\\n        char[] arr = s.toCharArray();\\n        Set<Character> set = new HashSet<>();\\n        for (char c: arr) set.add(c);\\n        for (int i = 0; i < arr.length; i++) {\\n            char c = arr[i];\\n            if (set.contains(Character.toUpperCase(c)) && set.contains(Character.toLowerCase(c))) continue;\\n            String sub1 = longestNiceSubstring(s.substring(0, i));\\n            String sub2 = longestNiceSubstring(s.substring(i+1));\\n            return sub1.length() >= sub2.length() ? sub1 : sub2;\\n        }\\n        return s; \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074677,
                "title": "this-is-a-good-problem-but-it-s-bad-to-use-small-constraint-and-mark-it-as-an-easy-problem",
                "content": "This is typically a divide and conquer problem,  and can be solve with the time complexity O(N)  (Actually this solution is O(N lg N))\\n\\nBut in the contest,  many people just use brute force and solve it using O(N^2). This method can save them a lot of time,  and get better standing.  And in the practise,  many people just get accepted using brute force and move on.\\n\\nHowever,  this is not good for them because in the real interview,  the interviewer will not satisfy if you only present him or her brute force method.   It can only waste him or her good chance to practise divide and conquer method. \\n\\nSo,  please add some large test cases  1<=n<=10^5,  and mark this problem an medium problem.\\n\\nHere is my O(N) solution,  for each s,  we try to find the location of any character for appear only in either uppercase or lowercase,  and split the string by these characters.  Then for each splited substring, do the same thing,  until it can not be splited. return the  longest substring with first appearance. \\n\\n(As some people point out,  this is actually NlgN because of the sorting part)\\n\\n```\\n        def getsplit(front,rear):\\n            if rear-front<1: return [1,0]\\n            lcase = [[] for i in range(26)]\\n            ucase = [[] for i in range(26)]\\n\\t\\t\\t\\n\\t\\t\\t\\n            for i in range(front,rear+1):\\n                if ord(s[i])-97>=0:  lcase[ord(s[i])-97].append(i)\\n                else: ucase[ord(s[i])-65].append(i)        \\n            part = [front-1,rear+1]\\n\\t\\t\\n    \\n            for k in range(26):\\n                if len(ucase[k])*len(lcase[k])>0 or len(ucase[k]) + len(lcase[k])==0: continue \\n                for i in ucase[k]+lcase[k]:\\n                    part.append(i)  \\n                \\n            if len(part)==2: return [front,rear]      \\n            part.sort()      \\n            output = [1,0]   \\n            for i in range(len(part)-1):\\n                temp = getsplit(part[i]+1,part[i+1]-1)\\n                if temp[1]-temp[0]>output[1]-output[0]:\\n                    output = temp  \\n            return output\\n    \\n        l,r = getsplit(0,len(s)-1)    \\n        return s[l:r+1]\\n```\\n\\n\\n\\n_________\\nupdated:  Since this is an OA problem,  no need to add more test cases.   It would be better if problem maker add a follow up below this problem:  Can you solve it in O(n) time?\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n        def getsplit(front,rear):\\n            if rear-front<1: return [1,0]\\n            lcase = [[] for i in range(26)]\\n            ucase = [[] for i in range(26)]\\n\\t\\t\\t\\n\\t\\t\\t\\n            for i in range(front,rear+1):\\n                if ord(s[i])-97>=0:  lcase[ord(s[i])-97].append(i)\\n                else: ucase[ord(s[i])-65].append(i)        \\n            part = [front-1,rear+1]\\n\\t\\t\\n    \\n            for k in range(26):\\n                if len(ucase[k])*len(lcase[k])>0 or len(ucase[k]) + len(lcase[k])==0: continue \\n                for i in ucase[k]+lcase[k]:\\n                    part.append(i)  \\n                \\n            if len(part)==2: return [front,rear]      \\n            part.sort()      \\n            output = [1,0]   \\n            for i in range(len(part)-1):\\n                temp = getsplit(part[i]+1,part[i+1]-1)\\n                if temp[1]-temp[0]>output[1]-output[0]:\\n                    output = temp  \\n            return output\\n    \\n        l,r = getsplit(0,len(s)-1)    \\n        return s[l:r+1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1645774,
                "title": "java-why-divide-conquer-explained",
                "content": "**Idea:** \\n* Why this is a Divide & Conquer problem?\\n\\t* If you\\'ve solved a good variety of problems, your initial approach might be Sliding window technique, which won\\'t work, at least not in its template form\\n\\t* However when you go down that route, you\\'ll see that a string can possbily become nice later but then some character gets into the string which will make it impossible for that sub-string to become nice because that char doesn\\'t exist in the entire string. So we know there\\'s no point in continuing any further.\\n\\t* In fact this character (say z in the given example) will not let any substring become nice in the entire string, so the only way to find a nice substring is to exlude this char, which means you split the string at z, something like `[start...]z[...end]`\\n\\t* Now you have two sub-problems with the left and right partitions which ask you to find the original LNS problem, which you can do recursively. This is the very definition of [Divide-and-Conquer technique](https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm) - *A divide-and-conquer algorithm recursively breaks down a problem into two or more sub-problems of the same or related type, until these become simple enough to be solved directly. The solutions to the sub-problems are then combined to give a solution to the original problem.* \\n* As long as both upper and lower case chars exists in the string, keep moving, else take the erroneous character as a partition and check for its left and right parts to be nice strings.\\n* s is not a nice string if size(s) < 2\\n* Return the longer nice sub-string from the recursive method\\n* If you\\'ll use `>` instead of `>=` then you\\'ll get the nice substring which occurs last, but the question says that in case of a tie, return the earliest one, thus `prefix >= suffix`\\n\\n![image](https://assets.leetcode.com/users/images/200922b2-2af6-4d51-9314-c7c3c13c51a0_1640409233.9692588.png)\\n\\n>**T/S:** O(n\\xB2)/O(n), where n = size(s)\\n```\\npublic String longestNiceSubstring(String s) {\\n\\tvar sub = longestNiceSubstring(s, 0, s.length());\\n\\treturn s.substring(sub[0], sub[1]);\\n}\\n\\nprivate int[] longestNiceSubstring(String s, int left, int right) {\\n\\tvar charSet = getCharSet(s, left, right);\\n\\n\\tfor (var i = left; i < right; i++)\\n\\t\\tif (!charSet.contains(Character.toLowerCase(s.charAt(i))) \\n\\t\\t || !charSet.contains(Character.toUpperCase(s.charAt(i)))) {\\n\\t\\t \\n\\t\\t\\tvar prefix = longestNiceSubstring(s, left, i);\\n\\t\\t\\tvar suffix = longestNiceSubstring(s, i + 1, right);\\n\\t\\t\\treturn prefix[1] - prefix[0] >= suffix[1] - suffix[0] \\n\\t\\t\\t\\t ? prefix \\n\\t\\t\\t\\t : suffix;\\n\\t\\t}\\n\\t\\t\\n\\treturn new int[]{left, right};\\n}\\n\\nprivate Set<Character> getCharSet(String s, int left, int right) {\\n\\tvar charSet = new HashSet<Character>();\\n\\t\\n\\tfor (var i = left; i < right; i++)\\n\\t\\tcharSet.add(s.charAt(i));\\n\\t\\t\\n\\treturn charSet;\\n}\\n```\\n\\n`getCharSet` method can be replaced with this 1 liner\\n```\\nIntStream.range(left, right)\\n\\t     .mapToObj(s::charAt)\\n\\t\\t .collect(Collectors.toCollection(HashSet::new));\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "```\\npublic String longestNiceSubstring(String s) {\\n\\tvar sub = longestNiceSubstring(s, 0, s.length());\\n\\treturn s.substring(sub[0], sub[1]);\\n}\\n\\nprivate int[] longestNiceSubstring(String s, int left, int right) {\\n\\tvar charSet = getCharSet(s, left, right);\\n\\n\\tfor (var i = left; i < right; i++)\\n\\t\\tif (!charSet.contains(Character.toLowerCase(s.charAt(i))) \\n\\t\\t || !charSet.contains(Character.toUpperCase(s.charAt(i)))) {\\n\\t\\t \\n\\t\\t\\tvar prefix = longestNiceSubstring(s, left, i);\\n\\t\\t\\tvar suffix = longestNiceSubstring(s, i + 1, right);\\n\\t\\t\\treturn prefix[1] - prefix[0] >= suffix[1] - suffix[0] \\n\\t\\t\\t\\t ? prefix \\n\\t\\t\\t\\t : suffix;\\n\\t\\t}\\n\\t\\t\\n\\treturn new int[]{left, right};\\n}\\n\\nprivate Set<Character> getCharSet(String s, int left, int right) {\\n\\tvar charSet = new HashSet<Character>();\\n\\t\\n\\tfor (var i = left; i < right; i++)\\n\\t\\tcharSet.add(s.charAt(i));\\n\\t\\t\\n\\treturn charSet;\\n}\\n```\n```\\nIntStream.range(left, right)\\n\\t     .mapToObj(s::charAt)\\n\\t\\t .collect(Collectors.toCollection(HashSet::new));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1074546,
                "title": "python3-brute-force-divide-and-conquer",
                "content": "\\n```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        ans = \"\"\\n        for i in range(len(s)):\\n            for ii in range(i+1, len(s)+1):\\n                if all(s[k].swapcase() in s[i:ii] for k in range(i, ii)): \\n                    ans = max(ans, s[i:ii], key=len)\\n        return ans \\n```\\n\\nEdited on 2/23/2021\\nApparently, the small size doesn\\'t give me enough motivation to seek more efficient algo. Below is the implementation of divide and conquer in Python3 of this [post](https://leetcode.com/problems/longest-nice-substring/discuss/1074589/JavaStraightforward-Divide-and-Conquer). This is indeed a lot faster than the naive solution above. Credit goes to original author. \\n```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        if not s: return \"\" # boundary condition \\n        ss = set(s)\\n        for i, c in enumerate(s):\\n            if c.swapcase() not in ss: \\n                s0 = self.longestNiceSubstring(s[:i])\\n                s1 = self.longestNiceSubstring(s[i+1:])\\n                return max(s0, s1, key=len)\\n        return s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        ans = \"\"\\n        for i in range(len(s)):\\n            for ii in range(i+1, len(s)+1):\\n                if all(s[k].swapcase() in s[i:ii] for k in range(i, ii)): \\n                    ans = max(ans, s[i:ii], key=len)\\n        return ans \\n```\n```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        if not s: return \"\" # boundary condition \\n        ss = set(s)\\n        for i, c in enumerate(s):\\n            if c.swapcase() not in ss: \\n                s0 = self.longestNiceSubstring(s[:i])\\n                s1 = self.longestNiceSubstring(s[i+1:])\\n                return max(s0, s1, key=len)\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344517,
                "title": "c-easy-to-understand-fast-and-efficient-using-divide-and-conquer-approach",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution \\n{\\npublic:\\nstring longestNiceSubstring(string s) {\\n        if (s.size() < 2) return \"\";\\n        unordered_set<char> st(begin(s), end(s));\\n        for (int i = 0; i < s.size(); i++) {\\n             if (st.find((char) toupper(s[i])) == end(st) || st.find((char) tolower(s[i])) == end(st)) {\\n                string s1 = longestNiceSubstring(s.substr(0, i));\\n                string s2 = longestNiceSubstring(s.substr(i + 1));\\n                return s1.size() >= s2.size() ? s1 : s2;\\n            }\\n        }\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Divide and Conquer"
                ],
                "code": "class Solution \\n{\\npublic:\\nstring longestNiceSubstring(string s) {\\n        if (s.size() < 2) return \"\";\\n        unordered_set<char> st(begin(s), end(s));\\n        for (int i = 0; i < s.size(); i++) {\\n             if (st.find((char) toupper(s[i])) == end(st) || st.find((char) tolower(s[i])) == end(st)) {\\n                string s1 = longestNiceSubstring(s.substr(0, i));\\n                string s2 = longestNiceSubstring(s.substr(i + 1));\\n                return s1.size() >= s2.size() ? s1 : s2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1074856,
                "title": "c-o-n",
                "content": "The idea is to find mismatched characters (lower without upper, or vice-versa), and split the string (possibly multiple times) on these characters. \\n\\nFor this example, we split the string into 4 substrings (between `x` and `Y`), and process them individually.\\n\\n`\"..........x.........Y........x..........\"`\\n\\n**Why this is O(n)?**\\nThis solution may look like O(n log n) for the case like this `[a,b,c,B,A,x,a,b,C,B,A]`. \\n\\nHowever, using the first example above, it\\'s important to realize that `x` and `Y` would not occur in the substring after the split.\\n\\nThus, we cannot have more than 26 recursive splits. Since the number of splits does not depend on the input size, this solution has linear complexity.\\n\\n```cpp\\nstring longestNiceSubstring(string s, int start = 0, int end = -1) {\\n    if (end == -1)\\n        end = s.size();\\n    int cnt[26][2] = {}, j = start - 1;\\n    for (auto i = start; i < end; ++i)\\n        cnt[tolower(s[i]) - \\'a\\'][(bool)islower(s[i])] = 1;\\n    string res;\\n    for (auto i = start; i <= end; ++i) {\\n        int ch = i == end ? -1 : tolower(s[i]) - \\'a\\';\\n        if (ch == -1 || cnt[ch][0] + cnt[ch][1] == 1) {\\n            if (j == -1 && ch == -1)\\n                return s;\\n            auto res1 = longestNiceSubstring(s.substr(j + 1, i - j - 1));\\n            if (res1.size() > res.size())\\n                res = res1;\\n            j = i;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nstring longestNiceSubstring(string s, int start = 0, int end = -1) {\\n    if (end == -1)\\n        end = s.size();\\n    int cnt[26][2] = {}, j = start - 1;\\n    for (auto i = start; i < end; ++i)\\n        cnt[tolower(s[i]) - \\'a\\'][(bool)islower(s[i])] = 1;\\n    string res;\\n    for (auto i = start; i <= end; ++i) {\\n        int ch = i == end ? -1 : tolower(s[i]) - \\'a\\';\\n        if (ch == -1 || cnt[ch][0] + cnt[ch][1] == 1) {\\n            if (j == -1 && ch == -1)\\n                return s;\\n            auto res1 = longestNiceSubstring(s.substr(j + 1, i - j - 1));\\n            if (res1.size() > res.size())\\n                res = res1;\\n            j = i;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1074567,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isNiceSubstring(string& s, int i, int j) {\\n        unordered_map<int, bool> mp;\\n        bool isTrue = true;\\n        for (int x = i; x <= j; x++) {\\n            mp[s[x]] = true;\\n        }\\n        \\n        while (i <= j) {\\n            if (s[i] < 97) {\\n                if (!mp[s[i] + 32]) {\\n                    return false;\\n                }\\n            } else {\\n                if (!mp[s[i] - 32]) {\\n                    return false;\\n                }\\n            }\\n            i++;\\n        }\\n        \\n        return true;\\n    }\\n    string longestNiceSubstring(string s) {\\n        int n = s.length();\\n        int maxLength = 0;\\n        string result;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                if (isNiceSubstring(s, i, j)) {\\n                    if (j - i + 1 > maxLength) {\\n                        maxLength = j - i + 1;\\n                        result = s.substr(i, j - i + 1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isNiceSubstring(string& s, int i, int j) {\\n        unordered_map<int, bool> mp;\\n        bool isTrue = true;\\n        for (int x = i; x <= j; x++) {\\n            mp[s[x]] = true;\\n        }\\n        \\n        while (i <= j) {\\n            if (s[i] < 97) {\\n                if (!mp[s[i] + 32]) {\\n                    return false;\\n                }\\n            } else {\\n                if (!mp[s[i] - 32]) {\\n                    return false;\\n                }\\n            }\\n            i++;\\n        }\\n        \\n        return true;\\n    }\\n    string longestNiceSubstring(string s) {\\n        int n = s.length();\\n        int maxLength = 0;\\n        string result;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                if (isNiceSubstring(s, i, j)) {\\n                    if (j - i + 1 > maxLength) {\\n                        maxLength = j - i + 1;\\n                        result = s.substr(i, j - i + 1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693408,
                "title": "python3-from-o-n-2-to-o-n",
                "content": "This post is inspired by \\nhttps://leetcode.com/problems/longest-nice-substring/discuss/1074677/This-is-a-good-problem-but-it\\'s-bad-to-use-small-constraint-and-mark-it-as-an-easy-problem\\n\\nI want to explain to myself how one can optimize step by step from O(N^2) brute force solution to the optimal solution O(N). \\n\\n## Approach 1:  Brute Force\\nThe intuition is simple. We basically check every possible substring to see if it\\'s a nice string. We also keep record of the current longest nice substring by remembering the start index of the substring as well as the length of it.\\n\\n```python\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        N = len(s)\\n        maxlen = 0\\n        start = 0\\n        for i in range(N):\\n            seen = set()\\n            missing = 0\\n            for j in range(i, N):\\n\\t\\t\\t# if we haven\\'t seen this \"type\", add it into the seen set\\n                if s[j] not in seen: \\n                    seen.add(s[j])\\n\\t\\t\\t\\t\\t# since this is the first time we see this \"type\" of character\\n\\t\\t\\t\\t\\t# we check if the other half has already been seen before\\n                    if (s[j].lower() not in seen) or (s[j].upper() not in seen):\\n                        missing += 1 # we haven\\'t seen the other half yet, so adding 1 to the missing type\\n                    else: # otherwise we know this character will compensate the other half which we pushed earlier into the set, so we subtract missing \"type\" by 1\\n                        missing -= 1\\n                if missing == 0 and (j - i + 1) > maxlen:\\n                    maxlen = j - i + 1\\n                    start = i\\n        return s[start:(start + maxlen)]\\n```\\n**Complexity Analysis**\\n\\nTime Complexity:  O(N^2)\\nSpace Complexity: O(26) There are only 26 lowercase English characters\\n\\n## Approach 2:  Divide and Conquer\\nThe key observation here is that if a character doesn\\'t have its other half (different case but same character) in the given string, it can\\'t be included into any of the nice substring.\\nFor instance, let\\'s look at string **\"abcBCEAamM\"**. We notice that every alphabet has both cases present in the string except character **E**. So any nice string can\\'t have **E** in it. In other words, the longest nice substring must be either in **E**\\'s left side or its right side, namely **\"abcBC\"** or **\"AamM\"**. We notice that we just create 2 subproblems to find the longest nice substring in **\"abcBC\"** and  **\"AamM\"**. \\n\\nWhen we get result from solving left subproblem and right subproblem, we simply compare the length of two strings and return the one with longer length. Note that if both strings have the same length, we need to return the left one since the problem statement explicitly mentions: **If there are multiple, return the substring of the earliest occurrence.**\\n\\nNow what if we don\\'t see any un-paired character after we go through the string? That\\'s good because that means the original string is a nice string, so we simply return it since it must be the longest one.\\n\\nWhat\\'s the base case? Well, if the length of string is less than 2, it can\\'t be a nice string, so we return empty string in that case.\\n\\n``` python\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        def helper(i: int, j: int):\\n\\t\\t   # string length is less than 2 return empty string\\n\\t\\t   # we return a tuple to indicate the start and end index of the string to avoid unncessary string copy operation\\n            if j - i + 1 < 2: return (0, -1)\\n            hashset = set()\\n\\t\\t\\t# scan the string once and save all char into a set\\n            for k in range(i, j + 1):\\n                hashset.add(s[k])\\n            \\n            for k in range(i, j + 1):\\n\\t\\t\\t   # if this char pairs with its other half, we are good\\n                if s[k].upper() in hashset and s[k].lower() in hashset:\\n                    continue\\n\\t\\t\\t  # we found `E` !\\n                slt = helper(i, k - 1)\\n                srt = helper(k + 1, j)\\n                return slt if (slt[1] - slt[0] + 1) >= (srt[1] - srt[0] + 1) else srt\\n            return (i, j)\\n        lt, rt = helper(0, len(s) - 1)\\n        return s[lt:(rt + 1)]\\n```\\n\\n**Complexity Analysis**\\n\\nTime Complexity:  O(N x Log(N))   Doesn\\'t this look similar to quick sort? In each recursion call, we use O(N) to build the hash set and find the position of un-paired character. Then we create two subproblems whose size was reduced. Ideally if we could reduce size of each subproblem to N/2 every time, then O(N x Log(N) will be the answer for all possible input. However, just like quick sort, dividing each subproblem to N/2 every time is not guaranteed. Consider the following input: **\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"**\\n\\nEvery time we divide our subproblem to **\"\"** and **\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"**. It only reduces the subproblem size by 1. So time complexity for this input will be **O(N^2)**\\n\\nSpace Complexity: **O(N)**  There are only 26 lowercase English characters, so the space used by hash set is constant. However, we need to take recursion into consideration. In the worst case we mentioned above, the recursion depth can reach **N**. \\n\\n## Approach 3: Improved Divide and Conquer\\nIf we look at string \"AbMab**E**cBC**E**Aam**E**MmdDaA\", we notice the un-paired character E appears at multiple location in the original string. That means we can divide our original string into subproblems using E as delimeter:\\n**\"AbMab\"\\n\"cBC\"\\n\"Aam\"\\n\"MmdDaA\"**\\n\\nWe know one of the factors that determine the time complexity of divide and conqure algorithm is the depth of the recursion tree. Why does dividing subproblems in this way help improve the time complexity? Because every time we are removing one alphabet completely from the data set. There are only 26 lowercase English characters, so at most we only need to remove **26** times, which means the depth of recursion tree is bound to **26**\\n\\n``` python\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        def helper(i: int, j: int):\\n            if (j - i + 1) < 2: return (0,-1)\\n\\n            hashset = set()\\n            for k in range(i, j + 1):\\n                hashset.add(s[k])\\n            # use parts array to store position (index) of delimeter in sorted order\\n            parts = [i - 1]\\n            for k in range(i, j + 1):\\n                up = s[k].upper()\\n                lower = s[k].lower()\\n                if (up not in hashset) or (lower not in hashset): # un-paired character\\n                    parts.append(k)\\n            parts.append(j+1) \\n\\t\\t\\t# why do we have i - 1 and j + 1 in the array?\\n\\t\\t\\t# go through this example aAbbcCEdDEfF\\n\\t\\t\\t# the subproblems are:\\n\\t\\t\\t# [0, 5], [7, 8], [10, 11]\\n            max_len_pair = (0, -1)\\n\\t\\t\\t# if we don\\'t find any delimeter, then the original string is a nice string\\n            if len(parts) == 2:\\n                return (i, j)\\n\\t\\t\\t# call recursively to solve each subproblem\\n            for i in range(len(parts) - 1):\\n                ni, nj = helper(parts[i] + 1, parts[i+1] - 1)\\n                if (nj - ni + 1) > (max_len_pair[1] - max_len_pair[0] + 1):\\n                    max_len_pair = (ni, nj)\\n            \\n            return max_len_pair\\n        \\n        lt, rt = helper(0, len(s) - 1)\\n        return s[lt:(rt+1)]\\n```\\n**Complexity Analysis**\\n\\nTime Complexity:  O(N x 26) = O(N). Recall the recursion depth is bound to 26\\nLet\\'s look at the worst case in approach 2 this time  **\"aaaaaaaa\"**\\nThe first time we call recursion function, we find **a** is un-paired so we created 9 subprolems of size 0. So it takes O(9) = O(N) to solve it\\n\\nSpace Complexity: O(26) = O(1). The hashset can contain at most 26 unique characters. The recursion depth is bound to 26\\n\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Divide and Conquer"
                ],
                "code": "```python\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        N = len(s)\\n        maxlen = 0\\n        start = 0\\n        for i in range(N):\\n            seen = set()\\n            missing = 0\\n            for j in range(i, N):\\n\\t\\t\\t# if we haven\\'t seen this \"type\", add it into the seen set\\n                if s[j] not in seen: \\n                    seen.add(s[j])\\n\\t\\t\\t\\t\\t# since this is the first time we see this \"type\" of character\\n\\t\\t\\t\\t\\t# we check if the other half has already been seen before\\n                    if (s[j].lower() not in seen) or (s[j].upper() not in seen):\\n                        missing += 1 # we haven\\'t seen the other half yet, so adding 1 to the missing type\\n                    else: # otherwise we know this character will compensate the other half which we pushed earlier into the set, so we subtract missing \"type\" by 1\\n                        missing -= 1\\n                if missing == 0 and (j - i + 1) > maxlen:\\n                    maxlen = j - i + 1\\n                    start = i\\n        return s[start:(start + maxlen)]\\n```\n``` python\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        def helper(i: int, j: int):\\n\\t\\t   # string length is less than 2 return empty string\\n\\t\\t   # we return a tuple to indicate the start and end index of the string to avoid unncessary string copy operation\\n            if j - i + 1 < 2: return (0, -1)\\n            hashset = set()\\n\\t\\t\\t# scan the string once and save all char into a set\\n            for k in range(i, j + 1):\\n                hashset.add(s[k])\\n            \\n            for k in range(i, j + 1):\\n\\t\\t\\t   # if this char pairs with its other half, we are good\\n                if s[k].upper() in hashset and s[k].lower() in hashset:\\n                    continue\\n\\t\\t\\t  # we found `E` !\\n                slt = helper(i, k - 1)\\n                srt = helper(k + 1, j)\\n                return slt if (slt[1] - slt[0] + 1) >= (srt[1] - srt[0] + 1) else srt\\n            return (i, j)\\n        lt, rt = helper(0, len(s) - 1)\\n        return s[lt:(rt + 1)]\\n```\n``` python\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        def helper(i: int, j: int):\\n            if (j - i + 1) < 2: return (0,-1)\\n\\n            hashset = set()\\n            for k in range(i, j + 1):\\n                hashset.add(s[k])\\n            # use parts array to store position (index) of delimeter in sorted order\\n            parts = [i - 1]\\n            for k in range(i, j + 1):\\n                up = s[k].upper()\\n                lower = s[k].lower()\\n                if (up not in hashset) or (lower not in hashset): # un-paired character\\n                    parts.append(k)\\n            parts.append(j+1) \\n\\t\\t\\t# why do we have i - 1 and j + 1 in the array?\\n\\t\\t\\t# go through this example aAbbcCEdDEfF\\n\\t\\t\\t# the subproblems are:\\n\\t\\t\\t# [0, 5], [7, 8], [10, 11]\\n            max_len_pair = (0, -1)\\n\\t\\t\\t# if we don\\'t find any delimeter, then the original string is a nice string\\n            if len(parts) == 2:\\n                return (i, j)\\n\\t\\t\\t# call recursively to solve each subproblem\\n            for i in range(len(parts) - 1):\\n                ni, nj = helper(parts[i] + 1, parts[i+1] - 1)\\n                if (nj - ni + 1) > (max_len_pair[1] - max_len_pair[0] + 1):\\n                    max_len_pair = (ni, nj)\\n            \\n            return max_len_pair\\n        \\n        lt, rt = helper(0, len(s) - 1)\\n        return s[lt:(rt+1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074569,
                "title": "python-fast-simple-recursive-function-split-if-invalid-character-is-found",
                "content": "\\nI found this to be rather a medium problem :D Maybe I just missed something, but I\\'m sure there are more efficient solutions. Anyway, that\\'s the solution I came up with:\\n\\nEdit: currently it says *Runtime: 32 ms, faster than 100.00%* so apparently it\\'s at least not the worst approach.\\n\\n\\nExample-Input: \"YazaAay\"\\n- build a set of all letters (e.g.: {a,A, y,Y,z})\\n- go through the string, check if it has an invalid letter (for which NOT both upper and lower case version are in the set)\\n    - if so, split the string and check recursively for the left and the right substring if they are valid. return the longer one.\\n    \\n\\n\\n```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        if len(s) < 2: return \"\"\\n        chars = set(list(s))\\n        for i in range(len(s)):\\n            if not (s[i].lower() in chars and s[i].upper() in chars):\\n                s1 = self.longestNiceSubstring(s[:i])\\n                s2 = self.longestNiceSubstring(s[i+1:])\\n                return s2 if len(s2) > len(s1) else s1  \\n        return s    \\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        if len(s) < 2: return \"\"\\n        chars = set(list(s))\\n        for i in range(len(s)):\\n            if not (s[i].lower() in chars and s[i].upper() in chars):\\n                s1 = self.longestNiceSubstring(s[:i])\\n                s2 = self.longestNiceSubstring(s[i+1:])\\n                return s2 if len(s2) > len(s1) else s1  \\n        return s    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2237699,
                "title": "javascript-brute-force-and-divide-and-conquer-with-illustrations",
                "content": "# 1. Brute-force (not an optimal solution).\\nWe just make an assumption that if we invert case of chars in a nice string then we will have at least one char in the inverted string for each char in the original string. For example, `aA` -> inverting case -> `Aa` - each char from original string is present in inverted string but in different order. That what we do in the code.\\n**Example: s = \"YazaAay\"**\\n![image](https://assets.leetcode.com/users/images/b4a50e48-ae52-4dfc-ab3a-68272910b896_1656926927.247289.png)\\n\\n```\\nconst swapCase = (str) => str.split(\\'\\').map((c) => c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase()).join(\\'\\');\\n\\nvar longestNiceSubstring = function(s) {\\n    let ans = \"\";\\n        for (let i = 0; i < s.length; i++) {\\n            for (let ii = i + 1; ii < s.length + 1; ii++) {\\n                let substring = s.slice(i, ii); // we take a substring\\n\\n                let invertedCaseChars = [...substring].map(swapCase); // we create an array of chars from the substring and invert case of this chars\\n                \\n                if (invertedCaseChars.every(char => substring.includes(char))) { // we check that substring includes every case inverted char (see the illustration above)\\n                    ans = substring.length > ans.length ? substring : ans; // we select the longest substring which satisfies our condition\\n                }\\n            } \\n        }\\n        return ans \\n};\\n```\\n\\n# 2. Divide and Conquer (an optimal solution).\\nThis method is pretty similar to the brute-force. We check that the lowerCase and upperCase versions of a char are present in the Set, if not we divide the string by this char and solve similar problem but with smaller substring in the next recursions. It\\'s usually pretty hard to imagine the process of solving a problem with recursion that\\'s why I created the illustration:\\n![image](https://assets.leetcode.com/users/images/30a2794c-3ad9-426e-87b1-82739e099cf3_1656954664.9839346.png)\\n\\n\\n```\\nconst longestNiceSubstring = (s) => {\\n    if (s.length < 2) return \"\";\\n    let arr = [...s];\\n    let set = new Set(arr);\\n    for (let i = 0; i < arr.length; i++) {\\n        const c = arr[i];\\n        if (set.has(c.toUpperCase()) && set.has(c.toLowerCase())) continue;\\n        const sub1 = longestNiceSubstring(s.substring(0, i));\\n        const sub2 = longestNiceSubstring(s.substring(i + 1));\\n        return sub1.length >= sub2.length ? sub1 : sub2;\\n    }\\n    return s; \\n}\\n```\\n\\n\\n\\n\\nAlso, it\\'s not an easy problem.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst swapCase = (str) => str.split(\\'\\').map((c) => c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase()).join(\\'\\');\\n\\nvar longestNiceSubstring = function(s) {\\n    let ans = \"\";\\n        for (let i = 0; i < s.length; i++) {\\n            for (let ii = i + 1; ii < s.length + 1; ii++) {\\n                let substring = s.slice(i, ii); // we take a substring\\n\\n                let invertedCaseChars = [...substring].map(swapCase); // we create an array of chars from the substring and invert case of this chars\\n                \\n                if (invertedCaseChars.every(char => substring.includes(char))) { // we check that substring includes every case inverted char (see the illustration above)\\n                    ans = substring.length > ans.length ? substring : ans; // we select the longest substring which satisfies our condition\\n                }\\n            } \\n        }\\n        return ans \\n};\\n```\n```\\nconst longestNiceSubstring = (s) => {\\n    if (s.length < 2) return \"\";\\n    let arr = [...s];\\n    let set = new Set(arr);\\n    for (let i = 0; i < arr.length; i++) {\\n        const c = arr[i];\\n        if (set.has(c.toUpperCase()) && set.has(c.toLowerCase())) continue;\\n        const sub1 = longestNiceSubstring(s.substring(0, i));\\n        const sub2 = longestNiceSubstring(s.substring(i + 1));\\n        return sub1.length >= sub2.length ? sub1 : sub2;\\n    }\\n    return s; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1076728,
                "title": "easy-to-understand-c-faster-than-100-00",
                "content": "**Implementation**\\n\\n**1st Approach in C++**\\nTime Complexity = O(N^2), Space Complexity = O(1)\\n```\\nstring longestNiceSubstring(string s) {\\n    int maxLength = 0;        \\n    string result;\\n    for (int itr = 0; itr < s.size(); itr++)\\n    {\\n        bool large[26] = {};\\n        bool small[26] = {};\\n        for (int jtr = itr; jtr < s.size(); jtr++)\\n        {\\n            if (isupper(s[jtr]))\\n                large[s[jtr] - \\'A\\'] = true;\\n            else\\n                small[s[jtr] - \\'a\\'] = true;\\n            \\n            int length = jtr - itr + 1;\\n            if (length > maxLength)\\n            {\\n                int ktr = 0;\\n                for (; ktr < 26; ktr++){\\n                    if (large[ktr] != small[ktr]) break;\\n                }       \\n                \\n                if (ktr == 26)\\n                {\\n                    maxLength = length;\\n                    result = s.substr(itr, maxLength);                        \\n                }\\n            }\\n        }\\n    }\\n        \\n    if (maxLength == 0) return \"\";\\n    return result;\\n}\\n```\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring longestNiceSubstring(string s) {\\n    int maxLength = 0;        \\n    string result;\\n    for (int itr = 0; itr < s.size(); itr++)\\n    {\\n        bool large[26] = {};\\n        bool small[26] = {};\\n        for (int jtr = itr; jtr < s.size(); jtr++)\\n        {\\n            if (isupper(s[jtr]))\\n                large[s[jtr] - \\'A\\'] = true;\\n            else\\n                small[s[jtr] - \\'a\\'] = true;\\n            \\n            int length = jtr - itr + 1;\\n            if (length > maxLength)\\n            {\\n                int ktr = 0;\\n                for (; ktr < 26; ktr++){\\n                    if (large[ktr] != small[ktr]) break;\\n                }       \\n                \\n                if (ktr == 26)\\n                {\\n                    maxLength = length;\\n                    result = s.substr(itr, maxLength);                        \\n                }\\n            }\\n        }\\n    }\\n        \\n    if (maxLength == 0) return \"\";\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2605338,
                "title": "python-divide-and-conquer",
                "content": "E.g. if we are given \"YazaAay\"\\n\\n\\nThen if we see, all the characters have their lowercase and uppercase variants except only \"z\".\\n\\nThis means that we can never have a valid subarray with \"z\" in it. \\n\\nSo, we need to look for a valid subarray before \"z\" and after \"z\" only. \\n\\nIn this string there is only one invalid character but there can be multiple. So, we simply create a set of all the characters and then, while looping over the string, just check if that character has its case variation in the set or not. If not, that means it is an invalid character and we need to find the valid substring before and after this character\\'s index. So we will make two recursive calls. One for finding a valid substring from beginning to  the invalid character\\'s index (excluding it) and the other to find a valid substring from the invalid character\\'s index + 1 to the end of the string.\\n\\nAnd if we get a valid substring out of both or even from just one, that means, just return the one that\\'s longer.\\n\\nIt is also possible that a string is already nice. e.g. \"aAa\". In this case, the recursive calls won\\'t be made since they are only made when we encounter an invalid character. So in such cases, we can return the string itself at the end. \\n\\n\\n```\\ndef longestNiceSubstring(self, s: str) -> str:\\n        \\n        # If length of string is less than 2, there is no way we can get a nice substring out of it\\n        if len(s) < 2 : return \"\"\\n        \\n        # A set of all characters in the given string\\n        ulSet = set(s)\\n        \\n        for i,c in enumerate(s):\\n            # If character is lowercase and the set does not have its uppercase variation or vice versa\\n            # It means that we need to not consider this character at all and so, find the longest substring till this character and after this character\\n            # Repeat this till we reach the end\\n            if c.swapcase() not in ulSet:\\n                s1 = self.longestNiceSubstring(s[0:i])\\n                s2 = self.longestNiceSubstring(s[i+1:])\\n                \\n                return s2 if len(s2) > len(s1) else s1\\n        \\n        \\n        # If the above recursive calls don\\'t happen that means our string has each character in lowercase and uppercase already so we can return it\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\ndef longestNiceSubstring(self, s: str) -> str:\\n        \\n        # If length of string is less than 2, there is no way we can get a nice substring out of it\\n        if len(s) < 2 : return \"\"\\n        \\n        # A set of all characters in the given string\\n        ulSet = set(s)\\n        \\n        for i,c in enumerate(s):\\n            # If character is lowercase and the set does not have its uppercase variation or vice versa\\n            # It means that we need to not consider this character at all and so, find the longest substring till this character and after this character\\n            # Repeat this till we reach the end\\n            if c.swapcase() not in ulSet:\\n                s1 = self.longestNiceSubstring(s[0:i])\\n                s2 = self.longestNiceSubstring(s[i+1:])\\n                \\n                return s2 if len(s2) > len(s1) else s1\\n        \\n        \\n        # If the above recursive calls don\\'t happen that means our string has each character in lowercase and uppercase already so we can return it\\n        return s\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1075274,
                "title": "java-solution-with-set-comment-explanation",
                "content": "```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        String result = \"\";\\n        // take first index, go from 0 to length-1 of the string\\n\\t\\tfor (int i = 0;i<s.length(); i++){        \\n            // take second index, this should go up to the length of the string <=\\n\\t\\t\\tfor (int j = i+1;j<=s.length(); j++){\\n                //get the substring for the index range from i to j\\n\\t\\t\\t\\tString temp = s.substring(i, j);\\n                // if length of the substring should be greater than 1\\n\\t\\t\\t\\t// if the length should be greater that the previous computed result\\n\\t\\t\\t\\t// if the substring is valid Nice String\\n\\t\\t\\t\\t// then update the result with the current substring from range i and j\\n\\t\\t\\t\\tif (temp.length() > 1 && result.length() < temp.length() && checkNice(temp)) result = temp;\\n            }    \\n        }\\n        return result;\\n    }\\n    \\n\\t//validate Nice String check\\n    public boolean checkNice(String temp){\\n        //add substring to the set\\n\\t\\tSet<Character> s = new HashSet<>();\\n        for (char ch : temp.toCharArray()) s.add(ch);\\n        \\n\\t\\t// return false If you do not find both lower case and upper case in the sub string\\n\\t\\t//for e.g \\'aAa\\' substring added to set will have both a and A in the substring which is valid\\n\\t\\t// \\'azaA\\' substring will fail for \\'z\\'\\n\\t\\t// \\'aaaaaaaa\\' will return \"\" as result\\n\\t\\t//make sure that the substring contains both lower and upper case\\n        for (char ch : s)\\n            if (s.contains(Character.toUpperCase(ch)) != s.contains(Character.toLowerCase(ch))) return false;  \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        String result = \"\";\\n        // take first index, go from 0 to length-1 of the string\\n\\t\\tfor (int i = 0;i<s.length(); i++){        \\n            // take second index, this should go up to the length of the string <=\\n\\t\\t\\tfor (int j = i+1;j<=s.length(); j++){\\n                //get the substring for the index range from i to j\\n\\t\\t\\t\\tString temp = s.substring(i, j);\\n                // if length of the substring should be greater than 1\\n\\t\\t\\t\\t// if the length should be greater that the previous computed result\\n\\t\\t\\t\\t// if the substring is valid Nice String\\n\\t\\t\\t\\t// then update the result with the current substring from range i and j\\n\\t\\t\\t\\tif (temp.length() > 1 && result.length() < temp.length() && checkNice(temp)) result = temp;\\n            }    \\n        }\\n        return result;\\n    }\\n    \\n\\t//validate Nice String check\\n    public boolean checkNice(String temp){\\n        //add substring to the set\\n\\t\\tSet<Character> s = new HashSet<>();\\n        for (char ch : temp.toCharArray()) s.add(ch);\\n        \\n\\t\\t// return false If you do not find both lower case and upper case in the sub string\\n\\t\\t//for e.g \\'aAa\\' substring added to set will have both a and A in the substring which is valid\\n\\t\\t// \\'azaA\\' substring will fail for \\'z\\'\\n\\t\\t// \\'aaaaaaaa\\' will return \"\" as result\\n\\t\\t//make sure that the substring contains both lower and upper case\\n        for (char ch : s)\\n            if (s.contains(Character.toUpperCase(ch)) != s.contains(Character.toLowerCase(ch))) return false;  \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1328541,
                "title": "java-easy-to-understand-solution",
                "content": "# Explanation\\n1. Divide the string if you get the character which pair is not present.\\n2. And solve recusively\\n```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        Set<Character> charSet = new HashSet<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            charSet.add(s.charAt(i));\\n        }\\n        for (int i = 0; i < s.length(); i++) {\\n            if (charSet.contains(Character.toUpperCase(s.charAt(i))) &&\\n                    charSet.contains(Character.toLowerCase(s.charAt(i)))) {\\n                continue;\\n            }\\n            String s1 = longestNiceSubstring(s.substring(0, i));\\n            String s2 = longestNiceSubstring(s.substring(i+1));\\n            return s1.length()>= s2.length() ? s1 : s2;\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        Set<Character> charSet = new HashSet<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            charSet.add(s.charAt(i));\\n        }\\n        for (int i = 0; i < s.length(); i++) {\\n            if (charSet.contains(Character.toUpperCase(s.charAt(i))) &&\\n                    charSet.contains(Character.toLowerCase(s.charAt(i)))) {\\n                continue;\\n            }\\n            String s1 = longestNiceSubstring(s.substring(0, i));\\n            String s2 = longestNiceSubstring(s.substring(i+1));\\n            return s1.length()>= s2.length() ? s1 : s2;\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075320,
                "title": "c-divide-and-conquer-o-n-time",
                "content": "## Solution 1. Divide and Conquer\\n### Time complexity\\n\\nThe depth of the recursion is at most 26 levels, each of which we use a letter to split the windows.\\n\\nIn each recursion, we traverse the string in `O(N)` time. Even though we take substring, each letter is at most copied once, so overall each recursion is still `O(N)`.\\n\\nSo the overall time complexity is `O(26N) = O(N)`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/longest-nice-substring/\\n// Author: github.com/lzl124631x\\n// Time: O(N), the depth of the recursion is at most 26.\\n// Space: O(N)\\nclass Solution {\\n    string ans;\\npublic:\\n    string longestNiceSubstring(string s) {\\n        int state[26] = {};\\n        for (char c : s) {\\n            if (isupper(c)) state[c - \\'A\\'] |= 2;\\n            else state[c - \\'a\\'] |= 1;\\n        }\\n        int i = 0, N = s.size();\\n        while (i < N) {\\n            int j = i;\\n            while (j < N && state[tolower(s[j]) - \\'a\\'] == 3) ++j; // find the window only contain characters that in state 3, i.e. having both upper and lower case\\n            int len = j - i;\\n            if (len == N) { // this string itself is nice, update the answer\\n                ans = s;\\n                break;\\n            }\\n            if (len > ans.size()) longestNiceSubstring(s.substr(i, len)); // handle this window recursively. The recursion is at most 26 levels.\\n            while (j < N && state[tolower(s[j]) - \\'a\\'] != 3) ++j;\\n            i = j;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/longest-nice-substring/\\n// Author: github.com/lzl124631x\\n// Time: O(N), the depth of the recursion is at most 26.\\n// Space: O(N)\\nclass Solution {\\n    string ans;\\npublic:\\n    string longestNiceSubstring(string s) {\\n        int state[26] = {};\\n        for (char c : s) {\\n            if (isupper(c)) state[c - \\'A\\'] |= 2;\\n            else state[c - \\'a\\'] |= 1;\\n        }\\n        int i = 0, N = s.size();\\n        while (i < N) {\\n            int j = i;\\n            while (j < N && state[tolower(s[j]) - \\'a\\'] == 3) ++j; // find the window only contain characters that in state 3, i.e. having both upper and lower case\\n            int len = j - i;\\n            if (len == N) { // this string itself is nice, update the answer\\n                ans = s;\\n                break;\\n            }\\n            if (len > ans.size()) longestNiceSubstring(s.substr(i, len)); // handle this window recursively. The recursion is at most 26 levels.\\n            while (j < N && state[tolower(s[j]) - \\'a\\'] != 3) ++j;\\n            i = j;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074844,
                "title": "python3-recursive-divide-and-conquer-solution-o-n",
                "content": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        def divcon(s):\\n\\t\\t    # string with length 1 or less arent considered nice\\n            if len(s) < 2:\\n                return \"\"\\n            \\n            pivot = []\\n            # get every character that is not nice\\n            for i, ch in enumerate(s):\\n                if ch.isupper() and ch.lower() not in s:\\n                    pivot.append(i)\\n                if ch.islower() and ch.upper() not in s:\\n                    pivot.append(i)\\n\\t\\t\\t# if no such character return the string\\n            if not pivot:\\n                return s\\n\\t\\t\\t# divide the string in half excluding the char that makes the string not nice\\n            else:\\n                mid = (len(pivot)) // 2\\n                return max(divcon(s[:pivot[mid]]),divcon(s[pivot[mid]+1:]),key=len)\\n        \\n        return divcon(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        def divcon(s):\\n\\t\\t    # string with length 1 or less arent considered nice\\n            if len(s) < 2:\\n                return \"\"\\n            \\n            pivot = []\\n            # get every character that is not nice\\n            for i, ch in enumerate(s):\\n                if ch.isupper() and ch.lower() not in s:\\n                    pivot.append(i)\\n                if ch.islower() and ch.upper() not in s:\\n                    pivot.append(i)\\n\\t\\t\\t# if no such character return the string\\n            if not pivot:\\n                return s\\n\\t\\t\\t# divide the string in half excluding the char that makes the string not nice\\n            else:\\n                mid = (len(pivot)) // 2\\n                return max(divcon(s[:pivot[mid]]),divcon(s[pivot[mid]+1:]),key=len)\\n        \\n        return divcon(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083676,
                "title": "java-0ms-100-convert-chars-to-bit-masks-or-and-xor-divide-and-conquer",
                "content": "Thanks to [stefal](https://leetcode.com/stefal) for pointing out a typo I had, which reduced run time from 1ms to 0ms.\\n```\\nclass Solution {\\n    int scLen;\\n    long[] scBits;\\n    int longestLen = 0;\\n    int longestStart = 0;\\n    \\n    \\n    public String longestNiceSubstring(String s) {\\n        // Convert the input string into a long[] array containg a bit mask for each \\n        // corresponding character.  After this, we don\\'t need to process characters until \\n        // we are ready to return the result, because we will be doing all the processing \\n        // with the array of bit masks.\\n        //\\n        // Because there are only uppercase and lowercase characters, and because of the \\n        // values of these characters are between 64 and 127, then a single Long can hold \\n        // bits where each letter will have it\\'s own bit.  The bits in the lower 32 bits \\n        // of the Long will contain the bits for uppercase characters,  The bits in the \\n        // higher 32 bits of the Long will contain bits for lowercase characters.\\n        //\\n        // Examples:\\n        //         char                                         bit mask value\\n        //      ----------    ------------------------------------------------------\\n        //      \\'A\\' == 65       65-\\'@\\' == 1   -->  1L << 1  == 0x00000000_00000002\\n        //      \\'a\\' == 97       97-\\'@\\' == 33  -->  1L << 33 == 0x00000002_00000000\\n        //      \\'Y\\' == 89       89-\\'@\\' == 25  -->  1L << 25 == 0x00000000_02000000\\n        //      \\'y\\' == 121     121-\\'@\\' == 57  -->  1L << 57 == 0x02000000_00000000\\n        //      \\'z\\' == 122     122-\\'@\\' == 58  -->  1L << 26 == 0x04000000_00000000\\n        //\\n        //      If passed string s is \"YazaAay\", then OR of the entire string is\\n        //              0x00000000_02000000     Y\\n        //              0x00000002_00000000     a\\n        //              0x04000000_00000000     z\\n        //              0x00000002_00000000     a\\n        //              0x00000000_00000002     A\\n        //              0x00000002_00000000     a\\n        //          OR  0x02000000_00000000     y\\n        //          ------------------------\\n        //              0x06000002_02000002\\n        //      \\n        //      From the above OR\\'ed result of 0x06000002_02000002, we then XOR the lower \\n        //      32 bits with the higher 32 bits as:\\n        //\\n        //              0x00000002  lower 32 bits\\n        //          XOR 0x06000002  higher 32 bits\\n        //          ---------------\\n        //              0x04000000  (Shows that \\'Z\\' or \\'z\\' are unmatched uppercase/lowercase)\\n        //\\n        //      Copying the above XOR result to both the lower 32 bits and higher 32 bits of a \\n        //      Long will result in a Long value of:\\n        //\\n        //              0x04000000_04000000\\n        //\\n        //      We can then use the above value to scan through the string, which has already been \\n        //      converted to an array of Long bit masks, where each character is represented by it\\'s \\n        //      bit mask.  For a character in the string, if that character\\'s bit mask is AND\\'ed with \\n        //      the above value, and the result of the AND is non-zero, then that character does NOT \\n        //      have matching uppercase and lowercase within the string.  If all of the AND\\'s result \\n        //      in a zero value, then the string (or substring) is \"nice\" and all characters have \\n        //      matching uppercase and lowercase.\\n        //\\n        int scLen = s.length();\\n        scBits = new long[scLen];\\n        for (int i = 0; i < scLen; i++)\\n            scBits[i] = 1L << (s.charAt(i) - \\'@\\');\\n\\n        // Scan the entire passed String s.  This will recurse as needed.\\n        checkRange(0, scLen);\\n        \\n        return (longestLen == 0) ? \"\" : s.substring(longestStart, longestStart + longestLen);\\n    }\\n\\n    \\n    \\n    // To check if a substring contains only letters that have both uppercase and \\n    // lowercase letters, we will only have to OR together the bit masks for each \\n    // character in the substring, into a Long which is a composite of all bit masks \\n    // from the substring.  Then we XOR the top 32 bits of this composite value, with \\n    // the bottom 32 bits of this composite value.  If this XOR\\'ed result is zero, \\n    // then the substring contains only characters with matching uppercase and lowercase.  \\n    // if the XOR\\'ed result is non-zero, then the XOR\\'ed result contains the bit mask of \\n    // all unmatched characters.  We can then make another pass through this substring \\n    // while using the XOR\\'ed result to locate unmatched characters.  We then recurse on \\n    // the sub-substrings between the unmatched characters.\\n    //\\n    private void checkRange(int startIdx, int endIdx) {\\n        // Get a bitmask for all characters in this section of the string that DO NOT have \\n        // matching uppercase and lowercase characters.\\n        long unmatchedChars = 0;\\n        for (int i = startIdx; i < endIdx; i++)\\n            unmatchedChars |= scBits[i];\\n        unmatchedChars = (unmatchedChars ^ (unmatchedChars >>> 32)) & 0xFFFFFFFFL;\\n        unmatchedChars |= (unmatchedChars << 32);\\n        \\n        // If ALL characters in this section of the string have both uppercase and lowercase, \\n        // then this is the new longest \"nice\" substring.\\n        if (unmatchedChars == 0) {\\n            longestLen = endIdx - startIdx;\\n            longestStart = startIdx;\\n        }\\n        \\n        // Else break the string into substrings between unmatched uppercase/lowercase characters, \\n        // and recurse to check these substrings.\\n        else {        \\n            int substrStart = startIdx;\\n            for (int i = startIdx; i < endIdx; i++) {\\n                if ((scBits[i] & unmatchedChars) != 0) {\\n                    if (i - substrStart > longestLen)\\n                        checkRange(substrStart, i);\\n                    substrStart = i + 1;\\n                }\\n            }\\n            if (endIdx - substrStart > longestLen)\\n                checkRange(substrStart, endIdx);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int scLen;\\n    long[] scBits;\\n    int longestLen = 0;\\n    int longestStart = 0;\\n    \\n    \\n    public String longestNiceSubstring(String s) {\\n        // Convert the input string into a long[] array containg a bit mask for each \\n        // corresponding character.  After this, we don\\'t need to process characters until \\n        // we are ready to return the result, because we will be doing all the processing \\n        // with the array of bit masks.\\n        //\\n        // Because there are only uppercase and lowercase characters, and because of the \\n        // values of these characters are between 64 and 127, then a single Long can hold \\n        // bits where each letter will have it\\'s own bit.  The bits in the lower 32 bits \\n        // of the Long will contain the bits for uppercase characters,  The bits in the \\n        // higher 32 bits of the Long will contain bits for lowercase characters.\\n        //\\n        // Examples:\\n        //         char                                         bit mask value\\n        //      ----------    ------------------------------------------------------\\n        //      \\'A\\' == 65       65-\\'@\\' == 1   -->  1L << 1  == 0x00000000_00000002\\n        //      \\'a\\' == 97       97-\\'@\\' == 33  -->  1L << 33 == 0x00000002_00000000\\n        //      \\'Y\\' == 89       89-\\'@\\' == 25  -->  1L << 25 == 0x00000000_02000000\\n        //      \\'y\\' == 121     121-\\'@\\' == 57  -->  1L << 57 == 0x02000000_00000000\\n        //      \\'z\\' == 122     122-\\'@\\' == 58  -->  1L << 26 == 0x04000000_00000000\\n        //\\n        //      If passed string s is \"YazaAay\", then OR of the entire string is\\n        //              0x00000000_02000000     Y\\n        //              0x00000002_00000000     a\\n        //              0x04000000_00000000     z\\n        //              0x00000002_00000000     a\\n        //              0x00000000_00000002     A\\n        //              0x00000002_00000000     a\\n        //          OR  0x02000000_00000000     y\\n        //          ------------------------\\n        //              0x06000002_02000002\\n        //      \\n        //      From the above OR\\'ed result of 0x06000002_02000002, we then XOR the lower \\n        //      32 bits with the higher 32 bits as:\\n        //\\n        //              0x00000002  lower 32 bits\\n        //          XOR 0x06000002  higher 32 bits\\n        //          ---------------\\n        //              0x04000000  (Shows that \\'Z\\' or \\'z\\' are unmatched uppercase/lowercase)\\n        //\\n        //      Copying the above XOR result to both the lower 32 bits and higher 32 bits of a \\n        //      Long will result in a Long value of:\\n        //\\n        //              0x04000000_04000000\\n        //\\n        //      We can then use the above value to scan through the string, which has already been \\n        //      converted to an array of Long bit masks, where each character is represented by it\\'s \\n        //      bit mask.  For a character in the string, if that character\\'s bit mask is AND\\'ed with \\n        //      the above value, and the result of the AND is non-zero, then that character does NOT \\n        //      have matching uppercase and lowercase within the string.  If all of the AND\\'s result \\n        //      in a zero value, then the string (or substring) is \"nice\" and all characters have \\n        //      matching uppercase and lowercase.\\n        //\\n        int scLen = s.length();\\n        scBits = new long[scLen];\\n        for (int i = 0; i < scLen; i++)\\n            scBits[i] = 1L << (s.charAt(i) - \\'@\\');\\n\\n        // Scan the entire passed String s.  This will recurse as needed.\\n        checkRange(0, scLen);\\n        \\n        return (longestLen == 0) ? \"\" : s.substring(longestStart, longestStart + longestLen);\\n    }\\n\\n    \\n    \\n    // To check if a substring contains only letters that have both uppercase and \\n    // lowercase letters, we will only have to OR together the bit masks for each \\n    // character in the substring, into a Long which is a composite of all bit masks \\n    // from the substring.  Then we XOR the top 32 bits of this composite value, with \\n    // the bottom 32 bits of this composite value.  If this XOR\\'ed result is zero, \\n    // then the substring contains only characters with matching uppercase and lowercase.  \\n    // if the XOR\\'ed result is non-zero, then the XOR\\'ed result contains the bit mask of \\n    // all unmatched characters.  We can then make another pass through this substring \\n    // while using the XOR\\'ed result to locate unmatched characters.  We then recurse on \\n    // the sub-substrings between the unmatched characters.\\n    //\\n    private void checkRange(int startIdx, int endIdx) {\\n        // Get a bitmask for all characters in this section of the string that DO NOT have \\n        // matching uppercase and lowercase characters.\\n        long unmatchedChars = 0;\\n        for (int i = startIdx; i < endIdx; i++)\\n            unmatchedChars |= scBits[i];\\n        unmatchedChars = (unmatchedChars ^ (unmatchedChars >>> 32)) & 0xFFFFFFFFL;\\n        unmatchedChars |= (unmatchedChars << 32);\\n        \\n        // If ALL characters in this section of the string have both uppercase and lowercase, \\n        // then this is the new longest \"nice\" substring.\\n        if (unmatchedChars == 0) {\\n            longestLen = endIdx - startIdx;\\n            longestStart = startIdx;\\n        }\\n        \\n        // Else break the string into substrings between unmatched uppercase/lowercase characters, \\n        // and recurse to check these substrings.\\n        else {        \\n            int substrStart = startIdx;\\n            for (int i = startIdx; i < endIdx; i++) {\\n                if ((scBits[i] & unmatchedChars) != 0) {\\n                    if (i - substrStart > longestLen)\\n                        checkRange(substrStart, i);\\n                    substrStart = i + 1;\\n                }\\n            }\\n            if (endIdx - substrStart > longestLen)\\n                checkRange(substrStart, endIdx);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762392,
                "title": "solution-with-recursion-beats-93-85-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n\\n        if len(s)<2:\\n            return \"\"\\n        valid=True\\n        for i in range(len(s)):\\n            if ord(s[i])>95 and s[i].upper() in s:\\n                    continue\\n            elif ord(s[i])<95 and s[i].lower() in s:\\n                    continue\\n            else:\\n                valid=False\\n                break\\n        if  valid:\\n            return s\\n        else:\\n            right=self.longestNiceSubstring(s[:i])\\n            left=self.longestNiceSubstring(s[i+1:])\\n            \\n            if len(left)<=len(right):\\n                return right\\n            else:\\n                return left \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n\\n        if len(s)<2:\\n            return \"\"\\n        valid=True\\n        for i in range(len(s)):\\n            if ord(s[i])>95 and s[i].upper() in s:\\n                    continue\\n            elif ord(s[i])<95 and s[i].lower() in s:\\n                    continue\\n            else:\\n                valid=False\\n                break\\n        if  valid:\\n            return s\\n        else:\\n            right=self.longestNiceSubstring(s[:i])\\n            left=self.longestNiceSubstring(s[i+1:])\\n            \\n            if len(left)<=len(right):\\n                return right\\n            else:\\n                return left \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885876,
                "title": "python-simple-and-elegant-multiple-solutions",
                "content": "**Brute Force**:\\n```\\nclass Solution:\\n    def longestNiceSubstring(self, s):\\n        subs = [s[i:j] for i in range(len(s)) for j in range(i+1, len(s)+1)]\\n        nice = [sub for sub in subs if set(sub)==set(sub.swapcase())]\\n        return max(nice, key=len, default=\"\")\\n```\\n\\n**Divide and Conquer ([Credit](https://leetcode.com/problems/longest-nice-substring/discuss/1074546/Python3-brute-force-and-divide-and-conquer))**:\\n```\\nclass Solution:\\n    def longestNiceSubstring(self, s):\\n        chars = set(s)\\n        for i, c in enumerate(s):\\n            if c.swapcase() not in chars:\\n                return max(map(self.longestNiceSubstring, [s[:i], s[i+1:]]), key=len)\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s):\\n        subs = [s[i:j] for i in range(len(s)) for j in range(i+1, len(s)+1)]\\n        nice = [sub for sub in subs if set(sub)==set(sub.swapcase())]\\n        return max(nice, key=len, default=\"\")\\n```\n```\\nclass Solution:\\n    def longestNiceSubstring(self, s):\\n        chars = set(s)\\n        for i, c in enumerate(s):\\n            if c.swapcase() not in chars:\\n                return max(map(self.longestNiceSubstring, [s[:i], s[i+1:]]), key=len)\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531119,
                "title": "c-2-approaches-explanation-bitmanipulation-divide-and-conquer",
                "content": "***1.) Bit Manipulation :\\nExplanation :*** \\uD83D\\uDCCA\\n**In the ASCII TABLE :**\\n***Range of Capital letters |\\u2081\\u2080 : A to Z***  ( from **65**(***A***) to **90**(***Z***) )\\n***Range of Cursive/ Small letters |\\u2081\\u2080 : a to z*** (from **97**(***a***) to **122**(***z***));\\n\\nUsing Double for loop for iterating over every substring : \\n***Condition :  if (s[j]>=\\'a\\')***  means s[j] is ***lowercase***.\\n***else*** it is ***uppercase***\\n\\n***(1<<(s[j]-\\'a\\'))***  : convert to integer .\\nEg : ***string s= abcABC*** \\n***a***-> 0 , ***b***-> 1, ***c***->2 (in integer)\\n***A***-> 0 , ***B***-> 1, ***C***->2 (in integer)\\n***exor :*** 1^2^3^1^2^3 =0  , Therefore , it is a ***valid*** string .\\n\\n**UPVOTE IF YOU LIKE** \\uD83D\\uDE07\\u2705\\n```\\n\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        int maxLength=0,idx=0;  // idx stores the starting index of the substring\\n        int lowerCase,upperCase;\\n        for (int i=0;i<s.length();i++)\\n        {\\n            lowerCase=0;\\n            upperCase=0;\\n            for (int j=i;j<s.length();j++)\\n            {\\n                if (s[j]>=\\'a\\')\\n                    lowerCase|=(1<<(s[j]-\\'a\\'));\\n                else \\n                    upperCase|=(1<<(s[j]-\\'A\\'));\\n                if ((lowerCase^upperCase)==0)\\n                {\\n                    if (maxLength<j-i+1)\\n                    {\\n                        idx=i;\\n                        maxLength=j-i+1;\\n                    }\\n                }\\n            }\\n        }\\n        if (maxLength==0)\\n            return \"\";\\n        return s.substr(idx,maxLength);\\n    }\\n};\\n```\\n***2.) Divide and Conquer  Approach :\\nExplanation :*** \\uD83D\\uDD11\\nFirstly  ,we store all characters in the set (no duplicates ) for O(1) access.\\nIf for a char in lower case , the corresponding uppercase is not present , and vis a vis , \\nwe cannot include it in answer, \\n->We divide string int substring . ***(Standard Divide and Conquer Structure )*** \\u270C\\uFE0F\\n->Select the string with larger length . \\n->Combine and return  the resultant string.\\n```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        if(s.length()<2)return \"\";\\n        \\n        unordered_set<char>set(s.begin(), s.end()); // store all the characters of string s\\n        \\n        for(int i=0; i<s.length(); ++i){\\n            // if corresponding upper or lower character not present we know it will\\n            // never be present in our answer substring\\n            if(set.find(toupper(s[i]))==set.end() || set.find(tolower(s[i]))==set.end()){\\n\\t\\t\\t   //Divide and Conquer step :\\n                string s1 = longestNiceSubstring(s.substr(0, i));\\n                string s2 = longestNiceSubstring(s.substr(i+1));\\n                return s1.size() >= s2.size() ? s1 : s2;\\n            }\\n        }\\n        \\n        return s; // whole string is the answer\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Divide and Conquer",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        int maxLength=0,idx=0;  // idx stores the starting index of the substring\\n        int lowerCase,upperCase;\\n        for (int i=0;i<s.length();i++)\\n        {\\n            lowerCase=0;\\n            upperCase=0;\\n            for (int j=i;j<s.length();j++)\\n            {\\n                if (s[j]>=\\'a\\')\\n                    lowerCase|=(1<<(s[j]-\\'a\\'));\\n                else \\n                    upperCase|=(1<<(s[j]-\\'A\\'));\\n                if ((lowerCase^upperCase)==0)\\n                {\\n                    if (maxLength<j-i+1)\\n                    {\\n                        idx=i;\\n                        maxLength=j-i+1;\\n                    }\\n                }\\n            }\\n        }\\n        if (maxLength==0)\\n            return \"\";\\n        return s.substr(idx,maxLength);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        if(s.length()<2)return \"\";\\n        \\n        unordered_set<char>set(s.begin(), s.end()); // store all the characters of string s\\n        \\n        for(int i=0; i<s.length(); ++i){\\n            // if corresponding upper or lower character not present we know it will\\n            // never be present in our answer substring\\n            if(set.find(toupper(s[i]))==set.end() || set.find(tolower(s[i]))==set.end()){\\n\\t\\t\\t   //Divide and Conquer step :\\n                string s1 = longestNiceSubstring(s.substr(0, i));\\n                string s2 = longestNiceSubstring(s.substr(i+1));\\n                return s1.size() >= s2.size() ? s1 : s2;\\n            }\\n        }\\n        \\n        return s; // whole string is the answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790784,
                "title": "python-3-using-a-decreasing-sliding-window",
                "content": "The intuition behind my approach is to check validity for substings starting with the longest one and decreasing our window size.\\n\\nThe difficult part was determining how to write a function that would determine \"niceness.\" The intuition behind the function I wrote is that if we compare the number of unique characters in a substring and the number of unique characters in the same substring but lowercased, a \"nice\" substring would have the property that `len(set(substring.lower())) == len(set(substring))`, since each lowercase letter must have a corresponding uppercase letter.\\n\\n```\\nclass Solution:\\n    def get_nice(self, s: str) -> bool:\\n        return len(set(s.lower())) == (len(set(s)) // 2)\\n        \\n    def longestNiceSubstring(self, s: str) -> str:\\n        window_size = len(s)\\n        \\n        while window_size:\\n            for i in range(len(s) - window_size + 1):\\n                substring = s[i:i + window_size]\\n                \\n                if self.get_nice(substring):\\n                    return substring\\n                \\n            window_size -= 1\\n            \\n        return \\'\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def get_nice(self, s: str) -> bool:\\n        return len(set(s.lower())) == (len(set(s)) // 2)\\n        \\n    def longestNiceSubstring(self, s: str) -> str:\\n        window_size = len(s)\\n        \\n        while window_size:\\n            for i in range(len(s) - window_size + 1):\\n                substring = s[i:i + window_size]\\n                \\n                if self.get_nice(substring):\\n                    return substring\\n                \\n            window_size -= 1\\n            \\n        return \\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506855,
                "title": "c-simple-easy-to-understand",
                "content": "```\\nbool check(string s){\\n        for(int i=0;i<s.size();i++) {\\n            char c = s[i];\\n            if(c<=90) c += 32;\\n            else c -= 32;\\n            if(s.find(c)==string::npos) return false;\\n        }\\n        return true;\\n    }\\n    string longestNiceSubstring(string s) {\\n        string ans = \"\";\\n        for(int i=0;i<s.size();i++){\\n            string res = \"\";\\n            res += s[i];\\n            for(int j = i+1;j<s.size();j++){\\n                res += s[j];\\n                if(check(res) and res.size()>ans.size()) ans = res;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\nUpvote, if it helped..",
                "solutionTags": [
                    "C++",
                    "C",
                    "Divide and Conquer"
                ],
                "code": "```\\nbool check(string s){\\n        for(int i=0;i<s.size();i++) {\\n            char c = s[i];\\n            if(c<=90) c += 32;\\n            else c -= 32;\\n            if(s.find(c)==string::npos) return false;\\n        }\\n        return true;\\n    }\\n    string longestNiceSubstring(string s) {\\n        string ans = \"\";\\n        for(int i=0;i<s.size();i++){\\n            string res = \"\";\\n            res += s[i];\\n            for(int j = i+1;j<s.size();j++){\\n                res += s[j];\\n                if(check(res) and res.size()>ans.size()) ans = res;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3013228,
                "title": "elegant-divide-and-conquer-approach",
                "content": "# Intuition\\nWe are using recursion here\\n\\n# Approach\\nWe find the first letter in the string which doesn\\'t have complementary and divide string into two substrings - and so on until we find the string without single letters\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        sSet = set(s)\\n        for i in range(len(s)):\\n            if s[i].lower() not in sSet or s[i].upper() not in sSet:\\n                lns1 = self.longestNiceSubstring(s[:i])\\n                lns2 = self.longestNiceSubstring(s[i+1:])\\n\\n                return max(lns1, lns2, key=len)\\n\\n        return s\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        sSet = set(s)\\n        for i in range(len(s)):\\n            if s[i].lower() not in sSet or s[i].upper() not in sSet:\\n                lns1 = self.longestNiceSubstring(s[:i])\\n                lns2 = self.longestNiceSubstring(s[i+1:])\\n\\n                return max(lns1, lns2, key=len)\\n\\n        return s\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761700,
                "title": "nice",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        def pper(s):\\n            for i in s:\\n                if i.lower() in s and i.upper() in s:\\n                    pass\\n                else:\\n                    return False\\n            return True        \\n        m=\"\"\\n        for i in range(len(s)):\\n            for j in range(i+1,len(s)):\\n                if pper(s[i:j+1]) and len(m)<len(s[i:j+1]):\\n                    m=s[i:j+1]\\n        return m\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        def pper(s):\\n            for i in s:\\n                if i.lower() in s and i.upper() in s:\\n                    pass\\n                else:\\n                    return False\\n            return True        \\n        m=\"\"\\n        for i in range(len(s)):\\n            for j in range(i+1,len(s)):\\n                if pper(s[i:j+1]) and len(m)<len(s[i:j+1]):\\n                    m=s[i:j+1]\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700228,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou have to find the characters which does not have it\\'s complimentary break the strings without single characters. Check every such string using recursion return the longest string .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you find it helpful\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(string s){\\n        vector<int> t1(26, 0), t2(26, 0); \\n        for(int i=0; i<s.length(); i++) if(s[i] >= \\'a\\' && s[i] <= \\'z\\') t1[s[i] - \\'a\\']++; \\n        for(int i=0; i<s.length(); i++) if(s[i] >= \\'A\\' && s[i] <= \\'Z\\') t2[s[i] - \\'A\\']++; \\n\\n         for(int i=0; i<26; i++){\\n            if(t1[i] == 0 && t2[i] == 0) continue; \\n            else if(t1[i] == 0 && t2[i] > 0) return false;  \\n            else if(t1[i] > 0 && t2[i] == 0) return false; \\n        } \\n\\n        return true; \\n    }\\n\\n    string longestNiceSubstring(string s) {\\n\\n        if(s == \"\") return \"\"; \\n        if(check(s)) return s; \\n\\n        unordered_map<char,int> m; \\n        vector<int> t1(26, 0), t2(26, 0); \\n        for(int i=0; i<s.length(); i++) if(s[i] >= \\'a\\' && s[i] <= \\'z\\') t1[s[i] - \\'a\\']++; \\n        for(int i=0; i<s.length(); i++) if(s[i] >= \\'A\\' && s[i] <= \\'Z\\') t2[s[i] - \\'A\\']++; \\n      \\n\\n        for(int i=0; i<26; i++){\\n            if(t1[i] == 0 && t2[i] == 0) continue; \\n            else if(t1[i] == 0 && t2[i] > 0) m[i + \\'A\\']++; \\n            else if(t1[i] > 0 && t2[i] == 0) m[i + \\'a\\']++; \\n        } \\n\\n\\n\\n        vector<string> ans; string temp = \"\"; \\n        for(int i=0; i<s.length(); i++){\\n            if(m.find(s[i]) == m.end()) temp += s[i]; \\n            else {\\n                ans.push_back(temp); temp = \"\"; \\n            }\\n           \\n        }\\n        if(temp != \"\") ans.push_back(temp); \\n\\n        string kk = \"\"; \\n\\n        for(int i=0; i<ans.size(); i++){\\n            if(ans[i] == \"\") continue; \\n            string t = longestNiceSubstring(ans[i]);\\n            if(t == \"\") continue;  \\n            if(kk == \"\" || kk.length() < t.length()) kk = t; \\n \\n        }\\n\\n        return kk; \\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string s){\\n        vector<int> t1(26, 0), t2(26, 0); \\n        for(int i=0; i<s.length(); i++) if(s[i] >= \\'a\\' && s[i] <= \\'z\\') t1[s[i] - \\'a\\']++; \\n        for(int i=0; i<s.length(); i++) if(s[i] >= \\'A\\' && s[i] <= \\'Z\\') t2[s[i] - \\'A\\']++; \\n\\n         for(int i=0; i<26; i++){\\n            if(t1[i] == 0 && t2[i] == 0) continue; \\n            else if(t1[i] == 0 && t2[i] > 0) return false;  \\n            else if(t1[i] > 0 && t2[i] == 0) return false; \\n        } \\n\\n        return true; \\n    }\\n\\n    string longestNiceSubstring(string s) {\\n\\n        if(s == \"\") return \"\"; \\n        if(check(s)) return s; \\n\\n        unordered_map<char,int> m; \\n        vector<int> t1(26, 0), t2(26, 0); \\n        for(int i=0; i<s.length(); i++) if(s[i] >= \\'a\\' && s[i] <= \\'z\\') t1[s[i] - \\'a\\']++; \\n        for(int i=0; i<s.length(); i++) if(s[i] >= \\'A\\' && s[i] <= \\'Z\\') t2[s[i] - \\'A\\']++; \\n      \\n\\n        for(int i=0; i<26; i++){\\n            if(t1[i] == 0 && t2[i] == 0) continue; \\n            else if(t1[i] == 0 && t2[i] > 0) m[i + \\'A\\']++; \\n            else if(t1[i] > 0 && t2[i] == 0) m[i + \\'a\\']++; \\n        } \\n\\n\\n\\n        vector<string> ans; string temp = \"\"; \\n        for(int i=0; i<s.length(); i++){\\n            if(m.find(s[i]) == m.end()) temp += s[i]; \\n            else {\\n                ans.push_back(temp); temp = \"\"; \\n            }\\n           \\n        }\\n        if(temp != \"\") ans.push_back(temp); \\n\\n        string kk = \"\"; \\n\\n        for(int i=0; i<ans.size(); i++){\\n            if(ans[i] == \"\") continue; \\n            string t = longestNiceSubstring(ans[i]);\\n            if(t == \"\") continue;  \\n            if(kk == \"\" || kk.length() < t.length()) kk = t; \\n \\n        }\\n\\n        return kk; \\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403071,
                "title": "c-brute-force-to-optimized-approaches",
                "content": "```\\n//Approach-1 (Brute force)\\n//Just create all substring and check if they are nice and find the longest nice string\\nclass Solution {\\npublic:\\n    bool isNice(string &s) {\\n        unordered_set<char> st(begin(s), end(s));\\n        \\n        for(char &ch : s) {\\n            if(!st.count(tolower(ch)) || !st.count(toupper(ch)))\\n                return false;\\n        }\\n        return true;\\n    }\\n    string longestNiceSubstring(string s) {\\n        string result = \"\";\\n        int n = s.length();\\n        \\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<n; j++) {\\n                string temp = s.substr(i, j-i+1);\\n                if(isNice(temp) && temp.length() > result.length())\\n                    result = temp;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2\\n//(Split the string into left and right if current character is invalid)\\n//Then recursively look for nice substring in left and right\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        unordered_set<char> st(begin(s), end(s));\\n        \\n        for(int i = 0; i<s.length(); i++) {\\n            if(st.count(tolower(s[i])) && st.count(toupper(s[i]))) continue;\\n            \\n            string left  = longestNiceSubstring(s.substr(0, i));\\n            string right = longestNiceSubstring(s.substr(i+1));\\n            \\n            return left.size() >= right.size() ? left : right;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Brute force)\\n//Just create all substring and check if they are nice and find the longest nice string\\nclass Solution {\\npublic:\\n    bool isNice(string &s) {\\n        unordered_set<char> st(begin(s), end(s));\\n        \\n        for(char &ch : s) {\\n            if(!st.count(tolower(ch)) || !st.count(toupper(ch)))\\n                return false;\\n        }\\n        return true;\\n    }\\n    string longestNiceSubstring(string s) {\\n        string result = \"\";\\n        int n = s.length();\\n        \\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<n; j++) {\\n                string temp = s.substr(i, j-i+1);\\n                if(isNice(temp) && temp.length() > result.length())\\n                    result = temp;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\n//Approach-2\\n//(Split the string into left and right if current character is invalid)\\n//Then recursively look for nice substring in left and right\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        unordered_set<char> st(begin(s), end(s));\\n        \\n        for(int i = 0; i<s.length(); i++) {\\n            if(st.count(tolower(s[i])) && st.count(toupper(s[i]))) continue;\\n            \\n            string left  = longestNiceSubstring(s.substr(0, i));\\n            string right = longestNiceSubstring(s.substr(i+1));\\n            \\n            return left.size() >= right.size() ? left : right;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315143,
                "title": "c-simple-solution",
                "content": "```\\nstring longestNiceSubstring(string s) {\\n        if(s.size() < 2) return \"\";\\n        unordered_set<char>set(begin(s), end(s));\\n        for(int i = 0; i < s.size(); i++) {\\n            if(!set.count((char)(s[i] ^ 32))) {    //  \\'a\\' ^ 32 = 65 and \\'A\\' ^ 32 = 97 // by XOR with 32 we can change b|w lower and uppercase \\n                string s1 = longestNiceSubstring(s.substr(0, i));\\n                string s2 = longestNiceSubstring(s.substr(i + 1));\\n                return s1.size() >= s2.size() ? s1 : s2;\\n            }\\n        }\\n        return s;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring longestNiceSubstring(string s) {\\n        if(s.size() < 2) return \"\";\\n        unordered_set<char>set(begin(s), end(s));\\n        for(int i = 0; i < s.size(); i++) {\\n            if(!set.count((char)(s[i] ^ 32))) {    //  \\'a\\' ^ 32 = 65 and \\'A\\' ^ 32 = 97 // by XOR with 32 we can change b|w lower and uppercase \\n                string s1 = longestNiceSubstring(s.substr(0, i));\\n                string s2 = longestNiceSubstring(s.substr(i + 1));\\n                return s1.size() >= s2.size() ? s1 : s2;\\n            }\\n        }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1108575,
                "title": "python-easy-solution-finding-subarrays",
                "content": "```\\ndef longestNiceSubstring(self, s: str) -> str:\\n        ans=\"\"\\n        for i in range(len(s)):\\n            for j in range(i,len(s)):\\n                sub=s[i:j+1]\\n                cnt=0\\n                for k in sub:\\n                    if k.isupper():\\n                        if k.lower() in sub:\\n                            cnt+=1\\n                    elif k.islower():\\n                        if k.upper() in sub:\\n                            cnt+=1\\n                if cnt==len(sub):\\n                    ans=max(ans,sub,key=len)\\n        return ans",
                "solutionTags": [],
                "code": "```\\ndef longestNiceSubstring(self, s: str) -> str:\\n        ans=\"\"\\n        for i in range(len(s)):\\n            for j in range(i,len(s)):\\n                sub=s[i:j+1]\\n                cnt=0\\n                for k in sub:\\n                    if k.isupper():\\n                        if k.lower() in sub:\\n                            cnt+=1\\n                    elif k.islower():\\n                        if k.upper() in sub:\\n                            cnt+=1\\n                if cnt==len(sub):\\n                    ans=max(ans,sub,key=len)\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 1074763,
                "title": "my-java-solution",
                "content": "```\\n// divide and conquer\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        if (s.length() < 2)\\n            return \"\";\\n        Set<Character> set = new HashSet<>();\\n        for (char ch : s.toCharArray())\\n            set.add(ch);\\n        for (int i=0; i<s.length(); i++) {\\n            char current = s.charAt(i);\\n            if (set.contains(Character.toUpperCase(current)) && set.contains(Character.toLowerCase(current)))\\n                continue;\\n            String str1 = longestNiceSubstring(s.substring(0, i));\\n            String str2 = longestNiceSubstring(s.substring(i + 1));\\n            return str1.length() >= str2.length() ? str1 : str2;\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n// divide and conquer\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        if (s.length() < 2)\\n            return \"\";\\n        Set<Character> set = new HashSet<>();\\n        for (char ch : s.toCharArray())\\n            set.add(ch);\\n        for (int i=0; i<s.length(); i++) {\\n            char current = s.charAt(i);\\n            if (set.contains(Character.toUpperCase(current)) && set.contains(Character.toLowerCase(current)))\\n                continue;\\n            String str1 = longestNiceSubstring(s.substring(0, i));\\n            String str2 = longestNiceSubstring(s.substring(i + 1));\\n            return str1.length() >= str2.length() ? str1 : str2;\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081871,
                "title": "java-using-xor",
                "content": "I think this can be further optimized using arrays to avoid substrings but would be more difficult to\\nfollow.  \\n\\nA small optimization over brute force is to only look for substrings that are longer than the current\\nlongest answer: ``int j = i + longest.length()``.\\n\\nThe helper method sets a bit for each lowercase and uppercase character occurrence, we don\\'t care about the count just that both or none exist. That means XOR ^ is perfect for this:\\n\\n0 ^ 0 = 0\\n1 ^ 1 = 0\\n1 ^ 0 = 1\\n0 ^ 1 = 1\\n\\n\\n```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        String longest = \"\";\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            // The substring needs to be longer than \"longest\"\\n            // otherwise don\\'t bother:\\n            for(int j = i + longest.length(); j < s.length(); j++) {\\n                String sub = s.substring(i, j + 1);\\n                if(isNice(sub)) {\\n                    longest = sub;\\n                }\\n            }\\n        }\\n        \\n        return longest;\\n    }\\n    \\n    private boolean isNice(String s) {\\n        int lower = 0;\\n        int upper = 0;\\n        \\n        for(char c : s.toCharArray()) {\\n            if(c < \\'a\\') {\\n                upper |= 1 << (c - \\'A\\');\\n            } else {\\n                lower |= 1 << (c - \\'a\\');\\n            }\\n        }\\n        \\n        return (lower ^ upper) == 0; // using XOR\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        String longest = \"\";\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            // The substring needs to be longer than \"longest\"\\n            // otherwise don\\'t bother:\\n            for(int j = i + longest.length(); j < s.length(); j++) {\\n                String sub = s.substring(i, j + 1);\\n                if(isNice(sub)) {\\n                    longest = sub;\\n                }\\n            }\\n        }\\n        \\n        return longest;\\n    }\\n    \\n    private boolean isNice(String s) {\\n        int lower = 0;\\n        int upper = 0;\\n        \\n        for(char c : s.toCharArray()) {\\n            if(c < \\'a\\') {\\n                upper |= 1 << (c - \\'A\\');\\n            } else {\\n                lower |= 1 << (c - \\'a\\');\\n            }\\n        }\\n        \\n        return (lower ^ upper) == 0; // using XOR\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074734,
                "title": "java-clean-solution-with-an-example-n-2-4-ms-faster-than-100",
                "content": "For the given interval of the array, set if the lower and upper letter present.\\n\\nIntervals are build in a following way:\\n```\\nString s = \"YaAz\";\\n\\n\"Y\"\\n\"YaA\"\\n\"YaAz\"\\n\\n\"a\"\\n\"aA\"\\n\"aAz\"\\n\\n\"A\"\\n\"Az\"\\n\\n\"z\"\\n```\\n\\n\\nFor each interval compare that the bool state for each character in the lower vs upper arrays are equal by:\\nArrays.equals(lower, upper)\\n\\n\\nTime complexity: O(26N^2)\\nSpace complexity: O(1) \\n\\n```\\n    public String longestNiceSubstring(String s) {    \\n        String ans = \"\";\\n           \\n        for (int i = 0; i < s.length(); i++) {\\n            boolean[] lower = new boolean[26];\\n            boolean[] upper = new boolean[26];\\n            \\n            for (int j = i; j < s.length(); j++) {\\n                if (s.charAt(j) < \\'a\\') upper[s.charAt(j) - \\'A\\'] = true;\\n                else                   lower[s.charAt(j) - \\'a\\'] = true;\\n                \\n                if (Arrays.equals(lower, upper) && ans.length() <= j - i) {\\n                    ans = s.substring(i, j + 1);\\n                }                \\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n\\nAslo, we could store the state not as array, but as bits of the integer.\\nSince Integer has 32 bits and we need to store state only for 26 chars.\\nThen we just compare two Integers - they should have all bits equal.\\nThe number of the chars in the String doesn\\'t matter.\\n\\nThis approach significantly reduce real time execution by removing constant C=26 for array comparison.\\n\\n```\\n    public String longestNiceSubstring(String s) {    \\n        String ans = \"\";\\n           \\n        for (int i = 0; i < s.length(); i++) {\\n            int lower = 0, upper = 0;\\n            \\n            for (int j = i; j < s.length(); j++) {\\n                if (s.charAt(j) < \\'a\\') lower |= (1 << (s.charAt(j) - \\'A\\'));\\n                else                   upper |= (1 << (s.charAt(j) - \\'a\\'));\\n            \\n                if (lower == upper && ans.length() <= j - i) {\\n                    ans = s.substring(i, j + 1);\\n                }                \\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nString s = \"YaAz\";\\n\\n\"Y\"\\n\"YaA\"\\n\"YaAz\"\\n\\n\"a\"\\n\"aA\"\\n\"aAz\"\\n\\n\"A\"\\n\"Az\"\\n\\n\"z\"\\n```\n```\\n    public String longestNiceSubstring(String s) {    \\n        String ans = \"\";\\n           \\n        for (int i = 0; i < s.length(); i++) {\\n            boolean[] lower = new boolean[26];\\n            boolean[] upper = new boolean[26];\\n            \\n            for (int j = i; j < s.length(); j++) {\\n                if (s.charAt(j) < \\'a\\') upper[s.charAt(j) - \\'A\\'] = true;\\n                else                   lower[s.charAt(j) - \\'a\\'] = true;\\n                \\n                if (Arrays.equals(lower, upper) && ans.length() <= j - i) {\\n                    ans = s.substring(i, j + 1);\\n                }                \\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\n    public String longestNiceSubstring(String s) {    \\n        String ans = \"\";\\n           \\n        for (int i = 0; i < s.length(); i++) {\\n            int lower = 0, upper = 0;\\n            \\n            for (int j = i; j < s.length(); j++) {\\n                if (s.charAt(j) < \\'a\\') lower |= (1 << (s.charAt(j) - \\'A\\'));\\n                else                   upper |= (1 << (s.charAt(j) - \\'a\\'));\\n            \\n                if (lower == upper && ans.length() <= j - i) {\\n                    ans = s.substring(i, j + 1);\\n                }                \\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1074577,
                "title": "c-0ms-optimal-solution",
                "content": "The constraints allow simple brute force where we can evaluate every subarray on whether it meets the criteria.\\nHowever, it can be optimized slightly by reusing the boolean maps.\\n\\n```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s)\\n    {\\n        int maxNiceLen = 0;\\n        int maxNiceStart = -1;\\n        int maxNiceStop = -1;\\n        \\n        for (int i = 0; i < s.size(); ++i)\\n        {\\n            bool large[26] = {};\\n            bool small[26] = {};\\n            for (int j = i; j < s.size(); ++j)\\n            {\\n                if (isupper(s[j]))\\n                    large[s[j] - \\'A\\'] = true;\\n                else\\n                    small[s[j] - \\'a\\'] = true;\\n                \\n                int len = j - i + 1;\\n                if (len > maxNiceLen)\\n                {\\n                    int k = 0;\\n                    for (; k < 26; ++k)\\n                        if (large[k] != small[k])\\n                            break;\\n                    \\n                    if (k == 26)\\n                    {\\n                        maxNiceLen = len;\\n                        maxNiceStart = i;\\n                        maxNiceStop = j;\\n                    }\\n                }\\n            }\\n        }\\n            \\n        if (maxNiceLen == 0)\\n            return \"\";\\n\\n        return s.substr(maxNiceStart, maxNiceLen);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s)\\n    {\\n        int maxNiceLen = 0;\\n        int maxNiceStart = -1;\\n        int maxNiceStop = -1;\\n        \\n        for (int i = 0; i < s.size(); ++i)\\n        {\\n            bool large[26] = {};\\n            bool small[26] = {};\\n            for (int j = i; j < s.size(); ++j)\\n            {\\n                if (isupper(s[j]))\\n                    large[s[j] - \\'A\\'] = true;\\n                else\\n                    small[s[j] - \\'a\\'] = true;\\n                \\n                int len = j - i + 1;\\n                if (len > maxNiceLen)\\n                {\\n                    int k = 0;\\n                    for (; k < 26; ++k)\\n                        if (large[k] != small[k])\\n                            break;\\n                    \\n                    if (k == 26)\\n                    {\\n                        maxNiceLen = len;\\n                        maxNiceStart = i;\\n                        maxNiceStop = j;\\n                    }\\n                }\\n            }\\n        }\\n            \\n        if (maxNiceLen == 0)\\n            return \"\";\\n\\n        return s.substr(maxNiceStart, maxNiceLen);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328367,
                "title": "java-easy-recursion-solution",
                "content": "```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        if(s.length() <=1)\\n            return \"\";\\n        Set<Character> set = new HashSet();\\n        for (int i =0; i< s.length() ; i++){\\n            set.add(s.charAt(i));\\n        }\\n        for(int i = 0; i< s.length() ; i++){\\n           if(set.contains(Character.toUpperCase(s.charAt(i))) && set.contains(Character.toLowerCase(s.charAt(i)))){\\n                continue;\\n            }\\n            \\n            String s1 = longestNiceSubstring(s.substring(0,i));\\n            String s2 = longestNiceSubstring(s.substring(i+1));\\n            \\n            return s1.length()>=s2.length() ? s1 : s2;\\n        }\\n        \\n        return s;\\n    }\\n}\\n   \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        if(s.length() <=1)\\n            return \"\";\\n        Set<Character> set = new HashSet();\\n        for (int i =0; i< s.length() ; i++){\\n            set.add(s.charAt(i));\\n        }\\n        for(int i = 0; i< s.length() ; i++){\\n           if(set.contains(Character.toUpperCase(s.charAt(i))) && set.contains(Character.toLowerCase(s.charAt(i)))){\\n                continue;\\n            }\\n            \\n            String s1 = longestNiceSubstring(s.substring(0,i));\\n            String s2 = longestNiceSubstring(s.substring(i+1));\\n            \\n            return s1.length()>=s2.length() ? s1 : s2;\\n        }\\n        \\n        return s;\\n    }\\n}\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114782,
                "title": "java-bit-manipulation-divide-conquer",
                "content": "Refine @Huayra007 solution with bit manipulation instead of hashset.\\n```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        int lower = 0, upper = 0;\\n        for(char ch : s.toCharArray()) {\\n            if( ch >= \\'a\\' && ch <= \\'z\\') {\\n                lower |= (1 << (ch - \\'a\\'));\\n            } else {\\n                upper |= (1 << (ch - \\'A\\'));\\n            }\\n        }\\n        for(int i = 0; i < s.length(); ++i) {\\n            char ch = s.charAt(i);\\n            int index = ch >= \\'a\\' && ch <= \\'z\\' ? ch - \\'a\\' : ch - \\'A\\';\\n            int lower_bit = (lower >> index) & 1;\\n            int upper_bit = ((upper >> index) & 1);\\n            if((lower_bit ^ upper_bit) == 0) continue;\\n            String sub1 = longestNiceSubstring(s.substring(0, i));\\n            String sub2 = longestNiceSubstring(s.substring(i+1));\\n            return sub1.length() >= sub2.length() ? sub1 : sub2;\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Divide and Conquer",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        int lower = 0, upper = 0;\\n        for(char ch : s.toCharArray()) {\\n            if( ch >= \\'a\\' && ch <= \\'z\\') {\\n                lower |= (1 << (ch - \\'a\\'));\\n            } else {\\n                upper |= (1 << (ch - \\'A\\'));\\n            }\\n        }\\n        for(int i = 0; i < s.length(); ++i) {\\n            char ch = s.charAt(i);\\n            int index = ch >= \\'a\\' && ch <= \\'z\\' ? ch - \\'a\\' : ch - \\'A\\';\\n            int lower_bit = (lower >> index) & 1;\\n            int upper_bit = ((upper >> index) & 1);\\n            if((lower_bit ^ upper_bit) == 0) continue;\\n            String sub1 = longestNiceSubstring(s.substring(0, i));\\n            String sub2 = longestNiceSubstring(s.substring(i+1));\\n            return sub1.length() >= sub2.length() ? sub1 : sub2;\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434552,
                "title": "python-divide-and-conquer-o-n-solution",
                "content": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        if len(s) < 2:\\n            return \"\"\\n        \\n        chars = set(s)\\n        \\n        for i, c in enumerate(s):\\n            if c.upper() not in chars or c.lower() not in chars:\\n                s1 = self.longestNiceSubstring(s[:i])\\n                s2 = self.longestNiceSubstring(s[i+1:])\\n                return s1 if len(s1) >= len(s2) else s2\\n            \\n        return s\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        if len(s) < 2:\\n            return \"\"\\n        \\n        chars = set(s)\\n        \\n        for i, c in enumerate(s):\\n            if c.upper() not in chars or c.lower() not in chars:\\n                s1 = self.longestNiceSubstring(s[:i])\\n                s2 = self.longestNiceSubstring(s[i+1:])\\n                return s1 if len(s1) >= len(s2) else s2\\n            \\n        return s\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294641,
                "title": "2-c-brute-force-solutions",
                "content": "Solution 1:\\nSpace complexity: O(N) \\n```\\nclass Solution {\\npublic:\\n    \\n   bool niceSubstr(string&s,int&i,int&j,int&n) {\\n       int l_freq[26]={0} , u_freq[26]={0};\\n       for(int x = i;x<=j;x++) {\\n           if(s[x]>=\\'a\\' && s[x]<=\\'z\\') \\n               l_freq[s[x]-\\'a\\']++;\\n           else \\n               u_freq[s[x]-\\'A\\']++;\\n       }\\n       for(int i=0;i<26;i++) {\\n           if((l_freq[i]&&!u_freq[i]) ||(!l_freq[i]&&u_freq[i]))\\n               return 0;\\n       }       \\n       return true;\\n    }\\n    \\n    string longestNiceSubstring(string s) {\\n        int maxLen =0;\\n        string ans = \"\";\\n        int n = s.length();\\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(niceSubstr(s,i,j,n)) {\\n                    if(maxLen < j-i+1){\\n                        maxLen = j-i+1;\\n                        ans = s.substr(i,j-i+1);\\n                    }                        \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nSolution 2: **No extra space**\\n```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        int n = s.length();\\n        string ans=\"\";\\n        for(int i=0;i<n;i++) {\\n            int lower = 0 , upper = 0;\\n            for(int j=i;j<n;j++) {\\n                if(s[j]>=\\'a\\' && s[j]<=\\'z\\') \\n                    lower |= (1<< (s[j]-\\'a\\'));\\n                else \\n                    upper |= (1<< (s[j]-\\'A\\'));\\n                if(!(lower^upper)) {\\n                    if(j-i+1>ans.size()) \\n                        ans = s.substr(i,j-i+1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n   bool niceSubstr(string&s,int&i,int&j,int&n) {\\n       int l_freq[26]={0} , u_freq[26]={0};\\n       for(int x = i;x<=j;x++) {\\n           if(s[x]>=\\'a\\' && s[x]<=\\'z\\') \\n               l_freq[s[x]-\\'a\\']++;\\n           else \\n               u_freq[s[x]-\\'A\\']++;\\n       }\\n       for(int i=0;i<26;i++) {\\n           if((l_freq[i]&&!u_freq[i]) ||(!l_freq[i]&&u_freq[i]))\\n               return 0;\\n       }       \\n       return true;\\n    }\\n    \\n    string longestNiceSubstring(string s) {\\n        int maxLen =0;\\n        string ans = \"\";\\n        int n = s.length();\\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(niceSubstr(s,i,j,n)) {\\n                    if(maxLen < j-i+1){\\n                        maxLen = j-i+1;\\n                        ans = s.substr(i,j-i+1);\\n                    }                        \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        int n = s.length();\\n        string ans=\"\";\\n        for(int i=0;i<n;i++) {\\n            int lower = 0 , upper = 0;\\n            for(int j=i;j<n;j++) {\\n                if(s[j]>=\\'a\\' && s[j]<=\\'z\\') \\n                    lower |= (1<< (s[j]-\\'a\\'));\\n                else \\n                    upper |= (1<< (s[j]-\\'A\\'));\\n                if(!(lower^upper)) {\\n                    if(j-i+1>ans.size()) \\n                        ans = s.substr(i,j-i+1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1078592,
                "title": "go-o-n-recursive-0-ms-with-fast-bit-flags-and-explanation",
                "content": "```\\nfunc longestNiceSubstring(s string) string {\\n    var lower, upper int32  // 2 * 24 bits for letter presence flags\\n    \\n    if len(s) <= 1 {  // recursion stops here\\n        return \"\"\\n    }\\n    for _,c := range s {  // go over the string to set upper and lower letter flags\\n        if c < rune(\\'a\\') { // isupper relying on c being a latin letter\\n            upper |= 1 << (c - rune(\\'A\\'))  // set the bit for \\'seen the letter in upper case\\'\\n        } else {  // islower\\n            lower |= 1 << (c - rune(\\'a\\'))  // set the bit for \\'seen the letter in lower case\\'\\n        }\\n    }\\n    for i,c := range s {\\n        var bit int32  // bit corresponding to the letter\\n        if c < rune(\\'a\\') {\\n            bit = 1 << (c - rune(\\'A\\'))\\n        } else {\\n            bit = 1 << (c - rune(\\'a\\'))\\n        }\\n        if (upper & bit) != (lower & bit) {  // the letter was not seen in upper or lower case\\n            // use recursion to find nice substring to the left of the letter\\n            ns1 := longestNiceSubstring(s[:i])  \\n            // use recursion to find nice substring to the right of the letter\\n            ns2 := longestNiceSubstring(s[i+1:])\\n            // return longest of the nice substrings\\n            if len(ns1) < len(ns2) {\\n                return ns2\\n            }\\n            return ns1\\n        }\\n    }\\n    // entire string is nice: saw every letter in both cases\\n    return s\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestNiceSubstring(s string) string {\\n    var lower, upper int32  // 2 * 24 bits for letter presence flags\\n    \\n    if len(s) <= 1 {  // recursion stops here\\n        return \"\"\\n    }\\n    for _,c := range s {  // go over the string to set upper and lower letter flags\\n        if c < rune(\\'a\\') { // isupper relying on c being a latin letter\\n            upper |= 1 << (c - rune(\\'A\\'))  // set the bit for \\'seen the letter in upper case\\'\\n        } else {  // islower\\n            lower |= 1 << (c - rune(\\'a\\'))  // set the bit for \\'seen the letter in lower case\\'\\n        }\\n    }\\n    for i,c := range s {\\n        var bit int32  // bit corresponding to the letter\\n        if c < rune(\\'a\\') {\\n            bit = 1 << (c - rune(\\'A\\'))\\n        } else {\\n            bit = 1 << (c - rune(\\'a\\'))\\n        }\\n        if (upper & bit) != (lower & bit) {  // the letter was not seen in upper or lower case\\n            // use recursion to find nice substring to the left of the letter\\n            ns1 := longestNiceSubstring(s[:i])  \\n            // use recursion to find nice substring to the right of the letter\\n            ns2 := longestNiceSubstring(s[i+1:])\\n            // return longest of the nice substrings\\n            if len(ns1) < len(ns2) {\\n                return ns2\\n            }\\n            return ns1\\n        }\\n    }\\n    // entire string is nice: saw every letter in both cases\\n    return s\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1075145,
                "title": "python-3-multi-divide-conquer-o-n-24ms",
                "content": "- Find all chars. Then split string by non-nice chars.\\n- Recursively find non-nice chars and split substrings. \\n- Return max length substring.\\n- According to the task string contains English letters (constant 26). So time complexity is O(n). For huge alphabet according to the third case of Master theorem the time complexity is the same O(n).\\n```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        chars = set(s); i = 0; ret = \\'\\'\\n        for j, c in enumerate(s):\\n            if c.swapcase() not in chars:\\n                ret = max(ret, self.longestNiceSubstring(s[i:j]), key=len); i = j+1\\n        return max(ret, self.longestNiceSubstring(s[i:]), key=len) if i else s\\n```",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        chars = set(s); i = 0; ret = \\'\\'\\n        for j, c in enumerate(s):\\n            if c.swapcase() not in chars:\\n                ret = max(ret, self.longestNiceSubstring(s[i:j]), key=len); i = j+1\\n        return max(ret, self.longestNiceSubstring(s[i:]), key=len) if i else s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413565,
                "title": "c-fast-simple-recursion",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis implementation first builds a set of missing characters that need to be present in the nice substring. It then iterates over the string `s`, checking if each character is missing. If a missing character is found, it recursively searches for the longest nice substring in the substrings to the left and right of the missing character. Finally, it returns the longer of the two substrings found or the original string if it is already nice.\\n\\n# Complexity\\n- Time complexity: `O(n^2)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this code is `O(n^2)`, where `n` is the length of the input string `s`. This is because the code uses two recursive calls to `longestNiceSubstring` on substrings of `s`, which can result in the function being called on substrings of `s` of size up to `n-1`.\\n\\n- Space complexity: `O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this code is `O(n)`, due to the use of an unordered set missing to store the set of characters missing from the input string `s`. The worst-case size of missing is the number of distinct characters in `s`, which is at most `n`.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        unordered_set<char> missing;\\n        for (char c : s) {\\n            if (islower(c)) missing.insert(toupper(c));\\n            else missing.insert(tolower(c));\\n        }\\n        for (int i = 0; i < s.size(); i++) {\\n            if (missing.count(s[i])) {\\n                continue;\\n            }\\n            string s1 = longestNiceSubstring(s.substr(0, i));\\n            string s2 = longestNiceSubstring(s.substr(i + 1));\\n            return s1.size() >= s2.size() ? s1 : s2;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        unordered_set<char> missing;\\n        for (char c : s) {\\n            if (islower(c)) missing.insert(toupper(c));\\n            else missing.insert(tolower(c));\\n        }\\n        for (int i = 0; i < s.size(); i++) {\\n            if (missing.count(s[i])) {\\n                continue;\\n            }\\n            string s1 = longestNiceSubstring(s.substr(0, i));\\n            string s2 = longestNiceSubstring(s.substr(i + 1));\\n            return s1.size() >= s2.size() ? s1 : s2;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381676,
                "title": "java-nice-solution",
                "content": "# Complexity\\n- Time complexity: O(n^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n       Set<Character> set = new HashSet();\\n       for(char c : s.toCharArray()){\\n           set.add(c);\\n       }\\n\\n       for(int i = 0; i < s.length(); i++){\\n           if(set.contains(Character.toUpperCase(s.charAt(i)))\\n              && set.contains(Character.toLowerCase(s.charAt(i))))\\n                continue;\\n            \\n            String s1 = longestNiceSubstring(s.substring(0, i));\\n            String s2 = longestNiceSubstring(s.substring(i+1));\\n            return s1.length() >= s2.length() ? s1 : s2;\\n       }\\n\\n       return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n       Set<Character> set = new HashSet();\\n       for(char c : s.toCharArray()){\\n           set.add(c);\\n       }\\n\\n       for(int i = 0; i < s.length(); i++){\\n           if(set.contains(Character.toUpperCase(s.charAt(i)))\\n              && set.contains(Character.toLowerCase(s.charAt(i))))\\n                continue;\\n            \\n            String s1 = longestNiceSubstring(s.substring(0, i));\\n            String s2 = longestNiceSubstring(s.substring(i+1));\\n            return s1.length() >= s2.length() ? s1 : s2;\\n       }\\n\\n       return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727072,
                "title": "python-with-re-split-solution",
                "content": "This post is inpired by the solutions list in the ref session. I think it is little clear if we use re.split :)\\n\\nTwo key points to solve this problem\\n\\n- know swapcase functoin in python\\n- take advantage of \"orphan\" charactors\\n\\n\\n```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        \\n        if set(s) == set(s.swapcase()):\\n            return s\\n        \\n        orphan = set(s) - set(s.swapcase())\\n        \\n        return max(map(self.longestNiceSubstring, re.split(\"|\".join(orphan), s)), key=len)\\n\\n```\\n\\nThe following solutions are really good and worth to study\\n\\n@ye15\\nhttps://leetcode.com/problems/longest-nice-substring/discuss/1074546/Python3-brute-force-and-divide-and-conquer\\n@KellyBundy shared another neat solution in the comment session of the post above\\n\\n@pasher13\\nhttps://leetcode.com/problems/longest-nice-substring/discuss/1075145/Python-3-Multi-Divide-and-conquer-24ms\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        \\n        if set(s) == set(s.swapcase()):\\n            return s\\n        \\n        orphan = set(s) - set(s.swapcase())\\n        \\n        return max(map(self.longestNiceSubstring, re.split(\"|\".join(orphan), s)), key=len)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684096,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   string longestNiceSubstring(string s) {\\n        if(s.length()<=1)\\n        {\\n            return \"\";\\n        }\\n        unordered_set<char>st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            st.insert(s[i]);\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch=s[i];\\n            if(st.find(tolower(ch))==st.end() || st.find(toupper(ch))==st.end())\\n            {\\n                string s1=longestNiceSubstring(s.substr(0,i));\\n                string s2=longestNiceSubstring(s.substr(i+1,s.length()));\\n                if(s1.length()>=s2.length())\\n                {\\n                    return s1;\\n                }\\n                else\\n                {\\n                    return s2;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   string longestNiceSubstring(string s) {\\n        if(s.length()<=1)\\n        {\\n            return \"\";\\n        }\\n        unordered_set<char>st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            st.insert(s[i]);\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch=s[i];\\n            if(st.find(tolower(ch))==st.end() || st.find(toupper(ch))==st.end())\\n            {\\n                string s1=longestNiceSubstring(s.substr(0,i));\\n                string s2=longestNiceSubstring(s.substr(i+1,s.length()));\\n                if(s1.length()>=s2.length())\\n                {\\n                    return s1;\\n                }\\n                else\\n                {\\n                    return s2;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448334,
                "title": "easy-c-solution-simple-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n\\t   bool isNice(string h){\\n\\n\\t\\t\\tfor(int i=0; i<h.length(); i++){\\n\\n\\t\\t\\t\\tchar c = h[i];\\n\\t\\t\\t\\tif(c >= 65 && c <=90){\\n\\t\\t\\t\\t\\tc = c + 32;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tc = c - 32;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(h.find(c) == string ::npos){\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\n\\t\\tstring longestNiceSubstring(string s) {\\n\\n\\t\\t\\tstring res= \"\";\\n\\t\\t\\tint n = s.size();\\n\\n\\t\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstring t=\"\";\\n\\t\\t\\t\\tt += s[i];\\n\\n\\t\\t\\t\\tfor(int j = i+1; j<n; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tt += s[j];\\n\\t\\t\\t\\t\\tif(isNice(t)  && t.length()> res.length())\\n\\t\\t\\t\\t\\t\\tres = t;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t   bool isNice(string h){\\n\\n\\t\\t\\tfor(int i=0; i<h.length(); i++){\\n\\n\\t\\t\\t\\tchar c = h[i];\\n\\t\\t\\t\\tif(c >= 65 && c <=90){\\n\\t\\t\\t\\t\\tc = c + 32;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2189970,
                "title": "javascript-simple-solution-window-sliding-recursion-easy",
                "content": "\\t\\tvar longestNiceSubstring = function (s) {\\n\\n\\t\\t\\tif (s.length < 2) return \"\";\\n\\n\\t\\t\\tconst obj = {};\\n\\n\\t\\t\\tfor (const i of s) obj[i] = i;\\n\\n\\t\\t\\tfor (let i = 0; i < s.length; i++) {\\n\\t\\t\\t\\tconst element = s[i];\\n\\n\\t\\t\\t\\tif (obj[element.toUpperCase()] && obj[element.toLowerCase()]) continue;\\n\\n\\t\\t\\t\\tconst prev = longestNiceSubstring(s.substring(0, i));\\n\\t\\t\\t\\tconst next = longestNiceSubstring(s.substring(i + 1));\\n\\n\\t\\t\\t\\treturn prev.length >= next.length ? prev : next;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn s;\\n\\t\\t};",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript",
                    "Recursion",
                    "Sliding Window"
                ],
                "code": "\\t\\tvar longestNiceSubstring = function (s) {\\n\\n\\t\\t\\tif (s.length < 2) return \"\";\\n\\n\\t\\t\\tconst obj = {};\\n\\n\\t\\t\\tfor (const i of s) obj[i] = i;\\n\\n\\t\\t\\tfor (let i = 0; i < s.length; i++) {\\n\\t\\t\\t\\tconst element = s[i];\\n\\n\\t\\t\\t\\tif (obj[element.toUpperCase()] && obj[element.toLowerCase()]) continue;\\n\\n\\t\\t\\t\\tconst prev = longestNiceSubstring(s.substring(0, i));\\n\\t\\t\\t\\tconst next = longestNiceSubstring(s.substring(i + 1));\\n\\n\\t\\t\\t\\treturn prev.length >= next.length ? prev : next;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn s;\\n\\t\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 2106326,
                "title": "java-brute-force",
                "content": "```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        int left = 0; String ans = \"\";\\n        for (int i = 0; i < s.length(); i++) {\\n            int[] UCArray = new int[26];\\n            int[] LCArray = new int[26];\\n            String temp = \"\";\\n            for (int j = i; j < s.length(); j++) {\\n                temp += s.charAt(j);\\n                if (s.charAt(j) >= 97)\\n                    LCArray[s.charAt(j) - \\'a\\']++;\\n                else\\n                    UCArray[s.charAt(j) - \\'A\\']++;\\n                \\n                boolean flag = false;\\n                for (int k = 0; k < 26; k++)\\n                    if ((LCArray[k] != 0 && UCArray[k] == 0) || (LCArray[k] == 0 && UCArray[k] != 0)) {\\n                        flag = true;\\n                        break;\\n                    }\\n                if (flag == false)\\n                    ans = ans.length() >= temp.length() ? ans : temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        int left = 0; String ans = \"\";\\n        for (int i = 0; i < s.length(); i++) {\\n            int[] UCArray = new int[26];\\n            int[] LCArray = new int[26];\\n            String temp = \"\";\\n            for (int j = i; j < s.length(); j++) {\\n                temp += s.charAt(j);\\n                if (s.charAt(j) >= 97)\\n                    LCArray[s.charAt(j) - \\'a\\']++;\\n                else\\n                    UCArray[s.charAt(j) - \\'A\\']++;\\n                \\n                boolean flag = false;\\n                for (int k = 0; k < 26; k++)\\n                    if ((LCArray[k] != 0 && UCArray[k] == 0) || (LCArray[k] == 0 && UCArray[k] != 0)) {\\n                        flag = true;\\n                        break;\\n                    }\\n                if (flag == false)\\n                    ans = ans.length() >= temp.length() ? ans : temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1925369,
                "title": "python-divide-and-conquer-replace-invalid-character-with",
                "content": "Replace invalid character with \\',\\' and solve the question recursively.\\n```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        S = set(s)\\n        if all(c.upper() in S and c.lower() in S for c in s):\\n            return s\\n        for c in S:\\n            if c.upper() not in S or c.lower() not in S:\\n                s = s.replace(c,\\',\\')\\n        res = \\'\\'\\n        for s2 in s.split(\\',\\'):\\n            tmp = self.longestNiceSubstring(s2)\\n            if len(tmp) > len(res):\\n                res = tmp\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        S = set(s)\\n        if all(c.upper() in S and c.lower() in S for c in s):\\n            return s\\n        for c in S:\\n            if c.upper() not in S or c.lower() not in S:\\n                s = s.replace(c,\\',\\')\\n        res = \\'\\'\\n        for s2 in s.split(\\',\\'):\\n            tmp = self.longestNiceSubstring(s2)\\n            if len(tmp) > len(res):\\n                res = tmp\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1614794,
                "title": "easy-to-understand-python3-solution",
                "content": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        res=\"\"\\n        n=len(s)\\n        for i in range(n):\\n            for j in range(i,n):\\n                if all(ch.swapcase() in s[i:j+1] for ch in s[i:j+1]):\\n                    if len(s[i:j+1])>len(res):\\n                        res=s[i:j+1]\\n        \\n        return res\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        res=\"\"\\n        n=len(s)\\n        for i in range(n):\\n            for j in range(i,n):\\n                if all(ch.swapcase() in s[i:j+1] for ch in s[i:j+1]):\\n                    if len(s[i:j+1])>len(res):\\n                        res=s[i:j+1]\\n        \\n        return res\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515779,
                "title": "checking-substrings-with-sets-80-speed",
                "content": "Runtime: 36 ms, faster than 80.69% of Python3 online submissions for Longest Nice Substring.\\nMemory Usage: 14.4 MB, less than 34.15% of Python3 online submissions for Longest Nice Substring.\\n```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        max_len, ans = 0, \"\"\\n        len_s = len(s)\\n        for start in range(len_s - 1):\\n            if len_s - start < max_len:\\n                break\\n            lower_set = set()\\n            upper_set = set()\\n            for end in range(start, len_s):\\n                if s[end].islower():\\n                    lower_set.add(s[end])\\n                else:\\n                    upper_set.add(s[end].lower())\\n                if lower_set == upper_set:\\n                    if end - start + 1 > max_len:\\n                        ans = s[start: end + 1]\\n                        max_len = end - start + 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        max_len, ans = 0, \"\"\\n        len_s = len(s)\\n        for start in range(len_s - 1):\\n            if len_s - start < max_len:\\n                break\\n            lower_set = set()\\n            upper_set = set()\\n            for end in range(start, len_s):\\n                if s[end].islower():\\n                    lower_set.add(s[end])\\n                else:\\n                    upper_set.add(s[end].lower())\\n                if lower_set == upper_set:\\n                    if end - start + 1 > max_len:\\n                        ans = s[start: end + 1]\\n                        max_len = end - start + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373060,
                "title": "java-sliding-window-time-o-n",
                "content": "```\\n\\t//There are 26 types of characters. So. let\\'s check if substring has 1 type of character .... 26 type of character.\\n\\t//Each check using sliding window algorthim O(N)\\n\\t//So. the total is 26 * O(N) => O(N)\\n\\tpublic String longestNiceSubstring(String s) {\\n        String ans = \"\";\\n        for(int i = 1; i <= 26; i++) {\\n            int[] range = possible(s.toCharArray(), i);\\n            if(range[1] - range[0] >= ans.length()) ans = s.substring(range[0], range[1] + 1);\\n        }\\n        return ans;\\n    }\\n\\n    private int[] possible(char[] arr, int total) {\\n        int[] lowers = new int[26], uppers = new int[26], res = new int[]{0, -1};\\n\\n        for(int left = 0, right = 0, count = 0; right < arr.length; right++) {\\n            if (\\'a\\' <= arr[right] && arr[right] <= \\'z\\') {\\n                if(lowers[arr[right] - \\'a\\'] + uppers[arr[right] - \\'a\\'] == 0) count++; //new character\\n                lowers[arr[right] - \\'a\\']++;  \\n            } else {\\n                if(lowers[arr[right] - \\'A\\'] + uppers[arr[right] - \\'A\\'] == 0) count++; //new character\\n                uppers[arr[right] - \\'A\\']++;\\n            }\\n            //character type is too much, move left side of sliding window\\n            while (total < count) {\\n                if (\\'a\\' <= arr[left] && arr[left] <= \\'z\\') {\\n                    lowers[arr[left] - \\'a\\']--;\\n                    if(lowers[arr[left] - \\'a\\'] + uppers[arr[left] - \\'a\\'] == 0) count--;\\n                } else {\\n                    uppers[arr[left] - \\'A\\']--;\\n                    if(lowers[arr[left] - \\'A\\'] + uppers[arr[left] - \\'A\\'] == 0) count--;\\n                }\\n                left++;\\n            }\\n            //check if this substring is valid. If so, update result\\n            int valid = 0;\\n            for (int i = 0; i < 26; i++) valid += (lowers[i] > 0 && uppers[i] > 0)? 1: 0;\\n            if (valid == count && right - left > res[1] - res[0]) {\\n                res[0] = left; res[1] = right;\\n            }\\n        }\\n\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\t//There are 26 types of characters. So. let\\'s check if substring has 1 type of character .... 26 type of character.\\n\\t//Each check using sliding window algorthim O(N)\\n\\t//So. the total is 26 * O(N) => O(N)\\n\\tpublic String longestNiceSubstring(String s) {\\n        String ans = \"\";\\n        for(int i = 1; i <= 26; i++) {\\n            int[] range = possible(s.toCharArray(), i);\\n            if(range[1] - range[0] >= ans.length()) ans = s.substring(range[0], range[1] + 1);\\n        }\\n        return ans;\\n    }\\n\\n    private int[] possible(char[] arr, int total) {\\n        int[] lowers = new int[26], uppers = new int[26], res = new int[]{0, -1};\\n\\n        for(int left = 0, right = 0, count = 0; right < arr.length; right++) {\\n            if (\\'a\\' <= arr[right] && arr[right] <= \\'z\\') {\\n                if(lowers[arr[right] - \\'a\\'] + uppers[arr[right] - \\'a\\'] == 0) count++; //new character\\n                lowers[arr[right] - \\'a\\']++;  \\n            } else {\\n                if(lowers[arr[right] - \\'A\\'] + uppers[arr[right] - \\'A\\'] == 0) count++; //new character\\n                uppers[arr[right] - \\'A\\']++;\\n            }\\n            //character type is too much, move left side of sliding window\\n            while (total < count) {\\n                if (\\'a\\' <= arr[left] && arr[left] <= \\'z\\') {\\n                    lowers[arr[left] - \\'a\\']--;\\n                    if(lowers[arr[left] - \\'a\\'] + uppers[arr[left] - \\'a\\'] == 0) count--;\\n                } else {\\n                    uppers[arr[left] - \\'A\\']--;\\n                    if(lowers[arr[left] - \\'A\\'] + uppers[arr[left] - \\'A\\'] == 0) count--;\\n                }\\n                left++;\\n            }\\n            //check if this substring is valid. If so, update result\\n            int valid = 0;\\n            for (int i = 0; i < 26; i++) valid += (lowers[i] > 0 && uppers[i] > 0)? 1: 0;\\n            if (valid == count && right - left > res[1] - res[0]) {\\n                res[0] = left; res[1] = right;\\n            }\\n        }\\n\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1371668,
                "title": "python-3-recursive-24-ms",
                "content": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        if len(s) < 2:\\n            return \\'\\'\\n        \\n        hs = set(s)\\n        badchars = {ch for ch in hs if ch.swapcase() not in hs}\\n        \\n        if len(badchars) == 0:\\n            return s\\n        if len(hs) == len(badchars):\\n            return \\'\\'\\n        \\n        substrs = []\\n        lp = 0\\n        for i in range(len(s)):\\n            if s[i] in badchars:\\n                if lp != i:\\n                    substrs.append(s[lp: i])\\n                lp = i+1\\n        substrs.append(s[lp:])    \\n        \\n        return sorted([self.longestNiceSubstring(x) for x in substrs], key=len, reverse=True)[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        if len(s) < 2:\\n            return \\'\\'\\n        \\n        hs = set(s)\\n        badchars = {ch for ch in hs if ch.swapcase() not in hs}\\n        \\n        if len(badchars) == 0:\\n            return s\\n        if len(hs) == len(badchars):\\n            return \\'\\'\\n        \\n        substrs = []\\n        lp = 0\\n        for i in range(len(s)):\\n            if s[i] in badchars:\\n                if lp != i:\\n                    substrs.append(s[lp: i])\\n                lp = i+1\\n        substrs.append(s[lp:])    \\n        \\n        return sorted([self.longestNiceSubstring(x) for x in substrs], key=len, reverse=True)[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344126,
                "title": "c-bruteforce",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isNice(string s){\\n        unordered_map<int,int> m;\\n        for(int i=0; i<s.length(); i++){\\n            m[s[i]]++;\\n        }\\n        for(int i=0; i<s.length(); i++){\\n            int check1 = s[i] + 32;\\n            int check2 = s[i]-32;\\n            if(s[i] < 97){\\n                if(m.find(check1) == m.end()){\\n                    return false;\\n                }\\n            }\\n            else{\\n                if(m.find(check2) == m.end()){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    string longestNiceSubstring(string s) {\\n        int n = s.size();\\n        string ans = \"\";\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                bool x;\\n                if(x = isNice(s.substr(i,n-j))){\\n                    cout<<x<<\" \"<<s.substr(i,n-j)<<endl;\\n                    string temp = s.substr(i,n-j);\\n                    if(temp.length() > ans.length()){\\n                        ans = temp;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isNice(string s){\\n        unordered_map<int,int> m;\\n        for(int i=0; i<s.length(); i++){\\n            m[s[i]]++;\\n        }\\n        for(int i=0; i<s.length(); i++){\\n            int check1 = s[i] + 32;\\n            int check2 = s[i]-32;\\n            if(s[i] < 97){\\n                if(m.find(check1) == m.end()){\\n                    return false;\\n                }\\n            }\\n            else{\\n                if(m.find(check2) == m.end()){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    string longestNiceSubstring(string s) {\\n        int n = s.size();\\n        string ans = \"\";\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                bool x;\\n                if(x = isNice(s.substr(i,n-j))){\\n                    cout<<x<<\" \"<<s.substr(i,n-j)<<endl;\\n                    string temp = s.substr(i,n-j);\\n                    if(temp.length() > ans.length()){\\n                        ans = temp;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1235283,
                "title": "c-easy-solution-explanation-100-00-runtime",
                "content": "Brute force to check each substring to see if it is nice.\\n\\nUse two 32-bit integers as bitmasks to keep track of the lowercase and uppercase alphabets seen in the substring.\\n\\nIf both values equal, then it means all characters in the substring have both their lower or upper cases counterparts present as well, so we can just take the substring as a candidate for the result.\\n\\nOf course we\\'ll still want to keep track of the longest and earliest beautiful substring as result.\\n\\nTime complexity: `O(N^2)`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution {\\npublic:\\n    std::string longestNiceSubstring(std::string s) {\\n        const auto N = s.size();\\n\\n        std::string result;\\n\\n        for ( size_t i = 0; i < N; ++i ) {\\n            int bitmaskLowerCase = 0;\\n            int bitmaskUpperCase = 0;\\n\\n            for ( size_t j = i; j < N; ++j ) {\\n                char c = s[j];\\n\\n                if ( c >= \\'a\\' && c <= \\'z\\' )\\n                    bitmaskLowerCase |= ( 1 << ( c - \\'a\\' ) );\\n\\n                if ( c >= \\'A\\' && c <= \\'Z\\' )\\n                    bitmaskUpperCase |= ( 1 << ( c - \\'A\\' ) );\\n\\n                if ( ( bitmaskLowerCase == bitmaskUpperCase ) && ( bitmaskLowerCase > 0 ) ) {\\n                    if ( (j-i+1) > result.size() )\\n                        result = s.substr(i, j-i+1);\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    std::string longestNiceSubstring(std::string s) {\\n        const auto N = s.size();\\n\\n        std::string result;\\n\\n        for ( size_t i = 0; i < N; ++i ) {\\n            int bitmaskLowerCase = 0;\\n            int bitmaskUpperCase = 0;\\n\\n            for ( size_t j = i; j < N; ++j ) {\\n                char c = s[j];\\n\\n                if ( c >= \\'a\\' && c <= \\'z\\' )\\n                    bitmaskLowerCase |= ( 1 << ( c - \\'a\\' ) );\\n\\n                if ( c >= \\'A\\' && c <= \\'Z\\' )\\n                    bitmaskUpperCase |= ( 1 << ( c - \\'A\\' ) );\\n\\n                if ( ( bitmaskLowerCase == bitmaskUpperCase ) && ( bitmaskLowerCase > 0 ) ) {\\n                    if ( (j-i+1) > result.size() )\\n                        result = s.substr(i, j-i+1);\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151065,
                "title": "rust-brute-force-solution-with-bytes-and-bit-masks",
                "content": "```\\nimpl Solution {\\n    pub fn longest_nice_substring(s: String) -> String {\\n        let sb = s.as_bytes();\\n        let mut max_range: (usize, usize) = (0, 0);\\n\\n        for i in 0..(s.len() - 1) {\\n            let (mut lower_mask, mut upper_mask) = (0u32, 0u32);\\n\\n            for j in i..s.len() {\\n                match sb[j] >= b\\'a\\' {\\n                    true => lower_mask |= 1 << (sb[j] - b\\'a\\'),\\n                    false => upper_mask |= 1 << (sb[j] - b\\'A\\')\\n                };\\n\\n                if lower_mask == upper_mask && (j + 1 - i) > (max_range.1 - max_range.0) {\\n                    max_range = (i, j + 1);\\n                }\\n            }\\n        }\\n\\n        String::from_utf8(sb[max_range.0..max_range.1].to_vec()).unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Bitmask"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn longest_nice_substring(s: String) -> String {\\n        let sb = s.as_bytes();\\n        let mut max_range: (usize, usize) = (0, 0);\\n\\n        for i in 0..(s.len() - 1) {\\n            let (mut lower_mask, mut upper_mask) = (0u32, 0u32);\\n\\n            for j in i..s.len() {\\n                match sb[j] >= b\\'a\\' {\\n                    true => lower_mask |= 1 << (sb[j] - b\\'a\\'),\\n                    false => upper_mask |= 1 << (sb[j] - b\\'A\\')\\n                };\\n\\n                if lower_mask == upper_mask && (j + 1 - i) > (max_range.1 - max_range.0) {\\n                    max_range = (i, j + 1);\\n                }\\n            }\\n        }\\n\\n        String::from_utf8(sb[max_range.0..max_range.1].to_vec()).unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1076734,
                "title": "javascript-direct-way-200ms",
                "content": "```\\nconst mx = Math.max;\\nconst longestNiceSubstring = (s) => {\\n    let n = s.length;\\n    let res = [];\\n    let max = 0;\\n    let se = new Set();\\n    for (let i = 0; i < n; i++) {\\n        for (let j = i; j < n; j++) {\\n            let sub = s.slice(i, j + 1);\\n            if (isNice(sub)) {\\n                se.add(sub);\\n                max = mx(max, j - i + 1);\\n            }\\n        }\\n    }\\n    for (const e of se) {\\n        if (e.length == max) return e;\\n    }\\n    return \\'\\';\\n};\\n\\nconst isNice = (s) => {\\n    let lower = new Set();\\n    let upper = new Set();\\n    for (const c of s) {\\n        isLowerCaseLetter(c) ? lower.add(c) : upper.add(c);\\n    }\\n    for (const lo of lower) {\\n        if (!upper.has(lo.toUpperCase())) return false;\\n    }\\n    for (const up of upper) {\\n        if (!lower.has(up.toLowerCase())) return false;\\n    }\\n    return true;\\n};\\n\\nconst isLowerCaseLetter = (c) => {\\n    return c.charCodeAt() >= 97 && c.charCodeAt() <= 122;\\n};\\n\\n// 220ms\\n// const isLowerCaseLetter = (c) => {\\n//     return c == c.toLowerCase();\\n// };\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst mx = Math.max;\\nconst longestNiceSubstring = (s) => {\\n    let n = s.length;\\n    let res = [];\\n    let max = 0;\\n    let se = new Set();\\n    for (let i = 0; i < n; i++) {\\n        for (let j = i; j < n; j++) {\\n            let sub = s.slice(i, j + 1);\\n            if (isNice(sub)) {\\n                se.add(sub);\\n                max = mx(max, j - i + 1);\\n            }\\n        }\\n    }\\n    for (const e of se) {\\n        if (e.length == max) return e;\\n    }\\n    return \\'\\';\\n};\\n\\nconst isNice = (s) => {\\n    let lower = new Set();\\n    let upper = new Set();\\n    for (const c of s) {\\n        isLowerCaseLetter(c) ? lower.add(c) : upper.add(c);\\n    }\\n    for (const lo of lower) {\\n        if (!upper.has(lo.toUpperCase())) return false;\\n    }\\n    for (const up of upper) {\\n        if (!lower.has(up.toLowerCase())) return false;\\n    }\\n    return true;\\n};\\n\\nconst isLowerCaseLetter = (c) => {\\n    return c.charCodeAt() >= 97 && c.charCodeAt() <= 122;\\n};\\n\\n// 220ms\\n// const isLowerCaseLetter = (c) => {\\n//     return c == c.toLowerCase();\\n// };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1075093,
                "title": "rust-divide-and-conquer-with-unit-test",
                "content": "Please support a follow Rustecean. Vote up or suggest better code. Thanks!\\n```\\nuse std::collections::HashSet;\\n\\nstruct Solution;\\n\\n#[allow(dead_code)]\\nimpl Solution {\\n    pub fn longest_nice_substring(s: String) -> String {\\n        if s.len() < 2 {\\n            return \"\".to_string();\\n        }\\n        let chars: HashSet<char> = s.chars().collect();\\n        for (i, c) in s.chars().into_iter().enumerate() {\\n            if chars.contains(&c.to_ascii_lowercase()) && chars.contains(&c.to_ascii_uppercase()) {\\n                continue;\\n            }\\n            let s1 = Self::longest_nice_substring(String::from(&s[0..i]));\\n            let s2 = Self::longest_nice_substring(String::from(&s[i + 1..]));\\n            if s1.len() >= s2.len() {\\n                return s1;\\n            } else {\\n                return s2;\\n            }\\n        }\\n        s\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_solution() {\\n        assert_eq!(\\n            \"aAa\".to_string(),\\n            Solution::longest_nice_substring(\"YazaAay\".to_string())\\n        );\\n        assert_eq!(\\n            \"Bb\".to_string(),\\n            Solution::longest_nice_substring(\"Bb\".to_string())\\n        );\\n        assert_eq!(\\n            \"\".to_string(),\\n            Solution::longest_nice_substring(\"c\".to_string())\\n        );\\n        assert_eq!(\\n            \"dD\".to_string(),\\n            Solution::longest_nice_substring(\"dDzeE\".to_string())\\n        );\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "Please support a follow Rustecean. Vote up or suggest better code. Thanks!\\n```\\nuse std::collections::HashSet;\\n\\nstruct Solution;\\n\\n#[allow(dead_code)]\\nimpl Solution {\\n    pub fn longest_nice_substring(s: String) -> String {\\n        if s.len() < 2 {\\n            return \"\".to_string();\\n        }\\n        let chars: HashSet<char> = s.chars().collect();\\n        for (i, c) in s.chars().into_iter().enumerate() {\\n            if chars.contains(&c.to_ascii_lowercase()) && chars.contains(&c.to_ascii_uppercase()) {\\n                continue;\\n            }\\n            let s1 = Self::longest_nice_substring(String::from(&s[0..i]));\\n            let s2 = Self::longest_nice_substring(String::from(&s[i + 1..]));\\n            if s1.len() >= s2.len() {\\n                return s1;\\n            } else {\\n                return s2;\\n            }\\n        }\\n        s\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_solution() {\\n        assert_eq!(\\n            \"aAa\".to_string(),\\n            Solution::longest_nice_substring(\"YazaAay\".to_string())\\n        );\\n        assert_eq!(\\n            \"Bb\".to_string(),\\n            Solution::longest_nice_substring(\"Bb\".to_string())\\n        );\\n        assert_eq!(\\n            \"\".to_string(),\\n            Solution::longest_nice_substring(\"c\".to_string())\\n        );\\n        assert_eq!(\\n            \"dD\".to_string(),\\n            Solution::longest_nice_substring(\"dDzeE\".to_string())\\n        );\\n    }\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1074952,
                "title": "java-simple-solution-o-n-2",
                "content": "Use two for-loops to check every possible substring.\\nFor each substring, keep tracking which lowercase and uppercase characters are seen.\\n\\n```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        int start = 0, end = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            boolean[] upper = new boolean[26];\\n            boolean[] lower = new boolean[26];\\n            for(int j = i; j < s.length(); j++) {\\n                char c = s.charAt(j);\\n                if(\\'a\\' <= c && c <= \\'z\\') lower[c - \\'a\\'] = true;\\n                if(\\'A\\' <= c && c <= \\'Z\\') upper[c - \\'A\\'] = true;\\n                if(Arrays.equals(lower, upper) && end-start < j-i+1) {\\n                    start = i;\\n                    end = j+1;\\n                }\\n            }\\n        }\\n        return s.substring(start, end);\\n    }\\n}\\n```\\n\\nTime: ```O(N^2)```\\nSpace: ```O(1)```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        int start = 0, end = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            boolean[] upper = new boolean[26];\\n            boolean[] lower = new boolean[26];\\n            for(int j = i; j < s.length(); j++) {\\n                char c = s.charAt(j);\\n                if(\\'a\\' <= c && c <= \\'z\\') lower[c - \\'a\\'] = true;\\n                if(\\'A\\' <= c && c <= \\'Z\\') upper[c - \\'A\\'] = true;\\n                if(Arrays.equals(lower, upper) && end-start < j-i+1) {\\n                    start = i;\\n                    end = j+1;\\n                }\\n            }\\n        }\\n        return s.substring(start, end);\\n    }\\n}\\n```\n```O(N^2)```\n```O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 1074802,
                "title": "python-3-simple-brute-force-with-explanation",
                "content": "Function ```isNice``` is checking if the string is nice. When the first \"not nice\" character is found, it returns False. \\n\\nWe are checking all possible substring only if the substring is longer than the actual answer.\\n\\nRuntime: 84 ms, faster than 100.00% of Python3\\n\\n```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n                \\n        def isNice(s):\\n            for ch in s:\\n                if ch.lower() not in s or ch.upper() not in s:\\n                    return False\\n            return True\\n        \\n        n=len(s)\\n        answ=\\'\\'\\n        for left in range(n-len(answ)):\\n            right=n\\n            while right-left>len(answ):\\n                if isNice(s[left:right]):\\n                    answ=s[left:right]\\n                right-=1\\n                    \\n        return answ\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```isNice```\n```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n                \\n        def isNice(s):\\n            for ch in s:\\n                if ch.lower() not in s or ch.upper() not in s:\\n                    return False\\n            return True\\n        \\n        n=len(s)\\n        answ=\\'\\'\\n        for left in range(n-len(answ)):\\n            right=n\\n            while right-left>len(answ):\\n                if isNice(s[left:right]):\\n                    answ=s[left:right]\\n                right-=1\\n                    \\n        return answ\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074601,
                "title": "js-brute-force",
                "content": "```\\nvar longestNiceSubstring = function (s) {\\n  s = s.split(\"\");\\n  const N = s.length;\\n  let max = \"\";\\n\\n  for (let i = 0; i < N - 1; i++) {\\n    let substr = [s[i]];\\n\\n    for (let j = i + 1; j < N; j++) {\\n      substr.push(s[j]);\\n      let isNice = true;\\n\\n      for (const c of substr) {\\n        if (\\n          !substr.includes(c.toLowerCase()) ||\\n          !substr.includes(c.toUpperCase())\\n        ) {\\n          isNice = false;\\n        }\\n      }\\n\\n      if (isNice && substr.join(\"\").length > max.length) {\\n        max = substr.join(\"\");\\n      }\\n    }\\n  }\\n\\n  return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestNiceSubstring = function (s) {\\n  s = s.split(\"\");\\n  const N = s.length;\\n  let max = \"\";\\n\\n  for (let i = 0; i < N - 1; i++) {\\n    let substr = [s[i]];\\n\\n    for (let j = i + 1; j < N; j++) {\\n      substr.push(s[j]);\\n      let isNice = true;\\n\\n      for (const c of substr) {\\n        if (\\n          !substr.includes(c.toLowerCase()) ||\\n          !substr.includes(c.toUpperCase())\\n        ) {\\n          isNice = false;\\n        }\\n      }\\n\\n      if (isNice && substr.join(\"\").length > max.length) {\\n        max = substr.join(\"\");\\n      }\\n    }\\n  }\\n\\n  return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1074560,
                "title": "a-few-solutions",
                "content": "Reduce the input string `s` by removing violations to the `isNice` rule, then recursively explore the substrings between violations to find the longest \"nice\" substring as the `best` answer.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun longestNiceSubstring(s: String): String {\\n        var best = \"\"\\n        fun go(s: String) {\\n            var seen = s.toSet()\\n            var isNice = { c: Char -> seen.contains(c.toLowerCase()) && seen.contains(c.toUpperCase()) }\\n            for (i in 0 until s.length) {\\n                if (!isNice(s[i])) {\\n                    go(s.substring(0, i)); go(s.substring(i + 1))\\n                    return\\n                }\\n            }\\n            if (best.length < s.length)\\n                best = s\\n        }\\n        go(s)\\n        return best\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet longestNiceSubstring = s => {\\n    let best = \\'\\';\\n    let go = s => {\\n        let seen = new Set(s);\\n        let isNice = c => seen.has(c.toLowerCase()) && seen.has(c.toUpperCase());\\n        for (let i = 0; i < s.length; ++i) {\\n            if (!isNice(s[i])) {\\n                go(s.substring(0, i)), go(s.substring(i + 1));\\n                return;\\n            }\\n        }\\n        if (best.length < s.length)\\n            best = s;\\n    }\\n    go(s);\\n    return best;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        best = \\'\\'\\n        def go(s):\\n            nonlocal best\\n            seen = set(s)\\n            isNice = lambda c: c.lower() in seen and c.upper() in seen\\n            for i in range(len(s)):\\n                if not isNice(s[i]):\\n                    go(s[:i]); go(s[i + 1:])\\n                    return\\n            if len(best) < len(s):\\n                best = s\\n        go(s)\\n        return best\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<char>;\\n    using fun = function<void(string&&)>;\\n    string longestNiceSubstring(string s, string best = {}) {\\n        fun go = [&](auto&& s) {\\n            Set seen{ s.begin(), s.end() };\\n            auto isNice = [&](auto c) {\\n                return seen.find(tolower(c)) != seen.end() && seen.find(toupper(c)) != seen.end();\\n            };\\n            for (auto i{ 0 }; i < s.size(); ++i) {\\n                if (!isNice(s[i])) {\\n                    go(s.substr(0, i)), go(s.substr(i + 1));\\n                    return;\\n                }\\n            }\\n            if (best.size() < s.size())\\n                best = s;\\n        };\\n        go(move(s));\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun longestNiceSubstring(s: String): String {\\n        var best = \"\"\\n        fun go(s: String) {\\n            var seen = s.toSet()\\n            var isNice = { c: Char -> seen.contains(c.toLowerCase()) && seen.contains(c.toUpperCase()) }\\n            for (i in 0 until s.length) {\\n                if (!isNice(s[i])) {\\n                    go(s.substring(0, i)); go(s.substring(i + 1))\\n                    return\\n                }\\n            }\\n            if (best.length < s.length)\\n                best = s\\n        }\\n        go(s)\\n        return best\\n    }\\n}\\n```\n```\\nlet longestNiceSubstring = s => {\\n    let best = \\'\\';\\n    let go = s => {\\n        let seen = new Set(s);\\n        let isNice = c => seen.has(c.toLowerCase()) && seen.has(c.toUpperCase());\\n        for (let i = 0; i < s.length; ++i) {\\n            if (!isNice(s[i])) {\\n                go(s.substring(0, i)), go(s.substring(i + 1));\\n                return;\\n            }\\n        }\\n        if (best.length < s.length)\\n            best = s;\\n    }\\n    go(s);\\n    return best;\\n};\\n```\n```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        best = \\'\\'\\n        def go(s):\\n            nonlocal best\\n            seen = set(s)\\n            isNice = lambda c: c.lower() in seen and c.upper() in seen\\n            for i in range(len(s)):\\n                if not isNice(s[i]):\\n                    go(s[:i]); go(s[i + 1:])\\n                    return\\n            if len(best) < len(s):\\n                best = s\\n        go(s)\\n        return best\\n```\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<char>;\\n    using fun = function<void(string&&)>;\\n    string longestNiceSubstring(string s, string best = {}) {\\n        fun go = [&](auto&& s) {\\n            Set seen{ s.begin(), s.end() };\\n            auto isNice = [&](auto c) {\\n                return seen.find(tolower(c)) != seen.end() && seen.find(toupper(c)) != seen.end();\\n            };\\n            for (auto i{ 0 }; i < s.size(); ++i) {\\n                if (!isNice(s[i])) {\\n                    go(s.substr(0, i)), go(s.substr(i + 1));\\n                    return;\\n                }\\n            }\\n            if (best.size() < s.size())\\n                best = s;\\n        };\\n        go(move(s));\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919584,
                "title": "o-n-using-set-substring",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n  O(N)\\n\\n- Space complexity:\\n O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        int n = s.size();\\n        if(n==1) return \"\";\\n        unordered_set<char>uset;\\n        for(int i =0 ; i<n ; i++){\\n           uset.insert(s[i]);\\n        }\\n        for(int i = 0 ; i<n ; i++){\\n        if(uset.count(tolower(s[i]))== true && uset.count(toupper(s[i]))== true) continue;\\n        string prev = longestNiceSubstring(s.substr(0,i)); // create two substring to compare length \\n        string next = longestNiceSubstring(s.substr(i+1));\\n        return prev.size()>=next.size()? prev:next;// return substring of max. length\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        int n = s.size();\\n        if(n==1) return \"\";\\n        unordered_set<char>uset;\\n        for(int i =0 ; i<n ; i++){\\n           uset.insert(s[i]);\\n        }\\n        for(int i = 0 ; i<n ; i++){\\n        if(uset.count(tolower(s[i]))== true && uset.count(toupper(s[i]))== true) continue;\\n        string prev = longestNiceSubstring(s.substr(0,i)); // create two substring to compare length \\n        string next = longestNiceSubstring(s.substr(i+1));\\n        return prev.size()>=next.size()? prev:next;// return substring of max. length\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642790,
                "title": "python-stack-divide-an-conquer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        res = \"\"\\n        stack = [s]\\n        while stack:\\n            word = stack.pop()\\n            if not word:\\n                continue\\n            sset = set(list(word))\\n            for i,j in enumerate(word):\\n                if j.swapcase() not in sset:\\n                    stack.append(word[i+1:])\\n                    stack.append(word[:i])\\n                    break\\n            else:\\n                res = max(res, word, key=len)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        res = \"\"\\n        stack = [s]\\n        while stack:\\n            word = stack.pop()\\n            if not word:\\n                continue\\n            sset = set(list(word))\\n            for i,j in enumerate(word):\\n                if j.swapcase() not in sset:\\n                    stack.append(word[i+1:])\\n                    stack.append(word[:i])\\n                    break\\n            else:\\n                res = max(res, word, key=len)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470957,
                "title": "c-accepted-brute-force-very-easy-and-detailed-explain",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool isnice(string str){\\n      map<int,bool>map;\\n//create a map to track the all letter if letter is persent so we can put true in map\\n     for(int i=0;i<str.length();i++){\\n            int p = str[i];//its a method to get the ascii value of any charachter \\n\\n             map[p]=true;\\n     }\\n\\n     for(int i=0;i<str.length();i++){\\n         int q=str[i];//its a method to get the ascii value of any charachter \\n         if(isupper(str[i])){\\n             //if letter is uppercase then we wil check for its lowercae letter from map ascii value of any lowercase letter is 32 more then ascii value of the uppercase letter\\n             int z=q+32;\\n             if(!(map[z])){\\n                 // if asci valueof uppercaseletter=32 is not persent in the map we return false\\n                 return false;\\n             }\\n         }\\n         else{\\n              int z=q-32;\\n             if(!(map[z])){\\n                 return false;\\n             }\\n         }       \\n    }\\n    //if we check all the string and false is not return we will return true\\n     return true;\\n   }\\n\\n    string longestNiceSubstring(string s) {\\n    string ans=\"\";\\n    //initialize ans string as empty string so if we dont get any nice string we can return that empty string\\n     for(int i=0;i<s.length();i++){\\n         for(int j=0;j<=s.length();j++){\\n        //these two for loop for get all the possible sub string\\n            string str = s.substr(i,j);  \\n //  s.substr(i,j); predefine function to get a substring take argumnet as index(where the substring start) and length (of the substring)  \\n            if(isnice(str)){  \\n                //isnice is function to check all the substring is nice or not\\n                   if(str.length()>ans.length()){\\n                       // if we found substring that is nice we can compare with the ans if ans is smaller string we can update our ans\\n                     ans = str;\\n                  }\\n              }\\n         }\\n     }\\n        \\n     return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool isnice(string str){\\n      map<int,bool>map;\\n//create a map to track the all letter if letter is persent so we can put true in map\\n     for(int i=0;i<str.length();i++){\\n            int p = str[i];//its a method to get the ascii value of any charachter \\n\\n             map[p]=true;\\n     }\\n\\n     for(int i=0;i<str.length();i++){\\n         int q=str[i];//its a method to get the ascii value of any charachter \\n         if(isupper(str[i])){\\n             //if letter is uppercase then we wil check for its lowercae letter from map ascii value of any lowercase letter is 32 more then ascii value of the uppercase letter\\n             int z=q+32;\\n             if(!(map[z])){\\n                 // if asci valueof uppercaseletter=32 is not persent in the map we return false\\n                 return false;\\n             }\\n         }\\n         else{\\n              int z=q-32;\\n             if(!(map[z])){\\n                 return false;\\n             }\\n         }       \\n    }\\n    //if we check all the string and false is not return we will return true\\n     return true;\\n   }\\n\\n    string longestNiceSubstring(string s) {\\n    string ans=\"\";\\n    //initialize ans string as empty string so if we dont get any nice string we can return that empty string\\n     for(int i=0;i<s.length();i++){\\n         for(int j=0;j<=s.length();j++){\\n        //these two for loop for get all the possible sub string\\n            string str = s.substr(i,j);  \\n //  s.substr(i,j); predefine function to get a substring take argumnet as index(where the substring start) and length (of the substring)  \\n            if(isnice(str)){  \\n                //isnice is function to check all the substring is nice or not\\n                   if(str.length()>ans.length()){\\n                       // if we found substring that is nice we can compare with the ans if ans is smaller string we can update our ans\\n                     ans = str;\\n                  }\\n              }\\n         }\\n     }\\n        \\n     return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3245857,
                "title": "js-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nfunction longestNiceSubstring(s) {\\n    if (s.length < 2) return \"\";\\n    const set = new Set();\\n    for (const c of s) set.add(c);\\n\\n    for (let i = 0; i <= s.length - 1; i++) {\\n        const upperCaseChar = s[i].toUpperCase();\\n        const lowerCaseChar = s[i].toLowerCase();\\n\\n        if (set.has(upperCaseChar) && set.has(lowerCaseChar)) {\\n            continue; \\n        }\\n        var str1=longestNiceSubstring(s.substring(0,i));\\n        var str2=longestNiceSubstring(s.substring(i+1));\\n        return str1.length>=str2.length?str1:str2;\\n    }\\n    return s;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nfunction longestNiceSubstring(s) {\\n    if (s.length < 2) return \"\";\\n    const set = new Set();\\n    for (const c of s) set.add(c);\\n\\n    for (let i = 0; i <= s.length - 1; i++) {\\n        const upperCaseChar = s[i].toUpperCase();\\n        const lowerCaseChar = s[i].toLowerCase();\\n\\n        if (set.has(upperCaseChar) && set.has(lowerCaseChar)) {\\n            continue; \\n        }\\n        var str1=longestNiceSubstring(s.substring(0,i));\\n        var str2=longestNiceSubstring(s.substring(i+1));\\n        return str1.length>=str2.length?str1:str2;\\n    }\\n    return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3227632,
                "title": "east-java-solution-divide-and-conquer-using-set-o-n",
                "content": "> Please UpVote if you find this solution useful \\uD83D\\uDC4D\\uD83D\\uDCAF\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        if(s.length()<2) return \"\";\\n        char[] arr = s.toCharArray();\\n        Set<Character> set = new HashSet<>();\\n        for(char c : arr) {\\n            set.add(c);\\n        }\\n        for(int i =0;i<arr.length;i++) {\\n            char ch = arr[i];\\n            if(set.contains(Character.toUpperCase(ch)) && set.contains(Character.toLowerCase(ch))) continue;\\n            String subStr1 = longestNiceSubstring(s.substring(0,i));\\n            String subStr2 = longestNiceSubstring(s.substring(i+1));\\n            return subStr1.length()>= subStr2.length()?subStr1:subStr2;\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        if(s.length()<2) return \"\";\\n        char[] arr = s.toCharArray();\\n        Set<Character> set = new HashSet<>();\\n        for(char c : arr) {\\n            set.add(c);\\n        }\\n        for(int i =0;i<arr.length;i++) {\\n            char ch = arr[i];\\n            if(set.contains(Character.toUpperCase(ch)) && set.contains(Character.toLowerCase(ch))) continue;\\n            String subStr1 = longestNiceSubstring(s.substring(0,i));\\n            String subStr2 = longestNiceSubstring(s.substring(i+1));\\n            return subStr1.length()>= subStr2.length()?subStr1:subStr2;\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835450,
                "title": "java-devide-and-conqure-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDevide and Conqure\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        // base case\\n        if (s.length() < 2) return \"\";\\n\\n        int mid = -1;\\n        Set<Character> set = new HashSet<Character>();\\n        // put characters into a set for each sub string\\n        for(int i=0; i<s.length(); i++){\\n            set.add(s.charAt(i));\\n        }\\n    \\n        for (int i=0; i<s.length(); i++){\\n            if(!set.contains(Character.toLowerCase(s.charAt(i))) || !set.contains(Character.toUpperCase(s.charAt(i)))){\\n                // find the element that should not be included\\n                mid = i;\\n                break;\\n            }\\n        }\\n        // if not find anything, which means it\\'s a nice string and no needs to be divied, retrun it\\n        if(mid == -1) return s;\\n\\n        /*\\n            if first level s = \"YazaAay\", then mid=2(z index) because we \\n            cannot include z withou Z in the set use z as mid point and \\n            devide string into two part, which are \"Ya\" and \"aAay\". \\n            Then keep doigin the same thing for the sub\\n            strings\\n        */\\n        String left  = longestNiceSubstring(s.substring(0,mid));\\n        String right = longestNiceSubstring(s.substring(mid+1));\\n\\n        // use = because it requires the first nice string that meet the requirement \\n        // for example=> if s=\"dDzeE\"\\n        //                  the answer should be \"dD\" rather than \"eE\"\\n        return left.length() >= right.length()? left:right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        // base case\\n        if (s.length() < 2) return \"\";\\n\\n        int mid = -1;\\n        Set<Character> set = new HashSet<Character>();\\n        // put characters into a set for each sub string\\n        for(int i=0; i<s.length(); i++){\\n            set.add(s.charAt(i));\\n        }\\n    \\n        for (int i=0; i<s.length(); i++){\\n            if(!set.contains(Character.toLowerCase(s.charAt(i))) || !set.contains(Character.toUpperCase(s.charAt(i)))){\\n                // find the element that should not be included\\n                mid = i;\\n                break;\\n            }\\n        }\\n        // if not find anything, which means it\\'s a nice string and no needs to be divied, retrun it\\n        if(mid == -1) return s;\\n\\n        /*\\n            if first level s = \"YazaAay\", then mid=2(z index) because we \\n            cannot include z withou Z in the set use z as mid point and \\n            devide string into two part, which are \"Ya\" and \"aAay\". \\n            Then keep doigin the same thing for the sub\\n            strings\\n        */\\n        String left  = longestNiceSubstring(s.substring(0,mid));\\n        String right = longestNiceSubstring(s.substring(mid+1));\\n\\n        // use = because it requires the first nice string that meet the requirement \\n        // for example=> if s=\"dDzeE\"\\n        //                  the answer should be \"dD\" rather than \"eE\"\\n        return left.length() >= right.length()? left:right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2662741,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        if(s.length()<=1)\\n        {\\n            return \"\";\\n        }\\n        unordered_set<char>st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            st.insert(s[i]);\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch=s[i];\\n            if(st.find(tolower(ch))==st.end() || st.find(toupper(ch))==st.end())\\n            {\\n                string s1=longestNiceSubstring(s.substr(0,i));\\n                string s2=longestNiceSubstring(s.substr(i+1,s.length()));\\n                if(s1.length()>=s2.length())\\n                {\\n                    return s1;\\n                }\\n                else\\n                {\\n                    return s2;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        if(s.length()<=1)\\n        {\\n            return \"\";\\n        }\\n        unordered_set<char>st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            st.insert(s[i]);\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch=s[i];\\n            if(st.find(tolower(ch))==st.end() || st.find(toupper(ch))==st.end())\\n            {\\n                string s1=longestNiceSubstring(s.substr(0,i));\\n                string s2=longestNiceSubstring(s.substr(i+1,s.length()));\\n                if(s1.length()>=s2.length())\\n                {\\n                    return s1;\\n                }\\n                else\\n                {\\n                    return s2;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351149,
                "title": "c-easily-understandable-brute-force",
                "content": "```\\nTime: O(n^3)  Space: O(1)\\n\\nclass Solution {\\npublic:\\n    bool nice(string str){\\n        int n=size(str);\\n        for(int i=0;i<n;i++){\\n            char t=str[i];\\n            t= t<=90 ? t+32 : t-32 ;\\n            if(str.find(t)==string::npos)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    string longestNiceSubstring(string s) {\\n        int n=size(s);\\n        string res=\"\";\\n        for(int i=0;i<n;i++){\\n            string t=\"\";\\n            t+=s[i];\\n            for(int j=i+1;j<n;j++){\\n                t+=s[j];\\n                if( nice(t) and (t.size()>res.size()) )\\n                    res=t;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nTime: O(n^3)  Space: O(1)\\n\\nclass Solution {\\npublic:\\n    bool nice(string str){\\n        int n=size(str);\\n        for(int i=0;i<n;i++){\\n            char t=str[i];\\n            t= t<=90 ? t+32 : t-32 ;\\n            if(str.find(t)==string::npos)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    string longestNiceSubstring(string s) {\\n        int n=size(s);\\n        string res=\"\";\\n        for(int i=0;i<n;i++){\\n            string t=\"\";\\n            t+=s[i];\\n            for(int j=i+1;j<n;j++){\\n                t+=s[j];\\n                if( nice(t) and (t.size()>res.size()) )\\n                    res=t;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888960,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        \\n        int index = isNotNiceString(s);\\n        \\n        if(index == -1){\\n            return s;\\n        }\\n        \\n        String left = longestNiceSubstring(s.substring(0, index));\\n        String right = longestNiceSubstring(s.substring(index+1));\\n        \\n        return left.length() >= right.length() ? left : right;   \\n    }\\n    \\n    int isNotNiceString(String s) {\\n        Set<Character> set = new HashSet<>();\\n        \\n        for (char c : s.toCharArray()) {\\n            set.add(c);\\n        }\\n        \\n               \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (!set.contains(Character.toLowerCase(c)) || !set.contains(Character.toUpperCase(c))) {\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        \\n        int index = isNotNiceString(s);\\n        \\n        if(index == -1){\\n            return s;\\n        }\\n        \\n        String left = longestNiceSubstring(s.substring(0, index));\\n        String right = longestNiceSubstring(s.substring(index+1));\\n        \\n        return left.length() >= right.length() ? left : right;   \\n    }\\n    \\n    int isNotNiceString(String s) {\\n        Set<Character> set = new HashSet<>();\\n        \\n        for (char c : s.toCharArray()) {\\n            set.add(c);\\n        }\\n        \\n               \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (!set.contains(Character.toLowerCase(c)) || !set.contains(Character.toUpperCase(c))) {\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1814236,
                "title": "javascript-easy-to-understand-divide-and-conquer",
                "content": "The idea behind the solution is to use a pivot (an index for which the opposite case char doesn\\'t exist)\\n\\nExample String: `YazaAbaACaAay`\\nFinding all the index for which the opposite case doesn\\'t exist.\\n`|Y |a |z |a |A |b |a |A |C |a |A  |a   |y  |`\\n`|0 |1 |2 |3 |4 |5 |6 |7 |8 |9 |10|11|12|`\\npivots = [2, 5, 8]\\nLooking at the pivot table it tells us that the solution can exist in the below buckets of substrings:\\n- `[0-2)` - `Ya`\\n- `(2,5)` - `aA`\\n-  `(5-8)` - `aA`\\n-  `[9-12]` - `aAay`\\n\\n\\n**Approach 1: Divide as soon the opposite case doesn\\'t exist**\\nIn this approach we divide the string into two halves excluding the character at current index as soon as the opposite case doesn\\'t exist. \\nFirst iteration `Ya` and `aAbaACaAay`\\n```\\nvar longestNiceSubstring = function(s) {    \\n    if (!s.length || s.length < 2) {\\n        return \"\";\\n    }\\n    \\n    let i=0;\\n    \\n    for (; i<s.length; i++) {\\n        const isUpper = isUpperCase(s[i]);\\n        if (isUpper && !s.includes(s[i].toLowerCase())) {\\n            break;\\n        } else if(!isUpper && !s.includes(s[i].toUpperCase())) {\\n            break;\\n        }\\n    }\\n\\t// when the string is nice \\n    if (i === s.length) {\\n        return s;\\n    }\\n    \\n    const leftSubstr = longestNiceSubstring(s.substring(0, i));\\n    const rightSubstr= longestNiceSubstring(s.substring(i+1));\\n\\t// question is asking for the first occurrence of the solution so we have the equality sign >=\\n    return leftSubstr.length >= rightSubstr.length ? leftSubstr : rightSubstr;\\n    \\n};\\n\\nfunction isUpperCase(c) {\\n    return c.toUpperCase() === c;\\n}\\n```\\n\\n**Approach 2: Divide using a pivot table**\\nIn this approach finds all the pivots then look for the answer for middle pivot index. \\n`YazaA` and `aACaAay`\\n```\\nvar longestNiceSubstring = function(s) {    \\n    if (!s.length || s.length < 2) {\\n        return \"\";\\n    }\\n    \\n    let pivot = [];\\n    \\n    for (let i=0; i<s.length; i++) {\\n        const isUpper = isUpperCase(s[i]);\\n        if (isUpper && !s.includes(s[i].toLowerCase())) {\\n            pivot.push(i);\\n        } else if(!isUpper && !s.includes(s[i].toUpperCase())) {\\n            pivot.push(i);\\n        }\\n    }\\n    \\n\\t// when the string is nice\\n    if (!pivot.length) {\\n        return s;\\n    }\\n    \\n\\t// Find the middle pivot index\\n    const mid = pivot[Math.floor(pivot.length / 2)];\\n    const leftSubstr = longestNiceSubstring(s.substring(0, mid));\\n    const rightSubstr= longestNiceSubstring(s.substring(mid+1));\\n\\t// question is asking for the first occurrence of the solution so we have the equality sign >=\\n    return leftSubstr.length >= rightSubstr.length ? leftSubstr : rightSubstr;\\n    \\n};\\n\\nfunction isUpperCase(c) {\\n    return c.toUpperCase() === c;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Divide and Conquer"
                ],
                "code": "```\\nvar longestNiceSubstring = function(s) {    \\n    if (!s.length || s.length < 2) {\\n        return \"\";\\n    }\\n    \\n    let i=0;\\n    \\n    for (; i<s.length; i++) {\\n        const isUpper = isUpperCase(s[i]);\\n        if (isUpper && !s.includes(s[i].toLowerCase())) {\\n            break;\\n        } else if(!isUpper && !s.includes(s[i].toUpperCase())) {\\n            break;\\n        }\\n    }\\n\\t// when the string is nice \\n    if (i === s.length) {\\n        return s;\\n    }\\n    \\n    const leftSubstr = longestNiceSubstring(s.substring(0, i));\\n    const rightSubstr= longestNiceSubstring(s.substring(i+1));\\n\\t// question is asking for the first occurrence of the solution so we have the equality sign >=\\n    return leftSubstr.length >= rightSubstr.length ? leftSubstr : rightSubstr;\\n    \\n};\\n\\nfunction isUpperCase(c) {\\n    return c.toUpperCase() === c;\\n}\\n```\n```\\nvar longestNiceSubstring = function(s) {    \\n    if (!s.length || s.length < 2) {\\n        return \"\";\\n    }\\n    \\n    let pivot = [];\\n    \\n    for (let i=0; i<s.length; i++) {\\n        const isUpper = isUpperCase(s[i]);\\n        if (isUpper && !s.includes(s[i].toLowerCase())) {\\n            pivot.push(i);\\n        } else if(!isUpper && !s.includes(s[i].toUpperCase())) {\\n            pivot.push(i);\\n        }\\n    }\\n    \\n\\t// when the string is nice\\n    if (!pivot.length) {\\n        return s;\\n    }\\n    \\n\\t// Find the middle pivot index\\n    const mid = pivot[Math.floor(pivot.length / 2)];\\n    const leftSubstr = longestNiceSubstring(s.substring(0, mid));\\n    const rightSubstr= longestNiceSubstring(s.substring(mid+1));\\n\\t// question is asking for the first occurrence of the solution so we have the equality sign >=\\n    return leftSubstr.length >= rightSubstr.length ? leftSubstr : rightSubstr;\\n    \\n};\\n\\nfunction isUpperCase(c) {\\n    return c.toUpperCase() === c;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1810981,
                "title": "c-optimal-d-c-o-26-n-time-o-1-space",
                "content": "I was just scrolling to see if anyone did a solution without `vector <int> (26)`, \\nbut I didn\\'t see any, so I wrote one. \\nThe general idea is the same any D&C, but it\\'s the most optimal imo:\\n```\\nvoid f(string &s, int l, int r, int &ret, int &reti) {\\n    // ret >= r - l prune by @stackdaniel\\n    if (l == r || ret >= r - l) return ; // empty\\n    int a = 0, b = 0, c = 0; // big, small, xor intersection\\n    for (int j = l; j < r; j++) {\\n        if (s[j] < \\'a\\') a |= (1 << (s[j] - \\'A\\')); // Big char present\\n        else b |= (1 << (s[j] - \\'a\\')); // Small char present\\n    }\\n    c = a ^ b; // bad chars\\n    if (c == 0) { // \\'nice\\', no bad chars\\n        // check no longer needed cause of pruning earlier\\n        // if (ret < r - l) { // update the answer\\n            ret = r - l;\\n            reti = l;\\n        // }\\n        return ; // don\\'t divide anymore\\n    }\\n    // otherwise divide into substrings over bad chars\\n    int i = l;\\n    for (int j = l; j < r; j++) {\\n        int x = s[j] < \\'a\\' ?  \\'A\\' : \\'a\\';\\n        if ((1 << (s[j] - x)) & c) { // bad char\\n            f(s, i, j, ret, reti); // check subarray [i -> j)\\n            i = j + 1;\\n        }\\n    }\\n    f(s, i, r, ret, reti); \\n    // check up to end [i -> r) \\n    // cause the for loop won\\'t check it\\n}\\nstring longestNiceSubstring(string s) {\\n    // divide until nice\\n    int ret = 0, reti = 0;\\n    f(s, 0, s.size(), ret, reti);\\n    return s.substr(reti, ret); // do substr only one time\\n    // technically O(N) space cause this return copies the string, \\n    // but hey O(1) space anywhere else xD \\n    // (*not including stack which is O(26) space) \\n}\\n```\\nIf you came up with the same idea:\\n* without vectors (or arrays/dicts) to store checks chars\\n* without multiple substr call\\n\\npaste your implementation in comments, I would like to see those.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Divide and Conquer"
                ],
                "code": "```\\nvoid f(string &s, int l, int r, int &ret, int &reti) {\\n    // ret >= r - l prune by @stackdaniel\\n    if (l == r || ret >= r - l) return ; // empty\\n    int a = 0, b = 0, c = 0; // big, small, xor intersection\\n    for (int j = l; j < r; j++) {\\n        if (s[j] < \\'a\\') a |= (1 << (s[j] - \\'A\\')); // Big char present\\n        else b |= (1 << (s[j] - \\'a\\')); // Small char present\\n    }\\n    c = a ^ b; // bad chars\\n    if (c == 0) { // \\'nice\\', no bad chars\\n        // check no longer needed cause of pruning earlier\\n        // if (ret < r - l) { // update the answer\\n            ret = r - l;\\n            reti = l;\\n        // }\\n        return ; // don\\'t divide anymore\\n    }\\n    // otherwise divide into substrings over bad chars\\n    int i = l;\\n    for (int j = l; j < r; j++) {\\n        int x = s[j] < \\'a\\' ?  \\'A\\' : \\'a\\';\\n        if ((1 << (s[j] - x)) & c) { // bad char\\n            f(s, i, j, ret, reti); // check subarray [i -> j)\\n            i = j + 1;\\n        }\\n    }\\n    f(s, i, r, ret, reti); \\n    // check up to end [i -> r) \\n    // cause the for loop won\\'t check it\\n}\\nstring longestNiceSubstring(string s) {\\n    // divide until nice\\n    int ret = 0, reti = 0;\\n    f(s, 0, s.size(), ret, reti);\\n    return s.substr(reti, ret); // do substr only one time\\n    // technically O(N) space cause this return copies the string, \\n    // but hey O(1) space anywhere else xD \\n    // (*not including stack which is O(26) space) \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1787756,
                "title": "c-divide-and-conquer-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        if(s.size()<2)return \"\";\\n        unordered_set<char>st(s.begin(),s.end());\\n        for(int i=0;i<s.size();i++){\\n            if(!st.count(toupper(s[i])) || !st.count(tolower(s[i]))){\\n                string s1= longestNiceSubstring(s.substr(0,i)),s2=longestNiceSubstring(s.substr(i+1));\\n                return s1.size()>=s2.size()?s1:s2;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        if(s.size()<2)return \"\";\\n        unordered_set<char>st(s.begin(),s.end());\\n        for(int i=0;i<s.size();i++){\\n            if(!st.count(toupper(s[i])) || !st.count(tolower(s[i]))){\\n                string s1= longestNiceSubstring(s.substr(0,i)),s2=longestNiceSubstring(s.substr(i+1));\\n                return s1.size()>=s2.size()?s1:s2;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731045,
                "title": "brute-force",
                "content": "I posted because i wanted to stay motivated. have been very down lately\\n```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        \\n        \\n        sli =\"\"\\n        maxx = 0\\n        ans = 0\\n        res=\"\"\\n        for i in range(len(s)):\\n            sli=s[i]\\n            for j in range(i+1,len(s)):\\n                d = {}\\n                sli+=s[j]\\n                print(sli)\\n                for k in range(len(sli)):\\n                    if sli[k].lower() not in d:\\n                        d[sli[k].lower()] = 0\\n                        d[sli[k].upper()] = 0\\n                \\n                for letter in sli:\\n                    if letter in d:\\n                        d[letter]=1\\n                print(d)\\n                if all(d.values()): \\n                    ans = j-i+1\\n                    print(i,j)\\n                if maxx<ans:\\n                    res = sli\\n                    maxx = max(maxx, ans)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        \\n        \\n        sli =\"\"\\n        maxx = 0\\n        ans = 0\\n        res=\"\"\\n        for i in range(len(s)):\\n            sli=s[i]\\n            for j in range(i+1,len(s)):\\n                d = {}\\n                sli+=s[j]\\n                print(sli)\\n                for k in range(len(sli)):\\n                    if sli[k].lower() not in d:\\n                        d[sli[k].lower()] = 0\\n                        d[sli[k].upper()] = 0\\n                \\n                for letter in sli:\\n                    if letter in d:\\n                        d[letter]=1\\n                print(d)\\n                if all(d.values()): \\n                    ans = j-i+1\\n                    print(i,j)\\n                if maxx<ans:\\n                    res = sli\\n                    maxx = max(maxx, ans)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680609,
                "title": "simple-brute-force-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isNice(string s)\\n    {\\n        map<char,int> mp;\\n        for(auto &i : s) mp[i]++;\\n        \\n        for(auto &i : s)\\n        {\\n            if(i >= \\'A\\' && i <= \\'Z\\')\\n            {\\n                if(mp[i+32] == 0) return 0;\\n            }\\n            else\\n            {\\n                if(mp[i-32] == 0) return 0;\\n            }\\n        }\\n        \\n        return 1;\\n    }\\n    string longestNiceSubstring(string s) {\\n        string res=\"\";\\n        int max_length = 0;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            for(int j=i+1;j<s.length();j++)\\n            {\\n                string t = s.substr(i,j-i+1);\\n                if(isNice(t))\\n                {\\n                    if(t.length() > max_length)\\n                    {\\n                        max_length = t.length();\\n                        res = t;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isNice(string s)\\n    {\\n        map<char,int> mp;\\n        for(auto &i : s) mp[i]++;\\n        \\n        for(auto &i : s)\\n        {\\n            if(i >= \\'A\\' && i <= \\'Z\\')\\n            {\\n                if(mp[i+32] == 0) return 0;\\n            }\\n            else\\n            {\\n                if(mp[i-32] == 0) return 0;\\n            }\\n        }\\n        \\n        return 1;\\n    }\\n    string longestNiceSubstring(string s) {\\n        string res=\"\";\\n        int max_length = 0;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            for(int j=i+1;j<s.length();j++)\\n            {\\n                string t = s.substr(i,j-i+1);\\n                if(isNice(t))\\n                {\\n                    if(t.length() > max_length)\\n                    {\\n                        max_length = t.length();\\n                        res = t;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577591,
                "title": "java-solution-100-faster-98-lesser-space",
                "content": "```\\npublic String longestNiceSubstring(String s) {\\n        int n = s.length();\\n        if(n<2)\\n            return \"\";\\n        boolean[] lower = new boolean[26];\\n        boolean[] upper = new boolean[26];\\n        char c;\\n        boolean flag=true;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if((int)s.charAt(i)>=97)\\n                upper[s.charAt(i)-97] = true;\\n            else\\n                lower[s.charAt(i)-65] = true;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(upper[i]!=lower[i])\\n            {\\n                if(upper[i])\\n                    c = (char)(i+97);\\n                else\\n                    c = (char)(i+65);\\n                flag = false;\\n                break;\\n            }\\n        }\\n        if(flag)\\n            return s;\\n        String str1,str2;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i) == c)\\n            {\\n                str1 = longestNiceSubstring(s.substring(0,i));\\n                str2 = longestNiceSubstring(s.substring(i+1,s.length()));\\n                return str1.length()<str2.length()?str2:str1;\\n               \\n            }\\n        }\\n        return \"\";\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\npublic String longestNiceSubstring(String s) {\\n        int n = s.length();\\n        if(n<2)\\n            return \"\";\\n        boolean[] lower = new boolean[26];\\n        boolean[] upper = new boolean[26];\\n        char c;\\n        boolean flag=true;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if((int)s.charAt(i)>=97)\\n                upper[s.charAt(i)-97] = true;\\n            else\\n                lower[s.charAt(i)-65] = true;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(upper[i]!=lower[i])\\n            {\\n                if(upper[i])\\n                    c = (char)(i+97);\\n                else\\n                    c = (char)(i+65);\\n                flag = false;\\n                break;\\n            }\\n        }\\n        if(flag)\\n            return s;\\n        String str1,str2;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i) == c)\\n            {\\n                str1 = longestNiceSubstring(s.substring(0,i));\\n                str2 = longestNiceSubstring(s.substring(i+1,s.length()));\\n                return str1.length()<str2.length()?str2:str1;\\n               \\n            }\\n        }\\n        return \"\";\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1547496,
                "title": "java-easy-solution-brute-force",
                "content": "```\\nclass Solution {\\n    \\n    \\n    \\n    boolean isnice(String s){\\n        boolean temp[]=new boolean[52];\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)>=97)\\n                temp[s.charAt(i)-97]=true;\\n            else\\n                temp[s.charAt(i)-39]=true;\\n                \\n        }\\n        for(int i=0;i<26;i++){\\n            if(temp[i])\\n            {  \\n                if(!temp[i+26])\\n                    return false;\\n            }\\n            if(temp[i+26])\\n                if(!temp[i])\\n                    return false;\\n            \\n            \\n            \\n        }\\n        return true;\\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n    public String longestNiceSubstring(String s) {\\n        String result=\"\";\\n        for(int i=0;i<s.length();i++){\\n            for(int j=i;j<s.length();j++)\\n            {\\n                String temp=s.substring(i,j+1);\\n                if(isnice(temp)){\\n                    if(result.length()<temp.length())\\n                        result=temp;\\n                }\\n            }\\n        }\\n        return result;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    \\n    \\n    boolean isnice(String s){\\n        boolean temp[]=new boolean[52];\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)>=97)\\n                temp[s.charAt(i)-97]=true;\\n            else\\n                temp[s.charAt(i)-39]=true;\\n                \\n        }\\n        for(int i=0;i<26;i++){\\n            if(temp[i])\\n            {  \\n                if(!temp[i+26])\\n                    return false;\\n            }\\n            if(temp[i+26])\\n                if(!temp[i])\\n                    return false;\\n            \\n            \\n            \\n        }\\n        return true;\\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n    public String longestNiceSubstring(String s) {\\n        String result=\"\";\\n        for(int i=0;i<s.length();i++){\\n            for(int j=i;j<s.length();j++)\\n            {\\n                String temp=s.substring(i,j+1);\\n                if(isnice(temp)){\\n                    if(result.length()<temp.length())\\n                        result=temp;\\n                }\\n            }\\n        }\\n        return result;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515286,
                "title": "swift-with-recursion-solved-after-4-5-hours-and-its-not-easy",
                "content": "```\\nclass Solution {\\n    func longestNiceSubstring(_ s: String) -> String {\\n        \\n        var result = [s]\\n        var prevResult = [String]()\\n        \\n        func recursion(arrays: [String]) -> String{\\n\\n            if arrays.count == 0 {\\n                return \"\"\\n            }\\n\\n            if prevResult == arrays {\\n                var answer = \"\"\\n                for each in prevResult {\\n                    if each.count > answer.count {\\n                        answer = each\\n                    }\\n                }\\n                return answer\\n            } else {\\n                prevResult = result\\n                result = []\\n            }\\n\\n            arrays.forEach{\\n\\n                let setOfString = Set($0)\\n                var stopChars = \"\"\\n                setOfString.forEach{\\n\\n                    if $0.isLowercase && !setOfString.contains(Character($0.uppercased())) {\\n                        stopChars.append($0)\\n                    } else if $0.isUppercase && !setOfString.contains(Character($0.lowercased())) {\\n                        stopChars.append($0)\\n                    }\\n                }\\n\\n                var newString = $0\\n                stopChars.forEach{\\n                    newString = newString.replacingOccurrences(of: String($0), with: \" \")\\n                }\\n\\n                result += newString.split(separator: \" \").map { String($0) }\\n            }\\n\\n            return recursion(arrays: result)\\n        }\\n\\n        return recursion(arrays: result)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func longestNiceSubstring(_ s: String) -> String {\\n        \\n        var result = [s]\\n        var prevResult = [String]()\\n        \\n        func recursion(arrays: [String]) -> String{\\n\\n            if arrays.count == 0 {\\n                return \"\"\\n            }\\n\\n            if prevResult == arrays {\\n                var answer = \"\"\\n                for each in prevResult {\\n                    if each.count > answer.count {\\n                        answer = each\\n                    }\\n                }\\n                return answer\\n            } else {\\n                prevResult = result\\n                result = []\\n            }\\n\\n            arrays.forEach{\\n\\n                let setOfString = Set($0)\\n                var stopChars = \"\"\\n                setOfString.forEach{\\n\\n                    if $0.isLowercase && !setOfString.contains(Character($0.uppercased())) {\\n                        stopChars.append($0)\\n                    } else if $0.isUppercase && !setOfString.contains(Character($0.lowercased())) {\\n                        stopChars.append($0)\\n                    }\\n                }\\n\\n                var newString = $0\\n                stopChars.forEach{\\n                    newString = newString.replacingOccurrences(of: String($0), with: \" \")\\n                }\\n\\n                result += newString.split(separator: \" \").map { String($0) }\\n            }\\n\\n            return recursion(arrays: result)\\n        }\\n\\n        return recursion(arrays: result)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508291,
                "title": "c-ez-solution-divide-and-conquer",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        if(s.length()<2){\\n            return \"\";\\n            \\n        }\\n        set<char> aux;\\n        for(char c:s)\\n            aux.insert(c);\\n        for(int i =0;i<s.length();i++){\\n            char c = s[i];\\n            if(aux.find(tolower(c)) == aux.end() || aux.find(toupper(c)) == aux.end()){\\n                string left = longestNiceSubstring(s.substr(0,i));\\n                string right = longestNiceSubstring(s.substr(i+1));\\n                \\n                if(left.length()>=right.length()){\\n                    return left;\\n                }\\n                else\\n                    return right;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        if(s.length()<2){\\n            return \"\";\\n            \\n        }\\n        set<char> aux;\\n        for(char c:s)\\n            aux.insert(c);\\n        for(int i =0;i<s.length();i++){\\n            char c = s[i];\\n            if(aux.find(tolower(c)) == aux.end() || aux.find(toupper(c)) == aux.end()){\\n                string left = longestNiceSubstring(s.substr(0,i));\\n                string right = longestNiceSubstring(s.substr(i+1));\\n                \\n                if(left.length()>=right.length()){\\n                    return left;\\n                }\\n                else\\n                    return right;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1483994,
                "title": "python-solution",
                "content": "```\\n\\t\\tdef iB(k:str):\\n            l1=[]\\n            l2=[]\\n            for i in range(len(k)):\\n                if ord(k[i])<97:\\n                    l1.append(ord(k[i]))\\n                else:\\n                    l2.append(ord(k[i]))\\n            for i in l2:\\n                if i-32 not in l1:\\n                    return False\\n            for i in l1:\\n                if i+32 not in l2:\\n                    return False\\n            return True\\n        for k in range(len(s),1,-1):\\n            i=0\\n            j=k\\n            while j!=len(s)+1:\\n                if iB(s[i:j]):\\n                    return s[i:j]\\n                i+=1\\n                j+=1\\n        return \"\"\\n```\\n\\n1. What does iB function(from the code) do? l1 list contains all the uppercase letters occuring in a particular string. Similarly, l2 contains all the lowercase letters. Iterate l1 and check if the corresponding lowercase letter is present in l2 or not. If not return False . If every correspoding letter is present , do the vice versa of above. If no new letter occurs,return True\\n2. Program Code: Applied sliding window to all the subsequences( subsequence size starting from len(string) to 2)",
                "solutionTags": [],
                "code": "```\\n\\t\\tdef iB(k:str):\\n            l1=[]\\n            l2=[]\\n            for i in range(len(k)):\\n                if ord(k[i])<97:\\n                    l1.append(ord(k[i]))\\n                else:\\n                    l2.append(ord(k[i]))\\n            for i in l2:\\n                if i-32 not in l1:\\n                    return False\\n            for i in l1:\\n                if i+32 not in l2:\\n                    return False\\n            return True\\n        for k in range(len(s),1,-1):\\n            i=0\\n            j=k\\n            while j!=len(s)+1:\\n                if iB(s[i:j]):\\n                    return s[i:j]\\n                i+=1\\n                j+=1\\n        return \"\"\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1201996,
                "title": "c-brute-force-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool f(string &s){\\n        int A[26]={0},B[26]={0};\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i]>=\\'a\\' && s[i]<=\\'z\\') A[s[i]-\\'a\\']++;\\n            else B[s[i]-\\'A\\']++;\\n        }\\n        for(int i=0;i<26;i++) {\\n            if(A[i]!=0 && B[i]==0) return false;\\n            if(B[i]!=0 && A[i]==0) return false;\\n        }\\n        return true;\\n    }\\n    string longestNiceSubstring(string s) {\\n        int i,j,n=s.size(),maxi=-1,val;\\n        string ss,ans;\\n        for(i=0;i<n;i++){\\n            for(j=1;j<=n-i;j++){\\n                ss=s.substr(i,j);\\n                if(f(ss)) {\\n                    val=ss.size();\\n                    if(maxi < val){\\n                        maxi=ss.size();\\n                        ans=ss;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(string &s){\\n        int A[26]={0},B[26]={0};\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i]>=\\'a\\' && s[i]<=\\'z\\') A[s[i]-\\'a\\']++;\\n            else B[s[i]-\\'A\\']++;\\n        }\\n        for(int i=0;i<26;i++) {\\n            if(A[i]!=0 && B[i]==0) return false;\\n            if(B[i]!=0 && A[i]==0) return false;\\n        }\\n        return true;\\n    }\\n    string longestNiceSubstring(string s) {\\n        int i,j,n=s.size(),maxi=-1,val;\\n        string ss,ans;\\n        for(i=0;i<n;i++){\\n            for(j=1;j<=n-i;j++){\\n                ss=s.substr(i,j);\\n                if(f(ss)) {\\n                    val=ss.size();\\n                    if(maxi < val){\\n                        maxi=ss.size();\\n                        ans=ss;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201976,
                "title": "python-brute-force-o-n-2-solution",
                "content": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        longest = \"\"\\n        for i in range(len(s)-1):            \\n            seen = set()\\n            unmatched = set()            \\n            for j in range(i, len(s)):\\n                if s[j] not in seen:\\n                    seen.add(s[j])\\n\\n                    if s[j].swapcase() in unmatched:\\n                        unmatched.remove(s[j].swapcase())\\n                    else:\\n                        unmatched.add(s[j])\\n                    \\n                if len(unmatched) == 0 and j-i+1 > len(longest):\\n                    longest = s[i:j+1]\\n                    \\n        return longest\\n```\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        longest = \"\"\\n        for i in range(len(s)-1):            \\n            seen = set()\\n            unmatched = set()            \\n            for j in range(i, len(s)):\\n                if s[j] not in seen:\\n                    seen.add(s[j])\\n\\n                    if s[j].swapcase() in unmatched:\\n                        unmatched.remove(s[j].swapcase())\\n                    else:\\n                        unmatched.add(s[j])\\n                    \\n                if len(unmatched) == 0 and j-i+1 > len(longest):\\n                    longest = s[i:j+1]\\n                    \\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190092,
                "title": "python3-divide-and-conquer",
                "content": "```python\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n\\n        def dp(i, j):\\n            if i > j:\\n                return \\'\\'\\n            count = set(list(s[i:j+1]))\\n            for k,c in enumerate(s[i:j+1]):\\n                if not (c.upper() in count and c.lower() in count):\\n                    break\\n            else:\\n                return s[i:j+1]\\n            return max([dp(i, i + k - 1), dp(i + k + 1, j)], key=len)\\n        \\n        n = len(s)\\n        return dp(0, n - 1)\\n ```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n\\n        def dp(i, j):\\n            if i > j:\\n                return \\'\\'\\n            count = set(list(s[i:j+1]))\\n            for k,c in enumerate(s[i:j+1]):\\n                if not (c.upper() in count and c.lower() in count):\\n                    break\\n            else:\\n                return s[i:j+1]\\n            return max([dp(i, i + k - 1), dp(i + k + 1, j)], key=len)\\n        \\n        n = len(s)\\n        return dp(0, n - 1)\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1104615,
                "title": "python3-simple-solution-using-brute-force-approach",
                "content": "```\\ndef x(t):\\n    z = t.swapcase()\\n    t = list(t)\\n    z = list(z)\\n    for c in t:\\n        if c not in z:\\n            return False\\n    return True\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        b = \"\"\\n        for i in range(len(s)):\\n            for j in range(i+1,len(s)):\\n                a = s[i:j+1]\\n                if x(a) and len(a) > len(b):\\n                    b = a\\n        return b\\n```\\n**If you like the solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef x(t):\\n    z = t.swapcase()\\n    t = list(t)\\n    z = list(z)\\n    for c in t:\\n        if c not in z:\\n            return False\\n    return True\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        b = \"\"\\n        for i in range(len(s)):\\n            for j in range(i+1,len(s)):\\n                a = s[i:j+1]\\n                if x(a) and len(a) > len(b):\\n                    b = a\\n        return b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074630,
                "title": "python3-simple-and-clean-brute-force",
                "content": "```\\ndef isNice(ss):\\n    ss_ = ss.swapcase()\\n    ss = list(ss)\\n    ss_ = list(ss_)\\n    for c in ss:\\n        if c not in ss_:\\n            return False\\n    return True\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        res = \"\"\\n        for i in range(len(s)):\\n            for j in range(i+1,len(s)):\\n                temp = s[i:j+1]\\n                if isNice(temp) and len(temp) > len(res):\\n                    res = temp\\n        return res\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef isNice(ss):\\n    ss_ = ss.swapcase()\\n    ss = list(ss)\\n    ss_ = list(ss_)\\n    for c in ss:\\n        if c not in ss_:\\n            return False\\n    return True\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        res = \"\"\\n        for i in range(len(s)):\\n            for j in range(i+1,len(s)):\\n                temp = s[i:j+1]\\n                if isNice(temp) and len(temp) > len(res):\\n                    res = temp\\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 3794333,
                "title": "beats-100-faster-c-easy-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nbool check(string s){\\n    for(int i=0; i<s.size(); i++){\\n        if(islower(s[i])){\\n            char big=toupper(s[i]);\\n            if(find(s.begin(),s.end(),big)==s.end()){\\n                return 0;\\n            }\\n        }\\n        else{\\n            char small=tolower(s[i]);\\n            if(find(s.begin(),s.end(),small)==s.end()){\\n                return 0;\\n            }\\n        }\\n    }\\n    return 1;\\n}\\n\\nstring longestNiceSubstring(string s) {\\n    if(s.size()==1) return \"\";    \\n    int maxlen=0;\\n    string ans=\"\";\\n    for(int i=0; i<s.size(); i++){\\n        string s1=\"\";\\n        for(int j=i+1; j<s.size(); j++){\\n            s1=s.substr(i,j-i+1);\\n            if(check(s1)){\\n                if(s1.size()>maxlen){\\n                    ans=s1;\\n                    maxlen=s1.size();\\n                }\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nbool check(string s){\\n    for(int i=0; i<s.size(); i++){\\n        if(islower(s[i])){\\n            char big=toupper(s[i]);\\n            if(find(s.begin(),s.end(),big)==s.end()){\\n                return 0;\\n            }\\n        }\\n        else{\\n            char small=tolower(s[i]);\\n            if(find(s.begin(),s.end(),small)==s.end()){\\n                return 0;\\n            }\\n        }\\n    }\\n    return 1;\\n}\\n\\nstring longestNiceSubstring(string s) {\\n    if(s.size()==1) return \"\";    \\n    int maxlen=0;\\n    string ans=\"\";\\n    for(int i=0; i<s.size(); i++){\\n        string s1=\"\";\\n        for(int j=i+1; j<s.size(); j++){\\n            s1=s.substr(i,j-i+1);\\n            if(check(s1)){\\n                if(s1.size()>maxlen){\\n                    ans=s1;\\n                    maxlen=s1.size();\\n                }\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759174,
                "title": "python3-brute-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestNiceSubstring(self, a: str) -> str:\\n      #  a=\"wWOExoVhvXebB\"\\n        l=0\\n        h=len(a)-1\\n        g=0\\n        h=[]\\n        y=0\\n        k=[]\\n        for i in range(len(a)):\\n            for j in range(len(a)):\\n                b=a[i:len(a)-j]\\n                for i in range(len(b)):\\n                    if b[i].upper()in b and b[i].lower()in b:\\n                        g=g+1\\n                if g==len(b) and b!=\"\":\\n                    k.append(b)\\n                g=0\\n        u=0\\n        j=[]\\n        for i in range(len(k)-1):\\n            if len(k[i])==len(k[i+1]):\\n                u=u+1\\n        if u==len(k)-1 and len(k)>1:\\n            for i in range(len(k)):\\n                c=a.find(k[i])\\n                j.append([c,k[i]])\\n            g=[100,\"a\"]\\n            for i in range(len(j)):\\n                if j[i][0]<g[0]:\\n                    g=j[i]\\n            return(g[1])\\n        else:\\n            p=\"\"\\n            max_=-inf\\n            for i in range(len(k)):\\n                if len(k[i])>max_:\\n                    max_=len(k[i])\\n                    p=k[i]\\n            return(p)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubstring(self, a: str) -> str:\\n      #  a=\"wWOExoVhvXebB\"\\n        l=0\\n        h=len(a)-1\\n        g=0\\n        h=[]\\n        y=0\\n        k=[]\\n        for i in range(len(a)):\\n            for j in range(len(a)):\\n                b=a[i:len(a)-j]\\n                for i in range(len(b)):\\n                    if b[i].upper()in b and b[i].lower()in b:\\n                        g=g+1\\n                if g==len(b) and b!=\"\":\\n                    k.append(b)\\n                g=0\\n        u=0\\n        j=[]\\n        for i in range(len(k)-1):\\n            if len(k[i])==len(k[i+1]):\\n                u=u+1\\n        if u==len(k)-1 and len(k)>1:\\n            for i in range(len(k)):\\n                c=a.find(k[i])\\n                j.append([c,k[i]])\\n            g=[100,\"a\"]\\n            for i in range(len(j)):\\n                if j[i][0]<g[0]:\\n                    g=j[i]\\n            return(g[1])\\n        else:\\n            p=\"\"\\n            max_=-inf\\n            for i in range(len(k)):\\n                if len(k[i])>max_:\\n                    max_=len(k[i])\\n                    p=k[i]\\n            return(p)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554456,
                "title": "c-took-advantage-of-multiple-functions-by-fun2s",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n bool find(string s,char c){\\n     for(int i=0;i<s.size();i++){\\n         if(s[i]==c+32 || s[i]==c-32)return true;\\n         \\n     }\\n     return false;\\n }\\n bool nice(string s){\\n     for(int i=0;i<s.size();i++){\\n         if(!find(s,s[i]))return false;\\n         \\n     }\\n     return true;\\n\\n }\\n    string longestNiceSubstring(string s) {\\n        int n=s.size();\\n        string ans=\"\";\\n        for(int i=0;i<n;i++){\\n            for(int j=2;j<=n;j++){\\n                if(nice(s.substr(i,j))){\\n                    string k=s.substr(i,j);\\n                    if(ans.size()<k.size())ans=k;\\n                };\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n bool find(string s,char c){\\n     for(int i=0;i<s.size();i++){\\n         if(s[i]==c+32 || s[i]==c-32)return true;\\n         \\n     }\\n     return false;\\n }\\n bool nice(string s){\\n     for(int i=0;i<s.size();i++){\\n         if(!find(s,s[i]))return false;\\n         \\n     }\\n     return true;\\n\\n }\\n    string longestNiceSubstring(string s) {\\n        int n=s.size();\\n        string ans=\"\";\\n        for(int i=0;i<n;i++){\\n            for(int j=2;j<=n;j++){\\n                if(nice(s.substr(i,j))){\\n                    string k=s.substr(i,j);\\n                    if(ans.size()<k.size())ans=k;\\n                };\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472203,
                "title": "c-accepted-detail-explain",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     string isnice(string str){\\n     map<int,bool>map;\\n     //create a map to track the all letter if letter is persent so we can put true in map\\n  \\n     for(int i=0;i<str.length();i++){\\n            int p = str[i];//its a method to get the ascii value of any charachter \\n\\n\\n             map[p]=true;\\n     }\\n\\n     for(int i=0;i<str.length();i++){\\n         int q=str[i];//its a method to get the ascii value of any charachter \\n         if(isupper(str[i])){\\n           //if letter is uppercase then we wil check for its lowercae letter from map ascii value of any lowercase letter is 32 more then ascii value of the uppercase letter\\n          \\n             int z=q+32;\\n             if(!(map[z])){\\n                if(str.length()<=1){\\n                    return \"\";\\n                }\\n                    // if asci valueof uppercaseletter=32 is not persent in the map we divide the string in two parts and call the function for both of them whichever gives the large length\\n                string susbtr1  = str.substr(0,i);  \\n                 string susbtr2  = str.substr(i+1,str.length());  \\n                 string ans1 =isnice(susbtr1);\\n                 string ans2 =isnice(susbtr2);\\n                 if(ans1.length()>=ans2.length()){\\n                     map.clear();\\n                        return ans1;\\n                 }\\n                 else{\\n                         map.clear();\\n                        return ans2;\\n                 }\\n             }\\n         }\\n        \\n         else{\\n              int z=q-32;\\n             if(!(map[z])){\\n                 if(str.length()<=1){\\n                    return \"\";\\n                }\\n\\n                string susbtr1  = str.substr(0,i);  \\n                string susbtr2  = str.substr(i+1,str.length());  \\n                 string ans1 =isnice(susbtr1);\\n                 string ans2 =isnice(susbtr2);\\n                 if(ans1.length()>=ans2.length()){\\n                        map.clear();\\n                        return ans1;\\n                 }\\n                 else{\\n                        map.clear();\\n                        return ans2;\\n                 }\\n             }\\n          }       \\n         }\\n\\n      return str;\\n     }\\n\\n    string longestNiceSubstring(string s) {\\n \\n     return isnice(s);    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     string isnice(string str){\\n     map<int,bool>map;\\n     //create a map to track the all letter if letter is persent so we can put true in map\\n  \\n     for(int i=0;i<str.length();i++){\\n            int p = str[i];//its a method to get the ascii value of any charachter \\n\\n\\n             map[p]=true;\\n     }\\n\\n     for(int i=0;i<str.length();i++){\\n         int q=str[i];//its a method to get the ascii value of any charachter \\n         if(isupper(str[i])){\\n           //if letter is uppercase then we wil check for its lowercae letter from map ascii value of any lowercase letter is 32 more then ascii value of the uppercase letter\\n          \\n             int z=q+32;\\n             if(!(map[z])){\\n                if(str.length()<=1){\\n                    return \"\";\\n                }\\n                    // if asci valueof uppercaseletter=32 is not persent in the map we divide the string in two parts and call the function for both of them whichever gives the large length\\n                string susbtr1  = str.substr(0,i);  \\n                 string susbtr2  = str.substr(i+1,str.length());  \\n                 string ans1 =isnice(susbtr1);\\n                 string ans2 =isnice(susbtr2);\\n                 if(ans1.length()>=ans2.length()){\\n                     map.clear();\\n                        return ans1;\\n                 }\\n                 else{\\n                         map.clear();\\n                        return ans2;\\n                 }\\n             }\\n         }\\n        \\n         else{\\n              int z=q-32;\\n             if(!(map[z])){\\n                 if(str.length()<=1){\\n                    return \"\";\\n                }\\n\\n                string susbtr1  = str.substr(0,i);  \\n                string susbtr2  = str.substr(i+1,str.length());  \\n                 string ans1 =isnice(susbtr1);\\n                 string ans2 =isnice(susbtr2);\\n                 if(ans1.length()>=ans2.length()){\\n                        map.clear();\\n                        return ans1;\\n                 }\\n                 else{\\n                        map.clear();\\n                        return ans2;\\n                 }\\n             }\\n          }       \\n         }\\n\\n      return str;\\n     }\\n\\n    string longestNiceSubstring(string s) {\\n \\n     return isnice(s);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258936,
                "title": "java-solution-explained-approach-using-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks to find the longest substring in the given string s which satisfies the given criteria of having all characters of both uppercase and lowercase letters. The brute force approach would be to generate all possible substrings of the given string and check if each substring is \"nice\" or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can solve this problem by iterating through all possible substrings of the given string, and checking each substring to see if it\\'s \"nice\" or not. We keep track of the maximum length of the \"nice\" substring found so far and return it in the end.\\n\\nTo check if a substring is \"nice\", we can create two boolean arrays - one for lowercase letters and one for uppercase letters. We iterate through each character in the substring, and if it\\'s a lowercase letter we set the corresponding index in the lowercase array to true, and if it\\'s an uppercase letter we set the corresponding index in the uppercase array to true. Finally, we iterate through both arrays and check if the value at each index is the same in both arrays. If it\\'s not, we return false, otherwise we return true.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the given solution is O(n^3) where n is the length of the input string s. This is because we are generating all possible substrings of s, and each substring can take up to O(n) time to check if it\\'s \"nice\".\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the given solution is O(n) where n is the length of the input string s. This is because we are creating two boolean arrays of size 26 each to store whether a letter is present or not.\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        int maxLength = 0;\\n        String result = \"\";\\n        for(int i = 0 ; i < s.length(); i++)\\n        {\\n            for(int j = i + 1 ; j <= s.length(); j++)\\n            {\\n                String substring = s.substring(i,j);\\n                if(isNice(substring) && substring.length() > maxLength)\\n                {\\n                    maxLength = substring.length();\\n                    result = substring;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public boolean isNice(String s)\\n    {\\n        boolean[] lowercase = new boolean[26];\\n        boolean[] uppercase = new boolean[26];\\n\\n        for(char c : s.toCharArray())\\n        {\\n            if(Character.isLowerCase(c))\\n            {\\n                lowercase[c - \\'a\\'] = true;\\n            }\\n            else if(Character.isUpperCase(c))\\n            {\\n                uppercase[c - \\'A\\'] = true;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < 26 ; i++)\\n        {\\n            if(lowercase[i] != uppercase[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        int maxLength = 0;\\n        String result = \"\";\\n        for(int i = 0 ; i < s.length(); i++)\\n        {\\n            for(int j = i + 1 ; j <= s.length(); j++)\\n            {\\n                String substring = s.substring(i,j);\\n                if(isNice(substring) && substring.length() > maxLength)\\n                {\\n                    maxLength = substring.length();\\n                    result = substring;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public boolean isNice(String s)\\n    {\\n        boolean[] lowercase = new boolean[26];\\n        boolean[] uppercase = new boolean[26];\\n\\n        for(char c : s.toCharArray())\\n        {\\n            if(Character.isLowerCase(c))\\n            {\\n                lowercase[c - \\'a\\'] = true;\\n            }\\n            else if(Character.isUpperCase(c))\\n            {\\n                uppercase[c - \\'A\\'] = true;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < 26 ; i++)\\n        {\\n            if(lowercase[i] != uppercase[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090579,
                "title": "simple-and-easy-to-understand-without-recursion",
                "content": "# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nconst longestNiceSubstring = function (s) {\\n  const isNice = function (str) {\\n    const set = [...new Set(str)].join(\\'\\');\\n    return set.length == new Set(set.toLowerCase()).size * 2;\\n  }\\n  let len = s.length, ans = \\'\\';\\n  for (let i = 2; i <= len; i++) {\\n    let [l, r] = [0, i];\\n    while (r <= len) {\\n      let currSubstr = s.slice(l, r);\\n      if (isNice(currSubstr) && r - l > ans.length) {\\n        ans = currSubstr;\\n      }\\n      l++; r++;\\n    }\\n  }\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nconst longestNiceSubstring = function (s) {\\n  const isNice = function (str) {\\n    const set = [...new Set(str)].join(\\'\\');\\n    return set.length == new Set(set.toLowerCase()).size * 2;\\n  }\\n  let len = s.length, ans = \\'\\';\\n  for (let i = 2; i <= len; i++) {\\n    let [l, r] = [0, i];\\n    while (r <= len) {\\n      let currSubstr = s.slice(l, r);\\n      if (isNice(currSubstr) && r - l > ans.length) {\\n        ans = currSubstr;\\n      }\\n      l++; r++;\\n    }\\n  }\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3038617,
                "title": "cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        string ans;\\n        for(int i=0;i<s.size()-1;i++){\\n            int h=s.size();\\n            int l=i;\\n            string k;\\n            while(h-l>0){\\n                bool ansbool=true;\\n                k=s.substr(l,h-l);\\n                unordered_set<char> st(k.begin(),k.end());\\n                for(auto val:st){\\n                    int x=(int(val)-32);\\n                    int y=(int(val)+32);\\n                    if(int(val)>=97 && int(val)<=122){\\n                        if(!(st.find(char(x))!=st.end())){\\n                            ansbool=false;\\n                            break;\\n                        }\\n                    }\\n                    if(int(val)>=65 && int(val)<=90){\\n                        if(!(st.find(char(y))!=st.end())){   \\n                            ansbool=false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(ansbool==false){\\n                    h--;\\n                    k.clear();\\n                    continue;\\n                }\\n                if(ansbool==true && ans.size()<k.size()){\\n                    ans=k;\\n                    k.clear();\\n                    break;\\n                }\\n                h--;\\n            }\\n        }  \\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        string ans;\\n        for(int i=0;i<s.size()-1;i++){\\n            int h=s.size();\\n            int l=i;\\n            string k;\\n            while(h-l>0){\\n                bool ansbool=true;\\n                k=s.substr(l,h-l);\\n                unordered_set<char> st(k.begin(),k.end());\\n                for(auto val:st){\\n                    int x=(int(val)-32);\\n                    int y=(int(val)+32);\\n                    if(int(val)>=97 && int(val)<=122){\\n                        if(!(st.find(char(x))!=st.end())){\\n                            ansbool=false;\\n                            break;\\n                        }\\n                    }\\n                    if(int(val)>=65 && int(val)<=90){\\n                        if(!(st.find(char(y))!=st.end())){   \\n                            ansbool=false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(ansbool==false){\\n                    h--;\\n                    k.clear();\\n                    continue;\\n                }\\n                if(ansbool==true && ans.size()<k.size()){\\n                    ans=k;\\n                    k.clear();\\n                    break;\\n                }\\n                h--;\\n            }\\n        }  \\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970821,
                "title": "cpp-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        string mx;\\n       for(int i=0;i<s.size();i++){\\n           for(int j=1;j+i<=s.size();j++){\\n               string st=s.substr(i,j);\\n               cout<<st<<endl;\\n               \\n               bool dis=true;\\n               for(char c:st){\\n                   if(islower(c)){\\n                       if(st.find(toupper(c))==-1){\\n                           dis=false;\\n                           break;\\n\\n                       }\\n                       \\n                   }\\n                   else if(st.find(tolower(c))==-1){\\n                       dis=false;\\n                           break;\\n                   }\\n               }\\n               if(dis){\\n                  if(st.size()>mx.size())mx=st;\\n               }\\n           }\\n       }\\n    return mx;}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        string mx;\\n       for(int i=0;i<s.size();i++){\\n           for(int j=1;j+i<=s.size();j++){\\n               string st=s.substr(i,j);\\n               cout<<st<<endl;\\n               \\n               bool dis=true;\\n               for(char c:st){\\n                   if(islower(c)){\\n                       if(st.find(toupper(c))==-1){\\n                           dis=false;\\n                           break;\\n\\n                       }\\n                       \\n                   }\\n                   else if(st.find(tolower(c))==-1){\\n                       dis=false;\\n                           break;\\n                   }\\n               }\\n               if(dis){\\n                  if(st.size()>mx.size())mx=st;\\n               }\\n           }\\n       }\\n    return mx;}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2939671,
                "title": "c-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecursion\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public string LongestNiceSubstring(string s) {\\n        return DFS(s);\\n    }\\n\\n    private string DFS(string s)\\n    {\\n        HashSet<char> hsSet = new HashSet<char>(s);\\n        if(s.Length < 2)\\n            return \"\";\\n        \\n        for(int i=0; i< s.Length; i++)\\n        {\\n            if( !hsSet.Contains(char.ToLower(s[i])) || !hsSet.Contains(char.ToUpper(s[i])))\\n            {\\n                string str1 = DFS(s.Substring(0,i));\\n                string str2 = DFS(s.Substring(i+1, s.Length-i-1));\\n                return str2.Length > str1.Length ? str2 : str1;\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    public string LongestNiceSubstring(string s) {\\n        return DFS(s);\\n    }\\n\\n    private string DFS(string s)\\n    {\\n        HashSet<char> hsSet = new HashSet<char>(s);\\n        if(s.Length < 2)\\n            return \"\";\\n        \\n        for(int i=0; i< s.Length; i++)\\n        {\\n            if( !hsSet.Contains(char.ToLower(s[i])) || !hsSet.Contains(char.ToUpper(s[i])))\\n            {\\n                string str1 = DFS(s.Substring(0,i));\\n                string str2 = DFS(s.Substring(i+1, s.Length-i-1));\\n                return str2.Length > str1.Length ? str2 : str1;\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700576,
                "title": "javascript-the-straightforward-easy-way-99-51-faster",
                "content": "```\\nvar longestNiceSubstring = function(s) {\\n    let a = \\'a\\'.charCodeAt(0), A = \\'A\\'.charCodeAt(0);\\n    var maxset, has, ones, twos;\\n    var i, l, c;\\n    let maxlen = 0, maxstr=\"\";\\n    \\n    for( l=0; l<s.length; l++ ) { // shiftable left pointer\\n\\n        has = new Array(26).fill(0);\\n        ones = twos = 0;\\n        maxset = false;\\n        for( i=l; i<s.length; i++ ) { // find longest working trace in this sector\\n            c = s.charCodeAt(i);\\n\\n            if( c >= a ) { // found lowercase\\n                if( has[c-a] == 0 ) {\\n                    has[c-a] = 1;\\n                    ones++;\\n                } else if( has[c-a] == 2 ) {\\n                    has[c-a] = 3;\\n                    twos--;\\n                }\\n            } else {\\n                if( has[c-A] == 0 ) {\\n                    has[c-A] = 2;\\n                    twos++;\\n                } else if( has[c-A] == 1 ) {\\n                    has[c-A] = 3;\\n                    ones--;\\n                }\\n            }\\n\\n            if( ones == 0 && twos == 0 ) {\\n                if( i+1-l > maxlen ) {\\n                    maxlen = i+1-l;\\n                    maxset = true;\\n                }\\n            }\\n        }\\n        \\n        if( maxset )\\n            maxstr = s.substr(l,maxlen);\\n    }\\n    \\n    return maxstr;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar longestNiceSubstring = function(s) {\\n    let a = \\'a\\'.charCodeAt(0), A = \\'A\\'.charCodeAt(0);\\n    var maxset, has, ones, twos;\\n    var i, l, c;\\n    let maxlen = 0, maxstr=\"\";\\n    \\n    for( l=0; l<s.length; l++ ) { // shiftable left pointer\\n\\n        has = new Array(26).fill(0);\\n        ones = twos = 0;\\n        maxset = false;\\n        for( i=l; i<s.length; i++ ) { // find longest working trace in this sector\\n            c = s.charCodeAt(i);\\n\\n            if( c >= a ) { // found lowercase\\n                if( has[c-a] == 0 ) {\\n                    has[c-a] = 1;\\n                    ones++;\\n                } else if( has[c-a] == 2 ) {\\n                    has[c-a] = 3;\\n                    twos--;\\n                }\\n            } else {\\n                if( has[c-A] == 0 ) {\\n                    has[c-A] = 2;\\n                    twos++;\\n                } else if( has[c-A] == 1 ) {\\n                    has[c-A] = 3;\\n                    ones--;\\n                }\\n            }\\n\\n            if( ones == 0 && twos == 0 ) {\\n                if( i+1-l > maxlen ) {\\n                    maxlen = i+1-l;\\n                    maxset = true;\\n                }\\n            }\\n        }\\n        \\n        if( maxset )\\n            maxstr = s.substr(l,maxlen);\\n    }\\n    \\n    return maxstr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2662769,
                "title": "c-simple-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) \\n    {\\n     \\n        return fun(s);\\n    }\\n    string fun(string str)\\n    {\\n\\t\\n        if(str.length()<=1)\\n        return \"\";\\n\\n        unordered_set<char>st;\\n        st.insert(str.begin(),str.end());\\n\\n        for(int i=0;i<str.length();i++)\\n        {\\n            char ch=str[i];\\n\\n            char temp1=toupper(ch);\\n            char temp2=tolower(ch);\\n\\n            if(st.find(temp1)==st.end() or st.find(temp2)==st.end())\\n            {\\n                //the counter part of the ith char is missing can never be in the substring\\n                string left = fun(str.substr(0,i));\\n                string right = fun(str.substr(i+1,str.length()));\\n\\n                if(left.length()==right.length())\\n                {\\n                    return left;\\n                }\\n                else if(left.length()>right.length())\\n                {\\n                    return left;\\n                }\\n                else\\n                {\\n                    return right;\\n                }\\n            }\\n        }\\n        return str;\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) \\n    {\\n     \\n        return fun(s);\\n    }\\n    string fun(string str)\\n    {\\n\\t\\n        if(str.length()<=1)\\n        return \"\";\\n\\n        unordered_set<char>st;\\n        st.insert(str.begin(),str.end());\\n\\n        for(int i=0;i<str.length();i++)\\n        {\\n            char ch=str[i];\\n\\n            char temp1=toupper(ch);\\n            char temp2=tolower(ch);\\n\\n            if(st.find(temp1)==st.end() or st.find(temp2)==st.end())\\n            {\\n                //the counter part of the ith char is missing can never be in the substring\\n                string left = fun(str.substr(0,i));\\n                string right = fun(str.substr(i+1,str.length()));\\n\\n                if(left.length()==right.length())\\n                {\\n                    return left;\\n                }\\n                else if(left.length()>right.length())\\n                {\\n                    return left;\\n                }\\n                else\\n                {\\n                    return right;\\n                }\\n            }\\n        }\\n        return str;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2624175,
                "title": "python3-sliding-window",
                "content": "Check if string inside the current window range is **NICE**\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        \\n        niceSubstr = \"\"\\n        \\n        for windowEnd in range(len(s)):\\n            \\n            for windowStart in range(windowEnd+1):\\n                \\n                substr = s[windowStart:windowEnd+1]\\n                \\n\\n                if self.isNice(substr):\\n                    niceSubstr = max(niceSubstr, substr, key=len)\\n        \\n        return niceSubstr\\n        \\n    \\n    \\n    def isNice(self, substr):\\n        \\n        charFreq = Counter(\"\".join(set(substr)))\\n        \\n        \\n        for key in charFreq:\\n            validChar = key.upper() in charFreq and key.lower() in charFreq\\n            \\n            if not validChar:\\n                return False\\n        \\n        return True\\n                \\n                \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        \\n        niceSubstr = \"\"\\n        \\n        for windowEnd in range(len(s)):\\n            \\n            for windowStart in range(windowEnd+1):\\n                \\n                substr = s[windowStart:windowEnd+1]\\n                \\n\\n                if self.isNice(substr):\\n                    niceSubstr = max(niceSubstr, substr, key=len)\\n        \\n        return niceSubstr\\n        \\n    \\n    \\n    def isNice(self, substr):\\n        \\n        charFreq = Counter(\"\".join(set(substr)))\\n        \\n        \\n        for key in charFreq:\\n            validChar = key.upper() in charFreq and key.lower() in charFreq\\n            \\n            if not validChar:\\n                return False\\n        \\n        return True\\n                \\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2566483,
                "title": "easy-naive-solution",
                "content": "```\\n/*\\nSimple Naive solution checking all substrings and checking if it is nice or not if yes, then updating the res\\n*/\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        int maxLength = 0;\\n        String res = \"\";\\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            for(int j = i+1;j<=s.length();j++)\\n            {\\n                String subString = s.substring(i,j);\\n                if(IsNiceString(subString))\\n                {\\n                    if(subString.length() > maxLength)\\n                    {\\n                        maxLength = subString.length();\\n                        res = subString;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public boolean IsNiceString(String s)\\n    {\\n        for(int i=0;i<s.length();i++)\\n        {\\n            char c = s.charAt(i);\\n            char ch = Character.isLowerCase(c)?       \\n                Character.toUpperCase(c):Character.toLowerCase(c);\\n            if(!s.contains(Character.toString(ch)))\\n                return false;                     \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nSimple Naive solution checking all substrings and checking if it is nice or not if yes, then updating the res\\n*/\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        int maxLength = 0;\\n        String res = \"\";\\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            for(int j = i+1;j<=s.length();j++)\\n            {\\n                String subString = s.substring(i,j);\\n                if(IsNiceString(subString))\\n                {\\n                    if(subString.length() > maxLength)\\n                    {\\n                        maxLength = subString.length();\\n                        res = subString;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public boolean IsNiceString(String s)\\n    {\\n        for(int i=0;i<s.length();i++)\\n        {\\n            char c = s.charAt(i);\\n            char ch = Character.isLowerCase(c)?       \\n                Character.toUpperCase(c):Character.toLowerCase(c);\\n            if(!s.contains(Character.toString(ch)))\\n                return false;                     \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545986,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\n    bool helper(string res)\\n    {\\n        for(int i=0;i<res.length();i++)\\n        {\\n            char x=res[i];\\n            if(x<=90)x+=32;\\n            else x-=32;\\n            if(res.find(x)==string::npos)return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    string longestNiceSubstring(string s) {\\n        string ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            string res=\"\";\\n            res+=s[i];\\n            for(int j=i+1;j<s.length();j++)\\n            {\\n                res+=s[j];\\n                if(helper(res) && res.size()>ans.size())ans=res;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    bool helper(string res)\\n    {\\n        for(int i=0;i<res.length();i++)\\n        {\\n            char x=res[i];\\n            if(x<=90)x+=32;\\n            else x-=32;\\n            if(res.find(x)==string::npos)return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    string longestNiceSubstring(string s) {\\n        string ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            string res=\"\";\\n            res+=s[i];\\n            for(int j=i+1;j<s.length();j++)\\n            {\\n                res+=s[j];\\n                if(helper(res) && res.size()>ans.size())ans=res;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406927,
                "title": "c-easy-solution",
                "content": "\\tpublic class Solution {\\n\\t\\tpublic string LongestNiceSubstring(string s) {\\n\\t\\t\\tint n = s.Length;\\n\\t\\t\\tvar str = string.Empty;\\n\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\tint xor1 = 0, xor2 = 0;\\n\\t\\t\\t\\tfor (int j = i; j < n; j++) {\\n\\t\\t\\t\\t\\tif(s[j] >= \\'a\\' && s[j] <= \\'z\\')\\n\\t\\t\\t\\t\\t\\t\\txor1 |= (1 << (s[j] - \\'a\\'));\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\txor2 |= (1 << (s[j] - \\'A\\'));\\n\\n\\t\\t\\t\\t\\tif((xor1 ^ xor2) == 0 && (j - i + 1) > str.Length)\\n\\t\\t\\t\\t\\t\\tstr = s.Substring(i, j - i + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn str;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\t\\tpublic string LongestNiceSubstring(string s) {\\n\\t\\t\\tint n = s.Length;\\n\\t\\t\\tvar str = string.Empty;\\n\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\tint xor1 = 0, xor2 = 0;\\n\\t\\t\\t\\tfor (int j = i; j < n; j++) {\\n\\t\\t\\t\\t\\tif(s[j] >= \\'a\\' && s[j] <= \\'z\\')\\n\\t\\t\\t\\t\\t\\t\\txor1 |= (1 << (s[j] - \\'a\\'));\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\txor2 |= (1 << (s[j] - \\'A\\'));\\n\\n\\t\\t\\t\\t\\tif((xor1 ^ xor2) == 0 && (j - i + 1) > str.Length)\\n\\t\\t\\t\\t\\t\\tstr = s.Substring(i, j - i + 1);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2346879,
                "title": "python-recursive-solution-faster-than-95-explained",
                "content": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n\\t# We create a hmap with all the unique chars in the string\\n\\t# as sson as we meet a char that doesn\\'t exist as both upper and lower case in the hmap\\n\\t# we split the string into two strings(we remove the char). We repeat the operation \\n\\t# untill we hit a single char string or we have a nice String.\\n\\t# When we\\'ll have a nice string, it will end up returning the entire string without spliting it.\\n        if len(s) < 2:\\n            return \"\"\\n        s_map = Counter(s)\\n        for i in range(len(s)):\\n            if s[i] not in s_map or s[i].swapcase() not in s_map:\\n                substr1 = self.longestNiceSubstring(s[:i])\\n                substr2 = self.longestNiceSubstring(s[i+1:])\\n                return substr1 if len(substr1) >= len(substr2) else substr2\\n        return s\\n\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n\\t# We create a hmap with all the unique chars in the string\\n\\t# as sson as we meet a char that doesn\\'t exist as both upper and lower case in the hmap\\n\\t# we split the string into two strings(we remove the char). We repeat the operation \\n\\t# untill we hit a single char string or we have a nice String.\\n\\t# When we\\'ll have a nice string, it will end up returning the entire string without spliting it.\\n        if len(s) < 2:\\n            return \"\"\\n        s_map = Counter(s)\\n        for i in range(len(s)):\\n            if s[i] not in s_map or s[i].swapcase() not in s_map:\\n                substr1 = self.longestNiceSubstring(s[:i])\\n                substr2 = self.longestNiceSubstring(s[i+1:])\\n                return substr1 if len(substr1) >= len(substr2) else substr2\\n        return s\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2302615,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n          StringBuilder sb1 =new StringBuilder();\\n          int max=0;        \\n          String ans=\"\";\\n          for(int i=0;i<s.length();i++)\\n          {\\n              sb1=new StringBuilder();\\n              for(int j=i;j<s.length();j++)\\n              {\\n                  sb1.append(s.charAt(j));\\n                  if(checkIt(sb1.toString().toCharArray()))\\n                  {\\n                       if(sb1.length()>max)\\n                       {\\n                           max=sb1.length();\\n                           ans=sb1.toString();\\n                       }\\n                  }                                      \\n              }\\n          }\\n        \\n        return ans;\\n    }\\n    public boolean checkIt(char []arr1)\\n    {\\n        int []count =new int[256];\\n        for(int i=0;i<arr1.length;i++)\\n        {\\n            count[arr1[i]]++;\\n        }\\n        for(int i=65;i<=90;i++)\\n        {\\n            if(count[i]!=0&&count[(i+32)]==0)\\n            {\\n                return false;\\n            }\\n            else if(count[i]==0&&count[(i+32)]!=0)\\n            {\\n                return false;\\n            }            \\n        }\\n        \\n        return true;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public String longestNiceSubstring(String s) {\\n          StringBuilder sb1 =new StringBuilder();\\n          int max=0;        \\n          String ans=\"\";\\n          for(int i=0;i<s.length();i++)\\n          {\\n              sb1=new StringBuilder();\\n              for(int j=i;j<s.length();j++)\\n              {\\n                  sb1.append(s.charAt(j));\\n                  if(checkIt(sb1.toString().toCharArray()))\\n                  {\\n                       if(sb1.length()>max)\\n                       {\\n                           max=sb1.length();\\n                           ans=sb1.toString();\\n                       }",
                "codeTag": "Java"
            },
            {
                "id": 2268809,
                "title": "simple-brute-force-code",
                "content": "```\\nclass Solution {\\n    typedef int ll;\\n    typedef pair<ll, ll> pi;\\n#define vi(x) vector<x>\\n#define pb push_back\\n    const ll mod = 1e9 + 7;\\n    const char nl = \\'\\\\n\\';\\npublic:\\n    void check(string& res, string& s) {\\n        ll szs = s.length(), szr = res.length();\\n        if (szs <= szr)\\n            return;\\n        unordered_set<char>ust;\\n        for (char ch : s)\\n            ust.insert(ch);\\n        for (char ch : s) {\\n            if (ch >= \\'a\\' && ust.find(\\'A\\' + ch - \\'a\\') == ust.end())\\n                return;\\n            if (ch <= \\'Z\\' && ust.find(\\'a\\' + ch - \\'A\\') == ust.end())\\n                return;\\n        }\\n        res = s;\\n    }\\n    string longestNiceSubstring(string& s) {\\n        string res;\\n        for (ll i = 0;i < s.length();++i) {\\n            string tmp;\\n            for (ll j = i;j < s.length();++j) {\\n                tmp.pb(s[j]);\\n                check(res, tmp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    typedef int ll;\\n    typedef pair<ll, ll> pi;\\n#define vi(x) vector<x>\\n#define pb push_back\\n    const ll mod = 1e9 + 7;\\n    const char nl = \\'\\\\n\\';\\npublic:\\n    void check(string& res, string& s) {\\n        ll szs = s.length(), szr = res.length();\\n        if (szs <= szr)\\n            return;\\n        unordered_set<char>ust;\\n        for (char ch : s)\\n            ust.insert(ch);\\n        for (char ch : s) {\\n            if (ch >= \\'a\\' && ust.find(\\'A\\' + ch - \\'a\\') == ust.end())\\n                return;\\n            if (ch <= \\'Z\\' && ust.find(\\'a\\' + ch - \\'A\\') == ust.end())\\n                return;\\n        }\\n        res = s;\\n    }\\n    string longestNiceSubstring(string& s) {\\n        string res;\\n        for (ll i = 0;i < s.length();++i) {\\n            string tmp;\\n            for (ll j = i;j < s.length();++j) {\\n                tmp.pb(s[j]);\\n                check(res, tmp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2216900,
                "title": "short-and-clean-code-c-recursion",
                "content": "\\n\\t\\t// we first find the character whose corresponding smaller char(or vice-versa) is not \\n\\t\\t// present in the given string\\n\\t\\t// Once found then we provide first and second half of the string to recursion\\n\\t\\t\\n\\t\\tset<char> st;\\n        for(auto i : s){st.insert(i);}\\n        for(int i = 0; i<s.size(); i++)\\n        {\\n            if(st.count(toupper(s[i])) && st.count(tolower(s[i]))) continue;\\n            \\n            string fst_hlf = longestNiceSubstring(s.substr(0,i));\\n            string snd_hlf = longestNiceSubstring(s.substr(i+1));\\n            \\n            return (fst_hlf.size() >= snd_hlf.size()) ? fst_hlf : snd_hlf;\\n        }\\n\\t\\t// If every iteration is continued that means complete string is a nice\\n\\t\\t// thus we return the complete string\\n        return s;\\n        \\n    //  \\uD83D\\uDE0C \\uD83D\\uDE0C \\uD83D\\uDE0CPlease upvote if you understood the logic and explanation \\uD83D\\uDE0C \\uD83D\\uDE0C \\uD83D\\uDE0C",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "\\n\\t\\t// we first find the character whose corresponding smaller char(or vice-versa) is not \\n\\t\\t// present in the given string\\n\\t\\t// Once found then we provide first and second half of the string to recursion\\n\\t\\t\\n\\t\\tset<char> st;\\n        for(auto i : s){st.insert(i);}\\n        for(int i = 0; i<s.size(); i++)\\n        {\\n            if(st.count(toupper(s[i])) && st.count(tolower(s[i]))) continue;\\n            \\n            string fst_hlf = longestNiceSubstring(s.substr(0,i));\\n            string snd_hlf = longestNiceSubstring(s.substr(i+1));\\n            \\n            return (fst_hlf.size() >= snd_hlf.size()) ? fst_hlf : snd_hlf;\\n        }\\n\\t\\t// If every iteration is continued that means complete string is a nice\\n\\t\\t// thus we return the complete string\\n        return s;\\n        \\n    //  \\uD83D\\uDE0C \\uD83D\\uDE0C \\uD83D\\uDE0CPlease upvote if you understood the logic and explanation \\uD83D\\uDE0C \\uD83D\\uDE0C \\uD83D\\uDE0C",
                "codeTag": "Unknown"
            },
            {
                "id": 2210140,
                "title": "c-brute-force-soluton",
                "content": "class Solution {\\npublic:\\n    bool check(string s)\\n    {\\n        int cf[26]={0},sf[26]={0};\\n        for(auto i:s)\\n        {\\n            if(i>=\\'a\\' && i<=\\'z\\')\\n                sf[i-\\'a\\']++;\\n            else\\n                cf[i-\\'A\\']++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if( (sf[i]==0 && cf[i]!=0) || (cf[i]==0 && sf[i]!=0) )\\n                return false;\\n        }\\n        return true;\\n    }\\n    string longestNiceSubstring(string s) {\\n        string res;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            for(int j=2;j<=s.size()-i;j++)\\n            {\\n                string t=s.substr(i,j);\\n                //cout<<t<<endl;\\n                if(check(t))\\n                {\\n                    if(res.size()<t.size())\\n                        res=t;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool check(string s)\\n    {\\n        int cf[26]={0}",
                "codeTag": "Java"
            },
            {
                "id": 2186042,
                "title": "1763-longest-nice-substring-c-divide-conquer",
                "content": "**Calculate prefix sum of counts of both uppercase and lowercase then try to find existence of alter character in the range**\\n###**Upvote**### If you Like my solution, comment if you have any doubt or suggestion :)\\n```\\n#define vvi vector<vector<int>>\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        int n = s.length();\\n        vvi cntu(n+1,vector<int>(26,0)); //cntu[i][j] => count of j\\'th uppercase character in [0->i]\\n        vvi cntl(n+1,vector<int>(26,0));//cntu[i][j] => count of j\\'th lowercase character in [0->i]\\n        for(int i=0;i<n;i++){\\n            cntl[i+1]=cntl[i];\\n            cntu[i+1]=cntu[i];\\n            if(s[i]&32){//check for lowercase [ obv: lowercase letter have setbit in 6th position from right]\\n                int inx = s[i]-\\'a\\';\\n                cntl[i+1][inx]++;\\n            }else{\\n                int inx = s[i]-\\'A\\';\\n                cntu[i+1][inx]++;\\n            }\\n        }\\n        return helper(s,0,n-1,cntl,cntu);\\n    }\\n    string helper(string &str,int s,int e, vvi& cntl, vvi& cntu){\\n        if(s > e) return \"\";\\n        for(int i=s;i<=e;i++){\\n            int inx = 0;\\n            int c = 0;\\n            if(str[i]&32){ //if cur character is lowercase then check if it\\'s uppercase is present in that range or not\\n                inx = str[i]-\\'a\\';\\n                c = cntu[e+1][inx]-cntu[s][inx];\\n            }else{\\n                inx = str[i]-\\'A\\';\\n                c = cntl[e+1][inx]-cntl[s][inx];\\n            }\\n            if(c==0){ //if the alter character is absent then result either in left part or in right part\\n                string left=helper(str,s,i-1,cntl,cntu);\\n                string right=helper(str,i+1,e,cntl,cntu);\\n                if(left.length() < right.length()) return right;\\n                return left;\\n            }\\n        }\\n        return str.substr(s,e-s+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Divide and Conquer",
                    "Prefix Sum"
                ],
                "code": "```\\n#define vvi vector<vector<int>>\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        int n = s.length();\\n        vvi cntu(n+1,vector<int>(26,0)); //cntu[i][j] => count of j\\'th uppercase character in [0->i]\\n        vvi cntl(n+1,vector<int>(26,0));//cntu[i][j] => count of j\\'th lowercase character in [0->i]\\n        for(int i=0;i<n;i++){\\n            cntl[i+1]=cntl[i];\\n            cntu[i+1]=cntu[i];\\n            if(s[i]&32){//check for lowercase [ obv: lowercase letter have setbit in 6th position from right]\\n                int inx = s[i]-\\'a\\';\\n                cntl[i+1][inx]++;\\n            }else{\\n                int inx = s[i]-\\'A\\';\\n                cntu[i+1][inx]++;\\n            }\\n        }\\n        return helper(s,0,n-1,cntl,cntu);\\n    }\\n    string helper(string &str,int s,int e, vvi& cntl, vvi& cntu){\\n        if(s > e) return \"\";\\n        for(int i=s;i<=e;i++){\\n            int inx = 0;\\n            int c = 0;\\n            if(str[i]&32){ //if cur character is lowercase then check if it\\'s uppercase is present in that range or not\\n                inx = str[i]-\\'a\\';\\n                c = cntu[e+1][inx]-cntu[s][inx];\\n            }else{\\n                inx = str[i]-\\'A\\';\\n                c = cntl[e+1][inx]-cntl[s][inx];\\n            }\\n            if(c==0){ //if the alter character is absent then result either in left part or in right part\\n                string left=helper(str,s,i-1,cntl,cntu);\\n                string right=helper(str,i+1,e,cntl,cntu);\\n                if(left.length() < right.length()) return right;\\n                return left;\\n            }\\n        }\\n        return str.substr(s,e-s+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176662,
                "title": "doubt-regarding-my-code",
                "content": "Can anyone please help me by answering why this code ain\\'t working for all test cases, and what changes I must do with this code to get  it done right.\\nI wanted to specifically know how can I proceed with this approach\\nPlease if anyone can answer it will help me a lot, trying for so long to fix it\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool check(string s,char ch){\\n      map<char,int>mp;\\n        for(auto it: s){\\n            mp[it]++;\\n        }\\n        if(ch>=65 && ch<=90){\\n            if(mp[ch+32]>0) return true;\\n        }\\n        else if(ch>=97 && ch<=122){\\n            if(mp[ch-32]>0) return true;\\n        }\\n        return false;\\n    }\\n    string longestNiceSubstring(string s) {\\n      string ans=\"\";\\n      int i=0,j=1;\\n        while(j<s.size()){\\n            if(check(s.substr(i,s.size()),s[j])) {   \\n               string temp=s.substr(i,j-i+1);\\n                j++;\\n                if(ans.size()<temp.size()) ans=temp;\\n                \\n            }\\n           if(!check(s.substr(i,s.size()),s[j])){\\n                for(int k=0;i<ans.size();k++){\\n                if(!check(ans,ans[k])){\\n                    ans.erase(ans.begin()+k,ans.end());\\n                   }\\n                 }\\n               \\n            }\\n            if(!check(s.substr(i,s.size()),s[j])){\\n                 i=j+1;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string s,char ch){\\n      map<char,int>mp;\\n        for(auto it: s){\\n            mp[it]++;\\n        }\\n        if(ch>=65 && ch<=90){\\n            if(mp[ch+32]>0) return true;\\n        }\\n        else if(ch>=97 && ch<=122){\\n            if(mp[ch-32]>0) return true;\\n        }\\n        return false;\\n    }\\n    string longestNiceSubstring(string s) {\\n      string ans=\"\";\\n      int i=0,j=1;\\n        while(j<s.size()){\\n            if(check(s.substr(i,s.size()),s[j])) {   \\n               string temp=s.substr(i,j-i+1);\\n                j++;\\n                if(ans.size()<temp.size()) ans=temp;\\n                \\n            }\\n           if(!check(s.substr(i,s.size()),s[j])){\\n                for(int k=0;i<ans.size();k++){\\n                if(!check(ans,ans[k])){\\n                    ans.erase(ans.begin()+k,ans.end());\\n                   }\\n                 }\\n               \\n            }\\n            if(!check(s.substr(i,s.size()),s[j])){\\n                 i=j+1;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2103179,
                "title": "c-solution-divide-conquer-sets",
                "content": "**Code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    string longestNiceSubstring(string s)\\n    {\\n        if (s.size() < 2)\\n            return \"\";\\n        unordered_set<char> st(begin(s), end(s));\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (st.find((char)toupper(s[i])) == end(st) || st.find((char)tolower(s[i])) == end(st))\\n            {\\n                string s1 = longestNiceSubstring(s.substr(0, i));\\n                string s2 = longestNiceSubstring(s.substr(i + 1));\\n                return s1.size() >= s2.size() ? s1 : s2;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    string longestNiceSubstring(string s)\\n    {\\n        if (s.size() < 2)\\n            return \"\";\\n        unordered_set<char> st(begin(s), end(s));\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (st.find((char)toupper(s[i])) == end(st) || st.find((char)tolower(s[i])) == end(st))\\n            {\\n                string s1 = longestNiceSubstring(s.substr(0, i));\\n                string s2 = longestNiceSubstring(s.substr(i + 1));\\n                return s1.size() >= s2.size() ? s1 : s2;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063940,
                "title": "simple-java-dfs-memorization-with-explanation",
                "content": "The idea is simple: use Set to check if curr char has its couterpart in the set. If not, break the string into left and right substring. Then, continue find the \"nice substring\" in the left and right. There is a repeated work e.g. \"aAaz\", \"aAa\" is evaluated twice, so use memo to cache previous work.\\n```\\nclass Solution {\\n    String s;\\n    String[][] memo;\\n    public String longestNiceSubstring(String s) {\\n        this.s = s;\\n        int n = s.length();\\n        memo = new String[n][n];\\n        \\n        return dfs(0, s.length() -1);\\n    }\\n    \\n    private String dfs(int i, int j) {\\n        if(i >= j) {\\n            return \"\";\\n        }\\n        \\n        if(memo[i][j] != null) {\\n            return memo[i][j];\\n        }\\n        \\n        Set<Character> set = new HashSet<>();\\n        for(int k = i; k <= j; k++) {\\n            set.add(s.charAt(k));\\n        }\\n        \\n        String left = \"\";\\n        String right = \"\";\\n        boolean isValid = true;\\n        int k = i;\\n        for(; k <= j; k++) {\\n            char c = s.charAt(k);\\n            if(Character.isLowerCase(c)) {\\n                if(!set.contains(Character.toUpperCase(c))) {\\n                    isValid = false;\\n                    break;\\n                }\\n            } else {\\n                if(!set.contains(Character.toLowerCase(c))) {\\n                    isValid = false;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if(isValid) {\\n            memo[i][j] = s.substring(i, j + 1);\\n        } else {\\n            left = dfs(i, k - 1);\\n            right = dfs(k + 1, j);\\n            memo[i][j] = left.length() >= right.length() ? left : right;\\n        }\\n        return memo[i][j];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    String s;\\n    String[][] memo;\\n    public String longestNiceSubstring(String s) {\\n        this.s = s;\\n        int n = s.length();\\n        memo = new String[n][n];\\n        \\n        return dfs(0, s.length() -1);\\n    }\\n    \\n    private String dfs(int i, int j) {\\n        if(i >= j) {\\n            return \"\";\\n        }\\n        \\n        if(memo[i][j] != null) {\\n            return memo[i][j];\\n        }\\n        \\n        Set<Character> set = new HashSet<>();\\n        for(int k = i; k <= j; k++) {\\n            set.add(s.charAt(k));\\n        }\\n        \\n        String left = \"\";\\n        String right = \"\";\\n        boolean isValid = true;\\n        int k = i;\\n        for(; k <= j; k++) {\\n            char c = s.charAt(k);\\n            if(Character.isLowerCase(c)) {\\n                if(!set.contains(Character.toUpperCase(c))) {\\n                    isValid = false;\\n                    break;\\n                }\\n            } else {\\n                if(!set.contains(Character.toLowerCase(c))) {\\n                    isValid = false;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if(isValid) {\\n            memo[i][j] = s.substring(i, j + 1);\\n        } else {\\n            left = dfs(i, k - 1);\\n            right = dfs(k + 1, j);\\n            memo[i][j] = left.length() >= right.length() ? left : right;\\n        }\\n        return memo[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928188,
                "title": "easy-c-solution",
                "content": "**Brute Force**\\n```\\nclass Solution {\\n    bool ifnice(string str, int s, int e){\\n        set<int> ele;\\n        for(int i=s;i<=e;++i) ele.insert(str[i]);\\n        for(auto a:ele){\\n            if(a<91 and ele.count(a+32)==0) return false;\\n            else if(a>96 and ele.count(a-32)==0) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    string longestNiceSubstring(string s) {\\n        int ans=0;\\n        string result;\\n        for(int i=0;i<s.size();++i)\\n            for(int j=i;j<s.size();++j)\\n                if(ifnice(s,i,j) and (j-i+1)>ans){\\n                        ans = j-i+1;\\n                        result = s.substr(i,ans);\\n                    }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    bool ifnice(string str, int s, int e){\\n        set<int> ele;\\n        for(int i=s;i<=e;++i) ele.insert(str[i]);\\n        for(auto a:ele){\\n            if(a<91 and ele.count(a+32)==0) return false;\\n            else if(a>96 and ele.count(a-32)==0) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    string longestNiceSubstring(string s) {\\n        int ans=0;\\n        string result;\\n        for(int i=0;i<s.size();++i)\\n            for(int j=i;j<s.size();++j)\\n                if(ifnice(s,i,j) and (j-i+1)>ans){\\n                        ans = j-i+1;\\n                        result = s.substr(i,ans);\\n                    }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901599,
                "title": "python-easy-o-n3",
                "content": "```python\\nclass Solution:\\n    def is_nice(self, s: str) -> bool:\\n        mask = 0\\n        for ch in s:\\n            mask |= 1 << ord(ch)\\n        mask >>= 65\\n        diff = ord(\\'a\\') - ord(\\'A\\')\\n        for i in range(diff):\\n            if ((mask & 1) ^ ((mask >> diff) & 1)):\\n                return False\\n            mask >>= 1\\n        return True\\n    \\n    def longestNiceSubstring(self, s: str) -> str:\\n        mx = -1\\n        res = \"\"\\n        for i in range(len(s) - 1):\\n            for j in range(i + 1, len(s) + 1):\\n                sub = s[i:j]\\n                if self.is_nice(sub) and len(sub) > mx:\\n                    mx = len(sub)\\n                    res = sub\\n        return res\\n        \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def is_nice(self, s: str) -> bool:\\n        mask = 0\\n        for ch in s:\\n            mask |= 1 << ord(ch)\\n        mask >>= 65\\n        diff = ord(\\'a\\') - ord(\\'A\\')\\n        for i in range(diff):\\n            if ((mask & 1) ^ ((mask >> diff) & 1)):\\n                return False\\n            mask >>= 1\\n        return True\\n    \\n    def longestNiceSubstring(self, s: str) -> str:\\n        mx = -1\\n        res = \"\"\\n        for i in range(len(s) - 1):\\n            for j in range(i + 1, len(s) + 1):\\n                sub = s[i:j]\\n                if self.is_nice(sub) and len(sub) > mx:\\n                    mx = len(sub)\\n                    res = sub\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821928,
                "title": "python-divide-and-conquer-solution-easy",
                "content": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        \\n        # Edge case\\n        if len(s) < 2:\\n            return \"\"\\n        \\n        nice = \"\"           # Store the longest nice substring\\n        unique = set(s)     # Store all unique letters\\n        \\n        for i in range(len(s)):\\n            \\n            if s[i].lower() in s and s[i].upper() in s:\\n                nice += s[i]\\n            else:\\n                leftPart = self.longestNiceSubstring(s[:i])\\n                rightPart = self.longestNiceSubstring(s[i+1:])\\n                \\n                return leftPart if len(leftPart) >= len(rightPart) else rightPart \\n                \\n        return nice\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        \\n        # Edge case\\n        if len(s) < 2:\\n            return \"\"\\n        \\n        nice = \"\"           # Store the longest nice substring\\n        unique = set(s)     # Store all unique letters\\n        \\n        for i in range(len(s)):\\n            \\n            if s[i].lower() in s and s[i].upper() in s:\\n                nice += s[i]\\n            else:\\n                leftPart = self.longestNiceSubstring(s[:i])\\n                rightPart = self.longestNiceSubstring(s[i+1:])\\n                \\n                return leftPart if len(leftPart) >= len(rightPart) else rightPart \\n                \\n        return nice\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804292,
                "title": "swift-sliding-window-o-n",
                "content": "Here\\'s a Swift verison that is O(N) time and O(1) space. Not as fast as other submissions, but saves more space than 50% of the submissions. Essentially, it grows a window until it has reached the end. Then, it will move the start of the window forward and start again a new window search until it reaches the end, repeat. \\n\\nIt can actually be made more efficient if we immediately store the next currentGreatest size substring after we have moved the start of the window forward. This will avoid unnecessary windows.\\n\\n```\\nfunc longestNiceSubstring(_ s: String) -> String {\\n    var windowStart = 0\\n    var windowEnd = 0\\n    var substring = \"\"\\n    var currentGreatest = 0\\n    var validStart = 0\\n    var validEnd = 0\\n\\n    while windowStart < (s.count - currentGreatest + 1) {\\n        let endChar = s[s.index(s.startIndex, offsetBy: windowEnd)]\\n        substring += String(endChar)\\n\\n        if isNiceString(substring) && substring.count > currentGreatest {\\n            validStart = windowStart\\n            validEnd = windowEnd\\n            currentGreatest = substring.count\\n        }\\n\\t\\t\\n        windowEnd += 1\\n        \\n        if windowEnd == s.count {\\n            windowStart += 1\\n            if s.count - windowStart <= currentGreatest { break }\\n\\n            windowEnd = windowStart\\n            substring = \"\"\\n        }\\n    }\\n    \\n    if (validEnd - validStart + 1) < 2 { return \"\" }\\n    \\n    let startIndex = s.index(s.startIndex, offsetBy: validStart)\\n    let endIndex = s.index(s.startIndex, offsetBy: validEnd)\\n    return String(s[startIndex...endIndex])\\n}\\n\\nprivate func isNiceString(_ str: String) -> Bool {\\n    return Double(Set(str.lowercased()).count) == (Double(Set(str).count) / 2.0)\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Sliding Window"
                ],
                "code": "```\\nfunc longestNiceSubstring(_ s: String) -> String {\\n    var windowStart = 0\\n    var windowEnd = 0\\n    var substring = \"\"\\n    var currentGreatest = 0\\n    var validStart = 0\\n    var validEnd = 0\\n\\n    while windowStart < (s.count - currentGreatest + 1) {\\n        let endChar = s[s.index(s.startIndex, offsetBy: windowEnd)]\\n        substring += String(endChar)\\n\\n        if isNiceString(substring) && substring.count > currentGreatest {\\n            validStart = windowStart\\n            validEnd = windowEnd\\n            currentGreatest = substring.count\\n        }\\n\\t\\t\\n        windowEnd += 1\\n        \\n        if windowEnd == s.count {\\n            windowStart += 1\\n            if s.count - windowStart <= currentGreatest { break }\\n\\n            windowEnd = windowStart\\n            substring = \"\"\\n        }\\n    }\\n    \\n    if (validEnd - validStart + 1) < 2 { return \"\" }\\n    \\n    let startIndex = s.index(s.startIndex, offsetBy: validStart)\\n    let endIndex = s.index(s.startIndex, offsetBy: validEnd)\\n    return String(s[startIndex...endIndex])\\n}\\n\\nprivate func isNiceString(_ str: String) -> Bool {\\n    return Double(Set(str.lowercased()).count) == (Double(Set(str).count) / 2.0)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1784405,
                "title": "scala-beats-100-recursive-divide-and-conquer",
                "content": "```\\n        def longestNiceSubstring(s: String): String = {\\n            val chars = s.toArray.toSet\\n            val diff = \\'a\\' - \\'A\\'\\n            for (i <- 0 until s.length) {\\n                val contain =  \\n                     if (s(i) < \\'a\\') chars.contains((s(i) + diff).toChar)\\n                     else chars.contains((s(i) - diff).toChar)\\n                            \\n                if (!contain) {\\n                    val s1 = longestNiceSubstring(s.substring(0, i))\\n                    val s2 = longestNiceSubstring(s.substring(i + 1))\\n                    if (s1.length >= s2.length) return s1 else return s2\\n                }\\n            }\\n            return s\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        def longestNiceSubstring(s: String): String = {\\n            val chars = s.toArray.toSet\\n            val diff = \\'a\\' - \\'A\\'\\n            for (i <- 0 until s.length) {\\n                val contain =  \\n                     if (s(i) < \\'a\\') chars.contains((s(i) + diff).toChar)\\n                     else chars.contains((s(i) - diff).toChar)\\n                            \\n                if (!contain) {\\n                    val s1 = longestNiceSubstring(s.substring(0, i))\\n                    val s2 = longestNiceSubstring(s.substring(i + 1))\\n                    if (s1.length >= s2.length) return s1 else return s2\\n                }\\n            }\\n            return s\\n        }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1733140,
                "title": "c-windowed-approach-using-unpaired-elements-as-window-ends-and-start-points",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string longestNiceSubstring(string s) {\\n        int arr1[26]={};\\n        int arr2[26]={};\\n        if(s.length()<2)\\n            return \"\";\\n        for(char ch:s)\\n        {\\n            if(ch>=\\'A\\' && ch<=\\'Z\\')\\n                arr1[(ch|32)-\\'a\\']++;\\n            else\\n                arr2[ch-\\'a\\']++;\\n        }\\n        vector<int> index;\\n        index.push_back(-1);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if((arr1[(s[i]|32)-\\'a\\']>=1 && arr2[(s[i]|32)-\\'a\\']==0) || (arr1[(s[i]|32)-\\'a\\']==0 && arr2[(s[i]|32)-\\'a\\']>=1))\\n                index.push_back(i);\\n        }\\n        //index.push_back(2);\\n        index.push_back(s.length());\\n        if(index.size()==2)\\n            return s;\\n        string minn=\"\";\\n        for(int i=0;i<index.size()-1;i++)\\n        {\\n            string temp = longestNiceSubstring(s.substr(index[i]+1,index[i+1]-index[i]-1));\\n            minn = temp.length()>minn.length()?temp:minn;\\n        }\\n        return minn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string longestNiceSubstring(string s) {\\n        int arr1[26]={};\\n        int arr2[26]={};\\n        if(s.length()<2)\\n            return \"\";\\n        for(char ch:s)\\n        {\\n            if(ch>=\\'A\\' && ch<=\\'Z\\')\\n                arr1[(ch|32)-\\'a\\']++;\\n            else\\n                arr2[ch-\\'a\\']++;\\n        }\\n        vector<int> index;\\n        index.push_back(-1);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if((arr1[(s[i]|32)-\\'a\\']>=1 && arr2[(s[i]|32)-\\'a\\']==0) || (arr1[(s[i]|32)-\\'a\\']==0 && arr2[(s[i]|32)-\\'a\\']>=1))\\n                index.push_back(i);\\n        }\\n        //index.push_back(2);\\n        index.push_back(s.length());\\n        if(index.size()==2)\\n            return s;\\n        string minn=\"\";\\n        for(int i=0;i<index.size()-1;i++)\\n        {\\n            string temp = longestNiceSubstring(s.substr(index[i]+1,index[i+1]-index[i]-1));\\n            minn = temp.length()>minn.length()?temp:minn;\\n        }\\n        return minn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1696978,
                "title": "c-using-xor-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        string longest = \"\";\\n            for(int i=0;i<s.length();i++){\\n\\t\\t\\t//as the string length must be min 2 to have both upper and lower case alphabets i started taking j = 2\\n                    for(int j = 2;j<=s.length();j++){\\n                            string sub = s.substr(i,j);\\n                            if(helper(sub)){\\n                                    if(sub.length()>longest.length())\\n                                           longest = sub;\\n                            }\\n                    }\\n            }\\n            return longest;\\n    }\\n    bool helper(string s){\\n           int lower=0,upper=0;\\n           for(char ch:s){\\n                   if(ch<\\'a\\'){\\n                         lower |= 1<<(ch-\\'A\\');\\n\\t\\t\\t\\t\\t\\t //lower  = lower|1<<(ch-\\'A\\') \\n\\t\\t\\t\\t\\t\\t //if ch is B then lower(0) = lower(0)|1<<(\\'B\\'-\\'A\\')\\n\\t\\t\\t\\t\\t\\t //0|1 = 1 => 1<<1 = ...10\\n                   }\\n                   else\\n                         upper |= 1<<(ch-\\'a\\');\\n           }\\n            return (lower^upper)==0;\\n\\t\\t\\t//if upper and lower have same letters then it returns true\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        string longest = \"\";\\n            for(int i=0;i<s.length();i++){\\n\\t\\t\\t//as the string length must be min 2 to have both upper and lower case alphabets i started taking j = 2\\n                    for(int j = 2;j<=s.length();j++){\\n                            string sub = s.substr(i,j);\\n                            if(helper(sub)){\\n                                    if(sub.length()>longest.length())\\n                                           longest = sub;\\n                            }\\n                    }\\n            }\\n            return longest;\\n    }\\n    bool helper(string s){\\n           int lower=0,upper=0;\\n           for(char ch:s){\\n                   if(ch<\\'a\\'){\\n                         lower |= 1<<(ch-\\'A\\');\\n\\t\\t\\t\\t\\t\\t //lower  = lower|1<<(ch-\\'A\\') \\n\\t\\t\\t\\t\\t\\t //if ch is B then lower(0) = lower(0)|1<<(\\'B\\'-\\'A\\')\\n\\t\\t\\t\\t\\t\\t //0|1 = 1 => 1<<1 = ...10\\n                   }\\n                   else\\n                         upper |= 1<<(ch-\\'a\\');\\n           }\\n            return (lower^upper)==0;\\n\\t\\t\\t//if upper and lower have same letters then it returns true\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620462,
                "title": "java-clean-and-intiutive",
                "content": "```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        int length = s.length();\\n        String maxStr = \"\";\\n        for(int left = 0; left < length; left++){\\n            for(int right = left+1; right < length; right++){\\n              String sub = s.substring(left, right + 1);\\n              if(isNice(sub) && sub.length() > maxStr.length())\\n                  maxStr = sub;\\n            }\\n        }\\n        return maxStr;\\n    }\\n    \\n    private boolean isNice(String str){\\n        Map<Character, Integer> map = new HashMap();\\n        \\n        for(int i = 0; i < str.length(); i++)\\n            map.put(str.charAt(i), map.getOrDefault(str.charAt(i), 0) +1);\\n        \\n        for(Map.Entry<Character,Integer> entry: map.entrySet()){\\n            \\n            if(Character.isLowerCase(entry.getKey()))\\n                if(!map.containsKey(Character.toUpperCase(entry.getKey())))\\n                    return false;\\n            if(!Character.isLowerCase(entry.getKey()))\\n                if(!map.containsKey(Character.toLowerCase(entry.getKey())))\\n                    return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        int length = s.length();\\n        String maxStr = \"\";\\n        for(int left = 0; left < length; left++){\\n            for(int right = left+1; right < length; right++){\\n              String sub = s.substring(left, right + 1);\\n              if(isNice(sub) && sub.length() > maxStr.length())\\n                  maxStr = sub;\\n            }\\n        }\\n        return maxStr;\\n    }\\n    \\n    private boolean isNice(String str){\\n        Map<Character, Integer> map = new HashMap();\\n        \\n        for(int i = 0; i < str.length(); i++)\\n            map.put(str.charAt(i), map.getOrDefault(str.charAt(i), 0) +1);\\n        \\n        for(Map.Entry<Character,Integer> entry: map.entrySet()){\\n            \\n            if(Character.isLowerCase(entry.getKey()))\\n                if(!map.containsKey(Character.toUpperCase(entry.getKey())))\\n                    return false;\\n            if(!Character.isLowerCase(entry.getKey()))\\n                if(!map.containsKey(Character.toLowerCase(entry.getKey())))\\n                    return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1614934,
                "title": "c-solution-time-o-n-2-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string a) {\\n        \\n        int n = a.size(),f,g;\\n        unordered_map<char,int> m;\\n        string ans ;\\n        char h ;\\n        for(int i=0;i<n;i++)\\n        {\\n            f = -1 ;                  // For max length of subsrting for current loop \\n            g=0;                      // For determing substring is nice or not \\n            for(int j=i;j<n;j++)\\n            {\\n                \\n                if(a[j]>92)           //  Opposite case alphabet\\n                    h = a[j]-32;\\n                else\\n                    h = a[j]+32;\\n                if(!m.count(a[j]))                  \\n                {\\n                    if(!m.count(h))   // If opposite case alphabet not present increase g \\n                        g++;\\n                    else              // If opposite case alphabet present decrease g\\n                        g--;\\n                    m[a[j]]++;\\n                }\\n                    \\n                if(g==0)             // If g = 0 means string is nice, update f for length of substring\\n                    f = j;\\n                \\n            }\\n            if(f!=-1&&ans.size()<f-i+1)  \\n            {\\n                ans = a.substr(i,f-i+1); // Updating ans string \\n            }\\n            m.clear();              // Clear map for next loop\\n                \\n        }\\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string a) {\\n        \\n        int n = a.size(),f,g;\\n        unordered_map<char,int> m;\\n        string ans ;\\n        char h ;\\n        for(int i=0;i<n;i++)\\n        {\\n            f = -1 ;                  // For max length of subsrting for current loop \\n            g=0;                      // For determing substring is nice or not \\n            for(int j=i;j<n;j++)\\n            {\\n                \\n                if(a[j]>92)           //  Opposite case alphabet\\n                    h = a[j]-32;\\n                else\\n                    h = a[j]+32;\\n                if(!m.count(a[j]))                  \\n                {\\n                    if(!m.count(h))   // If opposite case alphabet not present increase g \\n                        g++;\\n                    else              // If opposite case alphabet present decrease g\\n                        g--;\\n                    m[a[j]]++;\\n                }\\n                    \\n                if(g==0)             // If g = 0 means string is nice, update f for length of substring\\n                    f = j;\\n                \\n            }\\n            if(f!=-1&&ans.size()<f-i+1)  \\n            {\\n                ans = a.substr(i,f-i+1); // Updating ans string \\n            }\\n            m.clear();              // Clear map for next loop\\n                \\n        }\\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575557,
                "title": "python3-solution-using-sliding-window-and-hashmap",
                "content": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        d={}\\n        alpha=\"qwertyuiopasdfghjklzxcvbnm\"\\n        n=len(s)\\n        res=0\\n        ans=\"\"\\n\\n        for i in range(n):\\n            d={}\\n            for j in range(i,n):\\n                \\n                isSmall=s[j].islower()\\n                x=s[j].lower()\\n                if x not in d:\\n                    d[x]=[0,0]\\n                if isSmall:\\n                    d[x][0]+=1\\n                else:\\n                    d[x][1]+=1\\n                if all(((d[key][0]>0 and d[key][1]>0) or (d[key][0]==d[key][1])) for key in d):\\n                    if j-i+1>res:\\n                        res=j-i+1\\n                        ans=s[i:j+1]\\n        return ans\\n\\t\\t",
                "solutionTags": [],
                "code": "class Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        d={}",
                "codeTag": "Java"
            },
            {
                "id": 1570505,
                "title": "c-solution-in-o-n-2-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        int n = s.length();\\n        string res;\\n        for(int i=0;i<n;i++){\\n            int mismatches = 0;\\n            vector<bool> vec(52,false);\\n            for(int j=i;j<n;j++){\\n                int index = (islower(s[j])) ? s[j]-\\'a\\' : s[j]-\\'A\\'+26;\\n                int otherIndex = index<26 ? index+26 : index-26;\\n                \\n                if(!vec[index]){\\n                    if(vec[otherIndex]) mismatches--;\\n                    else mismatches++;\\n                    vec[index] = true;\\n                }\\n                \\n                if(mismatches==0 && j-i+1>res.length())\\n                    res = s.substr(i,j-i+1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string longestNiceSubstring(string s) {\\n        int n = s.length();\\n        string res;\\n        for(int i=0;i<n;i++){\\n            int mismatches = 0;\\n            vector<bool> vec(52,false);\\n            for(int j=i;j<n;j++){\\n                int index = (islower(s[j])) ? s[j]-\\'a\\' : s[j]-\\'A\\'+26;\\n                int otherIndex = index<26 ? index+26 : index-26;\\n                \\n                if(!vec[index]){\\n                    if(vec[otherIndex]) mismatches--;\\n                    else mismatches++;\\n                    vec[index] = true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1470246,
                "title": "brute-force-with-easy-understanding",
                "content": "\\n\\t\\t\\n\\t\\tdef isnice(substr):#return True or False\\n            hmap={}\\n            for letter in substr:\\n                hmap[letter]=hmap.get(letter,0)+1\\n            for letter in substr:\\n                if letter.isupper():\\n                    if letter.lower() not in hmap:\\n                        return False\\n                elif letter.islower():\\n                    if letter.upper() not in hmap:\\n                        return False\\n            return True\\n        result=\"\"\\n        for i in range(len(s)):\\n            for j in range(i+1,len(s)):\\n                substr=s[i:j+1]\\n                if (isnice(substr)):\\n                    if len(substr) >len(result):\\n                        result=substr\\n        return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\t\\t\\n\\t\\tdef isnice(substr):#return True or False\\n            hmap={}\\n            for letter in substr:\\n                hmap[letter]=hmap.get(letter,0)+1\\n            for letter in substr:\\n                if letter.isupper():\\n                    if letter.lower() not in hmap:\\n                        return False\\n                elif letter.islower():\\n                    if letter.upper() not in hmap:\\n                        return False\\n            return True\\n        result=\"\"\\n        for i in range(len(s)):\\n            for j in range(i+1,len(s)):\\n                substr=s[i:j+1]\\n                if (isnice(substr)):\\n                    if len(substr) >len(result):\\n                        result=substr\\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 1431700,
                "title": "c-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n  std::string longestNiceSubstring(std::string s) {\\n    for (size_t i = 0; i < s.length(); i++) {\\n      int diff = s[i] > \\'Z\\' ? -32 : 32;\\n      if (s.find(s[i] + diff) != s.npos) {\\n        continue;\\n      }\\n\\n      std::string left = longestNiceSubstring(s.substr(0, i));\\n      std::string right = longestNiceSubstring(s.substr(i + 1));\\n\\n      return left.size() >= right.size() ? left : right;\\n    }\\n    return s;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  std::string longestNiceSubstring(std::string s) {\\n    for (size_t i = 0; i < s.length(); i++) {\\n      int diff = s[i] > \\'Z\\' ? -32 : 32;\\n      if (s.find(s[i] + diff) != s.npos) {\\n        continue;\\n      }\\n\\n      std::string left = longestNiceSubstring(s.substr(0, i));\\n      std::string right = longestNiceSubstring(s.substr(i + 1));\\n\\n      return left.size() >= right.size() ? left : right;\\n    }\\n    return s;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1421975,
                "title": "golang-divide-and-conquer-100",
                "content": "I wasn\\'t able to find the solution by my own. I ended up with slow brute force solution.\\nThis one is a golang copy of this perfect solution: https://leetcode.com/problems/longest-nice-substring/discuss/1074589/JavaStraightforward-Divide-and-Conquer\\n\\n```\\nfunc longestNiceSubstring(s string) string {\\n\\tif len(s) < 2 {\\n\\t\\treturn \"\"\\n\\t}\\n\\n\\tchars := make(map[rune]struct{}, 0)\\n\\tfor _, r := range s {\\n\\t\\tchars[r] = struct{}{}\\n\\t}\\n\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tr := rune(s[i])\\n\\t\\t_, u := chars[unicode.ToUpper(r)]\\n\\t\\t_, l := chars[unicode.ToLower(r)]\\n\\t\\tif u && l {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tleft := longestNiceSubstring(s[:i])\\n\\t\\tright := longestNiceSubstring(s[i+1:])\\n\\t\\tif len(left) >= len(right) {\\n\\t\\t\\treturn left\\n\\t\\t} else {\\n\\t\\t\\treturn right\\n\\t\\t}\\n\\t}\\n\\treturn s\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "I wasn\\'t able to find the solution by my own. I ended up with slow brute force solution.\\nThis one is a golang copy of this perfect solution: https://leetcode.com/problems/longest-nice-substring/discuss/1074589/JavaStraightforward-Divide-and-Conquer\\n\\n```\\nfunc longestNiceSubstring(s string) string {\\n\\tif len(s) < 2 {\\n\\t\\treturn \"\"\\n\\t}\\n\\n\\tchars := make(map[rune]struct{}, 0)\\n\\tfor _, r := range s {\\n\\t\\tchars[r] = struct{}{}\\n\\t}\\n\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tr := rune(s[i])\\n\\t\\t_, u := chars[unicode.ToUpper(r)]\\n\\t\\t_, l := chars[unicode.ToLower(r)]\\n\\t\\tif u && l {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tleft := longestNiceSubstring(s[:i])\\n\\t\\tright := longestNiceSubstring(s[i+1:])\\n\\t\\tif len(left) >= len(right) {\\n\\t\\t\\treturn left\\n\\t\\t} else {\\n\\t\\t\\treturn right\\n\\t\\t}\\n\\t}\\n\\treturn s\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1420557,
                "title": "c-divide-and-conquer-using-recursion",
                "content": "In \"YazaAay\", there\\'s a char \\'z\\' that does not have its upper-case counterpart. This \\'z\\' is certainly not going to be part of the longest nice substring. \\nNow the task has become looking for longest nice substrig from the left part\"Ya\" and the right part \"aAay\". \\n\\n```\\npublic class Solution {\\n    public string LongestNiceSubstring(string s) {\\n        \\n        for (int i = 0; i < s.Length; i++) {\\n            char counterPart = Char.IsLower(s[i]) ? Char.ToUpper(s[i]) : Char.ToLower(s[i]);\\n            if (!s.Contains(counterPart)) {\\n                if (i == 0) {\\n                    return LongestNiceSubstring(s.Substring(1, s.Length - 1));\\n                }\\n                if (i == s.Length - 1) {\\n                    return LongestNiceSubstring(s.Substring(0, s.Length - 1));\\n                }\\n                string s1 = LongestNiceSubstring(s.Substring(0, i));\\n                string s2 = LongestNiceSubstring(s.Substring(i + 1, s.Length - i - 1));\\n                return s1.Length >= s2.Length ? s1 : s2;\\n            }\\n            if (i == s.Length - 1) \\n                return s;   \\n        }\\n        return \"\";\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string LongestNiceSubstring(string s) {\\n        \\n        for (int i = 0; i < s.Length; i++) {\\n            char counterPart = Char.IsLower(s[i]) ? Char.ToUpper(s[i]) : Char.ToLower(s[i]);\\n            if (!s.Contains(counterPart)) {\\n                if (i == 0) {\\n                    return LongestNiceSubstring(s.Substring(1, s.Length - 1));\\n                }\\n                if (i == s.Length - 1) {\\n                    return LongestNiceSubstring(s.Substring(0, s.Length - 1));\\n                }\\n                string s1 = LongestNiceSubstring(s.Substring(0, i));\\n                string s2 = LongestNiceSubstring(s.Substring(i + 1, s.Length - i - 1));\\n                return s1.Length >= s2.Length ? s1 : s2;\\n            }\\n            if (i == s.Length - 1) \\n                return s;   \\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1409016,
                "title": "python-brute-force",
                "content": "```\\n#Given, the length of string is less than 100, the worst this brute force can do is O(100*(n^2)) which is O(n^2)\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        if len(s) == 1:\\n            return \"\"\\n        if len(s) == 2:\\n            if s[0].swapcase() not in s:\\n                return \"\"\\n            else:\\n                return s\\n        dictt = {} #for storing nice seq with their length\\n        for i in range(2,len(s)+1): #checking each substring with a particular size\\n            seq = s[0:i]\\n            for j in range(i, len(s)+1):\\n                myset = set(seq) #set allow O(1) lookups\\n                count = 0\\n                for k in seq: #traversing through the seq to see if its nice\\n                    if k.swapcase() not in myset:\\n                        break\\n                    else:\\n                        count += 1\\n                if len(seq) == count:\\n\\t\\t\\t\\t#here, seq is nice, hence we store in the dictionary\\n                    dictt[seq] = count\\n                if j != len(s):\\n                    seq = seq[1:] + str(s[j]) #sliding window\\n        if len(dictt) == 0:\\n            return \"\"\\n        else:\\n            maxi = max(dictt.values())\\n        for x in dictt.keys():\\n            if dictt[x] == maxi:\\n                return x\\n#chech with testcase \"wruU\" for better understanding\\n```",
                "solutionTags": [],
                "code": "```\\n#Given, the length of string is less than 100, the worst this brute force can do is O(100*(n^2)) which is O(n^2)\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        if len(s) == 1:\\n            return \"\"\\n        if len(s) == 2:\\n            if s[0].swapcase() not in s:\\n                return \"\"\\n            else:\\n                return s\\n        dictt = {} #for storing nice seq with their length\\n        for i in range(2,len(s)+1): #checking each substring with a particular size\\n            seq = s[0:i]\\n            for j in range(i, len(s)+1):\\n                myset = set(seq) #set allow O(1) lookups\\n                count = 0\\n                for k in seq: #traversing through the seq to see if its nice\\n                    if k.swapcase() not in myset:\\n                        break\\n                    else:\\n                        count += 1\\n                if len(seq) == count:\\n\\t\\t\\t\\t#here, seq is nice, hence we store in the dictionary\\n                    dictt[seq] = count\\n                if j != len(s):\\n                    seq = seq[1:] + str(s[j]) #sliding window\\n        if len(dictt) == 0:\\n            return \"\"\\n        else:\\n            maxi = max(dictt.values())\\n        for x in dictt.keys():\\n            if dictt[x] == maxi:\\n                return x\\n#chech with testcase \"wruU\" for better understanding\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354833,
                "title": "c-solution-using-map-and-set",
                "content": "```\\n bool nice(string s){\\n        map<char,int> mp;\\n        \\n        set<char> st;\\n        \\n        for(int i=0;i<s.size();i++){\\n            st.insert(s[i]);\\n        }\\n        bool flag=1;\\n        \\n        for(auto x: s){\\n            if(x>=\\'A\\' and x<=\\'Z\\'){\\n                if(st.find((char(x + 32)))==st.end()){\\n                    return false;\\n                }\\n            }\\n            else{\\n                 if(st.find((char(x - 32)))==st.end()){\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    string longestNiceSubstring(string s) {\\n        \\n        \\n        string ans=\"\";\\n        \\n        \\n        for(int i=0;i<s.size();i++){\\n            string tmp=\"\";\\n            tmp+=s[i];\\n            for(int j=i + 1;j<s.size();j++){\\n                tmp+=s[j];\\n                if(nice(tmp)){\\n                    if(ans.size()<tmp.size()){\\n                        ans=tmp;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n bool nice(string s){\\n        map<char,int> mp;\\n        \\n        set<char> st;\\n        \\n        for(int i=0;i<s.size();i++){\\n            st.insert(s[i]);\\n        }\\n        bool flag=1;\\n        \\n        for(auto x: s){\\n            if(x>=\\'A\\' and x<=\\'Z\\'){\\n                if(st.find((char(x + 32)))==st.end()){\\n                    return false;\\n                }\\n            }\\n            else{\\n                 if(st.find((char(x - 32)))==st.end()){\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    string longestNiceSubstring(string s) {\\n        \\n        \\n        string ans=\"\";\\n        \\n        \\n        for(int i=0;i<s.size();i++){\\n            string tmp=\"\";\\n            tmp+=s[i];\\n            for(int j=i + 1;j<s.size();j++){\\n                tmp+=s[j];\\n                if(nice(tmp)){\\n                    if(ans.size()<tmp.size()){\\n                        ans=tmp;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1351047,
                "title": "o-n-2-runtime-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {       \\n        int bestStartPos = 0;\\n        int bestLength = 0;\\n        \\n        for (int startPos = 0; startPos < s.size(); startPos++) {\\n            int lower = 0;\\n            int upper = 0;\\n            \\n            for (int pos = startPos; pos < s.size(); pos++) {\\n                if (islower(s[pos])) {\\n                    lower |= 1 << (s[pos]-\\'a\\');\\n                } else {\\n                    upper |= 1 << (s[pos]-\\'A\\');\\n                }\\n                \\n                if ((lower ^ upper) == 0) {\\n                    const int currLength = pos - startPos + 1;\\n                    if (currLength > bestLength) {\\n                        bestLength = currLength;    \\n                        bestStartPos = startPos;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return s.substr(bestStartPos, bestLength);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(string s) {       \\n        int bestStartPos = 0;\\n        int bestLength = 0;\\n        \\n        for (int startPos = 0; startPos < s.size(); startPos++) {\\n            int lower = 0;\\n            int upper = 0;\\n            \\n            for (int pos = startPos; pos < s.size(); pos++) {\\n                if (islower(s[pos])) {\\n                    lower |= 1 << (s[pos]-\\'a\\');\\n                } else {\\n                    upper |= 1 << (s[pos]-\\'A\\');\\n                }\\n                \\n                if ((lower ^ upper) == 0) {\\n                    const int currLength = pos - startPos + 1;\\n                    if (currLength > bestLength) {\\n                        bestLength = currLength;    \\n                        bestStartPos = startPos;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return s.substr(bestStartPos, bestLength);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312661,
                "title": "simple-java-solution-divide-and-conquer",
                "content": "Whenever a char occurred for which upper/lower char is not available, We will try to find solution in left or right sub string. else consider current char part of solution string.  \\n\\n```\\n    public String longestNiceSubstring(String str) {\\n          Set<Character> charSet = new HashSet<>();\\n        for (int i = 0; i < str.length(); i++) {\\n            charSet.add(str.charAt(i));\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n            if (charSet.contains(Character.toUpperCase(str.charAt(i))) &&\\n                    charSet.contains(Character.toLowerCase(str.charAt(i)))) {\\n                continue;\\n            }\\n            String s1 = longestNiceSubstring(str.substring(0, i));\\n            String s2 = longestNiceSubstring(str.substring(i+1));\\n            return s1.length()>= s2.length() ? s1 : s2;\\n        }\\n        return str;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String longestNiceSubstring(String str) {\\n          Set<Character> charSet = new HashSet<>();\\n        for (int i = 0; i < str.length(); i++) {\\n            charSet.add(str.charAt(i));\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n            if (charSet.contains(Character.toUpperCase(str.charAt(i))) &&\\n                    charSet.contains(Character.toLowerCase(str.charAt(i)))) {\\n                continue;\\n            }\\n            String s1 = longestNiceSubstring(str.substring(0, i));\\n            String s2 = longestNiceSubstring(str.substring(i+1));\\n            return s1.length()>= s2.length() ? s1 : s2;\\n        }\\n        return str;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1297730,
                "title": "python3-implementation-using-divide-and-conquer-algorithm",
                "content": "```\\nclass Solution:\\n    \\n    def find_pivot(self,s,i,j):\\n        dic={s[k]:k for k in range(i,j+1)}\\n        for d in dic:\\n            if ord(d)>=97 and d.upper() not in dic:\\n                return False,dic[d]\\n            elif ord(d)>=65 and d.lower() not in dic:\\n                return False,dic[d]\\n        \\n        return True,s[i:j+1]\\n    \\n    def func(self,s,i,j):   \\n        if i>=j:\\n            return \\'\\'\\n        check,val=self.find_pivot(s,i,j)\\n        if check==True:\\n            return val\\n        return max(self.func(s,i,val-1),self.func(s,val+1,j),key=len)\\n        \\n    \\n    def longestNiceSubstring(self, s: str) -> str:\\n        return self.func(s,0,len(s)-1)\\n   \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def find_pivot(self,s,i,j):\\n        dic={s[k]:k for k in range(i,j+1)}\\n        for d in dic:\\n            if ord(d)>=97 and d.upper() not in dic:\\n                return False,dic[d]\\n            elif ord(d)>=65 and d.lower() not in dic:\\n                return False,dic[d]\\n        \\n        return True,s[i:j+1]\\n    \\n    def func(self,s,i,j):   \\n        if i>=j:\\n            return \\'\\'\\n        check,val=self.find_pivot(s,i,j)\\n        if check==True:\\n            return val\\n        return max(self.func(s,i,val-1),self.func(s,val+1,j),key=len)\\n        \\n    \\n    def longestNiceSubstring(self, s: str) -> str:\\n        return self.func(s,0,len(s)-1)\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1293121,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        if(s.length()<2)\\n            return \"\";\\n        HashSet<Character> hs=new HashSet<>();\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            hs.add(c);\\n        }\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            if(hs.contains(Character.toLowerCase(c)) && hs.contains(Character.toUpperCase(c)))\\n                continue;\\n            String sub1=longestNiceSubstring(s.substring(0,i));\\n            String sub2=longestNiceSubstring(s.substring(i+1));\\n            return sub1.length()>=sub2.length()?sub1:sub2;\\n        }\\n        return s;\\n        }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        if(s.length()<2)\\n            return \"\";\\n        HashSet<Character> hs=new HashSet<>();\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            hs.add(c);\\n        }\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            if(hs.contains(Character.toLowerCase(c)) && hs.contains(Character.toUpperCase(c)))\\n                continue;\\n            String sub1=longestNiceSubstring(s.substring(0,i));\\n            String sub2=longestNiceSubstring(s.substring(i+1));\\n            return sub1.length()>=sub2.length()?sub1:sub2;\\n        }\\n        return s;\\n        }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1290870,
                "title": "python-short-solution-using-two-sets-with-comments",
                "content": "1. Brute-force all contiguous substrings with two loops - first iterates over substring start, the second - over substring end\\n2. Keep track of two sets - uppercase characters and lowercase characters. For uppercase characters we store their lowercases in the second set\\n3. After completing internal loop, we check if two sets are equal, and if they do, we check if current substring is longer than the result, and update the result if it is necessary\\n```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        result = \"\"\\n        n = len(s)\\n        for i in range(n): # Inner loop\\n\\t\\t    # Initialize our sets\\n            c1 = set() # For lowercase occurences\\n            c2 = set() # For uppercase occurences\\n            for j in range(i, n):\\n                if str.islower(s[j]):\\n                    c1.add(s[j])\\n                else:\\n                    c2.add(str.lower(s[j])) # convert to lowercase so that we could compare sets for equality\\n                if c1 == c2: # if sets are equal (containing same characters)\\n                    ss = s[i:j+1] # get the substring\\n                    if len(ss) > len(result): # Update only if we have found a longer nice substring\\n                        result = ss\\n                \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        result = \"\"\\n        n = len(s)\\n        for i in range(n): # Inner loop\\n\\t\\t    # Initialize our sets\\n            c1 = set() # For lowercase occurences\\n            c2 = set() # For uppercase occurences\\n            for j in range(i, n):\\n                if str.islower(s[j]):\\n                    c1.add(s[j])\\n                else:\\n                    c2.add(str.lower(s[j])) # convert to lowercase so that we could compare sets for equality\\n                if c1 == c2: # if sets are equal (containing same characters)\\n                    ss = s[i:j+1] # get the substring\\n                    if len(ss) > len(result): # Update only if we have found a longer nice substring\\n                        result = ss\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255639,
                "title": "share-two-java-solutions-with-explanations",
                "content": "1. Solution1: \\n    see the length <= 100, maybe a O(n^3) brute-force can pass, so just need check all cases, and record current maxLength which meets requirement of LNS\\uFF0Cif the remaining length <= maxLength, break\\n\\tcomplexity: T:O(n^3), S:O(n^2)\\n\\t\\n2. Solution2: @https://leetcode.com/problems/longest-nice-substring/discuss/1074589/JavaStraightforward-Divide-and-Conquer\\n   When meets character that can pair upcase and lowercase, dividing string by it, and judge substring.\\n   complexity: T:O(n^2), S:O(n)\\n\\n```java\\n// solution 2: divider-conquer. \\n// AC: Runtime: 2 ms, faster than 92.31% of Java online submissions for Longest Nice Substring.\\n// Memory Usage: 39.1 MB, less than 50.87% of Java online submissions for Longest Nice Substring.\\n// thoughts: when meets character that can pair upcase and lowercase, dividing string by it, and judge substring.\\n// T:O(n^2), S:O(n)\\n// \\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        int size = s.length();\\n        if (size < 2) {\\n            return \"\";\\n        }\\n        HashSet<Character> record = new HashSet<>();\\n        for (char c: s.toCharArray()) {\\n            record.add(c);\\n        }\\n        for (int i = 0; i < size; i++) {\\n            char c = s.charAt(i);\\n            if (record.contains(Character.toUpperCase(c)) && record.contains(Character.toLowerCase(c))) {\\n                continue;\\n            }\\n            String s1 = longestNiceSubstring(s.substring(0, i));\\n            String s2 = longestNiceSubstring(s.substring(i + 1, size));\\n            return s1.length() >= s2.length() ? s1 : s2;\\n        }\\n        \\n        return s;\\n    }\\n}\\n```\\n_____________________________________________\\n\\n```\\n// solution 1: since the s.length() <= 100, guess maybe brute-force can pass.\\n// AC: Runtime: 68 ms, faster than 12.06% of Java online submissions for Longest Nice Substring.\\n// Memory Usage: 39.3 MB, less than 30.94% of Java online submissions for Longest Nice Substring.\\n// checking throught all cases, brute-force method\\n// T:O(n^3), O:(n^2)\\n//\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        int size = s.length(), maxLen = 0;\\n        List<String> ret = new LinkedList<>();\\n        for (int i = 0; i < size; i++) {\\n            if (size - i <= maxLen) {\\n                break;\\n            }\\n            for (int j = size - 1; j >= 0; j--) {\\n                HashSet<Character> check = new HashSet<>();\\n                for (int k = i; k <= j; k++) {\\n                    check.add(s.charAt(k));\\n                }\\n                boolean flag = true;\\n                for (char c: check) {\\n                    if (c >= \\'a\\') {\\n                        if (!check.contains((char)(c - 32))) {\\n                            flag = false;\\n                            break;\\n                        }\\n                    } else {\\n                        if (!check.contains((char)(c + 32))) {\\n                            flag = false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (flag) {\\n                    if (j - i + 1 > maxLen) {\\n                        maxLen = j - i + 1;\\n                        ret.add(s.substring(i, j + 1));\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        for (String str: ret) {\\n            if (str.length() == maxLen) {\\n                return str;\\n            }\\n        }\\n\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n// solution 2: divider-conquer. \\n// AC: Runtime: 2 ms, faster than 92.31% of Java online submissions for Longest Nice Substring.\\n// Memory Usage: 39.1 MB, less than 50.87% of Java online submissions for Longest Nice Substring.\\n// thoughts: when meets character that can pair upcase and lowercase, dividing string by it, and judge substring.\\n// T:O(n^2), S:O(n)\\n// \\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        int size = s.length();\\n        if (size < 2) {\\n            return \"\";\\n        }\\n        HashSet<Character> record = new HashSet<>();\\n        for (char c: s.toCharArray()) {\\n            record.add(c);\\n        }\\n        for (int i = 0; i < size; i++) {\\n            char c = s.charAt(i);\\n            if (record.contains(Character.toUpperCase(c)) && record.contains(Character.toLowerCase(c))) {\\n                continue;\\n            }\\n            String s1 = longestNiceSubstring(s.substring(0, i));\\n            String s2 = longestNiceSubstring(s.substring(i + 1, size));\\n            return s1.length() >= s2.length() ? s1 : s2;\\n        }\\n        \\n        return s;\\n    }\\n}\\n```\n```\\n// solution 1: since the s.length() <= 100, guess maybe brute-force can pass.\\n// AC: Runtime: 68 ms, faster than 12.06% of Java online submissions for Longest Nice Substring.\\n// Memory Usage: 39.3 MB, less than 30.94% of Java online submissions for Longest Nice Substring.\\n// checking throught all cases, brute-force method\\n// T:O(n^3), O:(n^2)\\n//\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        int size = s.length(), maxLen = 0;\\n        List<String> ret = new LinkedList<>();\\n        for (int i = 0; i < size; i++) {\\n            if (size - i <= maxLen) {\\n                break;\\n            }\\n            for (int j = size - 1; j >= 0; j--) {\\n                HashSet<Character> check = new HashSet<>();\\n                for (int k = i; k <= j; k++) {\\n                    check.add(s.charAt(k));\\n                }\\n                boolean flag = true;\\n                for (char c: check) {\\n                    if (c >= \\'a\\') {\\n                        if (!check.contains((char)(c - 32))) {\\n                            flag = false;\\n                            break;\\n                        }\\n                    } else {\\n                        if (!check.contains((char)(c + 32))) {\\n                            flag = false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (flag) {\\n                    if (j - i + 1 > maxLen) {\\n                        maxLen = j - i + 1;\\n                        ret.add(s.substring(i, j + 1));\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        for (String str: ret) {\\n            if (str.length() == maxLen) {\\n                return str;\\n            }\\n        }\\n\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120325,
                "title": "simple-java-solution-using-treemap",
                "content": "````\\nclass Solution {\\n     public String longestNiceSubstring(String s) {\\n\\n        int i = 0, j = 0;\\n        int len = s.length();\\n\\n        TreeMap<Integer, List<String>> map = new TreeMap<>();\\n        while (i < len) {\\n            String str = s.substring(i, j);\\n            if (isNice(str)) {\\n                int size = str.length();\\n                List<String> list = map.getOrDefault(size, new ArrayList<>());\\n                list.add(str);\\n                map.put(size, list);\\n            }\\n            j++;\\n            if (j > len) {\\n                i++;\\n                j = i;\\n            }\\n        }\\n        if (map.isEmpty()) {\\n            return \"\";\\n        }\\n        return map.lastEntry().getValue().get(0);\\n\\n    }\\n\\n    public boolean isNice(String str) {\\n        if (str.isEmpty()) {\\n            return false;\\n        }\\n        int[] upper = new int[26];\\n        int[] lower = new int[26];\\n\\n        for (char c : str.toCharArray()) {\\n            if (Character.isLowerCase(c)) {\\n                lower[c - \\'a\\']++;\\n            } else {\\n                upper[c - \\'A\\']++;\\n            }\\n        }\\n\\n        for (int i = 0; i < 26; i++) {\\n\\n            if ((lower[i] > 0 && upper[i] == 0) || (lower[i] == 0 && upper[i] > 0)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "````\\nclass Solution {\\n     public String longestNiceSubstring(String s) {\\n\\n        int i = 0, j = 0;\\n        int len = s.length();\\n\\n        TreeMap<Integer, List<String>> map = new TreeMap<>();\\n        while (i < len) {\\n            String str = s.substring(i, j);\\n            if (isNice(str)) {\\n                int size = str.length();\\n                List<String> list = map.getOrDefault(size, new ArrayList<>());\\n                list.add(str);\\n                map.put(size, list);\\n            }\\n            j++;\\n            if (j > len) {\\n                i++;\\n                j = i;\\n            }\\n        }\\n        if (map.isEmpty()) {\\n            return \"\";\\n        }\\n        return map.lastEntry().getValue().get(0);\\n\\n    }\\n\\n    public boolean isNice(String str) {\\n        if (str.isEmpty()) {\\n            return false;\\n        }\\n        int[] upper = new int[26];\\n        int[] lower = new int[26];\\n\\n        for (char c : str.toCharArray()) {\\n            if (Character.isLowerCase(c)) {\\n                lower[c - \\'a\\']++;\\n            } else {\\n                upper[c - \\'A\\']++;\\n            }\\n        }\\n\\n        for (int i = 0; i < 26; i++) {\\n\\n            if ((lower[i] > 0 && upper[i] == 0) || (lower[i] == 0 && upper[i] > 0)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107730,
                "title": "python-brute-force-solution",
                "content": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        s1=\"\"\\n        for i in range(len(s)):\\n            for j in range(i,len(s)):\\n                temp=s[i:j+1]\\n                sub=set(s[i:j+1])\\n                cnt=0\\n                for k in sub:\\n                    if k.isupper():\\n                        if k.lower() in sub:\\n                            cnt+=1\\n                    elif k.islower():\\n                        if k.upper() in sub:\\n                            cnt+=1\\n                if cnt==len(sub):\\n                    d=\"\".join(temp)\\n                    if len(d)>len(s1):\\n                        s1=d\\n        return s1",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        s1=\"\"\\n        for i in range(len(s)):\\n            for j in range(i,len(s)):\\n                temp=s[i:j+1]\\n                sub=set(s[i:j+1])\\n                cnt=0\\n                for k in sub:\\n                    if k.isupper():\\n                        if k.lower() in sub:\\n                            cnt+=1\\n                    elif k.islower():\\n                        if k.upper() in sub:\\n                            cnt+=1\\n                if cnt==len(sub):\\n                    d=\"\".join(temp)\\n                    if len(d)>len(s1):\\n                        s1=d\\n        return s1",
                "codeTag": "Java"
            },
            {
                "id": 1094750,
                "title": "ruby-solution",
                "content": "```ruby\\n# @param {String} s\\n# @return {String}\\ndef longest_nice_substring(s)\\n  return \\'\\' if s.length < 2\\n\\n  uniqs = s.chars.sort.uniq\\n  # or\\n  # uniqs = Set[*s.chars]\\n  \\n  s.each_char.with_index do |c, i|\\n    next if uniqs.include?(c.upcase) && uniqs.include?(c.downcase)\\n    \\n    left = longest_nice_substring(s[0...i])\\n    right = longest_nice_substring(s[i+1..])\\n    \\n    if left.length >= right.length\\n      return left\\n    else\\n      return right\\n    end\\n  end\\n\\n  s\\nend\\n```",
                "solutionTags": [],
                "code": "```ruby\\n# @param {String} s\\n# @return {String}\\ndef longest_nice_substring(s)\\n  return \\'\\' if s.length < 2\\n\\n  uniqs = s.chars.sort.uniq\\n  # or\\n  # uniqs = Set[*s.chars]\\n  \\n  s.each_char.with_index do |c, i|\\n    next if uniqs.include?(c.upcase) && uniqs.include?(c.downcase)\\n    \\n    left = longest_nice_substring(s[0...i])\\n    right = longest_nice_substring(s[i+1..])\\n    \\n    if left.length >= right.length\\n      return left\\n    else\\n      return right\\n    end\\n  end\\n\\n  s\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1086222,
                "title": "java-sliding-window-o-26-n",
                "content": "Similar to https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/\\n\\nCode for reference. Not quite readable. \\n```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        boolean[] used = new boolean[26];\\n        char[] arr = s.toCharArray();\\n        int res = 0;\\n        int start = 0, end = 0;\\n        int distinct = 0;\\n        for(char c : arr) {\\n            if(Character.isUpperCase(c)) used[c-\\'A\\'] = true;\\n            else used[c-\\'a\\'] = true;\\n        }\\n        for(int i = 0; i < 26; i++) distinct += used[i] ? 1 : 0; \\n        for(int k = 1; k <= distinct; k++) {\\n            int i = 0, j = 0;\\n            int unique = 0;\\n            int count = 0;\\n            int[][] dp = new int[26][2];\\n            int[] freq = new int[26];\\n            while(j < s.length()) {\\n                char c = arr[j];\\n                int pos = Character.toLowerCase(c) - \\'a\\';\\n                if(freq[pos] == 0) {\\n                    unique++;\\n                }\\n                freq[pos]++;\\n                // check if the substring from i  to j  is nice\\n                if(Character.isUpperCase(c)) {\\n                    if(dp[pos][1] == 0) {\\n                        count += dp[pos][0] > 0 ? -1 : 1;                        \\n                    }\\n                    dp[pos][1]++;\\n                } else {\\n                    if(dp[pos][0] == 0) {\\n                        count += dp[pos][1] > 0 ? -1 : 1;                   \\n                    }\\n                    dp[pos][0]++;\\n                }\\n                // increment i when constraint is met\\n                while(unique > k) {\\n                    pos = Character.toLowerCase(arr[i]) - \\'a\\';\\n                    if(Character.isUpperCase(arr[i])) {\\n                        dp[pos][1]--;\\n                        if(dp[pos][1] == 0){\\n                           count += dp[pos][0] == 0 ? -1 : 1; \\n                        }\\n                    } else {\\n                        dp[pos][0]--;\\n                        if(dp[pos][0] == 0){\\n                           count += dp[pos][1] == 0 ? -1 : 1; \\n                        }\\n                    }\\n                    \\n                    if(--freq[pos] == 0) {\\n                        unique--;\\n                    }\\n                    i++;\\n                }\\n                if(count == 0 && j - i + 1 > res) {\\n                    res = j - i + 1;\\n                    start = i;\\n                    end = j;\\n                }\\n                j++;\\n            }\\n        }\\n        return res == 0 ? \"\" : s.substring(start, end+1);\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        boolean[] used = new boolean[26];\\n        char[] arr = s.toCharArray();\\n        int res = 0;\\n        int start = 0, end = 0;\\n        int distinct = 0;\\n        for(char c : arr) {\\n            if(Character.isUpperCase(c)) used[c-\\'A\\'] = true;\\n            else used[c-\\'a\\'] = true;\\n        }\\n        for(int i = 0; i < 26; i++) distinct += used[i] ? 1 : 0; \\n        for(int k = 1; k <= distinct; k++) {\\n            int i = 0, j = 0;\\n            int unique = 0;\\n            int count = 0;\\n            int[][] dp = new int[26][2];\\n            int[] freq = new int[26];\\n            while(j < s.length()) {\\n                char c = arr[j];\\n                int pos = Character.toLowerCase(c) - \\'a\\';\\n                if(freq[pos] == 0) {\\n                    unique++;\\n                }\\n                freq[pos]++;\\n                // check if the substring from i  to j  is nice\\n                if(Character.isUpperCase(c)) {\\n                    if(dp[pos][1] == 0) {\\n                        count += dp[pos][0] > 0 ? -1 : 1;                        \\n                    }\\n                    dp[pos][1]++;\\n                } else {\\n                    if(dp[pos][0] == 0) {\\n                        count += dp[pos][1] > 0 ? -1 : 1;                   \\n                    }\\n                    dp[pos][0]++;\\n                }\\n                // increment i when constraint is met\\n                while(unique > k) {\\n                    pos = Character.toLowerCase(arr[i]) - \\'a\\';\\n                    if(Character.isUpperCase(arr[i])) {\\n                        dp[pos][1]--;\\n                        if(dp[pos][1] == 0){\\n                           count += dp[pos][0] == 0 ? -1 : 1; \\n                        }\\n                    } else {\\n                        dp[pos][0]--;\\n                        if(dp[pos][0] == 0){\\n                           count += dp[pos][1] == 0 ? -1 : 1; \\n                        }\\n                    }\\n                    \\n                    if(--freq[pos] == 0) {\\n                        unique--;\\n                    }\\n                    i++;\\n                }\\n                if(count == 0 && j - i + 1 > res) {\\n                    res = j - i + 1;\\n                    start = i;\\n                    end = j;\\n                }\\n                j++;\\n            }\\n        }\\n        return res == 0 ? \"\" : s.substring(start, end+1);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084656,
                "title": "c-o-n-2-time-o-1-space-simple-check-all-substrings",
                "content": "```csharp\\npublic string LongestNiceSubstring(string s)\\n{\\n\\tstring result = string.Empty;\\n\\tint maxLength = 0;\\n\\tint resultStart = 0;\\n\\n\\tfor (int start = 0; start < s.Length; start++)\\n\\t{\\n\\t\\tint upper = 0, lower = 0;                \\n\\t\\tfor (int end = start; end < s.Length; end++)\\n\\t\\t{   \\n\\t\\t\\tint length = end - start + 1;\\n\\t\\t\\tif(char.IsUpper(s[end]))\\n\\t\\t\\t{\\n\\t\\t\\t\\tupper |= 1 << (s[end] - \\'A\\');\\n\\t\\t\\t}\\n\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tlower |= 1 << (s[end] - \\'a\\');\\n\\t\\t\\t}                    \\n\\n\\t\\t\\tif ((upper ^ lower) == 0 && length > maxLength)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresultStart = start;\\n\\t\\t\\t\\tmaxLength = length;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tresult = s.Substring(resultStart, maxLength);\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic string LongestNiceSubstring(string s)\\n{\\n\\tstring result = string.Empty;\\n\\tint maxLength = 0;\\n\\tint resultStart = 0;\\n\\n\\tfor (int start = 0; start < s.Length; start++)\\n\\t{\\n\\t\\tint upper = 0, lower = 0;                \\n\\t\\tfor (int end = start; end < s.Length; end++)\\n\\t\\t{   \\n\\t\\t\\tint length = end - start + 1;\\n\\t\\t\\tif(char.IsUpper(s[end]))\\n\\t\\t\\t{\\n\\t\\t\\t\\tupper |= 1 << (s[end] - \\'A\\');\\n\\t\\t\\t}\\n\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tlower |= 1 << (s[end] - \\'a\\');\\n\\t\\t\\t}                    \\n\\n\\t\\t\\tif ((upper ^ lower) == 0 && length > maxLength)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresultStart = start;\\n\\t\\t\\t\\tmaxLength = length;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tresult = s.Substring(resultStart, maxLength);\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1077124,
                "title": "c-bitwise-operation-quadratic-brute-force",
                "content": "It\\'s the expected quadratic brute force naive solution but uses a neat representation of both cases of of the whole alphabet using bitwise operations to still run fast on the small problem sizes that the judging code offers. This stuffs the same functionality that naively you\\'d pull in an unordered map/set for into a value that fits in a single processor register.\\n\\nThere is also an algorithmic tweak in that the outer loop terminates as soon as there are not enough characters left to form a nice substring as long as the longest seen so far.\\n\\n```cpp\\nuint8_t longest_from(const string& s, const size_t start)\\n{\\n    // The \"unordered_set\" to record characters in the substring as we iterate over it:\\n\\tuint64_t flags = 0;\\n\\tsize_t longest = 0;\\n\\n    // We got lucky and the distance from A to z and the\\n\\t// punctuation padding the space between the cases is <= 64.\\n\\tfor(auto i = start; i < s.length(); ++i){\\n\\t\\tflags |= uint64_t(1u) << (s[i] -\\'A\\');\\n\\t\\tif((flags & (uint64_t(1u)<<32u)-1) == (flags >> 32u)){\\n\\t\\t\\tlongest = i - start + 1;\\n\\t\\t}\\n\\t}\\n\\treturn longest;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(const string& s)\\n    {   \\n        size_t longest_start = 0;\\n        size_t longest_len = 0;\\n        \\n        for(size_t i = 0; i < s.length(); ++i)\\n        {\\n            size_t pos_longest = longest_from(s, i);\\n            if(pos_longest > longest_len){\\n                longest_start = i;\\n                longest_len = pos_longest;\\n            }\\n            \\n            // End if we don\\'t have enough characters left in the input to beat the longest so far:\\n            if(longest_len >= s.length() - i) break;\\n        }\\n        return s.substr(longest_start, longest_len);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nuint8_t longest_from(const string& s, const size_t start)\\n{\\n    // The \"unordered_set\" to record characters in the substring as we iterate over it:\\n\\tuint64_t flags = 0;\\n\\tsize_t longest = 0;\\n\\n    // We got lucky and the distance from A to z and the\\n\\t// punctuation padding the space between the cases is <= 64.\\n\\tfor(auto i = start; i < s.length(); ++i){\\n\\t\\tflags |= uint64_t(1u) << (s[i] -\\'A\\');\\n\\t\\tif((flags & (uint64_t(1u)<<32u)-1) == (flags >> 32u)){\\n\\t\\t\\tlongest = i - start + 1;\\n\\t\\t}\\n\\t}\\n\\treturn longest;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    string longestNiceSubstring(const string& s)\\n    {   \\n        size_t longest_start = 0;\\n        size_t longest_len = 0;\\n        \\n        for(size_t i = 0; i < s.length(); ++i)\\n        {\\n            size_t pos_longest = longest_from(s, i);\\n            if(pos_longest > longest_len){\\n                longest_start = i;\\n                longest_len = pos_longest;\\n            }\\n            \\n            // End if we don\\'t have enough characters left in the input to beat the longest so far:\\n            if(longest_len >= s.length() - i) break;\\n        }\\n        return s.substr(longest_start, longest_len);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076104,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool isNiceString(string s){\\n        unordered_map<char,int> m;\\n        for(int i=0;i<s.length();i++){\\n            m[s[i]]++;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]>=65 && s[i]<=90){\\n                if(m[s[i]+32] > 0) continue;\\n                else {return false;}\\n            }\\n            else if(s[i]>=96 && s[i]<=122){\\n                if(m[s[i]-32] > 0) continue;\\n                else {return false;}\\n            }\\n        }\\n        return true;\\n            \\n    }\\n    \\n    string longestNiceSubstring(string s) {\\n        string longest = \"\";\\n        int n = s.length();\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                string temp = s.substr(i,j-i+1);\\n                if(isNiceString(temp) && temp.length()>longest.length()){\\n                    longest = temp;\\n                }\\n            }\\n        }\\n        return longest;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isNiceString(string s){\\n        unordered_map<char,int> m;\\n        for(int i=0;i<s.length();i++){\\n            m[s[i]]++;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]>=65 && s[i]<=90){\\n                if(m[s[i]+32] > 0) continue;\\n                else {return false;}\\n            }\\n            else if(s[i]>=96 && s[i]<=122){\\n                if(m[s[i]-32] > 0) continue;\\n                else {return false;}\\n            }\\n        }\\n        return true;\\n            \\n    }\\n    \\n    string longestNiceSubstring(string s) {\\n        string longest = \"\";\\n        int n = s.length();\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                string temp = s.substr(i,j-i+1);\\n                if(isNiceString(temp) && temp.length()>longest.length()){\\n                    longest = temp;\\n                }\\n            }\\n        }\\n        return longest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075319,
                "title": "java-bitmask-solution-beats-100",
                "content": "**Brute Force:**\\n```\\npublic String longestNiceSubstring(String s) {\\n\\tint len = s.length();\\n\\tint[] res = {0, 0};\\n\\tfor (int i = 0; i < len; i++) {\\n\\t\\tint upper = 0;\\n\\t\\tint lower = 0;\\n\\t\\tfor (int j = i; j < len; j++) {\\n\\t\\t\\tchar c = s.charAt(j);\\n\\t\\t\\tif (c > \\'Z\\') {\\n\\t\\t\\t\\tlower |= 1 << (c-\\'a\\');\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tupper |= 1 << (c-\\'A\\');\\n\\t\\t\\t}\\n\\t\\t\\tif ((lower ^ upper) == 0 &&\\n\\t\\t\\t\\tj - i + 1 > res[1] - res[0]) {\\n\\t\\t\\t\\tres[0] = i;\\n\\t\\t\\t\\tres[1] = j + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn s.substring(res[0], res[1]);\\n}\\n```\\n\\n**Divide and Conquer:**\\n```\\npublic String longestNiceSubstring(String s) {\\n\\treturn helper(s, 0, s.length());\\n}\\n\\nString helper(String s, int left, int right) {\\n\\tint lower = 0;\\n\\tint upper = 0;\\n\\tfor (int i = left; i < right; i++) {\\n\\t\\tchar c = s.charAt(i);\\n\\t\\tif (c > \\'Z\\') {\\n\\t\\t\\tlower |= 1 << (c-\\'a\\');\\n\\t\\t} else {\\n\\t\\t\\tupper |= 1 << (c-\\'A\\');\\n\\t\\t}\\n\\t}\\n\\tfor (int i = left; i < right; i++) {\\n\\t\\tchar c = s.charAt(i);\\n\\t\\tint shift = c - (c > \\'Z\\' ? \\'a\\' : \\'A\\');\\n\\t\\tif ((lower & 1 << shift) == (upper & 1 << shift)) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tString leftStr = helper(s, left, i);\\n\\t\\tString rightStr = helper(s, i+1, right);\\n\\t\\tif (leftStr.length() >= rightStr.length()) {\\n\\t\\t\\treturn leftStr;\\n\\t\\t} else {\\n\\t\\t\\treturn rightStr;\\n\\t\\t}\\n\\n\\t}\\n\\treturn s.substring(left, right);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String longestNiceSubstring(String s) {\\n\\tint len = s.length();\\n\\tint[] res = {0, 0};\\n\\tfor (int i = 0; i < len; i++) {\\n\\t\\tint upper = 0;\\n\\t\\tint lower = 0;\\n\\t\\tfor (int j = i; j < len; j++) {\\n\\t\\t\\tchar c = s.charAt(j);\\n\\t\\t\\tif (c > \\'Z\\') {\\n\\t\\t\\t\\tlower |= 1 << (c-\\'a\\');\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tupper |= 1 << (c-\\'A\\');\\n\\t\\t\\t}\\n\\t\\t\\tif ((lower ^ upper) == 0 &&\\n\\t\\t\\t\\tj - i + 1 > res[1] - res[0]) {\\n\\t\\t\\t\\tres[0] = i;\\n\\t\\t\\t\\tres[1] = j + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn s.substring(res[0], res[1]);\\n}\\n```\n```\\npublic String longestNiceSubstring(String s) {\\n\\treturn helper(s, 0, s.length());\\n}\\n\\nString helper(String s, int left, int right) {\\n\\tint lower = 0;\\n\\tint upper = 0;\\n\\tfor (int i = left; i < right; i++) {\\n\\t\\tchar c = s.charAt(i);\\n\\t\\tif (c > \\'Z\\') {\\n\\t\\t\\tlower |= 1 << (c-\\'a\\');\\n\\t\\t} else {\\n\\t\\t\\tupper |= 1 << (c-\\'A\\');\\n\\t\\t}\\n\\t}\\n\\tfor (int i = left; i < right; i++) {\\n\\t\\tchar c = s.charAt(i);\\n\\t\\tint shift = c - (c > \\'Z\\' ? \\'a\\' : \\'A\\');\\n\\t\\tif ((lower & 1 << shift) == (upper & 1 << shift)) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tString leftStr = helper(s, left, i);\\n\\t\\tString rightStr = helper(s, i+1, right);\\n\\t\\tif (leftStr.length() >= rightStr.length()) {\\n\\t\\t\\treturn leftStr;\\n\\t\\t} else {\\n\\t\\t\\treturn rightStr;\\n\\t\\t}\\n\\n\\t}\\n\\treturn s.substring(left, right);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1075071,
                "title": "golang-go-devide-and-conquer-with-unit-test",
                "content": "Please support the Golang community. Vote this up or suggest better code. Thanks!\\n```\\nimport (\\n\\t\"testing\"\\n\\t\"unicode\"\\n)\\n\\nfunc longestNiceSubstring(s string) string {\\n\\tif len(s) < 2 {\\n\\t\\treturn \"\"\\n\\t}\\n\\tchars := make(map[int32]struct{})\\n\\tfor _, c := range s {\\n\\t\\tchars[c] = struct{}{}\\n\\t}\\n\\tfor i, c := range s {\\n\\t\\t_, ok1 := chars[unicode.ToLower(c)]\\n\\t\\t_, ok2 := chars[unicode.ToUpper(c)]\\n\\t\\tif ok1 && ok2 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\ts1 := longestNiceSubstring(s[0:i])\\n\\t\\ts2 := longestNiceSubstring(s[i+1:])\\n\\t\\tif len(s1) >= len(s2) {\\n\\t\\t\\treturn s1\\n\\t\\t} else {\\n\\t\\t\\treturn s2\\n\\t\\t}\\n\\t}\\n\\treturn s\\n}\\n\\nvar dataItems1763 = []struct {\\n\\tinput  string\\n\\tresult string\\n}{\\n\\t{\"YazaAay\", \"aAa\"},\\n\\t{\"Bb\", \"Bb\"},\\n\\t{\"c\", \"\"},\\n\\t{\"dDzeE\", \"dD\"},\\n}\\n\\nfunc Test1763(t *testing.T) {\\n\\tfor _, item := range dataItems1763 {\\n\\t\\tresult := longestNiceSubstring(item.input)\\n\\t\\tif item.result == result {\\n\\t\\t\\tt.Log(\"PASSED\")\\n\\t\\t} else {\\n\\t\\t\\tt.Errorf(\"FAILED, expected %v but got %v\", item.result, result)\\n\\t\\t}\\n\\t}\\n}\\n",
                "solutionTags": [],
                "code": "Please support the Golang community. Vote this up or suggest better code. Thanks!\\n```\\nimport (\\n\\t\"testing\"\\n\\t\"unicode\"\\n)\\n\\nfunc longestNiceSubstring(s string) string {\\n\\tif len(s) < 2 {\\n\\t\\treturn \"\"\\n\\t}\\n\\tchars := make(map[int32]struct{})\\n\\tfor _, c := range s {\\n\\t\\tchars[c] = struct{}{}\\n\\t}\\n\\tfor i, c := range s {\\n\\t\\t_, ok1 := chars[unicode.ToLower(c)]\\n\\t\\t_, ok2 := chars[unicode.ToUpper(c)]\\n\\t\\tif ok1 && ok2 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\ts1 := longestNiceSubstring(s[0:i])\\n\\t\\ts2 := longestNiceSubstring(s[i+1:])\\n\\t\\tif len(s1) >= len(s2) {\\n\\t\\t\\treturn s1\\n\\t\\t} else {\\n\\t\\t\\treturn s2\\n\\t\\t}\\n\\t}\\n\\treturn s\\n}\\n\\nvar dataItems1763 = []struct {\\n\\tinput  string\\n\\tresult string\\n}{\\n\\t{\"YazaAay\", \"aAa\"},\\n\\t{\"Bb\", \"Bb\"},\\n\\t{\"c\", \"\"},\\n\\t{\"dDzeE\", \"dD\"},\\n}\\n\\nfunc Test1763(t *testing.T) {\\n\\tfor _, item := range dataItems1763 {\\n\\t\\tresult := longestNiceSubstring(item.input)\\n\\t\\tif item.result == result {\\n\\t\\t\\tt.Log(\"PASSED\")\\n\\t\\t} else {\\n\\t\\t\\tt.Errorf(\"FAILED, expected %v but got %v\", item.result, result)\\n\\t\\t}\\n\\t}\\n}\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1075041,
                "title": "ruby-solution",
                "content": "```\\ndef is_nice(str)\\n    letters = str.chars.uniq\\n    letter_hash = Hash.new(0)\\n    letters.each do |ltr|\\n        letter_hash[ltr.ord]+=1 if ltr>=\\'a\\' and ltr<=\\'z\\'\\n        letter_hash[ltr.ord+(\\'a\\'.ord-\\'A\\'.ord)]-=1 if ltr>=\\'A\\' and ltr<=\\'Z\\'\\n    end\\n    letter_hash.values.uniq == [0]\\nend\\n\\n# @param {String} s\\n# @return {String}\\ndef longest_nice_substring(s)\\n    max_length = 0\\n    max_string = \"\"\\n    for i in 0...s.length-1\\n        for j in i+1...s.length\\n            if is_nice(s[i..j])\\n                if j-i+1 > max_length\\n                    max_length = j-i+1\\n                    max_string = s[i..j]\\n                end\\n            end\\n        end\\n    end\\n    \\n    max_string    \\n    \\nend\\n",
                "solutionTags": [],
                "code": "```\\ndef is_nice(str)\\n    letters = str.chars.uniq\\n    letter_hash = Hash.new(0)\\n    letters.each do |ltr|\\n        letter_hash[ltr.ord]+=1 if ltr>=\\'a\\' and ltr<=\\'z\\'\\n        letter_hash[ltr.ord+(\\'a\\'.ord-\\'A\\'.ord)]-=1 if ltr>=\\'A\\' and ltr<=\\'Z\\'\\n    end\\n    letter_hash.values.uniq == [0]\\nend\\n\\n# @param {String} s\\n# @return {String}\\ndef longest_nice_substring(s)\\n    max_length = 0\\n    max_string = \"\"\\n    for i in 0...s.length-1\\n        for j in i+1...s.length\\n            if is_nice(s[i..j])\\n                if j-i+1 > max_length\\n                    max_length = j-i+1\\n                    max_string = s[i..j]\\n                end\\n            end\\n        end\\n    end\\n    \\n    max_string    \\n    \\nend\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1074936,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n      public String tocheck(String str){\\n            boolean check = false ;\\n            int count = 0 ;\\n           char[] ch = new char[str.length()]; \\n        for (int i = 0; i < str.length(); i++) { \\n            ch[i] = str.charAt(i); \\n        } \\n              for (int i = 0; i < ch.length; i++) {\\n                  if(Character.isUpperCase(ch[i])){\\n                       for (int j = 0; j < ch.length; j++){\\n                           if(ch[j] == ch[i]+32 ){\\n                              count++;\\n                               break ;\\n                           }\\n                       }\\n                  }else{\\n                             for (int j = 0; j < ch.length; j++){\\n                           if(ch[j] == ch[i]-32 ){\\n                              count++;\\n                               break ;\\n                           }\\n                       }\\n                  }\\n                  if(count == ch.length){\\n                      return str ;\\n                  }\\n                     }\\n                       \\n                    return \" \" ;\\n           \\n       }\\n    public String longestNiceSubstring(String s) {\\n            String temp = \"\";\\n         for (int i = 0; i < s.length(); i++) {\\n   for (int j = i+1; j <= s.length(); j++) {\\n        String str = s.substring(i,j);\\n     String strip =   tocheck(str);\\n       if(strip.length() > temp.length()){\\n           temp = strip ;\\n       }\\n       \\n \\n   }\\n  }\\n        \\n    if(temp == \" \"){\\n        return \"\";\\n    }else{\\n           return temp ;\\n    }\\n \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n      public String tocheck(String str){\\n            boolean check = false ;\\n            int count = 0 ;\\n           char[] ch = new char[str.length()]; \\n        for (int i = 0; i < str.length(); i++) { \\n            ch[i] = str.charAt(i); \\n        } \\n              for (int i = 0; i < ch.length; i++) {\\n                  if(Character.isUpperCase(ch[i])){\\n                       for (int j = 0; j < ch.length; j++){\\n                           if(ch[j] == ch[i]+32 ){\\n                              count++;\\n                               break ;\\n                           }\\n                       }\\n                  }else{\\n                             for (int j = 0; j < ch.length; j++){\\n                           if(ch[j] == ch[i]-32 ){\\n                              count++;\\n                               break ;\\n                           }\\n                       }\\n                  }\\n                  if(count == ch.length){\\n                      return str ;\\n                  }\\n                     }\\n                       \\n                    return \" \" ;\\n           \\n       }\\n    public String longestNiceSubstring(String s) {\\n            String temp = \"\";\\n         for (int i = 0; i < s.length(); i++) {\\n   for (int j = i+1; j <= s.length(); j++) {\\n        String str = s.substring(i,j);\\n     String strip =   tocheck(str);\\n       if(strip.length() > temp.length()){\\n           temp = strip ;\\n       }\\n       \\n \\n   }\\n  }\\n        \\n    if(temp == \" \"){\\n        return \"\";\\n    }else{\\n           return temp ;\\n    }\\n \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074772,
                "title": "java-recursive-solution-which-is-easy-to-unnderstand-and-beats-100",
                "content": "```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        if (s == null || s.length() <= 1) return \"\";\\n\\n        return helper(s, 0, s.length() - 1);\\n    }\\n\\n    private String helper(String s, int start, int end) {\\n        if (start >= end) return \"\";\\n\\n        Set<Character> set = new HashSet<>();\\n\\n        for (int i = start; i <= end; i++) {\\n            char ch = s.charAt(i);\\n            set.add(ch);\\n        }\\n\\n\\n        for (int i = start; i <= end; i++) {\\n            char ch = s.charAt(i);\\n            char lower = Character.toLowerCase(ch);\\n            char upper = Character.toUpperCase(ch);\\n\\n            if (set.contains(lower) && !set.contains(upper) || set.contains(upper) && !set.contains(lower)) {\\n                // one of capital or lower letter is not present, \\n                // this index divides the string into 2 parts.\\n                // check both sides, whichever returns the longest string, bubble that up as one solution\\n                String left = helper(s, start, i - 1);\\n                String right = helper(s, i + 1, end);\\n\\n                if (left.length() == right.length()) {\\n                    return left;\\n                } else {\\n                    return left.length() > right.length() ? left : right;\\n                }\\n            }\\n        }\\n\\n        return s.substring(start, end + 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        if (s == null || s.length() <= 1) return \"\";\\n\\n        return helper(s, 0, s.length() - 1);\\n    }\\n\\n    private String helper(String s, int start, int end) {\\n        if (start >= end) return \"\";\\n\\n        Set<Character> set = new HashSet<>();\\n\\n        for (int i = start; i <= end; i++) {\\n            char ch = s.charAt(i);\\n            set.add(ch);\\n        }\\n\\n\\n        for (int i = start; i <= end; i++) {\\n            char ch = s.charAt(i);\\n            char lower = Character.toLowerCase(ch);\\n            char upper = Character.toUpperCase(ch);\\n\\n            if (set.contains(lower) && !set.contains(upper) || set.contains(upper) && !set.contains(lower)) {\\n                // one of capital or lower letter is not present, \\n                // this index divides the string into 2 parts.\\n                // check both sides, whichever returns the longest string, bubble that up as one solution\\n                String left = helper(s, start, i - 1);\\n                String right = helper(s, i + 1, end);\\n\\n                if (left.length() == right.length()) {\\n                    return left;\\n                } else {\\n                    return left.length() > right.length() ? left : right;\\n                }\\n            }\\n        }\\n\\n        return s.substring(start, end + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074718,
                "title": "c-dp-o-n-2",
                "content": "Runtime: 100 ms\\nMemory Usage: 24.5 MB\\n\\n```\\n    public string LongestNiceSubstring(string s) {\\n        \\n        int[][,] dp = new int[s.Length][,];\\n        int[] count = new int[s.Length]; \\n        \\n        for(int i=0; i < s.Length; i++)\\n        {\\n            dp[i] = new int[\\'z\\'-\\'a\\'+1, 2];\\n        }\\n      \\n        bool isFirst;\\n        string result = string.Empty;\\n        \\n        for(int k=0; k <= s.Length; k++)\\n        {\\n            isFirst = true;\\n            for(int i=0, j=k; j < s.Length; i++, j++)\\n            {\\n                if (s[j] >= \\'A\\' && s[j] <= \\'Z\\') \\n                { \\n                    if (dp[i][s[j]-\\'A\\', 1] == 0)\\n                    {\\n                        if (dp[i][s[j]-\\'A\\', 0] == 1) { count[i]--; } else { count[i]++; } \\n                        dp[i][s[j]-\\'A\\', 1] = 1; \\n                    }\\n                } \\n                else if (dp[i][s[j]-\\'a\\', 0] == 0)\\n                {\\n                    if (dp[i][s[j]-\\'a\\', 1] == 1) { count[i]--; } else { count[i]++; } \\n                    dp[i][s[j]-\\'a\\', 0] = 1; \\n                }\\n                \\n                if (count[i] == 0 && isFirst)\\n                {\\n                    isFirst = false;\\n                    result = s.Substring(i,k+1);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 100 ms\\nMemory Usage: 24.5 MB\\n\\n```\\n    public string LongestNiceSubstring(string s) {\\n        \\n        int[][,] dp = new int[s.Length][,];\\n        int[] count = new int[s.Length]; \\n        \\n        for(int i=0; i < s.Length; i++)\\n        {\\n            dp[i] = new int[\\'z\\'-\\'a\\'+1, 2];\\n        }\\n      \\n        bool isFirst;\\n        string result = string.Empty;\\n        \\n        for(int k=0; k <= s.Length; k++)\\n        {\\n            isFirst = true;\\n            for(int i=0, j=k; j < s.Length; i++, j++)\\n            {\\n                if (s[j] >= \\'A\\' && s[j] <= \\'Z\\') \\n                { \\n                    if (dp[i][s[j]-\\'A\\', 1] == 0)\\n                    {\\n                        if (dp[i][s[j]-\\'A\\', 0] == 1) { count[i]--; } else { count[i]++; } \\n                        dp[i][s[j]-\\'A\\', 1] = 1; \\n                    }\\n                } \\n                else if (dp[i][s[j]-\\'a\\', 0] == 0)\\n                {\\n                    if (dp[i][s[j]-\\'a\\', 1] == 1) { count[i]--; } else { count[i]++; } \\n                    dp[i][s[j]-\\'a\\', 0] = 1; \\n                }\\n                \\n                if (count[i] == 0 && isFirst)\\n                {\\n                    isFirst = false;\\n                    result = s.Substring(i,k+1);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1074694,
                "title": "why-my-code-is-giving-runtime-error",
                "content": "i was stuck for 45min \\n```\\nclass Solution {\\npublic:\\n    bool check(int i,int j,string &s){\\n        vector<bool> u(26,false),l(26,false);\\n\\n        for(int x=i;x<=j;x++){\\n            if(((int)s[x])<90) l[(int)(s[x]-\\'A\\')]=true;\\n            else  u[(int)(s[x]-\\'a\\')]=true;\\n        }\\n        \\n        \\n        for(int x=0;x<=25;x++){\\n            if(l[x]==true&&u[x]==false) return false;\\n             if(u[x]==true&&l[x]==false) return false;\\n        }\\n        return true;\\n    }\\n    string longestNiceSubstring(string s) {\\n        int n=s.size(),ans=0,ai=-1;\\n        string as=\"\";\\n        for(int i=0;i<n;i++){\\n           for(int j=i+1;j<n;j++){\\n            if(check(i,j,s)==true&&(j-i+1>ans)){\\n                ans=j-i+1;\\n                ai=i;\\n                \\n            }\\n               \\n           }\\n            \\n        }\\n        return (ai==-1?\"\":s.substr(ai,ans));\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int i,int j,string &s){\\n        vector<bool> u(26,false),l(26,false);\\n\\n        for(int x=i;x<=j;x++){\\n            if(((int)s[x])<90) l[(int)(s[x]-\\'A\\')]=true;\\n            else  u[(int)(s[x]-\\'a\\')]=true;\\n        }\\n        \\n        \\n        for(int x=0;x<=25;x++){\\n            if(l[x]==true&&u[x]==false) return false;\\n             if(u[x]==true&&l[x]==false) return false;\\n        }\\n        return true;\\n    }\\n    string longestNiceSubstring(string s) {\\n        int n=s.size(),ans=0,ai=-1;\\n        string as=\"\";\\n        for(int i=0;i<n;i++){\\n           for(int j=i+1;j<n;j++){\\n            if(check(i,j,s)==true&&(j-i+1>ans)){\\n                ans=j-i+1;\\n                ai=i;\\n                \\n            }\\n               \\n           }\\n            \\n        }\\n        return (ai==-1?\"\":s.substr(ai,ans));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074654,
                "title": "brute-force-java",
                "content": "\\tclass Solution {\\n    public String longestNiceSubstring(String s) {\\n        int max = -(int)1e8;\\n        String res = \"\";\\n        for(int i = 0; i < s.length(); i++){\\n            for(int j = i + 1; j <= s.length(); j++){\\n                String ss = s.substring(i,j);\\n                if(isValid(ss) == true){\\n                    if(ss.length() > max){\\n                        max = ss.length();\\n                        res = ss;\\n                    }\\n                } \\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public boolean isValid(String ss){\\n        if(ss.length() == 1) return false;\\n        \\n        int freq[] = new int[128];\\n        for(int i = 0; i < ss.length(); i++){\\n            freq[ss.charAt(i)]++;\\n        }\\n        \\n        for(int i = 0; i < ss.length(); i++){\\n            if(ss.charAt(i) >= 97 && ss.charAt(i) <= 122){ //lower case char\\n                if(freq[ss.charAt(i) - 32] == 0) return false;\\n            }else{ // upper case char\\n                if(freq[ss.charAt(i) + 32] == 0) return false;\\n            }\\n        }\\n        \\n        return true;\\n      }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String longestNiceSubstring(String s) {\\n        int max = -(int)1e8;\\n        String res = \"\";\\n        for(int i = 0; i < s.length(); i++){\\n            for(int j = i + 1; j <= s.length(); j++){\\n                String ss = s.substring(i,j);\\n                if(isValid(ss) == true){\\n                    if(ss.length() > max){\\n                        max = ss.length();\\n                        res = ss;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1074639,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestNiceSubstring = function(s) {\\n    \\n    \\n    function isLongestNiceSubstring(a){\\n        if(a.length<2) return \"\";\\n        let checker = new Set();\\n        for(let i = 0; i<a.length; i++){\\n            checker.add(a[i]);\\n        }\\n        for(let i =0;i<a.length;i++){\\n            if(!checker.has(a[i].toLowerCase())||!checker.has(a[i].toUpperCase())){\\n                let s1=isLongestNiceSubstring(a.substring(0,i));\\n                let s2=isLongestNiceSubstring(a.substring(i+1,a.length));\\n                if(s2.length>s1.length){\\n                    return s2;\\n                }else return s1;\\n            }\\n        }\\n        return a;\\n    }\\n    \\n    return isLongestNiceSubstring(s);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestNiceSubstring = function(s) {\\n    \\n    \\n    function isLongestNiceSubstring(a){\\n        if(a.length<2) return \"\";\\n        let checker = new Set();\\n        for(let i = 0; i<a.length; i++){\\n            checker.add(a[i]);\\n        }\\n        for(let i =0;i<a.length;i++){\\n            if(!checker.has(a[i].toLowerCase())||!checker.has(a[i].toUpperCase())){\\n                let s1=isLongestNiceSubstring(a.substring(0,i));\\n                let s2=isLongestNiceSubstring(a.substring(i+1,a.length));\\n                if(s2.length>s1.length){\\n                    return s2;\\n                }else return s1;\\n            }\\n        }\\n        return a;\\n    }\\n    \\n    return isLongestNiceSubstring(s);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1074623,
                "title": "swift-brute-force",
                "content": "```swift\\nclass Solution {\\n    func longestNiceSubstring(_ s: String) -> String {\\n        guard s.count > 1  else {\\n            return \"\"\\n        }\\n        let chars = [Character](s)\\n        let N = s.count\\n        let values = chars.map {$0.asciiValue!}\\n        \\n        func valid(_ length: Int) -> String {\\n            for idx in 0...(N - length) {\\n                let tempValues = Set<UInt8>(values[idx..<(idx + length)]).sorted()\\n                // print(tempValues)\\n                guard tempValues.count % 2 == 0 else {\\n                    continue\\n                }\\n                let M = tempValues.count\\n                let half = M >> 1\\n                var flag = true\\n                for l in 0..<half {\\n                    guard tempValues[l + half] - tempValues[l] == 32 else  {\\n                        flag = false\\n                        break\\n                    }\\n                }\\n                if flag {\\n                    return String(chars[idx..<(idx + length)])\\n                }\\n            }\\n            return \"\"\\n        }\\n        \\n        for length in stride(from: N, through: 2, by: -1) {\\n            let ans = valid(length)\\n            guard ans.isEmpty else {\\n                return ans\\n            }\\n        }\\n        return \"\"\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func longestNiceSubstring(_ s: String) -> String {\\n        guard s.count > 1  else {\\n            return \"\"\\n        }\\n        let chars = [Character](s)\\n        let N = s.count\\n        let values = chars.map {$0.asciiValue!}\\n        \\n        func valid(_ length: Int) -> String {\\n            for idx in 0...(N - length) {\\n                let tempValues = Set<UInt8>(values[idx..<(idx + length)]).sorted()\\n                // print(tempValues)\\n                guard tempValues.count % 2 == 0 else {\\n                    continue\\n                }\\n                let M = tempValues.count\\n                let half = M >> 1\\n                var flag = true\\n                for l in 0..<half {\\n                    guard tempValues[l + half] - tempValues[l] == 32 else  {\\n                        flag = false\\n                        break\\n                    }\\n                }\\n                if flag {\\n                    return String(chars[idx..<(idx + length)])\\n                }\\n            }\\n            return \"\"\\n        }\\n        \\n        for length in stride(from: N, through: 2, by: -1) {\\n            let ans = valid(length)\\n            guard ans.isEmpty else {\\n                return ans\\n            }\\n        }\\n        return \"\"\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074595,
                "title": "naive-solution-but-easy-to-understand",
                "content": "We check every substring .\\nNOT FAST BUT EASY\\n\\n```\\nstring longestNiceSubstring(string s) {\\n        int n=s.size();\\n        string ans=\"\";\\n         for (int i = 0; i < n; i++)\\n         {\\n             for (int len = 1; len <= n - i; len++)\\n             {\\n                 string x=s.substr(i, len);\\n                 if(check(x))\\n                 {\\n                     if(x.size()>ans.size())\\n                     {\\n                         ans=x;\\n                     }\\n                 }\\n             }\\n            \\n         }\\n        \\n       return ans;\\n        \\n    }\\n    \\n    bool check(string s)\\n    {\\n         unordered_map<char,int> map;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            map[s[i]]++;\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]>=\\'a\\'&&s[i]<=\\'z\\')\\n            {\\n                if(map.find(s[i]-32)==map.end())\\n                {\\n                   return false;\\n                }\\n                \\n            }\\n            else\\n            {\\n                if(map.find(s[i]+32)==map.end())\\n                {\\n                   return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstring longestNiceSubstring(string s) {\\n        int n=s.size();\\n        string ans=\"\";\\n         for (int i = 0; i < n; i++)\\n         {\\n             for (int len = 1; len <= n - i; len++)\\n             {\\n                 string x=s.substr(i, len);\\n                 if(check(x))\\n                 {\\n                     if(x.size()>ans.size())\\n                     {\\n                         ans=x;\\n                     }\\n                 }\\n             }\\n            \\n         }\\n        \\n       return ans;\\n        \\n    }\\n    \\n    bool check(string s)\\n    {\\n         unordered_map<char,int> map;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            map[s[i]]++;\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]>=\\'a\\'&&s[i]<=\\'z\\')\\n            {\\n                if(map.find(s[i]-32)==map.end())\\n                {\\n                   return false;\\n                }\\n                \\n            }\\n            else\\n            {\\n                if(map.find(s[i]+32)==map.end())\\n                {\\n                   return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4091350,
                "title": "bruteforce-golang",
                "content": "# Approach\\n\\n1. Iterate over all of the substrings from s and check if they are nice\\n2. Nice check: initialize 2 slices for lower and upper runes. Save presence of lower and upper\\n3. Iterate once again over substring checking that for each upper lower is presented, if for upper lower case is not presented, return false\\n\\n# Complexity\\n- Time complexity: $$O(n ^ 3)$$ in a worst case\\n\\n- Space complexity: $$O(1)$$, because the input alphabet is finite\\n\\n# Code\\n```\\nfunc longestNiceSubstring(s string) string {\\n    res := \"\"\\n\\n    nice := func(s string) bool {\\n        // save presence of upper and lower case of runes\\n        lower, upper := make([]int, 26), make([]int, 26)\\n\\n        for _, r := range s {\\n            if unicode.IsUpper(r) {\\n                upper[r - \\'A\\'] += 1\\n            } else {\\n                lower[r - \\'a\\'] += 1\\n            }\\n        }\\n\\n        for _, r := range s {\\n            if unicode.IsUpper(r) {\\n                if lower[r - \\'A\\'] == 0 {return false}\\n            } else if upper[r - \\'a\\'] == 0 {\\n                return false\\n            }\\n        }\\n\\n        return true\\n    }\\n\\n    // bruteforce over all of the substrings from s\\n    for i := 0; i < len(s); i++ {\\n        for j := i + 1; j < len(s) + 1; j ++ {\\n            if !nice(s[i:j]) {continue}\\n            if len(s[i:j]) > len(res) {res = s[i:j]}\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestNiceSubstring(s string) string {\\n    res := \"\"\\n\\n    nice := func(s string) bool {\\n        // save presence of upper and lower case of runes\\n        lower, upper := make([]int, 26), make([]int, 26)\\n\\n        for _, r := range s {\\n            if unicode.IsUpper(r) {\\n                upper[r - \\'A\\'] += 1\\n            } else {\\n                lower[r - \\'a\\'] += 1\\n            }\\n        }\\n\\n        for _, r := range s {\\n            if unicode.IsUpper(r) {\\n                if lower[r - \\'A\\'] == 0 {return false}\\n            } else if upper[r - \\'a\\'] == 0 {\\n                return false\\n            }\\n        }\\n\\n        return true\\n    }\\n\\n    // bruteforce over all of the substrings from s\\n    for i := 0; i < len(s); i++ {\\n        for j := i + 1; j < len(s) + 1; j ++ {\\n            if !nice(s[i:j]) {continue}\\n            if len(s[i:j]) > len(res) {res = s[i:j]}\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4089158,
                "title": "python-brute-force-approach",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(pow(n,3))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(|s|)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        res=\\'\\'\\n        n=len(s)\\n        for i in range(n):\\n            small,capital=\\'\\',\\'\\'\\n            for j in range(i,n):\\n                if s[j]>=\\'a\\' and s[j]<=\\'z\\':\\n                    small+=s[j]\\n                else:\\n                    capital+=s[j]\\n                flag=1\\n                for cur in small:\\n                    if not cur.upper() in capital:\\n                        flag=0\\n                        break\\n                for cur in capital:\\n                    if not cur.lower() in small:\\n                        flag=0\\n                        break\\n                if flag and small and capital:\\n                    if len(res)<(j-i+1):\\n                        res=s[i:j+1]\\n        return res \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        res=\\'\\'\\n        n=len(s)\\n        for i in range(n):\\n            small,capital=\\'\\',\\'\\'\\n            for j in range(i,n):\\n                if s[j]>=\\'a\\' and s[j]<=\\'z\\':\\n                    small+=s[j]\\n                else:\\n                    capital+=s[j]\\n                flag=1\\n                for cur in small:\\n                    if not cur.upper() in capital:\\n                        flag=0\\n                        break\\n                for cur in capital:\\n                    if not cur.lower() in small:\\n                        flag=0\\n                        break\\n                if flag and small and capital:\\n                    if len(res)<(j-i+1):\\n                        res=s[i:j+1]\\n        return res \\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1732799,
                "content": [
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "This should be a medium problem in my opinion."
                    },
                    {
                        "username": "firefly1",
                        "content": "true"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Even I was thinking the same"
                    },
                    {
                        "username": "prepat21",
                        "content": "this is basically a version of maximum contiguous subarray sum"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Petition to change this to `Medium` difficulty in the feedback."
                    },
                    {
                        "username": "blank_1729",
                        "content": "why does this have sliding window tag anyways?"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "First problem with leetcode and competitive coding and now I rethink my decision \\uD83D\\uDE22"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Is sliding window technique possible in this scenario? ( I think sliding window is only possible if there is a scenario when we need to shrink the window back else not)\nMuch of the tags in the solutions aren't sliding window."
                    },
                    {
                        "username": "madpoly",
                        "content": "yall really gotta chill with the examples only showing one letter group and midway the tests there can be more. I am sure the question indicates nothing like that but I built my solution around detecting only up to 1 letter group. Need to rework it. No biggie but wish examples showed something a bit complex."
                    },
                    {
                        "username": "Adithya_pillai",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence\". \\nI guess it should be changed as \"If there are multiple substrings of same length, return the substring of the earliest occurrence\""
                    },
                    {
                        "username": "frozennuts",
                        "content": "I did this entire thing without the bit manipulation operator, I want to actually die it literately took me 4 days T_T"
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It does not comes under sliding window approach ..! I am not able to understand how can we solve this if\\nwe are not dealing with a contiguous substring. We need to consider all possible substrings of the input string and check if each substring meets the criteria of being \"nice\". It requires examining substrings at different positions within the string, rather than sliding a fixed-sized window across it. "
                    },
                    {
                        "username": "streetcoder123",
                        "content": "I\\'m confused about the part that says, \"If there are multiple, return the substring of the earliest occurrence.\"  Should we return the longest string or the first occurence of a substring?  These seems a little ambiguous.  "
                    },
                    {
                        "username": "RahulNauni",
                        "content": "Return longest that comes earliest. Here multiple means, longest substrings with same length."
                    }
                ]
            },
            {
                "id": 1862411,
                "content": [
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "This should be a medium problem in my opinion."
                    },
                    {
                        "username": "firefly1",
                        "content": "true"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Even I was thinking the same"
                    },
                    {
                        "username": "prepat21",
                        "content": "this is basically a version of maximum contiguous subarray sum"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Petition to change this to `Medium` difficulty in the feedback."
                    },
                    {
                        "username": "blank_1729",
                        "content": "why does this have sliding window tag anyways?"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "First problem with leetcode and competitive coding and now I rethink my decision \\uD83D\\uDE22"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Is sliding window technique possible in this scenario? ( I think sliding window is only possible if there is a scenario when we need to shrink the window back else not)\nMuch of the tags in the solutions aren't sliding window."
                    },
                    {
                        "username": "madpoly",
                        "content": "yall really gotta chill with the examples only showing one letter group and midway the tests there can be more. I am sure the question indicates nothing like that but I built my solution around detecting only up to 1 letter group. Need to rework it. No biggie but wish examples showed something a bit complex."
                    },
                    {
                        "username": "Adithya_pillai",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence\". \\nI guess it should be changed as \"If there are multiple substrings of same length, return the substring of the earliest occurrence\""
                    },
                    {
                        "username": "frozennuts",
                        "content": "I did this entire thing without the bit manipulation operator, I want to actually die it literately took me 4 days T_T"
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It does not comes under sliding window approach ..! I am not able to understand how can we solve this if\\nwe are not dealing with a contiguous substring. We need to consider all possible substrings of the input string and check if each substring meets the criteria of being \"nice\". It requires examining substrings at different positions within the string, rather than sliding a fixed-sized window across it. "
                    },
                    {
                        "username": "streetcoder123",
                        "content": "I\\'m confused about the part that says, \"If there are multiple, return the substring of the earliest occurrence.\"  Should we return the longest string or the first occurence of a substring?  These seems a little ambiguous.  "
                    },
                    {
                        "username": "RahulNauni",
                        "content": "Return longest that comes earliest. Here multiple means, longest substrings with same length."
                    }
                ]
            },
            {
                "id": 1868785,
                "content": [
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "This should be a medium problem in my opinion."
                    },
                    {
                        "username": "firefly1",
                        "content": "true"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Even I was thinking the same"
                    },
                    {
                        "username": "prepat21",
                        "content": "this is basically a version of maximum contiguous subarray sum"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Petition to change this to `Medium` difficulty in the feedback."
                    },
                    {
                        "username": "blank_1729",
                        "content": "why does this have sliding window tag anyways?"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "First problem with leetcode and competitive coding and now I rethink my decision \\uD83D\\uDE22"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Is sliding window technique possible in this scenario? ( I think sliding window is only possible if there is a scenario when we need to shrink the window back else not)\nMuch of the tags in the solutions aren't sliding window."
                    },
                    {
                        "username": "madpoly",
                        "content": "yall really gotta chill with the examples only showing one letter group and midway the tests there can be more. I am sure the question indicates nothing like that but I built my solution around detecting only up to 1 letter group. Need to rework it. No biggie but wish examples showed something a bit complex."
                    },
                    {
                        "username": "Adithya_pillai",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence\". \\nI guess it should be changed as \"If there are multiple substrings of same length, return the substring of the earliest occurrence\""
                    },
                    {
                        "username": "frozennuts",
                        "content": "I did this entire thing without the bit manipulation operator, I want to actually die it literately took me 4 days T_T"
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It does not comes under sliding window approach ..! I am not able to understand how can we solve this if\\nwe are not dealing with a contiguous substring. We need to consider all possible substrings of the input string and check if each substring meets the criteria of being \"nice\". It requires examining substrings at different positions within the string, rather than sliding a fixed-sized window across it. "
                    },
                    {
                        "username": "streetcoder123",
                        "content": "I\\'m confused about the part that says, \"If there are multiple, return the substring of the earliest occurrence.\"  Should we return the longest string or the first occurence of a substring?  These seems a little ambiguous.  "
                    },
                    {
                        "username": "RahulNauni",
                        "content": "Return longest that comes earliest. Here multiple means, longest substrings with same length."
                    }
                ]
            },
            {
                "id": 1794565,
                "content": [
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "This should be a medium problem in my opinion."
                    },
                    {
                        "username": "firefly1",
                        "content": "true"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Even I was thinking the same"
                    },
                    {
                        "username": "prepat21",
                        "content": "this is basically a version of maximum contiguous subarray sum"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Petition to change this to `Medium` difficulty in the feedback."
                    },
                    {
                        "username": "blank_1729",
                        "content": "why does this have sliding window tag anyways?"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "First problem with leetcode and competitive coding and now I rethink my decision \\uD83D\\uDE22"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Is sliding window technique possible in this scenario? ( I think sliding window is only possible if there is a scenario when we need to shrink the window back else not)\nMuch of the tags in the solutions aren't sliding window."
                    },
                    {
                        "username": "madpoly",
                        "content": "yall really gotta chill with the examples only showing one letter group and midway the tests there can be more. I am sure the question indicates nothing like that but I built my solution around detecting only up to 1 letter group. Need to rework it. No biggie but wish examples showed something a bit complex."
                    },
                    {
                        "username": "Adithya_pillai",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence\". \\nI guess it should be changed as \"If there are multiple substrings of same length, return the substring of the earliest occurrence\""
                    },
                    {
                        "username": "frozennuts",
                        "content": "I did this entire thing without the bit manipulation operator, I want to actually die it literately took me 4 days T_T"
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It does not comes under sliding window approach ..! I am not able to understand how can we solve this if\\nwe are not dealing with a contiguous substring. We need to consider all possible substrings of the input string and check if each substring meets the criteria of being \"nice\". It requires examining substrings at different positions within the string, rather than sliding a fixed-sized window across it. "
                    },
                    {
                        "username": "streetcoder123",
                        "content": "I\\'m confused about the part that says, \"If there are multiple, return the substring of the earliest occurrence.\"  Should we return the longest string or the first occurence of a substring?  These seems a little ambiguous.  "
                    },
                    {
                        "username": "RahulNauni",
                        "content": "Return longest that comes earliest. Here multiple means, longest substrings with same length."
                    }
                ]
            },
            {
                "id": 1761605,
                "content": [
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "This should be a medium problem in my opinion."
                    },
                    {
                        "username": "firefly1",
                        "content": "true"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Even I was thinking the same"
                    },
                    {
                        "username": "prepat21",
                        "content": "this is basically a version of maximum contiguous subarray sum"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Petition to change this to `Medium` difficulty in the feedback."
                    },
                    {
                        "username": "blank_1729",
                        "content": "why does this have sliding window tag anyways?"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "First problem with leetcode and competitive coding and now I rethink my decision \\uD83D\\uDE22"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Is sliding window technique possible in this scenario? ( I think sliding window is only possible if there is a scenario when we need to shrink the window back else not)\nMuch of the tags in the solutions aren't sliding window."
                    },
                    {
                        "username": "madpoly",
                        "content": "yall really gotta chill with the examples only showing one letter group and midway the tests there can be more. I am sure the question indicates nothing like that but I built my solution around detecting only up to 1 letter group. Need to rework it. No biggie but wish examples showed something a bit complex."
                    },
                    {
                        "username": "Adithya_pillai",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence\". \\nI guess it should be changed as \"If there are multiple substrings of same length, return the substring of the earliest occurrence\""
                    },
                    {
                        "username": "frozennuts",
                        "content": "I did this entire thing without the bit manipulation operator, I want to actually die it literately took me 4 days T_T"
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It does not comes under sliding window approach ..! I am not able to understand how can we solve this if\\nwe are not dealing with a contiguous substring. We need to consider all possible substrings of the input string and check if each substring meets the criteria of being \"nice\". It requires examining substrings at different positions within the string, rather than sliding a fixed-sized window across it. "
                    },
                    {
                        "username": "streetcoder123",
                        "content": "I\\'m confused about the part that says, \"If there are multiple, return the substring of the earliest occurrence.\"  Should we return the longest string or the first occurence of a substring?  These seems a little ambiguous.  "
                    },
                    {
                        "username": "RahulNauni",
                        "content": "Return longest that comes earliest. Here multiple means, longest substrings with same length."
                    }
                ]
            },
            {
                "id": 1825544,
                "content": [
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "This should be a medium problem in my opinion."
                    },
                    {
                        "username": "firefly1",
                        "content": "true"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Even I was thinking the same"
                    },
                    {
                        "username": "prepat21",
                        "content": "this is basically a version of maximum contiguous subarray sum"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Petition to change this to `Medium` difficulty in the feedback."
                    },
                    {
                        "username": "blank_1729",
                        "content": "why does this have sliding window tag anyways?"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "First problem with leetcode and competitive coding and now I rethink my decision \\uD83D\\uDE22"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Is sliding window technique possible in this scenario? ( I think sliding window is only possible if there is a scenario when we need to shrink the window back else not)\nMuch of the tags in the solutions aren't sliding window."
                    },
                    {
                        "username": "madpoly",
                        "content": "yall really gotta chill with the examples only showing one letter group and midway the tests there can be more. I am sure the question indicates nothing like that but I built my solution around detecting only up to 1 letter group. Need to rework it. No biggie but wish examples showed something a bit complex."
                    },
                    {
                        "username": "Adithya_pillai",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence\". \\nI guess it should be changed as \"If there are multiple substrings of same length, return the substring of the earliest occurrence\""
                    },
                    {
                        "username": "frozennuts",
                        "content": "I did this entire thing without the bit manipulation operator, I want to actually die it literately took me 4 days T_T"
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It does not comes under sliding window approach ..! I am not able to understand how can we solve this if\\nwe are not dealing with a contiguous substring. We need to consider all possible substrings of the input string and check if each substring meets the criteria of being \"nice\". It requires examining substrings at different positions within the string, rather than sliding a fixed-sized window across it. "
                    },
                    {
                        "username": "streetcoder123",
                        "content": "I\\'m confused about the part that says, \"If there are multiple, return the substring of the earliest occurrence.\"  Should we return the longest string or the first occurence of a substring?  These seems a little ambiguous.  "
                    },
                    {
                        "username": "RahulNauni",
                        "content": "Return longest that comes earliest. Here multiple means, longest substrings with same length."
                    }
                ]
            },
            {
                "id": 1930538,
                "content": [
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "This should be a medium problem in my opinion."
                    },
                    {
                        "username": "firefly1",
                        "content": "true"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Even I was thinking the same"
                    },
                    {
                        "username": "prepat21",
                        "content": "this is basically a version of maximum contiguous subarray sum"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Petition to change this to `Medium` difficulty in the feedback."
                    },
                    {
                        "username": "blank_1729",
                        "content": "why does this have sliding window tag anyways?"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "First problem with leetcode and competitive coding and now I rethink my decision \\uD83D\\uDE22"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Is sliding window technique possible in this scenario? ( I think sliding window is only possible if there is a scenario when we need to shrink the window back else not)\nMuch of the tags in the solutions aren't sliding window."
                    },
                    {
                        "username": "madpoly",
                        "content": "yall really gotta chill with the examples only showing one letter group and midway the tests there can be more. I am sure the question indicates nothing like that but I built my solution around detecting only up to 1 letter group. Need to rework it. No biggie but wish examples showed something a bit complex."
                    },
                    {
                        "username": "Adithya_pillai",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence\". \\nI guess it should be changed as \"If there are multiple substrings of same length, return the substring of the earliest occurrence\""
                    },
                    {
                        "username": "frozennuts",
                        "content": "I did this entire thing without the bit manipulation operator, I want to actually die it literately took me 4 days T_T"
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It does not comes under sliding window approach ..! I am not able to understand how can we solve this if\\nwe are not dealing with a contiguous substring. We need to consider all possible substrings of the input string and check if each substring meets the criteria of being \"nice\". It requires examining substrings at different positions within the string, rather than sliding a fixed-sized window across it. "
                    },
                    {
                        "username": "streetcoder123",
                        "content": "I\\'m confused about the part that says, \"If there are multiple, return the substring of the earliest occurrence.\"  Should we return the longest string or the first occurence of a substring?  These seems a little ambiguous.  "
                    },
                    {
                        "username": "RahulNauni",
                        "content": "Return longest that comes earliest. Here multiple means, longest substrings with same length."
                    }
                ]
            },
            {
                "id": 1983373,
                "content": [
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "This should be a medium problem in my opinion."
                    },
                    {
                        "username": "firefly1",
                        "content": "true"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Even I was thinking the same"
                    },
                    {
                        "username": "prepat21",
                        "content": "this is basically a version of maximum contiguous subarray sum"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Petition to change this to `Medium` difficulty in the feedback."
                    },
                    {
                        "username": "blank_1729",
                        "content": "why does this have sliding window tag anyways?"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "First problem with leetcode and competitive coding and now I rethink my decision \\uD83D\\uDE22"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Is sliding window technique possible in this scenario? ( I think sliding window is only possible if there is a scenario when we need to shrink the window back else not)\nMuch of the tags in the solutions aren't sliding window."
                    },
                    {
                        "username": "madpoly",
                        "content": "yall really gotta chill with the examples only showing one letter group and midway the tests there can be more. I am sure the question indicates nothing like that but I built my solution around detecting only up to 1 letter group. Need to rework it. No biggie but wish examples showed something a bit complex."
                    },
                    {
                        "username": "Adithya_pillai",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence\". \\nI guess it should be changed as \"If there are multiple substrings of same length, return the substring of the earliest occurrence\""
                    },
                    {
                        "username": "frozennuts",
                        "content": "I did this entire thing without the bit manipulation operator, I want to actually die it literately took me 4 days T_T"
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It does not comes under sliding window approach ..! I am not able to understand how can we solve this if\\nwe are not dealing with a contiguous substring. We need to consider all possible substrings of the input string and check if each substring meets the criteria of being \"nice\". It requires examining substrings at different positions within the string, rather than sliding a fixed-sized window across it. "
                    },
                    {
                        "username": "streetcoder123",
                        "content": "I\\'m confused about the part that says, \"If there are multiple, return the substring of the earliest occurrence.\"  Should we return the longest string or the first occurence of a substring?  These seems a little ambiguous.  "
                    },
                    {
                        "username": "RahulNauni",
                        "content": "Return longest that comes earliest. Here multiple means, longest substrings with same length."
                    }
                ]
            },
            {
                "id": 1964272,
                "content": [
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "This should be a medium problem in my opinion."
                    },
                    {
                        "username": "firefly1",
                        "content": "true"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Even I was thinking the same"
                    },
                    {
                        "username": "prepat21",
                        "content": "this is basically a version of maximum contiguous subarray sum"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Petition to change this to `Medium` difficulty in the feedback."
                    },
                    {
                        "username": "blank_1729",
                        "content": "why does this have sliding window tag anyways?"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "First problem with leetcode and competitive coding and now I rethink my decision \\uD83D\\uDE22"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Is sliding window technique possible in this scenario? ( I think sliding window is only possible if there is a scenario when we need to shrink the window back else not)\nMuch of the tags in the solutions aren't sliding window."
                    },
                    {
                        "username": "madpoly",
                        "content": "yall really gotta chill with the examples only showing one letter group and midway the tests there can be more. I am sure the question indicates nothing like that but I built my solution around detecting only up to 1 letter group. Need to rework it. No biggie but wish examples showed something a bit complex."
                    },
                    {
                        "username": "Adithya_pillai",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence\". \\nI guess it should be changed as \"If there are multiple substrings of same length, return the substring of the earliest occurrence\""
                    },
                    {
                        "username": "frozennuts",
                        "content": "I did this entire thing without the bit manipulation operator, I want to actually die it literately took me 4 days T_T"
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It does not comes under sliding window approach ..! I am not able to understand how can we solve this if\\nwe are not dealing with a contiguous substring. We need to consider all possible substrings of the input string and check if each substring meets the criteria of being \"nice\". It requires examining substrings at different positions within the string, rather than sliding a fixed-sized window across it. "
                    },
                    {
                        "username": "streetcoder123",
                        "content": "I\\'m confused about the part that says, \"If there are multiple, return the substring of the earliest occurrence.\"  Should we return the longest string or the first occurence of a substring?  These seems a little ambiguous.  "
                    },
                    {
                        "username": "RahulNauni",
                        "content": "Return longest that comes earliest. Here multiple means, longest substrings with same length."
                    }
                ]
            },
            {
                "id": 1906303,
                "content": [
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "This should be a medium problem in my opinion."
                    },
                    {
                        "username": "firefly1",
                        "content": "true"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Even I was thinking the same"
                    },
                    {
                        "username": "prepat21",
                        "content": "this is basically a version of maximum contiguous subarray sum"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Petition to change this to `Medium` difficulty in the feedback."
                    },
                    {
                        "username": "blank_1729",
                        "content": "why does this have sliding window tag anyways?"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "First problem with leetcode and competitive coding and now I rethink my decision \\uD83D\\uDE22"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Is sliding window technique possible in this scenario? ( I think sliding window is only possible if there is a scenario when we need to shrink the window back else not)\nMuch of the tags in the solutions aren't sliding window."
                    },
                    {
                        "username": "madpoly",
                        "content": "yall really gotta chill with the examples only showing one letter group and midway the tests there can be more. I am sure the question indicates nothing like that but I built my solution around detecting only up to 1 letter group. Need to rework it. No biggie but wish examples showed something a bit complex."
                    },
                    {
                        "username": "Adithya_pillai",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence\". \\nI guess it should be changed as \"If there are multiple substrings of same length, return the substring of the earliest occurrence\""
                    },
                    {
                        "username": "frozennuts",
                        "content": "I did this entire thing without the bit manipulation operator, I want to actually die it literately took me 4 days T_T"
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It does not comes under sliding window approach ..! I am not able to understand how can we solve this if\\nwe are not dealing with a contiguous substring. We need to consider all possible substrings of the input string and check if each substring meets the criteria of being \"nice\". It requires examining substrings at different positions within the string, rather than sliding a fixed-sized window across it. "
                    },
                    {
                        "username": "streetcoder123",
                        "content": "I\\'m confused about the part that says, \"If there are multiple, return the substring of the earliest occurrence.\"  Should we return the longest string or the first occurence of a substring?  These seems a little ambiguous.  "
                    },
                    {
                        "username": "RahulNauni",
                        "content": "Return longest that comes earliest. Here multiple means, longest substrings with same length."
                    }
                ]
            },
            {
                "id": 1732799,
                "content": [
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "This should be a medium problem in my opinion."
                    },
                    {
                        "username": "firefly1",
                        "content": "true"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Even I was thinking the same"
                    },
                    {
                        "username": "prepat21",
                        "content": "this is basically a version of maximum contiguous subarray sum"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Petition to change this to `Medium` difficulty in the feedback."
                    },
                    {
                        "username": "blank_1729",
                        "content": "why does this have sliding window tag anyways?"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "First problem with leetcode and competitive coding and now I rethink my decision \\uD83D\\uDE22"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Is sliding window technique possible in this scenario? ( I think sliding window is only possible if there is a scenario when we need to shrink the window back else not)\nMuch of the tags in the solutions aren't sliding window."
                    },
                    {
                        "username": "madpoly",
                        "content": "yall really gotta chill with the examples only showing one letter group and midway the tests there can be more. I am sure the question indicates nothing like that but I built my solution around detecting only up to 1 letter group. Need to rework it. No biggie but wish examples showed something a bit complex."
                    },
                    {
                        "username": "Adithya_pillai",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence\". \\nI guess it should be changed as \"If there are multiple substrings of same length, return the substring of the earliest occurrence\""
                    },
                    {
                        "username": "frozennuts",
                        "content": "I did this entire thing without the bit manipulation operator, I want to actually die it literately took me 4 days T_T"
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It does not comes under sliding window approach ..! I am not able to understand how can we solve this if\\nwe are not dealing with a contiguous substring. We need to consider all possible substrings of the input string and check if each substring meets the criteria of being \"nice\". It requires examining substrings at different positions within the string, rather than sliding a fixed-sized window across it. "
                    },
                    {
                        "username": "streetcoder123",
                        "content": "I\\'m confused about the part that says, \"If there are multiple, return the substring of the earliest occurrence.\"  Should we return the longest string or the first occurence of a substring?  These seems a little ambiguous.  "
                    },
                    {
                        "username": "RahulNauni",
                        "content": "Return longest that comes earliest. Here multiple means, longest substrings with same length."
                    }
                ]
            },
            {
                "id": 1862411,
                "content": [
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "This should be a medium problem in my opinion."
                    },
                    {
                        "username": "firefly1",
                        "content": "true"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Even I was thinking the same"
                    },
                    {
                        "username": "prepat21",
                        "content": "this is basically a version of maximum contiguous subarray sum"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Petition to change this to `Medium` difficulty in the feedback."
                    },
                    {
                        "username": "blank_1729",
                        "content": "why does this have sliding window tag anyways?"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "First problem with leetcode and competitive coding and now I rethink my decision \\uD83D\\uDE22"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Is sliding window technique possible in this scenario? ( I think sliding window is only possible if there is a scenario when we need to shrink the window back else not)\nMuch of the tags in the solutions aren't sliding window."
                    },
                    {
                        "username": "madpoly",
                        "content": "yall really gotta chill with the examples only showing one letter group and midway the tests there can be more. I am sure the question indicates nothing like that but I built my solution around detecting only up to 1 letter group. Need to rework it. No biggie but wish examples showed something a bit complex."
                    },
                    {
                        "username": "Adithya_pillai",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence\". \\nI guess it should be changed as \"If there are multiple substrings of same length, return the substring of the earliest occurrence\""
                    },
                    {
                        "username": "frozennuts",
                        "content": "I did this entire thing without the bit manipulation operator, I want to actually die it literately took me 4 days T_T"
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It does not comes under sliding window approach ..! I am not able to understand how can we solve this if\\nwe are not dealing with a contiguous substring. We need to consider all possible substrings of the input string and check if each substring meets the criteria of being \"nice\". It requires examining substrings at different positions within the string, rather than sliding a fixed-sized window across it. "
                    },
                    {
                        "username": "streetcoder123",
                        "content": "I\\'m confused about the part that says, \"If there are multiple, return the substring of the earliest occurrence.\"  Should we return the longest string or the first occurence of a substring?  These seems a little ambiguous.  "
                    },
                    {
                        "username": "RahulNauni",
                        "content": "Return longest that comes earliest. Here multiple means, longest substrings with same length."
                    }
                ]
            },
            {
                "id": 1868785,
                "content": [
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "This should be a medium problem in my opinion."
                    },
                    {
                        "username": "firefly1",
                        "content": "true"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Even I was thinking the same"
                    },
                    {
                        "username": "prepat21",
                        "content": "this is basically a version of maximum contiguous subarray sum"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Petition to change this to `Medium` difficulty in the feedback."
                    },
                    {
                        "username": "blank_1729",
                        "content": "why does this have sliding window tag anyways?"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "First problem with leetcode and competitive coding and now I rethink my decision \\uD83D\\uDE22"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Is sliding window technique possible in this scenario? ( I think sliding window is only possible if there is a scenario when we need to shrink the window back else not)\nMuch of the tags in the solutions aren't sliding window."
                    },
                    {
                        "username": "madpoly",
                        "content": "yall really gotta chill with the examples only showing one letter group and midway the tests there can be more. I am sure the question indicates nothing like that but I built my solution around detecting only up to 1 letter group. Need to rework it. No biggie but wish examples showed something a bit complex."
                    },
                    {
                        "username": "Adithya_pillai",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence\". \\nI guess it should be changed as \"If there are multiple substrings of same length, return the substring of the earliest occurrence\""
                    },
                    {
                        "username": "frozennuts",
                        "content": "I did this entire thing without the bit manipulation operator, I want to actually die it literately took me 4 days T_T"
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It does not comes under sliding window approach ..! I am not able to understand how can we solve this if\\nwe are not dealing with a contiguous substring. We need to consider all possible substrings of the input string and check if each substring meets the criteria of being \"nice\". It requires examining substrings at different positions within the string, rather than sliding a fixed-sized window across it. "
                    },
                    {
                        "username": "streetcoder123",
                        "content": "I\\'m confused about the part that says, \"If there are multiple, return the substring of the earliest occurrence.\"  Should we return the longest string or the first occurence of a substring?  These seems a little ambiguous.  "
                    },
                    {
                        "username": "RahulNauni",
                        "content": "Return longest that comes earliest. Here multiple means, longest substrings with same length."
                    }
                ]
            },
            {
                "id": 1794565,
                "content": [
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "This should be a medium problem in my opinion."
                    },
                    {
                        "username": "firefly1",
                        "content": "true"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Even I was thinking the same"
                    },
                    {
                        "username": "prepat21",
                        "content": "this is basically a version of maximum contiguous subarray sum"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Petition to change this to `Medium` difficulty in the feedback."
                    },
                    {
                        "username": "blank_1729",
                        "content": "why does this have sliding window tag anyways?"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "First problem with leetcode and competitive coding and now I rethink my decision \\uD83D\\uDE22"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Is sliding window technique possible in this scenario? ( I think sliding window is only possible if there is a scenario when we need to shrink the window back else not)\nMuch of the tags in the solutions aren't sliding window."
                    },
                    {
                        "username": "madpoly",
                        "content": "yall really gotta chill with the examples only showing one letter group and midway the tests there can be more. I am sure the question indicates nothing like that but I built my solution around detecting only up to 1 letter group. Need to rework it. No biggie but wish examples showed something a bit complex."
                    },
                    {
                        "username": "Adithya_pillai",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence\". \\nI guess it should be changed as \"If there are multiple substrings of same length, return the substring of the earliest occurrence\""
                    },
                    {
                        "username": "frozennuts",
                        "content": "I did this entire thing without the bit manipulation operator, I want to actually die it literately took me 4 days T_T"
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It does not comes under sliding window approach ..! I am not able to understand how can we solve this if\\nwe are not dealing with a contiguous substring. We need to consider all possible substrings of the input string and check if each substring meets the criteria of being \"nice\". It requires examining substrings at different positions within the string, rather than sliding a fixed-sized window across it. "
                    },
                    {
                        "username": "streetcoder123",
                        "content": "I\\'m confused about the part that says, \"If there are multiple, return the substring of the earliest occurrence.\"  Should we return the longest string or the first occurence of a substring?  These seems a little ambiguous.  "
                    },
                    {
                        "username": "RahulNauni",
                        "content": "Return longest that comes earliest. Here multiple means, longest substrings with same length."
                    }
                ]
            },
            {
                "id": 1761605,
                "content": [
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "This should be a medium problem in my opinion."
                    },
                    {
                        "username": "firefly1",
                        "content": "true"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Even I was thinking the same"
                    },
                    {
                        "username": "prepat21",
                        "content": "this is basically a version of maximum contiguous subarray sum"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Petition to change this to `Medium` difficulty in the feedback."
                    },
                    {
                        "username": "blank_1729",
                        "content": "why does this have sliding window tag anyways?"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "First problem with leetcode and competitive coding and now I rethink my decision \\uD83D\\uDE22"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Is sliding window technique possible in this scenario? ( I think sliding window is only possible if there is a scenario when we need to shrink the window back else not)\nMuch of the tags in the solutions aren't sliding window."
                    },
                    {
                        "username": "madpoly",
                        "content": "yall really gotta chill with the examples only showing one letter group and midway the tests there can be more. I am sure the question indicates nothing like that but I built my solution around detecting only up to 1 letter group. Need to rework it. No biggie but wish examples showed something a bit complex."
                    },
                    {
                        "username": "Adithya_pillai",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence\". \\nI guess it should be changed as \"If there are multiple substrings of same length, return the substring of the earliest occurrence\""
                    },
                    {
                        "username": "frozennuts",
                        "content": "I did this entire thing without the bit manipulation operator, I want to actually die it literately took me 4 days T_T"
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It does not comes under sliding window approach ..! I am not able to understand how can we solve this if\\nwe are not dealing with a contiguous substring. We need to consider all possible substrings of the input string and check if each substring meets the criteria of being \"nice\". It requires examining substrings at different positions within the string, rather than sliding a fixed-sized window across it. "
                    },
                    {
                        "username": "streetcoder123",
                        "content": "I\\'m confused about the part that says, \"If there are multiple, return the substring of the earliest occurrence.\"  Should we return the longest string or the first occurence of a substring?  These seems a little ambiguous.  "
                    },
                    {
                        "username": "RahulNauni",
                        "content": "Return longest that comes earliest. Here multiple means, longest substrings with same length."
                    }
                ]
            },
            {
                "id": 1825544,
                "content": [
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "This should be a medium problem in my opinion."
                    },
                    {
                        "username": "firefly1",
                        "content": "true"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Even I was thinking the same"
                    },
                    {
                        "username": "prepat21",
                        "content": "this is basically a version of maximum contiguous subarray sum"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Petition to change this to `Medium` difficulty in the feedback."
                    },
                    {
                        "username": "blank_1729",
                        "content": "why does this have sliding window tag anyways?"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "First problem with leetcode and competitive coding and now I rethink my decision \\uD83D\\uDE22"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Is sliding window technique possible in this scenario? ( I think sliding window is only possible if there is a scenario when we need to shrink the window back else not)\nMuch of the tags in the solutions aren't sliding window."
                    },
                    {
                        "username": "madpoly",
                        "content": "yall really gotta chill with the examples only showing one letter group and midway the tests there can be more. I am sure the question indicates nothing like that but I built my solution around detecting only up to 1 letter group. Need to rework it. No biggie but wish examples showed something a bit complex."
                    },
                    {
                        "username": "Adithya_pillai",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence\". \\nI guess it should be changed as \"If there are multiple substrings of same length, return the substring of the earliest occurrence\""
                    },
                    {
                        "username": "frozennuts",
                        "content": "I did this entire thing without the bit manipulation operator, I want to actually die it literately took me 4 days T_T"
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It does not comes under sliding window approach ..! I am not able to understand how can we solve this if\\nwe are not dealing with a contiguous substring. We need to consider all possible substrings of the input string and check if each substring meets the criteria of being \"nice\". It requires examining substrings at different positions within the string, rather than sliding a fixed-sized window across it. "
                    },
                    {
                        "username": "streetcoder123",
                        "content": "I\\'m confused about the part that says, \"If there are multiple, return the substring of the earliest occurrence.\"  Should we return the longest string or the first occurence of a substring?  These seems a little ambiguous.  "
                    },
                    {
                        "username": "RahulNauni",
                        "content": "Return longest that comes earliest. Here multiple means, longest substrings with same length."
                    }
                ]
            },
            {
                "id": 1930538,
                "content": [
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "This should be a medium problem in my opinion."
                    },
                    {
                        "username": "firefly1",
                        "content": "true"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Even I was thinking the same"
                    },
                    {
                        "username": "prepat21",
                        "content": "this is basically a version of maximum contiguous subarray sum"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Petition to change this to `Medium` difficulty in the feedback."
                    },
                    {
                        "username": "blank_1729",
                        "content": "why does this have sliding window tag anyways?"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "First problem with leetcode and competitive coding and now I rethink my decision \\uD83D\\uDE22"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Is sliding window technique possible in this scenario? ( I think sliding window is only possible if there is a scenario when we need to shrink the window back else not)\nMuch of the tags in the solutions aren't sliding window."
                    },
                    {
                        "username": "madpoly",
                        "content": "yall really gotta chill with the examples only showing one letter group and midway the tests there can be more. I am sure the question indicates nothing like that but I built my solution around detecting only up to 1 letter group. Need to rework it. No biggie but wish examples showed something a bit complex."
                    },
                    {
                        "username": "Adithya_pillai",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence\". \\nI guess it should be changed as \"If there are multiple substrings of same length, return the substring of the earliest occurrence\""
                    },
                    {
                        "username": "frozennuts",
                        "content": "I did this entire thing without the bit manipulation operator, I want to actually die it literately took me 4 days T_T"
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It does not comes under sliding window approach ..! I am not able to understand how can we solve this if\\nwe are not dealing with a contiguous substring. We need to consider all possible substrings of the input string and check if each substring meets the criteria of being \"nice\". It requires examining substrings at different positions within the string, rather than sliding a fixed-sized window across it. "
                    },
                    {
                        "username": "streetcoder123",
                        "content": "I\\'m confused about the part that says, \"If there are multiple, return the substring of the earliest occurrence.\"  Should we return the longest string or the first occurence of a substring?  These seems a little ambiguous.  "
                    },
                    {
                        "username": "RahulNauni",
                        "content": "Return longest that comes earliest. Here multiple means, longest substrings with same length."
                    }
                ]
            },
            {
                "id": 1983373,
                "content": [
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "This should be a medium problem in my opinion."
                    },
                    {
                        "username": "firefly1",
                        "content": "true"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Even I was thinking the same"
                    },
                    {
                        "username": "prepat21",
                        "content": "this is basically a version of maximum contiguous subarray sum"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Petition to change this to `Medium` difficulty in the feedback."
                    },
                    {
                        "username": "blank_1729",
                        "content": "why does this have sliding window tag anyways?"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "First problem with leetcode and competitive coding and now I rethink my decision \\uD83D\\uDE22"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Is sliding window technique possible in this scenario? ( I think sliding window is only possible if there is a scenario when we need to shrink the window back else not)\nMuch of the tags in the solutions aren't sliding window."
                    },
                    {
                        "username": "madpoly",
                        "content": "yall really gotta chill with the examples only showing one letter group and midway the tests there can be more. I am sure the question indicates nothing like that but I built my solution around detecting only up to 1 letter group. Need to rework it. No biggie but wish examples showed something a bit complex."
                    },
                    {
                        "username": "Adithya_pillai",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence\". \\nI guess it should be changed as \"If there are multiple substrings of same length, return the substring of the earliest occurrence\""
                    },
                    {
                        "username": "frozennuts",
                        "content": "I did this entire thing without the bit manipulation operator, I want to actually die it literately took me 4 days T_T"
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It does not comes under sliding window approach ..! I am not able to understand how can we solve this if\\nwe are not dealing with a contiguous substring. We need to consider all possible substrings of the input string and check if each substring meets the criteria of being \"nice\". It requires examining substrings at different positions within the string, rather than sliding a fixed-sized window across it. "
                    },
                    {
                        "username": "streetcoder123",
                        "content": "I\\'m confused about the part that says, \"If there are multiple, return the substring of the earliest occurrence.\"  Should we return the longest string or the first occurence of a substring?  These seems a little ambiguous.  "
                    },
                    {
                        "username": "RahulNauni",
                        "content": "Return longest that comes earliest. Here multiple means, longest substrings with same length."
                    }
                ]
            },
            {
                "id": 1964272,
                "content": [
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "This should be a medium problem in my opinion."
                    },
                    {
                        "username": "firefly1",
                        "content": "true"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Even I was thinking the same"
                    },
                    {
                        "username": "prepat21",
                        "content": "this is basically a version of maximum contiguous subarray sum"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Petition to change this to `Medium` difficulty in the feedback."
                    },
                    {
                        "username": "blank_1729",
                        "content": "why does this have sliding window tag anyways?"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "First problem with leetcode and competitive coding and now I rethink my decision \\uD83D\\uDE22"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Is sliding window technique possible in this scenario? ( I think sliding window is only possible if there is a scenario when we need to shrink the window back else not)\nMuch of the tags in the solutions aren't sliding window."
                    },
                    {
                        "username": "madpoly",
                        "content": "yall really gotta chill with the examples only showing one letter group and midway the tests there can be more. I am sure the question indicates nothing like that but I built my solution around detecting only up to 1 letter group. Need to rework it. No biggie but wish examples showed something a bit complex."
                    },
                    {
                        "username": "Adithya_pillai",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence\". \\nI guess it should be changed as \"If there are multiple substrings of same length, return the substring of the earliest occurrence\""
                    },
                    {
                        "username": "frozennuts",
                        "content": "I did this entire thing without the bit manipulation operator, I want to actually die it literately took me 4 days T_T"
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It does not comes under sliding window approach ..! I am not able to understand how can we solve this if\\nwe are not dealing with a contiguous substring. We need to consider all possible substrings of the input string and check if each substring meets the criteria of being \"nice\". It requires examining substrings at different positions within the string, rather than sliding a fixed-sized window across it. "
                    },
                    {
                        "username": "streetcoder123",
                        "content": "I\\'m confused about the part that says, \"If there are multiple, return the substring of the earliest occurrence.\"  Should we return the longest string or the first occurence of a substring?  These seems a little ambiguous.  "
                    },
                    {
                        "username": "RahulNauni",
                        "content": "Return longest that comes earliest. Here multiple means, longest substrings with same length."
                    }
                ]
            },
            {
                "id": 1906303,
                "content": [
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "This should be a medium problem in my opinion."
                    },
                    {
                        "username": "firefly1",
                        "content": "true"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Even I was thinking the same"
                    },
                    {
                        "username": "prepat21",
                        "content": "this is basically a version of maximum contiguous subarray sum"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Petition to change this to `Medium` difficulty in the feedback."
                    },
                    {
                        "username": "blank_1729",
                        "content": "why does this have sliding window tag anyways?"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "First problem with leetcode and competitive coding and now I rethink my decision \\uD83D\\uDE22"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Is sliding window technique possible in this scenario? ( I think sliding window is only possible if there is a scenario when we need to shrink the window back else not)\nMuch of the tags in the solutions aren't sliding window."
                    },
                    {
                        "username": "madpoly",
                        "content": "yall really gotta chill with the examples only showing one letter group and midway the tests there can be more. I am sure the question indicates nothing like that but I built my solution around detecting only up to 1 letter group. Need to rework it. No biggie but wish examples showed something a bit complex."
                    },
                    {
                        "username": "Adithya_pillai",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence\". \\nI guess it should be changed as \"If there are multiple substrings of same length, return the substring of the earliest occurrence\""
                    },
                    {
                        "username": "frozennuts",
                        "content": "I did this entire thing without the bit manipulation operator, I want to actually die it literately took me 4 days T_T"
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It does not comes under sliding window approach ..! I am not able to understand how can we solve this if\\nwe are not dealing with a contiguous substring. We need to consider all possible substrings of the input string and check if each substring meets the criteria of being \"nice\". It requires examining substrings at different positions within the string, rather than sliding a fixed-sized window across it. "
                    },
                    {
                        "username": "streetcoder123",
                        "content": "I\\'m confused about the part that says, \"If there are multiple, return the substring of the earliest occurrence.\"  Should we return the longest string or the first occurence of a substring?  These seems a little ambiguous.  "
                    },
                    {
                        "username": "RahulNauni",
                        "content": "Return longest that comes earliest. Here multiple means, longest substrings with same length."
                    }
                ]
            },
            {
                "id": 1771639,
                "content": [
                    {
                        "username": "L05tN0m4D",
                        "content": "Shouldn't this be solved with divide and conquer technique? As with decreasing sliding window it is O(n^2) solution"
                    },
                    {
                        "username": "Alcas1",
                        "content": "This is easily a medium wtf"
                    },
                    {
                        "username": "c4rtel",
                        "content": "lmfao that was not an easy, downvoted + bad."
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It is not easy problem even bruteforce approach need some skills and guts to move further \\nit is not a `easy ` problem change it to `medium`"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Only thing i see easy in the problem is Only its Contraints... Otherwise it is medium problem"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "This question seems like it can be solved using Stack not Sliding Window."
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "This is confusing, need more examples"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "This one\\'s pretty difficult..."
                    },
                    {
                        "username": "constantinemalykhin",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence.\"\\nSo, if we have s = \"cChH\" the earliest substring is \"cC\", but in tests expected the whole string \"cChH\"! Why is it expected to return the whole substring if we should return only the earliest?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you miss 1 requirement: the longest "
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "The problem is not easy or I am so stupid"
                    },
                    {
                        "username": "scor32k",
                        "content": "not easy though"
                    }
                ]
            },
            {
                "id": 2037528,
                "content": [
                    {
                        "username": "L05tN0m4D",
                        "content": "Shouldn't this be solved with divide and conquer technique? As with decreasing sliding window it is O(n^2) solution"
                    },
                    {
                        "username": "Alcas1",
                        "content": "This is easily a medium wtf"
                    },
                    {
                        "username": "c4rtel",
                        "content": "lmfao that was not an easy, downvoted + bad."
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It is not easy problem even bruteforce approach need some skills and guts to move further \\nit is not a `easy ` problem change it to `medium`"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Only thing i see easy in the problem is Only its Contraints... Otherwise it is medium problem"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "This question seems like it can be solved using Stack not Sliding Window."
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "This is confusing, need more examples"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "This one\\'s pretty difficult..."
                    },
                    {
                        "username": "constantinemalykhin",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence.\"\\nSo, if we have s = \"cChH\" the earliest substring is \"cC\", but in tests expected the whole string \"cChH\"! Why is it expected to return the whole substring if we should return only the earliest?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you miss 1 requirement: the longest "
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "The problem is not easy or I am so stupid"
                    },
                    {
                        "username": "scor32k",
                        "content": "not easy though"
                    }
                ]
            },
            {
                "id": 2013035,
                "content": [
                    {
                        "username": "L05tN0m4D",
                        "content": "Shouldn't this be solved with divide and conquer technique? As with decreasing sliding window it is O(n^2) solution"
                    },
                    {
                        "username": "Alcas1",
                        "content": "This is easily a medium wtf"
                    },
                    {
                        "username": "c4rtel",
                        "content": "lmfao that was not an easy, downvoted + bad."
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It is not easy problem even bruteforce approach need some skills and guts to move further \\nit is not a `easy ` problem change it to `medium`"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Only thing i see easy in the problem is Only its Contraints... Otherwise it is medium problem"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "This question seems like it can be solved using Stack not Sliding Window."
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "This is confusing, need more examples"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "This one\\'s pretty difficult..."
                    },
                    {
                        "username": "constantinemalykhin",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence.\"\\nSo, if we have s = \"cChH\" the earliest substring is \"cC\", but in tests expected the whole string \"cChH\"! Why is it expected to return the whole substring if we should return only the earliest?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you miss 1 requirement: the longest "
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "The problem is not easy or I am so stupid"
                    },
                    {
                        "username": "scor32k",
                        "content": "not easy though"
                    }
                ]
            },
            {
                "id": 1964276,
                "content": [
                    {
                        "username": "L05tN0m4D",
                        "content": "Shouldn't this be solved with divide and conquer technique? As with decreasing sliding window it is O(n^2) solution"
                    },
                    {
                        "username": "Alcas1",
                        "content": "This is easily a medium wtf"
                    },
                    {
                        "username": "c4rtel",
                        "content": "lmfao that was not an easy, downvoted + bad."
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It is not easy problem even bruteforce approach need some skills and guts to move further \\nit is not a `easy ` problem change it to `medium`"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Only thing i see easy in the problem is Only its Contraints... Otherwise it is medium problem"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "This question seems like it can be solved using Stack not Sliding Window."
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "This is confusing, need more examples"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "This one\\'s pretty difficult..."
                    },
                    {
                        "username": "constantinemalykhin",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence.\"\\nSo, if we have s = \"cChH\" the earliest substring is \"cC\", but in tests expected the whole string \"cChH\"! Why is it expected to return the whole substring if we should return only the earliest?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you miss 1 requirement: the longest "
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "The problem is not easy or I am so stupid"
                    },
                    {
                        "username": "scor32k",
                        "content": "not easy though"
                    }
                ]
            },
            {
                "id": 2048324,
                "content": [
                    {
                        "username": "L05tN0m4D",
                        "content": "Shouldn't this be solved with divide and conquer technique? As with decreasing sliding window it is O(n^2) solution"
                    },
                    {
                        "username": "Alcas1",
                        "content": "This is easily a medium wtf"
                    },
                    {
                        "username": "c4rtel",
                        "content": "lmfao that was not an easy, downvoted + bad."
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It is not easy problem even bruteforce approach need some skills and guts to move further \\nit is not a `easy ` problem change it to `medium`"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Only thing i see easy in the problem is Only its Contraints... Otherwise it is medium problem"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "This question seems like it can be solved using Stack not Sliding Window."
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "This is confusing, need more examples"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "This one\\'s pretty difficult..."
                    },
                    {
                        "username": "constantinemalykhin",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence.\"\\nSo, if we have s = \"cChH\" the earliest substring is \"cC\", but in tests expected the whole string \"cChH\"! Why is it expected to return the whole substring if we should return only the earliest?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you miss 1 requirement: the longest "
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "The problem is not easy or I am so stupid"
                    },
                    {
                        "username": "scor32k",
                        "content": "not easy though"
                    }
                ]
            },
            {
                "id": 2044013,
                "content": [
                    {
                        "username": "L05tN0m4D",
                        "content": "Shouldn't this be solved with divide and conquer technique? As with decreasing sliding window it is O(n^2) solution"
                    },
                    {
                        "username": "Alcas1",
                        "content": "This is easily a medium wtf"
                    },
                    {
                        "username": "c4rtel",
                        "content": "lmfao that was not an easy, downvoted + bad."
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It is not easy problem even bruteforce approach need some skills and guts to move further \\nit is not a `easy ` problem change it to `medium`"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Only thing i see easy in the problem is Only its Contraints... Otherwise it is medium problem"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "This question seems like it can be solved using Stack not Sliding Window."
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "This is confusing, need more examples"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "This one\\'s pretty difficult..."
                    },
                    {
                        "username": "constantinemalykhin",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence.\"\\nSo, if we have s = \"cChH\" the earliest substring is \"cC\", but in tests expected the whole string \"cChH\"! Why is it expected to return the whole substring if we should return only the earliest?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you miss 1 requirement: the longest "
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "The problem is not easy or I am so stupid"
                    },
                    {
                        "username": "scor32k",
                        "content": "not easy though"
                    }
                ]
            },
            {
                "id": 1996852,
                "content": [
                    {
                        "username": "L05tN0m4D",
                        "content": "Shouldn't this be solved with divide and conquer technique? As with decreasing sliding window it is O(n^2) solution"
                    },
                    {
                        "username": "Alcas1",
                        "content": "This is easily a medium wtf"
                    },
                    {
                        "username": "c4rtel",
                        "content": "lmfao that was not an easy, downvoted + bad."
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It is not easy problem even bruteforce approach need some skills and guts to move further \\nit is not a `easy ` problem change it to `medium`"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Only thing i see easy in the problem is Only its Contraints... Otherwise it is medium problem"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "This question seems like it can be solved using Stack not Sliding Window."
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "This is confusing, need more examples"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "This one\\'s pretty difficult..."
                    },
                    {
                        "username": "constantinemalykhin",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence.\"\\nSo, if we have s = \"cChH\" the earliest substring is \"cC\", but in tests expected the whole string \"cChH\"! Why is it expected to return the whole substring if we should return only the earliest?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you miss 1 requirement: the longest "
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "The problem is not easy or I am so stupid"
                    },
                    {
                        "username": "scor32k",
                        "content": "not easy though"
                    }
                ]
            },
            {
                "id": 1992026,
                "content": [
                    {
                        "username": "L05tN0m4D",
                        "content": "Shouldn't this be solved with divide and conquer technique? As with decreasing sliding window it is O(n^2) solution"
                    },
                    {
                        "username": "Alcas1",
                        "content": "This is easily a medium wtf"
                    },
                    {
                        "username": "c4rtel",
                        "content": "lmfao that was not an easy, downvoted + bad."
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It is not easy problem even bruteforce approach need some skills and guts to move further \\nit is not a `easy ` problem change it to `medium`"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Only thing i see easy in the problem is Only its Contraints... Otherwise it is medium problem"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "This question seems like it can be solved using Stack not Sliding Window."
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "This is confusing, need more examples"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "This one\\'s pretty difficult..."
                    },
                    {
                        "username": "constantinemalykhin",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence.\"\\nSo, if we have s = \"cChH\" the earliest substring is \"cC\", but in tests expected the whole string \"cChH\"! Why is it expected to return the whole substring if we should return only the earliest?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you miss 1 requirement: the longest "
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "The problem is not easy or I am so stupid"
                    },
                    {
                        "username": "scor32k",
                        "content": "not easy though"
                    }
                ]
            },
            {
                "id": 1991365,
                "content": [
                    {
                        "username": "L05tN0m4D",
                        "content": "Shouldn't this be solved with divide and conquer technique? As with decreasing sliding window it is O(n^2) solution"
                    },
                    {
                        "username": "Alcas1",
                        "content": "This is easily a medium wtf"
                    },
                    {
                        "username": "c4rtel",
                        "content": "lmfao that was not an easy, downvoted + bad."
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It is not easy problem even bruteforce approach need some skills and guts to move further \\nit is not a `easy ` problem change it to `medium`"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Only thing i see easy in the problem is Only its Contraints... Otherwise it is medium problem"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "This question seems like it can be solved using Stack not Sliding Window."
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "This is confusing, need more examples"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "This one\\'s pretty difficult..."
                    },
                    {
                        "username": "constantinemalykhin",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence.\"\\nSo, if we have s = \"cChH\" the earliest substring is \"cC\", but in tests expected the whole string \"cChH\"! Why is it expected to return the whole substring if we should return only the earliest?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you miss 1 requirement: the longest "
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "The problem is not easy or I am so stupid"
                    },
                    {
                        "username": "scor32k",
                        "content": "not easy though"
                    }
                ]
            },
            {
                "id": 1958797,
                "content": [
                    {
                        "username": "L05tN0m4D",
                        "content": "Shouldn't this be solved with divide and conquer technique? As with decreasing sliding window it is O(n^2) solution"
                    },
                    {
                        "username": "Alcas1",
                        "content": "This is easily a medium wtf"
                    },
                    {
                        "username": "c4rtel",
                        "content": "lmfao that was not an easy, downvoted + bad."
                    },
                    {
                        "username": "Praneethpathipati",
                        "content": "It is not easy problem even bruteforce approach need some skills and guts to move further \\nit is not a `easy ` problem change it to `medium`"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Only thing i see easy in the problem is Only its Contraints... Otherwise it is medium problem"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "This question seems like it can be solved using Stack not Sliding Window."
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "This is confusing, need more examples"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "This one\\'s pretty difficult..."
                    },
                    {
                        "username": "constantinemalykhin",
                        "content": "\"If there are multiple, return the substring of the earliest occurrence.\"\\nSo, if we have s = \"cChH\" the earliest substring is \"cC\", but in tests expected the whole string \"cChH\"! Why is it expected to return the whole substring if we should return only the earliest?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you miss 1 requirement: the longest "
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "The problem is not easy or I am so stupid"
                    },
                    {
                        "username": "scor32k",
                        "content": "not easy though"
                    }
                ]
            }
        ]
    }
]