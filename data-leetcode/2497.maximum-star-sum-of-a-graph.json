[
    {
        "title": "Maximum Star Sum of a Graph",
        "question_content": "There is an undirected graph consisting of n nodes numbered from 0 to n - 1. You are given a 0-indexed integer array vals of length n where vals[i] denotes the value of the ith node.\nYou are also given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.\nA star graph is a subgraph of the given graph having a center node containing 0 or more neighbors. In other words, it is a subset of edges of the given graph such that there exists a common node for all edges.\nThe image below shows star graphs with 3 and 4 neighbors respectively, centered at the blue node.\nThe star sum is the sum of the values of all the nodes present in the star graph.\nGiven an integer k, return the maximum star sum of a star graph containing at most k edges.\n&nbsp;\nExample 1:\n\nInput: vals = [1,2,3,4,10,-10,-20], edges = [[0,1],[1,2],[1,3],[3,4],[3,5],[3,6]], k = 2\nOutput: 16\nExplanation: The above diagram represents the input graph.\nThe star graph with the maximum star sum is denoted by blue. It is centered at 3 and includes its neighbors 1 and 4.\nIt can be shown it is not possible to get a star graph with a sum greater than 16.\n\nExample 2:\n\nInput: vals = [-5], edges = [], k = 0\nOutput: -5\nExplanation: There is only one possible star graph, which is node 0 itself.\nHence, we return -5.\n\n&nbsp;\nConstraints:\n\n\tn == vals.length\n\t1 <= n <= 105\n\t-104 <= vals[i] <= 104\n\t0 <= edges.length <= min(n * (n - 1) / 2, 105)\n\tedges[i].length == 2\n\t0 <= ai, bi <= n - 1\n\tai != bi\n\t0 <= k <= n - 1",
        "solutions": [
            {
                "id": 2897917,
                "title": "python-take-largest-positive-weights-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\n\\n**Comment.** Take at most `k` largest positive weights for each node.\\n\\n**Python #1.** Compact version.\\n```\\nclass Solution:\\n    def maxStarSum(self, v: List[int], edges: List[List[int]], k: int) -> int:\\n        \\n        g = defaultdict(set)\\n        for i,j in edges:\\n            if v[i] > 0 : g[j].add(i)\\n            if v[j] > 0 : g[i].add(j)\\n                \\n        return max(w + sum(sorted([v[j] for j in g[i]], reverse=True)[0:k])\\n                   for i,w in enumerate(v))\\n```\\n\\n**Python #2.** A more detailed solution.\\n```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        \\n        graph = defaultdict(set)\\n        for i,j in edges:\\n            if vals[i] > 0 : graph[j].add(i)\\n            if vals[j] > 0 : graph[i].add(j)\\n            \\n        stars = []\\n        for i,v in enumerate(vals):\\n            vv = [vals[j] for j in graph[i]]\\n            vv.sort(reverse=True)\\n            stars.append(v + sum(vv[0:k]))\\n            \\n        return max(stars)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxStarSum(self, v: List[int], edges: List[List[int]], k: int) -> int:\\n        \\n        g = defaultdict(set)\\n        for i,j in edges:\\n            if v[i] > 0 : g[j].add(i)\\n            if v[j] > 0 : g[i].add(j)\\n                \\n        return max(w + sum(sorted([v[j] for j in g[i]], reverse=True)[0:k])\\n                   for i,w in enumerate(v))\\n```\n```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        \\n        graph = defaultdict(set)\\n        for i,j in edges:\\n            if vals[i] > 0 : graph[j].add(i)\\n            if vals[j] > 0 : graph[i].add(j)\\n            \\n        stars = []\\n        for i,v in enumerate(vals):\\n            vv = [vals[j] for j in graph[i]]\\n            vv.sort(reverse=True)\\n            stars.append(v + sum(vv[0:k]))\\n            \\n        return max(stars)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897910,
                "title": "very-easy-cpp-solution-with-explanation-priority-queue",
                "content": "\\n# Time Complextity \\n@deepeshdkpathak thanks for that\\n- creating an adjacency list = O(E) &\\n- traversing through all the nodes * [going through all the adjacent nodes of a specific node * (adding them to a priority queue) + emptying the priority queue which will have a size of K] = O(N * [No. of adj Nodes of a given node * (log(No. of adj nodes)) + K])\\n- combining these two we get\\n    -- O(E) + O(N * (ADJ * log(ADJ)+ K))\\n- where E is the number of edges and ADJ is the number of adjacent nodes of any specific node and K is already provided.\\n\\n# Space Complexity\\n-   O(N * ADJ)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        \\n        // create graph\\n        vector<vector<int>> g(n);\\n        for(auto e : edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        \\n        \\n        int ans = INT_MIN;\\n        \\n        // we going to each node and calculate max sum of at most k edges connected centered node\\n        // given question says maximum sum of node vals with at most k edges so we neglacting negaticve vals to connected centerd node \\n        for(int i = 0; i < n; i++) {\\n            priority_queue<int, vector<int>, greater<int>> pq;\\n            \\n            int tt = vals[i];  // adding centered node value\\n            \\n            for(int u : g[i]) {\\n                pq.push(vals[u]);              \\n                if(pq.size() > k) pq.pop();  // calculate max values of k nodes connected to centered node\\n            }\\n  \\n            while(!pq.empty()){ \\n                if(pq.top() > 0) tt += pq.top();  // we only add positive values. suppose centered node connected all -ve vals so in that case only centered node vals is max sum with zero edges\\n                pq.pop(); \\n            }\\n            \\n            ans = max(tt, ans);\\n        }\\n        \\n        return  ans;\\n    }\\n};\\n```\\n\\nIf you helped please like...\\nIf any suggestions please leave comment.\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        \\n        // create graph\\n        vector<vector<int>> g(n);\\n        for(auto e : edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        \\n        \\n        int ans = INT_MIN;\\n        \\n        // we going to each node and calculate max sum of at most k edges connected centered node\\n        // given question says maximum sum of node vals with at most k edges so we neglacting negaticve vals to connected centerd node \\n        for(int i = 0; i < n; i++) {\\n            priority_queue<int, vector<int>, greater<int>> pq;\\n            \\n            int tt = vals[i];  // adding centered node value\\n            \\n            for(int u : g[i]) {\\n                pq.push(vals[u]);              \\n                if(pq.size() > k) pq.pop();  // calculate max values of k nodes connected to centered node\\n            }\\n  \\n            while(!pq.empty()){ \\n                if(pq.top() > 0) tt += pq.top();  // we only add positive values. suppose centered node connected all -ve vals so in that case only centered node vals is max sum with zero edges\\n                pq.pop(); \\n            }\\n            \\n            ans = max(tt, ans);\\n        }\\n        \\n        return  ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897967,
                "title": "c-solution-using-dfs-priority-queue-very-simple-easy-to-understand",
                "content": "<b>Up Vote if you like the solution\\n```\\n/*\\nApproach is to traverse the graph to each node and at each node check for the max possible sum with at most k connected node.\\nAs it says max value and at most k nodes we need to skip -ve value as it will always redule the value.\\n\\nSteps:\\n1. create a graph using the edges given.\\n2. Traverse to each node using dfs.\\n    - On each node create a priority queue to get sum of the max k nodes values \\n    - Traverse to next connected node and get max possible value \\n    - return max value among current node and the max value recieved from its connected node.\\n*/\\n\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>> &g, vector<int> &vis, int node, int k, vector<int> &val){\\n        priority_queue<int> pq;\\n        int res = INT_MIN;\\n        vis[node] = 1;\\n        for(auto i: g[node] ){\\n            if(val[i] > 0) pq.push(val[i]);\\n            if(vis[i] == 0) res = max(res, dfs(g, vis, i, k, val));\\n        }\\n        int sum = val[node];            //sum stores the max possible value when node is considered as the centre\\n        while(k > 0 && pq.size() > 0){\\n            sum += pq.top();\\n            pq.pop();\\n            k--;\\n        }\\n        return max(sum, res);\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int ans = INT_MIN, n = vals.size();\\n        vector<vector<int>> g(n);\\n        vector<int> vis(n, 0);\\n        for(auto e: edges){ g[e[0]].push_back(e[1]);  g[e[1]].push_back(e[0]); }    //create graph                  \\n        for(int i = 0; i < n; ++i){  //traverse to all nodes, lope required as the graph may be dissconnected \\n            if(vis[i] == 0) ans = max(ans, dfs(g, vis, i, k, vals));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\nApproach is to traverse the graph to each node and at each node check for the max possible sum with at most k connected node.\\nAs it says max value and at most k nodes we need to skip -ve value as it will always redule the value.\\n\\nSteps:\\n1. create a graph using the edges given.\\n2. Traverse to each node using dfs.\\n    - On each node create a priority queue to get sum of the max k nodes values \\n    - Traverse to next connected node and get max possible value \\n    - return max value among current node and the max value recieved from its connected node.\\n*/\\n\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>> &g, vector<int> &vis, int node, int k, vector<int> &val){\\n        priority_queue<int> pq;\\n        int res = INT_MIN;\\n        vis[node] = 1;\\n        for(auto i: g[node] ){\\n            if(val[i] > 0) pq.push(val[i]);\\n            if(vis[i] == 0) res = max(res, dfs(g, vis, i, k, val));\\n        }\\n        int sum = val[node];            //sum stores the max possible value when node is considered as the centre\\n        while(k > 0 && pq.size() > 0){\\n            sum += pq.top();\\n            pq.pop();\\n            k--;\\n        }\\n        return max(sum, res);\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int ans = INT_MIN, n = vals.size();\\n        vector<vector<int>> g(n);\\n        vector<int> vis(n, 0);\\n        for(auto e: edges){ g[e[0]].push_back(e[1]);  g[e[1]].push_back(e[0]); }    //create graph                  \\n        for(int i = 0; i < n; ++i){  //traverse to all nodes, lope required as the graph may be dissconnected \\n            if(vis[i] == 0) ans = max(ans, dfs(g, vis, i, k, vals));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899105,
                "title": "java-adjacency-list-graph-priorityqueue-topk-easy-to-understand-50ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each node, we need it\\'s own value (can be negative) and it\\'s top k neighbor with positive values .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate the adjacency list graph first, and loop each node to get max start sum.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(V+E)\\ncreate and iterate over graph\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(V+E+k)\\nV+E to create graph\\nk size priority queue\\n\\n# Code\\n[50ms Submission](https://leetcode.com/problems/maximum-star-sum-of-a-graph/submissions/857816006/)\\n```java\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        int res = vals[0];\\n        if (k == 0) { // corner case\\n            for (var x : vals) res = Math.max(res, x);\\n            return res;\\n        }\\n\\n        // create graph\\n        int n = vals.length;\\n        List<Integer>[] g = new List[n];\\n        for (int i = 0; i < n; i++) g[i] = new ArrayList<>();\\n        for (var e : edges) {\\n            if (vals[e[1]] > 0) g[e[0]].add(vals[e[1]]);\\n            if (vals[e[0]] > 0) g[e[1]].add(vals[e[0]]);\\n        }\\n\\n        for (int i = 0; i < n; i++) res = Math.max(res, topK(g[i], vals[i], k));\\n        return res;\\n    }\\n\\n    private int topK(List<Integer> l, int res, int k) {\\n        Queue<Integer> q = new PriorityQueue<>();\\n        for (int x : l) {\\n            if (q.size() < k) q.offer(x);\\n            else if (x > q.peek()) {\\n                q.poll();\\n                q.offer(x);\\n            }\\n        }\\n\\n        while (!q.isEmpty()) res += q.poll();\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        int res = vals[0];\\n        if (k == 0) { // corner case\\n            for (var x : vals) res = Math.max(res, x);\\n            return res;\\n        }\\n\\n        // create graph\\n        int n = vals.length;\\n        List<Integer>[] g = new List[n];\\n        for (int i = 0; i < n; i++) g[i] = new ArrayList<>();\\n        for (var e : edges) {\\n            if (vals[e[1]] > 0) g[e[0]].add(vals[e[1]]);\\n            if (vals[e[0]] > 0) g[e[1]].add(vals[e[0]]);\\n        }\\n\\n        for (int i = 0; i < n; i++) res = Math.max(res, topK(g[i], vals[i], k));\\n        return res;\\n    }\\n\\n    private int topK(List<Integer> l, int res, int k) {\\n        Queue<Integer> q = new PriorityQueue<>();\\n        for (int x : l) {\\n            if (q.size() < k) q.offer(x);\\n            else if (x > q.peek()) {\\n                q.poll();\\n                q.offer(x);\\n            }\\n        }\\n\\n        while (!q.isEmpty()) res += q.poll();\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929160,
                "title": "simple-priorityqueue-solution-java",
                "content": "```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n    int max=-(int)1e9;\\n       int n=vals.length;\\n        for(int i=0;i<n;i++){\\n            max=Math.max(max,vals[i]);\\n        }\\n        //storing the adj list in list of priorityQueue of integer of vals(not edge nodes) for storing max\\n        //value of vals top\\n        List<PriorityQueue<Integer>> l=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            l.add(new PriorityQueue<>(Collections.reverseOrder()));\\n        }\\n        \\n        for(int p[]:edges){\\n            //storing nodes along with values(vals) of other nodes\\n            l.get(p[0]).add(vals[p[1]]);\\n            l.get(p[1]).add(vals[p[0]]);\\n        }\\n        for(int i=0;i<l.size();i++){\\n            if(l.get(i).size()==0)continue;\\n            PriorityQueue<Integer> p=l.get(i);\\n            int u=k;\\n            int sum=vals[i];\\n            while(p.size()>0 && u-->0){\\n                int it=p.poll();\\n                //everytime updating max\\n                max=Math.max(max,sum);\\n                sum+=it;  \\n            }\\n            max=Math.max(max,sum);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n    int max=-(int)1e9;\\n       int n=vals.length;\\n        for(int i=0;i<n;i++){\\n            max=Math.max(max,vals[i]);\\n        }\\n        //storing the adj list in list of priorityQueue of integer of vals(not edge nodes) for storing max\\n        //value of vals top\\n        List<PriorityQueue<Integer>> l=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            l.add(new PriorityQueue<>(Collections.reverseOrder()));\\n        }\\n        \\n        for(int p[]:edges){\\n            //storing nodes along with values(vals) of other nodes\\n            l.get(p[0]).add(vals[p[1]]);\\n            l.get(p[1]).add(vals[p[0]]);\\n        }\\n        for(int i=0;i<l.size();i++){\\n            if(l.get(i).size()==0)continue;\\n            PriorityQueue<Integer> p=l.get(i);\\n            int u=k;\\n            int sum=vals[i];\\n            while(p.size()>0 && u-->0){\\n                int it=p.poll();\\n                //everytime updating max\\n                max=Math.max(max,sum);\\n                sum+=it;  \\n            }\\n            max=Math.max(max,sum);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897938,
                "title": "min-heap-intuition",
                "content": "# Intuition 1:\\n > A star graph is a subgraph of the given graph having a center node containing 0 or more neighbors.\\n   \\n  This line of question gives a intuition that any `node` can be a `star node`.\\n    \\n# Intuition 2:\\n>  star graph containing at most k edges.\\n    \\nThis line states that we have to take atmost `k top value nodes` which are `positive` and directly connected to a node which is giving us hint of using a `heap`.\\n# Why we discard negative?? \\nBecause it will decrease the star sum of node which we don\\'t want.\\n    \\n **Combining Above Intuitions, we deduce following steps :**\\n    \\n   + We will make a graph where every node will have a `min-heap` to filter `<= top k largest` positive directly connected nodes.\\n   + We will also maintain a array where we will store sum of  top k positive neighbours corresponding to every node with the help of priority_queue \\n   + By following the above two steps, we will have star sum for every node & we will simply return maximum value among all star sum of nodes.\\n\\n# C++\\n     int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        vector<int> sum = vals;\\n        vector<priority_queue<int, vector<int> , greater<int>>> G(vals.size());\\n        for(auto e : edges){\\n            int u = e[0], v = e[1];\\n            \\n            if(vals[v] > 0){\\n                G[u].push(vals[v]);\\n                sum[u] += vals[v];\\n\\t\\t\\t\\t// Remove nodes and reduce sum if heap has > k nodes\\n                if(G[u].size() > k){\\n                    sum[u] -= G[u].top();\\n                    G[u].pop();\\n                }\\n            }\\n            \\n            if(vals[u] > 0){\\n                G[v].push(vals[u]);\\n                sum[v] += vals[u];\\n\\t\\t\\t\\t// Remove nodes and reduce sum if heap has > k nodes\\n                if(G[v].size() > k){\\n                    sum[v] -= G[v].top();\\n                    G[v].pop();\\n                }\\n            }   \\n        }\\n        return *max_element(begin(sum), end(sum));\\n    }\\n> Time - O(nlogn)\\n\\n> Space - O(n)",
                "solutionTags": [
                    "C"
                ],
                "code": "# Intuition 1:\\n > A star graph is a subgraph of the given graph having a center node containing 0 or more neighbors.\\n   \\n  This line of question gives a intuition that any `node` can be a `star node`.\\n    \\n# Intuition 2:\\n>  star graph containing at most k edges.\\n    \\nThis line states that we have to take atmost `k top value nodes` which are `positive` and directly connected to a node which is giving us hint of using a `heap`.\\n# Why we discard negative?? \\nBecause it will decrease the star sum of node which we don\\'t want.\\n    \\n **Combining Above Intuitions, we deduce following steps :**\\n    \\n   + We will make a graph where every node will have a `min-heap` to filter `<= top k largest` positive directly connected nodes.\\n   + We will also maintain a array where we will store sum of  top k positive neighbours corresponding to every node with the help of priority_queue \\n   + By following the above two steps, we will have star sum for every node & we will simply return maximum value among all star sum of nodes.\\n\\n# C++\\n     int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        vector<int> sum = vals;\\n        vector<priority_queue<int, vector<int> , greater<int>>> G(vals.size());\\n        for(auto e : edges){\\n            int u = e[0], v = e[1];\\n            \\n            if(vals[v] > 0){\\n                G[u].push(vals[v]);\\n                sum[u] += vals[v];\\n\\t\\t\\t\\t// Remove nodes and reduce sum if heap has > k nodes\\n                if(G[u].size() > k){\\n                    sum[u] -= G[u].top();\\n                    G[u].pop();\\n                }\\n            }\\n            \\n            if(vals[u] > 0){\\n                G[v].push(vals[u]);\\n                sum[v] += vals[u];\\n\\t\\t\\t\\t// Remove nodes and reduce sum if heap has > k nodes\\n                if(G[v].size() > k){\\n                    sum[v] -= G[v].top();\\n                    G[v].pop();\\n                }\\n            }   \\n        }\\n        return *max_element(begin(sum), end(sum));\\n    }\\n> Time - O(nlogn)\\n\\n> Space - O(n)",
                "codeTag": "Unknown"
            },
            {
                "id": 2898543,
                "title": "c-sorting-to-get-max-values-easy-approach",
                "content": "# Approach\\nWe just need to find all the adjacent nodes of every node(0 to n-1) and storing them with their values into a data structure(which is vector adj for this code). \\n\\nThen, For every node (0 to n-1) we store all adjacent nodes\\' values in an array and sort it into descreasing order to get max values first then find maximum sum of at most top-k adjacent nodes values and return it.\\n\\n\\n# Complexity\\n- Time complexity: \\nO(N x E x log(E))\\n\\n- Space complexity:\\nO(N x E) \\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) \\n    {\\n        int n=vals.size();\\n        vector<pair<int, int>> adj[n]; //stores (ai, bi, and bi\\'s value) here ai and bi are node connected with an edge\\n        \\n        for(int i=0; i<edges.size(); i++) //creating undirected graph with node\\'s value\\n        {\\n            adj[edges[i][0]].push_back({edges[i][1], vals[edges[i][1]]});\\n            adj[edges[i][1]].push_back({edges[i][0], vals[edges[i][0]]});\\n        }\\n        \\n        int maxi = INT_MIN;\\n        vector<int> connectedNodesVals; //stores connected nodes\\' value \\n        for(int node=0; node<n; node++)\\n        {\\n            for(auto it:adj[node]) //storing all the adjacent nodes\\' value\\n            {\\n                connectedNodesVals.push_back(it.second);\\n            }\\n            //sort vals in descreasing order to get top-k max vals\\n            sort(connectedNodesVals.begin(), connectedNodesVals.end(), greater<int>()); \\n            \\n            int i=0, sum=vals[node];\\n            maxi = max(maxi, sum); //for handling single node condition & negative nodes\\' values \\n            while(i<connectedNodesVals.size() && i<k) //calculating max star sum\\n            {\\n                sum += connectedNodesVals[i++];\\n                maxi = max(maxi, sum);\\n            }\\n            \\n            connectedNodesVals.clear(); //clear array for next node\\n        }\\n        return maxi;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) \\n    {\\n        int n=vals.size();\\n        vector<pair<int, int>> adj[n]; //stores (ai, bi, and bi\\'s value) here ai and bi are node connected with an edge\\n        \\n        for(int i=0; i<edges.size(); i++) //creating undirected graph with node\\'s value\\n        {\\n            adj[edges[i][0]].push_back({edges[i][1], vals[edges[i][1]]});\\n            adj[edges[i][1]].push_back({edges[i][0], vals[edges[i][0]]});\\n        }\\n        \\n        int maxi = INT_MIN;\\n        vector<int> connectedNodesVals; //stores connected nodes\\' value \\n        for(int node=0; node<n; node++)\\n        {\\n            for(auto it:adj[node]) //storing all the adjacent nodes\\' value\\n            {\\n                connectedNodesVals.push_back(it.second);\\n            }\\n            //sort vals in descreasing order to get top-k max vals\\n            sort(connectedNodesVals.begin(), connectedNodesVals.end(), greater<int>()); \\n            \\n            int i=0, sum=vals[node];\\n            maxi = max(maxi, sum); //for handling single node condition & negative nodes\\' values \\n            while(i<connectedNodesVals.size() && i<k) //calculating max star sum\\n            {\\n                sum += connectedNodesVals[i++];\\n                maxi = max(maxi, sum);\\n            }\\n            \\n            connectedNodesVals.clear(); //clear array for next node\\n        }\\n        return maxi;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897989,
                "title": "c-simple-sort-explained-easy-to-understand",
                "content": "So a star graph is a graph having **one node [center node] which is connected to all other nodes directly** \\n\\nSo why not try all nodes \"as the center of star graph\"\\nFor each node,\\n  **star graph = node itself(center node)  + all it\\'s direct neighbors**\\n  \\n  Thus for each node treat it is as center node and **find sum of k highest value neighbors**\\n  [Take care of negative values =>  exclude negative values as they would decrease overall sum]\\n  \\n  \\n  \\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) \\n    {\\n        int n = vals.size();\\n        vector<vector<pair<int, int>>>adj(n);\\n        for (vector<int>edge : edges)\\n        {\\n            int startNode = edge[0], startNodeVal = vals[startNode];\\n            int endNode = edge[1], endNodeVal = vals[endNode];\\n            adj[startNode].push_back({endNodeVal, endNode});\\n            adj[endNode].push_back({startNodeVal, startNode});\\n        }\\n        //========================================================\\n        int mxSum = INT_MIN;\\n        for (int node = 0; node < n; node++)\\n        {\\n            sort(adj[node].begin(), adj[node].end()); //sort the neighbors based on increasing \"values\"\\n            int neighborSize = adj[node].size();\\n            int sum = vals[node];\\n            for (int i = neighborSize - 1; i >= 0 && i >= (neighborSize - k); i--) //take k neighbors [start from largest vals]\\n            {\\n                int val = adj[node][i].first;\\n                if (val < 0) break; //if value of neighbor is < 0, it would decrease sum so \"break\", \\n\\t\\t\\t\\t                     //as the neighbors left to it would also have negative values\\n                sum += val;\\n            }\\n            mxSum = max(mxSum, sum);\\n        }\\n        //=============================================================\\n        return mxSum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) \\n    {\\n        int n = vals.size();\\n        vector<vector<pair<int, int>>>adj(n);\\n        for (vector<int>edge : edges)\\n        {\\n            int startNode = edge[0], startNodeVal = vals[startNode];\\n            int endNode = edge[1], endNodeVal = vals[endNode];\\n            adj[startNode].push_back({endNodeVal, endNode});\\n            adj[endNode].push_back({startNodeVal, startNode});\\n        }\\n        //========================================================\\n        int mxSum = INT_MIN;\\n        for (int node = 0; node < n; node++)\\n        {\\n            sort(adj[node].begin(), adj[node].end()); //sort the neighbors based on increasing \"values\"\\n            int neighborSize = adj[node].size();\\n            int sum = vals[node];\\n            for (int i = neighborSize - 1; i >= 0 && i >= (neighborSize - k); i--) //take k neighbors [start from largest vals]\\n            {\\n                int val = adj[node][i].first;\\n                if (val < 0) break; //if value of neighbor is < 0, it would decrease sum so \"break\", \\n\\t\\t\\t\\t                     //as the neighbors left to it would also have negative values\\n                sum += val;\\n            }\\n            mxSum = max(mxSum, sum);\\n        }\\n        //=============================================================\\n        return mxSum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903382,
                "title": "o-e-log-k-why-to-use-minheaps-and-not-maxheaps-to-get-most-optimized-time-2-solutions-c",
                "content": "# TYPE 1 - SORT it and use it . SIMPLE\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Its actually so simple.\\n- We make adj list with NOde and its value\\n- We need to find star sum for all nodes one by one\\n- Star sum is nothing but sum of ur val + ur adj nodes vals (at max u can select k adj nodes = k edges) (0 to k possible selections)\\n- Where to stop selection. The first negative guy is the answer. As neg val reduces the sum. we need max sum.\\n- sort it in DESC ORDER so that u know the stop point. first neg u can stop. As after 1st neg, rest also neg only.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(E) + O(N^2 LOG N) + O(N) + O(N^2) = O(N^2 Log N) Dominating term\\n- Say ur graph is complete graph\\n- so node has N-1 edges so those many adj[] list len\\n- so it takes O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(V+E) adj list\\n- \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int N = vals.size();\\n        int M = edges.size();\\n        \\n        vector<pair<int,int>> adj[N];\\n        \\n        for(auto e : edges){\\n\\n            adj[e[0]].push_back({vals[e[1]],e[1]});\\n            adj[e[1]].push_back({vals[e[0]],e[0]});\\n            \\n        }\\n\\n        for(int i=0; i<N; i++){\\n            sort(adj[i].begin(), adj[i].end(), greater<pair<int,int>>());\\n        }\\n\\n        int maxSum = INT_MIN;\\n\\n        for(int i=0; i<N; i++){\\n            int sum = vals[i];\\n            int j = 0;\\n            for(auto it : adj[i]){\\n                if(it.first<0 || j>=k){\\n                    break;\\n                }\\n                \\n                sum += it.first;\\n                j++;\\n            }\\n            \\n            maxSum = max(sum, maxSum);\\n        }\\n        \\n        return maxSum;\\n        \\n    }\\n};\\n```\\n\\n# Type 2 - bit Complex - minHeaps used.\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- See its same as above. find star sum for every node and give the max.\\n- The point over hear is that we use minheap to find top K max elements.\\n- MinHeap character : O(1) to find min. O(log K) delete and insert ops.\\n- we never allow size of heap to grow more than k. This is the TURNING POINT.\\n- So that always for N insertions we make sure time is only O(NLogK)\\n- Not NlogN. \\n- We also never push neg vals, as it will indeed decrease our sum.\\n- In edge case of 0 edges all node vals neg, we need to take neg val.\\n- We also take it as we iterate all nodes with currSum init as VAL[i]\\n\\n- NOTE: In case of MaxHeaps - it takes O(NLogN) bcoz u use it to find the max element one by one, also u push all the elements into PQ.\\n\\n\\n\\n# Complexity\\n- Time complexity:O(N^2 LOG K)\\n- Log K not Log N. This is the optimization.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(V+E) adj list\\n- \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int N = vals.size();\\n        int M = edges.size();\\n        \\n        vector<int> adj[N];\\n        \\n        for(auto e : edges){ // O(E)\\n\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);         \\n        }\\n\\n        int maxSum = INT_MIN;\\n\\n        for(int i=0; i<N; i++){ // O(N)\\n            int currSum = vals[i]; // star sum = ur sum + ur adj sum upto k nodes\\n            //we need min heap. So that atlast we have top k max ele\\n            priority_queue<int,vector<int>,greater<int>> minH; //minheap\\n\\n            for(int adjN : adj[i] ){ //O(N) N in case of complete graphs\\n                if(vals[adjN] > 0) // only enter pos vals bcoz we dont need neg at all\\n                    minH.push(vals[adjN]); //O(Log K) \\n                if(minH.size() > k) \\n                    minH.pop(); // O(log k)\\n\\n                //we never allow minheap size to grow more than k \\n            }\\n\\n            //minHeap now has Top K Max ele\\n            while(!minH.empty()){ //O(K)\\n                currSum += minH.top();\\n                minH.pop();\\n            }\\n\\n            maxSum = max(maxSum, currSum);\\n\\n        }\\n\\n        return maxSum;\\n\\n    }\\n};\\n```\\n\\n### **KINDLY UPVOTE IF U LIKED AND UNDERSTOOD**\\n",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int N = vals.size();\\n        int M = edges.size();\\n        \\n        vector<pair<int,int>> adj[N];\\n        \\n        for(auto e : edges){\\n\\n            adj[e[0]].push_back({vals[e[1]],e[1]});\\n            adj[e[1]].push_back({vals[e[0]],e[0]});\\n            \\n        }\\n\\n        for(int i=0; i<N; i++){\\n            sort(adj[i].begin(), adj[i].end(), greater<pair<int,int>>());\\n        }\\n\\n        int maxSum = INT_MIN;\\n\\n        for(int i=0; i<N; i++){\\n            int sum = vals[i];\\n            int j = 0;\\n            for(auto it : adj[i]){\\n                if(it.first<0 || j>=k){\\n                    break;\\n                }\\n                \\n                sum += it.first;\\n                j++;\\n            }\\n            \\n            maxSum = max(sum, maxSum);\\n        }\\n        \\n        return maxSum;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int N = vals.size();\\n        int M = edges.size();\\n        \\n        vector<int> adj[N];\\n        \\n        for(auto e : edges){ // O(E)\\n\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);         \\n        }\\n\\n        int maxSum = INT_MIN;\\n\\n        for(int i=0; i<N; i++){ // O(N)\\n            int currSum = vals[i]; // star sum = ur sum + ur adj sum upto k nodes\\n            //we need min heap. So that atlast we have top k max ele\\n            priority_queue<int,vector<int>,greater<int>> minH; //minheap\\n\\n            for(int adjN : adj[i] ){ //O(N) N in case of complete graphs\\n                if(vals[adjN] > 0) // only enter pos vals bcoz we dont need neg at all\\n                    minH.push(vals[adjN]); //O(Log K) \\n                if(minH.size() > k) \\n                    minH.pop(); // O(log k)\\n\\n                //we never allow minheap size to grow more than k \\n            }\\n\\n            //minHeap now has Top K Max ele\\n            while(!minH.empty()){ //O(K)\\n                currSum += minH.top();\\n                minH.pop();\\n            }\\n\\n            maxSum = max(maxSum, currSum);\\n\\n        }\\n\\n        return maxSum;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897920,
                "title": "python-just-get-max-from-sorted-values-for-each-node",
                "content": "```python\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        g = defaultdict(list)\\n        \\n        # graph with neighbors values, but ignore negative values\\n        for a, b in edges:\\n            if vals[b] > 0:\\n                g[a].append(vals[b])\\n            if vals[a] > 0:\\n                g[b].append(vals[a])\\n        \\n        res = max(vals)\\n\\n        # find max sum of sorted values for each `start`\\n        for n, v in g.items():\\n            res = max(res, (vals[n] + sum(sorted(v, reverse=True)[:k])))\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        g = defaultdict(list)\\n        \\n        # graph with neighbors values, but ignore negative values\\n        for a, b in edges:\\n            if vals[b] > 0:\\n                g[a].append(vals[b])\\n            if vals[a] > 0:\\n                g[b].append(vals[a])\\n        \\n        res = max(vals)\\n\\n        # find max sum of sorted values for each `start`\\n        for n, v in g.items():\\n            res = max(res, (vals[n] + sum(sorted(v, reverse=True)[:k])))\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897919,
                "title": "simple-solution-using-multiset-c",
                "content": "since, set removes duplicates of a number , we have to use multiset.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<multiset<int>> v(n);\\n        for(auto &vec: edges){\\n            int first=vec[0],second=vec[1];\\n            v[first].insert(-vals[second]); //negative, in order to store numbers in non-increasing order\\n            v[second].insert(-vals[first]);\\n        }\\n        \\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int cnt=0;\\n            int sum=vals[i];\\n            for(auto &K: v[i]){\\n                if(K>0 || cnt==k) break;\\n                sum-=K;\\n                cnt++;\\n            }\\n            ans=max(ans,sum);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<multiset<int>> v(n);\\n        for(auto &vec: edges){\\n            int first=vec[0],second=vec[1];\\n            v[first].insert(-vals[second]); //negative, in order to store numbers in non-increasing order\\n            v[second].insert(-vals[first]);\\n        }\\n        \\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int cnt=0;\\n            int sum=vals[i];\\n            for(auto &K: v[i]){\\n                if(K>0 || cnt==k) break;\\n                sum-=K;\\n                cnt++;\\n            }\\n            ans=max(ans,sum);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898991,
                "title": "using-map-and-sorting",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        int ans=INT_MIN;\\n        vector<int> adj[n+1];\\n        //Make adjacency list of given graph\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(vals[edges[i][1]]);\\n            adj[edges[i][1]].push_back(vals[edges[i][0]]);\\n        }\\n        map<int,vector<int>> mp;\\n        //Store the value of all connected nodes to each node in a vector, sort it and store it in a map.\\n        for(int i=0;i<n;i++){\\n            vector<int> temp;\\n            for(auto it:adj[i]){\\n                temp.push_back(it);\\n            }\\n            sort(rbegin(temp),rend(temp));\\n            mp[i]=temp;\\n        }\\n        //Traverse each vector upto K elements and find max sum.\\n        for(auto i:mp){\\n            vector<int> temp = i.second;\\n            int sum=vals[i.first];\\n            ans=max(ans,sum);\\n            for(int it=0;it<k and it<temp.size();it++){\\n                ans=max(ans,sum);\\n                sum+=temp[it];\\n            } \\n            ans=max(ans,sum);\\n        }    \\n            \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        int ans=INT_MIN;\\n        vector<int> adj[n+1];\\n        //Make adjacency list of given graph\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(vals[edges[i][1]]);\\n            adj[edges[i][1]].push_back(vals[edges[i][0]]);\\n        }\\n        map<int,vector<int>> mp;\\n        //Store the value of all connected nodes to each node in a vector, sort it and store it in a map.\\n        for(int i=0;i<n;i++){\\n            vector<int> temp;\\n            for(auto it:adj[i]){\\n                temp.push_back(it);\\n            }\\n            sort(rbegin(temp),rend(temp));\\n            mp[i]=temp;\\n        }\\n        //Traverse each vector upto K elements and find max sum.\\n        for(auto i:mp){\\n            vector<int> temp = i.second;\\n            int sum=vals[i.first];\\n            ans=max(ans,sum);\\n            for(int it=0;it<k and it<temp.size();it++){\\n                ans=max(ans,sum);\\n                sum+=temp[it];\\n            } \\n            ans=max(ans,sum);\\n        }    \\n            \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897930,
                "title": "python-minheap",
                "content": "```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        \\n        m = defaultdict(list)                   # For each node, we will have min heap of size k which stores values                                                             # of Top-K nodes it is connected to.\\n        \\n        for x,y in edges:       \\n            \\n            if vals[y]>0:                       # If neighbor value is negative, our star will have more value without it.\\n                \\n                heapq.heappush(m[x], vals[y])   # For each node, push this neighbors value to its heap\\n                if len(m[x])>k:                 # If the Min-Heap size is more than K.                      \\n                    heapq.heappop(m[x])         # Pop the smallest Neighbour value as we can\\'t use it anyway.             \\n            \\n            if vals[x]>0:\\n                heapq.heappush(m[y], vals[x])   # Repeat the same for other neighbor              \\n                if len(m[y])>k:\\n                    heapq.heappop(m[y])\\n            \\n            \\n        res = -math.inf\\n        for i in range(len(vals)):              # We\\'ll try to maximize the star with each node being center\\n            tot = vals[i]                       # Our total will be value of that node as it has to be included.\\n            \\n            for nei_value in m[i]:              # We will check each value in the heap for the node.                      \\n                tot+=nei_value                  # We have already excluded neg values when pushing to Min-Heap\\n                \\n            res = max(res, tot)                 # We\\'ll maximize our result\\n            \\n        return res                              \\n        \\n            \\n            \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        \\n        m = defaultdict(list)                   # For each node, we will have min heap of size k which stores values                                                             # of Top-K nodes it is connected to.\\n        \\n        for x,y in edges:       \\n            \\n            if vals[y]>0:                       # If neighbor value is negative, our star will have more value without it.\\n                \\n                heapq.heappush(m[x], vals[y])   # For each node, push this neighbors value to its heap\\n                if len(m[x])>k:                 # If the Min-Heap size is more than K.                      \\n                    heapq.heappop(m[x])         # Pop the smallest Neighbour value as we can\\'t use it anyway.             \\n            \\n            if vals[x]>0:\\n                heapq.heappush(m[y], vals[x])   # Repeat the same for other neighbor              \\n                if len(m[y])>k:\\n                    heapq.heappop(m[y])\\n            \\n            \\n        res = -math.inf\\n        for i in range(len(vals)):              # We\\'ll try to maximize the star with each node being center\\n            tot = vals[i]                       # Our total will be value of that node as it has to be included.\\n            \\n            for nei_value in m[i]:              # We will check each value in the heap for the node.                      \\n                tot+=nei_value                  # We have already excluded neg values when pushing to Min-Heap\\n                \\n            res = max(res, tot)                 # We\\'ll maximize our result\\n            \\n        return res                              \\n        \\n            \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 2934338,
                "title": "optimized-nth-element",
                "content": "For each node, collect values of all its neighbors. \\n\\n> Note that we only collect positive values.\\n\\nThen, for each node, we pick up to `k` largest values. For that, we need to sort values first.\\n\\nOptimization 1: use `nth_element` to have `k` largest values together. We do not those values to be perfectly sorted.\\n\\nOptimization 2: only do the sorting when we have more than `k` positive values.\\n\\n**C++**\\n```cpp\\nint maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n    vector<vector<int>> av(vals.size());\\n    for (auto &e : edges) {\\n        if (vals[e[1]] > 0)\\n            av[e[0]].push_back(vals[e[1]]);\\n        if (vals[e[0]] > 0)        \\n            av[e[1]].push_back(vals[e[0]]);\\n    }\\n    for (int i = 0; i < vals.size(); ++i) {\\n        if (av[i].size() > k)\\n            nth_element(begin(av[i]), begin(av[i]) + k, end(av[i]), greater<int>());\\n        vals[i] += accumulate(begin(av[i]), k < av[i].size() ? begin(av[i]) + k : end(av[i]), 0);\\n    }\\n    return *max_element(begin(vals), end(vals));\\n} \\n```",
                "solutionTags": [],
                "code": "```cpp\\nint maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n    vector<vector<int>> av(vals.size());\\n    for (auto &e : edges) {\\n        if (vals[e[1]] > 0)\\n            av[e[0]].push_back(vals[e[1]]);\\n        if (vals[e[0]] > 0)        \\n            av[e[1]].push_back(vals[e[0]]);\\n    }\\n    for (int i = 0; i < vals.size(); ++i) {\\n        if (av[i].size() > k)\\n            nth_element(begin(av[i]), begin(av[i]) + k, end(av[i]), greater<int>());\\n        vals[i] += accumulate(begin(av[i]), k < av[i].size() ? begin(av[i]) + k : end(av[i]), 0);\\n    }\\n    return *max_element(begin(vals), end(vals));\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2898475,
                "title": "easy-c-solution-using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        vector<int> adj[n];\\n        \\n        // create adjacency list of graph\\n        for(int i=0 ; i<edges.size() ; i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        // create a maxi variable to store ans.\\n        int maxi = INT_MIN;\\n        \\n        for(int i = 0 ; i<n ; i++){\\n            int tmp = vals[i];\\n            // create min heap to store vals\\n            priority_queue<int , vector<int> , greater<int>> pq;\\n            for(auto it:adj[i]){\\n               pq.push(vals[it]);\\n            // we have to take k edges that\\'s why we have to remove extra value from heap (we remove top value bcoz min heap contain minimum value on its top)\\n               if(pq.size()>k){\\n                   pq.pop();\\n               }\\n            }\\n            // for each node store the k centered values in tmp.\\n            while(!pq.empty()){\\n                if(pq.top()>0)\\n                    tmp += pq.top();\\n                pq.pop();   \\n            }\\n            // store the maximum value in maxi.\\n            maxi = max(maxi , tmp);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        vector<int> adj[n];\\n        \\n        // create adjacency list of graph\\n        for(int i=0 ; i<edges.size() ; i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        // create a maxi variable to store ans.\\n        int maxi = INT_MIN;\\n        \\n        for(int i = 0 ; i<n ; i++){\\n            int tmp = vals[i];\\n            // create min heap to store vals\\n            priority_queue<int , vector<int> , greater<int>> pq;\\n            for(auto it:adj[i]){\\n               pq.push(vals[it]);\\n            // we have to take k edges that\\'s why we have to remove extra value from heap (we remove top value bcoz min heap contain minimum value on its top)\\n               if(pq.size()>k){\\n                   pq.pop();\\n               }\\n            }\\n            // for each node store the k centered values in tmp.\\n            while(!pq.empty()){\\n                if(pq.top()>0)\\n                    tmp += pq.top();\\n                pq.pop();   \\n            }\\n            // store the maximum value in maxi.\\n            maxi = max(maxi , tmp);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898001,
                "title": "c-sorting-hashing-easy-code",
                "content": "<!-- # Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        if(k==0){\\n            int maxi=INT_MIN;\\n            for(int n:vals)maxi=max(maxi,n);\\n            return maxi;\\n        }\\n        int n=vals.size();\\n        map<int,vector<pair<int,int>> > adj;\\n        for(auto p:edges){\\n            adj[p[0]].push_back({vals[p[1]], p[1]});\\n            adj[p[1]].push_back({vals[p[0]], p[0],});\\n        }\\n        int maxi=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            sort(adj[i].rbegin(),adj[i].rend());\\n            int kk=k;\\n            int sum=vals[i];\\n            maxi=max(maxi,sum);\\n            for(auto p:adj[i]){\\n                sum+=p.first;\\n                kk--;\\n                maxi=max(maxi,sum);\\n                if(kk==0 || p.first<0)break;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        if(k==0){\\n            int maxi=INT_MIN;\\n            for(int n:vals)maxi=max(maxi,n);\\n            return maxi;\\n        }\\n        int n=vals.size();\\n        map<int,vector<pair<int,int>> > adj;\\n        for(auto p:edges){\\n            adj[p[0]].push_back({vals[p[1]], p[1]});\\n            adj[p[1]].push_back({vals[p[0]], p[0],});\\n        }\\n        int maxi=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            sort(adj[i].rbegin(),adj[i].rend());\\n            int kk=k;\\n            int sum=vals[i];\\n            maxi=max(maxi,sum);\\n            for(auto p:adj[i]){\\n                sum+=p.first;\\n                kk--;\\n                maxi=max(maxi,sum);\\n                if(kk==0 || p.first<0)break;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897959,
                "title": "c-sort",
                "content": "\\n# Code\\n```\\npublic class Solution \\n{\\n    public int MaxStarSum(int[] vals, int[][] edges, int k)\\n    {\\n        int n = vals.Length;\\n        List<int>[] neghbours = new List<int>[n];\\n        for (int i = 0; i < n; i++)\\n        {\\n            neghbours[i] = new List<int>();\\n        }\\n        foreach (var edge in edges)\\n        {\\n            neghbours[edge[0]].Add(vals[edge[1]]);\\n            neghbours[edge[1]].Add(vals[edge[0]]);\\n        }\\n\\n        int sumMax = int.MinValue;\\n        for (int i = 0; i < n; i++)\\n        {\\n            int curSum = vals[i];\\n            curSum += neghbours[i].OrderByDescending(n => n).Take(k).Where(n => n > 0).Sum();\\n            sumMax = Math.Max(sumMax, curSum);\\n        }\\n        return sumMax;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int MaxStarSum(int[] vals, int[][] edges, int k)\\n    {\\n        int n = vals.Length;\\n        List<int>[] neghbours = new List<int>[n];\\n        for (int i = 0; i < n; i++)\\n        {\\n            neghbours[i] = new List<int>();\\n        }\\n        foreach (var edge in edges)\\n        {\\n            neghbours[edge[0]].Add(vals[edge[1]]);\\n            neghbours[edge[1]].Add(vals[edge[0]]);\\n        }\\n\\n        int sumMax = int.MinValue;\\n        for (int i = 0; i < n; i++)\\n        {\\n            int curSum = vals[i];\\n            curSum += neghbours[i].OrderByDescending(n => n).Take(k).Where(n => n > 0).Sum();\\n            sumMax = Math.Max(sumMax, curSum);\\n        }\\n        return sumMax;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897909,
                "title": "java-simple-graph-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSort the neighbour nodes based on their weights and take k biggest values\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NMlogM), M - max edge number\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        int n = vals.length;\\n        List<Integer>[] graph = new List[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<Integer>();\\n        }\\n        \\n        for (int[] edge : edges) {\\n            int a = edge[0], b = edge[1];\\n            graph[a].add(b);\\n            graph[b].add(a);\\n        }\\n        \\n        long res = Long.MIN_VALUE;\\n        \\n        for (int i = 0; i < n; i++) {\\n            List<Integer> curr = graph[i];\\n            \\n            curr.sort((a, b) -> vals[b]-vals[a]);\\n            \\n            long max = vals[i], sum = vals[i];\\n            \\n            for (int j = 0; j < k && j < curr.size(); j++) {\\n                sum += vals[curr.get(j)];\\n                max = Math.max(max, sum);\\n            }\\n            \\n            res = Math.max(res, max);\\n        }\\n        \\n        return (int) res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        int n = vals.length;\\n        List<Integer>[] graph = new List[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<Integer>();\\n        }\\n        \\n        for (int[] edge : edges) {\\n            int a = edge[0], b = edge[1];\\n            graph[a].add(b);\\n            graph[b].add(a);\\n        }\\n        \\n        long res = Long.MIN_VALUE;\\n        \\n        for (int i = 0; i < n; i++) {\\n            List<Integer> curr = graph[i];\\n            \\n            curr.sort((a, b) -> vals[b]-vals[a]);\\n            \\n            long max = vals[i], sum = vals[i];\\n            \\n            for (int j = 0; j < k && j < curr.size(); j++) {\\n                sum += vals[curr.get(j)];\\n                max = Math.max(max, sum);\\n            }\\n            \\n            res = Math.max(res, max);\\n        }\\n        \\n        return (int) res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929717,
                "title": "python-simple-detailed-solution-beats-98",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        \\n        #If there is only one value, then it must be highest sum\\n        if len(vals) == 1:\\n            return vals[0]\\n        \\n        #Create adjacency List \\n        #(dictionary where each key holds a list of all directly connected nodes)\\n        graph = DefaultDict(list)\\n        \\n        #Populate adjacency list\\n        for left,right in edges:\\n            if vals[right] > 0: graph[left].append(vals[right]) \\n            if vals[left] > 0: graph[right].append(vals[left]) \\n\\n        #Keep track of current largest. Initialize to largest value in vals\\n        #to cover the cases where individual node is greater than any 2 or more node sums\\n        largest = max(vals)\\n\\n        #Iterate through adjacency list and find which key has highest value after adding\\n        #key\\'s own value + sum of k-highest values for the key.\\n        for key,values in graph.items():\\n            subList = sorted(values, reverse = True)\\n            largest = max(largest, sum(subList[0:k]) + vals[key])\\n\\n        return largest\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        \\n        #If there is only one value, then it must be highest sum\\n        if len(vals) == 1:\\n            return vals[0]\\n        \\n        #Create adjacency List \\n        #(dictionary where each key holds a list of all directly connected nodes)\\n        graph = DefaultDict(list)\\n        \\n        #Populate adjacency list\\n        for left,right in edges:\\n            if vals[right] > 0: graph[left].append(vals[right]) \\n            if vals[left] > 0: graph[right].append(vals[left]) \\n\\n        #Keep track of current largest. Initialize to largest value in vals\\n        #to cover the cases where individual node is greater than any 2 or more node sums\\n        largest = max(vals)\\n\\n        #Iterate through adjacency list and find which key has highest value after adding\\n        #key\\'s own value + sum of k-highest values for the key.\\n        for key,values in graph.items():\\n            subList = sorted(values, reverse = True)\\n            largest = max(largest, sum(subList[0:k]) + vals[key])\\n\\n        return largest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928880,
                "title": "easy-c-well-explained-and-commented-without-priority-queue",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInstead of using priority queue(max heap) to get the maximum value of adjacent nodes, we can simply sort the graph that we are making.\\n**Steps:**\\n1. Create the graph.\\n2. Sort the values of adj nodes.\\n3. Initialize sum with the value of node.\\n4. Compare with 0 to avoid taking all negative elements after sorting, till the no. of nodes taken is less than k.\\n5. Store the maximum sum in a variable and return it.\\n\\n# Complexity\\n- Time complexity: O(n^2*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        int maxi=INT_MIN;\\n        vector<vector<int>> graph(n+1);\\n\\n        //creation of graph\\n        for(auto it: edges){\\n            graph[it[0]].push_back(vals[it[1]]); //storing the value of adj node in prev node\\n            graph[it[1]].push_back(vals[it[0]]); \\n        }\\n\\n        for(int i=0; i<n; i++){\\n            sort(graph[i].begin(), graph[i].end(), greater<int>());\\n            int sum=0;\\n            sum=vals[i]; //the value of the node on which you are\\n            //you need to consider the value of node as well\\n\\n            for(int j=0; j<k && j<graph[i].size(); j++){ //extra condition to avoid runtime error\\n                sum+=max(0, graph[i][j]); //comparing with 0, while taking sum\\n                //to avoid negative numbers in sum\\n            }\\n            \\n            maxi=max(maxi, sum); //taking the maximum possible sum\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        int maxi=INT_MIN;\\n        vector<vector<int>> graph(n+1);\\n\\n        //creation of graph\\n        for(auto it: edges){\\n            graph[it[0]].push_back(vals[it[1]]); //storing the value of adj node in prev node\\n            graph[it[1]].push_back(vals[it[0]]); \\n        }\\n\\n        for(int i=0; i<n; i++){\\n            sort(graph[i].begin(), graph[i].end(), greater<int>());\\n            int sum=0;\\n            sum=vals[i]; //the value of the node on which you are\\n            //you need to consider the value of node as well\\n\\n            for(int j=0; j<k && j<graph[i].size(); j++){ //extra condition to avoid runtime error\\n                sum+=max(0, graph[i][j]); //comparing with 0, while taking sum\\n                //to avoid negative numbers in sum\\n            }\\n            \\n            maxi=max(maxi, sum); //taking the maximum possible sum\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917036,
                "title": "edges-in-heap",
                "content": "# Intuition\\nTry taking every node as the center and at most `k` neighbouring nodes wiht max positive values. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\npushing all the positive value of the neighbouring nodes to a priority queue (max heap) and extracting `k` from them and caculating the sum of each node as center.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(nlogn)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(n)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size(), get;\\n        vector<priority_queue<int>> star(n);\\n        for(vector<int>& edge: edges) {\\n            if(vals[edge[0]] > 0)\\n                star[edge[1]].push(vals[edge[0]]);\\n            if(vals[edge[1]] > 0)\\n                star[edge[0]].push(vals[edge[1]]);\\n        }\\n        vector<int> center(vals.begin(), vals.end());\\n        for(int i = 0; i < n; i++) {\\n            get = k;\\n            while(get-- && !star[i].empty()) {\\n                center[i] += star[i].top();\\n                star[i].pop();\\n            }\\n        }\\n        return *max_element(center.begin(), center.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size(), get;\\n        vector<priority_queue<int>> star(n);\\n        for(vector<int>& edge: edges) {\\n            if(vals[edge[0]] > 0)\\n                star[edge[1]].push(vals[edge[0]]);\\n            if(vals[edge[1]] > 0)\\n                star[edge[0]].push(vals[edge[1]]);\\n        }\\n        vector<int> center(vals.begin(), vals.end());\\n        for(int i = 0; i < n; i++) {\\n            get = k;\\n            while(get-- && !star[i].empty()) {\\n                center[i] += star[i].top();\\n                star[i].pop();\\n            }\\n        }\\n        return *max_element(center.begin(), center.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2913026,
                "title": "c-easy-vector-priority-queue-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse priority queue to store values of associated nodes \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. For each node maintain a max priority queue of values of nodes connected with it.\\n2. Traverse and check the maximum value \\n\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& fs, int k) {\\n        int n=vals.size();\\n        vector<priority_queue<int>> edges(n);\\n        \\n        //Fill Up data structures \\n        for(int i=0;i<fs.size();i++){\\n            int f,s;\\n            f=fs[i][0];\\n            s=fs[i][1];\\n            \\n            edges[f].push(vals[s]);\\n            edges[s].push(vals[f]);\\n        }\\n        \\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int prev=vals[i], current=vals[i];\\n            int num=k;\\n            \\n            //Getting answer from each priority queue \\n            while(num>0 && !edges[i].empty()){\\n                prev=current;\\n                current+=edges[i].top();\\n                edges[i].pop();\\n                \\n                if(current<prev){\\n                    current=prev;\\n                    break;\\n                }\\n                num--;\\n            }\\n            ans=max(ans,current);\\n        }        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& fs, int k) {\\n        int n=vals.size();\\n        vector<priority_queue<int>> edges(n);\\n        \\n        //Fill Up data structures \\n        for(int i=0;i<fs.size();i++){\\n            int f,s;\\n            f=fs[i][0];\\n            s=fs[i][1];\\n            \\n            edges[f].push(vals[s]);\\n            edges[s].push(vals[f]);\\n        }\\n        \\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int prev=vals[i], current=vals[i];\\n            int num=k;\\n            \\n            //Getting answer from each priority queue \\n            while(num>0 && !edges[i].empty()){\\n                prev=current;\\n                current+=edges[i].top();\\n                edges[i].pop();\\n                \\n                if(current<prev){\\n                    current=prev;\\n                    break;\\n                }\\n                num--;\\n            }\\n            ans=max(ans,current);\\n        }        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902255,
                "title": "python-from-brute-force-to-optimal-minheap-o-v-e-log-k-solution",
                "content": "# 1) Brute Force (using sort)\\nBuild an adjacency list for each vertex in the graph. In a final pass, sort each adjacency list and compute the maximum possible star sum using at most K neighbors for each vertex.\\n\\n```Python\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], K: int) -> int:\\n        # T: O(E + V * K + V log(V)), S: O(V)\\n        V, E = len(vals), len(edges)\\n        adjList = [[] for _ in range(V)]\\n        for u, v in edges: # T: O(E)\\n            adjList[u].append(v)\\n            adjList[v].append(u)\\n            \\n        ans = -math.inf\\n        for u in range(V): # T: O(V * K)\\n            adjList[u].sort(key=lambda node: vals[node], reverse=True) # T: O(V log(V)) in total\\n            starSum = vals[u]\\n            for i in range(min(K, len(adjList[u]))):\\n                if vals[adjList[u][i]] <= 0: continue\\n                starSum += vals[adjList[u][i]]\\n            ans = max(ans, starSum)\\n\\n        return ans\\n```\\n\\n# 2) MinHeap (optimal)\\nInstead of adding all the neighbors of a node to the adjacency list, we can only add the K maximum ones with the help of a MinHeap.\\n- Neighbors with a value <= 0 contribute nothing to the star and must be skipped.\\n- We simply add nodes until the adjacency list has exactly K elements.\\n- If we see a better candidate, that is, a new neighbor with a value greater than the current minimum at the top of the MinHeap we swap them.\\n\\nWe also use a hashtable to keep track of the star sum for each vertex so that we don\\'t have to do additional O(K) work.\\n\\n```Python\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], K: int) -> int:\\n        # T: O(E log(K) + V), S: O(V)\\n        V, E = len(vals), len(edges)\\n        adjList = [[] for _ in range(V)]\\n        maxSum = [0] * V\\n        for u, v in edges: # T: O(E)\\n            for u, v in [(u, v), (v, u)]: # undirected edges are bidirectional\\n                if vals[v] <= 0: continue\\n\\n                if len(adjList[u]) < K:\\n                    heapq.heappush(adjList[u], vals[v])\\n                    maxSum[u] += vals[v]\\n                elif vals[v] > adjList[u][0]:\\n                    maxSum[u] -= adjList[u][0]\\n                    maxSum[u] += vals[v]\\n                    heapq.heapreplace(adjList[u], vals[v])\\n\\n        return max(vals[u] + maxSum[u] for u in range(V)) # T: O(V)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], K: int) -> int:\\n        # T: O(E + V * K + V log(V)), S: O(V)\\n        V, E = len(vals), len(edges)\\n        adjList = [[] for _ in range(V)]\\n        for u, v in edges: # T: O(E)\\n            adjList[u].append(v)\\n            adjList[v].append(u)\\n            \\n        ans = -math.inf\\n        for u in range(V): # T: O(V * K)\\n            adjList[u].sort(key=lambda node: vals[node], reverse=True) # T: O(V log(V)) in total\\n            starSum = vals[u]\\n            for i in range(min(K, len(adjList[u]))):\\n                if vals[adjList[u][i]] <= 0: continue\\n                starSum += vals[adjList[u][i]]\\n            ans = max(ans, starSum)\\n\\n        return ans\\n```\n```Python\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], K: int) -> int:\\n        # T: O(E log(K) + V), S: O(V)\\n        V, E = len(vals), len(edges)\\n        adjList = [[] for _ in range(V)]\\n        maxSum = [0] * V\\n        for u, v in edges: # T: O(E)\\n            for u, v in [(u, v), (v, u)]: # undirected edges are bidirectional\\n                if vals[v] <= 0: continue\\n\\n                if len(adjList[u]) < K:\\n                    heapq.heappush(adjList[u], vals[v])\\n                    maxSum[u] += vals[v]\\n                elif vals[v] > adjList[u][0]:\\n                    maxSum[u] -= adjList[u][0]\\n                    maxSum[u] += vals[v]\\n                    heapq.heapreplace(adjList[u], vals[v])\\n\\n        return max(vals[u] + maxSum[u] for u in range(V)) # T: O(V)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899017,
                "title": "beats-100-python-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        \\n        graph = defaultdict(list)\\n        \\n        for src,dest in edges:\\n            graph[src].append(dest)\\n            graph[dest].append(src)\\n            \\n        #traverse each node and find value of edges and pick the highest two \\n        maxi = float(\\'-inf\\')\\n        if not edges:\\n            return max(vals)\\n        for node in graph:\\n            temp = []\\n            for val in graph[node]:\\n                heapq.heappush(temp, vals[val])\\n                while len(temp) > k:\\n                    heapq.heappop(temp)\\n            \\n            tot = vals[node]\\n            for i in range(len(temp)):\\n                tot = max(tot, tot+ temp[i])\\n                maxi = max(maxi,tot)\\n        return maxi    \\n            \\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        \\n        graph = defaultdict(list)\\n        \\n        for src,dest in edges:\\n            graph[src].append(dest)\\n            graph[dest].append(src)\\n            \\n        #traverse each node and find value of edges and pick the highest two \\n        maxi = float(\\'-inf\\')\\n        if not edges:\\n            return max(vals)\\n        for node in graph:\\n            temp = []\\n            for val in graph[node]:\\n                heapq.heappush(temp, vals[val])\\n                while len(temp) > k:\\n                    heapq.heappop(temp)\\n            \\n            tot = vals[node]\\n            for i in range(len(temp)):\\n                tot = max(tot, tot+ temp[i])\\n                maxi = max(maxi,tot)\\n        return maxi    \\n            \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898925,
                "title": "simple-sorting-c-fast",
                "content": "```\\nbool comparator(int a,int b)\\n{\\n    return a>b;\\n}\\nclass Solution {\\npublic:\\n   \\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<vector<int>>dp(n);\\n        for(int i=0;i<edges.size();i++) \\n        {\\n            dp[edges[i][0]].push_back(vals[edges[i][1]]);\\n            dp[edges[i][1]].push_back(vals[edges[i][0]]);\\n        }\\n        int res = INT_MIN;\\n        for(int i=0 ; i<n ;i++) \\n        {\\n            sort(dp[i].begin(),dp[i].end(),comparator);\\n        }\\n        for(int i=0 ; i<dp.size() ;i++) \\n        {\\n            \\n            int count=vals[i];\\n            res = max(res,count);\\n            for(int j=0 ; j<min(k,(int)dp[i].size()) ; j++) {\\n                count+=dp[i][j];\\n                res = max(res,count);\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool comparator(int a,int b)\\n{\\n    return a>b;\\n}\\nclass Solution {\\npublic:\\n   \\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<vector<int>>dp(n);\\n        for(int i=0;i<edges.size();i++) \\n        {\\n            dp[edges[i][0]].push_back(vals[edges[i][1]]);\\n            dp[edges[i][1]].push_back(vals[edges[i][0]]);\\n        }\\n        int res = INT_MIN;\\n        for(int i=0 ; i<n ;i++) \\n        {\\n            sort(dp[i].begin(),dp[i].end(),comparator);\\n        }\\n        for(int i=0 ; i<dp.size() ;i++) \\n        {\\n            \\n            int count=vals[i];\\n            res = max(res,count);\\n            for(int j=0 ; j<min(k,(int)dp[i].size()) ; j++) {\\n                count+=dp[i][j];\\n                res = max(res,count);\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898370,
                "title": "python-simple-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxStarSum(self, v: List[int], edges: List[List[int]], k: int) -> int:\\n        n = len(v)\\n        g = defaultdict(list)\\n        for s,d in edges:\\n            g[s].append([v[d],d])\\n            g[d].append([v[s],s])\\n        \\n        ms = -inf\\n        \\n        for z in range(n):\\n            if g[z]:\\n                g[z].sort(reverse=True)\\n\\n                cs = v[z]\\n                c = k\\n                for j in range(len(g[z])):\\n\\n                    if g[z][j][0] > 0:\\n                        cs += g[z][j][0]\\n                        c = c-1\\n\\n                        if c == 0: break\\n\\n                    else: break\\n                    \\n                ms = max(ms,cs)\\n                \\n        \\n        if ms == -inf:\\n            return max(v)\\n        else:\\n            return ms\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStarSum(self, v: List[int], edges: List[List[int]], k: int) -> int:\\n        n = len(v)\\n        g = defaultdict(list)\\n        for s,d in edges:\\n            g[s].append([v[d],d])\\n            g[d].append([v[s],s])\\n        \\n        ms = -inf\\n        \\n        for z in range(n):\\n            if g[z]:\\n                g[z].sort(reverse=True)\\n\\n                cs = v[z]\\n                c = k\\n                for j in range(len(g[z])):\\n\\n                    if g[z][j][0] > 0:\\n                        cs += g[z][j][0]\\n                        c = c-1\\n\\n                        if c == 0: break\\n\\n                    else: break\\n                    \\n                ms = max(ms,cs)\\n                \\n        \\n        if ms == -inf:\\n            return max(v)\\n        else:\\n            return ms\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898134,
                "title": "simple-python-solution-sort-reverse",
                "content": "# Intuition\\nGet a list of all the neighbours, then sort them in descending order\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        graph = defaultdict(list)\\n        for start, end in edges:\\n            if vals[end] > 0:\\n                graph[start].append(vals[end])\\n            if vals[start] > 0:\\n                graph[end].append(vals[start])\\n        \\n        max_sum = -float(\\'inf\\')\\n        for i in range(len(vals)):\\n            total = 0\\n            graph[i].sort(reverse=True)\\n            max_sum = max(max_sum, vals[i] + sum(graph[i][:min(len(graph[i]), k)]))\\n            \\n        return max_sum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        graph = defaultdict(list)\\n        for start, end in edges:\\n            if vals[end] > 0:\\n                graph[start].append(vals[end])\\n            if vals[start] > 0:\\n                graph[end].append(vals[start])\\n        \\n        max_sum = -float(\\'inf\\')\\n        for i in range(len(vals)):\\n            total = 0\\n            graph[i].sort(reverse=True)\\n            max_sum = max(max_sum, vals[i] + sum(graph[i][:min(len(graph[i]), k)]))\\n            \\n        return max_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925132,
                "title": "max-heap-hash-table-easy-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a priority queue to store the top k max value adjacent nodes for\\neach node.\\n\\n# Complexity\\n- Time complexity: O(N * log(K))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*K)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& val, vector<vector<int>>& e, int k) {\\n        unordered_map<int,priority_queue<int,vector<int>,greater<int>>> adj;\\n        int ans = INT_MIN;\\n        for(int i = 0;i<e.size();i++)\\n        {\\n            adj[e[i][0]].push(val[e[i][1]]);\\n            adj[e[i][1]].push(val[e[i][0]]);\\n            if(adj[e[i][0]].size()>k) adj[e[i][0]].pop();\\n            if(adj[e[i][1]].size()>k) adj[e[i][1]].pop();\\n        }\\n\\n        for(int i = 0;i<val.size();i++)\\n        {\\n            if(adj.find(i)!=adj.end())\\n            {\\n               priority_queue<int,vector<int>,greater<int>> q = adj[i];\\n               int count = 0;\\n               while(!q.empty())\\n               {\\n                   count = (q.top())>0 ? count+q.top() :count;\\n                   q.pop();\\n               }\\n               ans = max(ans,count+val[i]);\\n            }\\n            else ans = max(ans,val[i]);\\n        }\\n        return ans;  \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/676904a2-9185-4f08-b210-84bf1d80ac30_1692333325.989491.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& val, vector<vector<int>>& e, int k) {\\n        unordered_map<int,priority_queue<int,vector<int>,greater<int>>> adj;\\n        int ans = INT_MIN;\\n        for(int i = 0;i<e.size();i++)\\n        {\\n            adj[e[i][0]].push(val[e[i][1]]);\\n            adj[e[i][1]].push(val[e[i][0]]);\\n            if(adj[e[i][0]].size()>k) adj[e[i][0]].pop();\\n            if(adj[e[i][1]].size()>k) adj[e[i][1]].pop();\\n        }\\n\\n        for(int i = 0;i<val.size();i++)\\n        {\\n            if(adj.find(i)!=adj.end())\\n            {\\n               priority_queue<int,vector<int>,greater<int>> q = adj[i];\\n               int count = 0;\\n               while(!q.empty())\\n               {\\n                   count = (q.top())>0 ? count+q.top() :count;\\n                   q.pop();\\n               }\\n               ans = max(ans,count+val[i]);\\n            }\\n            else ans = max(ans,val[i]);\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835190,
                "title": "mistake-in-description-faster-than-100-fully-explained-w-comments",
                "content": "**About the description :**\\n\\nI realise that the description is not framed correctly!\\nI know it is technically correct but it would be better if the wording could be modified a little.\\n```\\nGiven an integer k, return the maximum star sum of a star graph containing at most k edges.\\n\\n```\\nThis made me think we consider only nodes having at most k edges. When it was supposed to mean we consider at most k edges.\\n\\nSo maybe it can be changed to : \\n```\\nGiven an integer k, return the maximum star sum of a star graph by considering at most k of its edges.\\n```\\n\\n**Approach :**\\n\\nThe basic aproach is GREEDY, as we would like to only pick those nodes adjacent to our focal-node(centre of the star), which can help us increase the value of out \"starSum\". \\nWe do that by using a MAX HEAP as we insert the values of all the adjNode of our focal-node, and add to the sum only the top k values from the max heap (if they increase the overall \\'StarSum\\').\\n\\nPlease refer the code for full understanding!\\nPlease UPVOTE if this helps you, or if u think it can help others!\\nDiscussions in comments are welcome, CHEERS!\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int starsum(int node, vector<int> adj[], vector<int>& val, int k){\\n        \\n        // atmost k edges/nodes to take\\n        priority_queue<int> pq;\\n        int sum = val[node]; // as the focal node of the star has to be included\\n        int prev = sum;\\n\\n        for(auto it: adj[node]){\\n            pq.push(val[it]); //pushing all values of adjNodes of \\'currentNode\\' into MAX-HEAP\\n        }\\n\\n        int cnt=0; //cnt of nodes taken into summation\\n\\n        while(!pq.empty()){\\n\\n             if(cnt==k) break;\\n            // if u pick a node, then do cnt++; \\n            int n = pq.top();\\n            pq.pop();\\n\\n            sum = sum + n;\\n            if(sum>prev){\\n                cnt++;\\n                prev = sum;\\n            }\\n            else if(sum<=prev){ \\n                sum = prev; //again resetting sum to its prev value as the new node actually decrased its value\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n    int maxStarSum(vector<int>& val, vector<vector<int>>& edges, int k) {\\n        // 0 indexed graph   \\n        //undirected\\n        // star graph : subset of edges of the given graph such that there exists a common node for all edges.\\n        \\n        int n = val.size();\\n        if(n==1) return val[0];  //refer example test cases for n==1 case.\\n\\n        vector<int> adj[n];  // making adj list that stores adjNodes of a given node\\n        for(auto it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        int maxStarSum = -1e9;\\n\\n        for(int i=0; i<n; i++){\\n            maxStarSum = max( maxStarSum, starsum(i,adj,val,k));\\n        }\\n\\n        return maxStarSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nGiven an integer k, return the maximum star sum of a star graph containing at most k edges.\\n\\n```\n```\\nGiven an integer k, return the maximum star sum of a star graph by considering at most k of its edges.\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int starsum(int node, vector<int> adj[], vector<int>& val, int k){\\n        \\n        // atmost k edges/nodes to take\\n        priority_queue<int> pq;\\n        int sum = val[node]; // as the focal node of the star has to be included\\n        int prev = sum;\\n\\n        for(auto it: adj[node]){\\n            pq.push(val[it]); //pushing all values of adjNodes of \\'currentNode\\' into MAX-HEAP\\n        }\\n\\n        int cnt=0; //cnt of nodes taken into summation\\n\\n        while(!pq.empty()){\\n\\n             if(cnt==k) break;\\n            // if u pick a node, then do cnt++; \\n            int n = pq.top();\\n            pq.pop();\\n\\n            sum = sum + n;\\n            if(sum>prev){\\n                cnt++;\\n                prev = sum;\\n            }\\n            else if(sum<=prev){ \\n                sum = prev; //again resetting sum to its prev value as the new node actually decrased its value\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n    int maxStarSum(vector<int>& val, vector<vector<int>>& edges, int k) {\\n        // 0 indexed graph   \\n        //undirected\\n        // star graph : subset of edges of the given graph such that there exists a common node for all edges.\\n        \\n        int n = val.size();\\n        if(n==1) return val[0];  //refer example test cases for n==1 case.\\n\\n        vector<int> adj[n];  // making adj list that stores adjNodes of a given node\\n        for(auto it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        int maxStarSum = -1e9;\\n\\n        for(int i=0; i<n; i++){\\n            maxStarSum = max( maxStarSum, starsum(i,adj,val,k));\\n        }\\n\\n        return maxStarSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030324,
                "title": "adjacency-list-and-prefix-sum-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Aproach is to use adjacecy list and instead of making a list of connected neighbors, We will store the neighbour\\'s value in descending order. After that we will find maximum prefix so that it maximise the output. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nvalues - [1,2,3,4,10,-10,-20]\\nedges -  [[0,1],[1,2],[1,3],[3,4],[3,5],[3,6]]\\nAdjacency List: \\n1. Every node is a center node.\\n2. store values of connected nodes\\n3. sort them in descending order so that we can find at most **K** maximum valued edges.\\n4. find prefix sum of each list.\\n5. find maximum prefix sum (**>= 0**, because if the maximum prefix sum is negative then we can also take **K = 0**) until we hit atmost **K** valued neighbors (if no of neighbors **>= K** else we will consider all of the neighbors) for a center node.\\n6. maximize the output by **max**(*center node value **+** maximum prefix sum value*(can become less than center node value), *center node value*)\\n\\n\\n- [0] -> 2 \\n- [1] -> 4 7 8\\n- [2] -> 2 \\n- [3] -> 10 12 2 -18\\n- [4] -> 4\\n- [5] -> 4\\n- [6] -> 4 \\n\\nThe maximum prefix sum is **12** (by considering atmost **K** neighbors) for center node **3** which has a value of 4.\\nFinal O/P: **12 + 4 = 16**\\n# Complexity\\n- Time complexity: O(N*ElogE), N = Number of nodes, E = Number of neighbors\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N + E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        vector<int> adj[n];\\n        for(int i = 0; i<edges.size(); i++) {\\n            int s = edges[i][0];\\n            int d = edges[i][1];\\n            adj[s].push_back(vals[d]);\\n            adj[d].push_back(vals[s]);\\n        }\\n        int maxVal = INT_MIN;\\n        for(int i = 0; i<n; i++) {\\n            sort(adj[i].begin(), adj[i].end(), greater<int>());\\n            for(int j = 1; j<adj[i].size(); j++) {\\n                adj[i][j] += adj[i][j-1];\\n            }\\n            int j = 0;\\n            int temp = 0;\\n            while(j < min(k, (int)adj[i].size()) ) {\\n                temp = max(temp, adj[i][j]);\\n                j++;\\n            }\\n            maxVal = max({maxVal, temp + vals[i], vals[i]});\\n        }\\n        return maxVal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        vector<int> adj[n];\\n        for(int i = 0; i<edges.size(); i++) {\\n            int s = edges[i][0];\\n            int d = edges[i][1];\\n            adj[s].push_back(vals[d]);\\n            adj[d].push_back(vals[s]);\\n        }\\n        int maxVal = INT_MIN;\\n        for(int i = 0; i<n; i++) {\\n            sort(adj[i].begin(), adj[i].end(), greater<int>());\\n            for(int j = 1; j<adj[i].size(); j++) {\\n                adj[i][j] += adj[i][j-1];\\n            }\\n            int j = 0;\\n            int temp = 0;\\n            while(j < min(k, (int)adj[i].size()) ) {\\n                temp = max(temp, adj[i][j]);\\n                j++;\\n            }\\n            maxVal = max({maxVal, temp + vals[i], vals[i]});\\n        }\\n        return maxVal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991639,
                "title": "simple-bfs-and-dfs-with-priority-queue",
                "content": "# Method 1- BFS\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int>adj[n];\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n \\n         int ans=INT_MIN;\\n         for(int i=0;i<n;i++){\\n             priority_queue<int>pq;\\n             int temp=0;\\n             for(auto it:adj[i]){\\n                 if(vals[it]>0)pq.push(vals[it]);\\n             }\\n             int sz=pq.size();\\n             for(int j=0;j<min(k,sz);j++){\\n                 temp+=pq.top();\\n                 pq.pop();\\n             }\\n             temp+=vals[i];\\n             ans=max(ans,temp);\\n\\n            \\n         }\\n         return ans;\\n        \\n    }\\n\\n```\\n# Method 2- DFS\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<int>adj[], vector<bool>&vis,int node, int k , vector<int>&vals){\\n        vis[node]=true;\\n        priority_queue<int>pq;\\n        int res=INT_MIN;\\n        for(auto it:adj[node]){\\n            if(vals[it]>0)pq.push(vals[it]);\\n            if(vis[it]==false){\\n                res=max(res,dfs(adj ,vis, it, k, vals ));\\n            }\\n        }\\n        int sum=0;\\n        int sz=pq.size();\\n        for(int i=0;i<min(k,sz);i++){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        sum+=vals[node];\\n        return max(res,sum);\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int>adj[n];\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        int ans=INT_MIN;\\n\\n        vector<bool>vis(n,false);\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==false){\\n                ans=max(ans,dfs(adj,vis,i,k,vals));\\n            }\\n        }\\n        return ans;\\n      \\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int>adj[n];\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n \\n         int ans=INT_MIN;\\n         for(int i=0;i<n;i++){\\n             priority_queue<int>pq;\\n             int temp=0;\\n             for(auto it:adj[i]){\\n                 if(vals[it]>0)pq.push(vals[it]);\\n             }\\n             int sz=pq.size();\\n             for(int j=0;j<min(k,sz);j++){\\n                 temp+=pq.top();\\n                 pq.pop();\\n             }\\n             temp+=vals[i];\\n             ans=max(ans,temp);\\n\\n            \\n         }\\n         return ans;\\n        \\n    }\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<int>adj[], vector<bool>&vis,int node, int k , vector<int>&vals){\\n        vis[node]=true;\\n        priority_queue<int>pq;\\n        int res=INT_MIN;\\n        for(auto it:adj[node]){\\n            if(vals[it]>0)pq.push(vals[it]);\\n            if(vis[it]==false){\\n                res=max(res,dfs(adj ,vis, it, k, vals ));\\n            }\\n        }\\n        int sum=0;\\n        int sz=pq.size();\\n        for(int i=0;i<min(k,sz);i++){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        sum+=vals[node];\\n        return max(res,sum);\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int>adj[n];\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        int ans=INT_MIN;\\n\\n        vector<bool>vis(n,false);\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==false){\\n                ans=max(ans,dfs(adj,vis,i,k,vals));\\n            }\\n        }\\n        return ans;\\n      \\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988108,
                "title": "super-simple-solution",
                "content": "# Intuition\\nNote that we need to ensure that our subgraph is a **star graph**. However, if we take a node $$u$$ and look at a subset of its neighbors, we are guaranteed that the resulting subgraph is a star graph as all of the nodes have $u$ in common! Therefore, we simply just need to take the largest $k$ nodes that each node $u$ is connected to. Note that we can choose to exclude some nodes if their value is $< 0$ as they will not increase our sum (it is better for us to leave them out).\\n\\n**Time Complexity:** The time complexity is dominated by the sorting step. If we let $E$ denote the number of edges in the graph, then our algorithm runs in $O(E \\\\log E)$ due to the sorting step.\\n\\nPlease upvote if you found this helpful, as I am trying to reach 10+ reputation:)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        G = collections.defaultdict(list)\\n        for u, v in edges:\\n            G[u].append(vals[v])\\n            G[v].append(vals[u])\\n        \\n        for u in G:\\n            G[u].sort(reverse=True)\\n            \\n        res = float(\"-inf\")\\n        for u in range(len(vals)):\\n            currSum = vals[u]\\n            for i in range(min(k, len(G[u]))):\\n                if G[u][i] < 0:\\n                    break\\n                else:\\n                    currSum += G[u][i]\\n            res = max(res, currSum)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        G = collections.defaultdict(list)\\n        for u, v in edges:\\n            G[u].append(vals[v])\\n            G[v].append(vals[u])\\n        \\n        for u in G:\\n            G[u].sort(reverse=True)\\n            \\n        res = float(\"-inf\")\\n        for u in range(len(vals)):\\n            currSum = vals[u]\\n            for i in range(min(k, len(G[u]))):\\n                if G[u][i] < 0:\\n                    break\\n                else:\\n                    currSum += G[u][i]\\n            res = max(res, currSum)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903674,
                "title": "using-bfs-and-priority-queue-easy-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int>adj[100001];\\nint vis[100001]={0};\\nint  bfs(int node,vector<int>& val,int k)\\n  {\\n      queue<int>q;\\n      q.push(node);\\n      int maxm=INT_MIN;\\n      while(!q.empty())\\n      {\\n        int temp=q.front();\\n        q.pop();\\n        int sum=0;\\n        sum=val[temp];\\n        if(vis[temp]==0)\\n        {\\n            priority_queue<int>pq;\\n       for (auto child:adj[temp])\\n        {\\n            if(val[child]>0)\\n          pq.push(val[child]);\\n          q.push(child);\\n        }\\n        int j=k;\\n        while(!pq.empty()&&pq.top()>0&&j>0)\\n        {\\n          sum+=pq.top();\\n          pq.pop();\\n          j--;\\n        }\\n        }\\n        maxm=max(maxm,sum);\\n        vis[temp]=1;\\n      }\\n      return maxm;\\n  }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        for(auto edge:edges)\\n        {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        int maxm=INT_MIN;\\n      for(int i=0;i<n;i++)\\n      {\\n          if(vis[i]==0)\\n          maxm=max(maxm,bfs(i,vals,k));\\n      }\\n      return maxm;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int>adj[100001];\\nint vis[100001]={0};\\nint  bfs(int node,vector<int>& val,int k)\\n  {\\n      queue<int>q;\\n      q.push(node);\\n      int maxm=INT_MIN;\\n      while(!q.empty())\\n      {\\n        int temp=q.front();\\n        q.pop();\\n        int sum=0;\\n        sum=val[temp];\\n        if(vis[temp]==0)\\n        {\\n            priority_queue<int>pq;\\n       for (auto child:adj[temp])\\n        {\\n            if(val[child]>0)\\n          pq.push(val[child]);\\n          q.push(child);\\n        }\\n        int j=k;\\n        while(!pq.empty()&&pq.top()>0&&j>0)\\n        {\\n          sum+=pq.top();\\n          pq.pop();\\n          j--;\\n        }\\n        }\\n        maxm=max(maxm,sum);\\n        vis[temp]=1;\\n      }\\n      return maxm;\\n  }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        for(auto edge:edges)\\n        {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        int maxm=INT_MIN;\\n      for(int i=0;i<n;i++)\\n      {\\n          if(vis[i]==0)\\n          maxm=max(maxm,bfs(i,vals,k));\\n      }\\n      return maxm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903223,
                "title": "java-solution-using-sorting",
                "content": "# Intuition\\nstore the  value  of a node connected to a star node  in a list in descending order and add  k elements from the list,do for every n nodes.\\n\\n# Approach\\nGraph traversal\\n\\n# Complexity\\n- Time complexity:\\nO(N*LogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        ArrayList<ArrayList<Integer>> list=new ArrayList();\\n        int arr[]=new int[vals.length];\\n        for(int i=0;i<vals.length;i++)\\n            arr[i]=vals[i];\\n//edge cases\\n        if(vals.length==1)\\n            return vals[0];\\n        \\n        int n=vals.length;\\n        for(int i=0;i<=n;i++){\\n            list.add(new ArrayList<Integer>());\\n        }\\n        for(int row[]:edges){\\n            list.get(row[0]).add(row[1]);\\n            list.get(row[1]).add(row[0]);\\n        }\\n//edge cases\\n        Arrays.sort(vals);\\n        if(edges.length==0)\\n            return vals[vals.length-1];\\n        int max=0;\\n        \\n        for(int i=0;i<n;i++){\\n            List<Integer> adj=list.get(i);\\n            List<Integer> temp=new ArrayList<Integer>();\\n            for(int it:adj){\\n                temp.add(arr[it]);\\n            }\\n           Collections.sort(temp, Collections.reverseOrder());\\n            int sum=arr[i];\\n            max=Math.max(sum,max);\\n            int s=k;\\n            for(int it:temp){\\n                sum+=it;\\n                max=Math.max(sum,max);\\n                s--;\\n                if(s==0)\\n                    break;\\n            }\\n            \\n            \\n         \\n        }\\n        return max;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        ArrayList<ArrayList<Integer>> list=new ArrayList();\\n        int arr[]=new int[vals.length];\\n        for(int i=0;i<vals.length;i++)\\n            arr[i]=vals[i];\\n//edge cases\\n        if(vals.length==1)\\n            return vals[0];\\n        \\n        int n=vals.length;\\n        for(int i=0;i<=n;i++){\\n            list.add(new ArrayList<Integer>());\\n        }\\n        for(int row[]:edges){\\n            list.get(row[0]).add(row[1]);\\n            list.get(row[1]).add(row[0]);\\n        }\\n//edge cases\\n        Arrays.sort(vals);\\n        if(edges.length==0)\\n            return vals[vals.length-1];\\n        int max=0;\\n        \\n        for(int i=0;i<n;i++){\\n            List<Integer> adj=list.get(i);\\n            List<Integer> temp=new ArrayList<Integer>();\\n            for(int it:adj){\\n                temp.add(arr[it]);\\n            }\\n           Collections.sort(temp, Collections.reverseOrder());\\n            int sum=arr[i];\\n            max=Math.max(sum,max);\\n            int s=k;\\n            for(int it:temp){\\n                sum+=it;\\n                max=Math.max(sum,max);\\n                s--;\\n                if(s==0)\\n                    break;\\n            }\\n            \\n            \\n         \\n        }\\n        return max;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901546,
                "title": "c-no-priority-queue-just-use-nbrs-as-values",
                "content": "# Approach\\nNo Priority_queue ,just use nbr as values\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n       int res = INT_MIN;\\n       vector<vector<int>> graph(vals.size(), vector<int>());\\n       \\n       for(auto edge : edges) {\\n           int u = edge[0];\\n           int v = edge[1];\\n           \\n           graph[u].push_back(vals[v]);\\n           graph[v].push_back(vals[u]);\\n       }\\n       for(auto &e:graph)\\n           {\\n               sort(e.begin(),e.end(),greater<int>());\\n           }\\n        //    for(auto e:graph)\\n        //    {\\n        //        for(auto f:e)\\n        //        {\\n        //            cout<<f<<\" \";\\n        //        }\\n        //        cout<<endl;\\n        //    }\\n       for(int i=0; i<vals.size(); i++) {\\n           \\n           int cur=0;\\n           int temp=k;\\n           for(auto e:graph[i])\\n           {\\n               if(e>0 && temp>0)\\n               {\\n                   cur+=e;\\n                   temp--;\\n               }\\n               else\\n               {\\n                   break;\\n               }\\n           }\\n           res = max(res, cur+vals[i]);\\n       }\\n       \\n       return res;\\n   }\\n};\\n```\\nthanks!",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n       int res = INT_MIN;\\n       vector<vector<int>> graph(vals.size(), vector<int>());\\n       \\n       for(auto edge : edges) {\\n           int u = edge[0];\\n           int v = edge[1];\\n           \\n           graph[u].push_back(vals[v]);\\n           graph[v].push_back(vals[u]);\\n       }\\n       for(auto &e:graph)\\n           {\\n               sort(e.begin(),e.end(),greater<int>());\\n           }\\n        //    for(auto e:graph)\\n        //    {\\n        //        for(auto f:e)\\n        //        {\\n        //            cout<<f<<\" \";\\n        //        }\\n        //        cout<<endl;\\n        //    }\\n       for(int i=0; i<vals.size(); i++) {\\n           \\n           int cur=0;\\n           int temp=k;\\n           for(auto e:graph[i])\\n           {\\n               if(e>0 && temp>0)\\n               {\\n                   cur+=e;\\n                   temp--;\\n               }\\n               else\\n               {\\n                   break;\\n               }\\n           }\\n           res = max(res, cur+vals[i]);\\n       }\\n       \\n       return res;\\n   }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2901052,
                "title": "c-very-easy-solution-easy-to-understand",
                "content": "\\n# Approach\\nConsider every node is center node and from that push it\\'s neighbour nodes value in priority_queue.\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> graph;\\n    int ans;\\n    void solve(int src, vector<int>& vals, int k) {\\n        priority_queue<int> pq;\\n\\n        for(auto &nebr: graph[src]) {\\n            pq.push(vals[nebr]);\\n        }\\n\\n        int sum = vals[src];\\n        ans = max(ans, sum);    // for -ve node val\\n        for(int i = 0; i < k && !pq.empty(); i++) {\\n            sum += pq.top();\\n            ans = max(ans, sum);\\n            pq.pop();\\n        }\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = int(vals.size());\\n        graph = vector<vector<int>> (n + 1);\\n        ans = INT_MIN;\\n        for(auto &e: edges) {\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n        }\\n        for(int i = 0; i < n; i++) {\\n            solve(i, vals, k);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> graph;\\n    int ans;\\n    void solve(int src, vector<int>& vals, int k) {\\n        priority_queue<int> pq;\\n\\n        for(auto &nebr: graph[src]) {\\n            pq.push(vals[nebr]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2898504,
                "title": "easy-c-solution-no-priority-queue",
                "content": "int maxStarSum(vector<int>& v, vector<vector<int>>& e, int k) {\\n        int n=v.size();\\n        vector<int> g[n];\\n\\t\\t//create a graph with each row containong \"values\" of each node. \\n        for(auto it:e)\\n        {\\n            g[it[0]].push_back(v[it[1]]);//inserting value of connected node it[1] in row it[0]\\n            g[it[1]].push_back(v[it[0]]);\\n        }\\n         //sort values of each node in decreasing order;\\n        for(int i=0;i<n;i++)\\n        {   \\n            sort(g[i].rbegin(),g[i].rend());\\n        }\\n       \\n        int a=INT_MIN;\\n\\t\\t//intialise ans to min value\\n        for(int i=0;i<n;i++)\\n        {\\n            int m=v[i]; //initalise temp max value to value of node\\n\\t\\t\\t\\n            int z=k;// temp value of max numbers of node allowed\\n\\t\\t\\t\\n            for(auto it:g[i])\\n                //iterate graph\\n            { \\n                if(z==0)//k nodes selected\\n                break;\\n                if(it>0)//value is positive\\n                {\\n                    m=m+it;\\n                }\\n             else\\n                 break;\\n              \\n                z--;//decrease edge count\\n            }\\n            a=max(a,m);\\n        }\\n        return a;\\n        \\n    }",
                "solutionTags": [
                    "C",
                    "Graph",
                    "Sorting"
                ],
                "code": "int maxStarSum(vector<int>& v, vector<vector<int>>& e, int k) {\\n        int n=v.size();\\n        vector<int> g[n];\\n\\t\\t//create a graph with each row containong \"values\" of each node. \\n        for(auto it:e)\\n        {\\n            g[it[0]].push_back(v[it[1]]);//inserting value of connected node it[1] in row it[0]\\n            g[it[1]].push_back(v[it[0]]);\\n        }\\n         //sort values of each node in decreasing order;\\n        for(int i=0;i<n;i++)\\n        {   \\n            sort(g[i].rbegin(),g[i].rend());\\n        }\\n       \\n        int a=INT_MIN;\\n\\t\\t//intialise ans to min value\\n        for(int i=0;i<n;i++)\\n        {\\n            int m=v[i]; //initalise temp max value to value of node\\n\\t\\t\\t\\n            int z=k;// temp value of max numbers of node allowed\\n\\t\\t\\t\\n            for(auto it:g[i])\\n                //iterate graph\\n            { \\n                if(z==0)//k nodes selected\\n                break;\\n                if(it>0)//value is positive\\n                {\\n                    m=m+it;\\n                }\\n             else\\n                 break;\\n              \\n                z--;//decrease edge count\\n            }\\n            a=max(a,m);\\n        }\\n        return a;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2898337,
                "title": "java-adjacency-list-priority-queue",
                "content": "1. Idea is to create a adjacency list from the edges array given\\n2. I have take Priority Queue  for storing the edges as it will give us the maximum node values at top.\\n3. Do consider the key as the mandatory part of the star graph sum.\\n```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        HashMap<Integer, PriorityQueue<Integer>> hm = new HashMap<>();\\n        \\n\\t\\t// edge cases\\n        if(vals.length ==1)\\n        {\\n            return vals[0];\\n        }\\n        int min = Integer.MIN_VALUE;\\n        if(edges.length == 0)\\n        {\\n            for(int i=0;i<vals.length;i++)\\n            {\\n                min = Math.max(min, vals[i]);\\n            }\\n            \\n            return min;\\n        }\\n        \\n        for(int i=0;i<edges.length;i++)\\n        {\\n            int x = edges[i][0];\\n            int y = edges[i][1];\\n            \\n            if(hm.containsKey(x))\\n            {\\n                PriorityQueue<Integer> pq = hm.get(x);\\n                pq.add(vals[y]);\\n                hm.put(x, pq);\\n            }\\n            else\\n            {\\n\\t\\t\\t\\t// take max heap\\n                PriorityQueue<Integer> maxPQ = new PriorityQueue<>(Collections.reverseOrder());\\n                maxPQ.add(vals[y]);\\n                hm.put(x, maxPQ);\\n            }\\n            \\n            if(hm.containsKey(y))\\n            {\\n                PriorityQueue<Integer> pq = hm.get(y);\\n                pq.add(vals[x]);\\n                hm.put(y, pq);\\n            }\\n            else\\n            {\\n\\t\\t\\t\\t// take max heap\\n                PriorityQueue<Integer> maxPQ = new PriorityQueue<>(Collections.reverseOrder());\\n                maxPQ.add(vals[x]);\\n                hm.put(y, maxPQ);\\n            }\\n        }\\n        \\n        int maxVal = Integer.MIN_VALUE;\\n        for (Map.Entry<Integer, PriorityQueue<Integer>> entry : hm.entrySet())\\n        {  \\n            //returns keys and values respectively  \\n            int key = entry.getKey();\\n            PriorityQueue<Integer> pq = entry.getValue(); \\n            int num = k;\\n            int sum = vals[key];     //key must be a part of star \\n            while(pq.size()>0 && num>0)\\n            {\\n                int val = pq.poll();\\n               \\n                if(sum+val<sum)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    sum = sum+val;\\n                    num--;\\n                }\\n            }\\n            maxVal = Math.max(maxVal, sum);\\n        } \\n        return maxVal == Integer.MIN_VALUE ? 0 : maxVal;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        HashMap<Integer, PriorityQueue<Integer>> hm = new HashMap<>();\\n        \\n\\t\\t// edge cases\\n        if(vals.length ==1)\\n        {\\n            return vals[0];\\n        }\\n        int min = Integer.MIN_VALUE;\\n        if(edges.length == 0)\\n        {\\n            for(int i=0;i<vals.length;i++)\\n            {\\n                min = Math.max(min, vals[i]);\\n            }\\n            \\n            return min;\\n        }\\n        \\n        for(int i=0;i<edges.length;i++)\\n        {\\n            int x = edges[i][0];\\n            int y = edges[i][1];\\n            \\n            if(hm.containsKey(x))\\n            {\\n                PriorityQueue<Integer> pq = hm.get(x);\\n                pq.add(vals[y]);\\n                hm.put(x, pq);\\n            }\\n            else\\n            {\\n\\t\\t\\t\\t// take max heap\\n                PriorityQueue<Integer> maxPQ = new PriorityQueue<>(Collections.reverseOrder());\\n                maxPQ.add(vals[y]);\\n                hm.put(x, maxPQ);\\n            }\\n            \\n            if(hm.containsKey(y))\\n            {\\n                PriorityQueue<Integer> pq = hm.get(y);\\n                pq.add(vals[x]);\\n                hm.put(y, pq);\\n            }\\n            else\\n            {\\n\\t\\t\\t\\t// take max heap\\n                PriorityQueue<Integer> maxPQ = new PriorityQueue<>(Collections.reverseOrder());\\n                maxPQ.add(vals[x]);\\n                hm.put(y, maxPQ);\\n            }\\n        }\\n        \\n        int maxVal = Integer.MIN_VALUE;\\n        for (Map.Entry<Integer, PriorityQueue<Integer>> entry : hm.entrySet())\\n        {  \\n            //returns keys and values respectively  \\n            int key = entry.getKey();\\n            PriorityQueue<Integer> pq = entry.getValue(); \\n            int num = k;\\n            int sum = vals[key];     //key must be a part of star \\n            while(pq.size()>0 && num>0)\\n            {\\n                int val = pq.poll();\\n               \\n                if(sum+val<sum)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    sum = sum+val;\\n                    num--;\\n                }\\n            }\\n            maxVal = Math.max(maxVal, sum);\\n        } \\n        return maxVal == Integer.MIN_VALUE ? 0 : maxVal;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898218,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        vector<int> g[100005];\\n        int n = vals.size();\\n        for(auto x: edges) {            \\n            if(vals[x[1]] > 0) g[x[0]].push_back(vals[x[1]]);\\n            if(vals[x[0]] > 0) g[x[1]].push_back(vals[x[0]]);\\n        }\\n        for(int i=0; i<n; i++) {\\n            sort(g[i].rbegin(), g[i].rend());\\n            for(int j=1; j<g[i].size(); j++) g[i][j] += g[i][j-1];\\n        }\\n        int ans = INT_MIN;\\n        for(int i=0; i<n; i++) {\\n            int cnt = vals[i];\\n            if(k and g[i].size()) {\\n                if(k <= g[i].size()) cnt += g[i][k-1];\\n                else cnt += g[i].back();\\n            }\\n            ans = max(ans, cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        vector<int> g[100005];\\n        int n = vals.size();\\n        for(auto x: edges) {            \\n            if(vals[x[1]] > 0) g[x[0]].push_back(vals[x[1]]);\\n            if(vals[x[0]] > 0) g[x[1]].push_back(vals[x[0]]);\\n        }\\n        for(int i=0; i<n; i++) {\\n            sort(g[i].rbegin(), g[i].rend());\\n            for(int j=1; j<g[i].size(); j++) g[i][j] += g[i][j-1];\\n        }\\n        int ans = INT_MIN;\\n        for(int i=0; i<n; i++) {\\n            int cnt = vals[i];\\n            if(k and g[i].size()) {\\n                if(k <= g[i].size()) cnt += g[i][k-1];\\n                else cnt += g[i].back();\\n            }\\n            ans = max(ans, cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898125,
                "title": "python3-sort-positive-neighbors",
                "content": "# Approach\\nWe are storing all positive neighbors for each node.\\n\\n# Complexity\\n- Time complexity:\\nO(N*log(N))\\n\\n- Space complexity:\\nO(N**2)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        if k==0: return max(vals) \\n        n=len(vals)\\n        answ=max(vals)\\n        stars=[[] for _ in range(n)]\\n        for a,b in edges:\\n            if 0<vals[b]:\\n                stars[a].append(vals[b])\\n            if 0<vals[a]:\\n                stars[b].append(vals[a])\\n        answ=max(vals)\\n        for i in range(n):\\n            answ = max(answ,sum([vals[i]] + sorted(stars[i])[-k:]))  \\n        return answ      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        if k==0: return max(vals) \\n        n=len(vals)\\n        answ=max(vals)\\n        stars=[[] for _ in range(n)]\\n        for a,b in edges:\\n            if 0<vals[b]:\\n                stars[a].append(vals[b])\\n            if 0<vals[a]:\\n                stars[b].append(vals[a])\\n        answ=max(vals)\\n        for i in range(n):\\n            answ = max(answ,sum([vals[i]] + sorted(stars[i])[-k:]))  \\n        return answ      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898080,
                "title": "python-3-greedy",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Taking the maximum of sum of k neighbours of each node\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        d=defaultdict(list)\\n        for i in edges:\\n            d[i[0]].append(vals[i[1]])\\n            d[i[1]].append(vals[i[0]])\\n        ans=-float(\\'inf\\')\\n        if(not(d)):\\n            return max(vals)\\n        for i in d:\\n            d[i].sort(reverse=True)\\n        for i in range(len(vals)):\\n            x=vals[i]\\n            print\\n            for j in range(min(len(d[i]),k)):\\n                if(d[i][j]>=0):\\n                    x+=d[i][j]\\n            ans=max(ans,x)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        d=defaultdict(list)\\n        for i in edges:\\n            d[i[0]].append(vals[i[1]])\\n            d[i[1]].append(vals[i[0]])\\n        ans=-float(\\'inf\\')\\n        if(not(d)):\\n            return max(vals)\\n        for i in d:\\n            d[i].sort(reverse=True)\\n        for i in range(len(vals)):\\n            x=vals[i]\\n            print\\n            for j in range(min(len(d[i]),k)):\\n                if(d[i][j]>=0):\\n                    x+=d[i][j]\\n            ans=max(ans,x)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898050,
                "title": "java-solution-sorting-easy-clean-code",
                "content": "```java\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        ArrayList<Integer>[] a = new ArrayList[vals.length];\\n        \\n        for(int i=0;i<vals.length;i++)\\n        {\\n            a[i] = new ArrayList<Integer>();\\n        }\\n        \\n        for(int[] x:edges)\\n        {\\n            if(vals[x[1]]>0)\\n            a[x[0]].add(vals[x[1]]);\\n            if(vals[x[0]]>0)\\n            a[x[1]].add(vals[x[0]]);\\n        }\\n        \\n        int max=Integer.MIN_VALUE;\\n        int j=0;\\n        for(ArrayList<Integer> list: a){\\n            Collections.sort(list,Collections.reverseOrder());\\n            int sum=vals[j++];\\n            for(int i=0;i<Math.min(list.size(),k);i++)\\n            {\\n                sum+=list.get(i);\\n            }\\n            max=Math.max(sum,max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        ArrayList<Integer>[] a = new ArrayList[vals.length];\\n        \\n        for(int i=0;i<vals.length;i++)\\n        {\\n            a[i] = new ArrayList<Integer>();\\n        }\\n        \\n        for(int[] x:edges)\\n        {\\n            if(vals[x[1]]>0)\\n            a[x[0]].add(vals[x[1]]);\\n            if(vals[x[0]]>0)\\n            a[x[1]].add(vals[x[0]]);\\n        }\\n        \\n        int max=Integer.MIN_VALUE;\\n        int j=0;\\n        for(ArrayList<Integer> list: a){\\n            Collections.sort(list,Collections.reverseOrder());\\n            int sum=vals[j++];\\n            for(int i=0;i<Math.min(list.size(),k);i++)\\n            {\\n                sum+=list.get(i);\\n            }\\n            max=Math.max(sum,max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898045,
                "title": "c-sorting-easy-explanation",
                "content": "```\\nstatic bool comp(pair<int, int> &a, pair<int, int> &b) {\\n\\treturn a.second > b.second;\\n}\\nint maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n\\tint n = vals.size();\\n\\t\\n\\t// Create adjacency list\\n\\tvector<vector<pair<int, int>>> adj(n);\\n\\tfor(int i=0; i<edges.size(); i++) {\\n\\t\\tadj[edges[i][0]].push_back({edges[i][1], vals[edges[i][1]]});\\n\\t\\tadj[edges[i][1]].push_back({edges[i][0], vals[edges[i][0]]});\\n\\t}\\n\\t\\n\\t// Sort the adjacency list for each node\\n\\tint maxi = -1e9;\\n\\tfor(int i=0; i<n; i++) {\\n\\t\\tmaxi = max(maxi, vals[i]);\\n\\t\\tsort(adj[i].begin(), adj[i].end(), comp);\\n\\t}\\n\\t\\n\\t// get maximum star sum\\n\\tfor(int i=0; i<n; i++) {\\n\\t\\tint sum = vals[i];\\n\\t\\tint size = adj[i].size();\\n\\t\\tfor(int j = 0; j<min(k, size); j++) {\\n\\t\\t\\tsum += adj[i][j].second;\\n\\t\\t\\tif(sum > maxi) {\\n\\t\\t\\t\\tmaxi = sum;\\n\\t\\t\\t}\\n\\t\\t\\tif(sum < 0) {\\n\\t\\t\\t\\tsum = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn maxi;\\n}\\n```",
                "solutionTags": [
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nstatic bool comp(pair<int, int> &a, pair<int, int> &b) {\\n\\treturn a.second > b.second;\\n}\\nint maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n\\tint n = vals.size();\\n\\t\\n\\t// Create adjacency list\\n\\tvector<vector<pair<int, int>>> adj(n);\\n\\tfor(int i=0; i<edges.size(); i++) {\\n\\t\\tadj[edges[i][0]].push_back({edges[i][1], vals[edges[i][1]]});\\n\\t\\tadj[edges[i][1]].push_back({edges[i][0], vals[edges[i][0]]});\\n\\t}\\n\\t\\n\\t// Sort the adjacency list for each node\\n\\tint maxi = -1e9;\\n\\tfor(int i=0; i<n; i++) {\\n\\t\\tmaxi = max(maxi, vals[i]);\\n\\t\\tsort(adj[i].begin(), adj[i].end(), comp);\\n\\t}\\n\\t\\n\\t// get maximum star sum\\n\\tfor(int i=0; i<n; i++) {\\n\\t\\tint sum = vals[i];\\n\\t\\tint size = adj[i].size();\\n\\t\\tfor(int j = 0; j<min(k, size); j++) {\\n\\t\\t\\tsum += adj[i][j].second;\\n\\t\\t\\tif(sum > maxi) {\\n\\t\\t\\t\\tmaxi = sum;\\n\\t\\t\\t}\\n\\t\\t\\tif(sum < 0) {\\n\\t\\t\\t\\tsum = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn maxi;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2898035,
                "title": "simple-brute-force-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n         int n=vals.size();\\n        vector<int> adj[n];\\n        for(auto& it:edges){\\n            adj[it[0]].push_back(vals[it[1]]);\\n            adj[it[1]].push_back(vals[it[0]]);\\n\\n        }\\n        for(auto& it:adj){\\n            sort(rbegin(it),rend(it));\\n        }\\n        \\n        int ans=-1e9;\\n        \\n        for(int i=0;i<n;++i){\\n           \\n            int cnt=0;\\n            cnt+=vals[i];\\n            int ck=0;\\n            for(auto& it:adj[i]){\\n                \\n                if(it>0){\\n                     cnt+=it;\\n                    ck++;\\n                }\\n                if(ck>=k){\\n                    break;\\n                }\\n            }\\n            ans=max(ans,cnt);\\n        }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n         int n=vals.size();\\n        vector<int> adj[n];\\n        for(auto& it:edges){\\n            adj[it[0]].push_back(vals[it[1]]);\\n            adj[it[1]].push_back(vals[it[0]]);\\n\\n        }\\n        for(auto& it:adj){\\n            sort(rbegin(it),rend(it));\\n        }\\n        \\n        int ans=-1e9;\\n        \\n        for(int i=0;i<n;++i){\\n           \\n            int cnt=0;\\n            cnt+=vals[i];\\n            int ck=0;\\n            for(auto& it:adj[i]){\\n                \\n                if(it>0){\\n                     cnt+=it;\\n                    ck++;\\n                }\\n                if(ck>=k){\\n                    break;\\n                }\\n            }\\n            ans=max(ans,cnt);\\n        }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898011,
                "title": "c-java-python3-sorting",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/661cb4686dc915189ddbf0bc35fa51f408bf42ef) for solutions of biweekly 93. \\n\\n**Intuition**\\nFor each node, we find the (at most) `k` largest adjacent nodes in `vals`. \\n\\n**Implementation**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size(); \\n        vector<vector<int>> graph(n); \\n        for (auto& e : edges) {\\n            graph[e[0]].push_back(e[1]); \\n            graph[e[1]].push_back(e[0]); \\n        }\\n        int ans = INT_MIN; \\n        for (int u = 0; u < n; ++u) {\\n            int cand = vals[u]; \\n            if (graph[u].size() > k) \\n                nth_element(graph[u].begin(), graph[u].begin()+k, graph[u].end(), [&](auto& lhs, auto& rhs) {\\n                    return vals[lhs] > vals[rhs]; \\n                }); \\n            for (int i = 0; i < k && i < graph[u].size(); ++i) \\n                cand += max(0, vals[graph[u][i]]); \\n            ans = max(ans, cand); \\n        }\\n        return ans; \\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        int n = vals.length; \\n        List<Integer>[] graph = new ArrayList[n]; \\n        for (int u = 0; u < n; ++u) graph[u] = new ArrayList(); \\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]); \\n            graph[e[1]].add(e[0]); \\n        }\\n        int ans = Integer.MIN_VALUE; \\n        for (int u = 0; u < n; ++u) {\\n            int cand = vals[u]; \\n            if (graph[u].size() > k) Collections.sort(graph[u], (a, b) -> vals[b] - vals[a]);\\n            for (int v = 0; v < k && v < graph[u].size(); ++v)\\n                cand += Math.max(0, vals[graph[u].get(v)]); \\n            ans = Math.max(ans, cand); \\n        }\\n        return ans; \\n    }\\n}\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        n = len(vals)\\n        graph = [[] for _ in range(n)]\\n        for u, v in edges: \\n            graph[u].append(v)\\n            graph[v].append(u)\\n        ans = -inf \\n        for i, u in enumerate(graph): \\n            u.sort(key=vals.__getitem__, reverse=True)\\n            cand = vals[i] + sum(max(0, vals[x]) for x in u[:k])\\n            ans = max(ans, cand)\\n        return ans \\n```\\n**Complexity**\\nTime `O(ElogE)`\\nSpace `O(E)`",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size(); \\n        vector<vector<int>> graph(n); \\n        for (auto& e : edges) {\\n            graph[e[0]].push_back(e[1]); \\n            graph[e[1]].push_back(e[0]); \\n        }\\n        int ans = INT_MIN; \\n        for (int u = 0; u < n; ++u) {\\n            int cand = vals[u]; \\n            if (graph[u].size() > k) \\n                nth_element(graph[u].begin(), graph[u].begin()+k, graph[u].end(), [&](auto& lhs, auto& rhs) {\\n                    return vals[lhs] > vals[rhs]; \\n                }); \\n            for (int i = 0; i < k && i < graph[u].size(); ++i) \\n                cand += max(0, vals[graph[u][i]]); \\n            ans = max(ans, cand); \\n        }\\n        return ans; \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        int n = vals.length; \\n        List<Integer>[] graph = new ArrayList[n]; \\n        for (int u = 0; u < n; ++u) graph[u] = new ArrayList(); \\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]); \\n            graph[e[1]].add(e[0]); \\n        }\\n        int ans = Integer.MIN_VALUE; \\n        for (int u = 0; u < n; ++u) {\\n            int cand = vals[u]; \\n            if (graph[u].size() > k) Collections.sort(graph[u], (a, b) -> vals[b] - vals[a]);\\n            for (int v = 0; v < k && v < graph[u].size(); ++v)\\n                cand += Math.max(0, vals[graph[u].get(v)]); \\n            ans = Math.max(ans, cand); \\n        }\\n        return ans; \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        n = len(vals)\\n        graph = [[] for _ in range(n)]\\n        for u, v in edges: \\n            graph[u].append(v)\\n            graph[v].append(u)\\n        ans = -inf \\n        for i, u in enumerate(graph): \\n            u.sort(key=vals.__getitem__, reverse=True)\\n            cand = vals[i] + sum(max(0, vals[x]) for x in u[:k])\\n            ans = max(ans, cand)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898005,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        vector<vector<int>> valid_edges(n);\\n        for(int i=0;i<edges.size();i++){\\n            if(vals[edges[i][1]] > 0)\\n                valid_edges[edges[i][0]].push_back(vals[edges[i][1]]);\\n            if(vals[edges[i][0]] > 0)\\n                valid_edges[edges[i][1]].push_back(vals[edges[i][0]]);\\n        }\\n        int mx = INT_MIN;\\n        for(int i=0;i<n;i++){\\n            sort(valid_edges[i].rbegin(),valid_edges[i].rend());\\n            int tmp = vals[i];\\n            int cnt = min(k,(int)valid_edges[i].size());\\n            for(int j=0;j<cnt;j++)\\n                tmp += valid_edges[i][j];\\n            mx = max(mx,tmp);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        vector<vector<int>> valid_edges(n);\\n        for(int i=0;i<edges.size();i++){\\n            if(vals[edges[i][1]] > 0)\\n                valid_edges[edges[i][0]].push_back(vals[edges[i][1]]);\\n            if(vals[edges[i][0]] > 0)\\n                valid_edges[edges[i][1]].push_back(vals[edges[i][0]]);\\n        }\\n        int mx = INT_MIN;\\n        for(int i=0;i<n;i++){\\n            sort(valid_edges[i].rbegin(),valid_edges[i].rend());\\n            int tmp = vals[i];\\n            int cnt = min(k,(int)valid_edges[i].size());\\n            for(int j=0;j<cnt;j++)\\n                tmp += valid_edges[i][j];\\n            mx = max(mx,tmp);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897957,
                "title": "edges-to-graph",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k,int ans = INT_MIN) {\\n        vector<int> adj[(int)vals.size()];\\n        for(auto e:edges) {\\n            if(vals[e[1]]>0)adj[e[0]].push_back(vals[e[1]]);\\n            if(vals[e[0]]>0)adj[e[1]].push_back(vals[e[0]]);\\n        }\\n        for(int i = 0;i<vals.size(); i++) {\\n            sort(adj[i].rbegin(), adj[i].rend());\\n            int sum = vals[i];\\n            for(int j = 0; j < min(k,(int)adj[i].size());j++) sum += adj[i][j];\\n            ans = max(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k,int ans = INT_MIN) {\\n        vector<int> adj[(int)vals.size()];\\n        for(auto e:edges) {\\n            if(vals[e[1]]>0)adj[e[0]].push_back(vals[e[1]]);\\n            if(vals[e[0]]>0)adj[e[1]].push_back(vals[e[0]]);\\n        }\\n        for(int i = 0;i<vals.size(); i++) {\\n            sort(adj[i].rbegin(), adj[i].rend());\\n            int sum = vals[i];\\n            for(int j = 0; j < min(k,(int)adj[i].size());j++) sum += adj[i][j];\\n            ans = max(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897945,
                "title": "c-edge-to-graph-conversion",
                "content": "```\\nclass Solution {\\nprivate:\\n    unordered_map<int, vector<int>> graph;\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        for (auto e : edges) {\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n        }\\n        int ans = *max_element(vals.begin(), vals.end());\\n        for (auto [key, val] : graph) {\\n            priority_queue<pair<int, int>> qt;\\n            int res = vals[key];\\n            ans = max(ans, res);\\n            for (auto dest : val) {\\n                qt.push({vals[dest], dest});\\n            }\\n            int size = min(k, (int)qt.size());\\n            for (int i = 0; i < size; i++) {\\n                res += vals[qt.top().second];\\n                qt.pop();\\n                ans = max(ans, res);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Graph",
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    unordered_map<int, vector<int>> graph;\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        for (auto e : edges) {\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n        }\\n        int ans = *max_element(vals.begin(), vals.end());\\n        for (auto [key, val] : graph) {\\n            priority_queue<pair<int, int>> qt;\\n            int res = vals[key];\\n            ans = max(ans, res);\\n            for (auto dest : val) {\\n                qt.push({vals[dest], dest});\\n            }\\n            int size = min(k, (int)qt.size());\\n            for (int i = 0; i < size; i++) {\\n                res += vals[qt.top().second];\\n                qt.pop();\\n                ans = max(ans, res);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897939,
                "title": "form-a-graph-and-choose-biggest-edges",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        graph = defaultdict(list)\\n        for i in range(len(vals)):\\n            graph[i] = []\\n        for a, b in edges:\\n            graph[a].append((b, vals[b]))\\n            graph[b].append((a, vals[a]))\\n        res = float(\\'-inf\\')\\n        for el in graph:\\n            curr = vals[el]\\n            nb = []\\n            for j, c in graph[el]:\\n                nb.append(c)\\n            nb.sort(reverse = True)\\n            for i in range(min(len(nb), k)):\\n                curr += max(nb[i], 0)\\n            res = max(res, curr)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        graph = defaultdict(list)\\n        for i in range(len(vals)):\\n            graph[i] = []\\n        for a, b in edges:\\n            graph[a].append((b, vals[b]))\\n            graph[b].append((a, vals[a]))\\n        res = float(\\'-inf\\')\\n        for el in graph:\\n            curr = vals[el]\\n            nb = []\\n            for j, c in graph[el]:\\n                nb.append(c)\\n            nb.sort(reverse = True)\\n            for i in range(min(len(nb), k)):\\n                curr += max(nb[i], 0)\\n            res = max(res, curr)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897912,
                "title": "java-simple-graph-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSort the neighbour nodes based on their weights and take **k** biggest values\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NMlogM), M - max edge number\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        int n = vals.length;\\n        List<Integer>[] graph = new List[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<Integer>();\\n        }\\n        \\n        for (int[] edge : edges) {\\n            int a = edge[0], b = edge[1];\\n            graph[a].add(b);\\n            graph[b].add(a);\\n        }\\n        \\n        long res = Long.MIN_VALUE;\\n        \\n        for (int i = 0; i < n; i++) {\\n            List<Integer> curr = graph[i];\\n            \\n            curr.sort((a, b) -> vals[b]-vals[a]);\\n            \\n            long max = vals[i], sum = vals[i];\\n            \\n            for (int j = 0; j < k && j < curr.size(); j++) {\\n                sum += vals[curr.get(j)];\\n                max = Math.max(max, sum);\\n            }\\n            \\n            res = Math.max(res, max);\\n        }\\n        \\n        return (int) res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        int n = vals.length;\\n        List<Integer>[] graph = new List[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<Integer>();\\n        }\\n        \\n        for (int[] edge : edges) {\\n            int a = edge[0], b = edge[1];\\n            graph[a].add(b);\\n            graph[b].add(a);\\n        }\\n        \\n        long res = Long.MIN_VALUE;\\n        \\n        for (int i = 0; i < n; i++) {\\n            List<Integer> curr = graph[i];\\n            \\n            curr.sort((a, b) -> vals[b]-vals[a]);\\n            \\n            long max = vals[i], sum = vals[i];\\n            \\n            for (int j = 0; j < k && j < curr.size(); j++) {\\n                sum += vals[curr.get(j)];\\n                max = Math.max(max, sum);\\n            }\\n            \\n            res = Math.max(res, max);\\n        }\\n        \\n        return (int) res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897900,
                "title": "c-easy-map-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int X = 1e5+10;\\n        vector<int>adj[X];\\n        for(auto x:edges)\\n        {\\n            int a = x[0];\\n            int b = x[1];\\n            adj[a].push_back(b);\\n            adj[b].push_back(a);\\n        }\\n        map<int,vector<int>>mp;// Store the connected nodes of each index to calculate first k maximum values for each one\\n        for(int i=0;i<vals.size();i++)\\n        {\\n            for(auto x:adj[i])\\n            {\\n                mp[i].push_back(vals[x]);\\n            }\\n        }\\n        int ans = INT_MIN;\\n        for(int i=0;i<vals.size();i++)\\n        {\\n            auto &x = mp[i];\\n            sort(x.rbegin(),x.rend());// Sort and reverse the array\\n            int sum = 0;\\n            int maxi = 0;\\n            for(int j=0;j<min(k,(int)x.size());j++)// Take the first maximum k elements\\n            {\\n                sum+=x[j];\\n                maxi = max(maxi,sum);// In case the sum is negative or getting decreased then we will not consider those values like 5 4 3 -2 -1 then -2 and -1 will not be considered as they are decreasing the maximum sum\\n            }\\n            maxi+=vals[i];// Must add the value of the index because it is the center\\n            ans = max(ans,maxi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int X = 1e5+10;\\n        vector<int>adj[X];\\n        for(auto x:edges)\\n        {\\n            int a = x[0];\\n            int b = x[1];\\n            adj[a].push_back(b);\\n            adj[b].push_back(a);\\n        }\\n        map<int,vector<int>>mp;// Store the connected nodes of each index to calculate first k maximum values for each one\\n        for(int i=0;i<vals.size();i++)\\n        {\\n            for(auto x:adj[i])\\n            {\\n                mp[i].push_back(vals[x]);\\n            }\\n        }\\n        int ans = INT_MIN;\\n        for(int i=0;i<vals.size();i++)\\n        {\\n            auto &x = mp[i];\\n            sort(x.rbegin(),x.rend());// Sort and reverse the array\\n            int sum = 0;\\n            int maxi = 0;\\n            for(int j=0;j<min(k,(int)x.size());j++)// Take the first maximum k elements\\n            {\\n                sum+=x[j];\\n                maxi = max(maxi,sum);// In case the sum is negative or getting decreased then we will not consider those values like 5 4 3 -2 -1 then -2 and -1 will not be considered as they are decreasing the maximum sum\\n            }\\n            maxi+=vals[i];// Must add the value of the index because it is the center\\n            ans = max(ans,maxi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897894,
                "title": "java-priority-queue-with-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConstruct to graph, then sum all star of neighbor nodes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse `PriorityQueue` to sort the star of neighbor nodes.\\n\\n# Complexity\\n- Time complexity: $$O(N*logN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int maxStarSum(int[] vals, int[][] edges, int k) {\\n    Map<Integer, Queue<Integer>> graph = new HashMap<>();\\n    for (int[] edge : edges) {\\n      graph.putIfAbsent(edge[0], new PriorityQueue<>());\\n      if (vals[edge[1]] > 0) {\\n        Queue<Integer> queue = graph.get(edge[0]);\\n        queue.offer(vals[edge[1]]);\\n        if (queue.size() > k) {\\n          queue.poll();\\n        }\\n      }\\n\\n      graph.putIfAbsent(edge[1], new PriorityQueue<>());\\n      if (vals[edge[0]] > 0) {\\n        Queue<Integer> queue = graph.get(edge[1]);\\n        queue.offer(vals[edge[0]]);\\n        if (queue.size() > k) {\\n          queue.poll();\\n        }\\n      }\\n    }\\n\\n    int result = Integer.MIN_VALUE;\\n    // for lack of edge case\\n    for(int star: vals) {\\n      result = Math.max(result, star);\\n    }\\n\\n    for (Map.Entry<Integer, Queue<Integer>> entry : graph.entrySet()) {\\n      int sum = vals[entry.getKey()];\\n      for (int star : entry.getValue()) {\\n        sum += star;\\n      }\\n\\n      result = Math.max(result, sum);\\n    }\\n\\n    return result;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n  public int maxStarSum(int[] vals, int[][] edges, int k) {\\n    Map<Integer, Queue<Integer>> graph = new HashMap<>();\\n    for (int[] edge : edges) {\\n      graph.putIfAbsent(edge[0], new PriorityQueue<>());\\n      if (vals[edge[1]] > 0) {\\n        Queue<Integer> queue = graph.get(edge[0]);\\n        queue.offer(vals[edge[1]]);\\n        if (queue.size() > k) {\\n          queue.poll();\\n        }\\n      }\\n\\n      graph.putIfAbsent(edge[1], new PriorityQueue<>());\\n      if (vals[edge[0]] > 0) {\\n        Queue<Integer> queue = graph.get(edge[1]);\\n        queue.offer(vals[edge[0]]);\\n        if (queue.size() > k) {\\n          queue.poll();\\n        }\\n      }\\n    }\\n\\n    int result = Integer.MIN_VALUE;\\n    // for lack of edge case\\n    for(int star: vals) {\\n      result = Math.max(result, star);\\n    }\\n\\n    for (Map.Entry<Integer, Queue<Integer>> entry : graph.entrySet()) {\\n      int sum = vals[entry.getKey()];\\n      for (int star : entry.getValue()) {\\n        sum += star;\\n      }\\n\\n      result = Math.max(result, sum);\\n    }\\n\\n    return result;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085297,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<vector<pair<int,int>>> adj(n);\\n        if(k==0){\\n            int maxi=INT_MIN;\\n            for(int i=0;i<n;i++) maxi=max(maxi,vals[i]);\\n            return maxi;\\n        }\\n        for(auto x:edges){\\n            adj[x[0]].push_back({vals[x[1]],x[1]});\\n            adj[x[1]].push_back({vals[x[0]],x[0]});\\n        }\\n        for(int i=0;i<n;i++){\\n            sort(adj[i].begin(),adj[i].end(),greater<pair<int,int>>());\\n        }\\n        int maxi=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int ans=vals[i];\\n            int y=k;\\n            maxi=max(maxi,ans);\\n            \\n              for(auto x:adj[i]){\\n                  ans+=x.first;y--;\\n                  maxi=max(maxi,ans);\\n                  if(y==0||x.first<0) break;\\n              }\\n            \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Graph",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<vector<pair<int,int>>> adj(n);\\n        if(k==0){\\n            int maxi=INT_MIN;\\n            for(int i=0;i<n;i++) maxi=max(maxi,vals[i]);\\n            return maxi;\\n        }\\n        for(auto x:edges){\\n            adj[x[0]].push_back({vals[x[1]],x[1]});\\n            adj[x[1]].push_back({vals[x[0]],x[0]});\\n        }\\n        for(int i=0;i<n;i++){\\n            sort(adj[i].begin(),adj[i].end(),greater<pair<int,int>>());\\n        }\\n        int maxi=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int ans=vals[i];\\n            int y=k;\\n            maxi=max(maxi,ans);\\n            \\n              for(auto x:adj[i]){\\n                  ans+=x.first;y--;\\n                  maxi=max(maxi,ans);\\n                  if(y==0||x.first<0) break;\\n              }\\n            \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051505,
                "title": "basic-bfs-approach-c-code-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int max_sum=INT_MIN;\\n        vector<int>adj[vals.size()];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        queue<int>q;\\n        vector<bool>visited(vals.size(),false);\\n        for(int i=0;i<vals.size();i++){\\n            if(!visited[i]){\\n                q.push(i);\\n                visited[i]=true;\\n                while(!q.empty()){\\n                    int u=q.front();\\n                    q.pop();\\n                    int sum=vals[u];\\n                    int tsm=vals[u];\\n                    vector<int>t;\\n                    for(int x:adj[u]){\\n                        t.push_back(vals[x]);\\n                        if(!visited[x]){\\n                            visited[x]=true;\\n                            q.push(x);\\n                        }\\n                        \\n                    }\\n                    sort(t.begin(),t.end());\\n                   // cout<<u<<endl<<sum<<endl;\\n                    //cout<<\"sz \"<<t.size()<<endl;\\n                    int bnd=(t.size()-k);\\n                    if(bnd<0)bnd=0;\\n                    for(int i=t.size()-1;i>=0&&i>=bnd;i--){\\n                    //sum+=t[i];\\n                    sum=max(sum+t[i],sum);\\n                    //cout<<sum<<endl;\\n                    }\\n                    max_sum=max(max_sum,sum);\\n                   // cout<<u<<\" -> \"<<sum<<endl;\\n                }\\n            }\\n        }\\n        return max_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int max_sum=INT_MIN;\\n        vector<int>adj[vals.size()];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        queue<int>q;\\n        vector<bool>visited(vals.size(),false);\\n        for(int i=0;i<vals.size();i++){\\n            if(!visited[i]){\\n                q.push(i);\\n                visited[i]=true;\\n                while(!q.empty()){\\n                    int u=q.front();\\n                    q.pop();\\n                    int sum=vals[u];\\n                    int tsm=vals[u];\\n                    vector<int>t;\\n                    for(int x:adj[u]){\\n                        t.push_back(vals[x]);\\n                        if(!visited[x]){\\n                            visited[x]=true;\\n                            q.push(x);\\n                        }\\n                        \\n                    }\\n                    sort(t.begin(),t.end());\\n                   // cout<<u<<endl<<sum<<endl;\\n                    //cout<<\"sz \"<<t.size()<<endl;\\n                    int bnd=(t.size()-k);\\n                    if(bnd<0)bnd=0;\\n                    for(int i=t.size()-1;i>=0&&i>=bnd;i--){\\n                    //sum+=t[i];\\n                    sum=max(sum+t[i],sum);\\n                    //cout<<sum<<endl;\\n                    }\\n                    max_sum=max(max_sum,sum);\\n                   // cout<<u<<\" -> \"<<sum<<endl;\\n                }\\n            }\\n        }\\n        return max_sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4048996,
                "title": "java-easy-solution-used-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> ds\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    /* Step 1: create a pair for node & it\\'s val\\'\\n    Step 2: Construct a graph \\n    Step 3: apply loop & for each node find max sum star graph using priority queue\\n    Step 3: find max sum start graph among all nodes */\\n\\n    class Pair{ // apir to hold node & its val\\n        int node;\\n        int val;\\n        Pair(int node, int val) {\\n            this.node = node;\\n            this.val = val;\\n        }\\n    }\\n\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        ArrayList<ArrayList<Integer>> graph = new ArrayList<>(); // graph schema\\n\\n        for(int i = 0; i < vals.length; i++) \\n            graph.add(new ArrayList<>());\\n        \\n        for(int edge[]: edges) { // constructing a graph\\n            int u = edge[0];\\n            int v = edge[1];\\n\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        } \\n\\n        int maxStarSum = Integer.MIN_VALUE; // to hold the maximum tar sum val\\n\\n    //    Applying bfs to find max star graph for each node\\n        PriorityQueue<Pair> pq = new PriorityQueue<>( (a,b) -> { //to find max sum start graph\\n            return b.val - a.val;\\n        });\\n\\n        for(int i = 0; i < vals.length; i++) { // comparing max sum for each node then for all nodes\\n            int starSum = vals[i];\\n\\n            int count = 0;\\n            for(int nbr: graph.get(i)) // adding neighbor node to pq\\n                pq.add(new Pair(nbr, vals[nbr]));\\n            \\n            int temp = starSum;\\n            while(!pq.isEmpty() && count < k) { // remove & compare val of each node to find max sum star\\n                Pair node = pq.remove();\\n\\n                temp += node.val;\\n                starSum = Math.max(starSum, temp);\\n                \\n                count++;\\n            }\\n            maxStarSum = Math.max(maxStarSum, starSum);\\n            pq.clear(); // clearing all pq values to reuse for next node\\n        }\\n\\n        return maxStarSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /* Step 1: create a pair for node & it\\'s val\\'\\n    Step 2: Construct a graph \\n    Step 3: apply loop & for each node find max sum star graph using priority queue\\n    Step 3: find max sum start graph among all nodes */\\n\\n    class Pair{ // apir to hold node & its val\\n        int node;\\n        int val;\\n        Pair(int node, int val) {\\n            this.node = node;\\n            this.val = val;\\n        }\\n    }\\n\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        ArrayList<ArrayList<Integer>> graph = new ArrayList<>(); // graph schema\\n\\n        for(int i = 0; i < vals.length; i++) \\n            graph.add(new ArrayList<>());\\n        \\n        for(int edge[]: edges) { // constructing a graph\\n            int u = edge[0];\\n            int v = edge[1];\\n\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        } \\n\\n        int maxStarSum = Integer.MIN_VALUE; // to hold the maximum tar sum val\\n\\n    //    Applying bfs to find max star graph for each node\\n        PriorityQueue<Pair> pq = new PriorityQueue<>( (a,b) -> { //to find max sum start graph\\n            return b.val - a.val;\\n        });\\n\\n        for(int i = 0; i < vals.length; i++) { // comparing max sum for each node then for all nodes\\n            int starSum = vals[i];\\n\\n            int count = 0;\\n            for(int nbr: graph.get(i)) // adding neighbor node to pq\\n                pq.add(new Pair(nbr, vals[nbr]));\\n            \\n            int temp = starSum;\\n            while(!pq.isEmpty() && count < k) { // remove & compare val of each node to find max sum star\\n                Pair node = pq.remove();\\n\\n                temp += node.val;\\n                starSum = Math.max(starSum, temp);\\n                \\n                count++;\\n            }\\n            maxStarSum = Math.max(maxStarSum, starSum);\\n            pq.clear(); // clearing all pq values to reuse for next node\\n        }\\n\\n        return maxStarSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981366,
                "title": "golang-hash-and-sorting-solution",
                "content": "# Code\\n```go\\nfunc maxStarSum(vals []int, edges [][]int, k int) int {\\n\\tmaxStar := math.MinInt64\\n\\t// at lease be maximum star score\\n\\tfor _, v := range vals {\\n\\t\\tif v > maxStar {\\n\\t\\t\\tmaxStar = v\\n\\t\\t}\\n\\t}\\n\\tif len(edges) == 0 || k == 0 {\\n\\t\\t// no edges, return maximum star score\\n\\t\\treturn maxStar\\n\\t}\\n\\tconnect := make(map[int][]int, 16)\\n\\tfor _, edge := range edges {\\n\\t\\tconnect[edge[0]] = append(connect[edge[0]], vals[edge[1]])\\n\\t\\tconnect[edge[1]] = append(connect[edge[1]], vals[edge[0]])\\n\\t}\\n\\tfor centerIndex, otherStarsScore := range connect {\\n\\t\\tcurStar := vals[centerIndex]\\n\\t\\tsort.Sort(sort.Reverse(sort.IntSlice(otherStarsScore)))\\n\\t\\tfor i := 0; i < k && i < len(otherStarsScore); i++ {\\n\\t\\t\\tif otherStarsScore[i] <= 0 {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tcurStar += otherStarsScore[i]\\n\\t\\t}\\n\\t\\tif curStar > maxStar {\\n\\t\\t\\tmaxStar = curStar\\n\\t\\t}\\n\\t}\\n\\treturn maxStar\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc maxStarSum(vals []int, edges [][]int, k int) int {\\n\\tmaxStar := math.MinInt64\\n\\t// at lease be maximum star score\\n\\tfor _, v := range vals {\\n\\t\\tif v > maxStar {\\n\\t\\t\\tmaxStar = v\\n\\t\\t}\\n\\t}\\n\\tif len(edges) == 0 || k == 0 {\\n\\t\\t// no edges, return maximum star score\\n\\t\\treturn maxStar\\n\\t}\\n\\tconnect := make(map[int][]int, 16)\\n\\tfor _, edge := range edges {\\n\\t\\tconnect[edge[0]] = append(connect[edge[0]], vals[edge[1]])\\n\\t\\tconnect[edge[1]] = append(connect[edge[1]], vals[edge[0]])\\n\\t}\\n\\tfor centerIndex, otherStarsScore := range connect {\\n\\t\\tcurStar := vals[centerIndex]\\n\\t\\tsort.Sort(sort.Reverse(sort.IntSlice(otherStarsScore)))\\n\\t\\tfor i := 0; i < k && i < len(otherStarsScore); i++ {\\n\\t\\t\\tif otherStarsScore[i] <= 0 {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tcurStar += otherStarsScore[i]\\n\\t\\t}\\n\\t\\tif curStar > maxStar {\\n\\t\\t\\tmaxStar = curStar\\n\\t\\t}\\n\\t}\\n\\treturn maxStar\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3976626,
                "title": "see-if-it-helps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n// Approach: make adjacency list and store neighbours like {val,neigh}  and then sort in decending order each one and then calculated required sum and then find max value\\n \\nbool static comp(pair<int,int>&a,pair<int,int>&b){\\n    return a.first>=b.first;\\n}\\n \\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n\\n        int n=vals.size();\\n        // Creating Adjacency List\\n        vector<pair<int,int>>adj[n];\\n        for(auto &it:edges){\\n            int u=it[0];\\n            int v=it[1];\\n            adj[u].push_back({vals[v],v});\\n            adj[v].push_back({vals[u],u});\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            sort(adj[i].begin(),adj[i].end(),comp);\\n         }\\n\\n         int maxi=INT_MIN;\\n         for(int i=0;i<n;i++){\\n             int sum=0;\\n             sum+=vals[i];\\n             for(int j=0;j<k && j<adj[i].size();j++){\\n                 int neighval=adj[i][j].first;\\n                 if(neighval<0)\\n                 break;\\n                 else\\n                 sum+=neighval;\\n             }\\n             maxi=max(maxi,sum);\\n         }\\n         return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// Approach: make adjacency list and store neighbours like {val,neigh}  and then sort in decending order each one and then calculated required sum and then find max value\\n \\nbool static comp(pair<int,int>&a,pair<int,int>&b){\\n    return a.first>=b.first;\\n}\\n \\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n\\n        int n=vals.size();\\n        // Creating Adjacency List\\n        vector<pair<int,int>>adj[n];\\n        for(auto &it:edges){\\n            int u=it[0];\\n            int v=it[1];\\n            adj[u].push_back({vals[v],v});\\n            adj[v].push_back({vals[u],u});\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            sort(adj[i].begin(),adj[i].end(),comp);\\n         }\\n\\n         int maxi=INT_MIN;\\n         for(int i=0;i<n;i++){\\n             int sum=0;\\n             sum+=vals[i];\\n             for(int j=0;j<k && j<adj[i].size();j++){\\n                 int neighval=adj[i][j].first;\\n                 if(neighval<0)\\n                 break;\\n                 else\\n                 sum+=neighval;\\n             }\\n             maxi=max(maxi,sum);\\n         }\\n         return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972839,
                "title": "easy-partitioning-in-o-v-e-beats-99",
                "content": "# Intuition\\nWe will simply calculate the maximum star-sum for each possible center node, and take the highest result.  The maximum star-sum for a given center node is the sum of its own value and either the ```k``` highest positive neighbor-values, or all the positive neighbor-values if there are ```k``` or fewer.\\n\\n# Approach\\nIn order to calculate the maximum star-sum for a given center node, we only need to separate the highest ```k``` neighbor-values from the rest.  Instead of fully sorting the input, we can just select the ```(k + 1)```th highest neighbor-value using an expected linear time selection algorithm, and then partition the vector of neighbor-values by that value. The C++ algorithm library\\'s ```nth_element``` combines these operations into one. After using this, the first ```k``` elements of our positive neighbor-value vector contains exactly the highest ```k``` positive values (not necessarily in sorted order), so we can sum these up easily.\\n\\nThe reader of the code should consider the cases ```k < m``` and ```k >= m``` separately.\\n\\n# Complexity\\n- Time complexity:\\n$O(|V| + |E|)$\\n\\n- Space complexity:\\n$O(|V| + |E|)$\\n\\n# Optimality\\nWe must inspect each vertex and edge, so this algorithm achieves asymptotically optimal expected runtime.  In terms of space complexity, our space usage is proportional to the size of the input.  Furthermore, if the input was given as a vector of adjacency vectors, this algorithm could be modified to run in place with the only modification to input being the reordering of the adjacency vectors.\\n\\nAccording to the C++ standard, ```nth_element``` only gives expected time guarantees and may allocate additional memory; however, a hybrid quickselect / median-of-medians based selection algorithm can give guaranteed linear time performance with constant space usage.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n\\n        vector<vector<int>> adjLists(n, vector<int>());\\n        for (vector<int>& edge: edges) {\\n            int node1 = edge[0];\\n            int node2 = edge[1];\\n            if (vals[node2] > 0) { adjLists[node1].push_back(vals[node2]); }\\n            if (vals[node1] > 0) { adjLists[node2].push_back(vals[node1]); }\\n        }\\n\\n        int bestSum = INT_MIN;\\n        for (int i = 0; i < n; ++i) {\\n            vector<int>& adjList = adjLists[i];\\n            int m = adjList.size();\\n            if (k < m) {\\n                nth_element(adjList.begin(), k + adjList.begin(), adjList.end(), greater<int>());\\n            }\\n            int sum = vals[i];\\n            for (int j = min(m, k) - 1; j >= 0; --j) { sum += adjList[j]; }\\n            bestSum = max(bestSum, sum);\\n        }\\n\\n        return bestSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```k```\n```k```\n```k```\n```(k + 1)```\n```nth_element```\n```k```\n```k```\n```k < m```\n```k >= m```\n```nth_element```\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n\\n        vector<vector<int>> adjLists(n, vector<int>());\\n        for (vector<int>& edge: edges) {\\n            int node1 = edge[0];\\n            int node2 = edge[1];\\n            if (vals[node2] > 0) { adjLists[node1].push_back(vals[node2]); }\\n            if (vals[node1] > 0) { adjLists[node2].push_back(vals[node1]); }\\n        }\\n\\n        int bestSum = INT_MIN;\\n        for (int i = 0; i < n; ++i) {\\n            vector<int>& adjList = adjLists[i];\\n            int m = adjList.size();\\n            if (k < m) {\\n                nth_element(adjList.begin(), k + adjList.begin(), adjList.end(), greater<int>());\\n            }\\n            int sum = vals[i];\\n            for (int j = min(m, k) - 1; j >= 0; --j) { sum += adjList[j]; }\\n            bestSum = max(bestSum, sum);\\n        }\\n\\n        return bestSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959884,
                "title": "c",
                "content": "class Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        vector<int>adj[vals.size()];\\n        \\n        int ans=-1e9;\\n        \\n        //adjacency list creation\\n        \\n        for(int i=0; i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        \\n        for(int i=0;i<vals.size();i++){\\n            priority_queue<int>pq;\\n            for(auto x: adj[i]){\\n                pq.push(vals[x]);\\n                \\n                \\n            }\\n          \\n            int temp=k;\\n            int sum=vals[i];\\n            while(temp-- && !pq.empty()){\\n                \\n                if(sum+pq.top()<=sum)break;\\n                sum+=pq.top();\\n                pq.pop();\\n            }\\n         \\n            ans=max(sum,ans);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Graph"
                ],
                "code": "class Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        vector<int>adj[vals.size()];\\n        \\n        int ans=-1e9;\\n        \\n        //adjacency list creation\\n        \\n        for(int i=0; i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3954060,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        vector<vector<int>> adj(vals.size());\\n\\n        if (edges.size() == 0) {\\n            int maxi1 = INT_MIN;\\n            for (int i = 0; i < vals.size(); i++) {\\n                maxi1 = max(maxi1, vals[i]);\\n            }\\n            return maxi1;\\n        }\\n\\n        for (auto it : edges) {\\n            adj[it[0]].push_back(vals[it[1]]);\\n            adj[it[1]].push_back(vals[it[0]]);\\n        }\\n\\n        int maxi = INT_MIN;\\n        for (int i = 0; i < adj.size(); i++) {\\n            int ans = 0;\\n            sort(adj[i].rbegin(), adj[i].rend()); // Sort the adjacency list of node i\\n            for (int j = 0; j < min(k, (int)adj[i].size()); j++) {\\n                if (adj[i][j] > 0) { // Check for positive values\\n                    ans += adj[i][j];\\n                }\\n            }\\n            ans+=vals[i];\\n            maxi = max(maxi, ans);\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        vector<vector<int>> adj(vals.size());\\n\\n        if (edges.size() == 0) {\\n            int maxi1 = INT_MIN;\\n            for (int i = 0; i < vals.size(); i++) {\\n                maxi1 = max(maxi1, vals[i]);\\n            }\\n            return maxi1;\\n        }\\n\\n        for (auto it : edges) {\\n            adj[it[0]].push_back(vals[it[1]]);\\n            adj[it[1]].push_back(vals[it[0]]);\\n        }\\n\\n        int maxi = INT_MIN;\\n        for (int i = 0; i < adj.size(); i++) {\\n            int ans = 0;\\n            sort(adj[i].rbegin(), adj[i].rend()); // Sort the adjacency list of node i\\n            for (int j = 0; j < min(k, (int)adj[i].size()); j++) {\\n                if (adj[i][j] > 0) { // Check for positive values\\n                    ans += adj[i][j];\\n                }\\n            }\\n            ans+=vals[i];\\n            maxi = max(maxi, ans);\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954058,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        vector<vector<int>> adj(vals.size());\\n\\n        if (edges.size() == 0) {\\n            int maxi1 = INT_MIN;\\n            for (int i = 0; i < vals.size(); i++) {\\n                maxi1 = max(maxi1, vals[i]);\\n            }\\n            return maxi1;\\n        }\\n\\n        for (auto it : edges) {\\n            adj[it[0]].push_back(vals[it[1]]);\\n            adj[it[1]].push_back(vals[it[0]]);\\n        }\\n\\n        int maxi = INT_MIN;\\n        for (int i = 0; i < adj.size(); i++) {\\n            int ans = 0;\\n            sort(adj[i].rbegin(), adj[i].rend()); // Sort the adjacency list of node i\\n            for (int j = 0; j < min(k, (int)adj[i].size()); j++) {\\n                if (adj[i][j] > 0) { // Check for positive values\\n                    ans += adj[i][j];\\n                }\\n            }\\n            ans+=vals[i];\\n            maxi = max(maxi, ans);\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        vector<vector<int>> adj(vals.size());\\n\\n        if (edges.size() == 0) {\\n            int maxi1 = INT_MIN;\\n            for (int i = 0; i < vals.size(); i++) {\\n                maxi1 = max(maxi1, vals[i]);\\n            }\\n            return maxi1;\\n        }\\n\\n        for (auto it : edges) {\\n            adj[it[0]].push_back(vals[it[1]]);\\n            adj[it[1]].push_back(vals[it[0]]);\\n        }\\n\\n        int maxi = INT_MIN;\\n        for (int i = 0; i < adj.size(); i++) {\\n            int ans = 0;\\n            sort(adj[i].rbegin(), adj[i].rend()); // Sort the adjacency list of node i\\n            for (int j = 0; j < min(k, (int)adj[i].size()); j++) {\\n                if (adj[i][j] > 0) { // Check for positive values\\n                    ans += adj[i][j];\\n                }\\n            }\\n            ans+=vals[i];\\n            maxi = max(maxi, ans);\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922238,
                "title": "c-java-simple-solution-10lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- This is not a Complete graph Question. Because you must be greedy in picking the weights.\\n- If you do not know graphs, though this can be solved.\\n- We make a adjacency list where we have n nodes as indices from 0 to n-1. Then we have a Priority Queue assigned to every node.\\n- The main thing here is we try to maximize the sum, so we need to take the highest values first till we reach the limit or all the neighbours are chosen.\\n- We can fill the adj list by corresponding vals rather than nodes.\\n- Then we iterate over every node making it as the center and picking the corresponding high value nei nodes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        priority_queue<int> adj[n];\\n        for(auto edge:edges)\\n        {\\n            adj[edge[0]].push(vals[edge[1]]);\\n            adj[edge[1]].push(vals[edge[0]]);\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int sum=vals[i];\\n            for(int j=0;j<k&& !adj[i].empty();j++){\\n                ans=max(ans,sum);\\n                sum+=adj[i].top();adj[i].pop();\\n            }\\n            ans=max(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```JAVA []\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        int n = vals.length;\\n        PriorityQueue<Integer>[] adj = new PriorityQueue[n];\\n        for (int i = 0; i < n; i++) {\\n            adj[i] = new PriorityQueue<>(Collections.reverseOrder());\\n        }\\n        for (int[] edge : edges) {\\n            adj[edge[0]].add(vals[edge[1]]);\\n            adj[edge[1]].add(vals[edge[0]]);\\n        }\\n        int ans = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            int sum = vals[i];\\n            for (int j = 0; j < k && !adj[i].isEmpty(); j++) {\\n                ans = Math.max(ans, sum);\\n                sum += adj[i].poll();\\n            }\\n            ans = Math.max(ans, sum);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        priority_queue<int> adj[n];\\n        for(auto edge:edges)\\n        {\\n            adj[edge[0]].push(vals[edge[1]]);\\n            adj[edge[1]].push(vals[edge[0]]);\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int sum=vals[i];\\n            for(int j=0;j<k&& !adj[i].empty();j++){\\n                ans=max(ans,sum);\\n                sum+=adj[i].top();adj[i].pop();\\n            }\\n            ans=max(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```JAVA []\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        int n = vals.length;\\n        PriorityQueue<Integer>[] adj = new PriorityQueue[n];\\n        for (int i = 0; i < n; i++) {\\n            adj[i] = new PriorityQueue<>(Collections.reverseOrder());\\n        }\\n        for (int[] edge : edges) {\\n            adj[edge[0]].add(vals[edge[1]]);\\n            adj[edge[1]].add(vals[edge[0]]);\\n        }\\n        int ans = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            int sum = vals[i];\\n            for (int j = 0; j < k && !adj[i].isEmpty(); j++) {\\n                ans = Math.max(ans, sum);\\n                sum += adj[i].poll();\\n            }\\n            ans = Math.max(ans, sum);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894150,
                "title": "simple-c-solution-without-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<vector<int>>adj(n);\\n        for(auto it:edges){\\n            adj[it[0]].push_back(vals[it[1]]);\\n            adj[it[1]].push_back(vals[it[0]]);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            sort(adj[i].begin(),adj[i].end());\\n            reverse(adj[i].begin(),adj[i].end());\\n\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int temp=0;\\n            int sm=0,cnt=0;\\n            for(auto it:adj[i]){\\n                if(cnt==k)break;\\n                sm+=it;\\n                temp=max(temp,sm);\\n                cnt++;\\n            }\\n            temp+=vals[i];\\n            ans=max(ans,temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<vector<int>>adj(n);\\n        for(auto it:edges){\\n            adj[it[0]].push_back(vals[it[1]]);\\n            adj[it[1]].push_back(vals[it[0]]);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            sort(adj[i].begin(),adj[i].end());\\n            reverse(adj[i].begin(),adj[i].end());\\n\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int temp=0;\\n            int sm=0,cnt=0;\\n            for(auto it:adj[i]){\\n                if(cnt==k)break;\\n                sm+=it;\\n                temp=max(temp,sm);\\n                cnt++;\\n            }\\n            temp+=vals[i];\\n            ans=max(ans,temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877158,
                "title": "very-easy-solution-using-graph-with-sorting-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        \\n        vector<vector<pair<int,int>>>adj(n);\\n        for(auto i : edges){\\n            adj[i[0]].push_back({vals[i[1]],i[1]});\\n            adj[i[1]].push_back({vals[i[0]],i[0]});\\n        \\n        }\\n        int ans=-10001;\\n        for(int i=0;i<n;i++){\\n            \\n                sort(adj[i].rbegin(),adj[i].rend());\\n                int temp=vals[i];\\n                for(int j=0;j<k;j++) {\\n                    if(j<adj[i].size() and adj[i][j].first>=0){\\n                    temp+=adj[i][j].first;\\n                    }\\n                    else break;\\n                }\\n                \\n                ans=max(temp,ans);\\n            \\n        }\\n        \\n        if(ans!=-10001)return ans;\\n        else if(k==1) return *max_element(vals.begin(),vals.end());\\n        else return 0;\\n    }\\n};\\n```\\n**Please Upvote if found usefull**",
                "solutionTags": [
                    "C",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        \\n        vector<vector<pair<int,int>>>adj(n);\\n        for(auto i : edges){\\n            adj[i[0]].push_back({vals[i[1]],i[1]});\\n            adj[i[1]].push_back({vals[i[0]],i[0]});\\n        \\n        }\\n        int ans=-10001;\\n        for(int i=0;i<n;i++){\\n            \\n                sort(adj[i].rbegin(),adj[i].rend());\\n                int temp=vals[i];\\n                for(int j=0;j<k;j++) {\\n                    if(j<adj[i].size() and adj[i][j].first>=0){\\n                    temp+=adj[i][j].first;\\n                    }\\n                    else break;\\n                }\\n                \\n                ans=max(temp,ans);\\n            \\n        }\\n        \\n        if(ans!=-10001)return ans;\\n        else if(k==1) return *max_element(vals.begin(),vals.end());\\n        else return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867352,
                "title": "c-easy-clean-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& v, vector<vector<int>>& e, int k) {\\n        map<int,priority_queue<int>> p;\\n        for(auto i : e)\\n        {\\n            p[i[0]].push(v[i[1]]);\\n            p[i[1]].push(v[i[0]]);\\n        }\\n        int m=INT_MIN;\\n        for(auto i: p)\\n        {\\n            int s=0,x=k;\\n            s+=v[i.first];\\n            m=max(m,s);\\n            priority_queue<int> q=i.second;\\n            while(q.size() && x--)\\n              {s+=q.top();\\n               q.pop();\\n               m=max(m,s);}\\n        }\\n        for(int i=0;i<v.size();i++)\\n            if(p[i].size()==0) m=max(m,v[i]);\\n        \\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& v, vector<vector<int>>& e, int k) {\\n        map<int,priority_queue<int>> p;\\n        for(auto i : e)\\n        {\\n            p[i[0]].push(v[i[1]]);\\n            p[i[1]].push(v[i[0]]);\\n        }\\n        int m=INT_MIN;\\n        for(auto i: p)\\n        {\\n            int s=0,x=k;\\n            s+=v[i.first];\\n            m=max(m,s);\\n            priority_queue<int> q=i.second;\\n            while(q.size() && x--)\\n              {s+=q.top();\\n               q.pop();\\n               m=max(m,s);}\\n        }\\n        for(int i=0;i<v.size();i++)\\n            if(p[i].size()==0) m=max(m,v[i]);\\n        \\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860688,
                "title": "o-n-n-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n \\n    bool static cmp(pair<int,int>& a, pair<int,int>& b) {\\n        return a.second >= b.second;\\n    }\\n\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n\\n        int n = vals.size();\\n        vector<pair<int,int>>adj[n + 1];\\n        \\n        for(int i = 0; i < edges.size(); i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            \\n            adj[u].push_back({v, vals[v]});\\n            adj[v].push_back({u, vals[u]});\\n        }\\n\\n        for(int i = 0; i < n; i++) {\\n            sort(adj[i].begin(), adj[i].end(), cmp);\\n        }\\n\\n\\n        int ans = INT_MIN;\\n\\n        for(int i = 0; i < n; i++) {\\n                int cnt = 0;\\n                int add = 0;\\n                for(auto it : adj[i]) {\\n                    if(vals[it.first] > 0) {\\n                        if(cnt == k) break;\\n                        add += vals[it.first];\\n                        cnt++;\\n                    } else {\\n                        break;\\n                    }\\n                }\\n        \\n            ans = max(ans, add + vals[i]);\\n        \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\n    bool static cmp(pair<int,int>& a, pair<int,int>& b) {\\n        return a.second >= b.second;\\n    }\\n\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n\\n        int n = vals.size();\\n        vector<pair<int,int>>adj[n + 1];\\n        \\n        for(int i = 0; i < edges.size(); i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            \\n            adj[u].push_back({v, vals[v]});\\n            adj[v].push_back({u, vals[u]});\\n        }\\n\\n        for(int i = 0; i < n; i++) {\\n            sort(adj[i].begin(), adj[i].end(), cmp);\\n        }\\n\\n\\n        int ans = INT_MIN;\\n\\n        for(int i = 0; i < n; i++) {\\n                int cnt = 0;\\n                int add = 0;\\n                for(auto it : adj[i]) {\\n                    if(vals[it.first] > 0) {\\n                        if(cnt == k) break;\\n                        add += vals[it.first];\\n                        cnt++;\\n                    } else {\\n                        break;\\n                    }\\n                }\\n        \\n            ans = max(ans, add + vals[i]);\\n        \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856618,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<vector<int>>adj(n);\\n        for (auto it: edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n             adj[it[1]].push_back(it[0]);\\n        }\\n        int ans=0;\\n        for (int i=0;i<n;i++)\\n        {\\n            sort(adj[i].begin(),adj[i].end(),[&](int k,int j){return vals[k]>vals[j];});\\n        }\\n        for (int i=0;i<n;i++)\\n        {\\n            int cur=0;\\n            for (int j=0;j<k && j<adj[i].size();j++)\\n            {\\n                if (vals[adj[i][j]]<0) break;\\n               cur+=vals[adj[i][j]];\\n            }\\n            cur+=vals[i];\\n            ans=max(ans,cur);\\n        }\\n        sort(vals.begin(),vals.end());\\n        if (ans==0)\\n        {\\n            if(vals[n-1]<0) return vals[n-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<vector<int>>adj(n);\\n        for (auto it: edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n             adj[it[1]].push_back(it[0]);\\n        }\\n        int ans=0;\\n        for (int i=0;i<n;i++)\\n        {\\n            sort(adj[i].begin(),adj[i].end(),[&](int k,int j){return vals[k]>vals[j];});\\n        }\\n        for (int i=0;i<n;i++)\\n        {\\n            int cur=0;\\n            for (int j=0;j<k && j<adj[i].size();j++)\\n            {\\n                if (vals[adj[i][j]]<0) break;\\n               cur+=vals[adj[i][j]];\\n            }\\n            cur+=vals[i];\\n            ans=max(ans,cur);\\n        }\\n        sort(vals.begin(),vals.end());\\n        if (ans==0)\\n        {\\n            if(vals[n-1]<0) return vals[n-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849371,
                "title": "c-solution-using-map-of-priority-queue",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBuild two maps :\\n1) mp1 which stores index of node and priority queue of nodes with positive weights connected to this node\\n2) mp2 which stores index of node and priority queue of nodes with negative weights connected to this node.\\n\\nNow run a loop through all nodes, first \\'ans\\' is checked with current node weight. Now check for one of the two conditions :\\n1) Now if node contains other positive weight nodes connected to it ( mp1[i] is not empty ), we iterate through them till the map is empty or k1 ( which contains how many edges current node can contain ) is 0. \\n2) If node contains no positive weight nodes connected to it, check for nodes with negative weight attached to it. Iterate till mp2[i] is not empty and k1>0 , adding to sum.\\nFinally update \\'ans\\' with max(ans,sum) inside both if-else constructs.\\n\\nReturn \\'ans\\'.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int ans=INT_MIN;\\n        // for(auto it:vals)\\n        //     ans=max(ans,it);\\n        map<int,priority_queue<int>>mp1; // node - positive sums\\n        map<int,priority_queue<int>>mp2; // node - negative sums\\n        for(auto it:edges)\\n        {\\n            if(vals[it[1]]>=0)\\n                mp1[it[0]].push(vals[it[1]]);\\n            else\\n                mp2[it[0]].push(vals[it[1]]);\\n            \\n            if(vals[it[0]]>=0)\\n                mp1[it[1]].push(vals[it[0]]);\\n            else\\n                mp2[it[1]].push(vals[it[0]]);\\n        }\\n\\n        // atmost k edges ( 0 to k )\\n        int sum=0;\\n        int i;\\n        int k1=k;\\n        for(i=0;i<vals.size();i++)\\n        {\\n            ans=max(ans,vals[i]);\\n            k1=k;\\n            if(mp1[i].size()>0)\\n            {\\n                sum=vals[i];\\n                while(!mp1[i].empty() && k1>0)\\n                {\\n                    sum+=mp1[i].top();\\n                    mp1[i].pop();\\n                    k1--;\\n                }\\n                ans=max(ans,sum);\\n            }\\n            else\\n            {\\n                sum=vals[i];\\n                while(!mp2[i].empty() && k1>0)\\n                {\\n                    sum+=mp2[i].top();\\n                    mp2[i].pop();\\n                    k1--;\\n                }\\n                ans=max(ans,sum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int ans=INT_MIN;\\n        // for(auto it:vals)\\n        //     ans=max(ans,it);\\n        map<int,priority_queue<int>>mp1; // node - positive sums\\n        map<int,priority_queue<int>>mp2; // node - negative sums\\n        for(auto it:edges)\\n        {\\n            if(vals[it[1]]>=0)\\n                mp1[it[0]].push(vals[it[1]]);\\n            else\\n                mp2[it[0]].push(vals[it[1]]);\\n            \\n            if(vals[it[0]]>=0)\\n                mp1[it[1]].push(vals[it[0]]);\\n            else\\n                mp2[it[1]].push(vals[it[0]]);\\n        }\\n\\n        // atmost k edges ( 0 to k )\\n        int sum=0;\\n        int i;\\n        int k1=k;\\n        for(i=0;i<vals.size();i++)\\n        {\\n            ans=max(ans,vals[i]);\\n            k1=k;\\n            if(mp1[i].size()>0)\\n            {\\n                sum=vals[i];\\n                while(!mp1[i].empty() && k1>0)\\n                {\\n                    sum+=mp1[i].top();\\n                    mp1[i].pop();\\n                    k1--;\\n                }\\n                ans=max(ans,sum);\\n            }\\n            else\\n            {\\n                sum=vals[i];\\n                while(!mp2[i].empty() && k1>0)\\n                {\\n                    sum+=mp2[i].top();\\n                    mp2[i].pop();\\n                    k1--;\\n                }\\n                ans=max(ans,sum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839394,
                "title": "python-max-heap",
                "content": "```\\nfrom collections import defaultdict\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def maxStarSum(self, vals, edges, k):\\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            heappush(graph[a], (-vals[b], b))\\n            heappush(graph[b], (-vals[a], a))\\n        ans = float(\\'-inf\\')\\n        for i in range(len(vals)):\\n            j, sumAtMostK = 0, 0\\n            while graph[i] and j < k:\\n                valueNode = heappop(graph[i])[0]\\n                if -valueNode >= 0:\\n                    sumAtMostK += -valueNode\\n                j += 1\\n            ans = max(ans, sumAtMostK + vals[i])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def maxStarSum(self, vals, edges, k):\\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            heappush(graph[a], (-vals[b], b))\\n            heappush(graph[b], (-vals[a], a))\\n        ans = float(\\'-inf\\')\\n        for i in range(len(vals)):\\n            j, sumAtMostK = 0, 0\\n            while graph[i] and j < k:\\n                valueNode = heappop(graph[i])[0]\\n                if -valueNode >= 0:\\n                    sumAtMostK += -valueNode\\n                j += 1\\n            ans = max(ans, sumAtMostK + vals[i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837932,
                "title": "beats-100-of-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple Approach\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int>adj[n];\\n        for(auto it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        int maxi=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,vals[i]);\\n            vector<int>t;\\n            for(auto it: adj[i]){\\n                t.push_back(vals[it]);\\n            }\\n            int currsum=vals[i];\\n            sort(t.begin(),t.end());\\n            reverse(t.begin(),t.end());\\n            for(int j=0;j<min(k,(int)t.size());j++){\\n                currsum+=t[j];\\n                maxi=max(maxi,currsum);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int>adj[n];\\n        for(auto it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        int maxi=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,vals[i]);\\n            vector<int>t;\\n            for(auto it: adj[i]){\\n                t.push_back(vals[it]);\\n            }\\n            int currsum=vals[i];\\n            sort(t.begin(),t.end());\\n            reverse(t.begin(),t.end());\\n            for(int j=0;j<min(k,(int)t.size());j++){\\n                currsum+=t[j];\\n                maxi=max(maxi,currsum);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830531,
                "title": "beat-100-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        vector<int>adj[vals.size()];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        ll ans=-1e9;\\n        \\n        for(int i=0;i<vals.size();i++){\\n            vector<int>p;\\n            ans=max(ans,(ll)vals[i]);\\n            for(auto it:adj[i]){\\n                p.push_back(vals[it]);\\n            }\\n            sort(p.begin(),p.end());\\n            ll sum=vals[i];\\n            for(int j=p.size()-1;j>=max(0,(int)p.size()-k);j--){\\n                sum+=p[j];\\n                ans=max(ans,sum);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        vector<int>adj[vals.size()];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        ll ans=-1e9;\\n        \\n        for(int i=0;i<vals.size();i++){\\n            vector<int>p;\\n            ans=max(ans,(ll)vals[i]);\\n            for(auto it:adj[i]){\\n                p.push_back(vals[it]);\\n            }\\n            sort(p.begin(),p.end());\\n            ll sum=vals[i];\\n            for(int j=p.size()-1;j>=max(0,(int)p.size()-k);j--){\\n                sum+=p[j];\\n                ans=max(ans,sum);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807380,
                "title": "easy-bfs-and-priority-queue-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nin star we onlly need to go only one step ahead of any node so =>bfs\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe traverse every node and do bfs up to one step and fill the values of the neighbours in the priority queue to find the top k elements \\nand only add the values which increases the sum \\n\\nfor top k element try -https://leetcode.com/problems/top-k-frequent-elements/\\n\\n\\n# Complexity\\n- Time complexity:\\n- O(NxExlog(E))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(NxE)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n    private:\\n\\n    int bfs(int node,vector<int>adj[],vector<int>&values,int &k){\\n\\n        queue<pair<int,int>>q;\\n        q.push({node,0});\\n\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        int sum=values[node];\\n\\n        while(!q.empty()){\\n\\n            int curr=q.front().first;\\n            int count=q.front().second;\\n            q.pop();\\n\\n            if(count==0){\\n\\n                for(auto neigh:adj[curr]){\\n\\n                    \\n                    q.push({neigh,count+1});\\n                    \\n                    pq.push(values[neigh]);\\n                    \\n                    if(pq.size()>k){\\n\\n                        pq.pop();\\n\\n                    }\\n                    \\n                }    \\n\\n            }\\n\\n        }\\n\\n        while(pq.size()!=0){\\n\\n            sum=max(sum+pq.top(),sum);\\n            pq.pop();\\n\\n        }\\n        return sum;\\n    }\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        \\n        int n=vals.size();\\n\\n        vector<int>adj[n];\\n\\n        for(auto edge:edges){\\n\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n\\n        }\\n\\n        int ans=INT_MIN;\\n\\n        for(int i=0;i<n;i++){\\n\\n            int sum=bfs(i,adj,vals,k);\\n\\n            ans=max(ans,sum);\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n\\n    private:\\n\\n    int bfs(int node,vector<int>adj[],vector<int>&values,int &k){\\n\\n        queue<pair<int,int>>q;\\n        q.push({node,0});\\n\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        int sum=values[node];\\n\\n        while(!q.empty()){\\n\\n            int curr=q.front().first;\\n            int count=q.front().second;\\n            q.pop();\\n\\n            if(count==0){\\n\\n                for(auto neigh:adj[curr]){\\n\\n                    \\n                    q.push({neigh,count+1});\\n                    \\n                    pq.push(values[neigh]);\\n                    \\n                    if(pq.size()>k){\\n\\n                        pq.pop();\\n\\n                    }\\n                    \\n                }    \\n\\n            }\\n\\n        }\\n\\n        while(pq.size()!=0){\\n\\n            sum=max(sum+pq.top(),sum);\\n            pq.pop();\\n\\n        }\\n        return sum;\\n    }\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        \\n        int n=vals.size();\\n\\n        vector<int>adj[n];\\n\\n        for(auto edge:edges){\\n\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n\\n        }\\n\\n        int ans=INT_MIN;\\n\\n        for(int i=0;i<n;i++){\\n\\n            int sum=bfs(i,adj,vals,k);\\n\\n            ans=max(ans,sum);\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765808,
                "title": "easy-java-solution-using-min-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   \\n  \\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        if(edges.length==0)\\n        {\\n           Arrays.sort(vals);\\n           return vals[vals.length-1];\\n        }\\n        ArrayList<ArrayList<Integer>>adj=new ArrayList<>();\\n       \\n        int max=Integer.MIN_VALUE;\\n        for(int i=0; i<vals.length; i++)\\n        {\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0; i<edges.length; i++)\\n        {\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n            \\n        }\\n        for(int i=0; i<vals.length; i++)\\n        {\\n            PriorityQueue<Integer>pq=new PriorityQueue<>();\\n            int sum=0;\\n         \\n            for(Integer it: adj.get(i))\\n            {\\n               \\n                pq.add(vals[it]);\\n                if(pq.size()>k)\\n                {\\n                    pq.poll();\\n                }\\n\\n            }\\n            while(!pq.isEmpty())\\n            {\\n             if(sum+pq.peek()>sum)\\n             {\\n                sum=sum+pq.peek();\\n             }\\n              pq.poll();\\n            }\\n            max=Integer.max(max,sum+vals[i]);\\n            max=Integer.max(max,vals[i]);\\n        }\\n       return max;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   \\n  \\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        if(edges.length==0)\\n        {\\n           Arrays.sort(vals);\\n           return vals[vals.length-1];\\n        }\\n        ArrayList<ArrayList<Integer>>adj=new ArrayList<>();\\n       \\n        int max=Integer.MIN_VALUE;\\n        for(int i=0; i<vals.length; i++)\\n        {\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0; i<edges.length; i++)\\n        {\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n            \\n        }\\n        for(int i=0; i<vals.length; i++)\\n        {\\n            PriorityQueue<Integer>pq=new PriorityQueue<>();\\n            int sum=0;\\n         \\n            for(Integer it: adj.get(i))\\n            {\\n               \\n                pq.add(vals[it]);\\n                if(pq.size()>k)\\n                {\\n                    pq.poll();\\n                }\\n\\n            }\\n            while(!pq.isEmpty())\\n            {\\n             if(sum+pq.peek()>sum)\\n             {\\n                sum=sum+pq.peek();\\n             }\\n              pq.poll();\\n            }\\n            max=Integer.max(max,sum+vals[i]);\\n            max=Integer.max(max,vals[i]);\\n        }\\n       return max;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753775,
                "title": "c-solution-simple-easy-and-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        vector<int> vec[n+1];\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            int u,v;\\n            u = edges[i][0];\\n            v = edges[i][1];\\n            vec[u].push_back(v);\\n            vec[v].push_back(u);\\n        }\\n        int ans = INT_MIN;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            priority_queue<int> q1;\\n            int sum = vals[i];\\n            for(auto it: vec[i])\\n            {\\n                q1.push(vals[it]);\\n            }\\n            \\n            for(int k1=0; k1<k && (!q1.empty()); k1++)\\n            {\\n                int temp = q1.top();\\n                q1.pop();\\n                if(sum<sum+temp)\\n                sum += temp; \\n            }\\n            ans = max(ans,sum);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        vector<int> vec[n+1];\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            int u,v;\\n            u = edges[i][0];\\n            v = edges[i][1];\\n            vec[u].push_back(v);\\n            vec[v].push_back(u);\\n        }\\n        int ans = INT_MIN;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            priority_queue<int> q1;\\n            int sum = vals[i];\\n            for(auto it: vec[i])\\n            {\\n                q1.push(vals[it]);\\n            }\\n            \\n            for(int k1=0; k1<k && (!q1.empty()); k1++)\\n            {\\n                int temp = q1.top();\\n                q1.pop();\\n                if(sum<sum+temp)\\n                sum += temp; \\n            }\\n            ans = max(ans,sum);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736544,
                "title": "python-92-top-dictionary-heap",
                "content": "# Intuition\\nFor each node we want at most k biggest nodes connected to it via edge.\\nSo we want to keep them and then sum their values.\\n\\n# Approach\\nWe create a min heap for each node that will only take possitive values.\\nIf the heap is smaller then k we can add, otherwise we will remove the smallest element and replace it if we find a bigger node.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        if not k: return max(vals)\\n        heap_dict = defaultdict(list)\\n        ans = 0\\n        for n1,n2 in edges:\\n            if vals[n2]>0:\\n                if len(heap_dict[n1])<k: \\n                    heapq.heappush(heap_dict[n1], vals[n2])\\n                elif heap_dict[n1][0] < vals[n2]:\\n                    heapq.heapreplace(heap_dict[n1],vals[n2])\\n            if vals[n1]>0:\\n                if len(heap_dict[n2])<k: \\n                    heapq.heappush(heap_dict[n2], vals[n1])\\n                elif heap_dict[n2][0] < vals[n1]:\\n                    heapq.heapreplace(heap_dict[n2],vals[n1])\\n        return max(val+sum(heap_dict[i]) for i,val in enumerate(vals))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        if not k: return max(vals)\\n        heap_dict = defaultdict(list)\\n        ans = 0\\n        for n1,n2 in edges:\\n            if vals[n2]>0:\\n                if len(heap_dict[n1])<k: \\n                    heapq.heappush(heap_dict[n1], vals[n2])\\n                elif heap_dict[n1][0] < vals[n2]:\\n                    heapq.heapreplace(heap_dict[n1],vals[n2])\\n            if vals[n1]>0:\\n                if len(heap_dict[n2])<k: \\n                    heapq.heappush(heap_dict[n2], vals[n1])\\n                elif heap_dict[n2][0] < vals[n1]:\\n                    heapq.heapreplace(heap_dict[n2],vals[n1])\\n        return max(val+sum(heap_dict[i]) for i,val in enumerate(vals))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724272,
                "title": "kotlin-solution",
                "content": "# Intuition\\nEssentially what they\\'re asking for is the max sum of a node plus up to k of it\\'s neighbors.\\n\\n# Approach\\nI started by building a graph, but realized if I stored them in a list or set, I would have to sort the neighbors later to grab the largest k of them greater than 0. Since rather than navigating the graph, we just need to visit every node a single time, we can store neighbors in a MaxHeap, so they\\'re already sorted, and removing them from the heap while processing each node won\\'t cause any problems\\n\\n# Complexity\\n- Time complexity:\\n$$O(v + eloge)$$ to build the map because heap insertions, and $$O(v * k)$$ to get the max sum, but if k is treated like a constant here, building the map should be the bottleneck.\\n\\n- Space complexity:\\nSomething like $$O(v + e)$$ I guess, for the keys and values in the map. Clearly maps have some overhead inherent in the implementation.\\n\\n# Code\\n```\\nclass Solution {\\n    fun maxStarSum(vals: IntArray, edges: Array<IntArray>, k: Int): Int {\\n        val map = buildMap(vals, edges)\\n\\n        var maxSum = Integer.MIN_VALUE\\n\\n        map.forEach { entry ->\\n            var sum = vals[entry.key]\\n            val neighbors = entry.value\\n            var edges = 0\\n\\n            for (i in 0 until k) {\\n                if (neighbors.isEmpty() || neighbors.peek() <= 0) {\\n                    break\\n                }\\n                sum += neighbors.remove()\\n            }\\n            maxSum = maxOf(maxSum, sum)\\n        }\\n\\n        return maxSum\\n    }\\n\\n    fun buildMap(vals: IntArray, edges: Array<IntArray>): Map<Int, PriorityQueue<Int>> {\\n        val map = mutableMapOf<Int, PriorityQueue<Int>>()\\n        \\n        for (i in 0 until vals.size) {\\n            map[i] = PriorityQueue<Int>(compareByDescending { it })\\n        }\\n\\n        edges.forEach { edge ->\\n            map[edge[0]]?.add(vals[edge[1]])\\n            map[edge[1]]?.add(vals[edge[0]])\\n        }\\n\\n        return map\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    fun maxStarSum(vals: IntArray, edges: Array<IntArray>, k: Int): Int {\\n        val map = buildMap(vals, edges)\\n\\n        var maxSum = Integer.MIN_VALUE\\n\\n        map.forEach { entry ->\\n            var sum = vals[entry.key]\\n            val neighbors = entry.value\\n            var edges = 0\\n\\n            for (i in 0 until k) {\\n                if (neighbors.isEmpty() || neighbors.peek() <= 0) {\\n                    break\\n                }\\n                sum += neighbors.remove()\\n            }\\n            maxSum = maxOf(maxSum, sum)\\n        }\\n\\n        return maxSum\\n    }\\n\\n    fun buildMap(vals: IntArray, edges: Array<IntArray>): Map<Int, PriorityQueue<Int>> {\\n        val map = mutableMapOf<Int, PriorityQueue<Int>>()\\n        \\n        for (i in 0 until vals.size) {\\n            map[i] = PriorityQueue<Int>(compareByDescending { it })\\n        }\\n\\n        edges.forEach { edge ->\\n            map[edge[0]]?.add(vals[edge[1]])\\n            map[edge[1]]?.add(vals[edge[0]])\\n        }\\n\\n        return map\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712690,
                "title": "easy-java-solution-using-arraylist",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        int n = vals.length;\\n        List<Integer>[] graph = new List[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<Integer>();\\n        }\\n        \\n        for (int[] edge : edges) {\\n            int a = edge[0], b = edge[1];\\n            graph[a].add(b);\\n            graph[b].add(a);\\n        }\\n        \\n        long res = Long.MIN_VALUE;\\n        \\n        for (int i = 0; i < n; i++) {\\n            List<Integer> curr = graph[i];\\n            \\n            curr.sort((a, b) -> vals[b]-vals[a]);\\n            \\n            long max = vals[i], sum = vals[i];\\n            \\n            for (int j = 0; j < k && j < curr.size(); j++) {\\n                sum += vals[curr.get(j)];\\n                max = Math.max(max, sum);\\n            }\\n            \\n            res = Math.max(res, max);\\n        }\\n        \\n        return (int) res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        int n = vals.length;\\n        List<Integer>[] graph = new List[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<Integer>();\\n        }\\n        \\n        for (int[] edge : edges) {\\n            int a = edge[0], b = edge[1];\\n            graph[a].add(b);\\n            graph[b].add(a);\\n        }\\n        \\n        long res = Long.MIN_VALUE;\\n        \\n        for (int i = 0; i < n; i++) {\\n            List<Integer> curr = graph[i];\\n            \\n            curr.sort((a, b) -> vals[b]-vals[a]);\\n            \\n            long max = vals[i], sum = vals[i];\\n            \\n            for (int j = 0; j < k && j < curr.size(); j++) {\\n                sum += vals[curr.get(j)];\\n                max = Math.max(max, sum);\\n            }\\n            \\n            res = Math.max(res, max);\\n        }\\n        \\n        return (int) res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710978,
                "title": "java-solution-using-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        List<List<Integer>> graph=new ArrayList<List<Integer>>();\\n        if(edges.length==0)\\n        {\\n            if(vals.length==1) return vals[0];\\n        }\\n        for(int i=0;i<vals.length;i++)\\n        graph.add(new ArrayList<Integer>());\\n        for(int[] edge:edges)\\n        {\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<graph.size();i++)\\n        {\\n            PriorityQueue<Integer> pq=new PriorityQueue<Integer>((a,b)->(b-a));\\n            int count=vals[i],temp=k;\\n            for(Integer t:graph.get(i))\\n            {\\n              pq.add(vals[t]);\\n            }\\n            max=Math.max(max,count);\\n            while(temp>0&&!pq.isEmpty())\\n            {\\n                count+=pq.poll();\\n                max=Math.max(max,count);\\n                temp--;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        List<List<Integer>> graph=new ArrayList<List<Integer>>();\\n        if(edges.length==0)\\n        {\\n            if(vals.length==1) return vals[0];\\n        }\\n        for(int i=0;i<vals.length;i++)\\n        graph.add(new ArrayList<Integer>());\\n        for(int[] edge:edges)\\n        {\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<graph.size();i++)\\n        {\\n            PriorityQueue<Integer> pq=new PriorityQueue<Integer>((a,b)->(b-a));\\n            int count=vals[i],temp=k;\\n            for(Integer t:graph.get(i))\\n            {\\n              pq.add(vals[t]);\\n            }\\n            max=Math.max(max,count);\\n            while(temp>0&&!pq.isEmpty())\\n            {\\n                count+=pq.poll();\\n                max=Math.max(max,count);\\n                temp--;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700204,
                "title": "multiset-approach-c-simple",
                "content": "**Multiset Approach C++ Simple**\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        multiset<int, greater<int>> adj[n];\\n        for(auto &edge:edges) {\\n            adj[edge[0]].insert(vals[edge[1]]);\\n            adj[edge[1]].insert(vals[edge[0]]);\\n        }\\n        \\n        int maxSum = INT_MIN;\\n        for(int i = 0; i < n; i++) {\\n            int currSum = vals[i];\\n            auto it = adj[i].begin();\\n            int j = 1;\\n            while(it != adj[i].end() && j <= k) {\\n                if(currSum + (*it) > currSum) {\\n                    currSum += *it;\\n                    j++;\\n                }\\n                it++;\\n            }\\n            maxSum = max(maxSum, currSum);\\n        }\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        multiset<int, greater<int>> adj[n];\\n        for(auto &edge:edges) {\\n            adj[edge[0]].insert(vals[edge[1]]);\\n            adj[edge[1]].insert(vals[edge[0]]);\\n        }\\n        \\n        int maxSum = INT_MIN;\\n        for(int i = 0; i < n; i++) {\\n            int currSum = vals[i];\\n            auto it = adj[i].begin();\\n            int j = 1;\\n            while(it != adj[i].end() && j <= k) {\\n                if(currSum + (*it) > currSum) {\\n                    currSum += *it;\\n                    j++;\\n                }\\n                it++;\\n            }\\n            maxSum = max(maxSum, currSum);\\n        }\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697258,
                "title": "generic-approach-making-an-optimal-graph-c-graph-max-heap",
                "content": "# Intuition\\n- Make the Graph such that i has an edge to j if and only if value of j increases total value of i\\'s star graph. This happens only when vals[j] > 0.\\n- Then all we have to do is scan through all nodes and for all nodes one by one push all of their neighbours along with their values in a max heap and keep on choosing neighbours as long as we haven\\'t chosen k neighbours (here we can eigher choose k neighbours or we exhaust max heap).\\n- Note that we have to chose min(k,pq.size()) as we can exhaust priority_queue before hitting k.\\n- Also note that it we don\\'t have to check whether a particular neighbour will increase the value or not as we have made the graph in such a way that it\\'ll always do so.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Make the graph as described above (adj)\\n- Keep a maximum sum variable (maxsum). This will be our answer\\n- For all nodes i:-\\n- Make a max heap and push all of it\\'s neighbouring nodes in it. Also keep a temporary sum variable (sum) to see the sum of that particular node.\\n- Then keep on adding in sum as long as min(k,pq.size()) is not reached.\\n- Then update maxsum.\\n- After scanning for all nodes, return the final value of maxsum.\\n# Complexity\\n- Time complexity: O(V+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIt takes O(V+E) to scan for graph and O(V+E) for the bigger for loop\\n- Space complexity: O(V+E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIt takes O(V+E) for graph and O(V+E) for max heap.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        vector<int> adj[n];\\n        for (auto i:edges){\\n            if (vals[i[1]]>0) adj[i[0]].push_back(i[1]);\\n            if (vals[i[0]]>0) adj[i[1]].push_back(i[0]);\\n        }\\n        int maxsum = INT_MIN;\\n        for (int i=0;i<n;i++){\\n            priority_queue<pair<int,int>> pq;\\n            int sum = vals[i];\\n            for (auto j:adj[i]){\\n                pq.push(make_pair(vals[j],j));\\n            }\\n            int l = 0;\\n            while(!pq.empty()){\\n                if (l==k) break;\\n                pair<int,int> p = pq.top();\\n                pq.pop();\\n\\n                sum+=p.first;\\n                l++;\\n                if (l==k) break;\\n            }\\n            maxsum = max(maxsum,sum);\\n        }\\n        return maxsum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        vector<int> adj[n];\\n        for (auto i:edges){\\n            if (vals[i[1]]>0) adj[i[0]].push_back(i[1]);\\n            if (vals[i[0]]>0) adj[i[1]].push_back(i[0]);\\n        }\\n        int maxsum = INT_MIN;\\n        for (int i=0;i<n;i++){\\n            priority_queue<pair<int,int>> pq;\\n            int sum = vals[i];\\n            for (auto j:adj[i]){\\n                pq.push(make_pair(vals[j],j));\\n            }\\n            int l = 0;\\n            while(!pq.empty()){\\n                if (l==k) break;\\n                pair<int,int> p = pq.top();\\n                pq.pop();\\n\\n                sum+=p.first;\\n                l++;\\n                if (l==k) break;\\n            }\\n            maxsum = max(maxsum,sum);\\n        }\\n        return maxsum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679882,
                "title": "priority-queue-is-enough-no-dfs-bfs",
                "content": "# Complexity\\n- Time complexity:\\n  O(eloge+n)\\n\\n- Space complexity:\\n  O(e)\\n\\ne is the number of edges in the graph.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        vector<priority_queue<pair<int,int> ,vector<pair<int,int>> ,greater<pair<int,int>> > > adj(vals.size());\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push({vals[edges[i][1]],edges[i][1]});\\n            adj[edges[i][1]].push({vals[edges[i][0]],edges[i][0]});\\n            if(adj[edges[i][0]].size()>k) adj[edges[i][0]].pop();\\n            if(adj[edges[i][1]].size()>k) adj[edges[i][1]].pop();\\n        }\\n\\n        int maxi = INT_MIN;\\n        for(int i=0;i<adj.size();i++){\\n            int tot = vals[i];\\n            priority_queue<pair<int,int> ,vector<pair<int,int>> ,greater<pair<int,int>> > & t = adj[i];\\n            while(!t.empty()){\\n                maxi = max(maxi,tot);\\n                if(t.top().first>0) tot+=  t.top().first;\\n                t.pop();\\n            }\\n            maxi = max(maxi,tot);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        vector<priority_queue<pair<int,int> ,vector<pair<int,int>> ,greater<pair<int,int>> > > adj(vals.size());\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push({vals[edges[i][1]],edges[i][1]});\\n            adj[edges[i][1]].push({vals[edges[i][0]],edges[i][0]});\\n            if(adj[edges[i][0]].size()>k) adj[edges[i][0]].pop();\\n            if(adj[edges[i][1]].size()>k) adj[edges[i][1]].pop();\\n        }\\n\\n        int maxi = INT_MIN;\\n        for(int i=0;i<adj.size();i++){\\n            int tot = vals[i];\\n            priority_queue<pair<int,int> ,vector<pair<int,int>> ,greater<pair<int,int>> > & t = adj[i];\\n            while(!t.empty()){\\n                maxi = max(maxi,tot);\\n                if(t.top().first>0) tot+=  t.top().first;\\n                t.pop();\\n            }\\n            maxi = max(maxi,tot);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678021,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) \\n    {\\n        if(edges.size()==0)\\n        {\\n            return *max_element(vals.begin(),vals.end());\\n        }\\n\\n        int ans;\\n        ans=INT_MIN;\\n\\n        vector<vector<int>> v(vals.size());\\n\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            v[edges[i][0]].push_back(vals[edges[i][1]]);\\n            v[edges[i][1]].push_back(vals[edges[i][0]]);\\n        }   \\n\\n        for(int i=0;i<vals.size();i++)\\n        {\\n            sort(v[i].rbegin(),v[i].rend());\\n\\n            int sum;\\n            sum=vals[i];\\n            ans=max(ans,sum);\\n\\n            for(int j=0;j<v[i].size() && j<k && v[i][j]>0;j++)\\n            {\\n                sum+=v[i][j];\\n            }\\n            \\n            ans=max(ans,sum);\\n        }\\n\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) \\n    {\\n        if(edges.size()==0)\\n        {\\n            return *max_element(vals.begin(),vals.end());\\n        }\\n\\n        int ans;\\n        ans=INT_MIN;\\n\\n        vector<vector<int>> v(vals.size());\\n\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            v[edges[i][0]].push_back(vals[edges[i][1]]);\\n            v[edges[i][1]].push_back(vals[edges[i][0]]);\\n        }   \\n\\n        for(int i=0;i<vals.size();i++)\\n        {\\n            sort(v[i].rbegin(),v[i].rend());\\n\\n            int sum;\\n            sum=vals[i];\\n            ans=max(ans,sum);\\n\\n            for(int j=0;j<v[i].size() && j<k && v[i][j]>0;j++)\\n            {\\n                sum+=v[i][j];\\n            }\\n            \\n            ans=max(ans,sum);\\n        }\\n\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672838,
                "title": "simple-c-solution-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        vector<priority_queue<int,vector<int>,greater<int>>>v(vals.size(),priority_queue<int,vector<int>,greater<int>>());\\n        vector<int>sum(vals.size(),0);\\n        int ans=-1e9;\\n        for(int i=0;i<vals.size();i++){\\n            sum[i]=vals[i];\\n            ans=max(ans,vals[i]);\\n        }\\n        if(k==0)return ans;\\n        for(int i=0;i<edges.size();i++){\\n            int node1=edges[i][0];\\n            int node2=edges[i][1];\\n            int size_node1=v[node1].size();\\n            int size_node2=v[node2].size();\\n            int sum_node1=sum[node1];\\n            int sum_node2=sum[node2];\\n            if(size_node1<k){\\n                if(vals[node2]>=0){v[node1].push(vals[node2]);\\n                sum[node1]=sum[node1]+vals[node2];\\n                ans=max(ans,sum[node1]);\\n                }\\n            }\\n            else if(size_node1==k){\\n                auto it=v[node1].top();\\n                if(it<vals[node2]){\\n                    v[node1].pop();\\n                v[node1].push(vals[node2]);\\n                sum[node1]=sum[node1]-it;\\n                sum[node1]=sum[node1]+vals[node2];\\n                ans=max(ans,sum[node1]);\\n                }\\n            }\\n            if(size_node2<k){\\n                if(vals[node1]>=0){v[node2].push(vals[node1]);\\n                sum[node2]=sum[node2]+vals[node1];\\n                ans=max(ans,sum[node2]);\\n                }\\n            }\\n            else if(size_node2==k){\\n                auto it=v[node2].top();\\n                if(it<vals[node1]){\\n                    v[node2].pop();\\n                v[node2].push(vals[node1]);\\n                sum[node2]=sum[node2]-it;\\n                \\n                sum[node2]=sum[node2]+vals[node1];\\n                ans=max(ans,sum[node2]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        vector<priority_queue<int,vector<int>,greater<int>>>v(vals.size(),priority_queue<int,vector<int>,greater<int>>());\\n        vector<int>sum(vals.size(),0);\\n        int ans=-1e9;\\n        for(int i=0;i<vals.size();i++){\\n            sum[i]=vals[i];\\n            ans=max(ans,vals[i]);\\n        }\\n        if(k==0)return ans;\\n        for(int i=0;i<edges.size();i++){\\n            int node1=edges[i][0];\\n            int node2=edges[i][1];\\n            int size_node1=v[node1].size();\\n            int size_node2=v[node2].size();\\n            int sum_node1=sum[node1];\\n            int sum_node2=sum[node2];\\n            if(size_node1<k){\\n                if(vals[node2]>=0){v[node1].push(vals[node2]);\\n                sum[node1]=sum[node1]+vals[node2];\\n                ans=max(ans,sum[node1]);\\n                }\\n            }\\n            else if(size_node1==k){\\n                auto it=v[node1].top();\\n                if(it<vals[node2]){\\n                    v[node1].pop();\\n                v[node1].push(vals[node2]);\\n                sum[node1]=sum[node1]-it;\\n                sum[node1]=sum[node1]+vals[node2];\\n                ans=max(ans,sum[node1]);\\n                }\\n            }\\n            if(size_node2<k){\\n                if(vals[node1]>=0){v[node2].push(vals[node1]);\\n                sum[node2]=sum[node2]+vals[node1];\\n                ans=max(ans,sum[node2]);\\n                }\\n            }\\n            else if(size_node2==k){\\n                auto it=v[node2].top();\\n                if(it<vals[node1]){\\n                    v[node2].pop();\\n                v[node2].push(vals[node1]);\\n                sum[node2]=sum[node2]-it;\\n                \\n                sum[node2]=sum[node2]+vals[node1];\\n                ans=max(ans,sum[node2]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671667,
                "title": "heap-hashmap",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each node, store value of its adjacent vertex in a hashmap, iterate through each element of the k-th largest element and calculate star sum along the way.\\n\\nSet current estimate to the largest value of a node to deal with isolated vertex.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        D = defaultdict(list)\\n        ret = max(vals)\\n\\n        for u, v in edges:\\n            D[u].append(vals[v])\\n            D[v].append(vals[u])\\n        \\n        for node in D:\\n            heapq._heapify_max(D[node])\\n            star_sum = vals[node]\\n\\n            for val in nlargest(k, D[node]):\\n                star_sum += val\\n                ret = max(ret, star_sum)\\n\\n        return ret\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        D = defaultdict(list)\\n        ret = max(vals)\\n\\n        for u, v in edges:\\n            D[u].append(vals[v])\\n            D[v].append(vals[u])\\n        \\n        for node in D:\\n            heapq._heapify_max(D[node])\\n            star_sum = vals[node]\\n\\n            for val in nlargest(k, D[node]):\\n                star_sum += val\\n                ret = max(ret, star_sum)\\n\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663477,
                "title": "brute-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n\\n        vector<vector<int>> graph(n+1);\\n        int maxi=INT_MIN;\\n\\n        for(auto it:edges){\\n            graph[it[0]].push_back(vals[it[1]]);\\n            graph[it[1]].push_back(vals[it[0]]);\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            sort(graph[i].begin(), graph[i].end(), greater<int>());\\n            int sum=0;\\n            sum=vals[i];\\n            for(int j=0;j<k && j<graph[i].size(); j++){\\n                sum += max(0,graph[i][j]);//beacuse graph[i][j] can be negative\\n            }\\n            maxi=max(maxi,sum);\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n\\n        vector<vector<int>> graph(n+1);\\n        int maxi=INT_MIN;\\n\\n        for(auto it:edges){\\n            graph[it[0]].push_back(vals[it[1]]);\\n            graph[it[1]].push_back(vals[it[0]]);\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            sort(graph[i].begin(), graph[i].end(), greater<int>());\\n            int sum=0;\\n            sum=vals[i];\\n            for(int j=0;j<k && j<graph[i].size(); j++){\\n                sum += max(0,graph[i][j]);//beacuse graph[i][j] can be negative\\n            }\\n            maxi=max(maxi,sum);\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661699,
                "title": "solved-with-priority-queue",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalSum(priority_queue<int, vector<int>, greater<int>> q){\\n        int sum = 0;\\n        while(q.size()){\\n            if(q.top()>0)\\n            sum+=q.top();\\n            q.pop();\\n        }\\n        return sum;\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        int maxi1 = INT_MIN;\\n        for(auto i: vals) maxi1=  max(maxi1, i);\\n        vector<vector<int>> graph(n);\\n        for(auto i: edges){\\n            graph[i[0]].push_back(i[1]);\\n            graph[i[1]].push_back(i[0]);\\n        }\\n        int maxi = INT_MIN;\\n        for(int i=0; i<n; i++){\\n                priority_queue<int, vector<int>, greater<int>> q;\\n                for(auto j: graph[i]){\\n                    q.push(vals[j]);\\n                    if(q.size()>k) q.pop();\\n                }\\n                int sum = totalSum(q);\\n                maxi = max(sum+vals[i], maxi);\\n        }\\n        return max(maxi1, maxi );\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSum(priority_queue<int, vector<int>, greater<int>> q){\\n        int sum = 0;\\n        while(q.size()){\\n            if(q.top()>0)\\n            sum+=q.top();\\n            q.pop();\\n        }\\n        return sum;\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        int maxi1 = INT_MIN;\\n        for(auto i: vals) maxi1=  max(maxi1, i);\\n        vector<vector<int>> graph(n);\\n        for(auto i: edges){\\n            graph[i[0]].push_back(i[1]);\\n            graph[i[1]].push_back(i[0]);\\n        }\\n        int maxi = INT_MIN;\\n        for(int i=0; i<n; i++){\\n                priority_queue<int, vector<int>, greater<int>> q;\\n                for(auto j: graph[i]){\\n                    q.push(vals[j]);\\n                    if(q.size()>k) q.pop();\\n                }\\n                int sum = totalSum(q);\\n                maxi = max(sum+vals[i], maxi);\\n        }\\n        return max(maxi1, maxi );\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646369,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2 Log(k))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n+e)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int N = vals.size();\\n        int M = edges.size();\\n        \\n        vector<int> adj[N];\\n        \\n        for(auto e : edges){ \\n\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);         \\n        }\\n\\n        int maxSum = INT_MIN;\\n\\n        for(int i=0; i<N; i++){ \\n            int currSum = vals[i]; \\n\\n            priority_queue<int,vector<int>,greater<int>> minH;\\n\\n            for(int adjN : adj[i] ){ \\n                if(vals[adjN] > 0) \\n                    minH.push(vals[adjN]); //O(Log K) \\n                if(minH.size() > k) \\n                    minH.pop(); // O(log k)\\n\\n            }\\n            while(!minH.empty()){ //O(K)\\n                currSum += minH.top();\\n                minH.pop();\\n            }\\n\\n            maxSum = max(maxSum, currSum);\\n\\n        }\\n\\n        return maxSum;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int N = vals.size();\\n        int M = edges.size();\\n        \\n        vector<int> adj[N];\\n        \\n        for(auto e : edges){ \\n\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);         \\n        }\\n\\n        int maxSum = INT_MIN;\\n\\n        for(int i=0; i<N; i++){ \\n            int currSum = vals[i]; \\n\\n            priority_queue<int,vector<int>,greater<int>> minH;\\n\\n            for(int adjN : adj[i] ){ \\n                if(vals[adjN] > 0) \\n                    minH.push(vals[adjN]); //O(Log K) \\n                if(minH.size() > k) \\n                    minH.pop(); // O(log k)\\n\\n            }\\n            while(!minH.empty()){ //O(K)\\n                currSum += minH.top();\\n                minH.pop();\\n            }\\n\\n            maxSum = max(maxSum, currSum);\\n\\n        }\\n\\n        return maxSum;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614070,
                "title": "c-dfs",
                "content": "# Complexity\\n- Time complexity: $$O(NlogN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int ans;\\n    vector<bool> visited;\\n    void dfs(int u , vector<int> adj[] , vector<int> &vals , int k) {\\n        visited[u] = true;\\n        int cnt = vals[u];\\n        vector<int> vec;\\n        for(int v : adj[u]) {\\n            if(vals[v] > 0) vec.push_back(vals[v]);\\n            if(!visited[v]) {\\n                dfs(v , adj , vals , k);\\n            }\\n        }\\n        sort(vec.begin() , vec.end() , greater<int>());\\n        for(int i=0 ; i<min(k , (int)vec.size()) ; i++) {\\n            cnt += vec[i];\\n        }\\n        ans = max(ans , cnt);\\n    }\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        vector<int> adj[n];\\n        for(int i=0 ; i<edges.size() ; i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        ans = INT_MIN;\\n        for(int i=0 ; i<n ; i++) {\\n            ans = max(ans , vals[i]);\\n        }\\n        visited.clear();\\n        visited.resize(n , false);\\n        for(int i=0 ; i<n ; i++) {\\n            if(!visited[i]) {\\n                dfs(i , adj , vals , k);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int ans;\\n    vector<bool> visited;\\n    void dfs(int u , vector<int> adj[] , vector<int> &vals , int k) {\\n        visited[u] = true;\\n        int cnt = vals[u];\\n        vector<int> vec;\\n        for(int v : adj[u]) {\\n            if(vals[v] > 0) vec.push_back(vals[v]);\\n            if(!visited[v]) {\\n                dfs(v , adj , vals , k);\\n            }\\n        }\\n        sort(vec.begin() , vec.end() , greater<int>());\\n        for(int i=0 ; i<min(k , (int)vec.size()) ; i++) {\\n            cnt += vec[i];\\n        }\\n        ans = max(ans , cnt);\\n    }\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        vector<int> adj[n];\\n        for(int i=0 ; i<edges.size() ; i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        ans = INT_MIN;\\n        for(int i=0 ; i<n ; i++) {\\n            ans = max(ans , vals[i]);\\n        }\\n        visited.clear();\\n        visited.resize(n , false);\\n        for(int i=0 ; i<n ; i++) {\\n            if(!visited[i]) {\\n                dfs(i , adj , vals , k);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602719,
                "title": "c-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        vector<priority_queue<int>> star(n);\\n        for(vector<int>&edge: edges) {\\n            if(vals[edge[0]] > 0)\\n                star[edge[1]].push(vals[edge[0]]);\\n            if(vals[edge[1]] > 0)\\n                star[edge[0]].push(vals[edge[1]]);\\n        }\\n        int ans=-1e9;\\n        for(int i=0;i<n;i++){\\n            int num=k;\\n            int sum=vals[i];\\n            while(num>0 and !star[i].empty()){\\n                sum+=star[i].top();\\n                star[i].pop();\\n                num--;\\n            }\\n            ans=max(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        vector<priority_queue<int>> star(n);\\n        for(vector<int>&edge: edges) {\\n            if(vals[edge[0]] > 0)\\n                star[edge[1]].push(vals[edge[0]]);\\n            if(vals[edge[1]] > 0)\\n                star[edge[0]].push(vals[edge[1]]);\\n        }\\n        int ans=-1e9;\\n        for(int i=0;i<n;i++){\\n            int num=k;\\n            int sum=vals[i];\\n            while(num>0 and !star[i].empty()){\\n                sum+=star[i].top();\\n                star[i].pop();\\n                num--;\\n            }\\n            ans=max(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584057,
                "title": "simple-ruby-solution",
                "content": "# Code\\n```\\ndef max_star_sum vals, edges, k \\n    return vals[0] if vals.length == 1\\n    graph = {}\\n\\n    edges.each do |l, r| \\n        graph[l] ||= []\\n        graph[l] << vals[r] if vals[r] > 0\\n\\n        graph[r] ||= []\\n        graph[r] << vals[l] if vals[l] > 0\\n    end \\n\\n    largest = vals.max\\n\\n    graph.each do |key, values| \\n        sublist = values.sort.reverse \\n        largest = [largest, sublist[0...k].sum + vals[key]].max\\n    end \\n\\n    return largest\\nend \\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef max_star_sum vals, edges, k \\n    return vals[0] if vals.length == 1\\n    graph = {}\\n\\n    edges.each do |l, r| \\n        graph[l] ||= []\\n        graph[l] << vals[r] if vals[r] > 0\\n\\n        graph[r] ||= []\\n        graph[r] << vals[l] if vals[l] > 0\\n    end \\n\\n    largest = vals.max\\n\\n    graph.each do |key, values| \\n        sublist = values.sort.reverse \\n        largest = [largest, sublist[0...k].sum + vals[key]].max\\n    end \\n\\n    return largest\\nend \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3565022,
                "title": "clean-and-easy-to-understand",
                "content": "```\\nclass Solution {\\n    vector<int>adj[100001];\\n    #define ppi int\\n\\n#define mhp priority_queue<ppi,vector<ppi>,greater<ppi>>\\n\\npublic:\\n    int maxStarSum(vector<int>& v, vector<vector<int>>& e, int k) {\\n        for(auto i:e)adj[i[0]].push_back(i[1]),adj[i[1]].push_back(i[0]);\\n        \\n        long int n=v.size(),ans=-1e9;\\n        \\n        for(int i=0;i<n;i++){\\n            mhp q;\\n            long s=0,c=0;\\n           \\n            for(auto j:adj[i]){\\n                \\n                if(v[j]>0)q.push(v[j]);\\n                if(q.size()>k)q.pop();\\n            }\\n            q.push(v[i]);\\n            while(q.size())s+=q.top(),q.pop();\\n            ans=max(s,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    vector<int>adj[100001];\\n    #define ppi int\\n\\n#define mhp priority_queue<ppi,vector<ppi>,greater<ppi>>\\n\\npublic:\\n    int maxStarSum(vector<int>& v, vector<vector<int>>& e, int k) {\\n        for(auto i:e)adj[i[0]].push_back(i[1]),adj[i[1]].push_back(i[0]);\\n        \\n        long int n=v.size(),ans=-1e9;\\n        \\n        for(int i=0;i<n;i++){\\n            mhp q;\\n            long s=0,c=0;\\n           \\n            for(auto j:adj[i]){\\n                \\n                if(v[j]>0)q.push(v[j]);\\n                if(q.size()>k)q.pop();\\n            }\\n            q.push(v[i]);\\n            while(q.size())s+=q.top(),q.pop();\\n            ans=max(s,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556300,
                "title": "no-dfs-bfs-select-k-values",
                "content": "# Intuition\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\nBuild Graph with Adj nodes values - O(m) -- m is the # of edges\\nSort the neigh nodes values - O (m log m) // m can be n(n-1);\\npick K most values and sum O(k) * n -- k can be max n(n-1)\\n\\nAsymptotic compalexity 0(mlog m) where m can be atmost n*(n-1)\\n\\n- Space complexity:\\n0(n * m)\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        int n = vals.length;\\n        List<Integer>[] adjList = new ArrayList[n];\\n        buildGraph(vals, edges, adjList);\\n\\n        int maxStarSum = Integer.MIN_VALUE;\\n\\n        for (int i = 0; i < vals.length; i++){\\n            int csum = vals[i];\\n            for (int j = 0; j < adjList[i].size() && j < k ; j++){\\n                if (adjList[i].get(j) <= 0){\\n                    continue;\\n                }\\n                csum += adjList[i].get(j);\\n            }\\n            maxStarSum = Math.max(maxStarSum, csum);\\n        }\\n        return maxStarSum;\\n    }\\n\\n    private void buildGraph(int[] vals, int[][] edges, List<Integer>[] adjList){\\n        int n = vals.length;\\n\\n        for (int i = 0; i < n; i++){\\n            adjList[i] = new ArrayList<>();\\n        }\\n\\n        for (int[] edge : edges){\\n            int u = edge[0], v = edge[1];\\n            adjList[u].add(vals[v]);\\n            adjList[v].add(vals[u]);\\n        }\\n\\n        for (int i = 0; i < n; i++){\\n            Collections.sort (adjList[i], (a, b) -> b - a);\\n        }\\n    }\\n}\\n/*\\nn nodes from o .. n-1\\n\\nvals[i] is teh value of ith node\\n\\nedges list the edge connecting u and v\\n\\nstar graph is subset of edges , such that there is a common node among teh edges.\\n\\nstar sum -- sum of all values in the star graph\\n\\ngiven K, max start sum of a start graph containing at most k edges\\n\\nApproach:\\n\\ncreate an adjList\\n\\nsort the edge list in descending order\\n\\ngo through the adjacent list and pick the <= k values and sum them up.\\n\\nupdate the max star sum if curr sum is bigger than max start sum.\\n\\nBuild the graph with adjacent node valu in the adj list.\\n\\nsort them and pick top K positive elements.\\n\\n\\n*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        int n = vals.length;\\n        List<Integer>[] adjList = new ArrayList[n];\\n        buildGraph(vals, edges, adjList);\\n\\n        int maxStarSum = Integer.MIN_VALUE;\\n\\n        for (int i = 0; i < vals.length; i++){\\n            int csum = vals[i];\\n            for (int j = 0; j < adjList[i].size() && j < k ; j++){\\n                if (adjList[i].get(j) <= 0){\\n                    continue;\\n                }\\n                csum += adjList[i].get(j);\\n            }\\n            maxStarSum = Math.max(maxStarSum, csum);\\n        }\\n        return maxStarSum;\\n    }\\n\\n    private void buildGraph(int[] vals, int[][] edges, List<Integer>[] adjList){\\n        int n = vals.length;\\n\\n        for (int i = 0; i < n; i++){\\n            adjList[i] = new ArrayList<>();\\n        }\\n\\n        for (int[] edge : edges){\\n            int u = edge[0], v = edge[1];\\n            adjList[u].add(vals[v]);\\n            adjList[v].add(vals[u]);\\n        }\\n\\n        for (int i = 0; i < n; i++){\\n            Collections.sort (adjList[i], (a, b) -> b - a);\\n        }\\n    }\\n}\\n/*\\nn nodes from o .. n-1\\n\\nvals[i] is teh value of ith node\\n\\nedges list the edge connecting u and v\\n\\nstar graph is subset of edges , such that there is a common node among teh edges.\\n\\nstar sum -- sum of all values in the star graph\\n\\ngiven K, max start sum of a start graph containing at most k edges\\n\\nApproach:\\n\\ncreate an adjList\\n\\nsort the edge list in descending order\\n\\ngo through the adjacent list and pick the <= k values and sum them up.\\n\\nupdate the max star sum if curr sum is bigger than max start sum.\\n\\nBuild the graph with adjacent node valu in the adj list.\\n\\nsort them and pick top K positive elements.\\n\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550016,
                "title": "c-adj-list-sorting-solution-faster-than-97-8",
                "content": "- If you consider this graphic is a dense graph, the runtime for this algorthim is O(N^2)\\n```\\nclass Solution {\\npublic:\\n    // O(N^2)\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int result = INT_MIN;\\n        std::vector<std::vector<int>>adj_list(vals.size());\\n        // O(N)\\n        for(size_t i=0;i<edges.size();i++){\\n            int& first = edges[i][0];\\n            int& second = edges[i][1];\\n            if(vals[second] > 0)\\n                adj_list[first].push_back(vals[second]);\\n            if(vals[first] > 0)\\n                adj_list[second].push_back(vals[first]);\\n        }\\n        // O(N) * O(logN + N) => O(N^2)\\n        for(size_t i=0;i<vals.size();i++){\\n            // O(logE), where E in range min(n * (n - 1) / 2, n) => O(logN)\\n            std::sort(adj_list[i].begin(),adj_list[i].end(),std::greater<int>());\\n            int tmp = vals[i];\\n            // O(E), where E in range min(n * (n - 1) / 2, n)  => O(N)\\n            for(size_t j=0;j<adj_list[i].size() && j<k;j++){\\n                tmp += adj_list[i][j];\\n            }\\n            result = std::max(result,tmp);\\n        }       \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // O(N^2)\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int result = INT_MIN;\\n        std::vector<std::vector<int>>adj_list(vals.size());\\n        // O(N)\\n        for(size_t i=0;i<edges.size();i++){\\n            int& first = edges[i][0];\\n            int& second = edges[i][1];\\n            if(vals[second] > 0)\\n                adj_list[first].push_back(vals[second]);\\n            if(vals[first] > 0)\\n                adj_list[second].push_back(vals[first]);\\n        }\\n        // O(N) * O(logN + N) => O(N^2)\\n        for(size_t i=0;i<vals.size();i++){\\n            // O(logE), where E in range min(n * (n - 1) / 2, n) => O(logN)\\n            std::sort(adj_list[i].begin(),adj_list[i].end(),std::greater<int>());\\n            int tmp = vals[i];\\n            // O(E), where E in range min(n * (n - 1) / 2, n)  => O(N)\\n            for(size_t j=0;j<adj_list[i].size() && j<k;j++){\\n                tmp += adj_list[i][j];\\n            }\\n            result = std::max(result,tmp);\\n        }       \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544403,
                "title": "c-solution-using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        unordered_map<int,priority_queue<int>> mp;\\n        for(auto x:edges){\\n            mp[x[0]].push(vals[x[1]]);\\n            mp[x[1]].push(vals[x[0]]);\\n        }\\n        int ans = INT_MIN;\\n        int n = vals.size();\\n        for(int i=0;i<n;i++){ \\n            auto q = mp[i];\\n            int sum = 0;\\n            int c = k;\\n            while(q.size()>0 && c>0){\\n                int it = q.top();\\n                q.pop();\\n                if(sum+it<=sum){\\n                    break;\\n                }\\n                sum += it;\\n                c--;\\n            }\\n            sum += vals[i];\\n            ans = max(sum,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        unordered_map<int,priority_queue<int>> mp;\\n        for(auto x:edges){\\n            mp[x[0]].push(vals[x[1]]);\\n            mp[x[1]].push(vals[x[0]]);\\n        }\\n        int ans = INT_MIN;\\n        int n = vals.size();\\n        for(int i=0;i<n;i++){ \\n            auto q = mp[i];\\n            int sum = 0;\\n            int c = k;\\n            while(q.size()>0 && c>0){\\n                int it = q.top();\\n                q.pop();\\n                if(sum+it<=sum){\\n                    break;\\n                }\\n                sum += it;\\n                c--;\\n            }\\n            sum += vals[i];\\n            ans = max(sum,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539612,
                "title": "rust-python-explanation-sort-positive-nodes-in-adjacency-list",
                "content": "# Intuition\\n\\nThe task is equivalent to iteratating over all nodes and finding the sum of at most k top nodes from it. As we are looking for the biggest sum, there is no need to look at adjacent negative nodes.\\n\\nSo at first create adjacency nodes list `g` where you add only positive numbers. Once you have adjacency list, iterate over all nodes and sort those list and get the sum of top k.\\n\\n# Complexity\\n- Time complexity: $O(E + V)$\\n- Space complexity: $O(E + V)$\\n\\n# Code\\n\\n```Rust []\\nimpl Solution {\\n  pub fn max_star_sum(vals: Vec<i32>, edges: Vec<Vec<i32>>, k: i32) -> i32 {\\n    if k == 0 {\\n      return *vals.iter().max().unwrap();\\n    }\\n\\n    let mut g = vec![vec![]; vals.len()];\\n    for e in edges {\\n      let (n0, n1) = (e[0] as usize, e[1] as usize);\\n      let (v0, v1) = (vals[n0], vals[n1]);\\n      if v1 > 0 {\\n        g[n0].push(v1);\\n      }\\n      if v0 > 0 {\\n        g[n1].push(v0);\\n      }\\n    }\\n\\n    let mut res = i32::MIN;\\n    for i in 0 .. vals.len() {\\n      g[i].sort_unstable();\\n      let tmp: i32 = g[i].iter().rev().take(k as usize).sum();\\n      res = res.max(vals[i] + tmp);\\n    }\\n\\n    return res;\\n  }\\n}\\n```\\n```python []\\nclass Solution:\\n  def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n    if k == 0:\\n      return max(vals)\\n\\n    g = [[] for _ in range(len(vals))]\\n    for v1, v2 in edges:\\n      if vals[v2] > 0:\\n        g[v1].append(vals[v2])\\n      if vals[v1] > 0:\\n        g[v2].append(vals[v1])\\n\\n    res = -float(\\'inf\\')\\n    for i in range(len(vals)):\\n      res = max(res, vals[i] + sum(sorted(g[i])[-k:]))\\n\\n    return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```Rust []\\nimpl Solution {\\n  pub fn max_star_sum(vals: Vec<i32>, edges: Vec<Vec<i32>>, k: i32) -> i32 {\\n    if k == 0 {\\n      return *vals.iter().max().unwrap();\\n    }\\n\\n    let mut g = vec![vec![]; vals.len()];\\n    for e in edges {\\n      let (n0, n1) = (e[0] as usize, e[1] as usize);\\n      let (v0, v1) = (vals[n0], vals[n1]);\\n      if v1 > 0 {\\n        g[n0].push(v1);\\n      }\\n      if v0 > 0 {\\n        g[n1].push(v0);\\n      }\\n    }\\n\\n    let mut res = i32::MIN;\\n    for i in 0 .. vals.len() {\\n      g[i].sort_unstable();\\n      let tmp: i32 = g[i].iter().rev().take(k as usize).sum();\\n      res = res.max(vals[i] + tmp);\\n    }\\n\\n    return res;\\n  }\\n}\\n```\n```python []\\nclass Solution:\\n  def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n    if k == 0:\\n      return max(vals)\\n\\n    g = [[] for _ in range(len(vals))]\\n    for v1, v2 in edges:\\n      if vals[v2] > 0:\\n        g[v1].append(vals[v2])\\n      if vals[v1] > 0:\\n        g[v2].append(vals[v1])\\n\\n    res = -float(\\'inf\\')\\n    for i in range(len(vals)):\\n      res = max(res, vals[i] + sum(sorted(g[i])[-k:]))\\n\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536544,
                "title": "c-graphs-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n*logn)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        if(k==0){\\n            return *max_element(vals.begin(), vals.end());\\n        }\\n        map<int, vector<pair<int, int>>>m;\\n        for(auto it: edges){\\n            m[it[0]].push_back({vals[it[1]], it[1]});\\n            m[it[1]].push_back({vals[it[0]], it[0]});\\n        }\\n        int ans=-1e9;\\n        for(int i=0; i<n; i++){\\n            sort(m[i].begin(), m[i].end());\\n            reverse(m[i].begin(), m[i].end());\\n            int cnt=vals[i], k1=k;\\n            ans=max(ans, cnt);\\n            for(auto it: m[i]){\\n                cnt+=it.first;\\n                k1--;\\n                ans=max(ans, cnt);\\n                if(it.first<0 || k1==0){\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        if(k==0){\\n            return *max_element(vals.begin(), vals.end());\\n        }\\n        map<int, vector<pair<int, int>>>m;\\n        for(auto it: edges){\\n            m[it[0]].push_back({vals[it[1]], it[1]});\\n            m[it[1]].push_back({vals[it[0]], it[0]});\\n        }\\n        int ans=-1e9;\\n        for(int i=0; i<n; i++){\\n            sort(m[i].begin(), m[i].end());\\n            reverse(m[i].begin(), m[i].end());\\n            int cnt=vals[i], k1=k;\\n            ans=max(ans, cnt);\\n            for(auto it: m[i]){\\n                cnt+=it.first;\\n                k1--;\\n                ans=max(ans, cnt);\\n                if(it.first<0 || k1==0){\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524179,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size(); \\n        vector<vector<pair<int, int>>> adj(n); \\n        \\n        for(int i = 0; i<edges.size(); ++i){\\n            adj[edges[i][0]].push_back({vals[edges[i][1]], edges[i][1] });\\n            adj[edges[i][1]].push_back({vals[edges[i][0]],edges[i][0]});   \\n        }\\n        int ans = INT_MIN;\\n        for(int i = 0; i<n; ++i){\\n            \\n                sort(adj[i].begin(), adj[i].end()); \\n                reverse(adj[i].begin(), adj[i].end());\\n                int temp =vals[i];\\n                int ran;\\n                if(adj[i].size() >=k){\\n                    ran = k;\\n                }\\n                else{\\n                    ran = adj[i].size();\\n                }\\n                for(int j = 0; j<ran; ++j){\\n                    if(adj[i][j].first > 0){\\n                    temp += (adj[i][j].first);}\\n                }\\n                ans = max(ans, temp);\\n            \\n        }\\n        if(ans == INT_MIN){\\n            return 0;\\n        }\\n        return ans;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size(); \\n        vector<vector<pair<int, int>>> adj(n); \\n        \\n        for(int i = 0; i<edges.size(); ++i){\\n            adj[edges[i][0]].push_back({vals[edges[i][1]], edges[i][1] });\\n            adj[edges[i][1]].push_back({vals[edges[i][0]],edges[i][0]});   \\n        }\\n        int ans = INT_MIN;\\n        for(int i = 0; i<n; ++i){\\n            \\n                sort(adj[i].begin(), adj[i].end()); \\n                reverse(adj[i].begin(), adj[i].end());\\n                int temp =vals[i];\\n                int ran;\\n                if(adj[i].size() >=k){\\n                    ran = k;\\n                }\\n                else{\\n                    ran = adj[i].size();\\n                }\\n                for(int j = 0; j<ran; ++j){\\n                    if(adj[i][j].first > 0){\\n                    temp += (adj[i][j].first);}\\n                }\\n                ans = max(ans, temp);\\n            \\n        }\\n        if(ans == INT_MIN){\\n            return 0;\\n        }\\n        return ans;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523540,
                "title": "max-heap-simplest-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) \\n    {\\n        int res =INT_MIN;\\n        if(edges.size()==0)\\n        return *max_element(vals.begin(),vals.end());\\n\\n        unordered_map<int,priority_queue<int>> m ;\\n        for(auto x:edges)\\n        {\\n            m[x[0]].push(vals[x[1]]);\\n            m[x[1]].push(vals[x[0]]);\\n        }\\n       \\n\\n        for(auto x:m)\\n       {\\n           int curr = vals[x.first];\\n          \\n           for(int i = 0 ; i<k && x.second.size();i++)\\n           {  \\n               if(x.second.top()<0)\\n               break;\\n               curr += x.second.top();\\n               x.second.pop();\\n           }\\n           res = max(res,curr);\\n       }\\n\\n        return max(res,*max_element(vals.begin(),vals.end()));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) \\n    {\\n        int res =INT_MIN;\\n        if(edges.size()==0)\\n        return *max_element(vals.begin(),vals.end());\\n\\n        unordered_map<int,priority_queue<int>> m ;\\n        for(auto x:edges)\\n        {\\n            m[x[0]].push(vals[x[1]]);\\n            m[x[1]].push(vals[x[0]]);\\n        }\\n       \\n\\n        for(auto x:m)\\n       {\\n           int curr = vals[x.first];\\n          \\n           for(int i = 0 ; i<k && x.second.size();i++)\\n           {  \\n               if(x.second.top()<0)\\n               break;\\n               curr += x.second.top();\\n               x.second.pop();\\n           }\\n           res = max(res,curr);\\n       }\\n\\n        return max(res,*max_element(vals.begin(),vals.end()));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514530,
                "title": "easy-c-solution-graph-sorting",
                "content": "# Intuition\\nSort the adjacency matrix values (neighbour values) on basis of values.Now sum  neighbour values upto k counts for each node and keep track of maximum sum.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n\\n      vector<int>adj[n];\\n       for(auto it:edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n\\n        }\\n            for (auto &it : adj) {\\n        sort(it.begin(), it.end(), [&](int a, int b) { return vals[a] > vals[b]; });\\n    }\\n\\n        int maxi=INT_MIN;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int sum=0;\\n            int count=0;\\n\\nsum+=vals[i];\\n            for(auto it:adj[i])\\n            {\\n             if(   sum+vals[it]>sum && count<k)\\n             {\\n                 sum+=vals[it];\\n                   count++;\\n             }\\n\\n                // cout<<vals[it];\\n              \\n               \\n\\n               \\n            }\\n            // cout<<\" \"<<sum<<endl;\\n            maxi=max(sum,maxi);\\n\\n        }\\n        return maxi;\\n\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n\\n      vector<int>adj[n];\\n       for(auto it:edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n\\n        }\\n            for (auto &it : adj) {\\n        sort(it.begin(), it.end(), [&](int a, int b) { return vals[a] > vals[b]; });\\n    }\\n\\n        int maxi=INT_MIN;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int sum=0;\\n            int count=0;\\n\\nsum+=vals[i];\\n            for(auto it:adj[i])\\n            {\\n             if(   sum+vals[it]>sum && count<k)\\n             {\\n                 sum+=vals[it];\\n                   count++;\\n             }\\n\\n                // cout<<vals[it];\\n              \\n               \\n\\n               \\n            }\\n            // cout<<\" \"<<sum<<endl;\\n            maxi=max(sum,maxi);\\n\\n        }\\n        return maxi;\\n\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3507036,
                "title": "no-bfs-or-dfs-simple-for-loop-for-all-nodes-with-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nproblem is bit confusing but intuition is very simple.\\njust check the connected nodes sum for each node. \\nNO NEED OF DFS OR BFS. just a for loop and a priority queue.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) construct a graph for each node with its connected edges\\n2) at the same time maintain a pq for each node with all its nodes(just make sure you add only positive values)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO[N*k] -> for each node we go through all its connected edges upto k\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO[N*k] -> we store each node and its conncted values in a PQ\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        int n = vals.length;\\n        List<Integer>[] graph = new List[n];\\n        PriorityQueue<Integer>[] pq = new PriorityQueue[n];\\n        for(int i = 0 ; i < n ; i++){\\n            graph[i] = new ArrayList<>();\\n            pq[i] = new PriorityQueue((Comparator.reverseOrder()));\\n        }\\n        \\n        for(int[] edge : edges){\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n            if(vals[edge[1]] > 0)\\n            //add into pq while creating a graph\\n            pq[edge[0]].add(vals[edge[1]]);\\n            if(vals[edge[0]] > 0)\\n            pq[edge[1]].add(vals[edge[0]]);\\n        }\\n        int ans =Integer.MIN_VALUE;\\n        \\n        //main logic goes here\\n        for(int i = 0 ; i < n ; i++){\\n            int sum = vals[i];\\n            int count = 0;\\n            int size = pq[i].size();\\n            while (!pq[i].isEmpty() && count++ < k) {\\n                sum += pq[i].poll();\\n            }\\n            ans = Math.max(ans, sum);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        int n = vals.length;\\n        List<Integer>[] graph = new List[n];\\n        PriorityQueue<Integer>[] pq = new PriorityQueue[n];\\n        for(int i = 0 ; i < n ; i++){\\n            graph[i] = new ArrayList<>();\\n            pq[i] = new PriorityQueue((Comparator.reverseOrder()));\\n        }\\n        \\n        for(int[] edge : edges){\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n            if(vals[edge[1]] > 0)\\n            //add into pq while creating a graph\\n            pq[edge[0]].add(vals[edge[1]]);\\n            if(vals[edge[0]] > 0)\\n            pq[edge[1]].add(vals[edge[0]]);\\n        }\\n        int ans =Integer.MIN_VALUE;\\n        \\n        //main logic goes here\\n        for(int i = 0 ; i < n ; i++){\\n            int sum = vals[i];\\n            int count = 0;\\n            int size = pq[i].size();\\n            while (!pq[i].isEmpty() && count++ < k) {\\n                sum += pq[i].poll();\\n            }\\n            ans = Math.max(ans, sum);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489632,
                "title": "very-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        unordered_map<int,priority_queue<int>>m;\\n        for(int i=0;i<edges.size();i++){\\n           m[edges[i][0]].push(vals[edges[i][1]]);\\n          m[edges[i][1]].push(vals[edges[i][0]]);\\n        }\\n        int maxa=INT_MIN;\\n        for(auto l:m){\\n            int count=vals[l.first];\\n            auto pq=l.second;\\n            int cnt=0;\\n            \\n            while(!pq.empty()){\\n               if(pq.top()>=0 && cnt<k){\\n                 count+=pq.top();\\n                 pq.pop();\\n                 cnt++;\\n               }\\n               else\\n               break;\\n            }\\n            maxa=max(maxa,count);\\n        }\\n        int  c= *max_element(vals.begin(),vals.end());\\n      \\n        return max(maxa,c);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        unordered_map<int,priority_queue<int>>m;\\n        for(int i=0;i<edges.size();i++){\\n           m[edges[i][0]].push(vals[edges[i][1]]);\\n          m[edges[i][1]].push(vals[edges[i][0]]);\\n        }\\n        int maxa=INT_MIN;\\n        for(auto l:m){\\n            int count=vals[l.first];\\n            auto pq=l.second;\\n            int cnt=0;\\n            \\n            while(!pq.empty()){\\n               if(pq.top()>=0 && cnt<k){\\n                 count+=pq.top();\\n                 pq.pop();\\n                 cnt++;\\n               }\\n               else\\n               break;\\n            }\\n            maxa=max(maxa,count);\\n        }\\n        int  c= *max_element(vals.begin(),vals.end());\\n      \\n        return max(maxa,c);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457383,
                "title": "c-add-only-positive-nodes-to-adjacent-list-and-sum-via-nth-element",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        vector<vector<int>> adj(n);\\n        for(auto const& e : edges) {\\n            if(vals[e[1]] > 0) adj[e[0]].push_back(e[1]);\\n            if(vals[e[0]] > 0) adj[e[1]].push_back(e[0]);\\n        }\\n        int maxsum = INT_MIN;\\n        for(int node = 0; node < adj.size(); ++node) {\\n            auto& edges = adj[node];\\n            auto itr = edges.begin() + min(k, int(edges.size()));\\n            nth_element(edges.begin(), itr, edges.end(), [&vals](int v1, int v2) { return vals[v1] > vals[v2]; });\\n            int sum =  accumulate(edges.begin(), itr, vals[node], [&vals](int sum, int v) { return sum + vals[v]; });\\n            maxsum = max(maxsum, sum);\\n        }\\n        return maxsum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        vector<vector<int>> adj(n);\\n        for(auto const& e : edges) {\\n            if(vals[e[1]] > 0) adj[e[0]].push_back(e[1]);\\n            if(vals[e[0]] > 0) adj[e[1]].push_back(e[0]);\\n        }\\n        int maxsum = INT_MIN;\\n        for(int node = 0; node < adj.size(); ++node) {\\n            auto& edges = adj[node];\\n            auto itr = edges.begin() + min(k, int(edges.size()));\\n            nth_element(edges.begin(), itr, edges.end(), [&vals](int v1, int v2) { return vals[v1] > vals[v2]; });\\n            int sum =  accumulate(edges.begin(), itr, vals[node], [&vals](int sum, int v) { return sum + vals[v]; });\\n            maxsum = max(maxsum, sum);\\n        }\\n        return maxsum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456157,
                "title": "using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        vector<vector<int>>adj(n);\\n\\n        for(auto it : edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        int ans = INT_MIN;\\n        int temp = 0;\\n        for(int i = 0; i<n; i++){\\n         temp += vals[i];\\n         priority_queue<int>pq;\\n\\n         for(auto it : adj[i]){\\n             pq.push(vals[it]);\\n         }\\n        int s = k;\\n        int sum = 0;\\n        while(s && !pq.empty()){\\n                \\n                int z = pq.top();\\n\\n                temp = max(temp, temp+z);\\n                pq.pop();\\n                s--;\\n            \\n            \\n        }\\n\\n        ans = max(ans, temp);\\n        temp = 0;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        vector<vector<int>>adj(n);\\n\\n        for(auto it : edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        int ans = INT_MIN;\\n        int temp = 0;\\n        for(int i = 0; i<n; i++){\\n         temp += vals[i];\\n         priority_queue<int>pq;\\n\\n         for(auto it : adj[i]){\\n             pq.push(vals[it]);\\n         }\\n        int s = k;\\n        int sum = 0;\\n        while(s && !pq.empty()){\\n                \\n                int z = pq.top();\\n\\n                temp = max(temp, temp+z);\\n                pq.pop();\\n                s--;\\n            \\n            \\n        }\\n\\n        ans = max(ans, temp);\\n        temp = 0;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414896,
                "title": "java-simple-priorityqueue",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        List<Integer>[] graph = new List[vals.length];\\n        for (int i = 0; i < graph.length; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n\\n        int max = Integer.MIN_VALUE;\\n        \\n        for (int i = 0; i < vals.length; i++) {\\n            PriorityQueue<Integer> pq = new PriorityQueue<>();\\n            for (int e : graph[i]) {\\n                if (vals[e] <= 0) {\\n                    continue;\\n                }\\n                pq.add(vals[e]);\\n                if (pq.size() > k) {\\n                    pq.poll();\\n                }\\n            }\\n            int sum = vals[i];\\n            while ( ! pq.isEmpty()) {\\n                sum += pq.poll();\\n            }\\n            max = Math.max(max, sum);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        List<Integer>[] graph = new List[vals.length];\\n        for (int i = 0; i < graph.length; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n\\n        int max = Integer.MIN_VALUE;\\n        \\n        for (int i = 0; i < vals.length; i++) {\\n            PriorityQueue<Integer> pq = new PriorityQueue<>();\\n            for (int e : graph[i]) {\\n                if (vals[e] <= 0) {\\n                    continue;\\n                }\\n                pq.add(vals[e]);\\n                if (pq.size() > k) {\\n                    pq.poll();\\n                }\\n            }\\n            int sum = vals[i];\\n            while ( ! pq.isEmpty()) {\\n                sum += pq.poll();\\n            }\\n            max = Math.max(max, sum);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414644,
                "title": "c-sort-brute-force",
                "content": "\\n```\\nclass Solution \\n{\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) \\n    {\\n        vector<vector<int>> mp(vals.size());\\n\\n        for (auto& e : edges)\\n        {\\n            mp[e[0]].push_back(vals[e[1]]);\\n            mp[e[1]].push_back(vals[e[0]]);\\n        }\\n\\n        int ans = INT_MIN;\\n        for (int i = 0; i < mp.size(); ++i)\\n        {\\n            sort(mp[i].rbegin(), mp[i].rend());\\n\\n            int sum = vals[i];\\n            for (int j = 0, cnt = k; j < mp[i].size() && mp[i][j] > 0 && cnt > 0; ++j, --cnt)\\n            {\\n                sum += mp[i][j];\\n            }\\n\\n            ans = max(ans, sum);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) \\n    {\\n        vector<vector<int>> mp(vals.size());\\n\\n        for (auto& e : edges)\\n        {\\n            mp[e[0]].push_back(vals[e[1]]);\\n            mp[e[1]].push_back(vals[e[0]]);\\n        }\\n\\n        int ans = INT_MIN;\\n        for (int i = 0; i < mp.size(); ++i)\\n        {\\n            sort(mp[i].rbegin(), mp[i].rend());\\n\\n            int sum = vals[i];\\n            for (int j = 0, cnt = k; j < mp[i].size() && mp[i][j] > 0 && cnt > 0; ++j, --cnt)\\n            {\\n                sum += mp[i][j];\\n            }\\n\\n            ans = max(ans, sum);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413152,
                "title": "accepted-sorting-no-recursion-simple-easy",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n- O(n*nlogn);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(vals.size()^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool comp(int a,int b){\\n        return a>b;\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        //base case \\n        int mc = INT_MIN;\\n        for(auto &it : vals)\\n            mc = max(mc,it);\\n        if(edges.size()==0)\\n            return mc;\\n        //general case \\n        int n = vals.size();\\n        vector<vector<int>> store(n);\\n        for(int i=0;i<edges.size();i++){\\n            store[edges[i][0]].push_back(vals[edges[i][1]]);\\n            store[edges[i][1]].push_back(vals[edges[i][0]]);\\n        }\\n        int ans = INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int res = vals[i], times = 0;\\n            sort(store[i].begin(),store[i].end(),comp);\\n            for(auto &it : store[i]){\\n                if(times==k)\\n                    break;\\n                res+=it;\\n                ans = max(ans,res);\\n                times+=1;\\n            }\\n            ans = max(ans,vals[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(int a,int b){\\n        return a>b;\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        //base case \\n        int mc = INT_MIN;\\n        for(auto &it : vals)\\n            mc = max(mc,it);\\n        if(edges.size()==0)\\n            return mc;\\n        //general case \\n        int n = vals.size();\\n        vector<vector<int>> store(n);\\n        for(int i=0;i<edges.size();i++){\\n            store[edges[i][0]].push_back(vals[edges[i][1]]);\\n            store[edges[i][1]].push_back(vals[edges[i][0]]);\\n        }\\n        int ans = INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int res = vals[i], times = 0;\\n            sort(store[i].begin(),store[i].end(),comp);\\n            for(auto &it : store[i]){\\n                if(times==k)\\n                    break;\\n                res+=it;\\n                ans = max(ans,res);\\n                times+=1;\\n            }\\n            ans = max(ans,vals[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409068,
                "title": "java-bst",
                "content": "# Intuition\\nFor each node save the neighbors values in a binary search tree \\nat the second Iteration just go over the tree and poll K biggest\\n\\n# Complexity\\n- Time complexity:\\nO(max(edges,nodes)*log(nodes))\\n\\n- Space complexity:\\nO(edges^2)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        int n=vals.length;\\n        BinaryTreeNode [] kBiggests = new BinaryTreeNode[n];\\n\\n        for (int[] edge: edges){\\n            int node1 = edge[0];\\n            int node2 = edge[1];\\n            int val1 = vals[node1];\\n            int val2 = vals[node2];\\n            if (kBiggests[node1]==null) kBiggests[node1] = new BinaryTreeNode(val2);\\n            else kBiggests[node1].insert(val2);\\n            if (kBiggests[node2]==null) kBiggests[node2] = new BinaryTreeNode(val1);\\n            else kBiggests[node2].insert(val1);\\n        }\\n        \\n        int max = Integer.MIN_VALUE;\\n        for (int i=0;i<n;i++){\\n            int bestStar = vals[i] ;\\n            if (kBiggests[i]!=null) \\n                bestStar = bestStar+kBiggests[i].sumKBiggestPositive(new IntegerObj(k));\\n            max = Math.max(bestStar,max);\\n        }\\n        return max; \\n    }\\n\\n    public class IntegerObj {\\n        public int value;\\n        IntegerObj(int val) {\\n            this.value = val;\\n        }\\n    }\\n\\n    class BinaryTreeNode{\\n        int val;\\n        BinaryTreeNode left;\\n        BinaryTreeNode right;\\n        public BinaryTreeNode(int val){\\n            this.val = val;\\n        }\\n\\n        public void insert(int val)\\n        {\\n            if (val <= this.val) {\\n                if (this.left!=null)\\n                    this.left.insert(val);\\n                else\\n                    this.left =new BinaryTreeNode(val);\\n            }\\n            else {\\n                if (this.right!=null)\\n                    this.right.insert(val);\\n                else\\n                    this.right =new BinaryTreeNode(val);\\n            }\\n        }\\n\\n        public int sumKBiggestPositive(IntegerObj k){\\n            if (k.value==0) return 0;\\n            int sum = 0;\\n            if (right!=null) \\n                sum += right.sumKBiggestPositive(k);\\n            if (k.value>0 && val>0) sum+=val;\\n            else return sum; \\n            k.value--;\\n            if (left!=null)\\n                sum += left.sumKBiggestPositive(k);\\n            return sum;\\n        }     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        int n=vals.length;\\n        BinaryTreeNode [] kBiggests = new BinaryTreeNode[n];\\n\\n        for (int[] edge: edges){\\n            int node1 = edge[0];\\n            int node2 = edge[1];\\n            int val1 = vals[node1];\\n            int val2 = vals[node2];\\n            if (kBiggests[node1]==null) kBiggests[node1] = new BinaryTreeNode(val2);\\n            else kBiggests[node1].insert(val2);\\n            if (kBiggests[node2]==null) kBiggests[node2] = new BinaryTreeNode(val1);\\n            else kBiggests[node2].insert(val1);\\n        }\\n        \\n        int max = Integer.MIN_VALUE;\\n        for (int i=0;i<n;i++){\\n            int bestStar = vals[i] ;\\n            if (kBiggests[i]!=null) \\n                bestStar = bestStar+kBiggests[i].sumKBiggestPositive(new IntegerObj(k));\\n            max = Math.max(bestStar,max);\\n        }\\n        return max; \\n    }\\n\\n    public class IntegerObj {\\n        public int value;\\n        IntegerObj(int val) {\\n            this.value = val;\\n        }\\n    }\\n\\n    class BinaryTreeNode{\\n        int val;\\n        BinaryTreeNode left;\\n        BinaryTreeNode right;\\n        public BinaryTreeNode(int val){\\n            this.val = val;\\n        }\\n\\n        public void insert(int val)\\n        {\\n            if (val <= this.val) {\\n                if (this.left!=null)\\n                    this.left.insert(val);\\n                else\\n                    this.left =new BinaryTreeNode(val);\\n            }\\n            else {\\n                if (this.right!=null)\\n                    this.right.insert(val);\\n                else\\n                    this.right =new BinaryTreeNode(val);\\n            }\\n        }\\n\\n        public int sumKBiggestPositive(IntegerObj k){\\n            if (k.value==0) return 0;\\n            int sum = 0;\\n            if (right!=null) \\n                sum += right.sumKBiggestPositive(k);\\n            if (k.value>0 && val>0) sum+=val;\\n            else return sum; \\n            k.value--;\\n            if (left!=null)\\n                sum += left.sumKBiggestPositive(k);\\n            return sum;\\n        }     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394088,
                "title": "c-simple-intuitive-priority-queue-based-solution",
                "content": "# Intuition\\nThe intution is simple, just find k max weight wise adjacent neighbours excluding negative weights because they will never contributr to the answer.\\n\\n# Approach\\nTake a priority_queue to find sum of k max weights. Just add them up and maximize the answer at each step\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int> adj[n], vis(n, 0);\\n\\n        for(auto &i: edges) {\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n\\n        int ans = -1e9;\\n        for(int i=0;i<n;++i) {\\n            priority_queue<int, vector<int>, greater<int>> pq;\\n            int ref = vals[i];\\n            for(auto &node : adj[i]) {\\n                if(vals[node]<0) continue;\\n                pq.push(vals[node]);\\n                if(pq.size()>k) pq.pop();\\n            }\\n            while(!pq.empty()) {\\n                ref+=pq.top();\\n                pq.pop();\\n            }\\n            ans=max(ans, ref);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int> adj[n], vis(n, 0);\\n\\n        for(auto &i: edges) {\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n\\n        int ans = -1e9;\\n        for(int i=0;i<n;++i) {\\n            priority_queue<int, vector<int>, greater<int>> pq;\\n            int ref = vals[i];\\n            for(auto &node : adj[i]) {\\n                if(vals[node]<0) continue;\\n                pq.push(vals[node]);\\n                if(pq.size()>k) pq.pop();\\n            }\\n            while(!pq.empty()) {\\n                ref+=pq.top();\\n                pq.pop();\\n            }\\n            ans=max(ans, ref);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393235,
                "title": "golang-simple-solution-using-sorting-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc maxStarSum(vals []int, edges [][]int, k int) int {\\n    n := len(vals)\\n\\n    res :=  vals[0]\\n    if k ==0 {\\n        for _, v := range vals {\\n            res = int( math.Max(float64(res), float64(v) ) )\\n        }\\n        return res\\n    }\\n\\n    graph := make([][]int, n)\\n    for _, edge := range edges {\\n        a, b := edge[0], edge[1]\\n        if vals[b] > 0 {\\n            graph[a]= append(graph[a], vals[b])\\n        }\\n        if vals[a] > 0 {\\n            graph[b] = append(graph[b], vals[a])\\n        }\\n    }\\n\\n    for i := 0; i < n; i++ {\\n        res = int(math.Max(float64(res), float64(topK(graph[i], vals[i], k) )))\\n    }\\n\\n    return res\\n}\\n\\nfunc topK(graph []int, res int, k int ) int {\\n    sort.Slice(graph, func(a, b int) bool {\\n        return graph[a] > graph[b]\\n    })\\n    \\n    for i := 0; i < k && i < len(graph); i++ {\\n        res += graph[i]\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxStarSum(vals []int, edges [][]int, k int) int {\\n    n := len(vals)\\n\\n    res :=  vals[0]\\n    if k ==0 {\\n        for _, v := range vals {\\n            res = int( math.Max(float64(res), float64(v) ) )\\n        }\\n        return res\\n    }\\n\\n    graph := make([][]int, n)\\n    for _, edge := range edges {\\n        a, b := edge[0], edge[1]\\n        if vals[b] > 0 {\\n            graph[a]= append(graph[a], vals[b])\\n        }\\n        if vals[a] > 0 {\\n            graph[b] = append(graph[b], vals[a])\\n        }\\n    }\\n\\n    for i := 0; i < n; i++ {\\n        res = int(math.Max(float64(res), float64(topK(graph[i], vals[i], k) )))\\n    }\\n\\n    return res\\n}\\n\\nfunc topK(graph []int, res int, k int ) int {\\n    sort.Slice(graph, func(a, b int) bool {\\n        return graph[a] > graph[b]\\n    })\\n    \\n    for i := 0; i < k && i < len(graph); i++ {\\n        res += graph[i]\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3391443,
                "title": "simple-adjacency-list-taking-nodes-with-maximum-values",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        \\n\\n        vector<vector<int>>vis;\\n\\n        vis.resize(vals.size());\\n\\n\\n        for(int x=0;x<edges.size();x++){\\n\\n            int u = edges[x][0];\\n            int v = edges[x][1];\\n\\n            vis[u].push_back(v);\\n            vis[v].push_back(u);\\n\\n        }\\n\\n        // for(int x=0;x<vis.size();x++){\\n\\n        //     for(int y=0;y<vis[x].size();y++)\\n        //         cout<<vals[vis[x][y]]<<\" \";\\n\\n        //         cout<<endl;\\n        // }\\n\\n        int sum = 0,maxi = INT_MIN;\\n\\n        for(int x=0;x<vis.size();x++){\\n            \\n            vector<int>temp;\\n            sum+=vals[x];\\n\\n            for(int y=0;y<vis[x].size();y++){\\n\\n                temp.push_back(vals[vis[x][y]]);\\n            }\\n\\n            if(temp.size()>0){\\n                sort(temp.begin(),temp.end());\\n\\n                int h = temp.size()-1;\\n                int l = temp.size()-k;\\n\\n                for(int i = h ; i >= max(l,0) ;i--){\\n                    if(temp[i]>0)\\n                    {\\n                      sum+=temp[i];\\n                      //cout<<temp[i]<<\" \";\\n                    } \\n                }\\n                //cout<<endl;\\n            }\\n\\n            if(sum>maxi)\\n                maxi = sum;\\n            \\n            sum = 0;\\n            \\n        }\\n\\n\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        \\n\\n        vector<vector<int>>vis;\\n\\n        vis.resize(vals.size());\\n\\n\\n        for(int x=0;x<edges.size();x++){\\n\\n            int u = edges[x][0];\\n            int v = edges[x][1];\\n\\n            vis[u].push_back(v);\\n            vis[v].push_back(u);\\n\\n        }\\n\\n        // for(int x=0;x<vis.size();x++){\\n\\n        //     for(int y=0;y<vis[x].size();y++)\\n        //         cout<<vals[vis[x][y]]<<\" \";\\n\\n        //         cout<<endl;\\n        // }\\n\\n        int sum = 0,maxi = INT_MIN;\\n\\n        for(int x=0;x<vis.size();x++){\\n            \\n            vector<int>temp;\\n            sum+=vals[x];\\n\\n            for(int y=0;y<vis[x].size();y++){\\n\\n                temp.push_back(vals[vis[x][y]]);\\n            }\\n\\n            if(temp.size()>0){\\n                sort(temp.begin(),temp.end());\\n\\n                int h = temp.size()-1;\\n                int l = temp.size()-k;\\n\\n                for(int i = h ; i >= max(l,0) ;i--){\\n                    if(temp[i]>0)\\n                    {\\n                      sum+=temp[i];\\n                      //cout<<temp[i]<<\" \";\\n                    } \\n                }\\n                //cout<<endl;\\n            }\\n\\n            if(sum>maxi)\\n                maxi = sum;\\n            \\n            sum = 0;\\n            \\n        }\\n\\n\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3381532,
                "title": "c-adjacency-sort",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        vector<vector<int>> adj(vals.size());\\n        for(int i = 0; i < edges.size(); i++){\\n            adj[edges[i][0]].push_back(vals[edges[i][1]]);\\n            adj[edges[i][1]].push_back(vals[edges[i][0]]);\\n        }\\n        int m = INT_MIN;\\n        for(int i = 0; i < adj.size(); i++){\\n            int s = vals[i];\\n            sort(adj[i].rbegin(), adj[i].rend());\\n            for(int j = 0; j < adj[i].size() && adj[i][j] > 0 && j < k; j++) s += adj[i][j];\\n            m = max(s, m);\\n        }\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        vector<vector<int>> adj(vals.size());\\n        for(int i = 0; i < edges.size(); i++){\\n            adj[edges[i][0]].push_back(vals[edges[i][1]]);\\n            adj[edges[i][1]].push_back(vals[edges[i][0]]);\\n        }\\n        int m = INT_MIN;\\n        for(int i = 0; i < adj.size(); i++){\\n            int s = vals[i];\\n            sort(adj[i].rbegin(), adj[i].rend());\\n            for(int j = 0; j < adj[i].size() && adj[i][j] > 0 && j < k; j++) s += adj[i][j];\\n            m = max(s, m);\\n        }\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349004,
                "title": "c-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        \\n        int n=vals.size();\\n        unordered_map<int,vector<pair<int,int>>>ourmap;\\n        for(int i=0;i<edges.size();i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            ourmap[a].push_back({vals[b],b});\\n            ourmap[b].push_back({vals[a],a});\\n        }\\n        long long maxi=-1e9;\\n        for(int i=0;i<n;i++){\\n            \\n            vector<pair<int,int>> temp=ourmap[i];\\n            sort(temp.begin(),temp.end());\\n            long long ans=vals[i];\\n            int x=k;\\n            int j=temp.size()-1;\\n            while(j>=0 && x!=0){\\n                if(temp[j].first<0){\\n                    break;\\n                }\\n                ans=ans+temp[j].first;\\n                j--;\\n                x--;\\n            }\\n            maxi=max(maxi,ans);\\n        }\\n        return (maxi<=-1e9)? 0:maxi;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        \\n        int n=vals.size();\\n        unordered_map<int,vector<pair<int,int>>>ourmap;\\n        for(int i=0;i<edges.size();i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            ourmap[a].push_back({vals[b],b}",
                "codeTag": "Java"
            },
            {
                "id": 3315922,
                "title": "c-solution-using-max-heap",
                "content": "class Solution {\\npublic:\\n\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n= vals.size();\\n        \\n        vector<vector<int>> adj(n);\\n        \\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int u= edges[i][0];\\n            int v= edges[i][1];\\n            \\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        int ans= INT_MIN;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            priority_queue<int> pq;\\n            \\n            for(auto v: adj[i])\\n                pq.push(vals[v]);\\n            \\n            int subans= vals[i];\\n            \\n            int c=k;\\n            \\n            while(c-- && !pq.empty())\\n            {\\n                auto e= pq.top();\\n                pq.pop();\\n                \\n                if(e+subans >subans)\\n                    subans= e+subans;\\n                \\n            }\\n            ans= max(ans,subans);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n= vals.size();\\n        \\n        vector<vector<int>> adj(n);\\n        \\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int u= edges[i][0];\\n            int v= edges[i][1];\\n            \\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3300682,
                "title": "javascript-logic",
                "content": "# Code\\n```\\n// O(n log n * k)\\nvar maxStarSum = function(vals, edges, k) {\\n    const n = vals.length;\\n    const map = {}\\n    for (let [a, b] of edges) {\\n        if (!map[a]) map[a] = [];\\n        if (!map[b]) map[b] = [];\\n        map[a].push(b);\\n        map[b].push(a);\\n    }\\n\\n    const getMax = (i) => {\\n        const values = (map[i] || [])\\n            .map(x => vals[x])\\n            .sort((a, b) => b - a);\\n        let sum = vals[i];\\n        let cnt = 0;\\n        for (const v of values) {\\n            if (v > 0 && cnt < k) {\\n                sum += v;\\n                cnt++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return sum;\\n    }\\n\\n    let max = -Infinity;\\n    for (let i = 0; i < n; i++) {\\n        max = Math.max(max, getMax(i));\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// O(n log n * k)\\nvar maxStarSum = function(vals, edges, k) {\\n    const n = vals.length;\\n    const map = {}\\n    for (let [a, b] of edges) {\\n        if (!map[a]) map[a] = [];\\n        if (!map[b]) map[b] = [];\\n        map[a].push(b);\\n        map[b].push(a);\\n    }\\n\\n    const getMax = (i) => {\\n        const values = (map[i] || [])\\n            .map(x => vals[x])\\n            .sort((a, b) => b - a);\\n        let sum = vals[i];\\n        let cnt = 0;\\n        for (const v of values) {\\n            if (v > 0 && cnt < k) {\\n                sum += v;\\n                cnt++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return sum;\\n    }\\n\\n    let max = -Infinity;\\n    for (let i = 0; i < n; i++) {\\n        max = Math.max(max, getMax(i));\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3299056,
                "title": "cpp-solution-using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        int sum = -1e9;\\n        vector<vector<int>> adj(n);\\n        for(int i=0; i<edges.size(); i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        for(int i=0; i<n; i++){\\n            int tempSum = vals[i];\\n            priority_queue<int> pq;\\n            for(int j=0; j<adj[i].size(); j++){\\n                pq.push(vals[adj[i][j]]);\\n            }\\n            int mini;\\n            if(k <= pq.size()){\\n                mini = k;\\n            }\\n            else mini = pq.size();\\n            sum = max(tempSum,sum);\\n            for(int j=0; j<mini; j++){\\n                tempSum += pq.top();\\n                sum = max(tempSum,sum);\\n                pq.pop();\\n            }\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        int sum = -1e9;\\n        vector<vector<int>> adj(n);\\n        for(int i=0; i<edges.size(); i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        for(int i=0; i<n; i++){\\n            int tempSum = vals[i];\\n            priority_queue<int> pq;\\n            for(int j=0; j<adj[i].size(); j++){\\n                pq.push(vals[adj[i][j]]);\\n            }\\n            int mini;\\n            if(k <= pq.size()){\\n                mini = k;\\n            }\\n            else mini = pq.size();\\n            sum = max(tempSum,sum);\\n            for(int j=0; j<mini; j++){\\n                tempSum += pq.top();\\n                sum = max(tempSum,sum);\\n                pq.pop();\\n            }\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3296604,
                "title": "easy-solution-with-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        tree = defaultdict(list)\\n        for a, b in edges:\\n            tree[a].append(b)\\n            tree[b].append(a)\\n        \\n        def calculate(node):\\n            res = vals[node]\\n            arr = []\\n            for neigh in tree[node]:\\n                heappush(arr, -vals[neigh])\\n            temp = vals[node]\\n            for i in range(min(k, len(arr))):\\n                tar = -heappop(arr)\\n                # print(tar)\\n                temp += tar\\n                res = max(res, temp)\\n            return res\\n        \\n        ans = -math.inf        \\n        for i in range(len(vals)):\\n            ans = max(ans, calculate(i))\\n        return ans\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        tree = defaultdict(list)\\n        for a, b in edges:\\n            tree[a].append(b)\\n            tree[b].append(a)\\n        \\n        def calculate(node):\\n            res = vals[node]\\n            arr = []\\n            for neigh in tree[node]:\\n                heappush(arr, -vals[neigh])\\n            temp = vals[node]\\n            for i in range(min(k, len(arr))):\\n                tar = -heappop(arr)\\n                # print(tar)\\n                temp += tar\\n                res = max(res, temp)\\n            return res\\n        \\n        ans = -math.inf        \\n        for i in range(len(vals)):\\n            ans = max(ans, calculate(i))\\n        return ans\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295655,
                "title": "complex-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N^2 * logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N+E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        ArrayList<ArrayList<Integer>>adj = new ArrayList<ArrayList<Integer>>();\\n        int n = vals.length ;\\n        if(n==1)\\n        return vals[0];\\n         int max = Integer.MIN_VALUE;\\n        if(edges.length==0){\\n            \\n            for(int i = 0 ;i<n ;i++){\\n            max = Math.max(max,vals[i]);\\n            }\\n            return max; \\n        }\\n        \\n        for(int i =  0 ;i<n ;i++){\\n            adj.add(new ArrayList<Integer>());\\n        }\\n        for(int i =  0;i<edges.length ;i++){\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        for(int i = 0;i<n ;i++){\\n            Collections.sort(adj.get(i),(a,b)->vals[b]-vals[a]);\\n        }\\n        \\n       \\n        for(int i =  0;i<n;i++){\\n            int sum = 0;\\n          \\n              int j=  0 ;\\n              sum = sum +vals[i];\\n               max = Math.max(max,sum);\\n            while(j<k && j<adj.get(i).size()){\\n                    sum = sum +vals[adj.get(i).get(j)];\\n                  max = Math.max(max,sum);\\n                j++;\\n                }\\n              \\n           \\n                \\n            }\\n           \\n        \\n        return max ;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        ArrayList<ArrayList<Integer>>adj = new ArrayList<ArrayList<Integer>>();\\n        int n = vals.length ;\\n        if(n==1)\\n        return vals[0];\\n         int max = Integer.MIN_VALUE;\\n        if(edges.length==0){\\n            \\n            for(int i = 0 ;i<n ;i++){\\n            max = Math.max(max,vals[i]);\\n            }\\n            return max; \\n        }\\n        \\n        for(int i =  0 ;i<n ;i++){\\n            adj.add(new ArrayList<Integer>());\\n        }\\n        for(int i =  0;i<edges.length ;i++){\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        for(int i = 0;i<n ;i++){\\n            Collections.sort(adj.get(i),(a,b)->vals[b]-vals[a]);\\n        }\\n        \\n       \\n        for(int i =  0;i<n;i++){\\n            int sum = 0;\\n          \\n              int j=  0 ;\\n              sum = sum +vals[i];\\n               max = Math.max(max,sum);\\n            while(j<k && j<adj.get(i).size()){\\n                    sum = sum +vals[adj.get(i).get(j)];\\n                  max = Math.max(max,sum);\\n                j++;\\n                }\\n              \\n           \\n                \\n            }\\n           \\n        \\n        return max ;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281998,
                "title": "python-beats-84-time-heapq-solution",
                "content": "O(Nlogk)\\n```\\nclass Solution:\\n    import heapq\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        graph =  defaultdict(list)\\n        node_sum = vals[:]\\n        res = max(vals)\\n        for edge in edges:\\n            a,b = edge\\n            for i in range(2):\\n                if i == 1:\\n                    a,b=b,a\\n                \\n                if vals[b] > 0:\\n                    if len(graph[a]) == k:\\n                        heapq.heappush(graph[a],vals[b])\\n                        node_sum[a] += vals[b]\\n                        node_sum[a] -= heapq.heappop(graph[a])\\n                    else:\\n                        heapq.heappush(graph[a],vals[b])\\n                        node_sum[a] += vals[b]\\n                res = max(res,node_sum[a])\\n        return res",
                "solutionTags": [
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "O(Nlogk)\\n```\\nclass Solution:\\n    import heapq\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        graph =  defaultdict(list)\\n        node_sum = vals[:]\\n        res = max(vals)\\n        for edge in edges:\\n            a,b = edge\\n            for i in range(2):\\n                if i == 1:\\n                    a,b=b,a\\n                \\n                if vals[b] > 0:\\n                    if len(graph[a]) == k:\\n                        heapq.heappush(graph[a],vals[b])\\n                        node_sum[a] += vals[b]\\n                        node_sum[a] -= heapq.heappop(graph[a])\\n                    else:\\n                        heapq.heappush(graph[a],vals[b])\\n                        node_sum[a] += vals[b]\\n                res = max(res,node_sum[a])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 3275645,
                "title": "90-faster-max-heap-priority-queue-c-easy-to-understand",
                "content": "```\\nclass Solution\\n{\\npublic:\\n\\tint maxStarSum(vector<int> &vals, vector<vector<int>> &edges, int k)\\n\\t{\\n\\t\\tint n = vals.size();\\n\\t\\t\\n\\t\\t// edge case if their is no edge return the maximum in vals\\n\\t\\tif (edges.size() == 0)\\n\\t\\treturn *max_element(vals.begin(), vals.end());\\n\\t\\t\\t\\n\\t\\tvector<int> adj[n];\\n\\t\\tfor (auto &it : edges)\\n\\t\\t{\\n\\t\\t\\tadj[it[0]].push_back(it[1]);\\n\\t\\t\\tadj[it[1]].push_back(it[0]);\\n\\t\\t}\\n\\t\\tint ans = INT_MIN;\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tpriority_queue<int> pq;\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\t// case-> if the value of a particular node is maximum itself\\n\\t\\t\\tsum += vals[i];\\n\\t\\t\\tans = max(ans, sum);\\n\\t\\t\\tint chk = k;\\n\\t\\t\\tfor (auto it : adj[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tpq.push(vals[it]);\\n\\t\\t\\t}\\n\\t\\t\\twhile (chk-- && !pq.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint top = pq.top();\\n\\t\\t\\t\\t// for having the maximum sum and ignoring the others sum\\n\\t\\t\\t\\tsum = max(sum, sum + top);\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t}\\n\\t\\t\\tans = max(ans, sum);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tint maxStarSum(vector<int> &vals, vector<vector<int>> &edges, int k)\\n\\t{\\n\\t\\tint n = vals.size();\\n\\t\\t\\n\\t\\t// edge case if their is no edge return the maximum in vals\\n\\t\\tif (edges.size() == 0)\\n\\t\\treturn *max_element(vals.begin(), vals.end());\\n\\t\\t\\t\\n\\t\\tvector<int> adj[n];\\n\\t\\tfor (auto &it : edges)\\n\\t\\t{\\n\\t\\t\\tadj[it[0]].push_back(it[1]);\\n\\t\\t\\tadj[it[1]].push_back(it[0]);\\n\\t\\t}\\n\\t\\tint ans = INT_MIN;\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tpriority_queue<int> pq;\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\t// case-> if the value of a particular node is maximum itself\\n\\t\\t\\tsum += vals[i];\\n\\t\\t\\tans = max(ans, sum);\\n\\t\\t\\tint chk = k;\\n\\t\\t\\tfor (auto it : adj[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tpq.push(vals[it]);\\n\\t\\t\\t}\\n\\t\\t\\twhile (chk-- && !pq.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint top = pq.top();\\n\\t\\t\\t\\t// for having the maximum sum and ignoring the others sum\\n\\t\\t\\t\\tsum = max(sum, sum + top);\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t}\\n\\t\\t\\tans = max(ans, sum);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246187,
                "title": "java-priorityqueue-solution-86-4",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn order to easily get the max sum values of the adjancent neighbours , we need to sort them somehow. The problem requires that we need to return the maximum star sum of a star graph containing at most k edges. \\nAs such we need to maintain a maxheap, containing the values. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create an adjacency Max Heap\\n- Traverse the list and only poll the size of k max from every Heap, while maintaining max sum seen so far\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0(mn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        List<PriorityQueue<Integer>> adjList = new ArrayList<>();\\n\\n        for(int i = 0; i < vals.length; i++){\\n            adjList.add(new PriorityQueue<>((a,b)-> b - a));\\n        }\\n\\n        for(int [] edg: edges){\\n            adjList.get(edg[0]).offer(vals[edg[1]]);\\n            adjList.get(edg[1]).offer(vals[edg[0]]);\\n        }\\n        \\n        int res = Integer.MIN_VALUE;\\n\\n        for(int i = 0; i < vals.length; i++){\\n            PriorityQueue<Integer> q = adjList.get(i);\\n            int s = k, sum = vals[i];\\n            res = Math.max(res, sum);\\n            while(s--> 0 && !q.isEmpty()){\\n                sum+=q.poll();\\n                res = Math.max(res, sum);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        List<PriorityQueue<Integer>> adjList = new ArrayList<>();\\n\\n        for(int i = 0; i < vals.length; i++){\\n            adjList.add(new PriorityQueue<>((a,b)-> b - a));\\n        }\\n\\n        for(int [] edg: edges){\\n            adjList.get(edg[0]).offer(vals[edg[1]]);\\n            adjList.get(edg[1]).offer(vals[edg[0]]);\\n        }\\n        \\n        int res = Integer.MIN_VALUE;\\n\\n        for(int i = 0; i < vals.length; i++){\\n            PriorityQueue<Integer> q = adjList.get(i);\\n            int s = k, sum = vals[i];\\n            res = Math.max(res, sum);\\n            while(s--> 0 && !q.isEmpty()){\\n                sum+=q.poll();\\n                res = Math.max(res, sum);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238524,
                "title": "easy-to-undersatand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& e, int k) {\\n        int n=vals.size();\\n        vector<int>adj[n];\\n        for(auto it:e){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        int ans=INT_MIN;\\n        \\n        for(int i=0;i<n;i++){\\n             priority_queue<int,vector<int>,greater<int>>pq;\\n             for(auto it:adj[i]){\\n                \\n                 pq.push(vals[it]);\\n                 if(pq.size()>k)pq.pop();\\n             }\\n             int tt=vals[i];\\n            \\n             while(!pq.empty()){\\n                 if(pq.top()>0){\\n                     tt+=pq.top();\\n\\n                 }\\n                 pq.pop();\\n             }\\n             ans=max(ans,tt);\\n\\n        }\\n        return ans;\\n        \\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& e, int k) {\\n        int n=vals.size();\\n        vector<int>adj[n];\\n        for(auto it:e){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        int ans=INT_MIN;\\n        \\n        for(int i=0;i<n;i++){\\n             priority_queue<int,vector<int>,greater<int>>pq;\\n             for(auto it:adj[i]){\\n                \\n                 pq.push(vals[it]);\\n                 if(pq.size()>k)pq.pop();\\n             }\\n             int tt=vals[i];\\n            \\n             while(!pq.empty()){\\n                 if(pq.top()>0){\\n                     tt+=pq.top();\\n\\n                 }\\n                 pq.pop();\\n             }\\n             ans=max(ans,tt);\\n\\n        }\\n        return ans;\\n        \\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231977,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        if(k==0){\\n            int maxi=INT_MIN;\\n            for(int n:vals)maxi=max(maxi,n);\\n            return maxi;\\n        }\\n        int n=vals.size();\\n        map<int,vector<pair<int,int>> > adj;\\n        for(auto p:edges){\\n            adj[p[0]].push_back({vals[p[1]], p[1]});\\n            adj[p[1]].push_back({vals[p[0]], p[0],});\\n        }\\n        int maxi=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            sort(adj[i].rbegin(),adj[i].rend());\\n            int kk=k;\\n            int sum=vals[i];\\n            maxi=max(maxi,sum);\\n            for(auto p:adj[i]){\\n                sum+=p.first;\\n                kk--;\\n                maxi=max(maxi,sum);\\n                if(kk==0 || p.first<0)break;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        if(k==0){\\n            int maxi=INT_MIN;\\n            for(int n:vals)maxi=max(maxi,n);\\n            return maxi;\\n        }\\n        int n=vals.size();\\n        map<int,vector<pair<int,int>> > adj;\\n        for(auto p:edges){\\n            adj[p[0]].push_back({vals[p[1]], p[1]});\\n            adj[p[1]].push_back({vals[p[0]], p[0],});\\n        }\\n        int maxi=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            sort(adj[i].rbegin(),adj[i].rend());\\n            int kk=k;\\n            int sum=vals[i];\\n            maxi=max(maxi,sum);\\n            for(auto p:adj[i]){\\n                sum+=p.first;\\n                kk--;\\n                maxi=max(maxi,sum);\\n                if(kk==0 || p.first<0)break;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182966,
                "title": "greedy-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to start with the unconnected nodes and selectively add neighbors to maximize the subgraph sums at each step. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a dictionary to keep track of current sums, number of nodes, and a min heap of the node values. For each edge, update these values only if the total sum can increase. If max capacity has been reached, use the min heap to see if the minimum value can be replace with a new node.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(V + Elog(V))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(E)$$\\n# Code\\n```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        mx = max(vals)\\n        aDict = {}\\n\\n        for i, val in enumerate(vals):\\n            aDict[i] = (val, 0, [])\\n\\n        for edge in edges:\\n            v0 = edge[0]\\n            dict_0 = aDict[v0]\\n            s0 = dict_0[0]\\n            k0 = dict_0[1]\\n            m0 = dict_0[2]\\n            d0 = vals[edge[0]]\\n\\n            v1 = edge[1]\\n            dict_1 = aDict[v1]\\n            s1 = dict_1[0]\\n            k1 = dict_1[1]\\n            m1 = dict_1[2]\\n            d1 = vals[edge[1]]\\n\\n            if k0 != k and d1 > 0:\\n                heappush(m0, d1)\\n                aDict[v0] = (s0 + d1, k0 + 1, m0)\\n\\n            if k1 != k and d0 > 0:\\n                heappush(m1, d0)\\n                aDict[v1] = (s1 + d0, k1 + 1, m1)\\n            \\n            if k0 == k and len(m0) > 0 and d1 > m0[0]:\\n                num = heappop(m0)\\n                heappush(m0, d1)\\n                aDict[v0] = (s0 + d1 - num, k0, m0)\\n            if k1 == k and len(m1) > 0 and d0 > m1[0]:\\n                num = heappop(m1)\\n                heappush(m1, d0)\\n                aDict[v1] = (s1 + d0 - num, k1, m1)\\n\\n            mx = max(mx, aDict[v0][0], aDict[v1][0])\\n\\n        return mx\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        mx = max(vals)\\n        aDict = {}\\n\\n        for i, val in enumerate(vals):\\n            aDict[i] = (val, 0, [])\\n\\n        for edge in edges:\\n            v0 = edge[0]\\n            dict_0 = aDict[v0]\\n            s0 = dict_0[0]\\n            k0 = dict_0[1]\\n            m0 = dict_0[2]\\n            d0 = vals[edge[0]]\\n\\n            v1 = edge[1]\\n            dict_1 = aDict[v1]\\n            s1 = dict_1[0]\\n            k1 = dict_1[1]\\n            m1 = dict_1[2]\\n            d1 = vals[edge[1]]\\n\\n            if k0 != k and d1 > 0:\\n                heappush(m0, d1)\\n                aDict[v0] = (s0 + d1, k0 + 1, m0)\\n\\n            if k1 != k and d0 > 0:\\n                heappush(m1, d0)\\n                aDict[v1] = (s1 + d0, k1 + 1, m1)\\n            \\n            if k0 == k and len(m0) > 0 and d1 > m0[0]:\\n                num = heappop(m0)\\n                heappush(m0, d1)\\n                aDict[v0] = (s0 + d1 - num, k0, m0)\\n            if k1 == k and len(m1) > 0 and d0 > m1[0]:\\n                num = heappop(m1)\\n                heappush(m1, d0)\\n                aDict[v1] = (s1 + d0 - num, k1, m1)\\n\\n            mx = max(mx, aDict[v0][0], aDict[v1][0])\\n\\n        return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176300,
                "title": "o-n-log-n-solution-self-explanatory-and-easy-using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we know that PQ max heap gives the maximum element on the top, form the elements present inside it.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing prioirty queue max-heap, and insert elements using weight.\\n\\n# Complexity\\n- Time complexity: O(Vertices +  Edges log(K) ) in worst case\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        unordered_map<int , priority_queue<pair<int,int>>> mpp;\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            mpp[edges[i][0]].push({vals[edges[i][1]] , edges[i][1]});\\n            mpp[edges[i][1]].push({vals[edges[i][0]] , edges[i][0]});\\n        }\\n\\n        int maxi = INT_MIN;\\n        for(int i=0 ; i<vals.size() ; i++)\\n        {\\n            int curr_sum = vals[i];\\n            \\n            int num_of_nodes = 0;\\n            priority_queue<pair<int , int>> &temp = mpp[i];\\n            while(!temp.empty() && num_of_nodes < k)\\n            {\\n                maxi = max(maxi , curr_sum);\\n                curr_sum = curr_sum + temp.top().first;\\n                temp.pop();\\n                num_of_nodes++;\\n            }\\n            maxi = max(maxi , curr_sum);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        unordered_map<int , priority_queue<pair<int,int>>> mpp;\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            mpp[edges[i][0]].push({vals[edges[i][1]] , edges[i][1]});\\n            mpp[edges[i][1]].push({vals[edges[i][0]] , edges[i][0]});\\n        }\\n\\n        int maxi = INT_MIN;\\n        for(int i=0 ; i<vals.size() ; i++)\\n        {\\n            int curr_sum = vals[i];\\n            \\n            int num_of_nodes = 0;\\n            priority_queue<pair<int , int>> &temp = mpp[i];\\n            while(!temp.empty() && num_of_nodes < k)\\n            {\\n                maxi = max(maxi , curr_sum);\\n                curr_sum = curr_sum + temp.top().first;\\n                temp.pop();\\n                num_of_nodes++;\\n            }\\n            maxi = max(maxi , curr_sum);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137567,
                "title": "java-priority-queue",
                "content": "```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        Map<Integer,Map<Integer,Integer>> graph = buildGraph(edges,vals);\\n        long maxSum = Long.MIN_VALUE;\\n        if(edges.length==0){\\n            Arrays.sort(vals);\\n            return vals[vals.length -1];\\n        }else{\\n            for(int node = 0 ; node< vals.length ; node++ ){\\n                //priority queue to get in desc order\\n                PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a,b)->b-a);\\n                Map<Integer,Integer> pathMap  = graph.get(node);\\n                if(pathMap != null ){\\n                    for(Integer childNode : pathMap.keySet()){\\n                        pq.offer(pathMap.get(childNode));      \\n                    }\\n                }\\n                int sum = vals[node]; \\n                maxSum = Math.max(sum,maxSum);\\n                int index = k;\\n                while( index-- > 0 && !pq.isEmpty()){\\n                    sum += pq.poll(); \\n                    maxSum = Math.max(sum,maxSum);\\n                }\\n\\n            }\\n        }\\n        \\n        \\n        return (int)maxSum;\\n    }\\n    \\n    \\n    public Map<Integer,Map<Integer,Integer>> buildGraph(int[][] edges,int[] val){\\n        \\n        Map<Integer,Map<Integer,Integer>> graph = new HashMap<>();\\n        \\n        for(int[] edge : edges){\\n            if(!graph.containsKey(edge[0])){\\n                graph.put(edge[0],new HashMap<>());\\n            }\\n            \\n            if(!graph.containsKey(edge[1])){\\n                 graph.put(edge[1],new HashMap<>());            \\n            }\\n            \\n            graph.get(edge[0]).put(edge[1],val[edge[1]]);\\n            graph.get(edge[1]).put(edge[0],val[edge[0]]);\\n        }\\n        \\n        return graph;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        Map<Integer,Map<Integer,Integer>> graph = buildGraph(edges,vals);\\n        long maxSum = Long.MIN_VALUE;\\n        if(edges.length==0){\\n            Arrays.sort(vals);\\n            return vals[vals.length -1];\\n        }else{\\n            for(int node = 0 ; node< vals.length ; node++ ){\\n                //priority queue to get in desc order\\n                PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a,b)->b-a);\\n                Map<Integer,Integer> pathMap  = graph.get(node);\\n                if(pathMap != null ){\\n                    for(Integer childNode : pathMap.keySet()){\\n                        pq.offer(pathMap.get(childNode));      \\n                    }\\n                }\\n                int sum = vals[node]; \\n                maxSum = Math.max(sum,maxSum);\\n                int index = k;\\n                while( index-- > 0 && !pq.isEmpty()){\\n                    sum += pq.poll(); \\n                    maxSum = Math.max(sum,maxSum);\\n                }\\n\\n            }\\n        }\\n        \\n        \\n        return (int)maxSum;\\n    }\\n    \\n    \\n    public Map<Integer,Map<Integer,Integer>> buildGraph(int[][] edges,int[] val){\\n        \\n        Map<Integer,Map<Integer,Integer>> graph = new HashMap<>();\\n        \\n        for(int[] edge : edges){\\n            if(!graph.containsKey(edge[0])){\\n                graph.put(edge[0],new HashMap<>());\\n            }\\n            \\n            if(!graph.containsKey(edge[1])){\\n                 graph.put(edge[1],new HashMap<>());            \\n            }\\n            \\n            graph.get(edge[0]).put(edge[1],val[edge[1]]);\\n            graph.get(edge[1]).put(edge[0],val[edge[0]]);\\n        }\\n        \\n        return graph;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135437,
                "title": "java-solution-easy-using-priority-queue",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    int max = Integer.MIN_VALUE;\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        \\n\\n               ArrayList<ArrayList<Integer>> graph = new ArrayList();\\n                   for(int i=0;i<vals.length;i++) graph.add(new ArrayList());\\n               for(int i=0;i<edges.length;i++){\\n                     graph.get(edges[i][0]).add(edges[i][1]);\\n                     graph.get(edges[i][1]).add(edges[i][0]);\\n               }\\n             //   boolean[] visited = new boolean[vals.length];\\n                 for(int i=0;i<vals.length;i++)\\n                {  dfs(graph , i  ,k,vals );}\\n                 return max;\\n    }\\n    public void dfs(  ArrayList<ArrayList<Integer>> graph , int start,  int k, int[] vals){\\n                     \\n             \\n                    \\n                     max=Math.max(max , vals[start]);\\n                     int sum=vals[start];\\n                     PriorityQueue<Integer> pq = new PriorityQueue(Collections.reverseOrder());\\n                     for(int i:graph.get(start)){\\n                         pq.add(vals[i]);\\n                     }\\n                     int i=0;\\n                     while(!pq.isEmpty() && i<k){\\n                         sum+=pq.remove();\\n                         max=Math.max(max , sum);\\n                         i++;\\n                     }\\n                     //    max=Math.max(max , sum);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int max = Integer.MIN_VALUE;\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        \\n\\n               ArrayList<ArrayList<Integer>> graph = new ArrayList();\\n                   for(int i=0;i<vals.length;i++) graph.add(new ArrayList());\\n               for(int i=0;i<edges.length;i++){\\n                     graph.get(edges[i][0]).add(edges[i][1]);\\n                     graph.get(edges[i][1]).add(edges[i][0]);\\n               }\\n             //   boolean[] visited = new boolean[vals.length];\\n                 for(int i=0;i<vals.length;i++)\\n                {  dfs(graph , i  ,k,vals );}\\n                 return max;\\n    }\\n    public void dfs(  ArrayList<ArrayList<Integer>> graph , int start,  int k, int[] vals){\\n                     \\n             \\n                    \\n                     max=Math.max(max , vals[start]);\\n                     int sum=vals[start];\\n                     PriorityQueue<Integer> pq = new PriorityQueue(Collections.reverseOrder());\\n                     for(int i:graph.get(start)){\\n                         pq.add(vals[i]);\\n                     }\\n                     int i=0;\\n                     while(!pq.isEmpty() && i<k){\\n                         sum+=pq.remove();\\n                         max=Math.max(max , sum);\\n                         i++;\\n                     }\\n                     //    max=Math.max(max , sum);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133789,
                "title": "c",
                "content": "```\\nusing PII = pair<int, int> ;\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        int ans = INT_MIN;\\n        vector<vector<PII>> graph(n);\\n\\n        for (auto& edge : edges) {\\n          int u = edge[0];\\n          int v = edge[1];\\n          graph[u].push_back({v, vals[v]});\\n          graph[v].push_back({u, vals[u]});\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n          priority_queue<int, vector<int> > maxHeap;\\n          for (auto [ _ , val] : graph[i])\\n          {\\n            if (val > 0)\\n              maxHeap.push(val);\\n          }\\n          int sum = vals[i];\\n          for (int j = 0; j < k && !maxHeap.empty(); ++j)\\n          {\\n            sum += maxHeap.top() ; \\n            maxHeap.pop() ;\\n          }\\n          ans = max(ans, sum);\\n        }\\n        return ans;       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing PII = pair<int, int> ;\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n = vals.size();\\n        int ans = INT_MIN;\\n        vector<vector<PII>> graph(n);\\n\\n        for (auto& edge : edges) {\\n          int u = edge[0];\\n          int v = edge[1];\\n          graph[u].push_back({v, vals[v]});\\n          graph[v].push_back({u, vals[u]});\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n          priority_queue<int, vector<int> > maxHeap;\\n          for (auto [ _ , val] : graph[i])\\n          {\\n            if (val > 0)\\n              maxHeap.push(val);\\n          }\\n          int sum = vals[i];\\n          for (int j = 0; j < k && !maxHeap.empty(); ++j)\\n          {\\n            sum += maxHeap.top() ; \\n            maxHeap.pop() ;\\n          }\\n          ans = max(ans, sum);\\n        }\\n        return ans;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122022,
                "title": "python-priority-queue-solution",
                "content": "```\\nfrom queue import PriorityQueue\\n\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        memo = dict()\\n        counter = dict()\\n        size = dict()\\n        res= vals[0]\\n\\n        for i in range(len(vals)):\\n            memo[i] = PriorityQueue()\\n            counter[i] = vals[i]\\n            size[i] = 0\\n            res = max(res,vals[i])\\n        \\n        if k == 0: return res\\n\\n        for x,y in edges:\\n            if vals[y] > 0:\\n                if size[x] < k:\\n                    memo[x].put(vals[y])\\n                    size[x] += 1\\n                    counter[x] += vals[y]\\n                else:\\n                    cur_smallest = memo[x].get()\\n                    counter[x] -= cur_smallest\\n                    best = max(cur_smallest,vals[y])\\n                    memo[x].put(best)\\n                    counter[x] += best\\n                res = max(res,counter[x])\\n            \\n            if vals[x] > 0:\\n                if size[y] < k:\\n                    memo[y].put(vals[x])\\n                    size[y] += 1\\n                    counter[y] += vals[x]\\n                else:\\n                    cur_smallest = memo[y].get()\\n                    counter[y] -= cur_smallest\\n                    best = max(cur_smallest,vals[x])\\n                    memo[y].put(best)\\n                    counter[y] += best\\n                res = max(res,counter[y])\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom queue import PriorityQueue\\n\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        memo = dict()\\n        counter = dict()\\n        size = dict()\\n        res= vals[0]\\n\\n        for i in range(len(vals)):\\n            memo[i] = PriorityQueue()\\n            counter[i] = vals[i]\\n            size[i] = 0\\n            res = max(res,vals[i])\\n        \\n        if k == 0: return res\\n\\n        for x,y in edges:\\n            if vals[y] > 0:\\n                if size[x] < k:\\n                    memo[x].put(vals[y])\\n                    size[x] += 1\\n                    counter[x] += vals[y]\\n                else:\\n                    cur_smallest = memo[x].get()\\n                    counter[x] -= cur_smallest\\n                    best = max(cur_smallest,vals[y])\\n                    memo[x].put(best)\\n                    counter[x] += best\\n                res = max(res,counter[x])\\n            \\n            if vals[x] > 0:\\n                if size[y] < k:\\n                    memo[y].put(vals[x])\\n                    size[y] += 1\\n                    counter[y] += vals[x]\\n                else:\\n                    cur_smallest = memo[y].get()\\n                    counter[y] -= cur_smallest\\n                    best = max(cur_smallest,vals[x])\\n                    memo[y].put(best)\\n                    counter[y] += best\\n                res = max(res,counter[y])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096449,
                "title": "easy-map-c-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        if(k==0||vals.size()==1||edges.size()==0) return *max_element(vals.begin(),vals.end());\\n        map<int,multiset<int>>m;\\n        int maxi=INT_MIN;\\n        for(auto it:edges){\\n            m[it[0]].insert(vals[it[1]]);\\n            m[it[1]].insert(vals[it[0]]);\\n        }\\n        for(auto it:m){\\n            vector<int>v;\\n            int p=k;\\n            for(auto j:it.second) v.push_back(j);\\n            int s=0;\\n            s+=vals[it.first];\\n            reverse(v.begin(),v.end());\\n            int u=0;\\n            while(p--&&u<v.size()){\\n                if(v[u]<0) break;\\n                s+=v[u];\\n                u++;\\n            }\\n            maxi=max(maxi,s);\\n            cout<<endl;\\n        }\\n        return max(maxi,*max_element(vals.begin(),vals.end()));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        if(k==0||vals.size()==1||edges.size()==0) return *max_element(vals.begin(),vals.end());\\n        map<int,multiset<int>>m;\\n        int maxi=INT_MIN;\\n        for(auto it:edges){\\n            m[it[0]].insert(vals[it[1]]);\\n            m[it[1]].insert(vals[it[0]]);\\n        }\\n        for(auto it:m){\\n            vector<int>v;\\n            int p=k;\\n            for(auto j:it.second) v.push_back(j);\\n            int s=0;\\n            s+=vals[it.first];\\n            reverse(v.begin(),v.end());\\n            int u=0;\\n            while(p--&&u<v.size()){\\n                if(v[u]<0) break;\\n                s+=v[u];\\n                u++;\\n            }\\n            maxi=max(maxi,s);\\n            cout<<endl;\\n        }\\n        return max(maxi,*max_element(vals.begin(),vals.end()));\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3095126,
                "title": "adjacency-list-map-of-minheaps",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        Map<Integer, Queue<Integer>> map = new HashMap();\\n\\n        for(int[] edge : edges) {\\n            var pq1 = map.getOrDefault(edge[0], new PriorityQueue<Integer>());\\n            if(vals[edge[1]] > 0) pq1.offer(vals[edge[1]]);\\n            if(pq1.size() > k) pq1.poll();\\n\\n            map.put(edge[0], pq1);\\n\\n            var pq2 = map.getOrDefault(edge[1], new PriorityQueue<Integer>());\\n            if(vals[edge[0]] > 0) pq2.offer(vals[edge[0]]);\\n            if(pq2.size() > k) pq2.poll();\\n\\n            map.put(edge[1], pq2);\\n        }\\n        int max = Integer.MIN_VALUE;\\n        //handles the case with no edges. Alas, struggled a lot with this.\\n        for(int x : vals) max = Math.max(x, max); \\n\\n        for(int center : map.keySet()) {\\n            int sum = vals[center];\\n            for(int x : map.get(center)) {\\n                sum += x;\\n            }\\n            max = Math.max(max, sum);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Graph",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        Map<Integer, Queue<Integer>> map = new HashMap();\\n\\n        for(int[] edge : edges) {\\n            var pq1 = map.getOrDefault(edge[0], new PriorityQueue<Integer>());\\n            if(vals[edge[1]] > 0) pq1.offer(vals[edge[1]]);\\n            if(pq1.size() > k) pq1.poll();\\n\\n            map.put(edge[0], pq1);\\n\\n            var pq2 = map.getOrDefault(edge[1], new PriorityQueue<Integer>());\\n            if(vals[edge[0]] > 0) pq2.offer(vals[edge[0]]);\\n            if(pq2.size() > k) pq2.poll();\\n\\n            map.put(edge[1], pq2);\\n        }\\n        int max = Integer.MIN_VALUE;\\n        //handles the case with no edges. Alas, struggled a lot with this.\\n        for(int x : vals) max = Math.max(x, max); \\n\\n        for(int center : map.keySet()) {\\n            int sum = vals[center];\\n            for(int x : map.get(center)) {\\n                sum += x;\\n            }\\n            max = Math.max(max, sum);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091966,
                "title": "easy-to-understand-c-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dfs(vector<vector<int>>&v,int s,int k,vector<int>&vl){\\n        int n=v[s].size();\\n        priority_queue<int>pq;\\n        for(int i=0;i<n;i++){\\n            pq.push(vl[v[s][i]]);\\n        }\\n        int a=0;\\n        for(int i=0;i<min(k,n);i++){\\n            int b=pq.top();\\n            pq.pop();\\n            if(b<0)continue;\\n            a+=b;\\n        }\\n        return a+vl[s];\\n    }\\n\\n    int maxStarSum(vector<int>&vl, vector<vector<int>>&e, int k) {\\n        int n=vl.size();\\n        vector<vector<int>>v(n);\\n        for(int i=0;i<e.size();i++){\\n            v[e[i][0]].push_back(e[i][1]);\\n            v[e[i][1]].push_back(e[i][0]);\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int a=dfs(v,i,k,vl);\\n            ans=max(ans,a);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dfs(vector<vector<int>>&v,int s,int k,vector<int>&vl){\\n        int n=v[s].size();\\n        priority_queue<int>pq;\\n        for(int i=0;i<n;i++){\\n            pq.push(vl[v[s][i]]);\\n        }\\n        int a=0;\\n        for(int i=0;i<min(k,n);i++){\\n            int b=pq.top();\\n            pq.pop();\\n            if(b<0)continue;\\n            a+=b;\\n        }\\n        return a+vl[s];\\n    }\\n\\n    int maxStarSum(vector<int>&vl, vector<vector<int>>&e, int k) {\\n        int n=vl.size();\\n        vector<vector<int>>v(n);\\n        for(int i=0;i<e.size();i++){\\n            v[e[i][0]].push_back(e[i][1]);\\n            v[e[i][1]].push_back(e[i][0]);\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int a=dfs(v,i,k,vl);\\n            ans=max(ans,a);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091415,
                "title": "scala-immutable-solution",
                "content": "# Code\\n```\\nobject Solution {\\n  def maxStarSum(vals: Array[Int], edges: Array[Array[Int]], _k: Int): Int = {\\n    lazy val g = edges.toList.flatMap{e => List((e(0) -> e(1)), e(1) -> e(0))}.groupMap(_._1)(_._2)\\n    lazy val y0 = g.map{case (k,v) => \\n      lazy val neighbours = v.map(vals(_)).sorted.dropWhile(_ <= 0).reverse.take(_k)\\n      (vals(k) +: neighbours).sum\\n    }\\n    if(edges.isEmpty) vals.max else (y0.max) max (vals.max)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def maxStarSum(vals: Array[Int], edges: Array[Array[Int]], _k: Int): Int = {\\n    lazy val g = edges.toList.flatMap{e => List((e(0) -> e(1)), e(1) -> e(0))}.groupMap(_._1)(_._2)\\n    lazy val y0 = g.map{case (k,v) => \\n      lazy val neighbours = v.map(vals(_)).sorted.dropWhile(_ <= 0).reverse.take(_k)\\n      (vals(k) +: neighbours).sum\\n    }\\n    if(edges.isEmpty) vals.max else (y0.max) max (vals.max)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3087115,
                "title": "simple-approach-java-solution-adjacency-list-sorting-and-iteration",
                "content": "# Intuition\\nAs we needed to find the minimum star sum by considering at most K edges, the most natural approach for me was starting to consider all possible center nodes and iterating through the possible star sums for each of them.\\n\\n# Approach\\n From the edges array, I constructed adjacency lists for each node that could be conveniently accessed when evaluating the star sums. After that, I iterated through all the possible center nodes and started adding their neighbors from highest to lowest(having sorted previously using a Comparator) and stopped when a negative number was found, k edges were used, or all possible neighbors of that node were used.(There was no need to add a negative number neighbor as we are allowed to keep the value of the original center node with zero neighbors).\\n\\n# Complexity\\n- Worst-case Time complexity:\\nFirst for loop: O(n)\\nSecond for loop: O(E)\\nThird for loop: O(n * log(n) * k)\\nHence overall time-complexity is O(n+n^2+nk * log(n)) = O(n^2).\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        System.out.println(vals.length);\\n        List<List<Integer>> adjacencies = new ArrayList<List<Integer>>();\\n        for(int i = 0; i < vals.length; i++){\\n            adjacencies.add(new ArrayList<Integer>());\\n        }\\n        for(int j = 0; j < edges.length; j++){ // Iterating through all the edges\\n            System.out.println(edges[j]);\\n            adjacencies.get(edges[j][0]).add(vals[edges[j][1]]);\\n            adjacencies.get(edges[j][1]).add(vals[edges[j][0]]);\\n        }\\n        int max = Integer.MIN_VALUE;\\n        for(int l = 0; l < adjacencies.size(); l++){\\n            List<Integer> result = adjacencies.get(l);\\n            result.sort(Comparator.naturalOrder());\\n            int total = vals[l];\\n            // Otherwise update max with sum of K largest values if needed\\n            for(int i = 1; i <= k; i++){\\n                if(adjacencies.get(l).size() - i < 0) break;\\n                //System.out.println(\"adjacencies.get(l).size() \" + adjacencies.get(l).size());\\n                int num = adjacencies.get(l).get(adjacencies.get(l).size() - i);\\n                if(num < 0) break;\\n                total += num;\\n            }\\n            max = (total >= max) ? total : max;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        System.out.println(vals.length);\\n        List<List<Integer>> adjacencies = new ArrayList<List<Integer>>();\\n        for(int i = 0; i < vals.length; i++){\\n            adjacencies.add(new ArrayList<Integer>());\\n        }\\n        for(int j = 0; j < edges.length; j++){ // Iterating through all the edges\\n            System.out.println(edges[j]);\\n            adjacencies.get(edges[j][0]).add(vals[edges[j][1]]);\\n            adjacencies.get(edges[j][1]).add(vals[edges[j][0]]);\\n        }\\n        int max = Integer.MIN_VALUE;\\n        for(int l = 0; l < adjacencies.size(); l++){\\n            List<Integer> result = adjacencies.get(l);\\n            result.sort(Comparator.naturalOrder());\\n            int total = vals[l];\\n            // Otherwise update max with sum of K largest values if needed\\n            for(int i = 1; i <= k; i++){\\n                if(adjacencies.get(l).size() - i < 0) break;\\n                //System.out.println(\"adjacencies.get(l).size() \" + adjacencies.get(l).size());\\n                int num = adjacencies.get(l).get(adjacencies.get(l).size() - i);\\n                if(num < 0) break;\\n                total += num;\\n            }\\n            max = (total >= max) ? total : max;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058273,
                "title": "clean-easy-solution-priority-queue",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int maxStarSum(vector<int> &val, vector<vector< int>> &edges, int k)\\n        {\\n            int n = val.size(), ans = -1e9, it = 0;\\n            vector<priority_queue < int>> g(n);\\n            for (auto &v: edges)\\n            {\\n                g[v[0]].push(val[v[1]]);\\n                g[v[1]].push(val[v[0]]);\\n            }\\n            for (auto &pq: g)\\n            {\\n                int dup = k, maxi = val[it], calc = val[it];\\n                while (dup--and pq.size())\\n                {\\n                    calc += pq.top();\\n                    pq.pop();\\n                    maxi = max(maxi, calc);\\n                }\\n                ans = max(maxi, ans);\\n                it++;\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int maxStarSum(vector<int> &val, vector<vector< int>> &edges, int k)\\n        {\\n            int n = val.size(), ans = -1e9, it = 0;\\n            vector<priority_queue < int>> g(n);\\n            for (auto &v: edges)\\n            {\\n                g[v[0]].push(val[v[1]]);\\n                g[v[1]].push(val[v[0]]);\\n            }\\n            for (auto &pq: g)\\n            {\\n                int dup = k, maxi = val[it], calc = val[it];\\n                while (dup--and pq.size())\\n                {\\n                    calc += pq.top();\\n                    pq.pop();\\n                    maxi = max(maxi, calc);\\n                }\\n                ans = max(maxi, ans);\\n                it++;\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049991,
                "title": "c-easy-just-do-it",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k)\\n    {\\n        if(k==0)\\n        {\\n            int maxi = INT_MIN;\\n            int m = *max_element(vals.begin(),vals.end());\\n            return max(maxi,m);\\n        }\\n        int n = vals.size();\\n        // vector<vector<pair<int,int>>>ad_list;\\n        map<int,vector<pair<int,int>>>ad_list;\\n        for(int i = 0;i<edges.size();i++)\\n        {\\n            ad_list[edges[i][0]].push_back({vals[edges[i][1]], edges[i][1]});\\n            ad_list[edges[i][1]].push_back({vals[edges[i][0]], edges[i][0]});\\n        }\\n        int maxi = INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(ad_list[i].rbegin(),ad_list[i].rend());\\n            int count = k;\\n            int sum = vals[i];\\n            maxi = max(maxi,sum);\\n            for(int j=0;j<ad_list[i].size();j++)\\n            {\\n                sum+=ad_list[i][j].first;\\n                count--;\\n                maxi=max(maxi,sum);\\n                if(count == 0 || ad_list[i][j].first <0) break;\\n            }\\n        }\\n        return maxi;  \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k)\\n    {\\n        if(k==0)\\n        {\\n            int maxi = INT_MIN;\\n            int m = *max_element(vals.begin(),vals.end());\\n            return max(maxi,m);\\n        }\\n        int n = vals.size();\\n        // vector<vector<pair<int,int>>>ad_list;\\n        map<int,vector<pair<int,int>>>ad_list;\\n        for(int i = 0;i<edges.size();i++)\\n        {\\n            ad_list[edges[i][0]].push_back({vals[edges[i][1]], edges[i][1]});\\n            ad_list[edges[i][1]].push_back({vals[edges[i][0]], edges[i][0]});\\n        }\\n        int maxi = INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(ad_list[i].rbegin(),ad_list[i].rend());\\n            int count = k;\\n            int sum = vals[i];\\n            maxi = max(maxi,sum);\\n            for(int j=0;j<ad_list[i].size();j++)\\n            {\\n                sum+=ad_list[i][j].first;\\n                count--;\\n                maxi=max(maxi,sum);\\n                if(count == 0 || ad_list[i][j].first <0) break;\\n            }\\n        }\\n        return maxi;  \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047371,
                "title": "python-heap-to-keep-k-largest-and-positive-neighbors-of-each-node",
                "content": "# Intuition\\nPython Heap to keep k largest and positive neighbors of each node\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*logn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        if not edges:\\n            return max(vals)\\n\\n        A = [[] for _ in range(len(vals))]\\n        for a, b in edges:\\n            A[a].append(b)\\n            A[b].append(a)\\n\\n        ans = float(\\'-inf\\')\\n        for node in range(len(A)):\\n            heap = [] # mininum heap to keep largest k neighber values\\n            for neib in A[node]:\\n                if vals[neib] > 0:\\n                    heapq.heappush(heap, vals[neib])\\n                    if len(heap) > k:\\n                        heapq.heappop(heap)\\n            cur_sum = vals[node] + sum(heap)\\n            ans = max(ans, cur_sum)\\n\\n        return ans\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        if not edges:\\n            return max(vals)\\n\\n        A = [[] for _ in range(len(vals))]\\n        for a, b in edges:\\n            A[a].append(b)\\n            A[b].append(a)\\n\\n        ans = float(\\'-inf\\')\\n        for node in range(len(A)):\\n            heap = [] # mininum heap to keep largest k neighber values\\n            for neib in A[node]:\\n                if vals[neib] > 0:\\n                    heapq.heappush(heap, vals[neib])\\n                    if len(heap) > k:\\n                        heapq.heappop(heap)\\n            cur_sum = vals[node] + sum(heap)\\n            ans = max(ans, cur_sum)\\n\\n        return ans\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045103,
                "title": "golang-simple-solution-using-sorting",
                "content": "```go\\nfunc maxStarSum(vals []int, edges [][]int, k int) int {\\n  al := make([][]int, len(vals))\\n  // We\\'re just going to take the values of the adjacent vertices\\n  for _, edge := range edges {\\n    from, to := edge[0], edge[1]\\n    al[from] = append(al[from], vals[to])\\n    al[to] = append(al[to], vals[from])\\n  }\\n  res := math.MinInt32\\n  for i := 0; i < len(vals); i++ {\\n    // We\\'ll sort the values of the adjacent nodes of each node in descending order\\n    sort.Slice(al[i], func(j, k int) bool {\\n      return al[i][j] > al[i][k]\\n    })\\n    sum := vals[i]\\n    // We\\'ll take up to k nodes as long as they help making the sum bigger. If they are negative\\n    // there is no pointing adding that vertex.\\n    for j := 0; j < len(al[i]) && j < k && al[i][j] > 0; j++ {\\n      sum += al[i][j]\\n    }\\n    res = max(res, sum)\\n  }\\n  return res\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sorting"
                ],
                "code": "```go\\nfunc maxStarSum(vals []int, edges [][]int, k int) int {\\n  al := make([][]int, len(vals))\\n  // We\\'re just going to take the values of the adjacent vertices\\n  for _, edge := range edges {\\n    from, to := edge[0], edge[1]\\n    al[from] = append(al[from], vals[to])\\n    al[to] = append(al[to], vals[from])\\n  }\\n  res := math.MinInt32\\n  for i := 0; i < len(vals); i++ {\\n    // We\\'ll sort the values of the adjacent nodes of each node in descending order\\n    sort.Slice(al[i], func(j, k int) bool {\\n      return al[i][j] > al[i][k]\\n    })\\n    sum := vals[i]\\n    // We\\'ll take up to k nodes as long as they help making the sum bigger. If they are negative\\n    // there is no pointing adding that vertex.\\n    for j := 0; j < len(al[i]) && j < k && al[i][j] > 0; j++ {\\n      sum += al[i][j]\\n    }\\n    res = max(res, sum)\\n  }\\n  return res\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3015541,
                "title": "c-sol-using-heap",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        if(edges.size()==0)return *max_element(vals.begin(),vals.end());\\n        vector<pair<int,priority_queue<int>>>mp(vals.size());\\n        for(auto i:edges){\\n            mp[i[0]].second.push(vals[i[1]]);\\n            mp[i[0]].first=vals[i[0]];\\n            mp[i[1]].second.push(vals[i[0]]);\\n            mp[i[1]].first=vals[i[1]];\\n        }\\n        int ans=INT_MIN,ind=0;\\n        for(auto i:mp){\\n            int temp=i.first;\\n            if(temp==0) temp=vals[ind];\\n            int x=k;\\n            ans=max(ans,temp);\\n            while(!i.second.empty()&&x--){\\n                auto j=i.second.top(); i.second.pop();\\n                temp+=j;\\n                ans=max(ans,temp);\\n            }\\n            ind++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        if(edges.size()==0)return *max_element(vals.begin(),vals.end());\\n        vector<pair<int,priority_queue<int>>>mp(vals.size());\\n        for(auto i:edges){\\n            mp[i[0]].second.push(vals[i[1]]);\\n            mp[i[0]].first=vals[i[0]];\\n            mp[i[1]].second.push(vals[i[0]]);\\n            mp[i[1]].first=vals[i[1]];\\n        }\\n        int ans=INT_MIN,ind=0;\\n        for(auto i:mp){\\n            int temp=i.first;\\n            if(temp==0) temp=vals[ind];\\n            int x=k;\\n            ans=max(ans,temp);\\n            while(!i.second.empty()&&x--){\\n                auto j=i.second.top(); i.second.pop();\\n                temp+=j;\\n                ans=max(ans,temp);\\n            }\\n            ind++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014082,
                "title": "java-2-solutions",
                "content": "# 2.heap\\n```\\n    //2.heap\\n    //Runtime: 75ms 84%; Memory: 85.6MB 97%\\n    //Time: O(N + E * logK + N * K * logK); Space: O(E)\\n    public int maxStarSum_2(int[] vals, int[][] edges, int k) {\\n        PriorityQueue<Integer>[] graph = new PriorityQueue[vals.length];\\n        for (int i = 0; i < graph.length; i++)\\n            graph[i] = new PriorityQueue<>(Comparator.comparingInt(a -> vals[a]));\\n\\n        for (int[] edge: edges){\\n            graph[edge[0]].add(edge[1]);\\n            if (graph[edge[0]].size() > k) graph[edge[0]].poll();\\n\\n            graph[edge[1]].add(edge[0]);\\n            if (graph[edge[1]].size() > k) graph[edge[1]].poll();\\n        }\\n\\n        int res = Integer.MIN_VALUE;\\n        for (int i = 0; i < vals.length; i++) {\\n            PriorityQueue<Integer> neighbours = graph[i];\\n\\n            int sum = vals[i];\\n            while (!neighbours.isEmpty()) {\\n                int node = neighbours.poll();\\n                sum += vals[node] > 0 ? vals[node] : 0;\\n            }\\n            res = Math.max(res, sum);\\n        }\\n        return res;\\n    }\\n\\n```\\n# 1.sort\\n```\\n    //1.sort\\n    //Runtime: 105ms 65%; Memory: 91.3MB 76%\\n    //Time: O(N + E + N * N * logN); Space: O(E + logN)\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        List<Integer>[] graph = new List[vals.length];\\n        for (int i = 0; i < graph.length; i++)\\n            graph[i] = new ArrayList<>();\\n\\n        for (int[] edge: edges){\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n\\n        int res = Integer.MIN_VALUE;\\n        for (int i = 0; i < vals.length; i++) {\\n            List<Integer> neighbours = graph[i];\\n            Collections.sort(neighbours, (a, b) -> vals[b] - vals[a]);\\n\\n            int count = 0;\\n            int sum = vals[i];\\n            while (count < Math.min(k, neighbours.size()) && vals[neighbours.get(count)] > 0) {\\n                sum += vals[neighbours.get(count)];\\n                count++;\\n            }\\n            res = Math.max(res, sum);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    //2.heap\\n    //Runtime: 75ms 84%; Memory: 85.6MB 97%\\n    //Time: O(N + E * logK + N * K * logK); Space: O(E)\\n    public int maxStarSum_2(int[] vals, int[][] edges, int k) {\\n        PriorityQueue<Integer>[] graph = new PriorityQueue[vals.length];\\n        for (int i = 0; i < graph.length; i++)\\n            graph[i] = new PriorityQueue<>(Comparator.comparingInt(a -> vals[a]));\\n\\n        for (int[] edge: edges){\\n            graph[edge[0]].add(edge[1]);\\n            if (graph[edge[0]].size() > k) graph[edge[0]].poll();\\n\\n            graph[edge[1]].add(edge[0]);\\n            if (graph[edge[1]].size() > k) graph[edge[1]].poll();\\n        }\\n\\n        int res = Integer.MIN_VALUE;\\n        for (int i = 0; i < vals.length; i++) {\\n            PriorityQueue<Integer> neighbours = graph[i];\\n\\n            int sum = vals[i];\\n            while (!neighbours.isEmpty()) {\\n                int node = neighbours.poll();\\n                sum += vals[node] > 0 ? vals[node] : 0;\\n            }\\n            res = Math.max(res, sum);\\n        }\\n        return res;\\n    }\\n\\n```\n```\\n    //1.sort\\n    //Runtime: 105ms 65%; Memory: 91.3MB 76%\\n    //Time: O(N + E + N * N * logN); Space: O(E + logN)\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        List<Integer>[] graph = new List[vals.length];\\n        for (int i = 0; i < graph.length; i++)\\n            graph[i] = new ArrayList<>();\\n\\n        for (int[] edge: edges){\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n\\n        int res = Integer.MIN_VALUE;\\n        for (int i = 0; i < vals.length; i++) {\\n            List<Integer> neighbours = graph[i];\\n            Collections.sort(neighbours, (a, b) -> vals[b] - vals[a]);\\n\\n            int count = 0;\\n            int sum = vals[i];\\n            while (count < Math.min(k, neighbours.size()) && vals[neighbours.get(count)] > 0) {\\n                sum += vals[neighbours.get(count)];\\n                count++;\\n            }\\n            res = Math.max(res, sum);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3007781,
                "title": "python-sort-and-get-k-biggest",
                "content": "```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        graph = defaultdict(list)\\n        n = len(vals)\\n        for i in range(n):\\n            graph[i]\\n        \\n        for a, b in edges:\\n            graph[a].append( b )\\n            graph[b].append( a )\\n            \\n        for node, neighbours in graph.items():\\n            neighbours.sort(key = lambda node: -vals[node])\\n        \\n        answer = vals[0]\\n        for node, neighbours in graph.items():\\n            #\\xA0Have k biggest nodes\\n            node_sum = vals[node]\\n            answer = max(answer, node_sum)\\n            edge_count = 0\\n            for neighbor in neighbours:\\n                node_sum += vals[neighbor]\\n                edge_count += 1\\n                if edge_count > k:\\n                    node_sum -= vals[neighbor]\\n                answer = max(answer, node_sum)\\n                \\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        graph = defaultdict(list)\\n        n = len(vals)\\n        for i in range(n):\\n            graph[i]\\n        \\n        for a, b in edges:\\n            graph[a].append( b )\\n            graph[b].append( a )\\n            \\n        for node, neighbours in graph.items():\\n            neighbours.sort(key = lambda node: -vals[node])\\n        \\n        answer = vals[0]\\n        for node, neighbours in graph.items():\\n            #\\xA0Have k biggest nodes\\n            node_sum = vals[node]\\n            answer = max(answer, node_sum)\\n            edge_count = 0\\n            for neighbor in neighbours:\\n                node_sum += vals[neighbor]\\n                edge_count += 1\\n                if edge_count > k:\\n                    node_sum -= vals[neighbor]\\n                answer = max(answer, node_sum)\\n                \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998692,
                "title": "java-star-sum-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        int l = vals.length;\\n        HashSet<Integer> [] arr = new HashSet[l];\\n        for(int i =0;i<arr.length;i++)arr[i] = new HashSet<>();\\n        for(int [] edge:edges){\\n            int from = edge[0], to = edge[1];\\n            arr[from].add(to);\\n            arr[to].add(from);\\n        }\\n        int  max = Integer.MIN_VALUE;\\n        int u = 0;\\n        for(HashSet<Integer> set : arr){\\n            int [] val = new int[set.size()];\\n            int i =0;\\n            for(int a:set){\\n                val[i] = vals[a];\\n                i++;\\n            }\\n            Arrays.sort(val);\\n            int count = vals[u];\\n            for(int j = 0;j<k && j<set.size();j++){\\n                if(val[val.length- 1 - j]>0)count+= val[val.length- 1 - j];\\n            }\\n            max = Math.max(count,max);\\n            u++;\\n        }\\n\\n        return max;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        int l = vals.length;\\n        HashSet<Integer> [] arr = new HashSet[l];\\n        for(int i =0;i<arr.length;i++)arr[i] = new HashSet<>();\\n        for(int [] edge:edges){\\n            int from = edge[0], to = edge[1];\\n            arr[from].add(to);\\n            arr[to].add(from);\\n        }\\n        int  max = Integer.MIN_VALUE;\\n        int u = 0;\\n        for(HashSet<Integer> set : arr){\\n            int [] val = new int[set.size()];\\n            int i =0;\\n            for(int a:set){\\n                val[i] = vals[a];\\n                i++;\\n            }\\n            Arrays.sort(val);\\n            int count = vals[u];\\n            for(int j = 0;j<k && j<set.size();j++){\\n                if(val[val.length- 1 - j]>0)count+= val[val.length- 1 - j];\\n            }\\n            max = Math.max(count,max);\\n            u++;\\n        }\\n\\n        return max;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2983486,
                "title": "simple-and-easy-understanding-java-solution-beats-90",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a graph where neighbours are stored in priorityQueue\\n- Create an array of nodes and connect them with edges\\n- While Traversing the array check for maximum sum\\n- Return ans\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    class Node{\\n\\n        int val;\\n        Queue<Integer>next;\\n        Node(int i)\\n        {\\n            val=i;\\n            next=new PriorityQueue<>(Collections.reverseOrder());\\n\\n        }\\n    }\\n    public int maxStarSum(int[] vals, int[][] ed, int k) {\\n        \\n\\n            int n=vals.length;\\n            Node[]arr=new Node[n];\\n            for(int i=0;i<vals.length;i++)\\n            {\\n               arr[i]=new Node(vals[i]);\\n            }\\n\\n            for(int i=0;i<ed.length;i++)\\n            {\\n                arr[ed[i][0]].next.add(arr[ed[i][1]].val);\\n                arr[ed[i][1]].next.add(arr[ed[i][0]].val);\\n            }\\n            int ans=Integer.MIN_VALUE;\\n\\n            for(int i=0;i<n;i++)\\n            {\\n                int sum=arr[i].val;\\n                int c=0;\\n                ans=ans>sum?ans:sum;\\n                while(!arr[i].next.isEmpty()&&c<k)\\n                {\\n                    sum+=arr[i].next.poll();\\n                    c++;\\n                    ans=ans>sum?ans:sum;\\n                }\\n                ans=ans>sum?ans:sum;\\n                \\n            }\\n\\n    return ans;\\n\\n    }\\n}\\n```\\n> Stay hungry ! Stay f00lish ! : )",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n\\n    class Node{\\n\\n        int val;\\n        Queue<Integer>next;\\n        Node(int i)\\n        {\\n            val=i;\\n            next=new PriorityQueue<>(Collections.reverseOrder());\\n\\n        }\\n    }\\n    public int maxStarSum(int[] vals, int[][] ed, int k) {\\n        \\n\\n            int n=vals.length;\\n            Node[]arr=new Node[n];\\n            for(int i=0;i<vals.length;i++)\\n            {\\n               arr[i]=new Node(vals[i]);\\n            }\\n\\n            for(int i=0;i<ed.length;i++)\\n            {\\n                arr[ed[i][0]].next.add(arr[ed[i][1]].val);\\n                arr[ed[i][1]].next.add(arr[ed[i][0]].val);\\n            }\\n            int ans=Integer.MIN_VALUE;\\n\\n            for(int i=0;i<n;i++)\\n            {\\n                int sum=arr[i].val;\\n                int c=0;\\n                ans=ans>sum?ans:sum;\\n                while(!arr[i].next.isEmpty()&&c<k)\\n                {\\n                    sum+=arr[i].next.poll();\\n                    c++;\\n                    ans=ans>sum?ans:sum;\\n                }\\n                ans=ans>sum?ans:sum;\\n                \\n            }\\n\\n    return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982714,
                "title": "c-faster-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxStarSum(int[] vals, int[][] edges, int k) {\\n        int result = Int32.MinValue;\\n        var list = new List<int>[vals.Length];\\n        int numMax = Int32.MinValue;\\n        for(int i = 0; i < vals.Length; i++){\\n            list[i] = new List<int>();\\n            if(numMax < vals[i]){\\n                numMax = vals[i];\\n            }\\n        }\\n        if(edges.Length == 0){\\n            return numMax;\\n        }\\n        foreach(var arr in edges){\\n            list[arr[0]].Add(arr[1]);\\n            list[arr[1]].Add(arr[0]);\\n        }\\n        for(int j = 0; j < list.Length; j++){\\n            List<int> curr = list[j];\\n            curr.Sort((a, b) => vals[b] - vals[a]);\\n            int max = vals[j];\\n            int total = vals[j];\\n            for(int m = 0; m < k && m < curr.Count; m++){\\n                total += vals[curr[m]];\\n                max = Math.Max(max, total);\\n            }\\n            result = Math.Max(result, max);\\n        }\\n        return result;\\n    }\\n   \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxStarSum(int[] vals, int[][] edges, int k) {\\n        int result = Int32.MinValue;\\n        var list = new List<int>[vals.Length];\\n        int numMax = Int32.MinValue;\\n        for(int i = 0; i < vals.Length; i++){\\n            list[i] = new List<int>();\\n            if(numMax < vals[i]){\\n                numMax = vals[i];\\n            }\\n        }\\n        if(edges.Length == 0){\\n            return numMax;\\n        }\\n        foreach(var arr in edges){\\n            list[arr[0]].Add(arr[1]);\\n            list[arr[1]].Add(arr[0]);\\n        }\\n        for(int j = 0; j < list.Length; j++){\\n            List<int> curr = list[j];\\n            curr.Sort((a, b) => vals[b] - vals[a]);\\n            int max = vals[j];\\n            int total = vals[j];\\n            for(int m = 0; m < k && m < curr.Count; m++){\\n                total += vals[curr[m]];\\n                max = Math.Max(max, total);\\n            }\\n            result = Math.Max(result, max);\\n        }\\n        return result;\\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982527,
                "title": "c-heap-dynamic-top-k-sum",
                "content": "# Intuition\\nDynamic top k sum, use priority queue to maintain top k largest edge value.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int len = vals.size();\\n        vector<priority_queue<int, vector<int>, greater<>>> graph(len);\\n        vector<int> sums(len);\\n        auto enqueue = [&](const int from, const int to){\\n            if (vals[to] > 0) {\\n                if (graph[from].size() < k) {\\n                    sums[from] += vals[to];\\n                    graph[from].push(vals[to]);\\n                } else if (!graph[from].empty() && graph[from].top() < vals[to]) {\\n                    sums[from] -= graph[from].top();\\n                    sums[from] += vals[to];\\n                    graph[from].pop();\\n                    graph[from].push(vals[to]);\\n                }\\n            }\\n        };\\n        for (auto& edge : edges) {\\n            enqueue(edge[1], edge[0]);\\n            enqueue(edge[0], edge[1]); \\n        }\\n        int ma = INT_MIN;\\n        for (int i = 0; i < len; ++i) {\\n            ma = max(vals[i] + sums[i], ma);\\n        }\\n        return ma;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int len = vals.size();\\n        vector<priority_queue<int, vector<int>, greater<>>> graph(len);\\n        vector<int> sums(len);\\n        auto enqueue = [&](const int from, const int to){\\n            if (vals[to] > 0) {\\n                if (graph[from].size() < k) {\\n                    sums[from] += vals[to];\\n                    graph[from].push(vals[to]);\\n                } else if (!graph[from].empty() && graph[from].top() < vals[to]) {\\n                    sums[from] -= graph[from].top();\\n                    sums[from] += vals[to];\\n                    graph[from].pop();\\n                    graph[from].push(vals[to]);\\n                }\\n            }\\n        };\\n        for (auto& edge : edges) {\\n            enqueue(edge[1], edge[0]);\\n            enqueue(edge[0], edge[1]); \\n        }\\n        int ma = INT_MIN;\\n        for (int i = 0; i < len; ++i) {\\n            ma = max(vals[i] + sums[i], ma);\\n        }\\n        return ma;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981512,
                "title": "my-clean-java-code",
                "content": "# Intuition\\nConsider every node as center of star. For each center add k most valued nodes.\\n\\n# Approach\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO (E * log(K) )\\n\\n- Space complexity:\\n  O (E + V )\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        ArrayList<PriorityQueue<Integer>> list = new ArrayList<>();\\n        int n = vals.length;\\n        for(int i = 0 ; i<n ; i++)  list.add(new PriorityQueue<>( (a,b) -> a-b ));\\n\\n        for(int a[] : edges){\\n            PriorityQueue<Integer> q1 = list.get(a[0]);\\n            PriorityQueue<Integer> q2= list.get(a[1]);\\n            if(q1.size() < k){\\n                q1.add(vals[a[1]]);\\n            }else if(k!=0 && q1.peek() < vals[a[1]] ){\\n                q1.poll();\\n                q1.add(vals[a[1]]);\\n            }\\n\\n            if(q2.size() < k){\\n                q2.add(vals[a[0]]);\\n            }else if(k!=0 && q2.peek() < vals[a[0]] ){\\n                q2.poll();\\n                q2.add(vals[a[0]]);\\n            }\\n\\n        }\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0 ; i<n ; i++){\\n            int sum = vals[i];\\n            PriorityQueue<Integer> q = list.get(i);\\n            while(q.isEmpty()==false){\\n                if(q.peek()<0)  {\\n                    q.poll();\\n                    continue;\\n                }\\n                sum+=q.poll();\\n            }\\n            max = Math.max(max, sum);\\n        }\\n        return max;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        ArrayList<PriorityQueue<Integer>> list = new ArrayList<>();\\n        int n = vals.length;\\n        for(int i = 0 ; i<n ; i++)  list.add(new PriorityQueue<>( (a,b) -> a-b ));\\n\\n        for(int a[] : edges){\\n            PriorityQueue<Integer> q1 = list.get(a[0]);\\n            PriorityQueue<Integer> q2= list.get(a[1]);\\n            if(q1.size() < k){\\n                q1.add(vals[a[1]]);\\n            }else if(k!=0 && q1.peek() < vals[a[1]] ){\\n                q1.poll();\\n                q1.add(vals[a[1]]);\\n            }\\n\\n            if(q2.size() < k){\\n                q2.add(vals[a[0]]);\\n            }else if(k!=0 && q2.peek() < vals[a[0]] ){\\n                q2.poll();\\n                q2.add(vals[a[0]]);\\n            }\\n\\n        }\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0 ; i<n ; i++){\\n            int sum = vals[i];\\n            PriorityQueue<Integer> q = list.get(i);\\n            while(q.isEmpty()==false){\\n                if(q.peek()<0)  {\\n                    q.poll();\\n                    continue;\\n                }\\n                sum+=q.poll();\\n            }\\n            max = Math.max(max, sum);\\n        }\\n        return max;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969196,
                "title": "c-priority-queue-solution",
                "content": "```\\npublic class Solution {\\n    public int MaxStarSum(int[] vals, int[][] edges, int k) {\\n        PriorityQueue<int,int>[] g = new PriorityQueue<int,int>[vals.Length];\\n        for(int i = 0; i < vals.Length; i++){\\n            g[i] = new PriorityQueue<int,int>();\\n        }\\n        foreach(int[] edge in edges){\\n            g[edge[0]].Enqueue(edge[1], -vals[edge[1]]);\\n            g[edge[1]].Enqueue(edge[0], -vals[edge[0]]);\\n        }\\n        int max = int.MinValue;\\n        for(int i = 0; i < vals.Length; i++){\\n            int sum = vals[i], edgesAdded = 0;\\n            while(edgesAdded < k && g[i].Count > 0 && sum+vals[g[i].Peek()] > sum){\\n                sum += vals[g[i].Dequeue()];\\n                edgesAdded++;\\n            }\\n            max = Math.Max(max, sum);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxStarSum(int[] vals, int[][] edges, int k) {\\n        PriorityQueue<int,int>[] g = new PriorityQueue<int,int>[vals.Length];\\n        for(int i = 0; i < vals.Length; i++){\\n            g[i] = new PriorityQueue<int,int>();\\n        }\\n        foreach(int[] edge in edges){\\n            g[edge[0]].Enqueue(edge[1], -vals[edge[1]]);\\n            g[edge[1]].Enqueue(edge[0], -vals[edge[0]]);\\n        }\\n        int max = int.MinValue;\\n        for(int i = 0; i < vals.Length; i++){\\n            int sum = vals[i], edgesAdded = 0;\\n            while(edgesAdded < k && g[i].Count > 0 && sum+vals[g[i].Peek()] > sum){\\n                sum += vals[g[i].Dequeue()];\\n                edgesAdded++;\\n            }\\n            max = Math.Max(max, sum);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2968935,
                "title": "python-solution-with-detailed-explanation-of-every-step",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict;\\nclass Solution(object):\\n    def maxStarSum(self, vals, edges, k):\\n        \"\"\"\\n        :type vals: List[int]\\n        :type edges: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        #first check all the inputs if there is only one value given then just return that value,\\n        # or if edges list is empty return maximum value\\n        if len(vals) == 1:\\n            return vals[0];\\n        if len(edges) == 0:\\n            return max(vals)\\n        # if no such condition is met. Start the actual solution\\n        # make a dictionary where all the values will be stored in a list\\n        # result variable is declared because we need to make sure that our result is greater than the max value;\\n        #now start for loop to make dictionary. we need to ommit all negative values because those neg values will reduce the sum. so check if there is any neg value dont add it in our dectionary-value-list;\\n        vertex = defaultdict(list);\\n        temp =[];\\n        result = max(vals)\\n        \\n        for i, j in edges:\\n            if vals[j] > 0: \\n                vertex[i].append(vals[j])\\n            if vals[i] > 0: \\n                vertex[j].append(vals[i])\\n        \\n        #once dictionary is constructed it will look like this:\\n        # just sample : {0:[1,2,3], 1:[0,6], 2:[0]......etc};\\n        #now we need to find the largest \"k- values\" from all lists of our dictionary. for that I used heapq method heapq.nlargtest[k,iterable];\\n        #now sum these largest values and add it to that node where all these are connecting i.e the (key value) of that list\\n        # store all the sums in a list temp \\n        for i, j in vertex.items():\\n                temp.append(vals[i]+ sum(heapq.nlargest(k,j)))\\n\\n        #now find max of the temp list if that max is greater than the maximum node given in question just return it otherwise return the maximum node.\\n\\n        # if temp list is empty just return maximum node;\\n        if len(temp) == 0:\\n            return result;\\n        else:\\n            max_sum = max(temp);\\n            if max_sum > result:\\n                return max_sum\\n            else:\\n                return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict;\\nclass Solution(object):\\n    def maxStarSum(self, vals, edges, k):\\n        \"\"\"\\n        :type vals: List[int]\\n        :type edges: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        #first check all the inputs if there is only one value given then just return that value,\\n        # or if edges list is empty return maximum value\\n        if len(vals) == 1:\\n            return vals[0];\\n        if len(edges) == 0:\\n            return max(vals)\\n        # if no such condition is met. Start the actual solution\\n        # make a dictionary where all the values will be stored in a list\\n        # result variable is declared because we need to make sure that our result is greater than the max value;\\n        #now start for loop to make dictionary. we need to ommit all negative values because those neg values will reduce the sum. so check if there is any neg value dont add it in our dectionary-value-list;\\n        vertex = defaultdict(list);\\n        temp =[];\\n        result = max(vals)\\n        \\n        for i, j in edges:\\n            if vals[j] > 0: \\n                vertex[i].append(vals[j])\\n            if vals[i] > 0: \\n                vertex[j].append(vals[i])\\n        \\n        #once dictionary is constructed it will look like this:\\n        # just sample : {0:[1,2,3], 1:[0,6], 2:[0]......etc};\\n        #now we need to find the largest \"k- values\" from all lists of our dictionary. for that I used heapq method heapq.nlargtest[k,iterable];\\n        #now sum these largest values and add it to that node where all these are connecting i.e the (key value) of that list\\n        # store all the sums in a list temp \\n        for i, j in vertex.items():\\n                temp.append(vals[i]+ sum(heapq.nlargest(k,j)))\\n\\n        #now find max of the temp list if that max is greater than the maximum node given in question just return it otherwise return the maximum node.\\n\\n        # if temp list is empty just return maximum node;\\n        if len(temp) == 0:\\n            return result;\\n        else:\\n            max_sum = max(temp);\\n            if max_sum > result:\\n                return max_sum\\n            else:\\n                return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963963,
                "title": "java-javascript-c-solution",
                "content": "**Java, Heap**\\n```\\nimport java.util.PriorityQueue;\\n\\npublic class Solution {\\n\\n    //graph_nodeID_to_nodeValues[nodeID].size() <= maxNumberOfEdges\\n    //graph_nodeID_to_nodeValues[nodeID] contains only neighbours with positive values\\n    PriorityQueue<Integer>[] graph_nodeID_to_nodeValues;\\n\\n    public int maxStarSum(int[] nodeValues, int[][] edges, int maxNumberOfEdges) {\\n\\n        final int totalNodes = nodeValues.length;\\n        graph_nodeID_to_nodeValues = new PriorityQueue[totalNodes];\\n        for (int i = 0; i < totalNodes; ++i) {\\n            graph_nodeID_to_nodeValues[i] = new PriorityQueue<>();\\n        }\\n\\n        for (int[] edge : edges) {\\n            addEdgeEndingWithValueOfNode(nodeValues, edge[0], edge[1], maxNumberOfEdges);\\n            addEdgeEndingWithValueOfNode(nodeValues, edge[1], edge[0], maxNumberOfEdges);\\n        }\\n\\n        return calculateMaxStarSum(nodeValues, totalNodes);\\n    }\\n\\n    private void addEdgeEndingWithValueOfNode(int[] nodeValues, int fromNode, int toNode, int maxNumberOfEdges) {\\n        if (nodeValues[toNode] > 0 && graph_nodeID_to_nodeValues[fromNode].size() < maxNumberOfEdges) {\\n            graph_nodeID_to_nodeValues[fromNode].add(nodeValues[toNode]);\\n        } else if (!graph_nodeID_to_nodeValues[fromNode].isEmpty() && graph_nodeID_to_nodeValues[fromNode].peek() < nodeValues[toNode]) {\\n            graph_nodeID_to_nodeValues[fromNode].poll();\\n            graph_nodeID_to_nodeValues[fromNode].add(nodeValues[toNode]);\\n        }\\n    }\\n\\n    private int calculateMaxStarSum(int[] nodeValues, int totalNodes) {\\n        int maxStarSum = Integer.MIN_VALUE;\\n        for (int i = 0; i < totalNodes; ++i) {\\n            int sum = nodeValues[i];\\n            for (int value : graph_nodeID_to_nodeValues[i]) {\\n                sum += value;\\n            }\\n            maxStarSum = Math.max(maxStarSum, sum);\\n        }\\n        return maxStarSum;\\n    }\\n}\\n```\\n**Java, Sorting**\\n```\\nimport java.util.ArrayList;\\nimport java.util.Collections;\\nimport java.util.Comparator;\\nimport java.util.List;\\n\\npublic class Solution {\\n\\n    //graph_nodeID_to_nodeValues[nodeID] contains only neighbours with positive values\\n    List<Integer>[] graph_nodeID_to_nodeValues;\\n\\n    public int maxStarSum(int[] nodeValues, int[][] edges, int maxNumberOfEdges) {\\n\\n        final int totalNodes = nodeValues.length;\\n        graph_nodeID_to_nodeValues = new ArrayList[totalNodes];\\n        for (int i = 0; i < totalNodes; ++i) {\\n            graph_nodeID_to_nodeValues[i] = new ArrayList<>();\\n        }\\n\\n        for (int[] edge : edges) {\\n            addEdgeEndingWithValueOfNode(nodeValues, edge[0], edge[1]);\\n            addEdgeEndingWithValueOfNode(nodeValues, edge[1], edge[0]);\\n        }\\n\\n        return calculateMaxStarSum(nodeValues, totalNodes, maxNumberOfEdges);\\n    }\\n\\n    private void addEdgeEndingWithValueOfNode(int[] nodeValues, int fromNode, int toNode) {\\n        if (nodeValues[toNode] > 0) {\\n            graph_nodeID_to_nodeValues[fromNode].add(nodeValues[toNode]);\\n        }\\n    }\\n\\n    private int calculateMaxStarSum(int[] nodeValues, int totalNodes, int maxNumberOfEdges) {\\n        int maxStarSum = Integer.MIN_VALUE;\\n        for (int i = 0; i < totalNodes; ++i) {\\n            int sum = nodeValues[i];\\n            Collections.sort(graph_nodeID_to_nodeValues[i], Comparator.reverseOrder());\\n            for (int j = 0; j < maxNumberOfEdges && j < graph_nodeID_to_nodeValues[i].size(); ++j) {\\n                sum += graph_nodeID_to_nodeValues[i].get(j);\\n            }\\n            maxStarSum = Math.max(maxStarSum, sum);\\n        }\\n        return maxStarSum;\\n    }\\n}\\n```\\n**JavaScript, Heap**\\n```\\n//const {PriorityQueue} = require(\\'@datastructures-js/priority-queue\\');\\n\\n/**\\n * @param {number[]} nodeValues\\n * @param {number[][]} edges\\n * @param {number} maxNumberOfEdges\\n * @return {number}\\n */\\nvar maxStarSum = function (nodeValues, edges, maxNumberOfEdges) {\\n    const totalNodes = nodeValues.length;\\n    \\n    //graph_nodeID_to_nodeValues[nodeID].length <= maxNumberOfEdges\\n    //graph_nodeID_to_nodeValues[nodeID] contains only neighbours with positive values\\n    this.graph_nodeID_to_nodeValues = Array.from(new Array(totalNodes), () => new MinPriorityQueue());//new MinPriorityQueue<number>()\\n\\n    for (let edge of edges) {\\n        addEdgeEndingWithValueOfNode(nodeValues, edge[0], edge[1], maxNumberOfEdges);\\n        addEdgeEndingWithValueOfNode(nodeValues, edge[1], edge[0], maxNumberOfEdges);\\n    }\\n    return calculateMaxStarSum(nodeValues, totalNodes);\\n};\\n\\n/**\\n * @param {number[]} nodeValues\\n * @param {number} fromNode\\n * @param {number} toNode \\n * @param {number} maxNumberOfEdges\\n * @return {void}\\n */\\nfunction addEdgeEndingWithValueOfNode(nodeValues, fromNode, toNode, maxNumberOfEdges) {\\n    if (nodeValues[toNode] > 0 && this.graph_nodeID_to_nodeValues[fromNode].size() < maxNumberOfEdges) {\\n        this.graph_nodeID_to_nodeValues[fromNode].enqueue(nodeValues[toNode]);\\n    } else if (!this.graph_nodeID_to_nodeValues[fromNode].isEmpty() && this.graph_nodeID_to_nodeValues[fromNode].front().element < nodeValues[toNode]) {\\n        this.graph_nodeID_to_nodeValues[fromNode].dequeue();\\n        this.graph_nodeID_to_nodeValues[fromNode].enqueue(nodeValues[toNode]);\\n    }\\n}\\n\\n/**\\n * @param {number[]} nodeValues\\n * @param {number} totalNodes\\n * @return {number}\\n */\\nfunction  calculateMaxStarSum(nodeValues, totalNodes) {\\n    let maxStarSum = Number.MIN_SAFE_INTEGER;\\n    for (let i = 0; i < totalNodes; ++i) {\\n        let sum = nodeValues[i];\\n        const arrayFromPriorityQueue = this.graph_nodeID_to_nodeValues[i].toArray();\\n        arrayFromPriorityQueue.forEach(value => sum += value.element);\\n        maxStarSum = Math.max(maxStarSum, sum);\\n    }\\n    return maxStarSum;\\n}\\n```\\n**JavaScript, Sorting**\\n```\\n/**\\n * @param {number[]} nodeValues\\n * @param {number[][]} edges\\n * @param {number} maxNumberOfEdges\\n * @return {number}\\n */\\nvar maxStarSum = function (nodeValues, edges, maxNumberOfEdges) {\\n    const totalNodes = nodeValues.length;\\n    \\n    //graph_nodeID_to_nodeValues[nodeID] contains only neighbours with positive values\\n    this.graph_nodeID_to_nodeValues = Array.from(new Array(totalNodes), () => new Array());//Array<number>()\\n    for (let edge of edges) {\\n        addEdgeEndingWithValueOfNode(nodeValues, edge[0], edge[1]);\\n        addEdgeEndingWithValueOfNode(nodeValues, edge[1], edge[0]);\\n    }\\n    return calculateMaxStarSum(nodeValues, totalNodes, maxNumberOfEdges);\\n};\\n\\n/**\\n * @param {number[]} nodeValues\\n * @param {number} fromNode\\n * @param {number} toNode \\n * @return {void}\\n */\\nfunction addEdgeEndingWithValueOfNode(nodeValues, fromNode, toNode) {\\n    if (nodeValues[toNode] > 0) {\\n        this.graph_nodeID_to_nodeValues[fromNode].push(nodeValues[toNode]);\\n    }\\n}\\n\\n/**\\n * @param {number[]} nodeValues\\n * @param {number} totalNodes\\n * @param {number} maxNumberOfEdges \\n * @return {number}\\n */\\nfunction  calculateMaxStarSum(nodeValues, totalNodes, maxNumberOfEdges) {\\n    let maxStarSum = Number.MIN_SAFE_INTEGER;\\n    for (let i = 0; i < totalNodes; ++i) {\\n        let sum = nodeValues[i];\\n        this.graph_nodeID_to_nodeValues[i].sort((x, y) => y - x);\\n\\n        for (let j = 0; j < maxNumberOfEdges && j < this.graph_nodeID_to_nodeValues[i].length; ++j) {\\n            sum += this.graph_nodeID_to_nodeValues[i][j];\\n        }\\n        maxStarSum = Math.max(maxStarSum, sum);\\n    }\\n    return maxStarSum;\\n}\\n```\\n**C++, Heap**\\n```\\n#include <vector>\\n#include <algorithm>\\n#include <functional>\\nusing namespace std;\\n\\nclass Solution {\\n    \\n    //graph_nodeID_to_nodeValues[nodeID].length <= maxNumberOfEdges\\n    //graph_nodeID_to_nodeValues[nodeID] contains only neighbours with positive values\\n    vector<priority_queue<int, vector<int>, greater<>>> graph_nodeID_to_nodeValues;\\n    \\npublic:\\n    int maxStarSum(const vector<int>& nodeValues, const vector<vector<int>>& edges, int maxNumberOfEdges) {\\n        const size_t totalNodes = nodeValues.size();\\n        graph_nodeID_to_nodeValues.resize(totalNodes);\\n\\n        for (const auto& edge : edges) {\\n            addEdgeEndingWithValueOfNode(nodeValues, edge[0], edge[1], maxNumberOfEdges);\\n            addEdgeEndingWithValueOfNode(nodeValues, edge[1], edge[0], maxNumberOfEdges);\\n        }\\n\\n        return calculateMaxStarSum(nodeValues, totalNodes);\\n    }\\n\\nprivate:\\n    void addEdgeEndingWithValueOfNode(const vector<int>& nodeValues, int fromNode, int toNode, int maxNumberOfEdges) {\\n        if (nodeValues[toNode] > 0 && graph_nodeID_to_nodeValues[fromNode].size() < maxNumberOfEdges) {\\n            graph_nodeID_to_nodeValues[fromNode].push(nodeValues[toNode]);\\n        } else if (!graph_nodeID_to_nodeValues[fromNode].empty() && graph_nodeID_to_nodeValues[fromNode].top() < nodeValues[toNode]) {\\n            graph_nodeID_to_nodeValues[fromNode].pop();\\n            graph_nodeID_to_nodeValues[fromNode].push(nodeValues[toNode]);\\n        }\\n    }\\n\\n    int calculateMaxStarSum(const vector<int>& nodeValues, int totalNodes) {\\n        int maxStarSum = INT_MIN;\\n        for (int i = 0; i < totalNodes; ++i) {\\n            int sum = nodeValues[i];\\n\\n            while (!graph_nodeID_to_nodeValues[i].empty()) {\\n                sum += graph_nodeID_to_nodeValues[i].top();\\n                graph_nodeID_to_nodeValues[i].pop();\\n            }\\n            maxStarSum = max(maxStarSum, sum);\\n        }\\n        return maxStarSum;\\n    }\\n};\\n```\\n**C++, Sorting**\\n```\\n#include <vector>\\n#include <algorithm>\\n#include <functional>\\nusing namespace std;\\n\\nclass Solution {\\n    \\n    //graph_nodeID_to_nodeValues[nodeID] contains only neighbours with positive values\\n    vector<vector<int>> graph_nodeID_to_nodeValues;\\n    \\npublic:\\n    int maxStarSum(const vector<int>& nodeValues, const vector<vector<int>>& edges, int maxNumberOfEdges) {\\n        const size_t totalNodes = nodeValues.size();\\n        graph_nodeID_to_nodeValues.resize(totalNodes);\\n\\n        for (const auto& edge : edges) {\\n            addEdgeEndingWithValueOfNode(nodeValues, edge[0], edge[1], maxNumberOfEdges);\\n            addEdgeEndingWithValueOfNode(nodeValues, edge[1], edge[0], maxNumberOfEdges);\\n        }\\n\\n        return calculateMaxStarSum(nodeValues, totalNodes, maxNumberOfEdges);\\n    }\\n\\nprivate:\\n    void addEdgeEndingWithValueOfNode(const vector<int>& nodeValues, int fromNode, int toNode, int maxNumberOfEdges) {\\n        if (nodeValues[toNode] > 0) {\\n            graph_nodeID_to_nodeValues[fromNode].push_back(nodeValues[toNode]);\\n        }\\n    }\\n\\n    int calculateMaxStarSum(const vector<int>& nodeValues, size_t totalNodes, int maxNumberOfEdges) {\\n        int maxStarSum = INT_MIN;\\n        for (int i = 0; i < totalNodes; ++i) {\\n            int sum = nodeValues[i];\\n            sort(graph_nodeID_to_nodeValues[i].begin(), graph_nodeID_to_nodeValues[i].end(), greater<>());\\n            for (size_t j = 0; j < graph_nodeID_to_nodeValues[i].size() && j < maxNumberOfEdges; ++j) {\\n                sum += graph_nodeID_to_nodeValues[i][j];\\n            }\\n            maxStarSum = max(maxStarSum, sum);\\n        }\\n        return maxStarSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport java.util.PriorityQueue;\\n\\npublic class Solution {\\n\\n    //graph_nodeID_to_nodeValues[nodeID].size() <= maxNumberOfEdges\\n    //graph_nodeID_to_nodeValues[nodeID] contains only neighbours with positive values\\n    PriorityQueue<Integer>[] graph_nodeID_to_nodeValues;\\n\\n    public int maxStarSum(int[] nodeValues, int[][] edges, int maxNumberOfEdges) {\\n\\n        final int totalNodes = nodeValues.length;\\n        graph_nodeID_to_nodeValues = new PriorityQueue[totalNodes];\\n        for (int i = 0; i < totalNodes; ++i) {\\n            graph_nodeID_to_nodeValues[i] = new PriorityQueue<>();\\n        }\\n\\n        for (int[] edge : edges) {\\n            addEdgeEndingWithValueOfNode(nodeValues, edge[0], edge[1], maxNumberOfEdges);\\n            addEdgeEndingWithValueOfNode(nodeValues, edge[1], edge[0], maxNumberOfEdges);\\n        }\\n\\n        return calculateMaxStarSum(nodeValues, totalNodes);\\n    }\\n\\n    private void addEdgeEndingWithValueOfNode(int[] nodeValues, int fromNode, int toNode, int maxNumberOfEdges) {\\n        if (nodeValues[toNode] > 0 && graph_nodeID_to_nodeValues[fromNode].size() < maxNumberOfEdges) {\\n            graph_nodeID_to_nodeValues[fromNode].add(nodeValues[toNode]);\\n        } else if (!graph_nodeID_to_nodeValues[fromNode].isEmpty() && graph_nodeID_to_nodeValues[fromNode].peek() < nodeValues[toNode]) {\\n            graph_nodeID_to_nodeValues[fromNode].poll();\\n            graph_nodeID_to_nodeValues[fromNode].add(nodeValues[toNode]);\\n        }\\n    }\\n\\n    private int calculateMaxStarSum(int[] nodeValues, int totalNodes) {\\n        int maxStarSum = Integer.MIN_VALUE;\\n        for (int i = 0; i < totalNodes; ++i) {\\n            int sum = nodeValues[i];\\n            for (int value : graph_nodeID_to_nodeValues[i]) {\\n                sum += value;\\n            }\\n            maxStarSum = Math.max(maxStarSum, sum);\\n        }\\n        return maxStarSum;\\n    }\\n}\\n```\n```\\nimport java.util.ArrayList;\\nimport java.util.Collections;\\nimport java.util.Comparator;\\nimport java.util.List;\\n\\npublic class Solution {\\n\\n    //graph_nodeID_to_nodeValues[nodeID] contains only neighbours with positive values\\n    List<Integer>[] graph_nodeID_to_nodeValues;\\n\\n    public int maxStarSum(int[] nodeValues, int[][] edges, int maxNumberOfEdges) {\\n\\n        final int totalNodes = nodeValues.length;\\n        graph_nodeID_to_nodeValues = new ArrayList[totalNodes];\\n        for (int i = 0; i < totalNodes; ++i) {\\n            graph_nodeID_to_nodeValues[i] = new ArrayList<>();\\n        }\\n\\n        for (int[] edge : edges) {\\n            addEdgeEndingWithValueOfNode(nodeValues, edge[0], edge[1]);\\n            addEdgeEndingWithValueOfNode(nodeValues, edge[1], edge[0]);\\n        }\\n\\n        return calculateMaxStarSum(nodeValues, totalNodes, maxNumberOfEdges);\\n    }\\n\\n    private void addEdgeEndingWithValueOfNode(int[] nodeValues, int fromNode, int toNode) {\\n        if (nodeValues[toNode] > 0) {\\n            graph_nodeID_to_nodeValues[fromNode].add(nodeValues[toNode]);\\n        }\\n    }\\n\\n    private int calculateMaxStarSum(int[] nodeValues, int totalNodes, int maxNumberOfEdges) {\\n        int maxStarSum = Integer.MIN_VALUE;\\n        for (int i = 0; i < totalNodes; ++i) {\\n            int sum = nodeValues[i];\\n            Collections.sort(graph_nodeID_to_nodeValues[i], Comparator.reverseOrder());\\n            for (int j = 0; j < maxNumberOfEdges && j < graph_nodeID_to_nodeValues[i].size(); ++j) {\\n                sum += graph_nodeID_to_nodeValues[i].get(j);\\n            }\\n            maxStarSum = Math.max(maxStarSum, sum);\\n        }\\n        return maxStarSum;\\n    }\\n}\\n```\n```\\n//const {PriorityQueue} = require(\\'@datastructures-js/priority-queue\\');\\n\\n/**\\n * @param {number[]} nodeValues\\n * @param {number[][]} edges\\n * @param {number} maxNumberOfEdges\\n * @return {number}\\n */\\nvar maxStarSum = function (nodeValues, edges, maxNumberOfEdges) {\\n    const totalNodes = nodeValues.length;\\n    \\n    //graph_nodeID_to_nodeValues[nodeID].length <= maxNumberOfEdges\\n    //graph_nodeID_to_nodeValues[nodeID] contains only neighbours with positive values\\n    this.graph_nodeID_to_nodeValues = Array.from(new Array(totalNodes), () => new MinPriorityQueue());//new MinPriorityQueue<number>()\\n\\n    for (let edge of edges) {\\n        addEdgeEndingWithValueOfNode(nodeValues, edge[0], edge[1], maxNumberOfEdges);\\n        addEdgeEndingWithValueOfNode(nodeValues, edge[1], edge[0], maxNumberOfEdges);\\n    }\\n    return calculateMaxStarSum(nodeValues, totalNodes);\\n};\\n\\n/**\\n * @param {number[]} nodeValues\\n * @param {number} fromNode\\n * @param {number} toNode \\n * @param {number} maxNumberOfEdges\\n * @return {void}\\n */\\nfunction addEdgeEndingWithValueOfNode(nodeValues, fromNode, toNode, maxNumberOfEdges) {\\n    if (nodeValues[toNode] > 0 && this.graph_nodeID_to_nodeValues[fromNode].size() < maxNumberOfEdges) {\\n        this.graph_nodeID_to_nodeValues[fromNode].enqueue(nodeValues[toNode]);\\n    } else if (!this.graph_nodeID_to_nodeValues[fromNode].isEmpty() && this.graph_nodeID_to_nodeValues[fromNode].front().element < nodeValues[toNode]) {\\n        this.graph_nodeID_to_nodeValues[fromNode].dequeue();\\n        this.graph_nodeID_to_nodeValues[fromNode].enqueue(nodeValues[toNode]);\\n    }\\n}\\n\\n/**\\n * @param {number[]} nodeValues\\n * @param {number} totalNodes\\n * @return {number}\\n */\\nfunction  calculateMaxStarSum(nodeValues, totalNodes) {\\n    let maxStarSum = Number.MIN_SAFE_INTEGER;\\n    for (let i = 0; i < totalNodes; ++i) {\\n        let sum = nodeValues[i];\\n        const arrayFromPriorityQueue = this.graph_nodeID_to_nodeValues[i].toArray();\\n        arrayFromPriorityQueue.forEach(value => sum += value.element);\\n        maxStarSum = Math.max(maxStarSum, sum);\\n    }\\n    return maxStarSum;\\n}\\n```\n```\\n/**\\n * @param {number[]} nodeValues\\n * @param {number[][]} edges\\n * @param {number} maxNumberOfEdges\\n * @return {number}\\n */\\nvar maxStarSum = function (nodeValues, edges, maxNumberOfEdges) {\\n    const totalNodes = nodeValues.length;\\n    \\n    //graph_nodeID_to_nodeValues[nodeID] contains only neighbours with positive values\\n    this.graph_nodeID_to_nodeValues = Array.from(new Array(totalNodes), () => new Array());//Array<number>()\\n    for (let edge of edges) {\\n        addEdgeEndingWithValueOfNode(nodeValues, edge[0], edge[1]);\\n        addEdgeEndingWithValueOfNode(nodeValues, edge[1], edge[0]);\\n    }\\n    return calculateMaxStarSum(nodeValues, totalNodes, maxNumberOfEdges);\\n};\\n\\n/**\\n * @param {number[]} nodeValues\\n * @param {number} fromNode\\n * @param {number} toNode \\n * @return {void}\\n */\\nfunction addEdgeEndingWithValueOfNode(nodeValues, fromNode, toNode) {\\n    if (nodeValues[toNode] > 0) {\\n        this.graph_nodeID_to_nodeValues[fromNode].push(nodeValues[toNode]);\\n    }\\n}\\n\\n/**\\n * @param {number[]} nodeValues\\n * @param {number} totalNodes\\n * @param {number} maxNumberOfEdges \\n * @return {number}\\n */\\nfunction  calculateMaxStarSum(nodeValues, totalNodes, maxNumberOfEdges) {\\n    let maxStarSum = Number.MIN_SAFE_INTEGER;\\n    for (let i = 0; i < totalNodes; ++i) {\\n        let sum = nodeValues[i];\\n        this.graph_nodeID_to_nodeValues[i].sort((x, y) => y - x);\\n\\n        for (let j = 0; j < maxNumberOfEdges && j < this.graph_nodeID_to_nodeValues[i].length; ++j) {\\n            sum += this.graph_nodeID_to_nodeValues[i][j];\\n        }\\n        maxStarSum = Math.max(maxStarSum, sum);\\n    }\\n    return maxStarSum;\\n}\\n```\n```\\n#include <vector>\\n#include <algorithm>\\n#include <functional>\\nusing namespace std;\\n\\nclass Solution {\\n    \\n    //graph_nodeID_to_nodeValues[nodeID].length <= maxNumberOfEdges\\n    //graph_nodeID_to_nodeValues[nodeID] contains only neighbours with positive values\\n    vector<priority_queue<int, vector<int>, greater<>>> graph_nodeID_to_nodeValues;\\n    \\npublic:\\n    int maxStarSum(const vector<int>& nodeValues, const vector<vector<int>>& edges, int maxNumberOfEdges) {\\n        const size_t totalNodes = nodeValues.size();\\n        graph_nodeID_to_nodeValues.resize(totalNodes);\\n\\n        for (const auto& edge : edges) {\\n            addEdgeEndingWithValueOfNode(nodeValues, edge[0], edge[1], maxNumberOfEdges);\\n            addEdgeEndingWithValueOfNode(nodeValues, edge[1], edge[0], maxNumberOfEdges);\\n        }\\n\\n        return calculateMaxStarSum(nodeValues, totalNodes);\\n    }\\n\\nprivate:\\n    void addEdgeEndingWithValueOfNode(const vector<int>& nodeValues, int fromNode, int toNode, int maxNumberOfEdges) {\\n        if (nodeValues[toNode] > 0 && graph_nodeID_to_nodeValues[fromNode].size() < maxNumberOfEdges) {\\n            graph_nodeID_to_nodeValues[fromNode].push(nodeValues[toNode]);\\n        } else if (!graph_nodeID_to_nodeValues[fromNode].empty() && graph_nodeID_to_nodeValues[fromNode].top() < nodeValues[toNode]) {\\n            graph_nodeID_to_nodeValues[fromNode].pop();\\n            graph_nodeID_to_nodeValues[fromNode].push(nodeValues[toNode]);\\n        }\\n    }\\n\\n    int calculateMaxStarSum(const vector<int>& nodeValues, int totalNodes) {\\n        int maxStarSum = INT_MIN;\\n        for (int i = 0; i < totalNodes; ++i) {\\n            int sum = nodeValues[i];\\n\\n            while (!graph_nodeID_to_nodeValues[i].empty()) {\\n                sum += graph_nodeID_to_nodeValues[i].top();\\n                graph_nodeID_to_nodeValues[i].pop();\\n            }\\n            maxStarSum = max(maxStarSum, sum);\\n        }\\n        return maxStarSum;\\n    }\\n};\\n```\n```\\n#include <vector>\\n#include <algorithm>\\n#include <functional>\\nusing namespace std;\\n\\nclass Solution {\\n    \\n    //graph_nodeID_to_nodeValues[nodeID] contains only neighbours with positive values\\n    vector<vector<int>> graph_nodeID_to_nodeValues;\\n    \\npublic:\\n    int maxStarSum(const vector<int>& nodeValues, const vector<vector<int>>& edges, int maxNumberOfEdges) {\\n        const size_t totalNodes = nodeValues.size();\\n        graph_nodeID_to_nodeValues.resize(totalNodes);\\n\\n        for (const auto& edge : edges) {\\n            addEdgeEndingWithValueOfNode(nodeValues, edge[0], edge[1], maxNumberOfEdges);\\n            addEdgeEndingWithValueOfNode(nodeValues, edge[1], edge[0], maxNumberOfEdges);\\n        }\\n\\n        return calculateMaxStarSum(nodeValues, totalNodes, maxNumberOfEdges);\\n    }\\n\\nprivate:\\n    void addEdgeEndingWithValueOfNode(const vector<int>& nodeValues, int fromNode, int toNode, int maxNumberOfEdges) {\\n        if (nodeValues[toNode] > 0) {\\n            graph_nodeID_to_nodeValues[fromNode].push_back(nodeValues[toNode]);\\n        }\\n    }\\n\\n    int calculateMaxStarSum(const vector<int>& nodeValues, size_t totalNodes, int maxNumberOfEdges) {\\n        int maxStarSum = INT_MIN;\\n        for (int i = 0; i < totalNodes; ++i) {\\n            int sum = nodeValues[i];\\n            sort(graph_nodeID_to_nodeValues[i].begin(), graph_nodeID_to_nodeValues[i].end(), greater<>());\\n            for (size_t j = 0; j < graph_nodeID_to_nodeValues[i].size() && j < maxNumberOfEdges; ++j) {\\n                sum += graph_nodeID_to_nodeValues[i][j];\\n            }\\n            maxStarSum = max(maxStarSum, sum);\\n        }\\n        return maxStarSum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2962860,
                "title": "python-3-heap",
                "content": "```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        g = defaultdict(list)\\n        \\n        for i, j in edges:\\n            if vals[j] > 0:\\n                heappush(g[i], vals[j])\\n                if len(g[i]) > k:\\n                    heappop(g[i])\\n                    \\n            if vals[i] > 0:\\n                heappush(g[j], vals[i])\\n                if len(g[j]) > k:\\n                    heappop(g[j])\\n        \\n        res = max(vals)\\n        for node, v in g.items():\\n            res = max(res, vals[node] + sum(v))\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n        g = defaultdict(list)\\n        \\n        for i, j in edges:\\n            if vals[j] > 0:\\n                heappush(g[i], vals[j])\\n                if len(g[i]) > k:\\n                    heappop(g[i])\\n                    \\n            if vals[i] > 0:\\n                heappush(g[j], vals[i])\\n                if len(g[j]) > k:\\n                    heappop(g[j])\\n        \\n        res = max(vals)\\n        for node, v in g.items():\\n            res = max(res, vals[node] + sum(v))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962667,
                "title": "c-custom-priority-queue-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe want to take the **maximum** sum of the values of atmost k neighbors of a every node.\\n\\nK neighbors => use priority_queue\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWrite a custom comparator that stores the values of nodes in heap based on their value in `vals` array. We need a max heap for each node in the graph to store its neighbors\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(NlogK) - since we will add the values of upto K neighbors for each node.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N+V)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        auto comp = [&vals](int x, int y){\\n            return vals[x] < vals[y];\\n        };\\n        using pq = priority_queue<int, vector<int>, decltype(comp)>;\\n        vector<pq> vec(vals.size(), pq(comp));\\n        map<int, pq> adj;\\n        for(auto x :edges){\\n            vec[x[0]].push(x[1]);\\n            vec[x[1]].push(x[0]);\\n        }\\n        int ans = INT_MIN;\\n        for(int i =0 ; i< vals.size(); i++){\\n            pq heap = vec[i];\\n            int sum = 0, count = 0;\\n            sum += vals[i];\\n            while( !heap.empty() &&  count++ < k){\\n                ans = max(ans, sum);\\n                sum += vals[heap.top()];\\n                heap.pop();\\n            }\\n            ans = max(ans, sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        auto comp = [&vals](int x, int y){\\n            return vals[x] < vals[y];\\n        };\\n        using pq = priority_queue<int, vector<int>, decltype(comp)>;\\n        vector<pq> vec(vals.size(), pq(comp));\\n        map<int, pq> adj;\\n        for(auto x :edges){\\n            vec[x[0]].push(x[1]);\\n            vec[x[1]].push(x[0]);\\n        }\\n        int ans = INT_MIN;\\n        for(int i =0 ; i< vals.size(); i++){\\n            pq heap = vec[i];\\n            int sum = 0, count = 0;\\n            sum += vals[i];\\n            while( !heap.empty() &&  count++ < k){\\n                ans = max(ans, sum);\\n                sum += vals[heap.top()];\\n                heap.pop();\\n            }\\n            ans = max(ans, sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1713128,
                "content": [
                    {
                        "username": "jainaditya8464",
                        "content": "the constraints are wrong. According to constraints, n*k =10^10, so, O(n*k) solution should not pass, but it is passing. Even worse, I haven\\'t seen a better complexity solution that O(n*k) till now. I don\\'t see how it\\'s even possible. Bad question leetcode"
                    },
                    {
                        "username": "cooper--",
                        "content": "The description is a little misleading. I am thinking to find a sub graph, which is a star graph with respect to whole graph, meaning each other node has edge to this sub graph."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "2497. Maximum Star Sum of a Graph\\n\\nHow to approach such questions"
                    },
                    {
                        "username": "TTDLC",
                        "content": "[@guptaVBS](/guptaVBS) Thanks helped a lot"
                    },
                    {
                        "username": "guptaVBS",
                        "content": "Think about what is the exact ask in the question which is to find top(descending sorted on values) 0...K neighbors for every node of the graph. \\nNow your problem is reduced to somehow store all neighbors in graph in sorted order, which can be easily done through HEAP(Priority QUEUE). Reason for choosing HEAP is because it always ensure insertion and deletion time to be logN for at max N neighbors of a Node. \\nI would recommend breaking problem into various segments instead of thinking it as a big giant one. I hope it helps :)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "depressing question"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I think the description might be a little misleading. I know it is technically correct but it would be better if the wording could be modified a little.\\n> Given an integer k, return the maximum star sum of a star graph containing at most k edges.\\n\\nThis made me think we consider only nodes having at most k edges. When it was supposed to mean we consider at most k edges.\\n\\nSo maybe it can be changed to \\n> Given an integer k, return the maximum star sum of a star graph by considering at most k of its edges.\\n\\n"
                    },
                    {
                        "username": "shardul08",
                        "content": "What is wrong with this code?\\n- Create adjacency matrix\\n- For each node, calculate the sum of star graph with at-most k neighbours using priority queue\\n- Return maximum sum\\n ```\\nint maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int res = INT_MIN;\\n        vector<vector<int>> graph(vals.size(), vector<int>());\\n        \\n        for(auto edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        for(int i=0; i<vals.size(); i++) {\\n            priority_queue<int> pq;\\n            int cur = vals[i];\\n            for(int v : graph[i]) {\\n                if(pq.size() < k)\\n                    pq.push(vals[v]);\\n                else {\\n                    if(pq.top() < vals[v]) {\\n                        pq.pop();\\n                        pq.push(vals[v]);\\n                    }\\n                }\\n            }\\n            while(pq.size()) {\\n                if(pq.top() > 0)\\n                    cur += pq.top();\\n                pq.pop();\\n            }\\n            res = max(res, cur);\\n        }\\n        \\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "vsakjrs",
                        "content": "class Solution {\\n    private:\\n    int ans=INT_MIN;\\npublic:\\n    void bfs(unordered_map<int,vector<int>> &adj,vector<int>& vals,int src,int k){\\n        priority_queue<int> pq;\\n        vector<bool> visited(vals.size(),false);\\n        queue<int> q;\\n        q.push(src);\\n        visited[src]=true;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto &x:adj[u]){\\n                if(!visited[x]){\\n                    pq.push(vals[x]);\\n                    visited[x]=true;\\n                }\\n            }\\n        }\\n        int sum=vals[src];\\n        while(!pq.empty() && k--){\\n            if(pq.top()>=0)\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        ans=max(ans,sum);\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        for(int i=0;i<vals.size();i++)\\n            bfs(adj,vals,i,k);\\n        return ans;\\n\\n    }\\n};\\n\\nThat will solve your problerm"
                    },
                    {
                        "username": "varshaSahani",
                        "content": "[@shriyansnaik](/shriyansnaik) but in question is written there at most k "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "The star graph can have more than k neighbours. You can only consider at most k of its neighbours. Even I made the same mistake. Hope it helps."
                    },
                    {
                        "username": "annubhav001",
                        "content": "WHY MIN-HEAP ACTUALLY ? [THROUGH EXAMPLE]\\n\\n1st point : If we take max-heap then, after size of max-heap exceeds k, then we need to remove the top element which is actually the largest element which actually can increase the star-graph sum of a particular node but we removed it so we won\\'t be able to get the maximum star-graph sum of any node.\\n\\n2nd point : Now if we take min-heap, when size(min-heap)>k, then we need to remove that extra element inserted which will be the element at top of min-heap which is actually the smallest element from all those others elements in min heap which can give that maximum sum of a star-graph of any node.\\n\\nSummary : Using min-heap, ensures all the largest sum elements will remain in heap at bottom so that, when we remove that extra inserted element that minimum element from all those max elements in min-heap gets popped.\\n\\nThanks\\nYou can though upvote."
                    },
                    {
                        "username": "Alex-try",
                        "content": "an example failed, but i don\\'t know why. the example is   vals =[1,-8,0]  edges =[[1,0],[2,1]]   k=2\\nmy answer is -7,the right answer is 1.\\nI think it is centered at -8 . because k=2,so i add -8 and its neighbors 1 and 0. i got the answer -7.\\ni am confused. do i misunderstanding the problem?\\n"
                    },
                    {
                        "username": "harshchy2210",
                        "content": "yes, as the max no. of neighbors you are allowed to take is k, but if you get a sum which is greater without adding some neighbors then you need not add those neighbors. Total neighbors added may be less than k, but sum ha to be maximum. "
                    },
                    {
                        "username": "mr-ashok",
                        "content": "As per the description, we can have at-most K edges. So we can consider 0 edges as well. In above case, for 0th Node, with 0 edges, we get sum = value of Node => 1. Hope this helps."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Description and constraints are misleading."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "Should be an easy question"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "can anyone tell whats wrong in the approach and code:  `class Solution {\\nprivate:\\n    void dfs(vector<vector<int>>&adj,vector<int> &visited,vector<int>& vals,int &k,int &node,int &sum,int &count,int &maxsum){\\n        if(count-1<k){\\n            visited[node]=1;\\n            count++;\\n            sum+=vals[node];\\n            for(auto i:adj[node]){\\n                if(!visited[i]){\\n                    maxsum=max(sum,maxsum);\\n                     dfs(adj,visited,vals,k,i,sum,count,maxsum); \\n                                    \\n                }\\n            }\\n        count--;\\n        sum-=vals[node];\\n        }\\n       \\n    }\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int> visited(n,0);\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n\\n        }\\n        int maxsum=0;\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            int count=0;\\n            if(!visited[i]){\\n                dfs(adj,visited,vals,k,i,sum,count,maxsum);\\n                // maxsum=max(maxsum,sum);\\n            }\\n        }\\n        return maxsum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1712358,
                "content": [
                    {
                        "username": "jainaditya8464",
                        "content": "the constraints are wrong. According to constraints, n*k =10^10, so, O(n*k) solution should not pass, but it is passing. Even worse, I haven\\'t seen a better complexity solution that O(n*k) till now. I don\\'t see how it\\'s even possible. Bad question leetcode"
                    },
                    {
                        "username": "cooper--",
                        "content": "The description is a little misleading. I am thinking to find a sub graph, which is a star graph with respect to whole graph, meaning each other node has edge to this sub graph."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "2497. Maximum Star Sum of a Graph\\n\\nHow to approach such questions"
                    },
                    {
                        "username": "TTDLC",
                        "content": "[@guptaVBS](/guptaVBS) Thanks helped a lot"
                    },
                    {
                        "username": "guptaVBS",
                        "content": "Think about what is the exact ask in the question which is to find top(descending sorted on values) 0...K neighbors for every node of the graph. \\nNow your problem is reduced to somehow store all neighbors in graph in sorted order, which can be easily done through HEAP(Priority QUEUE). Reason for choosing HEAP is because it always ensure insertion and deletion time to be logN for at max N neighbors of a Node. \\nI would recommend breaking problem into various segments instead of thinking it as a big giant one. I hope it helps :)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "depressing question"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I think the description might be a little misleading. I know it is technically correct but it would be better if the wording could be modified a little.\\n> Given an integer k, return the maximum star sum of a star graph containing at most k edges.\\n\\nThis made me think we consider only nodes having at most k edges. When it was supposed to mean we consider at most k edges.\\n\\nSo maybe it can be changed to \\n> Given an integer k, return the maximum star sum of a star graph by considering at most k of its edges.\\n\\n"
                    },
                    {
                        "username": "shardul08",
                        "content": "What is wrong with this code?\\n- Create adjacency matrix\\n- For each node, calculate the sum of star graph with at-most k neighbours using priority queue\\n- Return maximum sum\\n ```\\nint maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int res = INT_MIN;\\n        vector<vector<int>> graph(vals.size(), vector<int>());\\n        \\n        for(auto edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        for(int i=0; i<vals.size(); i++) {\\n            priority_queue<int> pq;\\n            int cur = vals[i];\\n            for(int v : graph[i]) {\\n                if(pq.size() < k)\\n                    pq.push(vals[v]);\\n                else {\\n                    if(pq.top() < vals[v]) {\\n                        pq.pop();\\n                        pq.push(vals[v]);\\n                    }\\n                }\\n            }\\n            while(pq.size()) {\\n                if(pq.top() > 0)\\n                    cur += pq.top();\\n                pq.pop();\\n            }\\n            res = max(res, cur);\\n        }\\n        \\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "vsakjrs",
                        "content": "class Solution {\\n    private:\\n    int ans=INT_MIN;\\npublic:\\n    void bfs(unordered_map<int,vector<int>> &adj,vector<int>& vals,int src,int k){\\n        priority_queue<int> pq;\\n        vector<bool> visited(vals.size(),false);\\n        queue<int> q;\\n        q.push(src);\\n        visited[src]=true;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto &x:adj[u]){\\n                if(!visited[x]){\\n                    pq.push(vals[x]);\\n                    visited[x]=true;\\n                }\\n            }\\n        }\\n        int sum=vals[src];\\n        while(!pq.empty() && k--){\\n            if(pq.top()>=0)\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        ans=max(ans,sum);\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        for(int i=0;i<vals.size();i++)\\n            bfs(adj,vals,i,k);\\n        return ans;\\n\\n    }\\n};\\n\\nThat will solve your problerm"
                    },
                    {
                        "username": "varshaSahani",
                        "content": "[@shriyansnaik](/shriyansnaik) but in question is written there at most k "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "The star graph can have more than k neighbours. You can only consider at most k of its neighbours. Even I made the same mistake. Hope it helps."
                    },
                    {
                        "username": "annubhav001",
                        "content": "WHY MIN-HEAP ACTUALLY ? [THROUGH EXAMPLE]\\n\\n1st point : If we take max-heap then, after size of max-heap exceeds k, then we need to remove the top element which is actually the largest element which actually can increase the star-graph sum of a particular node but we removed it so we won\\'t be able to get the maximum star-graph sum of any node.\\n\\n2nd point : Now if we take min-heap, when size(min-heap)>k, then we need to remove that extra element inserted which will be the element at top of min-heap which is actually the smallest element from all those others elements in min heap which can give that maximum sum of a star-graph of any node.\\n\\nSummary : Using min-heap, ensures all the largest sum elements will remain in heap at bottom so that, when we remove that extra inserted element that minimum element from all those max elements in min-heap gets popped.\\n\\nThanks\\nYou can though upvote."
                    },
                    {
                        "username": "Alex-try",
                        "content": "an example failed, but i don\\'t know why. the example is   vals =[1,-8,0]  edges =[[1,0],[2,1]]   k=2\\nmy answer is -7,the right answer is 1.\\nI think it is centered at -8 . because k=2,so i add -8 and its neighbors 1 and 0. i got the answer -7.\\ni am confused. do i misunderstanding the problem?\\n"
                    },
                    {
                        "username": "harshchy2210",
                        "content": "yes, as the max no. of neighbors you are allowed to take is k, but if you get a sum which is greater without adding some neighbors then you need not add those neighbors. Total neighbors added may be less than k, but sum ha to be maximum. "
                    },
                    {
                        "username": "mr-ashok",
                        "content": "As per the description, we can have at-most K edges. So we can consider 0 edges as well. In above case, for 0th Node, with 0 edges, we get sum = value of Node => 1. Hope this helps."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Description and constraints are misleading."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "Should be an easy question"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "can anyone tell whats wrong in the approach and code:  `class Solution {\\nprivate:\\n    void dfs(vector<vector<int>>&adj,vector<int> &visited,vector<int>& vals,int &k,int &node,int &sum,int &count,int &maxsum){\\n        if(count-1<k){\\n            visited[node]=1;\\n            count++;\\n            sum+=vals[node];\\n            for(auto i:adj[node]){\\n                if(!visited[i]){\\n                    maxsum=max(sum,maxsum);\\n                     dfs(adj,visited,vals,k,i,sum,count,maxsum); \\n                                    \\n                }\\n            }\\n        count--;\\n        sum-=vals[node];\\n        }\\n       \\n    }\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int> visited(n,0);\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n\\n        }\\n        int maxsum=0;\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            int count=0;\\n            if(!visited[i]){\\n                dfs(adj,visited,vals,k,i,sum,count,maxsum);\\n                // maxsum=max(maxsum,sum);\\n            }\\n        }\\n        return maxsum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1712067,
                "content": [
                    {
                        "username": "jainaditya8464",
                        "content": "the constraints are wrong. According to constraints, n*k =10^10, so, O(n*k) solution should not pass, but it is passing. Even worse, I haven\\'t seen a better complexity solution that O(n*k) till now. I don\\'t see how it\\'s even possible. Bad question leetcode"
                    },
                    {
                        "username": "cooper--",
                        "content": "The description is a little misleading. I am thinking to find a sub graph, which is a star graph with respect to whole graph, meaning each other node has edge to this sub graph."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "2497. Maximum Star Sum of a Graph\\n\\nHow to approach such questions"
                    },
                    {
                        "username": "TTDLC",
                        "content": "[@guptaVBS](/guptaVBS) Thanks helped a lot"
                    },
                    {
                        "username": "guptaVBS",
                        "content": "Think about what is the exact ask in the question which is to find top(descending sorted on values) 0...K neighbors for every node of the graph. \\nNow your problem is reduced to somehow store all neighbors in graph in sorted order, which can be easily done through HEAP(Priority QUEUE). Reason for choosing HEAP is because it always ensure insertion and deletion time to be logN for at max N neighbors of a Node. \\nI would recommend breaking problem into various segments instead of thinking it as a big giant one. I hope it helps :)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "depressing question"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I think the description might be a little misleading. I know it is technically correct but it would be better if the wording could be modified a little.\\n> Given an integer k, return the maximum star sum of a star graph containing at most k edges.\\n\\nThis made me think we consider only nodes having at most k edges. When it was supposed to mean we consider at most k edges.\\n\\nSo maybe it can be changed to \\n> Given an integer k, return the maximum star sum of a star graph by considering at most k of its edges.\\n\\n"
                    },
                    {
                        "username": "shardul08",
                        "content": "What is wrong with this code?\\n- Create adjacency matrix\\n- For each node, calculate the sum of star graph with at-most k neighbours using priority queue\\n- Return maximum sum\\n ```\\nint maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int res = INT_MIN;\\n        vector<vector<int>> graph(vals.size(), vector<int>());\\n        \\n        for(auto edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        for(int i=0; i<vals.size(); i++) {\\n            priority_queue<int> pq;\\n            int cur = vals[i];\\n            for(int v : graph[i]) {\\n                if(pq.size() < k)\\n                    pq.push(vals[v]);\\n                else {\\n                    if(pq.top() < vals[v]) {\\n                        pq.pop();\\n                        pq.push(vals[v]);\\n                    }\\n                }\\n            }\\n            while(pq.size()) {\\n                if(pq.top() > 0)\\n                    cur += pq.top();\\n                pq.pop();\\n            }\\n            res = max(res, cur);\\n        }\\n        \\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "vsakjrs",
                        "content": "class Solution {\\n    private:\\n    int ans=INT_MIN;\\npublic:\\n    void bfs(unordered_map<int,vector<int>> &adj,vector<int>& vals,int src,int k){\\n        priority_queue<int> pq;\\n        vector<bool> visited(vals.size(),false);\\n        queue<int> q;\\n        q.push(src);\\n        visited[src]=true;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto &x:adj[u]){\\n                if(!visited[x]){\\n                    pq.push(vals[x]);\\n                    visited[x]=true;\\n                }\\n            }\\n        }\\n        int sum=vals[src];\\n        while(!pq.empty() && k--){\\n            if(pq.top()>=0)\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        ans=max(ans,sum);\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        for(int i=0;i<vals.size();i++)\\n            bfs(adj,vals,i,k);\\n        return ans;\\n\\n    }\\n};\\n\\nThat will solve your problerm"
                    },
                    {
                        "username": "varshaSahani",
                        "content": "[@shriyansnaik](/shriyansnaik) but in question is written there at most k "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "The star graph can have more than k neighbours. You can only consider at most k of its neighbours. Even I made the same mistake. Hope it helps."
                    },
                    {
                        "username": "annubhav001",
                        "content": "WHY MIN-HEAP ACTUALLY ? [THROUGH EXAMPLE]\\n\\n1st point : If we take max-heap then, after size of max-heap exceeds k, then we need to remove the top element which is actually the largest element which actually can increase the star-graph sum of a particular node but we removed it so we won\\'t be able to get the maximum star-graph sum of any node.\\n\\n2nd point : Now if we take min-heap, when size(min-heap)>k, then we need to remove that extra element inserted which will be the element at top of min-heap which is actually the smallest element from all those others elements in min heap which can give that maximum sum of a star-graph of any node.\\n\\nSummary : Using min-heap, ensures all the largest sum elements will remain in heap at bottom so that, when we remove that extra inserted element that minimum element from all those max elements in min-heap gets popped.\\n\\nThanks\\nYou can though upvote."
                    },
                    {
                        "username": "Alex-try",
                        "content": "an example failed, but i don\\'t know why. the example is   vals =[1,-8,0]  edges =[[1,0],[2,1]]   k=2\\nmy answer is -7,the right answer is 1.\\nI think it is centered at -8 . because k=2,so i add -8 and its neighbors 1 and 0. i got the answer -7.\\ni am confused. do i misunderstanding the problem?\\n"
                    },
                    {
                        "username": "harshchy2210",
                        "content": "yes, as the max no. of neighbors you are allowed to take is k, but if you get a sum which is greater without adding some neighbors then you need not add those neighbors. Total neighbors added may be less than k, but sum ha to be maximum. "
                    },
                    {
                        "username": "mr-ashok",
                        "content": "As per the description, we can have at-most K edges. So we can consider 0 edges as well. In above case, for 0th Node, with 0 edges, we get sum = value of Node => 1. Hope this helps."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Description and constraints are misleading."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "Should be an easy question"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "can anyone tell whats wrong in the approach and code:  `class Solution {\\nprivate:\\n    void dfs(vector<vector<int>>&adj,vector<int> &visited,vector<int>& vals,int &k,int &node,int &sum,int &count,int &maxsum){\\n        if(count-1<k){\\n            visited[node]=1;\\n            count++;\\n            sum+=vals[node];\\n            for(auto i:adj[node]){\\n                if(!visited[i]){\\n                    maxsum=max(sum,maxsum);\\n                     dfs(adj,visited,vals,k,i,sum,count,maxsum); \\n                                    \\n                }\\n            }\\n        count--;\\n        sum-=vals[node];\\n        }\\n       \\n    }\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int> visited(n,0);\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n\\n        }\\n        int maxsum=0;\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            int count=0;\\n            if(!visited[i]){\\n                dfs(adj,visited,vals,k,i,sum,count,maxsum);\\n                // maxsum=max(maxsum,sum);\\n            }\\n        }\\n        return maxsum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1713397,
                "content": [
                    {
                        "username": "jainaditya8464",
                        "content": "the constraints are wrong. According to constraints, n*k =10^10, so, O(n*k) solution should not pass, but it is passing. Even worse, I haven\\'t seen a better complexity solution that O(n*k) till now. I don\\'t see how it\\'s even possible. Bad question leetcode"
                    },
                    {
                        "username": "cooper--",
                        "content": "The description is a little misleading. I am thinking to find a sub graph, which is a star graph with respect to whole graph, meaning each other node has edge to this sub graph."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "2497. Maximum Star Sum of a Graph\\n\\nHow to approach such questions"
                    },
                    {
                        "username": "TTDLC",
                        "content": "[@guptaVBS](/guptaVBS) Thanks helped a lot"
                    },
                    {
                        "username": "guptaVBS",
                        "content": "Think about what is the exact ask in the question which is to find top(descending sorted on values) 0...K neighbors for every node of the graph. \\nNow your problem is reduced to somehow store all neighbors in graph in sorted order, which can be easily done through HEAP(Priority QUEUE). Reason for choosing HEAP is because it always ensure insertion and deletion time to be logN for at max N neighbors of a Node. \\nI would recommend breaking problem into various segments instead of thinking it as a big giant one. I hope it helps :)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "depressing question"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I think the description might be a little misleading. I know it is technically correct but it would be better if the wording could be modified a little.\\n> Given an integer k, return the maximum star sum of a star graph containing at most k edges.\\n\\nThis made me think we consider only nodes having at most k edges. When it was supposed to mean we consider at most k edges.\\n\\nSo maybe it can be changed to \\n> Given an integer k, return the maximum star sum of a star graph by considering at most k of its edges.\\n\\n"
                    },
                    {
                        "username": "shardul08",
                        "content": "What is wrong with this code?\\n- Create adjacency matrix\\n- For each node, calculate the sum of star graph with at-most k neighbours using priority queue\\n- Return maximum sum\\n ```\\nint maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int res = INT_MIN;\\n        vector<vector<int>> graph(vals.size(), vector<int>());\\n        \\n        for(auto edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        for(int i=0; i<vals.size(); i++) {\\n            priority_queue<int> pq;\\n            int cur = vals[i];\\n            for(int v : graph[i]) {\\n                if(pq.size() < k)\\n                    pq.push(vals[v]);\\n                else {\\n                    if(pq.top() < vals[v]) {\\n                        pq.pop();\\n                        pq.push(vals[v]);\\n                    }\\n                }\\n            }\\n            while(pq.size()) {\\n                if(pq.top() > 0)\\n                    cur += pq.top();\\n                pq.pop();\\n            }\\n            res = max(res, cur);\\n        }\\n        \\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "vsakjrs",
                        "content": "class Solution {\\n    private:\\n    int ans=INT_MIN;\\npublic:\\n    void bfs(unordered_map<int,vector<int>> &adj,vector<int>& vals,int src,int k){\\n        priority_queue<int> pq;\\n        vector<bool> visited(vals.size(),false);\\n        queue<int> q;\\n        q.push(src);\\n        visited[src]=true;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto &x:adj[u]){\\n                if(!visited[x]){\\n                    pq.push(vals[x]);\\n                    visited[x]=true;\\n                }\\n            }\\n        }\\n        int sum=vals[src];\\n        while(!pq.empty() && k--){\\n            if(pq.top()>=0)\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        ans=max(ans,sum);\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        for(int i=0;i<vals.size();i++)\\n            bfs(adj,vals,i,k);\\n        return ans;\\n\\n    }\\n};\\n\\nThat will solve your problerm"
                    },
                    {
                        "username": "varshaSahani",
                        "content": "[@shriyansnaik](/shriyansnaik) but in question is written there at most k "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "The star graph can have more than k neighbours. You can only consider at most k of its neighbours. Even I made the same mistake. Hope it helps."
                    },
                    {
                        "username": "annubhav001",
                        "content": "WHY MIN-HEAP ACTUALLY ? [THROUGH EXAMPLE]\\n\\n1st point : If we take max-heap then, after size of max-heap exceeds k, then we need to remove the top element which is actually the largest element which actually can increase the star-graph sum of a particular node but we removed it so we won\\'t be able to get the maximum star-graph sum of any node.\\n\\n2nd point : Now if we take min-heap, when size(min-heap)>k, then we need to remove that extra element inserted which will be the element at top of min-heap which is actually the smallest element from all those others elements in min heap which can give that maximum sum of a star-graph of any node.\\n\\nSummary : Using min-heap, ensures all the largest sum elements will remain in heap at bottom so that, when we remove that extra inserted element that minimum element from all those max elements in min-heap gets popped.\\n\\nThanks\\nYou can though upvote."
                    },
                    {
                        "username": "Alex-try",
                        "content": "an example failed, but i don\\'t know why. the example is   vals =[1,-8,0]  edges =[[1,0],[2,1]]   k=2\\nmy answer is -7,the right answer is 1.\\nI think it is centered at -8 . because k=2,so i add -8 and its neighbors 1 and 0. i got the answer -7.\\ni am confused. do i misunderstanding the problem?\\n"
                    },
                    {
                        "username": "harshchy2210",
                        "content": "yes, as the max no. of neighbors you are allowed to take is k, but if you get a sum which is greater without adding some neighbors then you need not add those neighbors. Total neighbors added may be less than k, but sum ha to be maximum. "
                    },
                    {
                        "username": "mr-ashok",
                        "content": "As per the description, we can have at-most K edges. So we can consider 0 edges as well. In above case, for 0th Node, with 0 edges, we get sum = value of Node => 1. Hope this helps."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Description and constraints are misleading."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "Should be an easy question"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "can anyone tell whats wrong in the approach and code:  `class Solution {\\nprivate:\\n    void dfs(vector<vector<int>>&adj,vector<int> &visited,vector<int>& vals,int &k,int &node,int &sum,int &count,int &maxsum){\\n        if(count-1<k){\\n            visited[node]=1;\\n            count++;\\n            sum+=vals[node];\\n            for(auto i:adj[node]){\\n                if(!visited[i]){\\n                    maxsum=max(sum,maxsum);\\n                     dfs(adj,visited,vals,k,i,sum,count,maxsum); \\n                                    \\n                }\\n            }\\n        count--;\\n        sum-=vals[node];\\n        }\\n       \\n    }\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int> visited(n,0);\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n\\n        }\\n        int maxsum=0;\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            int count=0;\\n            if(!visited[i]){\\n                dfs(adj,visited,vals,k,i,sum,count,maxsum);\\n                // maxsum=max(maxsum,sum);\\n            }\\n        }\\n        return maxsum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1713285,
                "content": [
                    {
                        "username": "jainaditya8464",
                        "content": "the constraints are wrong. According to constraints, n*k =10^10, so, O(n*k) solution should not pass, but it is passing. Even worse, I haven\\'t seen a better complexity solution that O(n*k) till now. I don\\'t see how it\\'s even possible. Bad question leetcode"
                    },
                    {
                        "username": "cooper--",
                        "content": "The description is a little misleading. I am thinking to find a sub graph, which is a star graph with respect to whole graph, meaning each other node has edge to this sub graph."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "2497. Maximum Star Sum of a Graph\\n\\nHow to approach such questions"
                    },
                    {
                        "username": "TTDLC",
                        "content": "[@guptaVBS](/guptaVBS) Thanks helped a lot"
                    },
                    {
                        "username": "guptaVBS",
                        "content": "Think about what is the exact ask in the question which is to find top(descending sorted on values) 0...K neighbors for every node of the graph. \\nNow your problem is reduced to somehow store all neighbors in graph in sorted order, which can be easily done through HEAP(Priority QUEUE). Reason for choosing HEAP is because it always ensure insertion and deletion time to be logN for at max N neighbors of a Node. \\nI would recommend breaking problem into various segments instead of thinking it as a big giant one. I hope it helps :)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "depressing question"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I think the description might be a little misleading. I know it is technically correct but it would be better if the wording could be modified a little.\\n> Given an integer k, return the maximum star sum of a star graph containing at most k edges.\\n\\nThis made me think we consider only nodes having at most k edges. When it was supposed to mean we consider at most k edges.\\n\\nSo maybe it can be changed to \\n> Given an integer k, return the maximum star sum of a star graph by considering at most k of its edges.\\n\\n"
                    },
                    {
                        "username": "shardul08",
                        "content": "What is wrong with this code?\\n- Create adjacency matrix\\n- For each node, calculate the sum of star graph with at-most k neighbours using priority queue\\n- Return maximum sum\\n ```\\nint maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int res = INT_MIN;\\n        vector<vector<int>> graph(vals.size(), vector<int>());\\n        \\n        for(auto edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        for(int i=0; i<vals.size(); i++) {\\n            priority_queue<int> pq;\\n            int cur = vals[i];\\n            for(int v : graph[i]) {\\n                if(pq.size() < k)\\n                    pq.push(vals[v]);\\n                else {\\n                    if(pq.top() < vals[v]) {\\n                        pq.pop();\\n                        pq.push(vals[v]);\\n                    }\\n                }\\n            }\\n            while(pq.size()) {\\n                if(pq.top() > 0)\\n                    cur += pq.top();\\n                pq.pop();\\n            }\\n            res = max(res, cur);\\n        }\\n        \\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "vsakjrs",
                        "content": "class Solution {\\n    private:\\n    int ans=INT_MIN;\\npublic:\\n    void bfs(unordered_map<int,vector<int>> &adj,vector<int>& vals,int src,int k){\\n        priority_queue<int> pq;\\n        vector<bool> visited(vals.size(),false);\\n        queue<int> q;\\n        q.push(src);\\n        visited[src]=true;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto &x:adj[u]){\\n                if(!visited[x]){\\n                    pq.push(vals[x]);\\n                    visited[x]=true;\\n                }\\n            }\\n        }\\n        int sum=vals[src];\\n        while(!pq.empty() && k--){\\n            if(pq.top()>=0)\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        ans=max(ans,sum);\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        for(int i=0;i<vals.size();i++)\\n            bfs(adj,vals,i,k);\\n        return ans;\\n\\n    }\\n};\\n\\nThat will solve your problerm"
                    },
                    {
                        "username": "varshaSahani",
                        "content": "[@shriyansnaik](/shriyansnaik) but in question is written there at most k "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "The star graph can have more than k neighbours. You can only consider at most k of its neighbours. Even I made the same mistake. Hope it helps."
                    },
                    {
                        "username": "annubhav001",
                        "content": "WHY MIN-HEAP ACTUALLY ? [THROUGH EXAMPLE]\\n\\n1st point : If we take max-heap then, after size of max-heap exceeds k, then we need to remove the top element which is actually the largest element which actually can increase the star-graph sum of a particular node but we removed it so we won\\'t be able to get the maximum star-graph sum of any node.\\n\\n2nd point : Now if we take min-heap, when size(min-heap)>k, then we need to remove that extra element inserted which will be the element at top of min-heap which is actually the smallest element from all those others elements in min heap which can give that maximum sum of a star-graph of any node.\\n\\nSummary : Using min-heap, ensures all the largest sum elements will remain in heap at bottom so that, when we remove that extra inserted element that minimum element from all those max elements in min-heap gets popped.\\n\\nThanks\\nYou can though upvote."
                    },
                    {
                        "username": "Alex-try",
                        "content": "an example failed, but i don\\'t know why. the example is   vals =[1,-8,0]  edges =[[1,0],[2,1]]   k=2\\nmy answer is -7,the right answer is 1.\\nI think it is centered at -8 . because k=2,so i add -8 and its neighbors 1 and 0. i got the answer -7.\\ni am confused. do i misunderstanding the problem?\\n"
                    },
                    {
                        "username": "harshchy2210",
                        "content": "yes, as the max no. of neighbors you are allowed to take is k, but if you get a sum which is greater without adding some neighbors then you need not add those neighbors. Total neighbors added may be less than k, but sum ha to be maximum. "
                    },
                    {
                        "username": "mr-ashok",
                        "content": "As per the description, we can have at-most K edges. So we can consider 0 edges as well. In above case, for 0th Node, with 0 edges, we get sum = value of Node => 1. Hope this helps."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Description and constraints are misleading."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "Should be an easy question"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "can anyone tell whats wrong in the approach and code:  `class Solution {\\nprivate:\\n    void dfs(vector<vector<int>>&adj,vector<int> &visited,vector<int>& vals,int &k,int &node,int &sum,int &count,int &maxsum){\\n        if(count-1<k){\\n            visited[node]=1;\\n            count++;\\n            sum+=vals[node];\\n            for(auto i:adj[node]){\\n                if(!visited[i]){\\n                    maxsum=max(sum,maxsum);\\n                     dfs(adj,visited,vals,k,i,sum,count,maxsum); \\n                                    \\n                }\\n            }\\n        count--;\\n        sum-=vals[node];\\n        }\\n       \\n    }\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int> visited(n,0);\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n\\n        }\\n        int maxsum=0;\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            int count=0;\\n            if(!visited[i]){\\n                dfs(adj,visited,vals,k,i,sum,count,maxsum);\\n                // maxsum=max(maxsum,sum);\\n            }\\n        }\\n        return maxsum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1783788,
                "content": [
                    {
                        "username": "jainaditya8464",
                        "content": "the constraints are wrong. According to constraints, n*k =10^10, so, O(n*k) solution should not pass, but it is passing. Even worse, I haven\\'t seen a better complexity solution that O(n*k) till now. I don\\'t see how it\\'s even possible. Bad question leetcode"
                    },
                    {
                        "username": "cooper--",
                        "content": "The description is a little misleading. I am thinking to find a sub graph, which is a star graph with respect to whole graph, meaning each other node has edge to this sub graph."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "2497. Maximum Star Sum of a Graph\\n\\nHow to approach such questions"
                    },
                    {
                        "username": "TTDLC",
                        "content": "[@guptaVBS](/guptaVBS) Thanks helped a lot"
                    },
                    {
                        "username": "guptaVBS",
                        "content": "Think about what is the exact ask in the question which is to find top(descending sorted on values) 0...K neighbors for every node of the graph. \\nNow your problem is reduced to somehow store all neighbors in graph in sorted order, which can be easily done through HEAP(Priority QUEUE). Reason for choosing HEAP is because it always ensure insertion and deletion time to be logN for at max N neighbors of a Node. \\nI would recommend breaking problem into various segments instead of thinking it as a big giant one. I hope it helps :)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "depressing question"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I think the description might be a little misleading. I know it is technically correct but it would be better if the wording could be modified a little.\\n> Given an integer k, return the maximum star sum of a star graph containing at most k edges.\\n\\nThis made me think we consider only nodes having at most k edges. When it was supposed to mean we consider at most k edges.\\n\\nSo maybe it can be changed to \\n> Given an integer k, return the maximum star sum of a star graph by considering at most k of its edges.\\n\\n"
                    },
                    {
                        "username": "shardul08",
                        "content": "What is wrong with this code?\\n- Create adjacency matrix\\n- For each node, calculate the sum of star graph with at-most k neighbours using priority queue\\n- Return maximum sum\\n ```\\nint maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int res = INT_MIN;\\n        vector<vector<int>> graph(vals.size(), vector<int>());\\n        \\n        for(auto edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        for(int i=0; i<vals.size(); i++) {\\n            priority_queue<int> pq;\\n            int cur = vals[i];\\n            for(int v : graph[i]) {\\n                if(pq.size() < k)\\n                    pq.push(vals[v]);\\n                else {\\n                    if(pq.top() < vals[v]) {\\n                        pq.pop();\\n                        pq.push(vals[v]);\\n                    }\\n                }\\n            }\\n            while(pq.size()) {\\n                if(pq.top() > 0)\\n                    cur += pq.top();\\n                pq.pop();\\n            }\\n            res = max(res, cur);\\n        }\\n        \\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "vsakjrs",
                        "content": "class Solution {\\n    private:\\n    int ans=INT_MIN;\\npublic:\\n    void bfs(unordered_map<int,vector<int>> &adj,vector<int>& vals,int src,int k){\\n        priority_queue<int> pq;\\n        vector<bool> visited(vals.size(),false);\\n        queue<int> q;\\n        q.push(src);\\n        visited[src]=true;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto &x:adj[u]){\\n                if(!visited[x]){\\n                    pq.push(vals[x]);\\n                    visited[x]=true;\\n                }\\n            }\\n        }\\n        int sum=vals[src];\\n        while(!pq.empty() && k--){\\n            if(pq.top()>=0)\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        ans=max(ans,sum);\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        for(int i=0;i<vals.size();i++)\\n            bfs(adj,vals,i,k);\\n        return ans;\\n\\n    }\\n};\\n\\nThat will solve your problerm"
                    },
                    {
                        "username": "varshaSahani",
                        "content": "[@shriyansnaik](/shriyansnaik) but in question is written there at most k "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "The star graph can have more than k neighbours. You can only consider at most k of its neighbours. Even I made the same mistake. Hope it helps."
                    },
                    {
                        "username": "annubhav001",
                        "content": "WHY MIN-HEAP ACTUALLY ? [THROUGH EXAMPLE]\\n\\n1st point : If we take max-heap then, after size of max-heap exceeds k, then we need to remove the top element which is actually the largest element which actually can increase the star-graph sum of a particular node but we removed it so we won\\'t be able to get the maximum star-graph sum of any node.\\n\\n2nd point : Now if we take min-heap, when size(min-heap)>k, then we need to remove that extra element inserted which will be the element at top of min-heap which is actually the smallest element from all those others elements in min heap which can give that maximum sum of a star-graph of any node.\\n\\nSummary : Using min-heap, ensures all the largest sum elements will remain in heap at bottom so that, when we remove that extra inserted element that minimum element from all those max elements in min-heap gets popped.\\n\\nThanks\\nYou can though upvote."
                    },
                    {
                        "username": "Alex-try",
                        "content": "an example failed, but i don\\'t know why. the example is   vals =[1,-8,0]  edges =[[1,0],[2,1]]   k=2\\nmy answer is -7,the right answer is 1.\\nI think it is centered at -8 . because k=2,so i add -8 and its neighbors 1 and 0. i got the answer -7.\\ni am confused. do i misunderstanding the problem?\\n"
                    },
                    {
                        "username": "harshchy2210",
                        "content": "yes, as the max no. of neighbors you are allowed to take is k, but if you get a sum which is greater without adding some neighbors then you need not add those neighbors. Total neighbors added may be less than k, but sum ha to be maximum. "
                    },
                    {
                        "username": "mr-ashok",
                        "content": "As per the description, we can have at-most K edges. So we can consider 0 edges as well. In above case, for 0th Node, with 0 edges, we get sum = value of Node => 1. Hope this helps."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Description and constraints are misleading."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "Should be an easy question"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "can anyone tell whats wrong in the approach and code:  `class Solution {\\nprivate:\\n    void dfs(vector<vector<int>>&adj,vector<int> &visited,vector<int>& vals,int &k,int &node,int &sum,int &count,int &maxsum){\\n        if(count-1<k){\\n            visited[node]=1;\\n            count++;\\n            sum+=vals[node];\\n            for(auto i:adj[node]){\\n                if(!visited[i]){\\n                    maxsum=max(sum,maxsum);\\n                     dfs(adj,visited,vals,k,i,sum,count,maxsum); \\n                                    \\n                }\\n            }\\n        count--;\\n        sum-=vals[node];\\n        }\\n       \\n    }\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int> visited(n,0);\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n\\n        }\\n        int maxsum=0;\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            int count=0;\\n            if(!visited[i]){\\n                dfs(adj,visited,vals,k,i,sum,count,maxsum);\\n                // maxsum=max(maxsum,sum);\\n            }\\n        }\\n        return maxsum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1712550,
                "content": [
                    {
                        "username": "jainaditya8464",
                        "content": "the constraints are wrong. According to constraints, n*k =10^10, so, O(n*k) solution should not pass, but it is passing. Even worse, I haven\\'t seen a better complexity solution that O(n*k) till now. I don\\'t see how it\\'s even possible. Bad question leetcode"
                    },
                    {
                        "username": "cooper--",
                        "content": "The description is a little misleading. I am thinking to find a sub graph, which is a star graph with respect to whole graph, meaning each other node has edge to this sub graph."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "2497. Maximum Star Sum of a Graph\\n\\nHow to approach such questions"
                    },
                    {
                        "username": "TTDLC",
                        "content": "[@guptaVBS](/guptaVBS) Thanks helped a lot"
                    },
                    {
                        "username": "guptaVBS",
                        "content": "Think about what is the exact ask in the question which is to find top(descending sorted on values) 0...K neighbors for every node of the graph. \\nNow your problem is reduced to somehow store all neighbors in graph in sorted order, which can be easily done through HEAP(Priority QUEUE). Reason for choosing HEAP is because it always ensure insertion and deletion time to be logN for at max N neighbors of a Node. \\nI would recommend breaking problem into various segments instead of thinking it as a big giant one. I hope it helps :)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "depressing question"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I think the description might be a little misleading. I know it is technically correct but it would be better if the wording could be modified a little.\\n> Given an integer k, return the maximum star sum of a star graph containing at most k edges.\\n\\nThis made me think we consider only nodes having at most k edges. When it was supposed to mean we consider at most k edges.\\n\\nSo maybe it can be changed to \\n> Given an integer k, return the maximum star sum of a star graph by considering at most k of its edges.\\n\\n"
                    },
                    {
                        "username": "shardul08",
                        "content": "What is wrong with this code?\\n- Create adjacency matrix\\n- For each node, calculate the sum of star graph with at-most k neighbours using priority queue\\n- Return maximum sum\\n ```\\nint maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int res = INT_MIN;\\n        vector<vector<int>> graph(vals.size(), vector<int>());\\n        \\n        for(auto edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        for(int i=0; i<vals.size(); i++) {\\n            priority_queue<int> pq;\\n            int cur = vals[i];\\n            for(int v : graph[i]) {\\n                if(pq.size() < k)\\n                    pq.push(vals[v]);\\n                else {\\n                    if(pq.top() < vals[v]) {\\n                        pq.pop();\\n                        pq.push(vals[v]);\\n                    }\\n                }\\n            }\\n            while(pq.size()) {\\n                if(pq.top() > 0)\\n                    cur += pq.top();\\n                pq.pop();\\n            }\\n            res = max(res, cur);\\n        }\\n        \\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "vsakjrs",
                        "content": "class Solution {\\n    private:\\n    int ans=INT_MIN;\\npublic:\\n    void bfs(unordered_map<int,vector<int>> &adj,vector<int>& vals,int src,int k){\\n        priority_queue<int> pq;\\n        vector<bool> visited(vals.size(),false);\\n        queue<int> q;\\n        q.push(src);\\n        visited[src]=true;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto &x:adj[u]){\\n                if(!visited[x]){\\n                    pq.push(vals[x]);\\n                    visited[x]=true;\\n                }\\n            }\\n        }\\n        int sum=vals[src];\\n        while(!pq.empty() && k--){\\n            if(pq.top()>=0)\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        ans=max(ans,sum);\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        for(int i=0;i<vals.size();i++)\\n            bfs(adj,vals,i,k);\\n        return ans;\\n\\n    }\\n};\\n\\nThat will solve your problerm"
                    },
                    {
                        "username": "varshaSahani",
                        "content": "[@shriyansnaik](/shriyansnaik) but in question is written there at most k "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "The star graph can have more than k neighbours. You can only consider at most k of its neighbours. Even I made the same mistake. Hope it helps."
                    },
                    {
                        "username": "annubhav001",
                        "content": "WHY MIN-HEAP ACTUALLY ? [THROUGH EXAMPLE]\\n\\n1st point : If we take max-heap then, after size of max-heap exceeds k, then we need to remove the top element which is actually the largest element which actually can increase the star-graph sum of a particular node but we removed it so we won\\'t be able to get the maximum star-graph sum of any node.\\n\\n2nd point : Now if we take min-heap, when size(min-heap)>k, then we need to remove that extra element inserted which will be the element at top of min-heap which is actually the smallest element from all those others elements in min heap which can give that maximum sum of a star-graph of any node.\\n\\nSummary : Using min-heap, ensures all the largest sum elements will remain in heap at bottom so that, when we remove that extra inserted element that minimum element from all those max elements in min-heap gets popped.\\n\\nThanks\\nYou can though upvote."
                    },
                    {
                        "username": "Alex-try",
                        "content": "an example failed, but i don\\'t know why. the example is   vals =[1,-8,0]  edges =[[1,0],[2,1]]   k=2\\nmy answer is -7,the right answer is 1.\\nI think it is centered at -8 . because k=2,so i add -8 and its neighbors 1 and 0. i got the answer -7.\\ni am confused. do i misunderstanding the problem?\\n"
                    },
                    {
                        "username": "harshchy2210",
                        "content": "yes, as the max no. of neighbors you are allowed to take is k, but if you get a sum which is greater without adding some neighbors then you need not add those neighbors. Total neighbors added may be less than k, but sum ha to be maximum. "
                    },
                    {
                        "username": "mr-ashok",
                        "content": "As per the description, we can have at-most K edges. So we can consider 0 edges as well. In above case, for 0th Node, with 0 edges, we get sum = value of Node => 1. Hope this helps."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Description and constraints are misleading."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "Should be an easy question"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "can anyone tell whats wrong in the approach and code:  `class Solution {\\nprivate:\\n    void dfs(vector<vector<int>>&adj,vector<int> &visited,vector<int>& vals,int &k,int &node,int &sum,int &count,int &maxsum){\\n        if(count-1<k){\\n            visited[node]=1;\\n            count++;\\n            sum+=vals[node];\\n            for(auto i:adj[node]){\\n                if(!visited[i]){\\n                    maxsum=max(sum,maxsum);\\n                     dfs(adj,visited,vals,k,i,sum,count,maxsum); \\n                                    \\n                }\\n            }\\n        count--;\\n        sum-=vals[node];\\n        }\\n       \\n    }\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int> visited(n,0);\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n\\n        }\\n        int maxsum=0;\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            int count=0;\\n            if(!visited[i]){\\n                dfs(adj,visited,vals,k,i,sum,count,maxsum);\\n                // maxsum=max(maxsum,sum);\\n            }\\n        }\\n        return maxsum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 2014283,
                "content": [
                    {
                        "username": "jainaditya8464",
                        "content": "the constraints are wrong. According to constraints, n*k =10^10, so, O(n*k) solution should not pass, but it is passing. Even worse, I haven\\'t seen a better complexity solution that O(n*k) till now. I don\\'t see how it\\'s even possible. Bad question leetcode"
                    },
                    {
                        "username": "cooper--",
                        "content": "The description is a little misleading. I am thinking to find a sub graph, which is a star graph with respect to whole graph, meaning each other node has edge to this sub graph."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "2497. Maximum Star Sum of a Graph\\n\\nHow to approach such questions"
                    },
                    {
                        "username": "TTDLC",
                        "content": "[@guptaVBS](/guptaVBS) Thanks helped a lot"
                    },
                    {
                        "username": "guptaVBS",
                        "content": "Think about what is the exact ask in the question which is to find top(descending sorted on values) 0...K neighbors for every node of the graph. \\nNow your problem is reduced to somehow store all neighbors in graph in sorted order, which can be easily done through HEAP(Priority QUEUE). Reason for choosing HEAP is because it always ensure insertion and deletion time to be logN for at max N neighbors of a Node. \\nI would recommend breaking problem into various segments instead of thinking it as a big giant one. I hope it helps :)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "depressing question"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I think the description might be a little misleading. I know it is technically correct but it would be better if the wording could be modified a little.\\n> Given an integer k, return the maximum star sum of a star graph containing at most k edges.\\n\\nThis made me think we consider only nodes having at most k edges. When it was supposed to mean we consider at most k edges.\\n\\nSo maybe it can be changed to \\n> Given an integer k, return the maximum star sum of a star graph by considering at most k of its edges.\\n\\n"
                    },
                    {
                        "username": "shardul08",
                        "content": "What is wrong with this code?\\n- Create adjacency matrix\\n- For each node, calculate the sum of star graph with at-most k neighbours using priority queue\\n- Return maximum sum\\n ```\\nint maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int res = INT_MIN;\\n        vector<vector<int>> graph(vals.size(), vector<int>());\\n        \\n        for(auto edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        for(int i=0; i<vals.size(); i++) {\\n            priority_queue<int> pq;\\n            int cur = vals[i];\\n            for(int v : graph[i]) {\\n                if(pq.size() < k)\\n                    pq.push(vals[v]);\\n                else {\\n                    if(pq.top() < vals[v]) {\\n                        pq.pop();\\n                        pq.push(vals[v]);\\n                    }\\n                }\\n            }\\n            while(pq.size()) {\\n                if(pq.top() > 0)\\n                    cur += pq.top();\\n                pq.pop();\\n            }\\n            res = max(res, cur);\\n        }\\n        \\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "vsakjrs",
                        "content": "class Solution {\\n    private:\\n    int ans=INT_MIN;\\npublic:\\n    void bfs(unordered_map<int,vector<int>> &adj,vector<int>& vals,int src,int k){\\n        priority_queue<int> pq;\\n        vector<bool> visited(vals.size(),false);\\n        queue<int> q;\\n        q.push(src);\\n        visited[src]=true;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto &x:adj[u]){\\n                if(!visited[x]){\\n                    pq.push(vals[x]);\\n                    visited[x]=true;\\n                }\\n            }\\n        }\\n        int sum=vals[src];\\n        while(!pq.empty() && k--){\\n            if(pq.top()>=0)\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        ans=max(ans,sum);\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        for(int i=0;i<vals.size();i++)\\n            bfs(adj,vals,i,k);\\n        return ans;\\n\\n    }\\n};\\n\\nThat will solve your problerm"
                    },
                    {
                        "username": "varshaSahani",
                        "content": "[@shriyansnaik](/shriyansnaik) but in question is written there at most k "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "The star graph can have more than k neighbours. You can only consider at most k of its neighbours. Even I made the same mistake. Hope it helps."
                    },
                    {
                        "username": "annubhav001",
                        "content": "WHY MIN-HEAP ACTUALLY ? [THROUGH EXAMPLE]\\n\\n1st point : If we take max-heap then, after size of max-heap exceeds k, then we need to remove the top element which is actually the largest element which actually can increase the star-graph sum of a particular node but we removed it so we won\\'t be able to get the maximum star-graph sum of any node.\\n\\n2nd point : Now if we take min-heap, when size(min-heap)>k, then we need to remove that extra element inserted which will be the element at top of min-heap which is actually the smallest element from all those others elements in min heap which can give that maximum sum of a star-graph of any node.\\n\\nSummary : Using min-heap, ensures all the largest sum elements will remain in heap at bottom so that, when we remove that extra inserted element that minimum element from all those max elements in min-heap gets popped.\\n\\nThanks\\nYou can though upvote."
                    },
                    {
                        "username": "Alex-try",
                        "content": "an example failed, but i don\\'t know why. the example is   vals =[1,-8,0]  edges =[[1,0],[2,1]]   k=2\\nmy answer is -7,the right answer is 1.\\nI think it is centered at -8 . because k=2,so i add -8 and its neighbors 1 and 0. i got the answer -7.\\ni am confused. do i misunderstanding the problem?\\n"
                    },
                    {
                        "username": "harshchy2210",
                        "content": "yes, as the max no. of neighbors you are allowed to take is k, but if you get a sum which is greater without adding some neighbors then you need not add those neighbors. Total neighbors added may be less than k, but sum ha to be maximum. "
                    },
                    {
                        "username": "mr-ashok",
                        "content": "As per the description, we can have at-most K edges. So we can consider 0 edges as well. In above case, for 0th Node, with 0 edges, we get sum = value of Node => 1. Hope this helps."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Description and constraints are misleading."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "Should be an easy question"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "can anyone tell whats wrong in the approach and code:  `class Solution {\\nprivate:\\n    void dfs(vector<vector<int>>&adj,vector<int> &visited,vector<int>& vals,int &k,int &node,int &sum,int &count,int &maxsum){\\n        if(count-1<k){\\n            visited[node]=1;\\n            count++;\\n            sum+=vals[node];\\n            for(auto i:adj[node]){\\n                if(!visited[i]){\\n                    maxsum=max(sum,maxsum);\\n                     dfs(adj,visited,vals,k,i,sum,count,maxsum); \\n                                    \\n                }\\n            }\\n        count--;\\n        sum-=vals[node];\\n        }\\n       \\n    }\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int> visited(n,0);\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n\\n        }\\n        int maxsum=0;\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            int count=0;\\n            if(!visited[i]){\\n                dfs(adj,visited,vals,k,i,sum,count,maxsum);\\n                // maxsum=max(maxsum,sum);\\n            }\\n        }\\n        return maxsum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1981745,
                "content": [
                    {
                        "username": "jainaditya8464",
                        "content": "the constraints are wrong. According to constraints, n*k =10^10, so, O(n*k) solution should not pass, but it is passing. Even worse, I haven\\'t seen a better complexity solution that O(n*k) till now. I don\\'t see how it\\'s even possible. Bad question leetcode"
                    },
                    {
                        "username": "cooper--",
                        "content": "The description is a little misleading. I am thinking to find a sub graph, which is a star graph with respect to whole graph, meaning each other node has edge to this sub graph."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "2497. Maximum Star Sum of a Graph\\n\\nHow to approach such questions"
                    },
                    {
                        "username": "TTDLC",
                        "content": "[@guptaVBS](/guptaVBS) Thanks helped a lot"
                    },
                    {
                        "username": "guptaVBS",
                        "content": "Think about what is the exact ask in the question which is to find top(descending sorted on values) 0...K neighbors for every node of the graph. \\nNow your problem is reduced to somehow store all neighbors in graph in sorted order, which can be easily done through HEAP(Priority QUEUE). Reason for choosing HEAP is because it always ensure insertion and deletion time to be logN for at max N neighbors of a Node. \\nI would recommend breaking problem into various segments instead of thinking it as a big giant one. I hope it helps :)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "depressing question"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I think the description might be a little misleading. I know it is technically correct but it would be better if the wording could be modified a little.\\n> Given an integer k, return the maximum star sum of a star graph containing at most k edges.\\n\\nThis made me think we consider only nodes having at most k edges. When it was supposed to mean we consider at most k edges.\\n\\nSo maybe it can be changed to \\n> Given an integer k, return the maximum star sum of a star graph by considering at most k of its edges.\\n\\n"
                    },
                    {
                        "username": "shardul08",
                        "content": "What is wrong with this code?\\n- Create adjacency matrix\\n- For each node, calculate the sum of star graph with at-most k neighbours using priority queue\\n- Return maximum sum\\n ```\\nint maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int res = INT_MIN;\\n        vector<vector<int>> graph(vals.size(), vector<int>());\\n        \\n        for(auto edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        for(int i=0; i<vals.size(); i++) {\\n            priority_queue<int> pq;\\n            int cur = vals[i];\\n            for(int v : graph[i]) {\\n                if(pq.size() < k)\\n                    pq.push(vals[v]);\\n                else {\\n                    if(pq.top() < vals[v]) {\\n                        pq.pop();\\n                        pq.push(vals[v]);\\n                    }\\n                }\\n            }\\n            while(pq.size()) {\\n                if(pq.top() > 0)\\n                    cur += pq.top();\\n                pq.pop();\\n            }\\n            res = max(res, cur);\\n        }\\n        \\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "vsakjrs",
                        "content": "class Solution {\\n    private:\\n    int ans=INT_MIN;\\npublic:\\n    void bfs(unordered_map<int,vector<int>> &adj,vector<int>& vals,int src,int k){\\n        priority_queue<int> pq;\\n        vector<bool> visited(vals.size(),false);\\n        queue<int> q;\\n        q.push(src);\\n        visited[src]=true;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto &x:adj[u]){\\n                if(!visited[x]){\\n                    pq.push(vals[x]);\\n                    visited[x]=true;\\n                }\\n            }\\n        }\\n        int sum=vals[src];\\n        while(!pq.empty() && k--){\\n            if(pq.top()>=0)\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        ans=max(ans,sum);\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        for(int i=0;i<vals.size();i++)\\n            bfs(adj,vals,i,k);\\n        return ans;\\n\\n    }\\n};\\n\\nThat will solve your problerm"
                    },
                    {
                        "username": "varshaSahani",
                        "content": "[@shriyansnaik](/shriyansnaik) but in question is written there at most k "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "The star graph can have more than k neighbours. You can only consider at most k of its neighbours. Even I made the same mistake. Hope it helps."
                    },
                    {
                        "username": "annubhav001",
                        "content": "WHY MIN-HEAP ACTUALLY ? [THROUGH EXAMPLE]\\n\\n1st point : If we take max-heap then, after size of max-heap exceeds k, then we need to remove the top element which is actually the largest element which actually can increase the star-graph sum of a particular node but we removed it so we won\\'t be able to get the maximum star-graph sum of any node.\\n\\n2nd point : Now if we take min-heap, when size(min-heap)>k, then we need to remove that extra element inserted which will be the element at top of min-heap which is actually the smallest element from all those others elements in min heap which can give that maximum sum of a star-graph of any node.\\n\\nSummary : Using min-heap, ensures all the largest sum elements will remain in heap at bottom so that, when we remove that extra inserted element that minimum element from all those max elements in min-heap gets popped.\\n\\nThanks\\nYou can though upvote."
                    },
                    {
                        "username": "Alex-try",
                        "content": "an example failed, but i don\\'t know why. the example is   vals =[1,-8,0]  edges =[[1,0],[2,1]]   k=2\\nmy answer is -7,the right answer is 1.\\nI think it is centered at -8 . because k=2,so i add -8 and its neighbors 1 and 0. i got the answer -7.\\ni am confused. do i misunderstanding the problem?\\n"
                    },
                    {
                        "username": "harshchy2210",
                        "content": "yes, as the max no. of neighbors you are allowed to take is k, but if you get a sum which is greater without adding some neighbors then you need not add those neighbors. Total neighbors added may be less than k, but sum ha to be maximum. "
                    },
                    {
                        "username": "mr-ashok",
                        "content": "As per the description, we can have at-most K edges. So we can consider 0 edges as well. In above case, for 0th Node, with 0 edges, we get sum = value of Node => 1. Hope this helps."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Description and constraints are misleading."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "Should be an easy question"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "can anyone tell whats wrong in the approach and code:  `class Solution {\\nprivate:\\n    void dfs(vector<vector<int>>&adj,vector<int> &visited,vector<int>& vals,int &k,int &node,int &sum,int &count,int &maxsum){\\n        if(count-1<k){\\n            visited[node]=1;\\n            count++;\\n            sum+=vals[node];\\n            for(auto i:adj[node]){\\n                if(!visited[i]){\\n                    maxsum=max(sum,maxsum);\\n                     dfs(adj,visited,vals,k,i,sum,count,maxsum); \\n                                    \\n                }\\n            }\\n        count--;\\n        sum-=vals[node];\\n        }\\n       \\n    }\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int> visited(n,0);\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n\\n        }\\n        int maxsum=0;\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            int count=0;\\n            if(!visited[i]){\\n                dfs(adj,visited,vals,k,i,sum,count,maxsum);\\n                // maxsum=max(maxsum,sum);\\n            }\\n        }\\n        return maxsum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1847738,
                "content": [
                    {
                        "username": "jainaditya8464",
                        "content": "the constraints are wrong. According to constraints, n*k =10^10, so, O(n*k) solution should not pass, but it is passing. Even worse, I haven\\'t seen a better complexity solution that O(n*k) till now. I don\\'t see how it\\'s even possible. Bad question leetcode"
                    },
                    {
                        "username": "cooper--",
                        "content": "The description is a little misleading. I am thinking to find a sub graph, which is a star graph with respect to whole graph, meaning each other node has edge to this sub graph."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "2497. Maximum Star Sum of a Graph\\n\\nHow to approach such questions"
                    },
                    {
                        "username": "TTDLC",
                        "content": "[@guptaVBS](/guptaVBS) Thanks helped a lot"
                    },
                    {
                        "username": "guptaVBS",
                        "content": "Think about what is the exact ask in the question which is to find top(descending sorted on values) 0...K neighbors for every node of the graph. \\nNow your problem is reduced to somehow store all neighbors in graph in sorted order, which can be easily done through HEAP(Priority QUEUE). Reason for choosing HEAP is because it always ensure insertion and deletion time to be logN for at max N neighbors of a Node. \\nI would recommend breaking problem into various segments instead of thinking it as a big giant one. I hope it helps :)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "depressing question"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I think the description might be a little misleading. I know it is technically correct but it would be better if the wording could be modified a little.\\n> Given an integer k, return the maximum star sum of a star graph containing at most k edges.\\n\\nThis made me think we consider only nodes having at most k edges. When it was supposed to mean we consider at most k edges.\\n\\nSo maybe it can be changed to \\n> Given an integer k, return the maximum star sum of a star graph by considering at most k of its edges.\\n\\n"
                    },
                    {
                        "username": "shardul08",
                        "content": "What is wrong with this code?\\n- Create adjacency matrix\\n- For each node, calculate the sum of star graph with at-most k neighbours using priority queue\\n- Return maximum sum\\n ```\\nint maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int res = INT_MIN;\\n        vector<vector<int>> graph(vals.size(), vector<int>());\\n        \\n        for(auto edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        for(int i=0; i<vals.size(); i++) {\\n            priority_queue<int> pq;\\n            int cur = vals[i];\\n            for(int v : graph[i]) {\\n                if(pq.size() < k)\\n                    pq.push(vals[v]);\\n                else {\\n                    if(pq.top() < vals[v]) {\\n                        pq.pop();\\n                        pq.push(vals[v]);\\n                    }\\n                }\\n            }\\n            while(pq.size()) {\\n                if(pq.top() > 0)\\n                    cur += pq.top();\\n                pq.pop();\\n            }\\n            res = max(res, cur);\\n        }\\n        \\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "vsakjrs",
                        "content": "class Solution {\\n    private:\\n    int ans=INT_MIN;\\npublic:\\n    void bfs(unordered_map<int,vector<int>> &adj,vector<int>& vals,int src,int k){\\n        priority_queue<int> pq;\\n        vector<bool> visited(vals.size(),false);\\n        queue<int> q;\\n        q.push(src);\\n        visited[src]=true;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto &x:adj[u]){\\n                if(!visited[x]){\\n                    pq.push(vals[x]);\\n                    visited[x]=true;\\n                }\\n            }\\n        }\\n        int sum=vals[src];\\n        while(!pq.empty() && k--){\\n            if(pq.top()>=0)\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        ans=max(ans,sum);\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        for(int i=0;i<vals.size();i++)\\n            bfs(adj,vals,i,k);\\n        return ans;\\n\\n    }\\n};\\n\\nThat will solve your problerm"
                    },
                    {
                        "username": "varshaSahani",
                        "content": "[@shriyansnaik](/shriyansnaik) but in question is written there at most k "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "The star graph can have more than k neighbours. You can only consider at most k of its neighbours. Even I made the same mistake. Hope it helps."
                    },
                    {
                        "username": "annubhav001",
                        "content": "WHY MIN-HEAP ACTUALLY ? [THROUGH EXAMPLE]\\n\\n1st point : If we take max-heap then, after size of max-heap exceeds k, then we need to remove the top element which is actually the largest element which actually can increase the star-graph sum of a particular node but we removed it so we won\\'t be able to get the maximum star-graph sum of any node.\\n\\n2nd point : Now if we take min-heap, when size(min-heap)>k, then we need to remove that extra element inserted which will be the element at top of min-heap which is actually the smallest element from all those others elements in min heap which can give that maximum sum of a star-graph of any node.\\n\\nSummary : Using min-heap, ensures all the largest sum elements will remain in heap at bottom so that, when we remove that extra inserted element that minimum element from all those max elements in min-heap gets popped.\\n\\nThanks\\nYou can though upvote."
                    },
                    {
                        "username": "Alex-try",
                        "content": "an example failed, but i don\\'t know why. the example is   vals =[1,-8,0]  edges =[[1,0],[2,1]]   k=2\\nmy answer is -7,the right answer is 1.\\nI think it is centered at -8 . because k=2,so i add -8 and its neighbors 1 and 0. i got the answer -7.\\ni am confused. do i misunderstanding the problem?\\n"
                    },
                    {
                        "username": "harshchy2210",
                        "content": "yes, as the max no. of neighbors you are allowed to take is k, but if you get a sum which is greater without adding some neighbors then you need not add those neighbors. Total neighbors added may be less than k, but sum ha to be maximum. "
                    },
                    {
                        "username": "mr-ashok",
                        "content": "As per the description, we can have at-most K edges. So we can consider 0 edges as well. In above case, for 0th Node, with 0 edges, we get sum = value of Node => 1. Hope this helps."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Description and constraints are misleading."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "Should be an easy question"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "can anyone tell whats wrong in the approach and code:  `class Solution {\\nprivate:\\n    void dfs(vector<vector<int>>&adj,vector<int> &visited,vector<int>& vals,int &k,int &node,int &sum,int &count,int &maxsum){\\n        if(count-1<k){\\n            visited[node]=1;\\n            count++;\\n            sum+=vals[node];\\n            for(auto i:adj[node]){\\n                if(!visited[i]){\\n                    maxsum=max(sum,maxsum);\\n                     dfs(adj,visited,vals,k,i,sum,count,maxsum); \\n                                    \\n                }\\n            }\\n        count--;\\n        sum-=vals[node];\\n        }\\n       \\n    }\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int> visited(n,0);\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n\\n        }\\n        int maxsum=0;\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            int count=0;\\n            if(!visited[i]){\\n                dfs(adj,visited,vals,k,i,sum,count,maxsum);\\n                // maxsum=max(maxsum,sum);\\n            }\\n        }\\n        return maxsum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1713128,
                "content": [
                    {
                        "username": "jainaditya8464",
                        "content": "the constraints are wrong. According to constraints, n*k =10^10, so, O(n*k) solution should not pass, but it is passing. Even worse, I haven\\'t seen a better complexity solution that O(n*k) till now. I don\\'t see how it\\'s even possible. Bad question leetcode"
                    },
                    {
                        "username": "cooper--",
                        "content": "The description is a little misleading. I am thinking to find a sub graph, which is a star graph with respect to whole graph, meaning each other node has edge to this sub graph."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "2497. Maximum Star Sum of a Graph\\n\\nHow to approach such questions"
                    },
                    {
                        "username": "TTDLC",
                        "content": "[@guptaVBS](/guptaVBS) Thanks helped a lot"
                    },
                    {
                        "username": "guptaVBS",
                        "content": "Think about what is the exact ask in the question which is to find top(descending sorted on values) 0...K neighbors for every node of the graph. \\nNow your problem is reduced to somehow store all neighbors in graph in sorted order, which can be easily done through HEAP(Priority QUEUE). Reason for choosing HEAP is because it always ensure insertion and deletion time to be logN for at max N neighbors of a Node. \\nI would recommend breaking problem into various segments instead of thinking it as a big giant one. I hope it helps :)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "depressing question"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I think the description might be a little misleading. I know it is technically correct but it would be better if the wording could be modified a little.\\n> Given an integer k, return the maximum star sum of a star graph containing at most k edges.\\n\\nThis made me think we consider only nodes having at most k edges. When it was supposed to mean we consider at most k edges.\\n\\nSo maybe it can be changed to \\n> Given an integer k, return the maximum star sum of a star graph by considering at most k of its edges.\\n\\n"
                    },
                    {
                        "username": "shardul08",
                        "content": "What is wrong with this code?\\n- Create adjacency matrix\\n- For each node, calculate the sum of star graph with at-most k neighbours using priority queue\\n- Return maximum sum\\n ```\\nint maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int res = INT_MIN;\\n        vector<vector<int>> graph(vals.size(), vector<int>());\\n        \\n        for(auto edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        for(int i=0; i<vals.size(); i++) {\\n            priority_queue<int> pq;\\n            int cur = vals[i];\\n            for(int v : graph[i]) {\\n                if(pq.size() < k)\\n                    pq.push(vals[v]);\\n                else {\\n                    if(pq.top() < vals[v]) {\\n                        pq.pop();\\n                        pq.push(vals[v]);\\n                    }\\n                }\\n            }\\n            while(pq.size()) {\\n                if(pq.top() > 0)\\n                    cur += pq.top();\\n                pq.pop();\\n            }\\n            res = max(res, cur);\\n        }\\n        \\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "vsakjrs",
                        "content": "class Solution {\\n    private:\\n    int ans=INT_MIN;\\npublic:\\n    void bfs(unordered_map<int,vector<int>> &adj,vector<int>& vals,int src,int k){\\n        priority_queue<int> pq;\\n        vector<bool> visited(vals.size(),false);\\n        queue<int> q;\\n        q.push(src);\\n        visited[src]=true;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto &x:adj[u]){\\n                if(!visited[x]){\\n                    pq.push(vals[x]);\\n                    visited[x]=true;\\n                }\\n            }\\n        }\\n        int sum=vals[src];\\n        while(!pq.empty() && k--){\\n            if(pq.top()>=0)\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        ans=max(ans,sum);\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        for(int i=0;i<vals.size();i++)\\n            bfs(adj,vals,i,k);\\n        return ans;\\n\\n    }\\n};\\n\\nThat will solve your problerm"
                    },
                    {
                        "username": "varshaSahani",
                        "content": "[@shriyansnaik](/shriyansnaik) but in question is written there at most k "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "The star graph can have more than k neighbours. You can only consider at most k of its neighbours. Even I made the same mistake. Hope it helps."
                    },
                    {
                        "username": "annubhav001",
                        "content": "WHY MIN-HEAP ACTUALLY ? [THROUGH EXAMPLE]\\n\\n1st point : If we take max-heap then, after size of max-heap exceeds k, then we need to remove the top element which is actually the largest element which actually can increase the star-graph sum of a particular node but we removed it so we won\\'t be able to get the maximum star-graph sum of any node.\\n\\n2nd point : Now if we take min-heap, when size(min-heap)>k, then we need to remove that extra element inserted which will be the element at top of min-heap which is actually the smallest element from all those others elements in min heap which can give that maximum sum of a star-graph of any node.\\n\\nSummary : Using min-heap, ensures all the largest sum elements will remain in heap at bottom so that, when we remove that extra inserted element that minimum element from all those max elements in min-heap gets popped.\\n\\nThanks\\nYou can though upvote."
                    },
                    {
                        "username": "Alex-try",
                        "content": "an example failed, but i don\\'t know why. the example is   vals =[1,-8,0]  edges =[[1,0],[2,1]]   k=2\\nmy answer is -7,the right answer is 1.\\nI think it is centered at -8 . because k=2,so i add -8 and its neighbors 1 and 0. i got the answer -7.\\ni am confused. do i misunderstanding the problem?\\n"
                    },
                    {
                        "username": "harshchy2210",
                        "content": "yes, as the max no. of neighbors you are allowed to take is k, but if you get a sum which is greater without adding some neighbors then you need not add those neighbors. Total neighbors added may be less than k, but sum ha to be maximum. "
                    },
                    {
                        "username": "mr-ashok",
                        "content": "As per the description, we can have at-most K edges. So we can consider 0 edges as well. In above case, for 0th Node, with 0 edges, we get sum = value of Node => 1. Hope this helps."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Description and constraints are misleading."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "Should be an easy question"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "can anyone tell whats wrong in the approach and code:  `class Solution {\\nprivate:\\n    void dfs(vector<vector<int>>&adj,vector<int> &visited,vector<int>& vals,int &k,int &node,int &sum,int &count,int &maxsum){\\n        if(count-1<k){\\n            visited[node]=1;\\n            count++;\\n            sum+=vals[node];\\n            for(auto i:adj[node]){\\n                if(!visited[i]){\\n                    maxsum=max(sum,maxsum);\\n                     dfs(adj,visited,vals,k,i,sum,count,maxsum); \\n                                    \\n                }\\n            }\\n        count--;\\n        sum-=vals[node];\\n        }\\n       \\n    }\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int> visited(n,0);\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n\\n        }\\n        int maxsum=0;\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            int count=0;\\n            if(!visited[i]){\\n                dfs(adj,visited,vals,k,i,sum,count,maxsum);\\n                // maxsum=max(maxsum,sum);\\n            }\\n        }\\n        return maxsum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1712358,
                "content": [
                    {
                        "username": "jainaditya8464",
                        "content": "the constraints are wrong. According to constraints, n*k =10^10, so, O(n*k) solution should not pass, but it is passing. Even worse, I haven\\'t seen a better complexity solution that O(n*k) till now. I don\\'t see how it\\'s even possible. Bad question leetcode"
                    },
                    {
                        "username": "cooper--",
                        "content": "The description is a little misleading. I am thinking to find a sub graph, which is a star graph with respect to whole graph, meaning each other node has edge to this sub graph."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "2497. Maximum Star Sum of a Graph\\n\\nHow to approach such questions"
                    },
                    {
                        "username": "TTDLC",
                        "content": "[@guptaVBS](/guptaVBS) Thanks helped a lot"
                    },
                    {
                        "username": "guptaVBS",
                        "content": "Think about what is the exact ask in the question which is to find top(descending sorted on values) 0...K neighbors for every node of the graph. \\nNow your problem is reduced to somehow store all neighbors in graph in sorted order, which can be easily done through HEAP(Priority QUEUE). Reason for choosing HEAP is because it always ensure insertion and deletion time to be logN for at max N neighbors of a Node. \\nI would recommend breaking problem into various segments instead of thinking it as a big giant one. I hope it helps :)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "depressing question"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I think the description might be a little misleading. I know it is technically correct but it would be better if the wording could be modified a little.\\n> Given an integer k, return the maximum star sum of a star graph containing at most k edges.\\n\\nThis made me think we consider only nodes having at most k edges. When it was supposed to mean we consider at most k edges.\\n\\nSo maybe it can be changed to \\n> Given an integer k, return the maximum star sum of a star graph by considering at most k of its edges.\\n\\n"
                    },
                    {
                        "username": "shardul08",
                        "content": "What is wrong with this code?\\n- Create adjacency matrix\\n- For each node, calculate the sum of star graph with at-most k neighbours using priority queue\\n- Return maximum sum\\n ```\\nint maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int res = INT_MIN;\\n        vector<vector<int>> graph(vals.size(), vector<int>());\\n        \\n        for(auto edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        for(int i=0; i<vals.size(); i++) {\\n            priority_queue<int> pq;\\n            int cur = vals[i];\\n            for(int v : graph[i]) {\\n                if(pq.size() < k)\\n                    pq.push(vals[v]);\\n                else {\\n                    if(pq.top() < vals[v]) {\\n                        pq.pop();\\n                        pq.push(vals[v]);\\n                    }\\n                }\\n            }\\n            while(pq.size()) {\\n                if(pq.top() > 0)\\n                    cur += pq.top();\\n                pq.pop();\\n            }\\n            res = max(res, cur);\\n        }\\n        \\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "vsakjrs",
                        "content": "class Solution {\\n    private:\\n    int ans=INT_MIN;\\npublic:\\n    void bfs(unordered_map<int,vector<int>> &adj,vector<int>& vals,int src,int k){\\n        priority_queue<int> pq;\\n        vector<bool> visited(vals.size(),false);\\n        queue<int> q;\\n        q.push(src);\\n        visited[src]=true;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto &x:adj[u]){\\n                if(!visited[x]){\\n                    pq.push(vals[x]);\\n                    visited[x]=true;\\n                }\\n            }\\n        }\\n        int sum=vals[src];\\n        while(!pq.empty() && k--){\\n            if(pq.top()>=0)\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        ans=max(ans,sum);\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        for(int i=0;i<vals.size();i++)\\n            bfs(adj,vals,i,k);\\n        return ans;\\n\\n    }\\n};\\n\\nThat will solve your problerm"
                    },
                    {
                        "username": "varshaSahani",
                        "content": "[@shriyansnaik](/shriyansnaik) but in question is written there at most k "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "The star graph can have more than k neighbours. You can only consider at most k of its neighbours. Even I made the same mistake. Hope it helps."
                    },
                    {
                        "username": "annubhav001",
                        "content": "WHY MIN-HEAP ACTUALLY ? [THROUGH EXAMPLE]\\n\\n1st point : If we take max-heap then, after size of max-heap exceeds k, then we need to remove the top element which is actually the largest element which actually can increase the star-graph sum of a particular node but we removed it so we won\\'t be able to get the maximum star-graph sum of any node.\\n\\n2nd point : Now if we take min-heap, when size(min-heap)>k, then we need to remove that extra element inserted which will be the element at top of min-heap which is actually the smallest element from all those others elements in min heap which can give that maximum sum of a star-graph of any node.\\n\\nSummary : Using min-heap, ensures all the largest sum elements will remain in heap at bottom so that, when we remove that extra inserted element that minimum element from all those max elements in min-heap gets popped.\\n\\nThanks\\nYou can though upvote."
                    },
                    {
                        "username": "Alex-try",
                        "content": "an example failed, but i don\\'t know why. the example is   vals =[1,-8,0]  edges =[[1,0],[2,1]]   k=2\\nmy answer is -7,the right answer is 1.\\nI think it is centered at -8 . because k=2,so i add -8 and its neighbors 1 and 0. i got the answer -7.\\ni am confused. do i misunderstanding the problem?\\n"
                    },
                    {
                        "username": "harshchy2210",
                        "content": "yes, as the max no. of neighbors you are allowed to take is k, but if you get a sum which is greater without adding some neighbors then you need not add those neighbors. Total neighbors added may be less than k, but sum ha to be maximum. "
                    },
                    {
                        "username": "mr-ashok",
                        "content": "As per the description, we can have at-most K edges. So we can consider 0 edges as well. In above case, for 0th Node, with 0 edges, we get sum = value of Node => 1. Hope this helps."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Description and constraints are misleading."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "Should be an easy question"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "can anyone tell whats wrong in the approach and code:  `class Solution {\\nprivate:\\n    void dfs(vector<vector<int>>&adj,vector<int> &visited,vector<int>& vals,int &k,int &node,int &sum,int &count,int &maxsum){\\n        if(count-1<k){\\n            visited[node]=1;\\n            count++;\\n            sum+=vals[node];\\n            for(auto i:adj[node]){\\n                if(!visited[i]){\\n                    maxsum=max(sum,maxsum);\\n                     dfs(adj,visited,vals,k,i,sum,count,maxsum); \\n                                    \\n                }\\n            }\\n        count--;\\n        sum-=vals[node];\\n        }\\n       \\n    }\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int> visited(n,0);\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n\\n        }\\n        int maxsum=0;\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            int count=0;\\n            if(!visited[i]){\\n                dfs(adj,visited,vals,k,i,sum,count,maxsum);\\n                // maxsum=max(maxsum,sum);\\n            }\\n        }\\n        return maxsum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1712067,
                "content": [
                    {
                        "username": "jainaditya8464",
                        "content": "the constraints are wrong. According to constraints, n*k =10^10, so, O(n*k) solution should not pass, but it is passing. Even worse, I haven\\'t seen a better complexity solution that O(n*k) till now. I don\\'t see how it\\'s even possible. Bad question leetcode"
                    },
                    {
                        "username": "cooper--",
                        "content": "The description is a little misleading. I am thinking to find a sub graph, which is a star graph with respect to whole graph, meaning each other node has edge to this sub graph."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "2497. Maximum Star Sum of a Graph\\n\\nHow to approach such questions"
                    },
                    {
                        "username": "TTDLC",
                        "content": "[@guptaVBS](/guptaVBS) Thanks helped a lot"
                    },
                    {
                        "username": "guptaVBS",
                        "content": "Think about what is the exact ask in the question which is to find top(descending sorted on values) 0...K neighbors for every node of the graph. \\nNow your problem is reduced to somehow store all neighbors in graph in sorted order, which can be easily done through HEAP(Priority QUEUE). Reason for choosing HEAP is because it always ensure insertion and deletion time to be logN for at max N neighbors of a Node. \\nI would recommend breaking problem into various segments instead of thinking it as a big giant one. I hope it helps :)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "depressing question"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I think the description might be a little misleading. I know it is technically correct but it would be better if the wording could be modified a little.\\n> Given an integer k, return the maximum star sum of a star graph containing at most k edges.\\n\\nThis made me think we consider only nodes having at most k edges. When it was supposed to mean we consider at most k edges.\\n\\nSo maybe it can be changed to \\n> Given an integer k, return the maximum star sum of a star graph by considering at most k of its edges.\\n\\n"
                    },
                    {
                        "username": "shardul08",
                        "content": "What is wrong with this code?\\n- Create adjacency matrix\\n- For each node, calculate the sum of star graph with at-most k neighbours using priority queue\\n- Return maximum sum\\n ```\\nint maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int res = INT_MIN;\\n        vector<vector<int>> graph(vals.size(), vector<int>());\\n        \\n        for(auto edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        for(int i=0; i<vals.size(); i++) {\\n            priority_queue<int> pq;\\n            int cur = vals[i];\\n            for(int v : graph[i]) {\\n                if(pq.size() < k)\\n                    pq.push(vals[v]);\\n                else {\\n                    if(pq.top() < vals[v]) {\\n                        pq.pop();\\n                        pq.push(vals[v]);\\n                    }\\n                }\\n            }\\n            while(pq.size()) {\\n                if(pq.top() > 0)\\n                    cur += pq.top();\\n                pq.pop();\\n            }\\n            res = max(res, cur);\\n        }\\n        \\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "vsakjrs",
                        "content": "class Solution {\\n    private:\\n    int ans=INT_MIN;\\npublic:\\n    void bfs(unordered_map<int,vector<int>> &adj,vector<int>& vals,int src,int k){\\n        priority_queue<int> pq;\\n        vector<bool> visited(vals.size(),false);\\n        queue<int> q;\\n        q.push(src);\\n        visited[src]=true;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto &x:adj[u]){\\n                if(!visited[x]){\\n                    pq.push(vals[x]);\\n                    visited[x]=true;\\n                }\\n            }\\n        }\\n        int sum=vals[src];\\n        while(!pq.empty() && k--){\\n            if(pq.top()>=0)\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        ans=max(ans,sum);\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        for(int i=0;i<vals.size();i++)\\n            bfs(adj,vals,i,k);\\n        return ans;\\n\\n    }\\n};\\n\\nThat will solve your problerm"
                    },
                    {
                        "username": "varshaSahani",
                        "content": "[@shriyansnaik](/shriyansnaik) but in question is written there at most k "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "The star graph can have more than k neighbours. You can only consider at most k of its neighbours. Even I made the same mistake. Hope it helps."
                    },
                    {
                        "username": "annubhav001",
                        "content": "WHY MIN-HEAP ACTUALLY ? [THROUGH EXAMPLE]\\n\\n1st point : If we take max-heap then, after size of max-heap exceeds k, then we need to remove the top element which is actually the largest element which actually can increase the star-graph sum of a particular node but we removed it so we won\\'t be able to get the maximum star-graph sum of any node.\\n\\n2nd point : Now if we take min-heap, when size(min-heap)>k, then we need to remove that extra element inserted which will be the element at top of min-heap which is actually the smallest element from all those others elements in min heap which can give that maximum sum of a star-graph of any node.\\n\\nSummary : Using min-heap, ensures all the largest sum elements will remain in heap at bottom so that, when we remove that extra inserted element that minimum element from all those max elements in min-heap gets popped.\\n\\nThanks\\nYou can though upvote."
                    },
                    {
                        "username": "Alex-try",
                        "content": "an example failed, but i don\\'t know why. the example is   vals =[1,-8,0]  edges =[[1,0],[2,1]]   k=2\\nmy answer is -7,the right answer is 1.\\nI think it is centered at -8 . because k=2,so i add -8 and its neighbors 1 and 0. i got the answer -7.\\ni am confused. do i misunderstanding the problem?\\n"
                    },
                    {
                        "username": "harshchy2210",
                        "content": "yes, as the max no. of neighbors you are allowed to take is k, but if you get a sum which is greater without adding some neighbors then you need not add those neighbors. Total neighbors added may be less than k, but sum ha to be maximum. "
                    },
                    {
                        "username": "mr-ashok",
                        "content": "As per the description, we can have at-most K edges. So we can consider 0 edges as well. In above case, for 0th Node, with 0 edges, we get sum = value of Node => 1. Hope this helps."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Description and constraints are misleading."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "Should be an easy question"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "can anyone tell whats wrong in the approach and code:  `class Solution {\\nprivate:\\n    void dfs(vector<vector<int>>&adj,vector<int> &visited,vector<int>& vals,int &k,int &node,int &sum,int &count,int &maxsum){\\n        if(count-1<k){\\n            visited[node]=1;\\n            count++;\\n            sum+=vals[node];\\n            for(auto i:adj[node]){\\n                if(!visited[i]){\\n                    maxsum=max(sum,maxsum);\\n                     dfs(adj,visited,vals,k,i,sum,count,maxsum); \\n                                    \\n                }\\n            }\\n        count--;\\n        sum-=vals[node];\\n        }\\n       \\n    }\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int> visited(n,0);\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n\\n        }\\n        int maxsum=0;\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            int count=0;\\n            if(!visited[i]){\\n                dfs(adj,visited,vals,k,i,sum,count,maxsum);\\n                // maxsum=max(maxsum,sum);\\n            }\\n        }\\n        return maxsum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1713397,
                "content": [
                    {
                        "username": "jainaditya8464",
                        "content": "the constraints are wrong. According to constraints, n*k =10^10, so, O(n*k) solution should not pass, but it is passing. Even worse, I haven\\'t seen a better complexity solution that O(n*k) till now. I don\\'t see how it\\'s even possible. Bad question leetcode"
                    },
                    {
                        "username": "cooper--",
                        "content": "The description is a little misleading. I am thinking to find a sub graph, which is a star graph with respect to whole graph, meaning each other node has edge to this sub graph."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "2497. Maximum Star Sum of a Graph\\n\\nHow to approach such questions"
                    },
                    {
                        "username": "TTDLC",
                        "content": "[@guptaVBS](/guptaVBS) Thanks helped a lot"
                    },
                    {
                        "username": "guptaVBS",
                        "content": "Think about what is the exact ask in the question which is to find top(descending sorted on values) 0...K neighbors for every node of the graph. \\nNow your problem is reduced to somehow store all neighbors in graph in sorted order, which can be easily done through HEAP(Priority QUEUE). Reason for choosing HEAP is because it always ensure insertion and deletion time to be logN for at max N neighbors of a Node. \\nI would recommend breaking problem into various segments instead of thinking it as a big giant one. I hope it helps :)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "depressing question"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I think the description might be a little misleading. I know it is technically correct but it would be better if the wording could be modified a little.\\n> Given an integer k, return the maximum star sum of a star graph containing at most k edges.\\n\\nThis made me think we consider only nodes having at most k edges. When it was supposed to mean we consider at most k edges.\\n\\nSo maybe it can be changed to \\n> Given an integer k, return the maximum star sum of a star graph by considering at most k of its edges.\\n\\n"
                    },
                    {
                        "username": "shardul08",
                        "content": "What is wrong with this code?\\n- Create adjacency matrix\\n- For each node, calculate the sum of star graph with at-most k neighbours using priority queue\\n- Return maximum sum\\n ```\\nint maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int res = INT_MIN;\\n        vector<vector<int>> graph(vals.size(), vector<int>());\\n        \\n        for(auto edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        for(int i=0; i<vals.size(); i++) {\\n            priority_queue<int> pq;\\n            int cur = vals[i];\\n            for(int v : graph[i]) {\\n                if(pq.size() < k)\\n                    pq.push(vals[v]);\\n                else {\\n                    if(pq.top() < vals[v]) {\\n                        pq.pop();\\n                        pq.push(vals[v]);\\n                    }\\n                }\\n            }\\n            while(pq.size()) {\\n                if(pq.top() > 0)\\n                    cur += pq.top();\\n                pq.pop();\\n            }\\n            res = max(res, cur);\\n        }\\n        \\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "vsakjrs",
                        "content": "class Solution {\\n    private:\\n    int ans=INT_MIN;\\npublic:\\n    void bfs(unordered_map<int,vector<int>> &adj,vector<int>& vals,int src,int k){\\n        priority_queue<int> pq;\\n        vector<bool> visited(vals.size(),false);\\n        queue<int> q;\\n        q.push(src);\\n        visited[src]=true;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto &x:adj[u]){\\n                if(!visited[x]){\\n                    pq.push(vals[x]);\\n                    visited[x]=true;\\n                }\\n            }\\n        }\\n        int sum=vals[src];\\n        while(!pq.empty() && k--){\\n            if(pq.top()>=0)\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        ans=max(ans,sum);\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        for(int i=0;i<vals.size();i++)\\n            bfs(adj,vals,i,k);\\n        return ans;\\n\\n    }\\n};\\n\\nThat will solve your problerm"
                    },
                    {
                        "username": "varshaSahani",
                        "content": "[@shriyansnaik](/shriyansnaik) but in question is written there at most k "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "The star graph can have more than k neighbours. You can only consider at most k of its neighbours. Even I made the same mistake. Hope it helps."
                    },
                    {
                        "username": "annubhav001",
                        "content": "WHY MIN-HEAP ACTUALLY ? [THROUGH EXAMPLE]\\n\\n1st point : If we take max-heap then, after size of max-heap exceeds k, then we need to remove the top element which is actually the largest element which actually can increase the star-graph sum of a particular node but we removed it so we won\\'t be able to get the maximum star-graph sum of any node.\\n\\n2nd point : Now if we take min-heap, when size(min-heap)>k, then we need to remove that extra element inserted which will be the element at top of min-heap which is actually the smallest element from all those others elements in min heap which can give that maximum sum of a star-graph of any node.\\n\\nSummary : Using min-heap, ensures all the largest sum elements will remain in heap at bottom so that, when we remove that extra inserted element that minimum element from all those max elements in min-heap gets popped.\\n\\nThanks\\nYou can though upvote."
                    },
                    {
                        "username": "Alex-try",
                        "content": "an example failed, but i don\\'t know why. the example is   vals =[1,-8,0]  edges =[[1,0],[2,1]]   k=2\\nmy answer is -7,the right answer is 1.\\nI think it is centered at -8 . because k=2,so i add -8 and its neighbors 1 and 0. i got the answer -7.\\ni am confused. do i misunderstanding the problem?\\n"
                    },
                    {
                        "username": "harshchy2210",
                        "content": "yes, as the max no. of neighbors you are allowed to take is k, but if you get a sum which is greater without adding some neighbors then you need not add those neighbors. Total neighbors added may be less than k, but sum ha to be maximum. "
                    },
                    {
                        "username": "mr-ashok",
                        "content": "As per the description, we can have at-most K edges. So we can consider 0 edges as well. In above case, for 0th Node, with 0 edges, we get sum = value of Node => 1. Hope this helps."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Description and constraints are misleading."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "Should be an easy question"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "can anyone tell whats wrong in the approach and code:  `class Solution {\\nprivate:\\n    void dfs(vector<vector<int>>&adj,vector<int> &visited,vector<int>& vals,int &k,int &node,int &sum,int &count,int &maxsum){\\n        if(count-1<k){\\n            visited[node]=1;\\n            count++;\\n            sum+=vals[node];\\n            for(auto i:adj[node]){\\n                if(!visited[i]){\\n                    maxsum=max(sum,maxsum);\\n                     dfs(adj,visited,vals,k,i,sum,count,maxsum); \\n                                    \\n                }\\n            }\\n        count--;\\n        sum-=vals[node];\\n        }\\n       \\n    }\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int> visited(n,0);\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n\\n        }\\n        int maxsum=0;\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            int count=0;\\n            if(!visited[i]){\\n                dfs(adj,visited,vals,k,i,sum,count,maxsum);\\n                // maxsum=max(maxsum,sum);\\n            }\\n        }\\n        return maxsum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1713285,
                "content": [
                    {
                        "username": "jainaditya8464",
                        "content": "the constraints are wrong. According to constraints, n*k =10^10, so, O(n*k) solution should not pass, but it is passing. Even worse, I haven\\'t seen a better complexity solution that O(n*k) till now. I don\\'t see how it\\'s even possible. Bad question leetcode"
                    },
                    {
                        "username": "cooper--",
                        "content": "The description is a little misleading. I am thinking to find a sub graph, which is a star graph with respect to whole graph, meaning each other node has edge to this sub graph."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "2497. Maximum Star Sum of a Graph\\n\\nHow to approach such questions"
                    },
                    {
                        "username": "TTDLC",
                        "content": "[@guptaVBS](/guptaVBS) Thanks helped a lot"
                    },
                    {
                        "username": "guptaVBS",
                        "content": "Think about what is the exact ask in the question which is to find top(descending sorted on values) 0...K neighbors for every node of the graph. \\nNow your problem is reduced to somehow store all neighbors in graph in sorted order, which can be easily done through HEAP(Priority QUEUE). Reason for choosing HEAP is because it always ensure insertion and deletion time to be logN for at max N neighbors of a Node. \\nI would recommend breaking problem into various segments instead of thinking it as a big giant one. I hope it helps :)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "depressing question"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I think the description might be a little misleading. I know it is technically correct but it would be better if the wording could be modified a little.\\n> Given an integer k, return the maximum star sum of a star graph containing at most k edges.\\n\\nThis made me think we consider only nodes having at most k edges. When it was supposed to mean we consider at most k edges.\\n\\nSo maybe it can be changed to \\n> Given an integer k, return the maximum star sum of a star graph by considering at most k of its edges.\\n\\n"
                    },
                    {
                        "username": "shardul08",
                        "content": "What is wrong with this code?\\n- Create adjacency matrix\\n- For each node, calculate the sum of star graph with at-most k neighbours using priority queue\\n- Return maximum sum\\n ```\\nint maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int res = INT_MIN;\\n        vector<vector<int>> graph(vals.size(), vector<int>());\\n        \\n        for(auto edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        for(int i=0; i<vals.size(); i++) {\\n            priority_queue<int> pq;\\n            int cur = vals[i];\\n            for(int v : graph[i]) {\\n                if(pq.size() < k)\\n                    pq.push(vals[v]);\\n                else {\\n                    if(pq.top() < vals[v]) {\\n                        pq.pop();\\n                        pq.push(vals[v]);\\n                    }\\n                }\\n            }\\n            while(pq.size()) {\\n                if(pq.top() > 0)\\n                    cur += pq.top();\\n                pq.pop();\\n            }\\n            res = max(res, cur);\\n        }\\n        \\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "vsakjrs",
                        "content": "class Solution {\\n    private:\\n    int ans=INT_MIN;\\npublic:\\n    void bfs(unordered_map<int,vector<int>> &adj,vector<int>& vals,int src,int k){\\n        priority_queue<int> pq;\\n        vector<bool> visited(vals.size(),false);\\n        queue<int> q;\\n        q.push(src);\\n        visited[src]=true;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto &x:adj[u]){\\n                if(!visited[x]){\\n                    pq.push(vals[x]);\\n                    visited[x]=true;\\n                }\\n            }\\n        }\\n        int sum=vals[src];\\n        while(!pq.empty() && k--){\\n            if(pq.top()>=0)\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        ans=max(ans,sum);\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        for(int i=0;i<vals.size();i++)\\n            bfs(adj,vals,i,k);\\n        return ans;\\n\\n    }\\n};\\n\\nThat will solve your problerm"
                    },
                    {
                        "username": "varshaSahani",
                        "content": "[@shriyansnaik](/shriyansnaik) but in question is written there at most k "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "The star graph can have more than k neighbours. You can only consider at most k of its neighbours. Even I made the same mistake. Hope it helps."
                    },
                    {
                        "username": "annubhav001",
                        "content": "WHY MIN-HEAP ACTUALLY ? [THROUGH EXAMPLE]\\n\\n1st point : If we take max-heap then, after size of max-heap exceeds k, then we need to remove the top element which is actually the largest element which actually can increase the star-graph sum of a particular node but we removed it so we won\\'t be able to get the maximum star-graph sum of any node.\\n\\n2nd point : Now if we take min-heap, when size(min-heap)>k, then we need to remove that extra element inserted which will be the element at top of min-heap which is actually the smallest element from all those others elements in min heap which can give that maximum sum of a star-graph of any node.\\n\\nSummary : Using min-heap, ensures all the largest sum elements will remain in heap at bottom so that, when we remove that extra inserted element that minimum element from all those max elements in min-heap gets popped.\\n\\nThanks\\nYou can though upvote."
                    },
                    {
                        "username": "Alex-try",
                        "content": "an example failed, but i don\\'t know why. the example is   vals =[1,-8,0]  edges =[[1,0],[2,1]]   k=2\\nmy answer is -7,the right answer is 1.\\nI think it is centered at -8 . because k=2,so i add -8 and its neighbors 1 and 0. i got the answer -7.\\ni am confused. do i misunderstanding the problem?\\n"
                    },
                    {
                        "username": "harshchy2210",
                        "content": "yes, as the max no. of neighbors you are allowed to take is k, but if you get a sum which is greater without adding some neighbors then you need not add those neighbors. Total neighbors added may be less than k, but sum ha to be maximum. "
                    },
                    {
                        "username": "mr-ashok",
                        "content": "As per the description, we can have at-most K edges. So we can consider 0 edges as well. In above case, for 0th Node, with 0 edges, we get sum = value of Node => 1. Hope this helps."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Description and constraints are misleading."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "Should be an easy question"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "can anyone tell whats wrong in the approach and code:  `class Solution {\\nprivate:\\n    void dfs(vector<vector<int>>&adj,vector<int> &visited,vector<int>& vals,int &k,int &node,int &sum,int &count,int &maxsum){\\n        if(count-1<k){\\n            visited[node]=1;\\n            count++;\\n            sum+=vals[node];\\n            for(auto i:adj[node]){\\n                if(!visited[i]){\\n                    maxsum=max(sum,maxsum);\\n                     dfs(adj,visited,vals,k,i,sum,count,maxsum); \\n                                    \\n                }\\n            }\\n        count--;\\n        sum-=vals[node];\\n        }\\n       \\n    }\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int> visited(n,0);\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n\\n        }\\n        int maxsum=0;\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            int count=0;\\n            if(!visited[i]){\\n                dfs(adj,visited,vals,k,i,sum,count,maxsum);\\n                // maxsum=max(maxsum,sum);\\n            }\\n        }\\n        return maxsum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1783788,
                "content": [
                    {
                        "username": "jainaditya8464",
                        "content": "the constraints are wrong. According to constraints, n*k =10^10, so, O(n*k) solution should not pass, but it is passing. Even worse, I haven\\'t seen a better complexity solution that O(n*k) till now. I don\\'t see how it\\'s even possible. Bad question leetcode"
                    },
                    {
                        "username": "cooper--",
                        "content": "The description is a little misleading. I am thinking to find a sub graph, which is a star graph with respect to whole graph, meaning each other node has edge to this sub graph."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "2497. Maximum Star Sum of a Graph\\n\\nHow to approach such questions"
                    },
                    {
                        "username": "TTDLC",
                        "content": "[@guptaVBS](/guptaVBS) Thanks helped a lot"
                    },
                    {
                        "username": "guptaVBS",
                        "content": "Think about what is the exact ask in the question which is to find top(descending sorted on values) 0...K neighbors for every node of the graph. \\nNow your problem is reduced to somehow store all neighbors in graph in sorted order, which can be easily done through HEAP(Priority QUEUE). Reason for choosing HEAP is because it always ensure insertion and deletion time to be logN for at max N neighbors of a Node. \\nI would recommend breaking problem into various segments instead of thinking it as a big giant one. I hope it helps :)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "depressing question"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I think the description might be a little misleading. I know it is technically correct but it would be better if the wording could be modified a little.\\n> Given an integer k, return the maximum star sum of a star graph containing at most k edges.\\n\\nThis made me think we consider only nodes having at most k edges. When it was supposed to mean we consider at most k edges.\\n\\nSo maybe it can be changed to \\n> Given an integer k, return the maximum star sum of a star graph by considering at most k of its edges.\\n\\n"
                    },
                    {
                        "username": "shardul08",
                        "content": "What is wrong with this code?\\n- Create adjacency matrix\\n- For each node, calculate the sum of star graph with at-most k neighbours using priority queue\\n- Return maximum sum\\n ```\\nint maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int res = INT_MIN;\\n        vector<vector<int>> graph(vals.size(), vector<int>());\\n        \\n        for(auto edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        for(int i=0; i<vals.size(); i++) {\\n            priority_queue<int> pq;\\n            int cur = vals[i];\\n            for(int v : graph[i]) {\\n                if(pq.size() < k)\\n                    pq.push(vals[v]);\\n                else {\\n                    if(pq.top() < vals[v]) {\\n                        pq.pop();\\n                        pq.push(vals[v]);\\n                    }\\n                }\\n            }\\n            while(pq.size()) {\\n                if(pq.top() > 0)\\n                    cur += pq.top();\\n                pq.pop();\\n            }\\n            res = max(res, cur);\\n        }\\n        \\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "vsakjrs",
                        "content": "class Solution {\\n    private:\\n    int ans=INT_MIN;\\npublic:\\n    void bfs(unordered_map<int,vector<int>> &adj,vector<int>& vals,int src,int k){\\n        priority_queue<int> pq;\\n        vector<bool> visited(vals.size(),false);\\n        queue<int> q;\\n        q.push(src);\\n        visited[src]=true;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto &x:adj[u]){\\n                if(!visited[x]){\\n                    pq.push(vals[x]);\\n                    visited[x]=true;\\n                }\\n            }\\n        }\\n        int sum=vals[src];\\n        while(!pq.empty() && k--){\\n            if(pq.top()>=0)\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        ans=max(ans,sum);\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        for(int i=0;i<vals.size();i++)\\n            bfs(adj,vals,i,k);\\n        return ans;\\n\\n    }\\n};\\n\\nThat will solve your problerm"
                    },
                    {
                        "username": "varshaSahani",
                        "content": "[@shriyansnaik](/shriyansnaik) but in question is written there at most k "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "The star graph can have more than k neighbours. You can only consider at most k of its neighbours. Even I made the same mistake. Hope it helps."
                    },
                    {
                        "username": "annubhav001",
                        "content": "WHY MIN-HEAP ACTUALLY ? [THROUGH EXAMPLE]\\n\\n1st point : If we take max-heap then, after size of max-heap exceeds k, then we need to remove the top element which is actually the largest element which actually can increase the star-graph sum of a particular node but we removed it so we won\\'t be able to get the maximum star-graph sum of any node.\\n\\n2nd point : Now if we take min-heap, when size(min-heap)>k, then we need to remove that extra element inserted which will be the element at top of min-heap which is actually the smallest element from all those others elements in min heap which can give that maximum sum of a star-graph of any node.\\n\\nSummary : Using min-heap, ensures all the largest sum elements will remain in heap at bottom so that, when we remove that extra inserted element that minimum element from all those max elements in min-heap gets popped.\\n\\nThanks\\nYou can though upvote."
                    },
                    {
                        "username": "Alex-try",
                        "content": "an example failed, but i don\\'t know why. the example is   vals =[1,-8,0]  edges =[[1,0],[2,1]]   k=2\\nmy answer is -7,the right answer is 1.\\nI think it is centered at -8 . because k=2,so i add -8 and its neighbors 1 and 0. i got the answer -7.\\ni am confused. do i misunderstanding the problem?\\n"
                    },
                    {
                        "username": "harshchy2210",
                        "content": "yes, as the max no. of neighbors you are allowed to take is k, but if you get a sum which is greater without adding some neighbors then you need not add those neighbors. Total neighbors added may be less than k, but sum ha to be maximum. "
                    },
                    {
                        "username": "mr-ashok",
                        "content": "As per the description, we can have at-most K edges. So we can consider 0 edges as well. In above case, for 0th Node, with 0 edges, we get sum = value of Node => 1. Hope this helps."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Description and constraints are misleading."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "Should be an easy question"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "can anyone tell whats wrong in the approach and code:  `class Solution {\\nprivate:\\n    void dfs(vector<vector<int>>&adj,vector<int> &visited,vector<int>& vals,int &k,int &node,int &sum,int &count,int &maxsum){\\n        if(count-1<k){\\n            visited[node]=1;\\n            count++;\\n            sum+=vals[node];\\n            for(auto i:adj[node]){\\n                if(!visited[i]){\\n                    maxsum=max(sum,maxsum);\\n                     dfs(adj,visited,vals,k,i,sum,count,maxsum); \\n                                    \\n                }\\n            }\\n        count--;\\n        sum-=vals[node];\\n        }\\n       \\n    }\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int> visited(n,0);\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n\\n        }\\n        int maxsum=0;\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            int count=0;\\n            if(!visited[i]){\\n                dfs(adj,visited,vals,k,i,sum,count,maxsum);\\n                // maxsum=max(maxsum,sum);\\n            }\\n        }\\n        return maxsum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1712550,
                "content": [
                    {
                        "username": "jainaditya8464",
                        "content": "the constraints are wrong. According to constraints, n*k =10^10, so, O(n*k) solution should not pass, but it is passing. Even worse, I haven\\'t seen a better complexity solution that O(n*k) till now. I don\\'t see how it\\'s even possible. Bad question leetcode"
                    },
                    {
                        "username": "cooper--",
                        "content": "The description is a little misleading. I am thinking to find a sub graph, which is a star graph with respect to whole graph, meaning each other node has edge to this sub graph."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "2497. Maximum Star Sum of a Graph\\n\\nHow to approach such questions"
                    },
                    {
                        "username": "TTDLC",
                        "content": "[@guptaVBS](/guptaVBS) Thanks helped a lot"
                    },
                    {
                        "username": "guptaVBS",
                        "content": "Think about what is the exact ask in the question which is to find top(descending sorted on values) 0...K neighbors for every node of the graph. \\nNow your problem is reduced to somehow store all neighbors in graph in sorted order, which can be easily done through HEAP(Priority QUEUE). Reason for choosing HEAP is because it always ensure insertion and deletion time to be logN for at max N neighbors of a Node. \\nI would recommend breaking problem into various segments instead of thinking it as a big giant one. I hope it helps :)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "depressing question"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I think the description might be a little misleading. I know it is technically correct but it would be better if the wording could be modified a little.\\n> Given an integer k, return the maximum star sum of a star graph containing at most k edges.\\n\\nThis made me think we consider only nodes having at most k edges. When it was supposed to mean we consider at most k edges.\\n\\nSo maybe it can be changed to \\n> Given an integer k, return the maximum star sum of a star graph by considering at most k of its edges.\\n\\n"
                    },
                    {
                        "username": "shardul08",
                        "content": "What is wrong with this code?\\n- Create adjacency matrix\\n- For each node, calculate the sum of star graph with at-most k neighbours using priority queue\\n- Return maximum sum\\n ```\\nint maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int res = INT_MIN;\\n        vector<vector<int>> graph(vals.size(), vector<int>());\\n        \\n        for(auto edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        for(int i=0; i<vals.size(); i++) {\\n            priority_queue<int> pq;\\n            int cur = vals[i];\\n            for(int v : graph[i]) {\\n                if(pq.size() < k)\\n                    pq.push(vals[v]);\\n                else {\\n                    if(pq.top() < vals[v]) {\\n                        pq.pop();\\n                        pq.push(vals[v]);\\n                    }\\n                }\\n            }\\n            while(pq.size()) {\\n                if(pq.top() > 0)\\n                    cur += pq.top();\\n                pq.pop();\\n            }\\n            res = max(res, cur);\\n        }\\n        \\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "vsakjrs",
                        "content": "class Solution {\\n    private:\\n    int ans=INT_MIN;\\npublic:\\n    void bfs(unordered_map<int,vector<int>> &adj,vector<int>& vals,int src,int k){\\n        priority_queue<int> pq;\\n        vector<bool> visited(vals.size(),false);\\n        queue<int> q;\\n        q.push(src);\\n        visited[src]=true;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto &x:adj[u]){\\n                if(!visited[x]){\\n                    pq.push(vals[x]);\\n                    visited[x]=true;\\n                }\\n            }\\n        }\\n        int sum=vals[src];\\n        while(!pq.empty() && k--){\\n            if(pq.top()>=0)\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        ans=max(ans,sum);\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        for(int i=0;i<vals.size();i++)\\n            bfs(adj,vals,i,k);\\n        return ans;\\n\\n    }\\n};\\n\\nThat will solve your problerm"
                    },
                    {
                        "username": "varshaSahani",
                        "content": "[@shriyansnaik](/shriyansnaik) but in question is written there at most k "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "The star graph can have more than k neighbours. You can only consider at most k of its neighbours. Even I made the same mistake. Hope it helps."
                    },
                    {
                        "username": "annubhav001",
                        "content": "WHY MIN-HEAP ACTUALLY ? [THROUGH EXAMPLE]\\n\\n1st point : If we take max-heap then, after size of max-heap exceeds k, then we need to remove the top element which is actually the largest element which actually can increase the star-graph sum of a particular node but we removed it so we won\\'t be able to get the maximum star-graph sum of any node.\\n\\n2nd point : Now if we take min-heap, when size(min-heap)>k, then we need to remove that extra element inserted which will be the element at top of min-heap which is actually the smallest element from all those others elements in min heap which can give that maximum sum of a star-graph of any node.\\n\\nSummary : Using min-heap, ensures all the largest sum elements will remain in heap at bottom so that, when we remove that extra inserted element that minimum element from all those max elements in min-heap gets popped.\\n\\nThanks\\nYou can though upvote."
                    },
                    {
                        "username": "Alex-try",
                        "content": "an example failed, but i don\\'t know why. the example is   vals =[1,-8,0]  edges =[[1,0],[2,1]]   k=2\\nmy answer is -7,the right answer is 1.\\nI think it is centered at -8 . because k=2,so i add -8 and its neighbors 1 and 0. i got the answer -7.\\ni am confused. do i misunderstanding the problem?\\n"
                    },
                    {
                        "username": "harshchy2210",
                        "content": "yes, as the max no. of neighbors you are allowed to take is k, but if you get a sum which is greater without adding some neighbors then you need not add those neighbors. Total neighbors added may be less than k, but sum ha to be maximum. "
                    },
                    {
                        "username": "mr-ashok",
                        "content": "As per the description, we can have at-most K edges. So we can consider 0 edges as well. In above case, for 0th Node, with 0 edges, we get sum = value of Node => 1. Hope this helps."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Description and constraints are misleading."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "Should be an easy question"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "can anyone tell whats wrong in the approach and code:  `class Solution {\\nprivate:\\n    void dfs(vector<vector<int>>&adj,vector<int> &visited,vector<int>& vals,int &k,int &node,int &sum,int &count,int &maxsum){\\n        if(count-1<k){\\n            visited[node]=1;\\n            count++;\\n            sum+=vals[node];\\n            for(auto i:adj[node]){\\n                if(!visited[i]){\\n                    maxsum=max(sum,maxsum);\\n                     dfs(adj,visited,vals,k,i,sum,count,maxsum); \\n                                    \\n                }\\n            }\\n        count--;\\n        sum-=vals[node];\\n        }\\n       \\n    }\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int> visited(n,0);\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n\\n        }\\n        int maxsum=0;\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            int count=0;\\n            if(!visited[i]){\\n                dfs(adj,visited,vals,k,i,sum,count,maxsum);\\n                // maxsum=max(maxsum,sum);\\n            }\\n        }\\n        return maxsum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 2014283,
                "content": [
                    {
                        "username": "jainaditya8464",
                        "content": "the constraints are wrong. According to constraints, n*k =10^10, so, O(n*k) solution should not pass, but it is passing. Even worse, I haven\\'t seen a better complexity solution that O(n*k) till now. I don\\'t see how it\\'s even possible. Bad question leetcode"
                    },
                    {
                        "username": "cooper--",
                        "content": "The description is a little misleading. I am thinking to find a sub graph, which is a star graph with respect to whole graph, meaning each other node has edge to this sub graph."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "2497. Maximum Star Sum of a Graph\\n\\nHow to approach such questions"
                    },
                    {
                        "username": "TTDLC",
                        "content": "[@guptaVBS](/guptaVBS) Thanks helped a lot"
                    },
                    {
                        "username": "guptaVBS",
                        "content": "Think about what is the exact ask in the question which is to find top(descending sorted on values) 0...K neighbors for every node of the graph. \\nNow your problem is reduced to somehow store all neighbors in graph in sorted order, which can be easily done through HEAP(Priority QUEUE). Reason for choosing HEAP is because it always ensure insertion and deletion time to be logN for at max N neighbors of a Node. \\nI would recommend breaking problem into various segments instead of thinking it as a big giant one. I hope it helps :)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "depressing question"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I think the description might be a little misleading. I know it is technically correct but it would be better if the wording could be modified a little.\\n> Given an integer k, return the maximum star sum of a star graph containing at most k edges.\\n\\nThis made me think we consider only nodes having at most k edges. When it was supposed to mean we consider at most k edges.\\n\\nSo maybe it can be changed to \\n> Given an integer k, return the maximum star sum of a star graph by considering at most k of its edges.\\n\\n"
                    },
                    {
                        "username": "shardul08",
                        "content": "What is wrong with this code?\\n- Create adjacency matrix\\n- For each node, calculate the sum of star graph with at-most k neighbours using priority queue\\n- Return maximum sum\\n ```\\nint maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int res = INT_MIN;\\n        vector<vector<int>> graph(vals.size(), vector<int>());\\n        \\n        for(auto edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        for(int i=0; i<vals.size(); i++) {\\n            priority_queue<int> pq;\\n            int cur = vals[i];\\n            for(int v : graph[i]) {\\n                if(pq.size() < k)\\n                    pq.push(vals[v]);\\n                else {\\n                    if(pq.top() < vals[v]) {\\n                        pq.pop();\\n                        pq.push(vals[v]);\\n                    }\\n                }\\n            }\\n            while(pq.size()) {\\n                if(pq.top() > 0)\\n                    cur += pq.top();\\n                pq.pop();\\n            }\\n            res = max(res, cur);\\n        }\\n        \\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "vsakjrs",
                        "content": "class Solution {\\n    private:\\n    int ans=INT_MIN;\\npublic:\\n    void bfs(unordered_map<int,vector<int>> &adj,vector<int>& vals,int src,int k){\\n        priority_queue<int> pq;\\n        vector<bool> visited(vals.size(),false);\\n        queue<int> q;\\n        q.push(src);\\n        visited[src]=true;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto &x:adj[u]){\\n                if(!visited[x]){\\n                    pq.push(vals[x]);\\n                    visited[x]=true;\\n                }\\n            }\\n        }\\n        int sum=vals[src];\\n        while(!pq.empty() && k--){\\n            if(pq.top()>=0)\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        ans=max(ans,sum);\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        for(int i=0;i<vals.size();i++)\\n            bfs(adj,vals,i,k);\\n        return ans;\\n\\n    }\\n};\\n\\nThat will solve your problerm"
                    },
                    {
                        "username": "varshaSahani",
                        "content": "[@shriyansnaik](/shriyansnaik) but in question is written there at most k "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "The star graph can have more than k neighbours. You can only consider at most k of its neighbours. Even I made the same mistake. Hope it helps."
                    },
                    {
                        "username": "annubhav001",
                        "content": "WHY MIN-HEAP ACTUALLY ? [THROUGH EXAMPLE]\\n\\n1st point : If we take max-heap then, after size of max-heap exceeds k, then we need to remove the top element which is actually the largest element which actually can increase the star-graph sum of a particular node but we removed it so we won\\'t be able to get the maximum star-graph sum of any node.\\n\\n2nd point : Now if we take min-heap, when size(min-heap)>k, then we need to remove that extra element inserted which will be the element at top of min-heap which is actually the smallest element from all those others elements in min heap which can give that maximum sum of a star-graph of any node.\\n\\nSummary : Using min-heap, ensures all the largest sum elements will remain in heap at bottom so that, when we remove that extra inserted element that minimum element from all those max elements in min-heap gets popped.\\n\\nThanks\\nYou can though upvote."
                    },
                    {
                        "username": "Alex-try",
                        "content": "an example failed, but i don\\'t know why. the example is   vals =[1,-8,0]  edges =[[1,0],[2,1]]   k=2\\nmy answer is -7,the right answer is 1.\\nI think it is centered at -8 . because k=2,so i add -8 and its neighbors 1 and 0. i got the answer -7.\\ni am confused. do i misunderstanding the problem?\\n"
                    },
                    {
                        "username": "harshchy2210",
                        "content": "yes, as the max no. of neighbors you are allowed to take is k, but if you get a sum which is greater without adding some neighbors then you need not add those neighbors. Total neighbors added may be less than k, but sum ha to be maximum. "
                    },
                    {
                        "username": "mr-ashok",
                        "content": "As per the description, we can have at-most K edges. So we can consider 0 edges as well. In above case, for 0th Node, with 0 edges, we get sum = value of Node => 1. Hope this helps."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Description and constraints are misleading."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "Should be an easy question"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "can anyone tell whats wrong in the approach and code:  `class Solution {\\nprivate:\\n    void dfs(vector<vector<int>>&adj,vector<int> &visited,vector<int>& vals,int &k,int &node,int &sum,int &count,int &maxsum){\\n        if(count-1<k){\\n            visited[node]=1;\\n            count++;\\n            sum+=vals[node];\\n            for(auto i:adj[node]){\\n                if(!visited[i]){\\n                    maxsum=max(sum,maxsum);\\n                     dfs(adj,visited,vals,k,i,sum,count,maxsum); \\n                                    \\n                }\\n            }\\n        count--;\\n        sum-=vals[node];\\n        }\\n       \\n    }\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int> visited(n,0);\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n\\n        }\\n        int maxsum=0;\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            int count=0;\\n            if(!visited[i]){\\n                dfs(adj,visited,vals,k,i,sum,count,maxsum);\\n                // maxsum=max(maxsum,sum);\\n            }\\n        }\\n        return maxsum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1981745,
                "content": [
                    {
                        "username": "jainaditya8464",
                        "content": "the constraints are wrong. According to constraints, n*k =10^10, so, O(n*k) solution should not pass, but it is passing. Even worse, I haven\\'t seen a better complexity solution that O(n*k) till now. I don\\'t see how it\\'s even possible. Bad question leetcode"
                    },
                    {
                        "username": "cooper--",
                        "content": "The description is a little misleading. I am thinking to find a sub graph, which is a star graph with respect to whole graph, meaning each other node has edge to this sub graph."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "2497. Maximum Star Sum of a Graph\\n\\nHow to approach such questions"
                    },
                    {
                        "username": "TTDLC",
                        "content": "[@guptaVBS](/guptaVBS) Thanks helped a lot"
                    },
                    {
                        "username": "guptaVBS",
                        "content": "Think about what is the exact ask in the question which is to find top(descending sorted on values) 0...K neighbors for every node of the graph. \\nNow your problem is reduced to somehow store all neighbors in graph in sorted order, which can be easily done through HEAP(Priority QUEUE). Reason for choosing HEAP is because it always ensure insertion and deletion time to be logN for at max N neighbors of a Node. \\nI would recommend breaking problem into various segments instead of thinking it as a big giant one. I hope it helps :)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "depressing question"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I think the description might be a little misleading. I know it is technically correct but it would be better if the wording could be modified a little.\\n> Given an integer k, return the maximum star sum of a star graph containing at most k edges.\\n\\nThis made me think we consider only nodes having at most k edges. When it was supposed to mean we consider at most k edges.\\n\\nSo maybe it can be changed to \\n> Given an integer k, return the maximum star sum of a star graph by considering at most k of its edges.\\n\\n"
                    },
                    {
                        "username": "shardul08",
                        "content": "What is wrong with this code?\\n- Create adjacency matrix\\n- For each node, calculate the sum of star graph with at-most k neighbours using priority queue\\n- Return maximum sum\\n ```\\nint maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int res = INT_MIN;\\n        vector<vector<int>> graph(vals.size(), vector<int>());\\n        \\n        for(auto edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        for(int i=0; i<vals.size(); i++) {\\n            priority_queue<int> pq;\\n            int cur = vals[i];\\n            for(int v : graph[i]) {\\n                if(pq.size() < k)\\n                    pq.push(vals[v]);\\n                else {\\n                    if(pq.top() < vals[v]) {\\n                        pq.pop();\\n                        pq.push(vals[v]);\\n                    }\\n                }\\n            }\\n            while(pq.size()) {\\n                if(pq.top() > 0)\\n                    cur += pq.top();\\n                pq.pop();\\n            }\\n            res = max(res, cur);\\n        }\\n        \\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "vsakjrs",
                        "content": "class Solution {\\n    private:\\n    int ans=INT_MIN;\\npublic:\\n    void bfs(unordered_map<int,vector<int>> &adj,vector<int>& vals,int src,int k){\\n        priority_queue<int> pq;\\n        vector<bool> visited(vals.size(),false);\\n        queue<int> q;\\n        q.push(src);\\n        visited[src]=true;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto &x:adj[u]){\\n                if(!visited[x]){\\n                    pq.push(vals[x]);\\n                    visited[x]=true;\\n                }\\n            }\\n        }\\n        int sum=vals[src];\\n        while(!pq.empty() && k--){\\n            if(pq.top()>=0)\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        ans=max(ans,sum);\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        for(int i=0;i<vals.size();i++)\\n            bfs(adj,vals,i,k);\\n        return ans;\\n\\n    }\\n};\\n\\nThat will solve your problerm"
                    },
                    {
                        "username": "varshaSahani",
                        "content": "[@shriyansnaik](/shriyansnaik) but in question is written there at most k "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "The star graph can have more than k neighbours. You can only consider at most k of its neighbours. Even I made the same mistake. Hope it helps."
                    },
                    {
                        "username": "annubhav001",
                        "content": "WHY MIN-HEAP ACTUALLY ? [THROUGH EXAMPLE]\\n\\n1st point : If we take max-heap then, after size of max-heap exceeds k, then we need to remove the top element which is actually the largest element which actually can increase the star-graph sum of a particular node but we removed it so we won\\'t be able to get the maximum star-graph sum of any node.\\n\\n2nd point : Now if we take min-heap, when size(min-heap)>k, then we need to remove that extra element inserted which will be the element at top of min-heap which is actually the smallest element from all those others elements in min heap which can give that maximum sum of a star-graph of any node.\\n\\nSummary : Using min-heap, ensures all the largest sum elements will remain in heap at bottom so that, when we remove that extra inserted element that minimum element from all those max elements in min-heap gets popped.\\n\\nThanks\\nYou can though upvote."
                    },
                    {
                        "username": "Alex-try",
                        "content": "an example failed, but i don\\'t know why. the example is   vals =[1,-8,0]  edges =[[1,0],[2,1]]   k=2\\nmy answer is -7,the right answer is 1.\\nI think it is centered at -8 . because k=2,so i add -8 and its neighbors 1 and 0. i got the answer -7.\\ni am confused. do i misunderstanding the problem?\\n"
                    },
                    {
                        "username": "harshchy2210",
                        "content": "yes, as the max no. of neighbors you are allowed to take is k, but if you get a sum which is greater without adding some neighbors then you need not add those neighbors. Total neighbors added may be less than k, but sum ha to be maximum. "
                    },
                    {
                        "username": "mr-ashok",
                        "content": "As per the description, we can have at-most K edges. So we can consider 0 edges as well. In above case, for 0th Node, with 0 edges, we get sum = value of Node => 1. Hope this helps."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Description and constraints are misleading."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "Should be an easy question"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "can anyone tell whats wrong in the approach and code:  `class Solution {\\nprivate:\\n    void dfs(vector<vector<int>>&adj,vector<int> &visited,vector<int>& vals,int &k,int &node,int &sum,int &count,int &maxsum){\\n        if(count-1<k){\\n            visited[node]=1;\\n            count++;\\n            sum+=vals[node];\\n            for(auto i:adj[node]){\\n                if(!visited[i]){\\n                    maxsum=max(sum,maxsum);\\n                     dfs(adj,visited,vals,k,i,sum,count,maxsum); \\n                                    \\n                }\\n            }\\n        count--;\\n        sum-=vals[node];\\n        }\\n       \\n    }\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int> visited(n,0);\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n\\n        }\\n        int maxsum=0;\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            int count=0;\\n            if(!visited[i]){\\n                dfs(adj,visited,vals,k,i,sum,count,maxsum);\\n                // maxsum=max(maxsum,sum);\\n            }\\n        }\\n        return maxsum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1847738,
                "content": [
                    {
                        "username": "jainaditya8464",
                        "content": "the constraints are wrong. According to constraints, n*k =10^10, so, O(n*k) solution should not pass, but it is passing. Even worse, I haven\\'t seen a better complexity solution that O(n*k) till now. I don\\'t see how it\\'s even possible. Bad question leetcode"
                    },
                    {
                        "username": "cooper--",
                        "content": "The description is a little misleading. I am thinking to find a sub graph, which is a star graph with respect to whole graph, meaning each other node has edge to this sub graph."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "2497. Maximum Star Sum of a Graph\\n\\nHow to approach such questions"
                    },
                    {
                        "username": "TTDLC",
                        "content": "[@guptaVBS](/guptaVBS) Thanks helped a lot"
                    },
                    {
                        "username": "guptaVBS",
                        "content": "Think about what is the exact ask in the question which is to find top(descending sorted on values) 0...K neighbors for every node of the graph. \\nNow your problem is reduced to somehow store all neighbors in graph in sorted order, which can be easily done through HEAP(Priority QUEUE). Reason for choosing HEAP is because it always ensure insertion and deletion time to be logN for at max N neighbors of a Node. \\nI would recommend breaking problem into various segments instead of thinking it as a big giant one. I hope it helps :)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "depressing question"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I think the description might be a little misleading. I know it is technically correct but it would be better if the wording could be modified a little.\\n> Given an integer k, return the maximum star sum of a star graph containing at most k edges.\\n\\nThis made me think we consider only nodes having at most k edges. When it was supposed to mean we consider at most k edges.\\n\\nSo maybe it can be changed to \\n> Given an integer k, return the maximum star sum of a star graph by considering at most k of its edges.\\n\\n"
                    },
                    {
                        "username": "shardul08",
                        "content": "What is wrong with this code?\\n- Create adjacency matrix\\n- For each node, calculate the sum of star graph with at-most k neighbours using priority queue\\n- Return maximum sum\\n ```\\nint maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int res = INT_MIN;\\n        vector<vector<int>> graph(vals.size(), vector<int>());\\n        \\n        for(auto edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        for(int i=0; i<vals.size(); i++) {\\n            priority_queue<int> pq;\\n            int cur = vals[i];\\n            for(int v : graph[i]) {\\n                if(pq.size() < k)\\n                    pq.push(vals[v]);\\n                else {\\n                    if(pq.top() < vals[v]) {\\n                        pq.pop();\\n                        pq.push(vals[v]);\\n                    }\\n                }\\n            }\\n            while(pq.size()) {\\n                if(pq.top() > 0)\\n                    cur += pq.top();\\n                pq.pop();\\n            }\\n            res = max(res, cur);\\n        }\\n        \\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "vsakjrs",
                        "content": "class Solution {\\n    private:\\n    int ans=INT_MIN;\\npublic:\\n    void bfs(unordered_map<int,vector<int>> &adj,vector<int>& vals,int src,int k){\\n        priority_queue<int> pq;\\n        vector<bool> visited(vals.size(),false);\\n        queue<int> q;\\n        q.push(src);\\n        visited[src]=true;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto &x:adj[u]){\\n                if(!visited[x]){\\n                    pq.push(vals[x]);\\n                    visited[x]=true;\\n                }\\n            }\\n        }\\n        int sum=vals[src];\\n        while(!pq.empty() && k--){\\n            if(pq.top()>=0)\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        ans=max(ans,sum);\\n    }\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        for(int i=0;i<vals.size();i++)\\n            bfs(adj,vals,i,k);\\n        return ans;\\n\\n    }\\n};\\n\\nThat will solve your problerm"
                    },
                    {
                        "username": "varshaSahani",
                        "content": "[@shriyansnaik](/shriyansnaik) but in question is written there at most k "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "The star graph can have more than k neighbours. You can only consider at most k of its neighbours. Even I made the same mistake. Hope it helps."
                    },
                    {
                        "username": "annubhav001",
                        "content": "WHY MIN-HEAP ACTUALLY ? [THROUGH EXAMPLE]\\n\\n1st point : If we take max-heap then, after size of max-heap exceeds k, then we need to remove the top element which is actually the largest element which actually can increase the star-graph sum of a particular node but we removed it so we won\\'t be able to get the maximum star-graph sum of any node.\\n\\n2nd point : Now if we take min-heap, when size(min-heap)>k, then we need to remove that extra element inserted which will be the element at top of min-heap which is actually the smallest element from all those others elements in min heap which can give that maximum sum of a star-graph of any node.\\n\\nSummary : Using min-heap, ensures all the largest sum elements will remain in heap at bottom so that, when we remove that extra inserted element that minimum element from all those max elements in min-heap gets popped.\\n\\nThanks\\nYou can though upvote."
                    },
                    {
                        "username": "Alex-try",
                        "content": "an example failed, but i don\\'t know why. the example is   vals =[1,-8,0]  edges =[[1,0],[2,1]]   k=2\\nmy answer is -7,the right answer is 1.\\nI think it is centered at -8 . because k=2,so i add -8 and its neighbors 1 and 0. i got the answer -7.\\ni am confused. do i misunderstanding the problem?\\n"
                    },
                    {
                        "username": "harshchy2210",
                        "content": "yes, as the max no. of neighbors you are allowed to take is k, but if you get a sum which is greater without adding some neighbors then you need not add those neighbors. Total neighbors added may be less than k, but sum ha to be maximum. "
                    },
                    {
                        "username": "mr-ashok",
                        "content": "As per the description, we can have at-most K edges. So we can consider 0 edges as well. In above case, for 0th Node, with 0 edges, we get sum = value of Node => 1. Hope this helps."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Description and constraints are misleading."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "Should be an easy question"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "can anyone tell whats wrong in the approach and code:  `class Solution {\\nprivate:\\n    void dfs(vector<vector<int>>&adj,vector<int> &visited,vector<int>& vals,int &k,int &node,int &sum,int &count,int &maxsum){\\n        if(count-1<k){\\n            visited[node]=1;\\n            count++;\\n            sum+=vals[node];\\n            for(auto i:adj[node]){\\n                if(!visited[i]){\\n                    maxsum=max(sum,maxsum);\\n                     dfs(adj,visited,vals,k,i,sum,count,maxsum); \\n                                    \\n                }\\n            }\\n        count--;\\n        sum-=vals[node];\\n        }\\n       \\n    }\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\\n        int n=vals.size();\\n        vector<int> visited(n,0);\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n\\n        }\\n        int maxsum=0;\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            int count=0;\\n            if(!visited[i]){\\n                dfs(adj,visited,vals,k,i,sum,count,maxsum);\\n                // maxsum=max(maxsum,sum);\\n            }\\n        }\\n        return maxsum;\\n    }\\n};`"
                    }
                ]
            }
        ]
    }
]