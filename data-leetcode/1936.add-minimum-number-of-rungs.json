[
    {
        "title": "Merge BSTs to Create Single BST",
        "question_content": "You are given n BST (binary search tree) root nodes for n separate BSTs stored in an array trees (0-indexed). Each BST in trees has at most 3 nodes, and no two roots have the same value. In one operation, you can:\n\n\tSelect two distinct indices i and j such that the value stored at one of the leaves of trees[i] is equal to the root value of trees[j].\n\tReplace the leaf node in trees[i] with trees[j].\n\tRemove trees[j] from trees.\n\nReturn the root of the resulting BST if it is possible to form a valid BST after performing n - 1 operations, or null if it is impossible to create a valid BST.\nA BST (binary search tree) is a binary tree where each node satisfies the following property:\n\n\tEvery node in the node's left subtree has a value&nbsp;strictly less&nbsp;than the node's value.\n\tEvery node in the node's right subtree has a value&nbsp;strictly greater&nbsp;than the node's value.\n\nA leaf is a node that has no children.\n&nbsp;\nExample 1:\n\nInput: trees = [[2,1],[3,2,5],[5,4]]\nOutput: [3,2,5,1,null,4]\nExplanation:\nIn the first operation, pick i=1 and j=0, and merge trees[0] into trees[1].\nDelete trees[0], so trees = [[3,2,5,1],[5,4]].\nIn the second operation, pick i=0 and j=1, and merge trees[1] into trees[0].\nDelete trees[1], so trees = [[3,2,5,1,null,4]].\nThe resulting tree, shown above, is a valid BST, so return its root.\nExample 2:\n\nInput: trees = [[5,3,8],[3,2,6]]\nOutput: []\nExplanation:\nPick i=0 and j=1 and merge trees[1] into trees[0].\nDelete trees[1], so trees = [[5,3,8,2,6]].\nThe resulting tree is shown above. This is the only valid operation that can be performed, but the resulting tree is not a valid BST, so return null.\n\nExample 3:\n\nInput: trees = [[5,4],[3]]\nOutput: []\nExplanation: It is impossible to perform any operations.\n\n&nbsp;\nConstraints:\n\n\tn == trees.length\n\t1 <= n <= 5 * 104\n\tThe number of nodes in each tree is in the range [1, 3].\n\tEach node in the input may have children but no grandchildren.\n\tNo two roots of trees have the same value.\n\tAll the trees in the input are valid BSTs.\n\t1 <= TreeNode.val <= 5 * 104.",
        "solutions": [
            {
                "id": 1330387,
                "title": "just-do-what-it-says",
                "content": "Not a hard problem - just long and a bit frustrating. I failed the hidden test case when we have only one tree...\\n\\n> Update: see an alternative below that combines trees in an arbitrary order.\\n\\n#### Approach 1: Build from root\\nThis solution identifies the topmost root, and then traverses from it, joining leaves with matching roots.\\n\\n1. Populate a hashmap {value: root} . All root values are guaranteed to be unique.\\n2. Count values among all trees.\\n3. Identify a root of the combined tree; it\\'s value must be counted only once.\\n4. Traverse from the root:\\n\\t- Check BST validity, like in [98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/).\\n\\t- Join leaves with roots, matching leaf and root value using the map.\\n5. If the combined tree is valid, and it includes all roots - return the root of the combined tree.\\n\\n**C++**\\n```cpp\\nbool traverse(TreeNode* r, unordered_map<int, TreeNode*> &m, int min_left = INT_MIN, int max_right = INT_MAX) {\\n    if (r == nullptr) \\n        return true;\\n    if (r->val <= min_left || r->val >= max_right)\\n        return false;\\n    if (r->left == r->right) {\\n        auto it = m.find(r->val);\\n        if (it != end(m) && r != it->second) {\\n            r->left = it->second->left;\\n            r->right = it->second->right;\\n            m.erase(it);\\n        }\\n    }\\n    return traverse(r->left, m, min_left, r->val) && traverse(r->right, m, r->val, max_right);\\n}    \\nTreeNode* canMerge(vector<TreeNode*>& trees) {\\n    unordered_map<int, TreeNode*> m;\\n    unordered_map<int, int> cnt;\\n    for (auto &t : trees) {\\n        m[t->val] = t;\\n        ++cnt[t->val];\\n        ++cnt[t->left ? t->left->val : 0];\\n        ++cnt[t->right ? t->right->val : 0];\\n    }\\n    for (auto &t : trees)\\n        if (cnt[t->val] == 1)\\n            return traverse(t, m) && m.size() == 1 ? t : nullptr;\\n    return nullptr;\\n}\\n```\\n\\n#### Approach 2: Join all leaves\\nAs before, we map values to tree roots. Then, we collect *all* leaves that have a matching root.\\n\\nFinally, we combine leaves with matching roots, removing those roots from the map. In the end, one root (of the entire tree) should remain in the map.\\n\\nOne caveat here is that we need to make sure that the final tree includes all nodes. Because we combine trees in no specific order, we can have another disconnected tree with a loop.\\n\\n**C++**\\n```cpp\\nunordered_set<int> unique_vals;\\nunordered_map<int, TreeNode*> roots;\\nvector<TreeNode*> leaves;\\nvoid addLeaf(TreeNode* r) {\\n    if (r != nullptr) {\\n        unique_vals.insert(r->val);\\n        if (roots.count(r->val))\\n            leaves.push_back(r);    \\n    }\\n}    \\nint validNodes(TreeNode* r, int min_left = INT_MIN, int max_right = INT_MAX) {\\n    if (r == nullptr || r->val <= min_left || r->val >= max_right) \\n        return 0;\\n    return 1 + validNodes(r->left, min_left, r->val) + validNodes(r->right, r->val, max_right);\\n} \\nTreeNode* canMerge(vector<TreeNode*>& trees) {\\n    for (auto &t : trees)\\n        roots[t->val] = t;\\n    for (auto &t : trees) {\\n        unique_vals.insert(t->val);\\n        addLeaf(t->left);\\n        addLeaf(t->right);\\n    }\\n    for (auto leaf : leaves) {\\n        auto it = roots.find(leaf->val);\\n        if (it == end(roots)) \\n            return nullptr;\\n        leaf->left = it->second->left;\\n        leaf->right = it->second->right;\\n        roots.erase(it);\\n    }\\n    return roots.size() == 1 && validNodes(begin(roots)->second) == unique_vals.size() ? begin(roots)->second : nullptr;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool traverse(TreeNode* r, unordered_map<int, TreeNode*> &m, int min_left = INT_MIN, int max_right = INT_MAX) {\\n    if (r == nullptr) \\n        return true;\\n    if (r->val <= min_left || r->val >= max_right)\\n        return false;\\n    if (r->left == r->right) {\\n        auto it = m.find(r->val);\\n        if (it != end(m) && r != it->second) {\\n            r->left = it->second->left;\\n            r->right = it->second->right;\\n            m.erase(it);\\n        }\\n    }\\n    return traverse(r->left, m, min_left, r->val) && traverse(r->right, m, r->val, max_right);\\n}    \\nTreeNode* canMerge(vector<TreeNode*>& trees) {\\n    unordered_map<int, TreeNode*> m;\\n    unordered_map<int, int> cnt;\\n    for (auto &t : trees) {\\n        m[t->val] = t;\\n        ++cnt[t->val];\\n        ++cnt[t->left ? t->left->val : 0];\\n        ++cnt[t->right ? t->right->val : 0];\\n    }\\n    for (auto &t : trees)\\n        if (cnt[t->val] == 1)\\n            return traverse(t, m) && m.size() == 1 ? t : nullptr;\\n    return nullptr;\\n}\\n```\n```cpp\\nunordered_set<int> unique_vals;\\nunordered_map<int, TreeNode*> roots;\\nvector<TreeNode*> leaves;\\nvoid addLeaf(TreeNode* r) {\\n    if (r != nullptr) {\\n        unique_vals.insert(r->val);\\n        if (roots.count(r->val))\\n            leaves.push_back(r);    \\n    }\\n}    \\nint validNodes(TreeNode* r, int min_left = INT_MIN, int max_right = INT_MAX) {\\n    if (r == nullptr || r->val <= min_left || r->val >= max_right) \\n        return 0;\\n    return 1 + validNodes(r->left, min_left, r->val) + validNodes(r->right, r->val, max_right);\\n} \\nTreeNode* canMerge(vector<TreeNode*>& trees) {\\n    for (auto &t : trees)\\n        roots[t->val] = t;\\n    for (auto &t : trees) {\\n        unique_vals.insert(t->val);\\n        addLeaf(t->left);\\n        addLeaf(t->right);\\n    }\\n    for (auto leaf : leaves) {\\n        auto it = roots.find(leaf->val);\\n        if (it == end(roots)) \\n            return nullptr;\\n        leaf->left = it->second->left;\\n        leaf->right = it->second->right;\\n        roots.erase(it);\\n    }\\n    return roots.size() == 1 && validNodes(begin(roots)->second) == unique_vals.size() ? begin(roots)->second : nullptr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1330156,
                "title": "python-clean-in-order-traversal-solution-o-n-o-n",
                "content": "**Idea**\\n\\nWhen asked to validate BST, we naturally think about in-order traversal ([98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)). The question is how to do in-order traversal when we are given many separate trees.\\n\\nFirst of all, we want to find a root node to start the traversal from, and we can do so by finding the node without any incoming edge (`indeg = 0`). If there\\'s zero or more than one roots, we cannot create a single BST.\\n\\nTo traverse through nodes, we need to go from one BST to another. We achieve this with the help of a value-to-node map (`nodes`).\\n\\nThere are also two edges cases we need to check:\\n* There is no cycle\\n* We traverse through all nodes\\n\\nPlease see code below for more details =)\\n\\n</br>\\n\\n**Complexity**\\n\\n- Time complexity: `O(N)`\\n- Space complexity: `O(N)`\\n\\n</br>\\n\\n**Python**\\n\\n```Python\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        nodes = {}\\n        indeg = collections.defaultdict(int)\\n        for t in trees:\\n            if t.val not in indeg:\\n                indeg[t.val] = 0\\n            if t.left:\\n                indeg[t.left.val] += 1\\n                if t.left.val not in nodes: nodes[t.left.val] = t.left\\n            if t.right:\\n                indeg[t.right.val] += 1\\n                if t.right.val not in nodes: nodes[t.right.val] = t.right\\n            nodes[t.val] = t\\n            \\n        # check single root\\n        sources = [k for k, v in indeg.items() if v == 0]\\n        if len(sources) != 1: return None\\n        \\n        self.cur = float(\\'-inf\\')\\n        self.is_invalid = False\\n        seen = set()\\n        def inorder(val):\\n            # check cycle\\n            if val in seen:\\n                self.is_invalid = True\\n                return\\n            seen.add(val)\\n            node = nodes[val]\\n            if node.left: node.left = inorder(node.left.val)\\n            # check inorder increasing\\n            if val <= self.cur:\\n                self.is_invalid = True\\n                return\\n            self.cur = val\\n            if node.right: node.right = inorder(node.right.val)\\n            return node\\n        \\n        root = inorder(sources[0])\\n        # check full traversal\\n        if len(seen) != len(nodes) or self.is_invalid:\\n            return None\\n        return root\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        nodes = {}\\n        indeg = collections.defaultdict(int)\\n        for t in trees:\\n            if t.val not in indeg:\\n                indeg[t.val] = 0\\n            if t.left:\\n                indeg[t.left.val] += 1\\n                if t.left.val not in nodes: nodes[t.left.val] = t.left\\n            if t.right:\\n                indeg[t.right.val] += 1\\n                if t.right.val not in nodes: nodes[t.right.val] = t.right\\n            nodes[t.val] = t\\n            \\n        # check single root\\n        sources = [k for k, v in indeg.items() if v == 0]\\n        if len(sources) != 1: return None\\n        \\n        self.cur = float(\\'-inf\\')\\n        self.is_invalid = False\\n        seen = set()\\n        def inorder(val):\\n            # check cycle\\n            if val in seen:\\n                self.is_invalid = True\\n                return\\n            seen.add(val)\\n            node = nodes[val]\\n            if node.left: node.left = inorder(node.left.val)\\n            # check inorder increasing\\n            if val <= self.cur:\\n                self.is_invalid = True\\n                return\\n            self.cur = val\\n            if node.right: node.right = inorder(node.right.val)\\n            return node\\n        \\n        root = inorder(sources[0])\\n        # check full traversal\\n        if len(seen) != len(nodes) or self.is_invalid:\\n            return None\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486253,
                "title": "java-easy-to-understand",
                "content": "```\\npublic TreeNode canMerge(List<TreeNode> trees) {\\n        //Collect the leaves\\n        Set<Integer> leaves = new HashSet();\\n         Map<Integer, TreeNode> map = new HashMap<>(); \\n        for(TreeNode tree : trees) {\\n             map.put(tree.val, tree);\\n            if(tree.left != null) {\\n                leaves.add(tree.left.val);\\n            }\\n            if(tree.right != null) {\\n                leaves.add(tree.right.val);\\n            }\\n        }\\n        \\n        //Decide the root of the resulting tree\\n        TreeNode result = null;\\n        for(TreeNode tree : trees) {\\n            if(!leaves.contains(tree.val) ) {\\n                result = tree;\\n                break;\\n            }\\n        }\\n        if(result == null) {\\n            return null;\\n        }\\n        \\n        return traverse(result, map, Integer.MIN_VALUE, Integer.MAX_VALUE) && map.size() == 1 ? result : null;\\n    }\\n    \\n    private boolean traverse(TreeNode root, Map<Integer, TreeNode> map, int min, int max) {\\n        if(root == null) return true;\\n        if(root.val <= min || root.val >= max) return false;\\n        \\n        if(root.left == null && root.right == null) {\\n            if(map.containsKey(root.val) && root != map.get(root.val)) {\\n                TreeNode next = map.get(root.val);\\n                root.left = next.left;\\n                root.right = next.right;\\n                map.remove(root.val);\\n            }\\n        }\\n        return traverse(root.left, map, min, root.val) && traverse(root.right, map, root.val, max);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic TreeNode canMerge(List<TreeNode> trees) {\\n        //Collect the leaves\\n        Set<Integer> leaves = new HashSet();\\n         Map<Integer, TreeNode> map = new HashMap<>(); \\n        for(TreeNode tree : trees) {\\n             map.put(tree.val, tree);\\n            if(tree.left != null) {\\n                leaves.add(tree.left.val);\\n            }\\n            if(tree.right != null) {\\n                leaves.add(tree.right.val);\\n            }\\n        }\\n        \\n        //Decide the root of the resulting tree\\n        TreeNode result = null;\\n        for(TreeNode tree : trees) {\\n            if(!leaves.contains(tree.val) ) {\\n                result = tree;\\n                break;\\n            }\\n        }\\n        if(result == null) {\\n            return null;\\n        }\\n        \\n        return traverse(result, map, Integer.MIN_VALUE, Integer.MAX_VALUE) && map.size() == 1 ? result : null;\\n    }\\n    \\n    private boolean traverse(TreeNode root, Map<Integer, TreeNode> map, int min, int max) {\\n        if(root == null) return true;\\n        if(root.val <= min || root.val >= max) return false;\\n        \\n        if(root.left == null && root.right == null) {\\n            if(map.containsKey(root.val) && root != map.get(root.val)) {\\n                TreeNode next = map.get(root.val);\\n                root.left = next.left;\\n                root.right = next.right;\\n                map.remove(root.val);\\n            }\\n        }\\n        return traverse(root.left, map, min, root.val) && traverse(root.right, map, root.val, max);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1330145,
                "title": "python3-bfs-with-comments",
                "content": "```\\n# problem is pretty straightforward (as for hard one), but with different edge cases\\n#\\n# algo:\\n#   1. find the result tree root:\\n#       1.1. root should have a value that\\'s not in leaf of any subtree\\n#       1.2. there should be exactly one root\\n#   2. map all input subtrees to their root values, so we can find a subtree by value in constant time\\n#   3. run bfs (or dfs) from the result tree root (we found on step 1):\\n#       3.1. to build the result tree\\n#       3.2. with keeping left and right bounds, so we can check every node if it fits the BST\\n#       3.3. also with deleting all subtrees that have been used\\n#   4. return result tree if all subtrees have been used and all nodes fits the BST\\n\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        leaf_values = set()\\n        root_by_value = {}\\n        \\n        for node in trees:                       # collect leaf values and fill \"root_by_value\" dict\\n            if node.left:\\n                leaf_values.add(node.left.val)\\n            if node.right:\\n                leaf_values.add(node.right.val)\\n            root_by_value[node.val] = node\\n            \\n        root = None\\n        for node in trees:\\n            if node.val not in leaf_values:\\n                if root is None:\\n                    root = node\\n                else:                           # we found more than one root, so return None\\n                    return None\\n\\n        if root is None:                        # the result tree root is not found, so return None\\n            return None\\n        \\n        del root_by_value[root.val]                     # the tree is used so delete \\n        queue = deque([(root, -math.inf, math.inf)])    # (current_node, left_bound, right_bound)\\n        while queue:                                    # standard iterative BFS with using queue\\n            node, left, right = queue.popleft()\\n            if not (left < node.val < right):           # check if node fits BST\\n                return None\\n\\n            if node.left:\\n                if node.left.val in root_by_value:               # if leaf value is root of some subtree\\n                    node.left = root_by_value[node.left.val]     # reassign leaf\\n                    del root_by_value[node.left.val]             # and delete subtree as used\\n                queue.append((node.left, left, node.val))        # add leaf to BFS\\n\\n            if node.right:\\n                if node.right.val in root_by_value:\\n                    node.right = root_by_value[node.right.val]\\n                    del root_by_value[node.right.val]\\n                queue.append((node.right, node.val, right))\\n\\n        return root if not root_by_value else None      # if no subtrees left, return the result tree\\n            \\n```",
                "solutionTags": [],
                "code": "```\\n# problem is pretty straightforward (as for hard one), but with different edge cases\\n#\\n# algo:\\n#   1. find the result tree root:\\n#       1.1. root should have a value that\\'s not in leaf of any subtree\\n#       1.2. there should be exactly one root\\n#   2. map all input subtrees to their root values, so we can find a subtree by value in constant time\\n#   3. run bfs (or dfs) from the result tree root (we found on step 1):\\n#       3.1. to build the result tree\\n#       3.2. with keeping left and right bounds, so we can check every node if it fits the BST\\n#       3.3. also with deleting all subtrees that have been used\\n#   4. return result tree if all subtrees have been used and all nodes fits the BST\\n\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        leaf_values = set()\\n        root_by_value = {}\\n        \\n        for node in trees:                       # collect leaf values and fill \"root_by_value\" dict\\n            if node.left:\\n                leaf_values.add(node.left.val)\\n            if node.right:\\n                leaf_values.add(node.right.val)\\n            root_by_value[node.val] = node\\n            \\n        root = None\\n        for node in trees:\\n            if node.val not in leaf_values:\\n                if root is None:\\n                    root = node\\n                else:                           # we found more than one root, so return None\\n                    return None\\n\\n        if root is None:                        # the result tree root is not found, so return None\\n            return None\\n        \\n        del root_by_value[root.val]                     # the tree is used so delete \\n        queue = deque([(root, -math.inf, math.inf)])    # (current_node, left_bound, right_bound)\\n        while queue:                                    # standard iterative BFS with using queue\\n            node, left, right = queue.popleft()\\n            if not (left < node.val < right):           # check if node fits BST\\n                return None\\n\\n            if node.left:\\n                if node.left.val in root_by_value:               # if leaf value is root of some subtree\\n                    node.left = root_by_value[node.left.val]     # reassign leaf\\n                    del root_by_value[node.left.val]             # and delete subtree as used\\n                queue.append((node.left, left, node.val))        # add leaf to BFS\\n\\n            if node.right:\\n                if node.right.val in root_by_value:\\n                    node.right = root_by_value[node.right.val]\\n                    del root_by_value[node.right.val]\\n                queue.append((node.right, node.val, right))\\n\\n        return root if not root_by_value else None      # if no subtrees left, return the result tree\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407162,
                "title": "c-simple-and-clean-solution-with-easy-detailed-explanation",
                "content": "**Explanation:**\\n1. First, for easy search and access, we map all our roots in an unordered_map roots: [value->root].\\n    We also put all leafs in a set `leaves` to be able to find our new root.\\n2. The result root will be the one which is not found in any trees leaves, because otherwise in the resulting tree there will be two nodes with the same value, and that\\'s impossible as we need each node to be strictly greater/less than parent.\\nSo `getRoot` function checks which root doesn\\'t appear in the leaves set.\\nThen we can remove the new root from the roots map.\\n3. Now, all we have to do is recursively find leaves that are in the roots node and merge trees.\\n\\tWe create a `tmp` node to keep the current node.\\n\\tIf we found a node that appears in the roots map, tmp = roots[root->val]. Otherwise, it stays `root`.\\n\\tWe can remove it from roots map and recursively do the same for left node and right node.\\n4. Last, is to check that our result is a valid BST and we used all trees given.\\n```\\nclass Solution {\\npublic:\\n    bool isBST(TreeNode* root, long top, long bottom) {\\n        if (!root) return true;\\n        if (root->val >= top || root->val <= bottom) return false; \\n        return isBST(root->left, root->val, bottom) && isBST(root->right, top, root->val);\\n    }\\n\\n    TreeNode* getTree(TreeNode* root) {\\n        if (!root) return NULL;\\n        TreeNode* tmp =  roots.count(root->val) ? roots[root->val]: root;\\n        roots.erase(root->val);\\n        root->left = getTree(tmp->left);\\n        root->right = getTree(tmp->right);\\n        return tmp;\\n    }\\n    \\n    TreeNode* getRoot(vector<TreeNode*>& trees) {\\n        for (auto root : trees) {\\n            if (!leaves.count(root->val)) return root;\\n        }\\n        return NULL;\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        for (auto root : trees) {\\n            roots[root->val] = root;\\n            if (root->left) leaves.insert(root->left->val);\\n            if (root->right) leaves.insert(root->right->val);\\n        }\\n        \\n        TreeNode* new_root = getRoot(trees);\\n        if (!new_root) return NULL;\\n        roots.erase(new_root->val);\\n        \\n        getTree(new_root);\\n        \\n        return isBST(new_root, 2147483648, -2147483649) && !roots.size() ? new_root : NULL;\\n            \\n    }\\n    \\nprivate:\\n    unordered_map<int, TreeNode*> roots;\\n    unordered_set<int> leaves;\\n};\\n```\\n**like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBST(TreeNode* root, long top, long bottom) {\\n        if (!root) return true;\\n        if (root->val >= top || root->val <= bottom) return false; \\n        return isBST(root->left, root->val, bottom) && isBST(root->right, top, root->val);\\n    }\\n\\n    TreeNode* getTree(TreeNode* root) {\\n        if (!root) return NULL;\\n        TreeNode* tmp =  roots.count(root->val) ? roots[root->val]: root;\\n        roots.erase(root->val);\\n        root->left = getTree(tmp->left);\\n        root->right = getTree(tmp->right);\\n        return tmp;\\n    }\\n    \\n    TreeNode* getRoot(vector<TreeNode*>& trees) {\\n        for (auto root : trees) {\\n            if (!leaves.count(root->val)) return root;\\n        }\\n        return NULL;\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        for (auto root : trees) {\\n            roots[root->val] = root;\\n            if (root->left) leaves.insert(root->left->val);\\n            if (root->right) leaves.insert(root->right->val);\\n        }\\n        \\n        TreeNode* new_root = getRoot(trees);\\n        if (!new_root) return NULL;\\n        roots.erase(new_root->val);\\n        \\n        getTree(new_root);\\n        \\n        return isBST(new_root, 2147483648, -2147483649) && !roots.size() ? new_root : NULL;\\n            \\n    }\\n    \\nprivate:\\n    unordered_map<int, TreeNode*> roots;\\n    unordered_set<int> leaves;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330182,
                "title": "c-using-hash-maps-commented-explained",
                "content": "* Store the leaf nodes of all  the trees in a map with its parent Node address\\n* when we find current tree node value in the map we need to merge\\n* if we dont find the current node value in map then it is the node  which we should return \\n* when we merge a current tree x to another tree y then we check - \\n* if x is left child of y and maximum node value in the x is >=  y root node value then return NULL , else merge them and change the y minimum node value to x minimum node value\\n* if x is right child of y and the minimum node value in x is <= y root node value then return NULL, else merge them and change the y maximum node value to x  maximum value\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        //store the leaves of every node\\n\\n        unordered_map<int,TreeNode*> mp;\\n        \\n        //store the current min and current max nodes in the current tree\\n        unordered_map<TreeNode*,pair<int,int>> mini;\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            pair<int,int> ans={trees[i]->val,trees[i]->val};\\n            if(trees[i]->left)\\n            {\\n                \\n                mp[trees[i]->left->val]={trees[i]};\\n                ans.first=trees[i]->left->val;\\n            }\\n            if(trees[i]->right)\\n            {\\n                mp[trees[i]->right->val]=trees[i];\\n                ans.second=trees[i]->right->val;\\n            }\\n            mini[trees[i]]=ans;\\n        }\\n        \\n        //store the number of merging operations we will be doing\\n        int count=0;\\n        int rootCount=0;\\n        TreeNode* root=NULL;\\n        //now for every node get the root\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            \\n            //if the current tree can be merged into some other tree\\n            if(mp.find(trees[i]->val)!=mp.end())\\n            {\\n                count++;\\n                //merge them\\n                TreeNode* parent=mp[trees[i]->val];\\n                if(trees[i]->val < parent->val)\\n                {\\n                    //left child \\n                    \\n                    //if the maximum of the current sub tree is greater than the parent value \\n                    //then return NULL\\n                    if(parent->val <= mini[trees[i]].second)\\n                        return NULL;\\n                    //change the minimum value of the parent tree to the current min value of the tree\\n                    mini[parent].first=mini[trees[i]].first;\\n                    //merge the trees\\n                    parent->left=trees[i];\\n                }\\n                else  if(trees[i]->val > parent->val)\\n                {\\n                    //right child\\n                    \\n                    //if the minimum of the current tree is lesser than the parent value\\n                    //we cannot merge \\n                    //so return NULL\\n                    if(parent->val >= mini[trees[i]].first)\\n                        return NULL;\\n                    \\n                    //change the parent tree maximum to the current tree maximum\\n                    mini[parent].second=mini[trees[i]].second;\\n                    //merge the trees\\n                    parent->right=trees[i];\\n                }\\n                //erase the current tree value\\n                mp.erase(trees[i]->val);\\n            }\\n            else{\\n                //it has no other tree to merge \\n                //it is the root node we should return \\n                if(rootCount==1)\\n                    return NULL;\\n                else \\n                {\\n                    rootCount++;\\n                    root=trees[i];\\n                }\\n            }\\n        }\\n        //if we are not able to merge all trees return NULL\\n        if(count!=trees.size()-1)\\n            return NULL;\\n        return root;\\n        \\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        //store the leaves of every node\\n\\n        unordered_map<int,TreeNode*> mp;\\n        \\n        //store the current min and current max nodes in the current tree\\n        unordered_map<TreeNode*,pair<int,int>> mini;\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            pair<int,int> ans={trees[i]->val,trees[i]->val};\\n            if(trees[i]->left)\\n            {\\n                \\n                mp[trees[i]->left->val]={trees[i]};\\n                ans.first=trees[i]->left->val;\\n            }\\n            if(trees[i]->right)\\n            {\\n                mp[trees[i]->right->val]=trees[i];\\n                ans.second=trees[i]->right->val;\\n            }\\n            mini[trees[i]]=ans;\\n        }\\n        \\n        //store the number of merging operations we will be doing\\n        int count=0;\\n        int rootCount=0;\\n        TreeNode* root=NULL;\\n        //now for every node get the root\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            \\n            //if the current tree can be merged into some other tree\\n            if(mp.find(trees[i]->val)!=mp.end())\\n            {\\n                count++;\\n                //merge them\\n                TreeNode* parent=mp[trees[i]->val];\\n                if(trees[i]->val < parent->val)\\n                {\\n                    //left child \\n                    \\n                    //if the maximum of the current sub tree is greater than the parent value \\n                    //then return NULL\\n                    if(parent->val <= mini[trees[i]].second)\\n                        return NULL;\\n                    //change the minimum value of the parent tree to the current min value of the tree\\n                    mini[parent].first=mini[trees[i]].first;\\n                    //merge the trees\\n                    parent->left=trees[i];\\n                }\\n                else  if(trees[i]->val > parent->val)\\n                {\\n                    //right child\\n                    \\n                    //if the minimum of the current tree is lesser than the parent value\\n                    //we cannot merge \\n                    //so return NULL\\n                    if(parent->val >= mini[trees[i]].first)\\n                        return NULL;\\n                    \\n                    //change the parent tree maximum to the current tree maximum\\n                    mini[parent].second=mini[trees[i]].second;\\n                    //merge the trees\\n                    parent->right=trees[i];\\n                }\\n                //erase the current tree value\\n                mp.erase(trees[i]->val);\\n            }\\n            else{\\n                //it has no other tree to merge \\n                //it is the root node we should return \\n                if(rootCount==1)\\n                    return NULL;\\n                else \\n                {\\n                    rootCount++;\\n                    root=trees[i];\\n                }\\n            }\\n        }\\n        //if we are not able to merge all trees return NULL\\n        if(count!=trees.size()-1)\\n            return NULL;\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344318,
                "title": "c-90-faster-using-hashmap-explained",
                "content": "1. The root of merged tree will be that root node whose value is not equal to leaf node of any other tree and it has to be unique.\\n2. Build the tree by combining the leafs with matching roots.\\n3. Check if the all the BSTs are combined.\\n4. Check if tree formed is a valid BST.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n  long long prev=LLONG_MIN;\\n    bool isValidBST(TreeNode* root) {\\n        if(root==NULL)return true;\\n        if(isValidBST(root->left)==false)return false;\\n        if(root->val<=prev)return false;\\n        prev=root->val;\\n        return isValidBST(root->right);\\n    }\\n    \\n    \\n    void make_tree(TreeNode* &root,unordered_map<int,TreeNode*>&m )\\n    {\\n        if(!root)return;\\n        if(root->left)\\n        {\\n            if(m[root->left->val]){\\n            root->left=m[root->left->val];\\n            m[root->left->val]=NULL;\\n            }\\n        }\\n        if(root->right)\\n        {\\n            if(m[root->right->val]){\\n            root->right=m[root->right->val];\\n                m[root->right->val]=NULL;\\n            }\\n        }\\n        make_tree(root->left,m);\\n        make_tree(root->right,m);\\n    }\\n    \\n    \\n    \\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,int>nodes;  //map to store freq of root nodes\\n        for(auto x:trees)\\n        {\\n            nodes[x->val]++;\\n            if(x->left)nodes[x->left->val]++;\\n            if(x->right)nodes[x->right->val]++;\\n        }\\n        TreeNode* curr=NULL;      //root node of combined tree\\n        for(auto x:trees)\\n        {\\n            if(nodes[x->val]==1)    //if a root node val is not equals to leaf of any other root, then it can be for root node of comibed tree\\n            {\\n                if(curr!=NULL)return NULL; //not more than 1 root can exist for combined tree\\n                curr=x;\\n            }\\n        }\\n        unordered_map<int,TreeNode*>m; //map to store root nodes\\n        for(auto x:trees)\\n        {\\n            m[x->val]=x;\\n        }\\n        make_tree(curr,m); //function to combine all BSTs\\n        int count=0;\\n        for(auto x:m)\\n        {\\n            \\n            if(x.second!=NULL)count++;   //to check if all BSTs have been included\\n        }\\n        if(count>1)return NULL;\\n        if(isValidBST(curr))return curr;   //check if tree formed is a valid BST or not\\n        return NULL;\\n        \\n      \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n  long long prev=LLONG_MIN;\\n    bool isValidBST(TreeNode* root) {\\n        if(root==NULL)return true;\\n        if(isValidBST(root->left)==false)return false;\\n        if(root->val<=prev)return false;\\n        prev=root->val;\\n        return isValidBST(root->right);\\n    }\\n    \\n    \\n    void make_tree(TreeNode* &root,unordered_map<int,TreeNode*>&m )\\n    {\\n        if(!root)return;\\n        if(root->left)\\n        {\\n            if(m[root->left->val]){\\n            root->left=m[root->left->val];\\n            m[root->left->val]=NULL;\\n            }\\n        }\\n        if(root->right)\\n        {\\n            if(m[root->right->val]){\\n            root->right=m[root->right->val];\\n                m[root->right->val]=NULL;\\n            }\\n        }\\n        make_tree(root->left,m);\\n        make_tree(root->right,m);\\n    }\\n    \\n    \\n    \\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,int>nodes;  //map to store freq of root nodes\\n        for(auto x:trees)\\n        {\\n            nodes[x->val]++;\\n            if(x->left)nodes[x->left->val]++;\\n            if(x->right)nodes[x->right->val]++;\\n        }\\n        TreeNode* curr=NULL;      //root node of combined tree\\n        for(auto x:trees)\\n        {\\n            if(nodes[x->val]==1)    //if a root node val is not equals to leaf of any other root, then it can be for root node of comibed tree\\n            {\\n                if(curr!=NULL)return NULL; //not more than 1 root can exist for combined tree\\n                curr=x;\\n            }\\n        }\\n        unordered_map<int,TreeNode*>m; //map to store root nodes\\n        for(auto x:trees)\\n        {\\n            m[x->val]=x;\\n        }\\n        make_tree(curr,m); //function to combine all BSTs\\n        int count=0;\\n        for(auto x:m)\\n        {\\n            \\n            if(x.second!=NULL)count++;   //to check if all BSTs have been included\\n        }\\n        if(count>1)return NULL;\\n        if(isValidBST(curr))return curr;   //check if tree formed is a valid BST or not\\n        return NULL;\\n        \\n      \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330172,
                "title": "java-two-hashmaps",
                "content": "1. Use Map to store root value to root node\\n2. Use set to mark the deleted trees\\n3. Traverse the list of roots and check if left and right nodes can be replaced\\n4. Check if the new root forms valid BST\\n\\n**Special case**: root1 set root2 as child and root2 trying to set root1 as child\\nUse a map to maintain the new parent of tree when it is modified and check if we are trying to set the parent as child when traversing the trees\\n```\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> map = new HashMap<>(); /* Value to root map */\\n        Set<TreeNode> set = new HashSet<>();\\n        Map<TreeNode, TreeNode> parent = new HashMap<>(); /* Track the parent node which modified current node */\\n        for (TreeNode root : trees)\\n            map.put(root.val, root);\\n\\n        for (TreeNode root : trees) {\\n        \\t/* If left node is present as root somewhere in list, replace the left node with root */\\n            if (root.left != null && map.containsKey(root.left.val) && !set.contains(map.get(root.left.val))) {\\n                TreeNode node = parent.getOrDefault(root, null);\\n                /* Special case of child node trying to set its root as child node */\\n                if (node != map.get(root.left.val)) {\\n                    root.left = map.get(root.left.val);\\n                    parent.put(map.get(root.left.val), root);\\n                    set.add(map.get(root.left.val));\\n                }\\n            }\\n            \\n            /* If right node is present as root somewhere in list, replace the right node with root */\\n            if (root.right != null && map.containsKey(root.right.val) && !set.contains(map.get(root.right.val))) {\\n                TreeNode node = parent.getOrDefault(root, null);\\n                if (node != map.get(root.right.val)) {\\n                    root.right = map.get(root.right.val);\\n                    parent.put(map.get(root.right.val), root);\\n                    set.add(map.get(root.right.val));\\n                }\\n            }\\n        }\\n        \\n        /* There should be only one root */\\n        if (set.size() != trees.size() - 1)\\n            return null;\\n\\n        /* Check if the new root is a valid BST */\\n        for (TreeNode root : trees) {\\n            if (!set.contains(root)) {\\n                if (validBST(root, null, null))\\n                    return root;\\n                return null;\\n            }\\n        }\\n        \\n        return null;\\n    }\\n    \\n    private boolean validBST(TreeNode node, TreeNode left, TreeNode right) {\\n        if (node == null)\\n            return true;\\n        \\n        if (left != null && node.val <= left.val) return false;\\n        if (right != null && node.val >= right.val) return false;\\n        return validBST(node.left, left, node) && validBST(node.right, node, right);\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> map = new HashMap<>(); /* Value to root map */\\n        Set<TreeNode> set = new HashSet<>();\\n        Map<TreeNode, TreeNode> parent = new HashMap<>(); /* Track the parent node which modified current node */\\n        for (TreeNode root : trees)\\n            map.put(root.val, root);\\n\\n        for (TreeNode root : trees) {\\n        \\t/* If left node is present as root somewhere in list, replace the left node with root */\\n            if (root.left != null && map.containsKey(root.left.val) && !set.contains(map.get(root.left.val))) {\\n                TreeNode node = parent.getOrDefault(root, null);\\n                /* Special case of child node trying to set its root as child node */\\n                if (node != map.get(root.left.val)) {\\n                    root.left = map.get(root.left.val);\\n                    parent.put(map.get(root.left.val), root);\\n                    set.add(map.get(root.left.val));\\n                }\\n            }\\n            \\n            /* If right node is present as root somewhere in list, replace the right node with root */\\n            if (root.right != null && map.containsKey(root.right.val) && !set.contains(map.get(root.right.val))) {\\n                TreeNode node = parent.getOrDefault(root, null);\\n                if (node != map.get(root.right.val)) {\\n                    root.right = map.get(root.right.val);\\n                    parent.put(map.get(root.right.val), root);\\n                    set.add(map.get(root.right.val));\\n                }\\n            }\\n        }\\n        \\n        /* There should be only one root */\\n        if (set.size() != trees.size() - 1)\\n            return null;\\n\\n        /* Check if the new root is a valid BST */\\n        for (TreeNode root : trees) {\\n            if (!set.contains(root)) {\\n                if (validBST(root, null, null))\\n                    return root;\\n                return null;\\n            }\\n        }\\n        \\n        return null;\\n    }\\n    \\n    private boolean validBST(TreeNode node, TreeNode left, TreeNode right) {\\n        if (node == null)\\n            return true;\\n        \\n        if (left != null && node.val <= left.val) return false;\\n        if (right != null && node.val >= right.val) return false;\\n        return validBST(node.left, left, node) && validBST(node.right, node, right);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086103,
                "title": "just-find-the-root-simple-bfs-solution",
                "content": "![image](https://assets.leetcode.com/users/images/eda8df4e-9fc2-4522-927b-d4a3875085d4_1674391548.905983.png)\\n\\nJust You have to Find the root!\\nRoot cannot be the child of any node so simply by hashing and hashset you can find it.\\n\\n-> If more than two root occurs or no root occurs than simply return {} empty list \\n\\nElse start building the solution from top and keep strech it to the bottom ans at last just check if the final tree is BST or not (Validating a BST)\\n\\n\\nCode:\\n\\nclass Solution {\\npublic:\\n     bool check(TreeNode* root,int lb,int ub){\\n        if(root==NULL)return true;\\n        if(root->val<=lb||root->val>=ub)return false;\\n        \\n        bool left=check(root->left,lb,root->val);\\n        bool right=check(root->right,root->val,ub);\\n        return left&right;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n     unordered_set<int>st;\\n        unordered_map<int,TreeNode*>hash;\\n        unordered_set<TreeNode*>temp;\\n        for(auto it:trees){\\n            hash[it->val]=it;\\n            temp.insert(it);\\n            if(it->left)st.insert(it->left->val);\\n             if(it->right)st.insert(it->right->val);\\n        }\\n        TreeNode* root=NULL;\\n        int cnt=0;\\n        for(auto it:trees){\\n           if(st.find(it->val)==st.end()){\\n               cnt++;\\n               root=it;\\n               if(cnt>1)return {};\\n           } \\n        }\\n        temp.erase(root);\\n        queue<TreeNode*>que;\\n        if(root==NULL)return {};\\n        que.push(root);\\n        while(que.size()){\\n            int size=que.size();\\n            while(size--){\\n                TreeNode* node=que.front();\\n                que.pop();\\n                if(node->left==NULL&&node->right==NULL){\\n                   \\n                    if(temp.find(hash[node->val])!=temp.end()){\\n                        node->left=hash[node->val]->left;\\n                        node->right=hash[node->val]->right;\\n                        temp.erase(hash[node->val]);\\n                    }\\n                }\\n                if(node->left)que.push(node->left);\\n                if(node->right)que.push(node->right);\\n            }\\n        }\\n        if(temp.size())return {};\\n          if(check(root,INT_MIN,INT_MAX))return root;\\n          return {};\\n    }\\n};\\n",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n     bool check(TreeNode* root,int lb,int ub){\\n        if(root==NULL)return true;\\n        if(root->val<=lb||root->val>=ub)return false;\\n        \\n        bool left=check(root->left,lb,root->val);\\n        bool right=check(root->right,root->val,ub);\\n        return left&right;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1989069,
                "title": "c-easy-and-simple-solution-merge-bsts-to-create-single-bst",
                "content": "**Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F**\\n```\\nclass Solution {\\npublic:\\n    \\n  long long prev=LLONG_MIN;\\n    bool isValidBST(TreeNode* root) {\\n        if(root==NULL)return true;\\n        if(isValidBST(root->left)==false)return false;\\n        if(root->val<=prev)return false;\\n        prev=root->val;\\n        return isValidBST(root->right);\\n    }\\n    \\n    \\n    void make_tree(TreeNode* &root,unordered_map<int,TreeNode*>&m )\\n    {\\n        if(!root)return;\\n        if(root->left)\\n        {\\n            if(m[root->left->val]){\\n            root->left=m[root->left->val];\\n            m[root->left->val]=NULL;\\n            }\\n        }\\n        if(root->right)\\n        {\\n            if(m[root->right->val]){\\n            root->right=m[root->right->val];\\n                m[root->right->val]=NULL;\\n            }\\n        }\\n        make_tree(root->left,m);\\n        make_tree(root->right,m);\\n    }\\n    \\n    \\n    \\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,int>nodes;  //map to store freq of root nodes\\n        for(auto x:trees)\\n        {\\n            nodes[x->val]++;\\n            if(x->left)nodes[x->left->val]++;\\n            if(x->right)nodes[x->right->val]++;\\n        }\\n        TreeNode* curr=NULL;      //root node of combined tree\\n        for(auto x:trees)\\n        {\\n            if(nodes[x->val]==1)    //if a root node val is not equals to leaf of any other root, then it can be for root node of comibed tree\\n            {\\n                if(curr!=NULL)return NULL; //not more than 1 root can exist for combined tree\\n                curr=x;\\n            }\\n        }\\n        unordered_map<int,TreeNode*>m; //map to store root nodes\\n        for(auto x:trees)\\n        {\\n            m[x->val]=x;\\n        }\\n        make_tree(curr,m); //function to combine all BSTs\\n        int count=0;\\n        for(auto x:m)\\n        {\\n            \\n            if(x.second!=NULL)count++;   //to check if all BSTs have been included\\n        }\\n        if(count>1)return NULL;\\n        if(isValidBST(curr))return curr;   //check if tree formed is a valid BST or not\\n        return NULL;\\n        \\n      \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n  long long prev=LLONG_MIN;\\n    bool isValidBST(TreeNode* root) {\\n        if(root==NULL)return true;\\n        if(isValidBST(root->left)==false)return false;\\n        if(root->val<=prev)return false;\\n        prev=root->val;\\n        return isValidBST(root->right);\\n    }\\n    \\n    \\n    void make_tree(TreeNode* &root,unordered_map<int,TreeNode*>&m )\\n    {\\n        if(!root)return;\\n        if(root->left)\\n        {\\n            if(m[root->left->val]){\\n            root->left=m[root->left->val];\\n            m[root->left->val]=NULL;\\n            }\\n        }\\n        if(root->right)\\n        {\\n            if(m[root->right->val]){\\n            root->right=m[root->right->val];\\n                m[root->right->val]=NULL;\\n            }\\n        }\\n        make_tree(root->left,m);\\n        make_tree(root->right,m);\\n    }\\n    \\n    \\n    \\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,int>nodes;  //map to store freq of root nodes\\n        for(auto x:trees)\\n        {\\n            nodes[x->val]++;\\n            if(x->left)nodes[x->left->val]++;\\n            if(x->right)nodes[x->right->val]++;\\n        }\\n        TreeNode* curr=NULL;      //root node of combined tree\\n        for(auto x:trees)\\n        {\\n            if(nodes[x->val]==1)    //if a root node val is not equals to leaf of any other root, then it can be for root node of comibed tree\\n            {\\n                if(curr!=NULL)return NULL; //not more than 1 root can exist for combined tree\\n                curr=x;\\n            }\\n        }\\n        unordered_map<int,TreeNode*>m; //map to store root nodes\\n        for(auto x:trees)\\n        {\\n            m[x->val]=x;\\n        }\\n        make_tree(curr,m); //function to combine all BSTs\\n        int count=0;\\n        for(auto x:m)\\n        {\\n            \\n            if(x.second!=NULL)count++;   //to check if all BSTs have been included\\n        }\\n        if(count>1)return NULL;\\n        if(isValidBST(curr))return curr;   //check if tree formed is a valid BST or not\\n        return NULL;\\n        \\n      \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1358113,
                "title": "c-most-intuitive",
                "content": "The most important thing to understand is the fact that the final root node will be the one which is not found in any trees leaves. After figuring this out, we just need to recursively merge the dependecies, and finally check if everything has been merged and if the resuting tree is a BST or not. \\n\\n```\\n\\nclass Solution {\\npublic:\\n    unordered_map<int, TreeNode*> rootMap; \\n    \\n    bool findBST(TreeNode* root, long left, long right){\\n        if(root == NULL) return true; \\n        int res = root->val > left && root->val < right; \\n        res = res && findBST(root->left, left, root->val)  && findBST(root->right, root->val, right); \\n        return res;\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        return findBST(root, LONG_MIN, LONG_MAX);     \\n    }\\n    \\n    TreeNode* mergeAll(TreeNode* root){ \\n        TreeNode* res =  rootMap.count(root->val)? rootMap[root->val]: root; \\n        rootMap.erase(root->val); \\n        if(res->left) root->left = mergeAll(res->left); \\n        if(res->right) root->right = mergeAll(res->right);\\n        return res; \\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_set<int> st ;\\n        for(auto x:trees){\\n            rootMap[x->val] = x;\\n            if(x->left) st.insert(x->left->val);\\n            if(x->right) st.insert(x->right->val);\\n        }\\n        TreeNode* root; \\n        for(auto x:trees){\\n            if(!st.count(x->val)){\\n                root = x;\\n                break ; \\n            }\\n        }\\n        mergeAll(root); \\n        return isValidBST(root) && (rootMap.size() == 0)? root: NULL; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    unordered_map<int, TreeNode*> rootMap; \\n    \\n    bool findBST(TreeNode* root, long left, long right){\\n        if(root == NULL) return true; \\n        int res = root->val > left && root->val < right; \\n        res = res && findBST(root->left, left, root->val)  && findBST(root->right, root->val, right); \\n        return res;\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        return findBST(root, LONG_MIN, LONG_MAX);     \\n    }\\n    \\n    TreeNode* mergeAll(TreeNode* root){ \\n        TreeNode* res =  rootMap.count(root->val)? rootMap[root->val]: root; \\n        rootMap.erase(root->val); \\n        if(res->left) root->left = mergeAll(res->left); \\n        if(res->right) root->right = mergeAll(res->right);\\n        return res; \\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_set<int> st ;\\n        for(auto x:trees){\\n            rootMap[x->val] = x;\\n            if(x->left) st.insert(x->left->val);\\n            if(x->right) st.insert(x->right->val);\\n        }\\n        TreeNode* root; \\n        for(auto x:trees){\\n            if(!st.count(x->val)){\\n                root = x;\\n                break ; \\n            }\\n        }\\n        mergeAll(root); \\n        return isValidBST(root) && (rootMap.size() == 0)? root: NULL; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537226,
                "title": "just-do-what-is-says-explained-the-approach-in-detail-time-complexity-o-n",
                "content": "# Approach : \\nTime complexity : $$O(n)$$\\n\\nSo, first I have inserted all the leaf nodes to parent <key,value> pairs are stored. \\n\\n![image.png](https://assets.leetcode.com/users/images/8e5bc7c9-bfa8-4373-bffb-f8ea7caeec58_1684390579.3647506.png)\\n\\nThe the unordered map is stored to get the root of the tree having leaf value same as root2->val\\nHere in the image, 2 is root2 (tree[0]) and then I will find the root of the tree having a leaf node value as 2. So using unordered_map it becomes easy to find. So while searching I get the TreeNode* 3 (i.e. the root of leaf node value == 2)\\n\\n### Joining Part   : \\n\\nSo to join a bst 1 to another bst 2, i will check if I\\'m adding the bst1 to left of bst2, then I have to check if the right of bst1 if smaller than root value, if it is smaller then add the bst1 to bst2 or else return NULL.\\n\\n##### So in the Above example : \\nTaking (tree[0] and tree[1]) into consideration, tree[0] will be added to left of tree[1]. So I check if the right value of right of 2 is smaller than 3 (ie the root of tree[1]), here it does not exist so then add the tree[0] to tree[1].\\n\\n##### Below example : \\nTaking (tree[0] and tree[1]) into consideration, tree[1] will be added to left of tree[0].\\nSo I check if the right value of right of 3 (tree[1]) is smaller than 5 (ie the root of tree[1]), here the value if 6>5, so return NULL\\n\\n![image.png](https://assets.leetcode.com/users/images/199f02d4-47d5-4197-8bc1-65a03c88ce56_1684390990.772047.png)\\n\\n\\n###### Similarly, do the checks while adding the bst to right, check if the value of bst1\\'s left is greater than the root of bst2.\\n\\nAnd then finally after connecting the trees, check if there is only 1 single connected tree or not. If there is only one connected tree, then just check if it is a valid bst.\\n\\n# Code\\n```\\n// Here mp is the unordered_map where the leaf to parent is stored\\n\\n\\nclass Solution {\\npublic:\\n    bool isBSTHelper(TreeNode* root, long minVal, long maxVal) {\\n        if (root == NULL) return true;\\n        if(root->val <= minVal || root->val >= maxVal) return false;\\n        return isBSTHelper(root->left, minVal, root->val) && isBSTHelper(root->right, root->val, maxVal);\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, TreeNode*> mp;\\n//  trees -> parent\\n        unordered_map<TreeNode*,TreeNode*> par;\\n        // inserting values in parent\\n        for(auto t : trees){\\n            par[t] = t;\\n        }\\n        \\n        // inserting the values in mp\\n        for(int i =0; i< trees.size(); i++){\\n            TreeNode* tmp = trees[i];\\n            if(tmp->left){ \\n                if(mp.find(tmp->left->val) == mp.end())\\n                    mp[tmp->left->val] = tmp;\\n                else return NULL;\\n            }\\n            if(tmp->right){ \\n                if(mp.find(tmp->right->val) == mp.end())\\n                    mp[tmp->right->val] = tmp;\\n                else return NULL;\\n            }\\n        }\\n        for(int i = 0; i< trees.size(); i++){\\n            TreeNode* tmp = trees[i];\\n            if(mp.find(tmp->val) != mp.end()){\\n                TreeNode* root = mp[tmp->val];\\n                if(root->right && root->right->val == tmp->val){\\n                    int check = INT_MAX;\\n                    if(tmp->left){\\n                        check = tmp->left->val;\\n                    }\\n                    if(check > root->val){\\n                        root->right = tmp;\\n                        par[tmp] = par[root];\\n                        mp.erase(tmp->val);\\n                    }else{\\n                        return NULL;\\n                    }\\n                }\\n                else if(root->left && root->left->val == tmp->val){\\n                    int check = 0;\\n                    if(tmp->right){\\n                        check = tmp->right->val;\\n                    }\\n                    if(check< root->val){\\n                        root->left = tmp;\\n                        par[tmp] = par[root];\\n                        mp.erase(tmp->val);\\n                    }else{\\n                        return NULL;\\n                    }\\n                }\\n            }\\n        }\\n        vector<TreeNode*> ans;\\n        for(auto t : par){\\n            if(t.first == t.second){\\n                ans.push_back(t.first);\\n            }\\n        }\\n        if(ans.size() == 1){ \\n            if(isBSTHelper(ans[0],LONG_MIN, LONG_MAX))\\n                return ans[0];\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n###### Please upvote \\uD83E\\uDD79 !",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Here mp is the unordered_map where the leaf to parent is stored\\n\\n\\nclass Solution {\\npublic:\\n    bool isBSTHelper(TreeNode* root, long minVal, long maxVal) {\\n        if (root == NULL) return true;\\n        if(root->val <= minVal || root->val >= maxVal) return false;\\n        return isBSTHelper(root->left, minVal, root->val) && isBSTHelper(root->right, root->val, maxVal);\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, TreeNode*> mp;\\n//  trees -> parent\\n        unordered_map<TreeNode*,TreeNode*> par;\\n        // inserting values in parent\\n        for(auto t : trees){\\n            par[t] = t;\\n        }\\n        \\n        // inserting the values in mp\\n        for(int i =0; i< trees.size(); i++){\\n            TreeNode* tmp = trees[i];\\n            if(tmp->left){ \\n                if(mp.find(tmp->left->val) == mp.end())\\n                    mp[tmp->left->val] = tmp;\\n                else return NULL;\\n            }\\n            if(tmp->right){ \\n                if(mp.find(tmp->right->val) == mp.end())\\n                    mp[tmp->right->val] = tmp;\\n                else return NULL;\\n            }\\n        }\\n        for(int i = 0; i< trees.size(); i++){\\n            TreeNode* tmp = trees[i];\\n            if(mp.find(tmp->val) != mp.end()){\\n                TreeNode* root = mp[tmp->val];\\n                if(root->right && root->right->val == tmp->val){\\n                    int check = INT_MAX;\\n                    if(tmp->left){\\n                        check = tmp->left->val;\\n                    }\\n                    if(check > root->val){\\n                        root->right = tmp;\\n                        par[tmp] = par[root];\\n                        mp.erase(tmp->val);\\n                    }else{\\n                        return NULL;\\n                    }\\n                }\\n                else if(root->left && root->left->val == tmp->val){\\n                    int check = 0;\\n                    if(tmp->right){\\n                        check = tmp->right->val;\\n                    }\\n                    if(check< root->val){\\n                        root->left = tmp;\\n                        par[tmp] = par[root];\\n                        mp.erase(tmp->val);\\n                    }else{\\n                        return NULL;\\n                    }\\n                }\\n            }\\n        }\\n        vector<TreeNode*> ans;\\n        for(auto t : par){\\n            if(t.first == t.second){\\n                ans.push_back(t.first);\\n            }\\n        }\\n        if(ans.size() == 1){ \\n            if(isBSTHelper(ans[0],LONG_MIN, LONG_MAX))\\n                return ans[0];\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367650,
                "title": "split-problem-into-multiple-subproblems-and-solution-is-ready",
                "content": "This problem can be broken down into 4 subproblems - \\n1. How to find leave nodes & root nodes in constant time out of n BST\\n2. How to find a BST whoes root node is not a leaf node in any one of the BSTs\\n3. Given a BST (found in step 2), try to merge rest of BSTs to its left and right child\\n4. Find if given tree is BST or not. \\n\\nLets start 1 by 1 - \\n1. How to traverse leave nodes & root nodes in constant time out of n BST - \\n\\t* Why we need constant time search - \\n\\t\\t* For each BST\\'s root node we wanted to verify if root node is part of any BST\\'s leaf node or not. \\n\\t\\t* to find a BST whoes root node is not a leaf node in any one of the BSTs\\n\\t* We can leverage Map here keep track of both type queries\\n\\n2. How to find a BST whoes root node is not a leaf node in any one of the BSTs -\\n\\t* We can use above Map to perform this query. For each root node in List we can query in **leaves** Map if no leaves exists then it can become my combined BST root. \\n\\n3. Given a BST (found in step 2), try to merge rest of BSTs to its left and right child -\\n\\t* if left child(by value we will compare) is present in **roots** map then replace left child with this node from **roots** map\\n\\t* if right child (by value we will compare) is present in **roots** map then replace right child with this node from **roots** map.\\n\\t* recurse above 2 steps for each left & right child\\n\\t\\n4. Find if given tree is BST or not. \\n\\t* Multiple ways to do it. Either in-order traversal or comparing left & right with min/max. You can surely find answer for this on internet.\\n\\nBelow code snippet can be improved further but is just to give an idea how we can implement all 4 subproblems and stich them togather.\\n\\n```\\nclass Solution {\\n    // Map to hold leaves\\n    // It will help to query if any given root not is part of leaves node in any of the BST\\n    Map<Integer, List<TreeNode> > leaves = new HashMap<>();\\n    \\n    // Map to hold roots\\n    // It will help to query - give me any root node which matches given node \\n    // Mostly used for querying for left node matches with any root and right node matches any root\\n    Map<Integer, TreeNode> roots = new HashMap<>();\\n\\n    //Function to check if it can be merged or not\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n    \\n        // To queries nodes mulitple times in constant operation we will put them into Map\\n         for(TreeNode node: trees){\\n             // append to root map\\n            roots.put(node.val, node);\\n             \\n             // append to leaves map\\n            if(node.left != null){\\n                List<TreeNode> nodes = leaves.get(node.left.val);\\n                if(nodes == null) nodes = new LinkedList<TreeNode>();\\n                nodes.add(node);\\n                leaves.put(node.left.val, nodes);\\n            }\\n            if(node.right != null){\\n                List<TreeNode> nodes = leaves.get(node.right.val);\\n                if(nodes == null) nodes = new LinkedList<TreeNode>();\\n                nodes.add(node);\\n                leaves.put(node.right.val, nodes);\\n            }     \\n        }\\n\\n        // find a node which will become root of bst\\n        TreeNode bstRoot = null;\\n        for(TreeNode n: trees){\\n            if(!leaves.containsKey(n.val)){\\n                bstRoot = n;\\n                break;\\n            }\\n        }\\n        \\n        // if no unique root found we cannot merge it\\n        if(bstRoot == null)\\n            return null;\\n        \\n        // invoke merge operation\\n        merge(bstRoot);\\n        \\n        // at the end we will check only 1 tree should be remaining and it should be BST\\n        if (roots.size() == 1 && isValidBST(bstRoot, Integer.MIN_VALUE, Integer.MAX_VALUE) )\\n            return bstRoot;\\n        \\n        return null;\\n            \\n    }\\n    \\n    void merge(TreeNode node){\\n        if(node == null)\\n            return;\\n        if(node.left != null){\\n            // Find any root node which matches with left leaf node and then append it to my BST\\n            if(roots.containsKey(node.left.val)){\\n                node.left = roots.get(node.left.val);\\n                roots.remove(node.left.val);\\n            }\\n        }\\n        if(node.right != null){\\n            // Find any root node which matches with right leaf node and then append it to my BST\\n            // this duplicate code can be reduced by extracting a function\\n            if(roots.containsKey(node.right.val)){     \\n                node.right = roots.get(node.right.val);\\n                roots.remove(node.right.val);\\n            }\\n        }\\n        \\n        merge(node.left);\\n        merge(node.right);\\n    }\\n    \\n    boolean isValidBST(TreeNode n, int min, int max){\\n        if(n.val < min || n.val > max)\\n            return false;\\n        \\n        boolean l =true, r= true;\\n        \\n        if(n.left != null)\\n             l = isValidBST(n.left, min, n.val);\\n        if(n.right != null)\\n             r = isValidBST(n.right, n.val, max);\\n        \\n        return n.val>min && n.val < max & l && r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // Map to hold leaves\\n    // It will help to query if any given root not is part of leaves node in any of the BST\\n    Map<Integer, List<TreeNode> > leaves = new HashMap<>();\\n    \\n    // Map to hold roots\\n    // It will help to query - give me any root node which matches given node \\n    // Mostly used for querying for left node matches with any root and right node matches any root\\n    Map<Integer, TreeNode> roots = new HashMap<>();\\n\\n    //Function to check if it can be merged or not\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n    \\n        // To queries nodes mulitple times in constant operation we will put them into Map\\n         for(TreeNode node: trees){\\n             // append to root map\\n            roots.put(node.val, node);\\n             \\n             // append to leaves map\\n            if(node.left != null){\\n                List<TreeNode> nodes = leaves.get(node.left.val);\\n                if(nodes == null) nodes = new LinkedList<TreeNode>();\\n                nodes.add(node);\\n                leaves.put(node.left.val, nodes);\\n            }\\n            if(node.right != null){\\n                List<TreeNode> nodes = leaves.get(node.right.val);\\n                if(nodes == null) nodes = new LinkedList<TreeNode>();\\n                nodes.add(node);\\n                leaves.put(node.right.val, nodes);\\n            }     \\n        }\\n\\n        // find a node which will become root of bst\\n        TreeNode bstRoot = null;\\n        for(TreeNode n: trees){\\n            if(!leaves.containsKey(n.val)){\\n                bstRoot = n;\\n                break;\\n            }\\n        }\\n        \\n        // if no unique root found we cannot merge it\\n        if(bstRoot == null)\\n            return null;\\n        \\n        // invoke merge operation\\n        merge(bstRoot);\\n        \\n        // at the end we will check only 1 tree should be remaining and it should be BST\\n        if (roots.size() == 1 && isValidBST(bstRoot, Integer.MIN_VALUE, Integer.MAX_VALUE) )\\n            return bstRoot;\\n        \\n        return null;\\n            \\n    }\\n    \\n    void merge(TreeNode node){\\n        if(node == null)\\n            return;\\n        if(node.left != null){\\n            // Find any root node which matches with left leaf node and then append it to my BST\\n            if(roots.containsKey(node.left.val)){\\n                node.left = roots.get(node.left.val);\\n                roots.remove(node.left.val);\\n            }\\n        }\\n        if(node.right != null){\\n            // Find any root node which matches with right leaf node and then append it to my BST\\n            // this duplicate code can be reduced by extracting a function\\n            if(roots.containsKey(node.right.val)){     \\n                node.right = roots.get(node.right.val);\\n                roots.remove(node.right.val);\\n            }\\n        }\\n        \\n        merge(node.left);\\n        merge(node.right);\\n    }\\n    \\n    boolean isValidBST(TreeNode n, int min, int max){\\n        if(n.val < min || n.val > max)\\n            return false;\\n        \\n        boolean l =true, r= true;\\n        \\n        if(n.left != null)\\n             l = isValidBST(n.left, min, n.val);\\n        if(n.right != null)\\n             r = isValidBST(n.right, n.val, max);\\n        \\n        return n.val>min && n.val < max & l && r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333876,
                "title": "java-o-n-using-two-hashmaps-optimized-40ms-explained-with-comments",
                "content": "Reference : https://leetcode.com/problems/merge-bsts-to-create-single-bst/discuss/1330172/Java-or-two-HashMaps\\n\\n```\\nclass Solution {\\n     public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> rootMap = new HashMap<>(); /* Value to root map */\\n        Set<TreeNode> deletedRoots = new HashSet<>();\\n        Map<TreeNode, TreeNode> parentMap = new HashMap<>(); /* Track the parent node which modified current node */\\n        for (TreeNode root : trees)\\n            rootMap.put(root.val, root);\\n\\n        for (TreeNode currentNode : trees) {\\n            /* If left node is present as root somewhere in list, replace the left node with root */\\n            if (currentNode.left != null && rootMap.containsKey(currentNode.left.val)) {\\n                TreeNode node = parentMap.getOrDefault(currentNode, null);\\n                TreeNode root = rootMap.get(currentNode.left.val);\\n                /* Check if two leaves with same value */\\n                if(deletedRoots.contains(root))\\n                    return null;\\n                /* Special case of child node trying to set its root as child node */\\n                if (node != root) {\\n                    currentNode.left = root;\\n                    parentMap.put(root, currentNode);\\n                    deletedRoots.add(root);\\n                }\\n                else{\\n                    return null;\\n                }\\n            }\\n\\n            /* If right node is present as root somewhere in list, replace the right node with root */\\n            if (currentNode.right != null && rootMap.containsKey(currentNode.right.val)) {\\n                TreeNode node = parentMap.getOrDefault(currentNode, null);\\n                TreeNode root = rootMap.get(currentNode.right.val);\\n                /* Check if two leaves with same value */\\n                if(deletedRoots.contains(root))\\n                    return null;\\n                /* Special case of child node trying to set its root as child node */\\n                if (node != root) {\\n                    currentNode.right = root;\\n                    parentMap.put(root, currentNode);\\n                    deletedRoots.add(root);\\n                }\\n                else{\\n                    return null;\\n                }\\n            }\\n        }\\n\\n        /* There should be only one root */\\n        if (deletedRoots.size() != trees.size() - 1)\\n            return null;\\n\\n        /* Check if the new root is a valid BST */\\n        for (TreeNode root : trees) {\\n            if (!deletedRoots.contains(root)) {\\n                if (validBST(root, null, null))\\n                    return root;\\n                return null;\\n            }\\n        }\\n\\n        return null;\\n    }\\n\\n    private boolean validBST(TreeNode node, TreeNode left, TreeNode right) {\\n        if (node == null)\\n            return true;\\n\\n        if (left != null && node.val <= left.val) return false;\\n        if (right != null && node.val >= right.val) return false;\\n        return validBST(node.left, left, node) && validBST(node.right, node, right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> rootMap = new HashMap<>(); /* Value to root map */\\n        Set<TreeNode> deletedRoots = new HashSet<>();\\n        Map<TreeNode, TreeNode> parentMap = new HashMap<>(); /* Track the parent node which modified current node */\\n        for (TreeNode root : trees)\\n            rootMap.put(root.val, root);\\n\\n        for (TreeNode currentNode : trees) {\\n            /* If left node is present as root somewhere in list, replace the left node with root */\\n            if (currentNode.left != null && rootMap.containsKey(currentNode.left.val)) {\\n                TreeNode node = parentMap.getOrDefault(currentNode, null);\\n                TreeNode root = rootMap.get(currentNode.left.val);\\n                /* Check if two leaves with same value */\\n                if(deletedRoots.contains(root))\\n                    return null;\\n                /* Special case of child node trying to set its root as child node */\\n                if (node != root) {\\n                    currentNode.left = root;\\n                    parentMap.put(root, currentNode);\\n                    deletedRoots.add(root);\\n                }\\n                else{\\n                    return null;\\n                }\\n            }\\n\\n            /* If right node is present as root somewhere in list, replace the right node with root */\\n            if (currentNode.right != null && rootMap.containsKey(currentNode.right.val)) {\\n                TreeNode node = parentMap.getOrDefault(currentNode, null);\\n                TreeNode root = rootMap.get(currentNode.right.val);\\n                /* Check if two leaves with same value */\\n                if(deletedRoots.contains(root))\\n                    return null;\\n                /* Special case of child node trying to set its root as child node */\\n                if (node != root) {\\n                    currentNode.right = root;\\n                    parentMap.put(root, currentNode);\\n                    deletedRoots.add(root);\\n                }\\n                else{\\n                    return null;\\n                }\\n            }\\n        }\\n\\n        /* There should be only one root */\\n        if (deletedRoots.size() != trees.size() - 1)\\n            return null;\\n\\n        /* Check if the new root is a valid BST */\\n        for (TreeNode root : trees) {\\n            if (!deletedRoots.contains(root)) {\\n                if (validBST(root, null, null))\\n                    return root;\\n                return null;\\n            }\\n        }\\n\\n        return null;\\n    }\\n\\n    private boolean validBST(TreeNode node, TreeNode left, TreeNode right) {\\n        if (node == null)\\n            return true;\\n\\n        if (left != null && node.val <= left.val) return false;\\n        if (right != null && node.val >= right.val) return false;\\n        return validBST(node.left, left, node) && validBST(node.right, node, right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330943,
                "title": "c-hash-map-detailed-comments",
                "content": "```\\n/*\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    bool check(TreeNode* root,int minl,int maxr)\\n    {\\n        if(!root)\\n            return true;\\n        if(root->val >minl and root->val<maxr)\\n        {\\n            return check(root->left,minl,root->val) and check(root->right,root->val,maxr);\\n        }\\n        return false;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,TreeNode*> par;//to map values of node to it\\'s parent node\\n        unordered_map<TreeNode*,pair<int,int>> range;//range to store min and max values in BST rooted at a node \"TreeNode\"\\n        TreeNode* root=NULL;//root of final BST after n-1 merges\\n        int merges=0;//count of merge operation\\n        //Build par and range maps\\n        for(auto &node:trees){\\n            range[node].F= (node->left!=NULL ? node->left->val:node->val);\\n            range[node].S= (node->right!=NULL ? node->right->val:node->val);\\n            if(node->left!=NULL){\\n                par[node->left->val]=node;\\n            }\\n            if(node->right!=NULL){\\n                par[node->right->val]=node;\\n            }\\n        }\\n        for(auto &node:trees){\\n            \\n            //node->current_node\\n            \\n            if(par.find(node->val)!=par.end()){\\n                //It means this node may become made a child of another node. So try to make it child if satisfies the condition of BST\\n                TreeNode* parent=par[node->val];//parent of the current node\\n                \\n                //if the value of current node is less than value of parent node,it must be placed as left chid \\n                if(node->val < parent->val){\\n                    //Now we need to check that max value in substree of current node should be less than value of parent node\\n                    if(range[node].S< parent->val){\\n                        parent->left= node;\\n                        //Now update min value for parent node\\n                        range[parent].F = range[node].F;\\n                        //increment the no of merges \\n                        merges++;\\n                    }\\n                    else\\n                        return NULL;\\n                }\\n                //Similarily, if the value of current node is greater than value of parent node,it must be placed as right chid \\n                else if(node->val > parent->val){\\n                    //Also the min value in substree of current node should also be greater than value of parent node -> conditions of BST :)\\n                    if(range[node].F > parent->val){\\n                        parent->right=node;\\n                        //Update max value in subtree of parent node\\n                        range[parent].S= range[node].S;\\n                        //Increment the no of merges\\n                        merges++;\\n                    }\\n                    else\\n                        return NULL;\\n                }\\n                else{\\n                    return NULL;\\n                }\\n            }\\n            else{\\n                //It means the current node can be a potential candidate for root node of final BST\\n                if(root==NULL){\\n                    root=node;\\n                }\\n                //If multiple candidates available for root node of final BST just return NULL. We can\\'t form a valid BST\\n                else{\\n                    return NULL;\\n                }\\n            }\\n        }\\n        //Check whether the tree formed is BST or not\\n        if(!check(root,INT_MIN,INT_MAX)){\\n            return NULL;\\n        }\\n        //If the tree formed is BST,then check whether the no of merges is n-1 i.e  it is possible to form a valid BST after performing strictly n-1 operations, \\n        \\n        return (merges == (int)trees.size()-1 ? root:NULL);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    bool check(TreeNode* root,int minl,int maxr)\\n    {\\n        if(!root)\\n            return true;\\n        if(root->val >minl and root->val<maxr)\\n        {\\n            return check(root->left,minl,root->val) and check(root->right,root->val,maxr);\\n        }\\n        return false;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,TreeNode*> par;//to map values of node to it\\'s parent node\\n        unordered_map<TreeNode*,pair<int,int>> range;//range to store min and max values in BST rooted at a node \"TreeNode\"\\n        TreeNode* root=NULL;//root of final BST after n-1 merges\\n        int merges=0;//count of merge operation\\n        //Build par and range maps\\n        for(auto &node:trees){\\n            range[node].F= (node->left!=NULL ? node->left->val:node->val);\\n            range[node].S= (node->right!=NULL ? node->right->val:node->val);\\n            if(node->left!=NULL){\\n                par[node->left->val]=node;\\n            }\\n            if(node->right!=NULL){\\n                par[node->right->val]=node;\\n            }\\n        }\\n        for(auto &node:trees){\\n            \\n            //node->current_node\\n            \\n            if(par.find(node->val)!=par.end()){\\n                //It means this node may become made a child of another node. So try to make it child if satisfies the condition of BST\\n                TreeNode* parent=par[node->val];//parent of the current node\\n                \\n                //if the value of current node is less than value of parent node,it must be placed as left chid \\n                if(node->val < parent->val){\\n                    //Now we need to check that max value in substree of current node should be less than value of parent node\\n                    if(range[node].S< parent->val){\\n                        parent->left= node;\\n                        //Now update min value for parent node\\n                        range[parent].F = range[node].F;\\n                        //increment the no of merges \\n                        merges++;\\n                    }\\n                    else\\n                        return NULL;\\n                }\\n                //Similarily, if the value of current node is greater than value of parent node,it must be placed as right chid \\n                else if(node->val > parent->val){\\n                    //Also the min value in substree of current node should also be greater than value of parent node -> conditions of BST :)\\n                    if(range[node].F > parent->val){\\n                        parent->right=node;\\n                        //Update max value in subtree of parent node\\n                        range[parent].S= range[node].S;\\n                        //Increment the no of merges\\n                        merges++;\\n                    }\\n                    else\\n                        return NULL;\\n                }\\n                else{\\n                    return NULL;\\n                }\\n            }\\n            else{\\n                //It means the current node can be a potential candidate for root node of final BST\\n                if(root==NULL){\\n                    root=node;\\n                }\\n                //If multiple candidates available for root node of final BST just return NULL. We can\\'t form a valid BST\\n                else{\\n                    return NULL;\\n                }\\n            }\\n        }\\n        //Check whether the tree formed is BST or not\\n        if(!check(root,INT_MIN,INT_MAX)){\\n            return NULL;\\n        }\\n        //If the tree formed is BST,then check whether the no of merges is n-1 i.e  it is possible to form a valid BST after performing strictly n-1 operations, \\n        \\n        return (merges == (int)trees.size()-1 ? root:NULL);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358695,
                "title": "don-t-think-too-much-c-time-o-n-space-o-n",
                "content": "# Intuition : Go in flow\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDo what we do with separate nodes to make binary search tree.\\n\\n\\n# Approach : Brute force\\n<!-- Describe your approach to solving the problem. -->\\n> 1. Check the size of trees array if its 1 then just check that tree is `validBST` or not and return root;\\n> 2. Collect all the node in map except root of each tree in `val -> nodeAddress`.\\n> 3. Now create `root variable` with value `null` and loop through all tree heads. if that head value exist in map then update that values address with head address. \\n> 4. if not in map then store in `created root variable and check root should be assigned exactly 1 time if not then return null`.\\n> 5. Its time to make tree from root since we have collected correct value with node address in map.\\n> 6. Go through `makeTree` DFS function with root if left & right of node is null and that is exist in map  then update that address and `count++`.\\n> 7. if count and size of map is not same then return null.\\n> 8. Now, check `root is validBST or not` with [98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/).\\n---\\n# Note : Corner cases steps\\n- Step 1 for only 1 tree in array\\n- Step 4 for completely diffrent trees that never match\\n- Step 7 loop between trees like tree1: [1, 2] and tree2: [2, 1]\\n\\n\\n\\n# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\n    void collectNodes(unordered_map<int, TreeNode*>& mp, TreeNode* node) {\\n\\n        if(!node) return;\\n        mp[node->val] = node;\\n        collectNodes(mp, node->left);\\n        collectNodes(mp, node->right);\\n    }\\n\\n    void makeTree(unordered_map<int, TreeNode*>& mp, TreeNode*& node, int& cnt) {\\n\\n        if(!node) return;\\n        if(!node->left && !node->right && mp[node->val]) {\\n            node = mp[node->val];\\n            mp[node->val] = NULL;\\n            cnt++;\\n        }\\n        makeTree(mp, node->left, cnt);\\n        makeTree(mp, node->right, cnt);\\n    }\\n    \\n    bool validateBST(TreeNode* root, TreeNode* low, TreeNode* high) {\\n        \\n        if(!root) return true;\\n        if((low && root->val <= low->val) || \\n           (high && root->val >= high->val)) return false;\\n        \\n        return validateBST(root->left, low, root) && \\n                validateBST(root->right, root, high);\\n    }\\n\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        \\n        if(trees.size() == 1) {\\n            return validateBST(trees[0], NULL, NULL) ? trees[0] : NULL;\\n        }\\n\\n        unordered_map<int, TreeNode*> mp;\\n        for(auto& node: trees) {\\n            collectNodes(mp, node->left);\\n            collectNodes(mp, node->right);\\n        }\\n\\n        TreeNode* root = NULL;\\n        for(auto& node: trees) {\\n            if(mp.count(node->val)) mp[node->val] = node;\\n            else if(root) return NULL;\\n            else root = node;\\n        }\\n\\n        if(!root) return NULL;\\n\\n        int cnt = 0;\\n        makeTree(mp, root, cnt);\\n        if(cnt != mp.size()) return NULL;\\n        \\n        return validateBST(root, NULL, NULL) ? root : NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\n    void collectNodes(unordered_map<int, TreeNode*>& mp, TreeNode* node) {\\n\\n        if(!node) return;\\n        mp[node->val] = node;\\n        collectNodes(mp, node->left);\\n        collectNodes(mp, node->right);\\n    }\\n\\n    void makeTree(unordered_map<int, TreeNode*>& mp, TreeNode*& node, int& cnt) {\\n\\n        if(!node) return;\\n        if(!node->left && !node->right && mp[node->val]) {\\n            node = mp[node->val];\\n            mp[node->val] = NULL;\\n            cnt++;\\n        }\\n        makeTree(mp, node->left, cnt);\\n        makeTree(mp, node->right, cnt);\\n    }\\n    \\n    bool validateBST(TreeNode* root, TreeNode* low, TreeNode* high) {\\n        \\n        if(!root) return true;\\n        if((low && root->val <= low->val) || \\n           (high && root->val >= high->val)) return false;\\n        \\n        return validateBST(root->left, low, root) && \\n                validateBST(root->right, root, high);\\n    }\\n\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        \\n        if(trees.size() == 1) {\\n            return validateBST(trees[0], NULL, NULL) ? trees[0] : NULL;\\n        }\\n\\n        unordered_map<int, TreeNode*> mp;\\n        for(auto& node: trees) {\\n            collectNodes(mp, node->left);\\n            collectNodes(mp, node->right);\\n        }\\n\\n        TreeNode* root = NULL;\\n        for(auto& node: trees) {\\n            if(mp.count(node->val)) mp[node->val] = node;\\n            else if(root) return NULL;\\n            else root = node;\\n        }\\n\\n        if(!root) return NULL;\\n\\n        int cnt = 0;\\n        makeTree(mp, root, cnt);\\n        if(cnt != mp.size()) return NULL;\\n        \\n        return validateBST(root, NULL, NULL) ? root : NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433286,
                "title": "java-o-n-solution",
                "content": "```\\npublic class Solution {\\n\\tpublic TreeNode canMerge(List<TreeNode> trees) {\\n        final int size = trees.size();\\n        final Map<Integer, TreeNode> roots = new HashMap<>(size);\\n        for (final TreeNode node : trees) {\\n            roots.put(node.val, node);\\n        }\\n        for (final TreeNode node : trees) {\\n            if (roots.containsKey(node.val)) {\\n                final TreeNode root = buildTree(roots, node);\\n                roots.put(root.val, root);\\n            }\\n        }\\n        if (roots.size() != 1) return null;\\n        final TreeNode root = roots.values().iterator().next();\\n        return isValid(root, Integer.MIN_VALUE, Integer.MAX_VALUE) ? root : null;\\n    }\\n\\n    private TreeNode buildTree(Map<Integer, TreeNode> roots, TreeNode node) {\\n        final TreeNode next = roots.remove(node.val);\\n        if (next != null) {\\n            if (next.left != null) node.left = buildTree(roots, next.left);\\n            if (next.right != null) node.right = buildTree(roots, next.right);\\n        }\\n        return node;\\n    }\\n\\n    private boolean isValid(TreeNode node, int min, int max) {\\n        if (node == null) return true;\\n        final int value = node.val;\\n        if (value <= min || max <= value) return false;\\n        return isValid(node.left, min, value) && isValid(node.right, value, max);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\tpublic TreeNode canMerge(List<TreeNode> trees) {\\n        final int size = trees.size();\\n        final Map<Integer, TreeNode> roots = new HashMap<>(size);\\n        for (final TreeNode node : trees) {\\n            roots.put(node.val, node);\\n        }\\n        for (final TreeNode node : trees) {\\n            if (roots.containsKey(node.val)) {\\n                final TreeNode root = buildTree(roots, node);\\n                roots.put(root.val, root);\\n            }\\n        }\\n        if (roots.size() != 1) return null;\\n        final TreeNode root = roots.values().iterator().next();\\n        return isValid(root, Integer.MIN_VALUE, Integer.MAX_VALUE) ? root : null;\\n    }\\n\\n    private TreeNode buildTree(Map<Integer, TreeNode> roots, TreeNode node) {\\n        final TreeNode next = roots.remove(node.val);\\n        if (next != null) {\\n            if (next.left != null) node.left = buildTree(roots, next.left);\\n            if (next.right != null) node.right = buildTree(roots, next.right);\\n        }\\n        return node;\\n    }\\n\\n    private boolean isValid(TreeNode node, int min, int max) {\\n        if (node == null) return true;\\n        final int value = node.val;\\n        if (value <= min || max <= value) return false;\\n        return isValid(node.left, min, value) && isValid(node.right, value, max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331994,
                "title": "two-dfs",
                "content": "Let us call the input trees small trees, and the final BST the big tree.\\n\\nOne insight is that there can only be one such small tree that can be the topmost small tree in the final big tree . Because in the final big tree, except the topmost small tree, all other trees\\' root values appear in some leaves of other small trees. So if there exists a final big tree, then there is one and only one small tree whose root value is unique. This is a necessary condition. \\n\\nWe use two DFS. The 1st DFS writes down all leaves\\' occurrences, and use this info the decide which small tree is the topmost one. Then we use the second DFS to traverse and stitch the final tree at the same time.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        for (TreeNode* tree : trees) {\\n            roots[tree->val] = tree;\\n            dfs1(tree);\\n        }\\n        int rootVal = -1;\\n        for (auto [val, root] : roots) {\\n            if (leaves[val] == (root->left || root->right ? 0 : 1)) {\\n                if (rootVal == -1) {\\n                    rootVal = val;\\n                } else {\\n                    return nullptr;\\n                }\\n            }\\n        }\\n        if (rootVal == -1) {\\n            return nullptr;\\n        }\\n        TreeNode* ans = roots[rootVal];\\n        bool valid = dfs2(ans, INT_MIN, INT_MAX);\\n        return roots.size() == 1 && valid ? ans : nullptr;\\n    }\\n    \\nprivate:\\n    void dfs1(TreeNode* root) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        if (root->left == nullptr && root->right == nullptr) {\\n            ++leaves[root->val];\\n            return;\\n        }\\n        dfs1(root->left);\\n        dfs1(root->right);\\n    }\\n    bool dfs2(TreeNode* root, int l, int r) {\\n        assert(root != nullptr);\\n        if (root->val <= l || root->val >= r) {\\n            return false;\\n        }\\n        if (root->left == nullptr && root->right == nullptr) {\\n            if (auto iter = roots.find(root->val); iter != roots.end() && iter->second != root) {\\n                root->left = iter->second->left;\\n                root->right = iter->second->right;\\n                roots.erase(iter);\\n            }\\n        }\\n        if (root->left) {\\n            if (!dfs2(root->left, l, root->val)) {\\n                return false;\\n            }\\n        }\\n        if (root->right) {\\n            if (!dfs2(root->right, root->val, r)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    unordered_map<int, TreeNode*> roots;\\n    unordered_map<int, int> leaves;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        for (TreeNode* tree : trees) {\\n            roots[tree->val] = tree;\\n            dfs1(tree);\\n        }\\n        int rootVal = -1;\\n        for (auto [val, root] : roots) {\\n            if (leaves[val] == (root->left || root->right ? 0 : 1)) {\\n                if (rootVal == -1) {\\n                    rootVal = val;\\n                } else {\\n                    return nullptr;\\n                }\\n            }\\n        }\\n        if (rootVal == -1) {\\n            return nullptr;\\n        }\\n        TreeNode* ans = roots[rootVal];\\n        bool valid = dfs2(ans, INT_MIN, INT_MAX);\\n        return roots.size() == 1 && valid ? ans : nullptr;\\n    }\\n    \\nprivate:\\n    void dfs1(TreeNode* root) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        if (root->left == nullptr && root->right == nullptr) {\\n            ++leaves[root->val];\\n            return;\\n        }\\n        dfs1(root->left);\\n        dfs1(root->right);\\n    }\\n    bool dfs2(TreeNode* root, int l, int r) {\\n        assert(root != nullptr);\\n        if (root->val <= l || root->val >= r) {\\n            return false;\\n        }\\n        if (root->left == nullptr && root->right == nullptr) {\\n            if (auto iter = roots.find(root->val); iter != roots.end() && iter->second != root) {\\n                root->left = iter->second->left;\\n                root->right = iter->second->right;\\n                roots.erase(iter);\\n            }\\n        }\\n        if (root->left) {\\n            if (!dfs2(root->left, l, root->val)) {\\n                return false;\\n            }\\n        }\\n        if (root->right) {\\n            if (!dfs2(root->right, root->val, r)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    unordered_map<int, TreeNode*> roots;\\n    unordered_map<int, int> leaves;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330153,
                "title": "python-there-is-at-most-one-way-to-merge",
                "content": "**Explanation**\\n\\nThe fact that this is a strict BST, and we want all values to be distinct, makes our job much, much easier. This means that for each value v we find in any tree, there are two options:\\n1. v appears exactly once ever, or\\n2. v appears exactly twice: once as a root, and once as a leaf.\\n\\nThis means there is at most one way to merge the trees together. We want to process all of our trees, storing root values and child values in dictionaries and checking conflicts (values that are duplicated, but not in one of the two cases above). At the end, we try to merge all of our trees by repeatedly selecting any root and moving it to its final destination. We return true if we succeeded (i.e. if we have a valid BST, of the correct expected size).\\n\\n**Complexity**\\nTime and space complexity: `O(n)`. The code is also quite fast, since we try to break as quickly as possible if we see that we can\\'t merge the trees.\\n\\n**Python**\\n\\n```\\nclass Solution:\\n\\tdef canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n\\t\\tn = len(trees)\\n\\t\\tif n == 1: return trees[0]\\n\\n\\t\\tvalue_to_root = {}  # Map each integer root value to its node\\n\\t\\tappeared_as_middle_child = set()  # All values appearing in trees but not in a curr or leaf\\n\\t\\tself.saw_conflict = False  # If this is ever true, break out of function and return None\\n\\t\\tleaf_value_to_parent_node = {}\\n\\n\\t\\tdef is_leaf_node(curr: TreeNode) -> bool:\\n\\t\\t\\treturn curr.left is None and curr.right is None\\n\\n\\t\\tdef get_size(curr: TreeNode) -> int:  # DFS to count Binary Tree Size\\n\\t\\t\\tif curr is None: return 0\\n\\t\\t\\treturn 1 + get_size(curr.left) + get_size(curr.right)\\n\\n\\t\\tdef is_valid_bst(curr: TreeNode, lo=-math.inf, hi=math.inf) -> bool:  # Standard BST validation code\\n\\t\\t\\tif curr is None: return True\\n\\t\\t\\treturn all((lo < curr.val < hi,\\n\\t\\t\\t\\t\\t\\tis_valid_bst(curr.left, lo, curr.val),\\n\\t\\t\\t\\t\\t\\tis_valid_bst(curr.right, curr.val, hi)))\\n\\n\\t\\tdef process_child(child_node: TreeNode, parent: TreeNode) -> None:\\n\\t\\t\\tif child_node is None:\\n\\t\\t\\t\\treturn None\\n\\t\\t\\telif child_node.val in leaf_value_to_parent_node or child_node.val in appeared_as_middle_child:\\n\\t\\t\\t\\tself.saw_conflict = True  # Already saw this child node\\'s value in a non-root node\\n\\t\\t\\telif is_leaf_node(child_node):\\n\\t\\t\\t\\tleaf_value_to_parent_node[child_node.val] = parent\\n\\t\\t\\telif child_node.val in value_to_root:\\n\\t\\t\\t\\tself.saw_conflict = True\\n\\t\\t\\telse:\\n\\t\\t\\t\\tappeared_as_middle_child.add(child_node.val)\\n\\t\\t\\t\\tprocess_child(child_node.left, child_node)\\n\\t\\t\\t\\tprocess_child(child_node.right, child_node)\\n\\n\\t\\tdef process_root(curr_root: TreeNode) -> None:\\n\\t\\t\\tvalue_to_root[curr_root.val] = curr_root\\n\\n\\t\\t\\tif curr_root.val in appeared_as_middle_child:\\n\\t\\t\\t\\tself.saw_conflict = True\\n\\t\\t\\telse:\\n\\t\\t\\t\\tprocess_child(curr_root.left, curr_root)\\n\\t\\t\\t\\tprocess_child(curr_root.right, curr_root)\\n\\n\\t\\tfor root_here in trees:\\n\\t\\t\\tprocess_root(root_here)\\n\\t\\t\\tif self.saw_conflict: return None\\n\\n\\t\\tfinal_expected_size = len(leaf_value_to_parent_node) + len(appeared_as_middle_child) + 1\\n\\n\\t\\tfinal_root = None  # The root of our final BST will be stored here\\n\\t\\twhile value_to_root:\\n\\t\\t\\troot_val, root_node_to_move = value_to_root.popitem()\\n\\n\\t\\t\\tif root_val not in leaf_value_to_parent_node:  # Possibly found main root\\n\\t\\t\\t\\tif final_root is None:\\n\\t\\t\\t\\t\\tfinal_root = root_node_to_move\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn None  # Found two main roots\\n\\t\\t\\telse:\\n\\t\\t\\t\\tnew_parent = leaf_value_to_parent_node.pop(root_val)\\n\\t\\t\\t\\tif new_parent.left is not None and new_parent.left.val == root_val:\\n\\t\\t\\t\\t\\tnew_parent.left = root_node_to_move\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telif new_parent.right is not None and new_parent.right.val == root_val:\\n\\t\\t\\t\\t\\tnew_parent.right = root_node_to_move\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn None  # Didn\\'t find a place to put this node\\n\\n\\t\\t# Didn\\'t find any candidates for main root, or have a cycle, or didn\\'t use all trees\\n\\t\\tif final_root is None or not is_valid_bst(final_root) or get_size(final_root) != final_expected_size:\\n\\t\\t\\treturn None\\n\\n\\t\\treturn final_root\\n```\\n\\nEdit: Most of the code is broken up into useful chunks of helper functions. This code also works with arbitrary BST\\'s of any size. Since the problem statement is currently a bit unclear about whether a 3-node, one-leaf BST is a valid input, the current code should still AC if the problem does get modified.\\n\\nAlso, a big thanks to @yaroslav-repeta for critiques on the code style.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n\\tdef canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n\\t\\tn = len(trees)\\n\\t\\tif n == 1: return trees[0]\\n\\n\\t\\tvalue_to_root = {}  # Map each integer root value to its node\\n\\t\\tappeared_as_middle_child = set()  # All values appearing in trees but not in a curr or leaf\\n\\t\\tself.saw_conflict = False  # If this is ever true, break out of function and return None\\n\\t\\tleaf_value_to_parent_node = {}\\n\\n\\t\\tdef is_leaf_node(curr: TreeNode) -> bool:\\n\\t\\t\\treturn curr.left is None and curr.right is None\\n\\n\\t\\tdef get_size(curr: TreeNode) -> int:  # DFS to count Binary Tree Size\\n\\t\\t\\tif curr is None: return 0\\n\\t\\t\\treturn 1 + get_size(curr.left) + get_size(curr.right)\\n\\n\\t\\tdef is_valid_bst(curr: TreeNode, lo=-math.inf, hi=math.inf) -> bool:  # Standard BST validation code\\n\\t\\t\\tif curr is None: return True\\n\\t\\t\\treturn all((lo < curr.val < hi,\\n\\t\\t\\t\\t\\t\\tis_valid_bst(curr.left, lo, curr.val),\\n\\t\\t\\t\\t\\t\\tis_valid_bst(curr.right, curr.val, hi)))\\n\\n\\t\\tdef process_child(child_node: TreeNode, parent: TreeNode) -> None:\\n\\t\\t\\tif child_node is None:\\n\\t\\t\\t\\treturn None\\n\\t\\t\\telif child_node.val in leaf_value_to_parent_node or child_node.val in appeared_as_middle_child:\\n\\t\\t\\t\\tself.saw_conflict = True  # Already saw this child node\\'s value in a non-root node\\n\\t\\t\\telif is_leaf_node(child_node):\\n\\t\\t\\t\\tleaf_value_to_parent_node[child_node.val] = parent\\n\\t\\t\\telif child_node.val in value_to_root:\\n\\t\\t\\t\\tself.saw_conflict = True\\n\\t\\t\\telse:\\n\\t\\t\\t\\tappeared_as_middle_child.add(child_node.val)\\n\\t\\t\\t\\tprocess_child(child_node.left, child_node)\\n\\t\\t\\t\\tprocess_child(child_node.right, child_node)\\n\\n\\t\\tdef process_root(curr_root: TreeNode) -> None:\\n\\t\\t\\tvalue_to_root[curr_root.val] = curr_root\\n\\n\\t\\t\\tif curr_root.val in appeared_as_middle_child:\\n\\t\\t\\t\\tself.saw_conflict = True\\n\\t\\t\\telse:\\n\\t\\t\\t\\tprocess_child(curr_root.left, curr_root)\\n\\t\\t\\t\\tprocess_child(curr_root.right, curr_root)\\n\\n\\t\\tfor root_here in trees:\\n\\t\\t\\tprocess_root(root_here)\\n\\t\\t\\tif self.saw_conflict: return None\\n\\n\\t\\tfinal_expected_size = len(leaf_value_to_parent_node) + len(appeared_as_middle_child) + 1\\n\\n\\t\\tfinal_root = None  # The root of our final BST will be stored here\\n\\t\\twhile value_to_root:\\n\\t\\t\\troot_val, root_node_to_move = value_to_root.popitem()\\n\\n\\t\\t\\tif root_val not in leaf_value_to_parent_node:  # Possibly found main root\\n\\t\\t\\t\\tif final_root is None:\\n\\t\\t\\t\\t\\tfinal_root = root_node_to_move\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn None  # Found two main roots\\n\\t\\t\\telse:\\n\\t\\t\\t\\tnew_parent = leaf_value_to_parent_node.pop(root_val)\\n\\t\\t\\t\\tif new_parent.left is not None and new_parent.left.val == root_val:\\n\\t\\t\\t\\t\\tnew_parent.left = root_node_to_move\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telif new_parent.right is not None and new_parent.right.val == root_val:\\n\\t\\t\\t\\t\\tnew_parent.right = root_node_to_move\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn None  # Didn\\'t find a place to put this node\\n\\n\\t\\t# Didn\\'t find any candidates for main root, or have a cycle, or didn\\'t use all trees\\n\\t\\tif final_root is None or not is_valid_bst(final_root) or get_size(final_root) != final_expected_size:\\n\\t\\t\\treturn None\\n\\n\\t\\treturn final_root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561451,
                "title": "python-solution-beats-100-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n\\n        leaves = set()\\n        treeDict = {}\\n\\n        for tree in trees:\\n            treeDict[tree.val]=tree\\n            if tree.left:\\n                leaves.add(tree.left.val)\\n            if tree.right:\\n                leaves.add(tree.right.val)\\n\\n        root=None\\n\\n        for tree in trees:\\n            if tree.val not in leaves:\\n                root = tree\\n                break\\n        \\n        if not root:\\n            return None\\n        \\n        curleaves = {}\\n        if root.left:\\n            curleaves[root.left.val] = (-sys.maxsize,root.val,root,0)\\n\\n        if root.right:\\n            curleaves[root.right.val] = (root.val,sys.maxsize,root,1)\\n\\n        del treeDict[root.val]\\n\\n        while treeDict:\\n            findTree = False\\n            for leaf,(low,high,par,lor) in curleaves.items():\\n                if leaf in treeDict:\\n                    newTree = treeDict[leaf]\\n                    del curleaves[leaf]\\n\\n                    if newTree.left:\\n                        if low < newTree.left.val < high and newTree.left.val not in curleaves:\\n                            curleaves[newTree.left.val] = (low,newTree.val,newTree,0)\\n                        else:\\n                            return None\\n                    if newTree.right:\\n                        if low < newTree.right.val < high and newTree.right.val not in curleaves:\\n                            curleaves[newTree.right.val] = (newTree.val,high,newTree,1)\\n                        else:\\n                            return None\\n\\n                    if lor == 0:\\n                        par.left = newTree\\n                    else:\\n                        par.right = newTree\\n\\n                    findTree = True\\n                    del treeDict[newTree.val]\\n                    break\\n            if not findTree:\\n                return None\\n        return root\\n                    \\n             \\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n\\n        leaves = set()\\n        treeDict = {}\\n\\n        for tree in trees:\\n            treeDict[tree.val]=tree\\n            if tree.left:\\n                leaves.add(tree.left.val)\\n            if tree.right:\\n                leaves.add(tree.right.val)\\n\\n        root=None\\n\\n        for tree in trees:\\n            if tree.val not in leaves:\\n                root = tree\\n                break\\n        \\n        if not root:\\n            return None\\n        \\n        curleaves = {}\\n        if root.left:\\n            curleaves[root.left.val] = (-sys.maxsize,root.val,root,0)\\n\\n        if root.right:\\n            curleaves[root.right.val] = (root.val,sys.maxsize,root,1)\\n\\n        del treeDict[root.val]\\n\\n        while treeDict:\\n            findTree = False\\n            for leaf,(low,high,par,lor) in curleaves.items():\\n                if leaf in treeDict:\\n                    newTree = treeDict[leaf]\\n                    del curleaves[leaf]\\n\\n                    if newTree.left:\\n                        if low < newTree.left.val < high and newTree.left.val not in curleaves:\\n                            curleaves[newTree.left.val] = (low,newTree.val,newTree,0)\\n                        else:\\n                            return None\\n                    if newTree.right:\\n                        if low < newTree.right.val < high and newTree.right.val not in curleaves:\\n                            curleaves[newTree.right.val] = (newTree.val,high,newTree,1)\\n                        else:\\n                            return None\\n\\n                    if lor == 0:\\n                        par.left = newTree\\n                    else:\\n                        par.right = newTree\\n\\n                    findTree = True\\n                    del treeDict[newTree.val]\\n                    break\\n            if not findTree:\\n                return None\\n        return root\\n                    \\n             \\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709355,
                "title": "100-test-cases-passed-java-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> valToNode = new HashMap<>(); \\n    Map<Integer, Integer> count = new HashMap<>();      \\n\\n    for (TreeNode tree : trees) {\\n      valToNode.put(tree.val, tree);\\n      count.merge(tree.val, 1, Integer::sum);\\n      if (tree.left != null)\\n        count.merge(tree.left.val, 1, Integer::sum);\\n      if (tree.right != null)\\n        count.merge(tree.right.val, 1, Integer::sum);\\n    }\\n\\n    for (TreeNode tree : trees)\\n      if (count.get(tree.val) == 1) {\\n        if (isValidBST(tree, null, null, valToNode) && valToNode.size() <= 1)\\n          return tree;\\n        return null;\\n      }\\n\\n    return null;\\n  }\\n\\n  public boolean isValidBST(TreeNode tree, TreeNode minNode, TreeNode maxNode,\\n                             Map<Integer, TreeNode> valToNode) {\\n    if (tree == null)\\n      return true;\\n    if (minNode != null && tree.val <= minNode.val)\\n      return false;\\n    if (maxNode != null && tree.val >= maxNode.val)\\n      return false;\\n    if (tree.left == null && tree.right == null && valToNode.containsKey(tree.val)) {\\n      final int val = tree.val;\\n      tree.left = valToNode.get(val).left;\\n      tree.right = valToNode.get(val).right;\\n      valToNode.remove(val);\\n    }\\n\\n    return isValidBST(tree.left, minNode, tree, valToNode) &&\\n           isValidBST(tree.right, tree, maxNode, valToNode);\\n    }\\n}\\n    \\n\\n```",
                "solutionTags": [
                    "Array",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> valToNode = new HashMap<>(); \\n    Map<Integer, Integer> count = new HashMap<>();      \\n\\n    for (TreeNode tree : trees) {\\n      valToNode.put(tree.val, tree);\\n      count.merge(tree.val, 1, Integer::sum);\\n      if (tree.left != null)\\n        count.merge(tree.left.val, 1, Integer::sum);\\n      if (tree.right != null)\\n        count.merge(tree.right.val, 1, Integer::sum);\\n    }\\n\\n    for (TreeNode tree : trees)\\n      if (count.get(tree.val) == 1) {\\n        if (isValidBST(tree, null, null, valToNode) && valToNode.size() <= 1)\\n          return tree;\\n        return null;\\n      }\\n\\n    return null;\\n  }\\n\\n  public boolean isValidBST(TreeNode tree, TreeNode minNode, TreeNode maxNode,\\n                             Map<Integer, TreeNode> valToNode) {\\n    if (tree == null)\\n      return true;\\n    if (minNode != null && tree.val <= minNode.val)\\n      return false;\\n    if (maxNode != null && tree.val >= maxNode.val)\\n      return false;\\n    if (tree.left == null && tree.right == null && valToNode.containsKey(tree.val)) {\\n      final int val = tree.val;\\n      tree.left = valToNode.get(val).left;\\n      tree.right = valToNode.get(val).right;\\n      valToNode.remove(val);\\n    }\\n\\n    return isValidBST(tree.left, minNode, tree, valToNode) &&\\n           isValidBST(tree.right, tree, maxNode, valToNode);\\n    }\\n}\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347222,
                "title": "c-simple-hashmap-explained-with-comments",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    //checking validity of final BST\\n    //***************************************************************************************\\n    bool checkBST(TreeNode *root, int left=0, int right =50001){\\n        \\n        if(root==NULL) return true;\\n        if(root->val >= right || root->val <= left) return false;\\n        \\n        bool leftSide=checkBST(root->left,left,root->val);\\n        bool rightSide=checkBST(root->right,root->val,right);\\n        \\n        return leftSide && rightSide;\\n    }\\n    \\n    \\n    \\n    //are all the trees placed in main bst?\\n    //***************************************************************************************\\n    bool allTreesPlaced(unordered_map<int,TreeNode*> &nodes, vector<TreeNode*>& trees){\\n        \\n        \\n        for(auto &itr : trees){\\n            if(nodes[itr->val]!=NULL) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    \\n    \\n    //to merge into bst of found parent root\\n    //***************************************************************************************\\n    void merge(TreeNode *root, unordered_map<int,TreeNode*> &umap){\\n        \\n        if(root==NULL) return;\\n        \\n        //in left\\n        if(root->left){\\n            //if it is to be replaced\\n            if(umap[root->left->val]!=NULL){\\n                root->left=umap[root->left->val];\\n                umap[root->left->val]=NULL; //once found its place remove\\n            }\\n        }\\n        \\n        //in right\\n        if(root->right){\\n            //if it is to be replaced\\n            if(umap[root->right->val]!=NULL){\\n                root->right=umap[root->right->val];\\n                umap[root->right->val]=NULL; //once found its place remove\\n            }\\n        }\\n        \\n        \\n        //repeat for children\\n        merge(root->left,umap);\\n        merge(root->right,umap);\\n        \\n        return;\\n    }\\n    \\n    \\n   \\n    //to find if can merge\\n    //if can do it\\n    //else send NULL\\n    //***************************************************************************************\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        \\n        \\n        \\n        \\n        //find start of final bst\\n        unordered_map<int,int> umap;\\n        \\n        for(auto &itr : trees){\\n            umap[itr->val]++;\\n            if(itr->left !=NULL) umap[itr->left->val]++;\\n            if(itr->right !=NULL) umap[itr->right->val]++;\\n       }\\n        \\n        TreeNode *root=NULL;\\n        for(auto &itr : trees){\\n            \\n            if(umap[itr->val]==1){\\n                if(root!=NULL) return NULL;\\n                root=itr;\\n            }\\n            \\n        }\\n        if(root==NULL) return NULL;\\n        \\n        \\n        \\n        \\n        \\n        //all nodes to be placed in root;\\n        unordered_map<int,TreeNode*> umap2;\\n        for(auto &itr : trees){\\n            umap2[itr->val]=itr;\\n        }\\n        umap2[root->val]=NULL;  //removed root one from to be placed ones\\n        merge(root,umap2);\\n        \\n        \\n        \\n        \\n        \\n        //if all not found place invalid\\n        if(!allTreesPlaced(umap2,trees)) return NULL;\\n        \\n        \\n        \\n        \\n        \\n        //check final BST valid or not\\n        if(!checkBST(root)) return NULL;\\n        \\n        \\n        \\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    //checking validity of final BST\\n    //***************************************************************************************\\n    bool checkBST(TreeNode *root, int left=0, int right =50001){\\n        \\n        if(root==NULL) return true;\\n        if(root->val >= right || root->val <= left) return false;\\n        \\n        bool leftSide=checkBST(root->left,left,root->val);\\n        bool rightSide=checkBST(root->right,root->val,right);\\n        \\n        return leftSide && rightSide;\\n    }\\n    \\n    \\n    \\n    //are all the trees placed in main bst?\\n    //***************************************************************************************\\n    bool allTreesPlaced(unordered_map<int,TreeNode*> &nodes, vector<TreeNode*>& trees){\\n        \\n        \\n        for(auto &itr : trees){\\n            if(nodes[itr->val]!=NULL) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    \\n    \\n    //to merge into bst of found parent root\\n    //***************************************************************************************\\n    void merge(TreeNode *root, unordered_map<int,TreeNode*> &umap){\\n        \\n        if(root==NULL) return;\\n        \\n        //in left\\n        if(root->left){\\n            //if it is to be replaced\\n            if(umap[root->left->val]!=NULL){\\n                root->left=umap[root->left->val];\\n                umap[root->left->val]=NULL; //once found its place remove\\n            }\\n        }\\n        \\n        //in right\\n        if(root->right){\\n            //if it is to be replaced\\n            if(umap[root->right->val]!=NULL){\\n                root->right=umap[root->right->val];\\n                umap[root->right->val]=NULL; //once found its place remove\\n            }\\n        }\\n        \\n        \\n        //repeat for children\\n        merge(root->left,umap);\\n        merge(root->right,umap);\\n        \\n        return;\\n    }\\n    \\n    \\n   \\n    //to find if can merge\\n    //if can do it\\n    //else send NULL\\n    //***************************************************************************************\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        \\n        \\n        \\n        \\n        //find start of final bst\\n        unordered_map<int,int> umap;\\n        \\n        for(auto &itr : trees){\\n            umap[itr->val]++;\\n            if(itr->left !=NULL) umap[itr->left->val]++;\\n            if(itr->right !=NULL) umap[itr->right->val]++;\\n       }\\n        \\n        TreeNode *root=NULL;\\n        for(auto &itr : trees){\\n            \\n            if(umap[itr->val]==1){\\n                if(root!=NULL) return NULL;\\n                root=itr;\\n            }\\n            \\n        }\\n        if(root==NULL) return NULL;\\n        \\n        \\n        \\n        \\n        \\n        //all nodes to be placed in root;\\n        unordered_map<int,TreeNode*> umap2;\\n        for(auto &itr : trees){\\n            umap2[itr->val]=itr;\\n        }\\n        umap2[root->val]=NULL;  //removed root one from to be placed ones\\n        merge(root,umap2);\\n        \\n        \\n        \\n        \\n        \\n        //if all not found place invalid\\n        if(!allTreesPlaced(umap2,trees)) return NULL;\\n        \\n        \\n        \\n        \\n        \\n        //check final BST valid or not\\n        if(!checkBST(root)) return NULL;\\n        \\n        \\n        \\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824005,
                "title": "c-one-map-for-root-one-set-for-leaf",
                "content": "class Solution {\\npublic:\\n    unordered_map<int, TreeNode*> rootmap;\\n    unordered_set<int> leafmap;\\n  \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n      \\n        for(auto it : trees) {\\n            rootmap[it->val] = it;\\n            if(it->left)\\n                leafmap.insert(it->left->val);\\n            if(it->right)\\n                leafmap.insert(it->right->val);\\n        }\\n        TreeNode* root = nullptr;\\n        for(auto it : trees) {\\n            if(leafmap.find(it->val) == leafmap.end())\\n                root = it;\\n        }\\n        if(helper(root, INT_MIN, INT_MAX)) {\\n            if(rootmap.size() == 1)\\n                return root;\\n        }\\n        return nullptr;\\n    }\\n    \\n    bool helper(TreeNode* root, int low, int high) {\\n        if(!root)\\n            return true;\\n        if(root->val >= high || root->val <= low)\\n            return false;    \\n        if(root->left) {\\n            int cur = root->left->val;\\n            if(rootmap.find(cur) != rootmap.end()) {\\n                root->left = rootmap[cur];\\n                rootmap.erase(cur);\\n            }\\n        }\\n        \\n        if(root->right) {\\n            int cur = root->right->val;\\n            if(rootmap.find(cur) != rootmap.end()) {\\n                root->right = rootmap[cur];\\n                rootmap.erase(cur);\\n            }            \\n        }\\n        \\n         if(!helper(root->left, low, root->val))\\n            return false;\\n        \\n        if(!helper(root->right, root->val, high))\\n            return false;\\n        \\n     \\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    unordered_map<int, TreeNode*> rootmap;\\n    unordered_set<int> leafmap;\\n  \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n      \\n        for(auto it : trees) {\\n            rootmap[it->val] = it;\\n            if(it->left)\\n                leafmap.insert(it->left->val);\\n            if(it->right)\\n                leafmap.insert(it->right->val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1805468,
                "title": "c",
                "content": "\\'\\'\\'\\'class Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        set<int> temp;\\n        vector<int> temp2;\\n        for(int i=0;i<trees.size();i++)\\n        {   \\n           \\n             inorder(trees[i],temp);\\n        }\\n        for(auto c:temp)\\n        {\\n            temp2.push_back(c);\\n        }\\n        if(temp2.size()==0)return nullptr;\\n      TreeNode* root1=  convertToBST(temp2,0,temp2.size()-1);\\n        return root1;\\n        \\n    }\\n    void inorder(TreeNode* root,set<int>& temp)\\n    {\\n          if(root==NULL)return;\\n         inorder(root->left,temp);\\n        temp.insert(root->val);\\n        inorder(root->right,temp);\\n        \\n    }\\n    TreeNode* convertToBST(vector<int>& temp2,int low,int high)\\n    {\\n        if(low>high)\\n            return nullptr;\\n        int mid=(low+high)/2;\\n        TreeNode* root=new TreeNode(temp2[mid]);\\n        TreeNode* ltree=convertToBST(temp2,low,mid-1);\\n        TreeNode* rtree=convertToBST(temp2,mid+1,high);\\n        root->left=ltree;\\n        root->right=rtree;\\n        return root;\\n    }\\n};\\'\\'\\'\\'\\'\\n\\nPlease suggest ,what i am doing wrong here",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        set<int> temp;\\n        vector<int> temp2;\\n        for(int i=0;i<trees.size();i++)\\n        {   \\n           \\n             inorder(trees[i],temp);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1757102,
                "title": "python-a-tale-of-2-dicts-simple-dfs",
                "content": "Check for multiple root trees when done merging with DFS.\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def __init__(self):\\n        self.roots = {}\\n        self.leaves = {}\\n        \\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        for tree in trees:\\n            self.generate_roots_and_leaves(tree)\\n        start = set(self.roots.keys()) - set(self.leaves.keys())\\n\\t\\t\\n\\t\\t# Check only 1 starting root else disjointed\\n        if len(start) != 1:\\n            return None\\n\\t\\t\\t\\n        start = self.roots[next(iter(start))]\\n        root = self.dfs(start)\\n        return root if len(self.roots) == 1 and self.is_valid_tree(root, float(\"inf\"), float(\"-inf\")) else None\\n\\n    def is_valid_tree(self, node, max_left, min_right):\\n        if node:\\n            if node.val < max_left and node.val > min_right:\\n                return all([self.is_valid_tree(node.left, min(node.val, max_left), min_right), self.is_valid_tree(node.right, max_left, max(min_right, node.val))])\\n            else:\\n                return False\\n        return True\\n           \\n    def generate_roots_and_leaves(self, tree):\\n        self.roots[tree.val] = tree\\n\\n        if tree.left:\\n            self.leaves[tree.left.val] = tree.left\\n        if tree.right:\\n            self.leaves[tree.right.val] = tree.right\\n            \\n    def dfs(self, tree):\\n        if tree:\\n            if tree.left and tree.left.val in self.roots:\\n                tree.left = self.roots[tree.left.val]\\n                del(self.roots[tree.left.val])\\n                self.dfs(tree.left)\\n\\n            if tree.right and tree.right.val in self.roots:\\n                tree.right = self.roots[tree.right.val]\\n                del(self.roots[tree.right.val])\\n                self.dfs(tree.right)\\n\\n        return tree\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def __init__(self):\\n        self.roots = {}\\n        self.leaves = {}\\n        \\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        for tree in trees:\\n            self.generate_roots_and_leaves(tree)\\n        start = set(self.roots.keys()) - set(self.leaves.keys())\\n\\t\\t\\n\\t\\t# Check only 1 starting root else disjointed\\n        if len(start) != 1:\\n            return None\\n\\t\\t\\t\\n        start = self.roots[next(iter(start))]\\n        root = self.dfs(start)\\n        return root if len(self.roots) == 1 and self.is_valid_tree(root, float(\"inf\"), float(\"-inf\")) else None\\n\\n    def is_valid_tree(self, node, max_left, min_right):\\n        if node:\\n            if node.val < max_left and node.val > min_right:\\n                return all([self.is_valid_tree(node.left, min(node.val, max_left), min_right), self.is_valid_tree(node.right, max_left, max(min_right, node.val))])\\n            else:\\n                return False\\n        return True\\n           \\n    def generate_roots_and_leaves(self, tree):\\n        self.roots[tree.val] = tree\\n\\n        if tree.left:\\n            self.leaves[tree.left.val] = tree.left\\n        if tree.right:\\n            self.leaves[tree.right.val] = tree.right\\n            \\n    def dfs(self, tree):\\n        if tree:\\n            if tree.left and tree.left.val in self.roots:\\n                tree.left = self.roots[tree.left.val]\\n                del(self.roots[tree.left.val])\\n                self.dfs(tree.left)\\n\\n            if tree.right and tree.right.val in self.roots:\\n                tree.right = self.roots[tree.right.val]\\n                del(self.roots[tree.right.val])\\n                self.dfs(tree.right)\\n\\n        return tree\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1689069,
                "title": "using-two-hashmaps-roots-and-leaves",
                "content": "Idea is to use two hashmaps - \\n1. to store all the roots\\n2. to store all the leaf openings\\n\\nAfter this we can just scan through our trees and find if there are any openings. If we do, connect them together. We then also update our hashmaps by removing the opening as well as the root that got merged.\\n\\nFinally, we check whether the final remaining roots are only 1, and a valid BST. We also match the sizes as there were some test cases that had created cycles.\\n\\n```\\nclass Solution {\\n    Map<Integer, TreeNode> rootLookup;\\n    Map<String, TreeNode> openings;\\n\\n    private Map<Integer, TreeNode> buildLookup(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> lookup = new HashMap<>();\\n        for(TreeNode tree: trees) lookup.put(tree.val, tree);\\n        return lookup;\\n    }\\n    \\n    private Map<String, TreeNode> buildOpenings(List<TreeNode> trees) {\\n        Map<String, TreeNode> lookup = new HashMap<>();\\n        for(TreeNode tree: trees) {\\n            if(tree.left != null) lookup.put(tree.left.val + \"L\", tree);\\n            if(tree.right != null) lookup.put(tree.right.val + \"R\", tree);\\n        }\\n        return lookup;\\n    }\\n    \\n    private boolean isValidBST(TreeNode a, int min, int max) {\\n        if(a == null) return true;\\n        if(a.val <= min || a.val >= max) return false;\\n        return isValidBST(a.left, min, a.val) && isValidBST(a.right, a.val, max);\\n    }    \\n\\n    private TreeNode connectThemAll(List<TreeNode> trees, int expectedSize) {\\n        for(TreeNode tree: trees) {\\n            // meaning tree has already been merged\\n            if(!rootLookup.containsKey(tree.val)) continue;\\n            \\n            // check if there is any left leaf opening\\n            TreeNode leftChildOpening = openings.get(tree.val + \"L\");\\n            if(leftChildOpening != null) { \\n                leftChildOpening.left = tree; \\n                rootLookup.remove(tree.val);\\n                openings.remove(tree.val + \"L\");\\n                continue; \\n            }\\n            \\n            // check if there is any right leaf opening\\n            TreeNode rightChildOpening = openings.get(tree.val + \"R\");\\n            if(rightChildOpening != null) { \\n                rightChildOpening.right = tree; \\n                rootLookup.remove(tree.val);\\n                openings.remove(tree.val + \"R\");\\n                continue; \\n            }\\n        }\\n        \\n        if(rootLookup.size() != 1) return null;\\n        TreeNode root = rootLookup.entrySet().iterator().next().getValue();\\n        if(!isValidBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE)) return null;\\n        \\n        // due to cycles, we need to also check for the size\\n        if(size(root) != expectedSize) return null;\\n\\n        return root;\\n    }\\n    \\n    // calculate the size of the tree\\n    private int size(TreeNode curr) {\\n        if(curr == null) return 0;\\n        return size(curr.left) + size(curr.right) + 1;\\n    }\\n    \\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        rootLookup = buildLookup(trees);\\n        openings = buildOpenings(trees);\\n        Set<Integer> uniqueVals = new HashSet<>();\\n        for(TreeNode tree: trees) {\\n            uniqueVals.add(tree.val);\\n            if(tree.left != null) uniqueVals.add(tree.left.val);\\n            if(tree.right != null) uniqueVals.add(tree.right.val);\\n        }\\n        return connectThemAll(trees, uniqueVals.size());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, TreeNode> rootLookup;\\n    Map<String, TreeNode> openings;\\n\\n    private Map<Integer, TreeNode> buildLookup(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> lookup = new HashMap<>();\\n        for(TreeNode tree: trees) lookup.put(tree.val, tree);\\n        return lookup;\\n    }\\n    \\n    private Map<String, TreeNode> buildOpenings(List<TreeNode> trees) {\\n        Map<String, TreeNode> lookup = new HashMap<>();\\n        for(TreeNode tree: trees) {\\n            if(tree.left != null) lookup.put(tree.left.val + \"L\", tree);\\n            if(tree.right != null) lookup.put(tree.right.val + \"R\", tree);\\n        }\\n        return lookup;\\n    }\\n    \\n    private boolean isValidBST(TreeNode a, int min, int max) {\\n        if(a == null) return true;\\n        if(a.val <= min || a.val >= max) return false;\\n        return isValidBST(a.left, min, a.val) && isValidBST(a.right, a.val, max);\\n    }    \\n\\n    private TreeNode connectThemAll(List<TreeNode> trees, int expectedSize) {\\n        for(TreeNode tree: trees) {\\n            // meaning tree has already been merged\\n            if(!rootLookup.containsKey(tree.val)) continue;\\n            \\n            // check if there is any left leaf opening\\n            TreeNode leftChildOpening = openings.get(tree.val + \"L\");\\n            if(leftChildOpening != null) { \\n                leftChildOpening.left = tree; \\n                rootLookup.remove(tree.val);\\n                openings.remove(tree.val + \"L\");\\n                continue; \\n            }\\n            \\n            // check if there is any right leaf opening\\n            TreeNode rightChildOpening = openings.get(tree.val + \"R\");\\n            if(rightChildOpening != null) { \\n                rightChildOpening.right = tree; \\n                rootLookup.remove(tree.val);\\n                openings.remove(tree.val + \"R\");\\n                continue; \\n            }\\n        }\\n        \\n        if(rootLookup.size() != 1) return null;\\n        TreeNode root = rootLookup.entrySet().iterator().next().getValue();\\n        if(!isValidBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE)) return null;\\n        \\n        // due to cycles, we need to also check for the size\\n        if(size(root) != expectedSize) return null;\\n\\n        return root;\\n    }\\n    \\n    // calculate the size of the tree\\n    private int size(TreeNode curr) {\\n        if(curr == null) return 0;\\n        return size(curr.left) + size(curr.right) + 1;\\n    }\\n    \\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        rootLookup = buildLookup(trees);\\n        openings = buildOpenings(trees);\\n        Set<Integer> uniqueVals = new HashSet<>();\\n        for(TreeNode tree: trees) {\\n            uniqueVals.add(tree.val);\\n            if(tree.left != null) uniqueVals.add(tree.left.val);\\n            if(tree.right != null) uniqueVals.add(tree.right.val);\\n        }\\n        return connectThemAll(trees, uniqueVals.size());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411216,
                "title": "c-simple-approach-proof-based-explanation-code",
                "content": "\\n\\n**Important Observations**\\n1) **If any two leaves have same value, we can\\'t have a valid BST.**\\n\\tProof: Let say, two nodes, namely, node1 & node2 have same value.\\n\\t\\t\\t  WLOG, let node2 is in left subtree of node1. \\n\\t\\t\\t\\t  => node2->val < node1->val, \\n\\t\\t\\t\\t  {because left tree should contains nodes with strictly lesser value, according to the definition given in the question statement}\\n\\t\\t\\t\\t  => Thus, node2->val != node1->val (**Contradiction**)\\n\\n2) **There should be exactly one root, which does not have corresponding leaf node to merge with.**\\n\\tProof by contradiction: It we have two such roots, then we will have two head nodes of our merged BST, which is not possible.\\n\\t\\n\\n**Algorithm**\\n\\n1) Map root and leaf pointers to their values.\\n2) Find Head Node, and merge in arbitary order.\\n3) Check Validness of the BST\\n\\n\\n**Time Complexity**\\nO(m), where m is max tree node value. Here m<= 5*10^4.  \\nBut we can optimise it to O(n), where n is the number of tree nodes. Just use unordered_map instead of vectors root & leaf.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nint cnt = 0;\\nbool isValid(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) {\\n    if(!root) return true;\\n    cnt++;\\n    if(minNode && root->val <= minNode->val || maxNode && root->val >= maxNode->val)\\n        return false;\\n    return isValid(root->left, minNode, root) && isValid(root->right, root, maxNode);\\n}\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n = 0;\\n        vector<TreeNode*> root(50001, nullptr),leaf(50001, nullptr);\\n        for(auto ptr:trees){\\n            root[ptr->val] = ptr;\\n            n++;\\n            if(ptr->left) {\\n                n++;\\n                if(leaf[ptr->left->val]) return nullptr; //from observation 1\\n                leaf[ptr->left->val] = ptr->left;\\n            }\\n            \\n            if(ptr->right){\\n                n++;\\n                if(leaf[ptr->right->val]) return nullptr;  //from observation 1              \\n                leaf[ptr->right->val] = ptr->right;\\n            }\\n        }\\n        TreeNode* head = nullptr;\\n        for(auto ptr : root){\\n            if(ptr){\\n                auto pp = leaf[ptr->val];\\n                if(!pp && !head) { head = ptr; continue;}  //from observation 2\\n                else if(!pp) return nullptr; //from observation 2\\n                // cout<<pp->val<<endl;\\n                pp->left  = ptr->left;    //merging\\n                pp->right = ptr->right;  //merging\\n            }\\n        }\\n        \\n        cnt = 0;\\n        bool ff = isValid(head, nullptr, nullptr);\\n        \\n        return ff && cnt== n-trees.size()+1? head : nullptr;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nint cnt = 0;\\nbool isValid(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) {\\n    if(!root) return true;\\n    cnt++;\\n    if(minNode && root->val <= minNode->val || maxNode && root->val >= maxNode->val)\\n        return false;\\n    return isValid(root->left, minNode, root) && isValid(root->right, root, maxNode);\\n}\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n = 0;\\n        vector<TreeNode*> root(50001, nullptr),leaf(50001, nullptr);\\n        for(auto ptr:trees){\\n            root[ptr->val] = ptr;\\n            n++;\\n            if(ptr->left) {\\n                n++;\\n                if(leaf[ptr->left->val]) return nullptr; //from observation 1\\n                leaf[ptr->left->val] = ptr->left;\\n            }\\n            \\n            if(ptr->right){\\n                n++;\\n                if(leaf[ptr->right->val]) return nullptr;  //from observation 1              \\n                leaf[ptr->right->val] = ptr->right;\\n            }\\n        }\\n        TreeNode* head = nullptr;\\n        for(auto ptr : root){\\n            if(ptr){\\n                auto pp = leaf[ptr->val];\\n                if(!pp && !head) { head = ptr; continue;}  //from observation 2\\n                else if(!pp) return nullptr; //from observation 2\\n                // cout<<pp->val<<endl;\\n                pp->left  = ptr->left;    //merging\\n                pp->right = ptr->right;  //merging\\n            }\\n        }\\n        \\n        cnt = 0;\\n        bool ff = isValid(head, nullptr, nullptr);\\n        \\n        return ff && cnt== n-trees.size()+1? head : nullptr;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1359112,
                "title": "concise-c-beats-99-single-map-single-dfs-roo-leaf-merge",
                "content": "Major observations:\\n1. Apart from unquie root values, we also need **unique leaf values**, otherwise we dont have unique node to mount the root to, and also this would break the bst contraints for **strict** ordering.\\n2. If a **root does not map to a leaf, it must be the root of final tree**\\n3. If multiple roots dont map to leaves, then we have disjoint trees/graphs\\n4. the **count of nodes in the final valid bst must be equal to the total unique node cnt**( this will eliminate loops, non valid bst, and even disjoint sets)\\n\\nSolution:\\n1. Create map of leaf node val to its reference( have used double pointer in code as we cant store references in map. Parent node pointer could also be used here). Basically during  merge, we need to update the child node pointers in trees to new pointers.\\n2. Now traverse the root nodes one by one and merge them to leaf nodes\\n3. Traverse the merged bst to validate the number of nodes\\n4. Use the above observations to find invalid usecases\\n\\n````\\n#define MIN 0\\n#define MAX 500001\\nclass Solution {\\n    unordered_map<int,TreeNode**> leaves;\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        for(auto ptr:trees){\\n            if(ptr->left){\\n                if(leaves.count(ptr->left->val))return nullptr;//multiple leafs with same val\\n                leaves[ptr->left->val]=&(ptr->left);\\n            }\\n            if(ptr->right){\\n                if(leaves.count(ptr->right->val))return nullptr;//multiple leafs with same val\\n                leaves[ptr->right->val]=&(ptr->right);\\n            }\\n        }\\n        int cnt=leaves.size();//cnt is the number of distinct nodes, distinct roots+ leaves\\n        for(auto ptr:trees){\\n            if(!leaves.count(ptr->val))cnt++;\\n        }\\n        TreeNode* ans=nullptr;\\n        for(auto root:trees){\\n            int val=root->val;\\n            if(leaves.find(val)!=leaves.end()){//merge\\n                auto leaf = leaves[val];\\n                *leaf=root;\\n                leaves.erase(val);\\n            }else{//root does not map to any leaf, so mark it ans\\n                if(ans!=nullptr)//multiple roots\\n                    return nullptr;\\n                ans=root;\\n            }\\n        }\\n        if(isValidBST(ans)!=cnt)return nullptr;\\n        return ans;\\n    }\\n    int isValidBST(TreeNode* root, int min=MIN, int max=MAX) {\\n        if(!root || root->val>=max || root->val<=min)return 0;\\n        return 1 + (isValidBST(root->left,min,root->val) + isValidBST(root->right,root->val,max));\\n    }\\n};\\n````",
                "solutionTags": [],
                "code": "````\\n#define MIN 0\\n#define MAX 500001\\nclass Solution {\\n    unordered_map<int,TreeNode**> leaves;\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        for(auto ptr:trees){\\n            if(ptr->left){\\n                if(leaves.count(ptr->left->val))return nullptr;//multiple leafs with same val\\n                leaves[ptr->left->val]=&(ptr->left);\\n            }\\n            if(ptr->right){\\n                if(leaves.count(ptr->right->val))return nullptr;//multiple leafs with same val\\n                leaves[ptr->right->val]=&(ptr->right);\\n            }\\n        }\\n        int cnt=leaves.size();//cnt is the number of distinct nodes, distinct roots+ leaves\\n        for(auto ptr:trees){\\n            if(!leaves.count(ptr->val))cnt++;\\n        }\\n        TreeNode* ans=nullptr;\\n        for(auto root:trees){\\n            int val=root->val;\\n            if(leaves.find(val)!=leaves.end()){//merge\\n                auto leaf = leaves[val];\\n                *leaf=root;\\n                leaves.erase(val);\\n            }else{//root does not map to any leaf, so mark it ans\\n                if(ans!=nullptr)//multiple roots\\n                    return nullptr;\\n                ans=root;\\n            }\\n        }\\n        if(isValidBST(ans)!=cnt)return nullptr;\\n        return ans;\\n    }\\n    int isValidBST(TreeNode* root, int min=MIN, int max=MAX) {\\n        if(!root || root->val>=max || root->val<=min)return 0;\\n        return 1 + (isValidBST(root->left,min,root->val) + isValidBST(root->right,root->val,max));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341795,
                "title": "python-simple-simulation-o-n-easy-to-understand-with-explanations",
                "content": "This description of this problem lists the steps to simulate the merging process. The only thing we need to do is to implement the whole process. Notably there are some edge cases, and also a few quick ways to check if there exists a valid solution. \\n\\nFrom the begining, we know that:\\n1. The final result is a BST, which can NOT have duplicated values across its nodes.\\n2. The are `n` trees initially and we can only merge nodes for `n-1` times, which means each node can at most be merged for `1` time.\\n\\nThe above information indicates that:\\n1. In the original trees, the maximum ocurring frequency of a duplicated value is 2, otherwise there must be duplicates in the final BST. \\n2. The number of 2-duplicated pairs must be exactly `n-1`, becasue each merging solves a duplicate.\\n\\nThe above 2 conditions can help us quickly rule out invalid cases and return `null` before the simulation process. Moreover, we need to figure out which nodes will be paired together and merged before the simulation process as well, so we traverse over all nodes in the original trees and create a mapping from each value to `a list of its locations` (the index of the tree it belongs to and its position in that tree). The information we need looks like: \\n```\\n {value : [(ind, \\'root\\'/\\'left\\'/\\'right\\')]}\\n```\\nThe maximum length of such a list is 2, and the number of lists of length 2 is exactly `n-1`, as explained above.  For those nodes to be merged (whose value has a location list of length 2), one node must be `root` and the other must be `left/right` leaf of a tree, following the described merging process.\\n\\nSo the next step is to merge those nodes one by one, where we use a `deleted` array to mark which trees will be deleted after the merging process. since we will merge `n-1` tree, there will be only one remaining tree root undeleted in `trees`, which can be the final result only if it leads a valid `BST`. We then use inorder traversal to check if the tree rooted by the undeleted root is a valid BST and return the root if so. \\n\\nNotably, there is an edge case, e.g., in test case 465: \\n`[[1,null,3],[3,1],[4,2]]`\\nThe first 2 input trees forms a cycle and both will be deleted in the merging process. The algorithm will return `[[4,2]]`, which is indeed a valid BST but does not contain all origianl nodes. We can avoid this edge case by comparing the number of nodes in the final result to the number of original nodes after merging and deletion. \\n\\nThe complete code is as below: \\n\\n```\\nfrom collections import Counter, defaultdict\\n\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:        \\n        locs = defaultdict(list) # {value : [(ind, \\'root\\'/\\'left\\'/\\'right\\')]}\\n        deleted = [False for i in range(len(trees))] # to mark the deleted roots        \\n        n_nodes = 0 # num of nodes in the original trees\\n        \\n        # find the location of each value and its position in a tree\\n        for i, node in enumerate(trees):            \\n            locs[node.val].append((i, \\'root\\'))\\n            n_nodes += 1\\n            if node.left:\\n                locs[node.left.val].append((i, \\'left\\'))\\n                n_nodes += 1\\n            if node.right:\\n                locs[node.right.val].append((i, \\'right\\'))  \\n                n_nodes += 1\\n        \\n        # check if max freq of dups is 2\\n        freq = {k : len(v) for k,v in locs.items()}        \\n        if max(freq.values()) > 2:\\n            return None\\n        # check if number of 2-dups is n-1\\n        freq_dist = Counter(freq.values())\\n        if freq_dist[2] != len(trees)-1:\\n            return None\\n        \\n        # simulate the merging process\\n        for k, v in locs.items():\\n            if len(v) == 2:\\n                ind1, pos1 = v[0]\\n                ind2, pos2 = v[1]\\n                \\n                # must be a root and a non-root\\n                if pos1 != \\'root\\' and pos2 != \\'root\\':\\n                    return None\\n                elif pos1 == \\'root\\' and pos2 == \\'root\\':\\n                    return None\\n                elif pos1 == \\'root\\': # hypothrically delete ind2-node and append it to ind1                 \\n                    deleted[ind1] = True\\n                    n_nodes -= 1 \\n                    if pos2 == \\'left\\':\\n                        trees[ind2].left = trees[ind1]\\n                    else:\\n                        trees[ind2].right = trees[ind1]                                            \\n                else:                    \\n                    deleted[ind2] = True\\n                    n_nodes -= 1 \\n                    if pos1 == \\'left\\':\\n                        trees[ind1].left = trees[ind2]\\n                    else:\\n                        trees[ind1].right = trees[ind2]\\n                    \\n        # a valid trees must have one and only one root undeleted after n-1 operations\\n        if sum(deleted) != len(trees)-1: \\n            return None\\n        \\n        for i, root in enumerate(trees):\\n            if not deleted[i]:\\n                is_valid_bst, n_final_nodes = self.isValidBST(root)                \\n                if is_valid_bst and n_final_nodes == n_nodes:\\n                    return root\\n            \\n        return None\\n        \\n    def isValidBST(self, root: TreeNode):\\n        stack = []\\n        prev_val = -float(\\'inf\\')\\n        n_nodes = 0\\n        \\n        while root or stack:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            root = stack.pop()\\n            n_nodes += 1\\n            if prev_val >= root.val: \\n                return False, -1 # if it\\'s not a valis BST, num of nodes does not matter\\n            \\n            prev_val = root.val\\n            root = root.right\\n            \\n        return True, n_nodes\\n```",
                "solutionTags": [],
                "code": "```\\n {value : [(ind, \\'root\\'/\\'left\\'/\\'right\\')]}\\n```\n```\\nfrom collections import Counter, defaultdict\\n\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:        \\n        locs = defaultdict(list) # {value : [(ind, \\'root\\'/\\'left\\'/\\'right\\')]}\\n        deleted = [False for i in range(len(trees))] # to mark the deleted roots        \\n        n_nodes = 0 # num of nodes in the original trees\\n        \\n        # find the location of each value and its position in a tree\\n        for i, node in enumerate(trees):            \\n            locs[node.val].append((i, \\'root\\'))\\n            n_nodes += 1\\n            if node.left:\\n                locs[node.left.val].append((i, \\'left\\'))\\n                n_nodes += 1\\n            if node.right:\\n                locs[node.right.val].append((i, \\'right\\'))  \\n                n_nodes += 1\\n        \\n        # check if max freq of dups is 2\\n        freq = {k : len(v) for k,v in locs.items()}        \\n        if max(freq.values()) > 2:\\n            return None\\n        # check if number of 2-dups is n-1\\n        freq_dist = Counter(freq.values())\\n        if freq_dist[2] != len(trees)-1:\\n            return None\\n        \\n        # simulate the merging process\\n        for k, v in locs.items():\\n            if len(v) == 2:\\n                ind1, pos1 = v[0]\\n                ind2, pos2 = v[1]\\n                \\n                # must be a root and a non-root\\n                if pos1 != \\'root\\' and pos2 != \\'root\\':\\n                    return None\\n                elif pos1 == \\'root\\' and pos2 == \\'root\\':\\n                    return None\\n                elif pos1 == \\'root\\': # hypothrically delete ind2-node and append it to ind1                 \\n                    deleted[ind1] = True\\n                    n_nodes -= 1 \\n                    if pos2 == \\'left\\':\\n                        trees[ind2].left = trees[ind1]\\n                    else:\\n                        trees[ind2].right = trees[ind1]                                            \\n                else:                    \\n                    deleted[ind2] = True\\n                    n_nodes -= 1 \\n                    if pos1 == \\'left\\':\\n                        trees[ind1].left = trees[ind2]\\n                    else:\\n                        trees[ind1].right = trees[ind2]\\n                    \\n        # a valid trees must have one and only one root undeleted after n-1 operations\\n        if sum(deleted) != len(trees)-1: \\n            return None\\n        \\n        for i, root in enumerate(trees):\\n            if not deleted[i]:\\n                is_valid_bst, n_final_nodes = self.isValidBST(root)                \\n                if is_valid_bst and n_final_nodes == n_nodes:\\n                    return root\\n            \\n        return None\\n        \\n    def isValidBST(self, root: TreeNode):\\n        stack = []\\n        prev_val = -float(\\'inf\\')\\n        n_nodes = 0\\n        \\n        while root or stack:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            root = stack.pop()\\n            n_nodes += 1\\n            if prev_val >= root.val: \\n                return False, -1 # if it\\'s not a valis BST, num of nodes does not matter\\n            \\n            prev_val = root.val\\n            root = root.right\\n            \\n        return True, n_nodes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332841,
                "title": "easy-c-implementation-stimulation",
                "content": "```c++\\nclass Solution {\\npublic:\\n    //first is maximum and second is minimum\\n    pair<bool,pair<int,int>> isvalidbst(TreeNode *root){\\n        if(root==NULL){\\n            return {true,{INT_MIN,INT_MAX}};\\n        }\\n        auto left = isvalidbst(root->left);\\n        auto right = isvalidbst(root->right);\\n        \\n        //min max\\n        int maxele = max(left.second.first,max(root->val,right.second.first));\\n        int minele = min(left.second.second,min(right.second.second,root->val));\\n        \\n        //return \\n        if(left.second.first < root->val&&right.second.second > root->val)\\n            return {left.first&right.first&true,{maxele,minele}};\\n        else return {false,{maxele,minele}};\\n    }\\n    //root\\n    TreeNode *par;\\n    \\n    //Join b with a\\n    //calculate leaves\\n    unordered_map<int,int>leaf;\\n    void dfs(TreeNode *curr){\\n        if(curr==NULL) return;\\n        if(curr->left==NULL&&curr->right==NULL){\\n            leaf[curr->val]++;\\n            return;\\n        }\\n        dfs(curr->left);\\n        dfs(curr->right);\\n    }\\n    unordered_map<int,TreeNode *>m;\\n    void make(TreeNode *curr){\\n        if(curr==NULL) return;\\n        //should able to merge\\n        if(curr->left==NULL&&curr->right==NULL){\\n            if(m.find(curr->val)==m.end()) return;\\n            TreeNode *b = m[curr->val];\\n            if(b==curr) return;\\n            curr->left = b->left;\\n            curr->right = b->right;\\n            m.erase(curr->val);\\n        }\\n        make(curr->left);\\n        make(curr->right);\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {    \\n        if(trees.size()==1) return trees[0];\\n        //precalculate the leaves;\\n        for(int i = 0;i<trees.size();i++){\\n            m[trees[i]->val] = trees[i];\\n            dfs(trees[i]);\\n        }\\n        par = NULL;\\n        int count = 0;\\n        //Find the root \\n        for(int i = 0;i<trees.size();i++){\\n            int curr = trees[i]->val;\\n            if(leaf.find(curr)==leaf.end()){\\n                par = trees[i];\\n                break;\\n            }\\n        }\\n        \\n        //merge from the root\\n        make(par);\\n        \\n        //return root\\n        if(m.size() > 1) return NULL;\\n        auto check = isvalidbst(par);\\n        if(check.first==false) return NULL;\\n        return par;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    //first is maximum and second is minimum\\n    pair<bool,pair<int,int>> isvalidbst(TreeNode *root){\\n        if(root==NULL){\\n            return {true,{INT_MIN,INT_MAX}};\\n        }\\n        auto left = isvalidbst(root->left);\\n        auto right = isvalidbst(root->right);\\n        \\n        //min max\\n        int maxele = max(left.second.first,max(root->val,right.second.first));\\n        int minele = min(left.second.second,min(right.second.second,root->val));\\n        \\n        //return \\n        if(left.second.first < root->val&&right.second.second > root->val)\\n            return {left.first&right.first&true,{maxele,minele}};\\n        else return {false,{maxele,minele}};\\n    }\\n    //root\\n    TreeNode *par;\\n    \\n    //Join b with a\\n    //calculate leaves\\n    unordered_map<int,int>leaf;\\n    void dfs(TreeNode *curr){\\n        if(curr==NULL) return;\\n        if(curr->left==NULL&&curr->right==NULL){\\n            leaf[curr->val]++;\\n            return;\\n        }\\n        dfs(curr->left);\\n        dfs(curr->right);\\n    }\\n    unordered_map<int,TreeNode *>m;\\n    void make(TreeNode *curr){\\n        if(curr==NULL) return;\\n        //should able to merge\\n        if(curr->left==NULL&&curr->right==NULL){\\n            if(m.find(curr->val)==m.end()) return;\\n            TreeNode *b = m[curr->val];\\n            if(b==curr) return;\\n            curr->left = b->left;\\n            curr->right = b->right;\\n            m.erase(curr->val);\\n        }\\n        make(curr->left);\\n        make(curr->right);\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {    \\n        if(trees.size()==1) return trees[0];\\n        //precalculate the leaves;\\n        for(int i = 0;i<trees.size();i++){\\n            m[trees[i]->val] = trees[i];\\n            dfs(trees[i]);\\n        }\\n        par = NULL;\\n        int count = 0;\\n        //Find the root \\n        for(int i = 0;i<trees.size();i++){\\n            int curr = trees[i]->val;\\n            if(leaf.find(curr)==leaf.end()){\\n                par = trees[i];\\n                break;\\n            }\\n        }\\n        \\n        //merge from the root\\n        make(par);\\n        \\n        //return root\\n        if(m.size() > 1) return NULL;\\n        auto check = isvalidbst(par);\\n        if(check.first==false) return NULL;\\n        return par;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332725,
                "title": "c-merge-using-dictionaries",
                "content": "```csharp\\npublic TreeNode CanMerge(IList<TreeNode> trees)\\n{\\n\\tDictionary<int, TreeNode> map = new Dictionary<int, TreeNode>();\\n\\tHashSet<TreeNode> visited = new HashSet<TreeNode>();\\n\\tDictionary<TreeNode, TreeNode> parentMap = new Dictionary<TreeNode, TreeNode>();\\n\\n\\tforeach (var tree in trees)\\n\\t{\\n\\t\\tmap[tree.val] = tree;\\n\\t}\\n\\n\\tforeach (var tree in trees)\\n\\t{\\n\\t\\tTreeNode parent = null;\\n\\t\\tif (parentMap.ContainsKey(tree))\\n\\t\\t{\\n\\t\\t\\tparent = parentMap[tree];\\n\\t\\t}\\n\\n\\t\\t// Check for left node\\n\\t\\tif (tree.left != null && map.ContainsKey(tree.left.val) && !visited.Contains(tree.left))\\n\\t\\t{\\n\\t\\t\\tvar currentRoot = map[tree.left.val];\\n\\t\\t\\tbool hasCycle = checkCycle(parentMap, parent, currentRoot);\\n\\n\\t\\t\\tif (!hasCycle)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttree.left = currentRoot;\\n\\t\\t\\t\\tparentMap[currentRoot] = tree;\\n\\t\\t\\t\\tvisited.Add(currentRoot);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Check for right node\\n\\t\\tif (tree.right != null && map.ContainsKey(tree.right.val) && !visited.Contains(tree.right))\\n\\t\\t{\\n\\t\\t\\tvar currentRoot = map[tree.right.val];\\n\\t\\t\\tbool hasCycle = checkCycle(parentMap, parent, currentRoot);\\n\\n\\t\\t\\tif (!hasCycle)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttree.right = currentRoot;\\n\\t\\t\\t\\tparentMap[currentRoot] = tree;\\n\\t\\t\\t\\tvisited.Add(currentRoot);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif (visited.Count != trees.Count - 1)\\n\\t{\\n\\t\\treturn null;\\n\\t}\\n\\n\\tforeach (var tree in trees)\\n\\t{\\n\\t\\tif (!visited.Contains(tree))\\n\\t\\t{\\n\\t\\t\\tif (isValidBST(tree))\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn tree;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t}\\n\\n\\treturn null;\\n}\\n\\nprivate bool checkCycle(Dictionary<TreeNode, TreeNode> parentMap, TreeNode parent, TreeNode currentRoot)\\n{\\n\\tbool hasCycle = false;\\n\\n\\twhile (parent != null)\\n\\t{\\n\\t\\tif (parent == currentRoot)\\n\\t\\t{\\n\\t\\t\\thasCycle = true;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tif (parentMap.ContainsKey(parent))\\n\\t\\t{\\n\\t\\t\\tparent = parentMap[parent];\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tparent = null;\\n\\t\\t}\\n\\t}\\n\\n\\treturn hasCycle;\\n}\\n\\nprivate bool isValidBST(TreeNode root)\\n{\\n\\treturn Validate(root, long.MinValue, long.MaxValue);\\n}\\n\\nprivate bool Validate(TreeNode root, long min, long max)\\n{\\n\\tif (root == null)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\n\\tif (root.val <= min || root.val >= max)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\treturn Validate(root.left, min, root.val) && Validate(root.right, root.val, max);\\n} \\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic TreeNode CanMerge(IList<TreeNode> trees)\\n{\\n\\tDictionary<int, TreeNode> map = new Dictionary<int, TreeNode>();\\n\\tHashSet<TreeNode> visited = new HashSet<TreeNode>();\\n\\tDictionary<TreeNode, TreeNode> parentMap = new Dictionary<TreeNode, TreeNode>();\\n\\n\\tforeach (var tree in trees)\\n\\t{\\n\\t\\tmap[tree.val] = tree;\\n\\t}\\n\\n\\tforeach (var tree in trees)\\n\\t{\\n\\t\\tTreeNode parent = null;\\n\\t\\tif (parentMap.ContainsKey(tree))\\n\\t\\t{\\n\\t\\t\\tparent = parentMap[tree];\\n\\t\\t}\\n\\n\\t\\t// Check for left node\\n\\t\\tif (tree.left != null && map.ContainsKey(tree.left.val) && !visited.Contains(tree.left))\\n\\t\\t{\\n\\t\\t\\tvar currentRoot = map[tree.left.val];\\n\\t\\t\\tbool hasCycle = checkCycle(parentMap, parent, currentRoot);\\n\\n\\t\\t\\tif (!hasCycle)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttree.left = currentRoot;\\n\\t\\t\\t\\tparentMap[currentRoot] = tree;\\n\\t\\t\\t\\tvisited.Add(currentRoot);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Check for right node\\n\\t\\tif (tree.right != null && map.ContainsKey(tree.right.val) && !visited.Contains(tree.right))\\n\\t\\t{\\n\\t\\t\\tvar currentRoot = map[tree.right.val];\\n\\t\\t\\tbool hasCycle = checkCycle(parentMap, parent, currentRoot);\\n\\n\\t\\t\\tif (!hasCycle)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttree.right = currentRoot;\\n\\t\\t\\t\\tparentMap[currentRoot] = tree;\\n\\t\\t\\t\\tvisited.Add(currentRoot);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif (visited.Count != trees.Count - 1)\\n\\t{\\n\\t\\treturn null;\\n\\t}\\n\\n\\tforeach (var tree in trees)\\n\\t{\\n\\t\\tif (!visited.Contains(tree))\\n\\t\\t{\\n\\t\\t\\tif (isValidBST(tree))\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn tree;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t}\\n\\n\\treturn null;\\n}\\n\\nprivate bool checkCycle(Dictionary<TreeNode, TreeNode> parentMap, TreeNode parent, TreeNode currentRoot)\\n{\\n\\tbool hasCycle = false;\\n\\n\\twhile (parent != null)\\n\\t{\\n\\t\\tif (parent == currentRoot)\\n\\t\\t{\\n\\t\\t\\thasCycle = true;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tif (parentMap.ContainsKey(parent))\\n\\t\\t{\\n\\t\\t\\tparent = parentMap[parent];\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tparent = null;\\n\\t\\t}\\n\\t}\\n\\n\\treturn hasCycle;\\n}\\n\\nprivate bool isValidBST(TreeNode root)\\n{\\n\\treturn Validate(root, long.MinValue, long.MaxValue);\\n}\\n\\nprivate bool Validate(TreeNode root, long min, long max)\\n{\\n\\tif (root == null)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\n\\tif (root.val <= min || root.val >= max)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\treturn Validate(root.left, min, root.val) && Validate(root.right, root.val, max);\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1332564,
                "title": "javascript-dfs-adding-trees-on-the-go",
                "content": "**Idea**\\nBuild the tree from the top down.\\n**Issues**\\nThere are a couple edge cases that need to be considered. Namely, problems arise when:\\n* There are cycles, for example   [2,null,3] , [3,2,null]\\n* Some mini trees are not used at all\\n* The resulting tree is not a BST\\n\\n**Implementation**\\nOne dfs will determine the indegrees of each node and will place pointers in each node to their parent, such that replacing can be easy, even when currently at the node itself. The node with the indegree===0, is the main root, from which a second dfs will form the resulting tree. Finally, after each edge case has been dealt with, the root node will be returned.\\n\\n```\\nvar canMerge = function(trees) {\\n    let Node={},indeg={}\\n    // traverse the mini trees and put back pointers to their parents, also figure out the indegree of each node\\n    let dfs=(node,leftparent=null,rightparent=null)=>{\\n        if(!node)return\\n        indeg[node.val]=indeg[node.val]||Number(leftparent!==null||rightparent!==null)\\n        node.lp=leftparent,node.rp=rightparent\\n        dfs(node.left,node,null),dfs(node.right,null,node)\\n    }\\n    for(let root of trees)\\n        Node[root.val]=root,\\n        dfs(root)\\n    //there are a lot of potential roots=> no bueno\\n    if(Object.values(indeg).reduce((a,b)=>a+b)!=Object.keys(indeg).length-1)\\n        return null\\n    //find THE root\\n    let bigRoot,timesMerged=0\\n    for(let root of trees)\\n        if(indeg[root.val]===0)\\n            bigRoot=root\\n    // traverse the tree while replacing each leaf that can be replaced\\n    let rec=(node=bigRoot)=>{\\n        if(!node)\\n            return\\n        if(!node.left&&!node.right){\\n            let toadd=Node[node.val]\\n            Node[node.val]=undefined //invalidating the trees you already used\\n            if(toadd===undefined)\\n                return\\n            //make the change\\n            if(node.lp===null&&node.rp===null)\\n                return\\n            else if(node.lp!==null)\\n                node.lp.left=toadd\\n            else\\n                node.rp.right=toadd\\n            timesMerged++\\n            rec(toadd)\\n        }\\n        else\\n            rec(node.left),rec(node.right)\\n    }\\n    rec()\\n    var isValidBST = function(node,l=-Infinity,r=Infinity) { //l and r are the limits node.val should be within\\n        if(!node)\\n            return true\\n        if(node.val<l || node.val >r)\\n            return false\\n        return isValidBST(node.left,l,node.val-1)&&isValidBST(node.right,node.val+1,r)\\n    };\\n    //check if every item was used and if the result bst is valid \\n    return !isValidBST(bigRoot)||timesMerged!==trees.length-1?null:bigRoot\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nvar canMerge = function(trees) {\\n    let Node={},indeg={}\\n    // traverse the mini trees and put back pointers to their parents, also figure out the indegree of each node\\n    let dfs=(node,leftparent=null,rightparent=null)=>{\\n        if(!node)return\\n        indeg[node.val]=indeg[node.val]||Number(leftparent!==null||rightparent!==null)\\n        node.lp=leftparent,node.rp=rightparent\\n        dfs(node.left,node,null),dfs(node.right,null,node)\\n    }\\n    for(let root of trees)\\n        Node[root.val]=root,\\n        dfs(root)\\n    //there are a lot of potential roots=> no bueno\\n    if(Object.values(indeg).reduce((a,b)=>a+b)!=Object.keys(indeg).length-1)\\n        return null\\n    //find THE root\\n    let bigRoot,timesMerged=0\\n    for(let root of trees)\\n        if(indeg[root.val]===0)\\n            bigRoot=root\\n    // traverse the tree while replacing each leaf that can be replaced\\n    let rec=(node=bigRoot)=>{\\n        if(!node)\\n            return\\n        if(!node.left&&!node.right){\\n            let toadd=Node[node.val]\\n            Node[node.val]=undefined //invalidating the trees you already used\\n            if(toadd===undefined)\\n                return\\n            //make the change\\n            if(node.lp===null&&node.rp===null)\\n                return\\n            else if(node.lp!==null)\\n                node.lp.left=toadd\\n            else\\n                node.rp.right=toadd\\n            timesMerged++\\n            rec(toadd)\\n        }\\n        else\\n            rec(node.left),rec(node.right)\\n    }\\n    rec()\\n    var isValidBST = function(node,l=-Infinity,r=Infinity) { //l and r are the limits node.val should be within\\n        if(!node)\\n            return true\\n        if(node.val<l || node.val >r)\\n            return false\\n        return isValidBST(node.left,l,node.val-1)&&isValidBST(node.right,node.val+1,r)\\n    };\\n    //check if every item was used and if the result bst is valid \\n    return !isValidBST(bigRoot)||timesMerged!==trees.length-1?null:bigRoot\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1331418,
                "title": "python-3-bfs-updating-lower-and-upper-bound-2844-ms",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        root = {}\\n        leaves = set()\\n        start = set()\\n        for tree in trees:\\n            if tree.left:\\n                leaves.add(tree.left.val)\\n            if tree.right:\\n                leaves.add(tree.right.val)\\n            root[tree.val] = tree\\n            start.add(tree.val)\\n        \\n        start = start.difference(leaves)\\n        \\n        if len(start) != 1: return None\\n        res = root[list(start)[0]]\\n        \\n        cnt = 1\\n        n = len(trees)\\n        q = deque([(res, float(\\'-inf\\'), float(\\'inf\\'))])\\n        \\n        while q and cnt < n:\\n            node, low, high = q.popleft()\\n            if node.left and node.left.val in root:\\n                h = min(high, node.val)\\n                tmp = root[node.left.val]\\n                if (not tmp.right or tmp.right.val < h) and (not tmp.left or tmp.left.val > low):\\n                    node.left = tmp\\n                    q.append((node.left, low, h))\\n                    cnt += 1\\n            if node.right and node.right.val in root:\\n                l = max(low, node.val)\\n                tmp = root[node.right.val]\\n                if (not tmp.right or tmp.right.val < h) and (not tmp.left or tmp.left.val > low):\\n                    node.right = tmp\\n                    q.append((node.right, l, high))\\n                    cnt += 1\\n        \\n        return res if cnt == n else None",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Binary Search Tree"
                ],
                "code": "class Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        root = {}",
                "codeTag": "Java"
            },
            {
                "id": 1330973,
                "title": "java-solution-using-hashmap-readable-code",
                "content": "```\\n\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        //Map root value to tree\\n        HashMap<Integer, TreeNode> map = new HashMap<>();\\n        for(TreeNode t : trees){\\n            map.put(t.val, t);\\n        }\\n        \\n        // Merge trees\\n        for(TreeNode t : trees){\\n            if(map.containsKey(t.val)){\\n                merger(t, map);\\n            }\\n        }\\n\\n        \\n        //After merging we should have only one tree left else return null\\n        if(map.size() != 1) return null;\\n        else {\\n            //Return the one tree left after merging\\n            for(int c : map.keySet()) {\\n                //Check if final tree is valid else return null\\n                if(isValidBST(map.get(c))){\\n                    return map.get(c);\\n                } else return null;\\n            }\\n        }\\n        \\n      return null;\\n        \\n        \\n    }\\n    \\n    void merger(TreeNode t, HashMap<Integer, TreeNode> map){\\n        map.remove(t.val); // Remove current tree to prevent cyclical merging For. 2->3(Right) and 3->2(Left)\\n        //Merge on left\\n        if(t.left != null && map.containsKey(t.left.val) ){\\n            // Before merging child node, merge the grandchild nodes\\n            merger(map.get(t.left.val), map);\\n            t.left = map.get(t.left.val);\\n            map.remove(t.left.val);\\n        }\\n        \\n        // Merge on right\\n        if(t.right!=null &&  map.containsKey(t.right.val)  ){\\n            // Before merging child node, merge the grandchild nodes\\n            merger(map.get(t.right.val), map);\\n            t.right = map.get(t.right.val);\\n            map.remove(t.right.val);\\n        }\\n        // Add tree back to map once right and left merge is complete\\n        map.put(t.val, t);\\n    }\\n    \\n    // Validate BST\\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n    \\n    public boolean helper(TreeNode root, long min, long max){\\n        if(root == null) return true;\\n        if(root.val <= min || root.val >= max) return false;\\n        return helper(root.left, min, root.val) && helper(root.right, root.val, max);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        //Map root value to tree\\n        HashMap<Integer, TreeNode> map = new HashMap<>();\\n        for(TreeNode t : trees){\\n            map.put(t.val, t);\\n        }\\n        \\n        // Merge trees\\n        for(TreeNode t : trees){\\n            if(map.containsKey(t.val)){\\n                merger(t, map);\\n            }\\n        }\\n\\n        \\n        //After merging we should have only one tree left else return null\\n        if(map.size() != 1) return null;\\n        else {\\n            //Return the one tree left after merging\\n            for(int c : map.keySet()) {\\n                //Check if final tree is valid else return null\\n                if(isValidBST(map.get(c))){\\n                    return map.get(c);\\n                } else return null;\\n            }\\n        }\\n        \\n      return null;\\n        \\n        \\n    }\\n    \\n    void merger(TreeNode t, HashMap<Integer, TreeNode> map){\\n        map.remove(t.val); // Remove current tree to prevent cyclical merging For. 2->3(Right) and 3->2(Left)\\n        //Merge on left\\n        if(t.left != null && map.containsKey(t.left.val) ){\\n            // Before merging child node, merge the grandchild nodes\\n            merger(map.get(t.left.val), map);\\n            t.left = map.get(t.left.val);\\n            map.remove(t.left.val);\\n        }\\n        \\n        // Merge on right\\n        if(t.right!=null &&  map.containsKey(t.right.val)  ){\\n            // Before merging child node, merge the grandchild nodes\\n            merger(map.get(t.right.val), map);\\n            t.right = map.get(t.right.val);\\n            map.remove(t.right.val);\\n        }\\n        // Add tree back to map once right and left merge is complete\\n        map.put(t.val, t);\\n    }\\n    \\n    // Validate BST\\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n    \\n    public boolean helper(TreeNode root, long min, long max){\\n        if(root == null) return true;\\n        if(root.val <= min || root.val >= max) return false;\\n        return helper(root.left, min, root.val) && helper(root.right, root.val, max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330285,
                "title": "beginner-friendly-c-solution-using-two-hash-maps-explained-commented",
                "content": "This may not be an optimal solution. But a solution easy to understand. \\n* Store the leaf nodes of all  the trees in a map with its parent Node address\\n* when we find current tree node value in the map we need to merge\\n* if we dont find the current node value in map then it is the node  which we should return \\n* when we merge a current tree x to another tree y then we check - \\n* if x is left child of y and maximum node value in the x is >=  y root node value then return NULL , else merge them and change the y minimum node value to x minimum node value\\n* if x is right child of y and the minimum node value in x is <= y root node value then return NULL, else merge them and change the y maximum node value to x  maximum value\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        //store the leaves of every node\\n\\n        unordered_map<int,TreeNode*> mp;\\n        \\n        //store the current min and current max nodes in the current tree\\n        unordered_map<TreeNode*,pair<int,int>> mini;\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            pair<int,int> ans={trees[i]->val,trees[i]->val};\\n            if(trees[i]->left)\\n            {\\n                \\n                mp[trees[i]->left->val]={trees[i]};\\n                ans.first=trees[i]->left->val;\\n            }\\n            if(trees[i]->right)\\n            {\\n                mp[trees[i]->right->val]=trees[i];\\n                ans.second=trees[i]->right->val;\\n            }\\n            mini[trees[i]]=ans;\\n        }\\n        \\n        //store the number of merging operations we will be doing\\n        int count=0;\\n        int rootCount=0;\\n        TreeNode* root=NULL;\\n        //now for every node get the root\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            \\n            //if the current tree can be merged into some other tree\\n            if(mp.find(trees[i]->val)!=mp.end())\\n            {\\n                count++;\\n                //merge them\\n                TreeNode* parent=mp[trees[i]->val];\\n                if(trees[i]->val < parent->val)\\n                {\\n                    //left child \\n                    \\n                    //if the maximum of the current sub tree is greater than the parent value \\n                    //then return NULL\\n                    if(parent->val <= mini[trees[i]].second)\\n                        return NULL;\\n                    //change the minimum value of the parent tree to the current min value of the tree\\n                    mini[parent].first=mini[trees[i]].first;\\n                    //merge the trees\\n                    parent->left=trees[i];\\n                }\\n                else  if(trees[i]->val > parent->val)\\n                {\\n                    //right child\\n                    \\n                    //if the minimum of the current tree is lesser than the parent value\\n                    //we cannot merge \\n                    //so return NULL\\n                    if(parent->val >= mini[trees[i]].first)\\n                        return NULL;\\n                    \\n                    //change the parent tree maximum to the current tree maximum\\n                    mini[parent].second=mini[trees[i]].second;\\n                    //merge the trees\\n                    parent->right=trees[i];\\n                }\\n                //erase the current tree value\\n                mp.erase(trees[i]->val);\\n            }\\n            else{\\n                //it has no other tree to merge \\n                //it is the root node we should return \\n                if(rootCount==1)\\n                    return NULL;\\n                else \\n                {\\n                    rootCount++;\\n                    root=trees[i];\\n                }\\n            }\\n        }\\n        //if we are not able to merge all trees return NULL\\n        if(count!=trees.size()-1)\\n            return NULL;\\n        return root;\\n        \\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        //store the leaves of every node\\n\\n        unordered_map<int,TreeNode*> mp;\\n        \\n        //store the current min and current max nodes in the current tree\\n        unordered_map<TreeNode*,pair<int,int>> mini;\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            pair<int,int> ans={trees[i]->val,trees[i]->val};\\n            if(trees[i]->left)\\n            {\\n                \\n                mp[trees[i]->left->val]={trees[i]};\\n                ans.first=trees[i]->left->val;\\n            }\\n            if(trees[i]->right)\\n            {\\n                mp[trees[i]->right->val]=trees[i];\\n                ans.second=trees[i]->right->val;\\n            }\\n            mini[trees[i]]=ans;\\n        }\\n        \\n        //store the number of merging operations we will be doing\\n        int count=0;\\n        int rootCount=0;\\n        TreeNode* root=NULL;\\n        //now for every node get the root\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            \\n            //if the current tree can be merged into some other tree\\n            if(mp.find(trees[i]->val)!=mp.end())\\n            {\\n                count++;\\n                //merge them\\n                TreeNode* parent=mp[trees[i]->val];\\n                if(trees[i]->val < parent->val)\\n                {\\n                    //left child \\n                    \\n                    //if the maximum of the current sub tree is greater than the parent value \\n                    //then return NULL\\n                    if(parent->val <= mini[trees[i]].second)\\n                        return NULL;\\n                    //change the minimum value of the parent tree to the current min value of the tree\\n                    mini[parent].first=mini[trees[i]].first;\\n                    //merge the trees\\n                    parent->left=trees[i];\\n                }\\n                else  if(trees[i]->val > parent->val)\\n                {\\n                    //right child\\n                    \\n                    //if the minimum of the current tree is lesser than the parent value\\n                    //we cannot merge \\n                    //so return NULL\\n                    if(parent->val >= mini[trees[i]].first)\\n                        return NULL;\\n                    \\n                    //change the parent tree maximum to the current tree maximum\\n                    mini[parent].second=mini[trees[i]].second;\\n                    //merge the trees\\n                    parent->right=trees[i];\\n                }\\n                //erase the current tree value\\n                mp.erase(trees[i]->val);\\n            }\\n            else{\\n                //it has no other tree to merge \\n                //it is the root node we should return \\n                if(rootCount==1)\\n                    return NULL;\\n                else \\n                {\\n                    rootCount++;\\n                    root=trees[i];\\n                }\\n            }\\n        }\\n        //if we are not able to merge all trees return NULL\\n        if(count!=trees.size()-1)\\n            return NULL;\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081370,
                "title": "map-tree-conditions-commented-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA binary search tree that is valid is a graph of contracts of node relations. As such, we can use graphs and sets of tree node relations and utilize them to determine validity. Validity needs to agree on a node level, and as a whole tree, and so we use a map for trees and a map for leaves, along with a set for each as well. This then lets us uniquely determine the valid binary search tree, for which there must be only one organization for the result based on the problem description. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMake a set of leaf values, tree values, a map of trees, a max tree and min tree value variable as needed for the problem, a min prob value and max prob value as needed for the problem. \\n\\nLoop such that \\n- For tree in trees \\n    - map tree value to tree in tree map \\n    - add tree value to tree values set \\n    - for each of the tree children \\n        - if leaf add to the leaves the child values \\n    - update max tree, min tree as needed related to tree.val \\n\\nBuild a root set as the difference of tree values set and leaves value set \\nSet root as \\n- None if len of root set is != 1 (non-unique valid bst) \\n- tree_map at root_set.pop() if len of root set is 1 \\n\\nValid conditions checked as follows \\n- If root is None\\n    - return None  \\n- elif root.left and root.right is None \\n    - return root if length of trees is 1 else None \\n- elif root.left and not root.right and root.val is not max_tree \\n    - return None    \\n- elif root.right and not root.left and root.val is not min_tree \\n    - return None \\n\\nIf root is None, no tree. If both left and right are None, no tree unless only one tree. If left and not right or right and not left and the root value is not the max or min tree respectively -> also none \\n\\nConsider child states as (low value limit, high value limit, parent node, side of placement of parent node). This then lets you understand each child state in relation to parent state, and allows for handedness. A left child will always use a parent value as the high limit, and a right child will always use the parent value as the low limit. \\n\\nIn all other cases, we now need to traverse \\n- Make a leaf map, set left to 0 and right to 1 \\n- If root.left add to leaf map at root.left.val the tree state of (min_prob, root.val, root, left) \\n- If root.right, add to leaf map at root.right.val the tree state of (root.val, max_prob, root, right) \\n- delete tree map at root value \\n- While you have a tree map \\n    - set tree exists to False \\n    - loop for leaf and leaf (child) state in leaf map items \\n        - if leaf in tree map  \\n            - set new_tree to tree_map at leaf \\n            - delete leaf_map at leaf \\n            - Each of the new_tree\\'s children must satisfy that they are in bounds of the leaf state (low < children value < high) and children value not in leaf map \\n            - For each child, if not satisfactory, return None. Otherwise, set leaf map at child value to appropriate leaf state\\n            - based on sidedness of child state, set parent on side to new tree \\n            - mark tree exists as True if a leaf was satisfied \\n            - delete tree map at new tree value \\n            - break out of loop \\n        - if leaf not in tree map, continue until leaf in tree map \\n    - if tree exists is False return None as no leaf was satisfied \\n- if loop completes, return root             \\n\\n# Complexity\\n- Time complexity : O(T) \\n    - O(T) loop trees at start \\n    - O(T) build root set \\n    - validity check in O(1) lets lower bound at O(2T) \\n    - O(T) loop tree map \\n        - O(L) leaf map items (at most 2 or 3 items each loop) \\n            - early check available inside \\n        - early check available oustide L loop\\n    - Total value is O(cT) where c is a constant -> O(T) \\n\\n- Space complexity : O(L + T) \\n    - Leaf set of size L \\n    - Tree values of size L \\n    - Tree map of size T -> T \\n    - Leaf map of size L -> LS (held at constant size by deletes / adds) \\n    - Total size is L + T \\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        # build set of leaves and map of trees \\n        # note that all tree roots are unique, but not necessarily leaves\\n        # find min and max tree for easier short circuits later \\n        leaves = set() \\n        tree_map = dict() \\n        tree_vals = set()\\n        max_tree = 0 \\n        min_tree = 10**5\\n        max_prob = 100000\\n        min_prob = 0 \\n        for tree in trees : \\n            # map each tree val uniquely \\n            tree_map[tree.val] = tree \\n            # add each to the tree val set \\n            tree_vals.add(tree.val)\\n            # then based on presence of leaves, add uniques as needed \\n            if tree.left : \\n                leaves.add(tree.left.val)\\n            if tree.right : \\n                leaves.add(tree.right.val) \\n            # and update maxima and minima of tree values \\n            max_tree, min_tree = max(max_tree, tree.val), min(min_tree, tree.val)\\n        \\n        # build root set from difference of tree vals with leaves \\n        root_set = tree_vals.difference(leaves)\\n        root = None if len(root_set) != 1 else tree_map[root_set.pop()]\\n            \\n        # if none are valid though, no trees are possible \\n        # invalid set ups are root is None or root is isolated and not solitary \\n        # else if isolated and solitary return root, otherwise return None \\n        # else if one side isolated and not matching maxima -> return None \\n        # otherwise, traverse tree for resolution \\n        if root is None : \\n            return None \\n        elif root.left is None and root.right is None : \\n            return root if len(trees) == 1 else None \\n        elif root.left and not root.right and root.val != max_tree : \\n            return None \\n        elif root.right and not root.left and root.val != min_tree : \\n            return None \\n        else : \\n            # make a map of leaves to nodes of leaf states \\n            # leaf states include low value, high value, parent value and handed-ness \\n            # assume left handed as 0 and right handed as 1 \\n            leaf_map = dict() \\n            # set variables for references minimizing overhead \\n            left = 0 \\n            right = 1 \\n            # if root has a left and right, we can utilize it in the leaf map \\n            # check left and right and record as needed \\n            if root.left : \\n                leaf_map[root.left.val] = (min_prob, root.val, root, left)\\n            if root.right : \\n                leaf_map[root.right.val] = (root.val, max_prob, root, right) \\n          \\n            # since root is now pinned, remove from map \\n            del tree_map[root.val]\\n    \\n            # while you have a tree map \\n            while tree_map : \\n                # determine if a tree exists succesfully for the selected item\\n                tree_exists = False \\n                # for leaf key, leaf state in leaf map items \\n                for leaf, (low, high, parent, side) in leaf_map.items() : \\n                    # if leaf in tree map \\n                    if leaf in tree_map : \\n                        # make a new tree based off of tree map via leaf value and update leaf map\\n                        new_tree = tree_map[leaf] \\n                        del leaf_map[leaf]\\n\\n                        # satisfy left and right in bounds of low and high of leaf state \\n                        # on failure to satisfy all, none satisfy, so may return None \\n                        if new_tree.left : \\n                            if low < new_tree.left.val < high and new_tree.left.val not in leaf_map : \\n                                leaf_map[new_tree.left.val] = (low, new_tree.val, new_tree, left)\\n                            else : \\n                                return None \\n\\n                        if new_tree.right : \\n                            if low < new_tree.right.val < high and new_tree.right.val not in leaf_map : \\n                                leaf_map[new_tree.right.val] = (new_tree.val, high, new_tree, right)\\n                            else : \\n                                return None \\n                    \\n                        # if side is left, place on left; otherwise place on right \\n                        if side == left : \\n                            parent.left = new_tree \\n                        else : \\n                            parent.right = new_tree\\n                    \\n                        # if a leaf was satisfied, mark as tree exists \\n                        # this may be superseded by failure of any future leaves still \\n                        tree_exists = True \\n                        # remove the value as needed from the tree map \\n                        del tree_map[new_tree.val]\\n                        # once one satisfaction is found, break for loop \\n                        break \\n                    else : \\n                        continue \\n                # at end of while loop before next iteration, if no leaves satisfied, return None \\n                if tree_exists == False : \\n                    return None \\n            # if all leaves satisfied, and all trees satisfied, tree constructed \\n            return root \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        # build set of leaves and map of trees \\n        # note that all tree roots are unique, but not necessarily leaves\\n        # find min and max tree for easier short circuits later \\n        leaves = set() \\n        tree_map = dict() \\n        tree_vals = set()\\n        max_tree = 0 \\n        min_tree = 10**5\\n        max_prob = 100000\\n        min_prob = 0 \\n        for tree in trees : \\n            # map each tree val uniquely \\n            tree_map[tree.val] = tree \\n            # add each to the tree val set \\n            tree_vals.add(tree.val)\\n            # then based on presence of leaves, add uniques as needed \\n            if tree.left : \\n                leaves.add(tree.left.val)\\n            if tree.right : \\n                leaves.add(tree.right.val) \\n            # and update maxima and minima of tree values \\n            max_tree, min_tree = max(max_tree, tree.val), min(min_tree, tree.val)\\n        \\n        # build root set from difference of tree vals with leaves \\n        root_set = tree_vals.difference(leaves)\\n        root = None if len(root_set) != 1 else tree_map[root_set.pop()]\\n            \\n        # if none are valid though, no trees are possible \\n        # invalid set ups are root is None or root is isolated and not solitary \\n        # else if isolated and solitary return root, otherwise return None \\n        # else if one side isolated and not matching maxima -> return None \\n        # otherwise, traverse tree for resolution \\n        if root is None : \\n            return None \\n        elif root.left is None and root.right is None : \\n            return root if len(trees) == 1 else None \\n        elif root.left and not root.right and root.val != max_tree : \\n            return None \\n        elif root.right and not root.left and root.val != min_tree : \\n            return None \\n        else : \\n            # make a map of leaves to nodes of leaf states \\n            # leaf states include low value, high value, parent value and handed-ness \\n            # assume left handed as 0 and right handed as 1 \\n            leaf_map = dict() \\n            # set variables for references minimizing overhead \\n            left = 0 \\n            right = 1 \\n            # if root has a left and right, we can utilize it in the leaf map \\n            # check left and right and record as needed \\n            if root.left : \\n                leaf_map[root.left.val] = (min_prob, root.val, root, left)\\n            if root.right : \\n                leaf_map[root.right.val] = (root.val, max_prob, root, right) \\n          \\n            # since root is now pinned, remove from map \\n            del tree_map[root.val]\\n    \\n            # while you have a tree map \\n            while tree_map : \\n                # determine if a tree exists succesfully for the selected item\\n                tree_exists = False \\n                # for leaf key, leaf state in leaf map items \\n                for leaf, (low, high, parent, side) in leaf_map.items() : \\n                    # if leaf in tree map \\n                    if leaf in tree_map : \\n                        # make a new tree based off of tree map via leaf value and update leaf map\\n                        new_tree = tree_map[leaf] \\n                        del leaf_map[leaf]\\n\\n                        # satisfy left and right in bounds of low and high of leaf state \\n                        # on failure to satisfy all, none satisfy, so may return None \\n                        if new_tree.left : \\n                            if low < new_tree.left.val < high and new_tree.left.val not in leaf_map : \\n                                leaf_map[new_tree.left.val] = (low, new_tree.val, new_tree, left)\\n                            else : \\n                                return None \\n\\n                        if new_tree.right : \\n                            if low < new_tree.right.val < high and new_tree.right.val not in leaf_map : \\n                                leaf_map[new_tree.right.val] = (new_tree.val, high, new_tree, right)\\n                            else : \\n                                return None \\n                    \\n                        # if side is left, place on left; otherwise place on right \\n                        if side == left : \\n                            parent.left = new_tree \\n                        else : \\n                            parent.right = new_tree\\n                    \\n                        # if a leaf was satisfied, mark as tree exists \\n                        # this may be superseded by failure of any future leaves still \\n                        tree_exists = True \\n                        # remove the value as needed from the tree map \\n                        del tree_map[new_tree.val]\\n                        # once one satisfaction is found, break for loop \\n                        break \\n                    else : \\n                        continue \\n                # at end of while loop before next iteration, if no leaves satisfied, return None \\n                if tree_exists == False : \\n                    return None \\n            # if all leaves satisfied, and all trees satisfied, tree constructed \\n            return root \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050610,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  TreeNode* canMerge(vector<TreeNode*>& trees) {\\n    unordered_map<int, TreeNode*> valToNode;  // {val: node}\\n    unordered_map<int, int> count;            // {val: freq}\\n\\n    for (TreeNode* tree : trees) {\\n      valToNode[tree->val] = tree;\\n      ++count[tree->val];\\n      if (tree->left)\\n        ++count[tree->left->val];\\n      if (tree->right)\\n        ++count[tree->right->val];\\n    }\\n\\n    for (TreeNode* tree : trees)\\n      if (count[tree->val] == 1) {\\n        if (isValidBST(tree, nullptr, nullptr, valToNode) &&\\n            valToNode.size() <= 1)\\n          return tree;\\n        return nullptr;\\n      }\\n\\n    return nullptr;\\n  }\\n\\n private:\\n  bool isValidBST(TreeNode* tree, TreeNode* minNode, TreeNode* maxNode,\\n                  unordered_map<int, TreeNode*>& valToNode) {\\n    if (tree == nullptr)\\n      return true;\\n    if (minNode && tree->val <= minNode->val)\\n      return false;\\n    if (maxNode && tree->val >= maxNode->val)\\n      return false;\\n    if (!tree->left && !tree->right && valToNode.count(tree->val)) {\\n      const int val = tree->val;\\n      tree->left = valToNode[val]->left;\\n      tree->right = valToNode[val]->right;\\n      valToNode.erase(val);\\n    }\\n\\n    return isValidBST(tree->left, minNode, tree, valToNode) &&\\n           isValidBST(tree->right, tree, maxNode, valToNode);\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  TreeNode* canMerge(vector<TreeNode*>& trees) {\\n    unordered_map<int, TreeNode*> valToNode;  // {val: node}\\n    unordered_map<int, int> count;            // {val: freq}\\n\\n    for (TreeNode* tree : trees) {\\n      valToNode[tree->val] = tree;\\n      ++count[tree->val];\\n      if (tree->left)\\n        ++count[tree->left->val];\\n      if (tree->right)\\n        ++count[tree->right->val];\\n    }\\n\\n    for (TreeNode* tree : trees)\\n      if (count[tree->val] == 1) {\\n        if (isValidBST(tree, nullptr, nullptr, valToNode) &&\\n            valToNode.size() <= 1)\\n          return tree;\\n        return nullptr;\\n      }\\n\\n    return nullptr;\\n  }\\n\\n private:\\n  bool isValidBST(TreeNode* tree, TreeNode* minNode, TreeNode* maxNode,\\n                  unordered_map<int, TreeNode*>& valToNode) {\\n    if (tree == nullptr)\\n      return true;\\n    if (minNode && tree->val <= minNode->val)\\n      return false;\\n    if (maxNode && tree->val >= maxNode->val)\\n      return false;\\n    if (!tree->left && !tree->right && valToNode.count(tree->val)) {\\n      const int val = tree->val;\\n      tree->left = valToNode[val]->left;\\n      tree->right = valToNode[val]->right;\\n      valToNode.erase(val);\\n    }\\n\\n    return isValidBST(tree->left, minNode, tree, valToNode) &&\\n           isValidBST(tree->right, tree, maxNode, valToNode);\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027705,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  bool checkValidBst(TreeNode* root, int mini,int maxi)\\n  {\\n      if (root==NULL) return true;\\n      if (root->val<=mini || root->val>=maxi) return false;\\n      return checkValidBst(root->left,mini,root->val) && checkValidBst(root->right,root->val,maxi);\\n  }\\n    TreeNode* helper(TreeNode* root, map<int,TreeNode*>&mp)\\n    {\\n        if (root==NULL) return NULL;\\n        if (mp.find(root->val)!=mp.end())\\n        {\\n            TreeNode* tree=mp[root->val];\\n            root->left=tree->left;\\n            root->right=tree->right;\\n            mp.erase(root->val);\\n        }\\n        if (root->left)\\n        root->left=helper(root->left,mp);\\n        if (root->right)\\n        root->right=helper(root->right,mp);\\n        return root;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) \\n    {\\n        if (trees.size()==1) return trees[0];\\n        set<int>leaves;\\n        for (auto it:trees)\\n        {\\n            if (it->left) leaves.insert(it->left->val);\\n            if (it->right) leaves.insert(it->right->val);\\n        }\\n        TreeNode* root=NULL;\\n        for (auto it: trees)\\n        {\\n            if (leaves.find(it->val)==leaves.end())\\n            {\\n                root=it;\\n            }\\n        }\\n        if (root==NULL) return NULL;\\n        set<TreeNode*>rem;\\n        for (auto it: trees)\\n        {\\n            if (it->val!=root->val) rem.insert(it);\\n        }\\n        map<int,TreeNode*>mp;\\n        for (auto it: rem)\\n        {\\n            mp[it->val]=it;\\n        }\\n        TreeNode* ans=helper(root,mp);\\n\\n        if (checkValidBst(root,INT_MIN,INT_MAX) && mp.size()==0 ) return root;\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  bool checkValidBst(TreeNode* root, int mini,int maxi)\\n  {\\n      if (root==NULL) return true;\\n      if (root->val<=mini || root->val>=maxi) return false;\\n      return checkValidBst(root->left,mini,root->val) && checkValidBst(root->right,root->val,maxi);\\n  }\\n    TreeNode* helper(TreeNode* root, map<int,TreeNode*>&mp)\\n    {\\n        if (root==NULL) return NULL;\\n        if (mp.find(root->val)!=mp.end())\\n        {\\n            TreeNode* tree=mp[root->val];\\n            root->left=tree->left;\\n            root->right=tree->right;\\n            mp.erase(root->val);\\n        }\\n        if (root->left)\\n        root->left=helper(root->left,mp);\\n        if (root->right)\\n        root->right=helper(root->right,mp);\\n        return root;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) \\n    {\\n        if (trees.size()==1) return trees[0];\\n        set<int>leaves;\\n        for (auto it:trees)\\n        {\\n            if (it->left) leaves.insert(it->left->val);\\n            if (it->right) leaves.insert(it->right->val);\\n        }\\n        TreeNode* root=NULL;\\n        for (auto it: trees)\\n        {\\n            if (leaves.find(it->val)==leaves.end())\\n            {\\n                root=it;\\n            }\\n        }\\n        if (root==NULL) return NULL;\\n        set<TreeNode*>rem;\\n        for (auto it: trees)\\n        {\\n            if (it->val!=root->val) rem.insert(it);\\n        }\\n        map<int,TreeNode*>mp;\\n        for (auto it: rem)\\n        {\\n            mp[it->val]=it;\\n        }\\n        TreeNode* ans=helper(root,mp);\\n\\n        if (checkValidBst(root,INT_MIN,INT_MAX) && mp.size()==0 ) return root;\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009835,
                "title": "simple-easy-well-explained",
                "content": "Yess it\\'s just all about heavy and careful implimentation\\nfirst we need to mark all child and parent  here as we will mark parent by value of left and right child iff exists\\nso we will have a map\\n```\\nmap<int , TreeNode*> par  // child_values => parent\\n```\\nand for binary tree we need to have range of values each node covers \\n```\\nmap<TreeNode* ,pair<int,int>> range\\n```\\nand now just begin\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    #define f first\\n    #define s second\\n     bool check(TreeNode* root,int minl,int maxr)  // check valid tree\\n    {\\n        if(!root)\\n            return true;\\n        if(root->val >minl and root->val<maxr)\\n        {\\n            return check(root->left,minl,root->val) and check(root->right,root->val,maxr);\\n        }\\n        return false;\\n    }\\n   \\n    TreeNode* canMerge(vector<TreeNode*>& trees) \\n    {\\n        map<int, TreeNode* > par;\\n        map<TreeNode* , pair<int,int>> range;\\n        for(auto i: trees) // mark parents and range for each root node\\n        {\\n            if(i->left) \\n            {\\n                par[i->left->val]=i;\\n                range[i].f = i->left->val;\\n            }else range[i].f=i->val;\\n            if(i->right)\\n            {\\n                par[i->right->val]=i;\\n                range[i].s = i->right->val;\\n            }else range[i].s=i->val;\\n        }\\n        \\n        TreeNode* root=NULL;\\n        int count=0;\\n        int n= trees.size();\\n        for(auto i: trees)\\n        {\\n            if(par.find(i->val)!=par.end())\\n            {\\n                if(i->val<par[i->val]->val)//left;\\n                {\\n                    if(range[i].s<par[i->val]->val)  // if  it\\'s range values are smaller than root\\n                    {\\n                        par[i->val]->left=i;\\n                        range[par[i->val]].f=range[i].f;// update the minimum value of range after adding the left child\\n                            count++;\\n                    }else return NULL; // else it\\'s not fit => so no use=> no solution \\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// do same thing for right child\\n                }else if(i->val>par[i->val]->val)//right;  \\n                {\\n                    if(range[i].s>par[i->val]->val)\\n                    {\\n                        par[i->val]->right=i;\\n                        range[par[i->val]].s=range[i].s;\\n                            count++;\\n                    }else return NULL;\\n                }\\n            }else\\n            {\\n                if(root==NULL) // only one root is possible if we encounter multiple so no solution\\n                {\\n                    root=i;\\n                    \\n                }else return NULL;\\n            }\\n        \\n        }\\n        if(check(root, INT_MIN, INT_MAX)==false) return NULL;  // juct check for surity so that it\\'s valid tree  of unique values\\n        return count==n-1? root: NULL;  // check that we merged n-1  time \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nmap<int , TreeNode*> par  // child_values => parent\\n```\n```\\nmap<TreeNode* ,pair<int,int>> range\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    #define f first\\n    #define s second\\n     bool check(TreeNode* root,int minl,int maxr)  // check valid tree\\n    {\\n        if(!root)\\n            return true;\\n        if(root->val >minl and root->val<maxr)\\n        {\\n            return check(root->left,minl,root->val) and check(root->right,root->val,maxr);\\n        }\\n        return false;\\n    }\\n   \\n    TreeNode* canMerge(vector<TreeNode*>& trees) \\n    {\\n        map<int, TreeNode* > par;\\n        map<TreeNode* , pair<int,int>> range;\\n        for(auto i: trees) // mark parents and range for each root node\\n        {\\n            if(i->left) \\n            {\\n                par[i->left->val]=i;\\n                range[i].f = i->left->val;\\n            }else range[i].f=i->val;\\n            if(i->right)\\n            {\\n                par[i->right->val]=i;\\n                range[i].s = i->right->val;\\n            }else range[i].s=i->val;\\n        }\\n        \\n        TreeNode* root=NULL;\\n        int count=0;\\n        int n= trees.size();\\n        for(auto i: trees)\\n        {\\n            if(par.find(i->val)!=par.end())\\n            {\\n                if(i->val<par[i->val]->val)//left;\\n                {\\n                    if(range[i].s<par[i->val]->val)  // if  it\\'s range values are smaller than root\\n                    {\\n                        par[i->val]->left=i;\\n                        range[par[i->val]].f=range[i].f;// update the minimum value of range after adding the left child\\n                            count++;\\n                    }else return NULL; // else it\\'s not fit => so no use=> no solution \\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// do same thing for right child\\n                }else if(i->val>par[i->val]->val)//right;  \\n                {\\n                    if(range[i].s>par[i->val]->val)\\n                    {\\n                        par[i->val]->right=i;\\n                        range[par[i->val]].s=range[i].s;\\n                            count++;\\n                    }else return NULL;\\n                }\\n            }else\\n            {\\n                if(root==NULL) // only one root is possible if we encounter multiple so no solution\\n                {\\n                    root=i;\\n                    \\n                }else return NULL;\\n            }\\n        \\n        }\\n        if(check(root, INT_MIN, INT_MAX)==false) return NULL;  // juct check for surity so that it\\'s valid tree  of unique values\\n        return count==n-1? root: NULL;  // check that we merged n-1  time \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958516,
                "title": "well-commented",
                "content": "\\n# Code\\n```\\n/*\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    bool check(TreeNode* root,int minl,int maxr)\\n    {\\n        if(!root)\\n            return true;\\n        if(root->val >minl and root->val<maxr)\\n        {\\n            return check(root->left,minl,root->val) and check(root->right,root->val,maxr);\\n        }\\n        return false;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,TreeNode*> par;//to map values of node to it\\'s parent node\\n        unordered_map<TreeNode*,pair<int,int>> range;//range to store min and max values in BST rooted at a node \"TreeNode\"\\n        TreeNode* root=NULL;//root of final BST after n-1 merges\\n        int merges=0;//count of merge operation\\n        //Build par and range maps\\n        for(auto &node:trees){\\n            range[node].F= (node->left!=NULL ? node->left->val:node->val);\\n            range[node].S= (node->right!=NULL ? node->right->val:node->val);\\n            if(node->left!=NULL){\\n                par[node->left->val]=node;\\n            }\\n            if(node->right!=NULL){\\n                par[node->right->val]=node;\\n            }\\n        }\\n        for(auto &node:trees){\\n            \\n            //node->current_node\\n            \\n            if(par.find(node->val)!=par.end()){\\n                //It means this node may become made a child of another node. So try to make it child if satisfies the condition of BST\\n                TreeNode* parent=par[node->val];//parent of the current node\\n                \\n                //if the value of current node is less than value of parent node,it must be placed as left chid \\n                if(node->val < parent->val){\\n                    //Now we need to check that max value in substree of current node should be less than value of parent node\\n                    if(range[node].S< parent->val){\\n                        parent->left= node;\\n                        //Now update min value for parent node\\n                        range[parent].F = range[node].F;\\n                        //increment the no of merges \\n                        merges++;\\n                    }\\n                    else\\n                        return NULL;\\n                }\\n                //Similarily, if the value of current node is greater than value of parent node,it must be placed as right chid \\n                else if(node->val > parent->val){\\n                    //Also the min value in substree of current node should also be greater than value of parent node -> conditions of BST :)\\n                    if(range[node].F > parent->val){\\n                        parent->right=node;\\n                        //Update max value in subtree of parent node\\n                        range[parent].S= range[node].S;\\n                        //Increment the no of merges\\n                        merges++;\\n                    }\\n                    else\\n                        return NULL;\\n                }\\n                else{\\n                    return NULL;\\n                }\\n            }\\n            else{\\n                //It means the current node can be a potential candidate for root node of final BST\\n                if(root==NULL){\\n                    root=node;\\n                }\\n                //If multiple candidates available for root node of final BST just return NULL. We can\\'t form a valid BST\\n                else{\\n                    return NULL;\\n                }\\n            }\\n        }\\n        //Check whether the tree formed is BST or not\\n        if(!check(root,INT_MIN,INT_MAX)){\\n            return NULL;\\n        }\\n        //If the tree formed is BST,then check whether the no of merges is n-1 i.e  it is possible to form a valid BST after performing strictly n-1 operations, \\n        \\n        return (merges == (int)trees.size()-1 ? root:NULL);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    bool check(TreeNode* root,int minl,int maxr)\\n    {\\n        if(!root)\\n            return true;\\n        if(root->val >minl and root->val<maxr)\\n        {\\n            return check(root->left,minl,root->val) and check(root->right,root->val,maxr);\\n        }\\n        return false;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,TreeNode*> par;//to map values of node to it\\'s parent node\\n        unordered_map<TreeNode*,pair<int,int>> range;//range to store min and max values in BST rooted at a node \"TreeNode\"\\n        TreeNode* root=NULL;//root of final BST after n-1 merges\\n        int merges=0;//count of merge operation\\n        //Build par and range maps\\n        for(auto &node:trees){\\n            range[node].F= (node->left!=NULL ? node->left->val:node->val);\\n            range[node].S= (node->right!=NULL ? node->right->val:node->val);\\n            if(node->left!=NULL){\\n                par[node->left->val]=node;\\n            }\\n            if(node->right!=NULL){\\n                par[node->right->val]=node;\\n            }\\n        }\\n        for(auto &node:trees){\\n            \\n            //node->current_node\\n            \\n            if(par.find(node->val)!=par.end()){\\n                //It means this node may become made a child of another node. So try to make it child if satisfies the condition of BST\\n                TreeNode* parent=par[node->val];//parent of the current node\\n                \\n                //if the value of current node is less than value of parent node,it must be placed as left chid \\n                if(node->val < parent->val){\\n                    //Now we need to check that max value in substree of current node should be less than value of parent node\\n                    if(range[node].S< parent->val){\\n                        parent->left= node;\\n                        //Now update min value for parent node\\n                        range[parent].F = range[node].F;\\n                        //increment the no of merges \\n                        merges++;\\n                    }\\n                    else\\n                        return NULL;\\n                }\\n                //Similarily, if the value of current node is greater than value of parent node,it must be placed as right chid \\n                else if(node->val > parent->val){\\n                    //Also the min value in substree of current node should also be greater than value of parent node -> conditions of BST :)\\n                    if(range[node].F > parent->val){\\n                        parent->right=node;\\n                        //Update max value in subtree of parent node\\n                        range[parent].S= range[node].S;\\n                        //Increment the no of merges\\n                        merges++;\\n                    }\\n                    else\\n                        return NULL;\\n                }\\n                else{\\n                    return NULL;\\n                }\\n            }\\n            else{\\n                //It means the current node can be a potential candidate for root node of final BST\\n                if(root==NULL){\\n                    root=node;\\n                }\\n                //If multiple candidates available for root node of final BST just return NULL. We can\\'t form a valid BST\\n                else{\\n                    return NULL;\\n                }\\n            }\\n        }\\n        //Check whether the tree formed is BST or not\\n        if(!check(root,INT_MIN,INT_MAX)){\\n            return NULL;\\n        }\\n        //If the tree formed is BST,then check whether the no of merges is n-1 i.e  it is possible to form a valid BST after performing strictly n-1 operations, \\n        \\n        return (merges == (int)trees.size()-1 ? root:NULL);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917823,
                "title": "structured-code",
                "content": "# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution { \\n    void calc_min_max(vector<TreeNode*>& trees,vector<pair<int,int>>&min_max){\\n        for(int i=0;i<trees.size();i++){\\n            TreeNode* leftd=trees[i];\\n            TreeNode* rightd=trees[i];\\n            int currmin=INT_MAX,currmax=INT_MIN;\\n            while(leftd!=NULL){\\n                currmin=min(currmin,leftd->val);\\n                leftd=leftd->left;\\n            }\\n            while(rightd!=NULL){\\n                currmax=max(currmax,rightd->val);\\n                rightd=rightd->right;\\n            }\\n            min_max.push_back({currmin,currmax});\\n        }\\n    }\\n\\n    void calc_head_bst(vector<TreeNode*>&trees,int &head_ind,map<int,int>&tree_index){\\n        int sum=0;\\n        unordered_set<int>values;\\n        for(int i=0;i<trees.size();i++){\\n            if(trees[i]==NULL)continue;\\n            sum+=i;\\n            queue<TreeNode*>q;\\n            q.push(trees[i]);\\n            while(!q.empty()){\\n                TreeNode* curr=q.front();\\n                q.pop();\\n                if(trees[i]!=curr){\\n                    if(values.count(curr->val)!=0){\\n                        head_ind=-1;\\n                        return;\\n                    }\\n                    values.insert(curr->val);\\n                }\\n                if(curr->left==NULL&&curr->right==NULL&&curr!=trees[i]&&tree_index.count(curr->val)!=0){\\n                    sum-=tree_index[curr->val];\\n                }\\n                if(curr->left!=NULL)q.push(curr->left);\\n                if(curr->right!=NULL)q.push(curr->right);\\n            }\\n        }\\n        head_ind=sum;\\n    }\\n    \\n    TreeNode* buildTree(vector<TreeNode*>&trees,vector<pair<int,int>>&min_max,map<int,int>&tree_index,int &head){\\n        int n=trees.size();\\n        vector<int>vis(n,0);\\n        vis[head]=1;\\n        queue<pair<TreeNode*,pair<int,int>>>qpp;\\n        qpp.push({trees[head],{INT_MIN,INT_MAX}});\\n        \\n        while(!qpp.empty()){\\n            TreeNode* curr=qpp.front().first;\\n            int minReq=qpp.front().second.first;\\n            int maxLim=qpp.front().second.second;\\n            qpp.pop();\\n            \\n            if(curr->left==NULL&&curr->right==NULL){\\n                int curr_val=curr->val;\\n                if(tree_index.count(curr_val)!=0){\\n                    int index=tree_index[curr_val];\\n                    if(vis[index]==1&&index!=head){\\n                        return NULL;\\n                    }\\n                    vis[index]=1;\\n                    if(min_max[index].first<=minReq||min_max[index].second>=maxLim){\\n                        return NULL;\\n                    }\\n                    \\n                    curr->left=trees[index]->left;\\n                    curr->right=trees[index]->right;\\n                }\\n            }\\n            if(curr->left!=NULL){\\n                qpp.push({curr->left,{minReq,curr->val}});\\n            }\\n            if(curr->right!=NULL){\\n                qpp.push({curr->right,{curr->val,maxLim}});\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(i!=head&&!vis[i]){\\n                return NULL;\\n            }\\n        }\\n        return trees[head];\\n    }\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,int>tree_index;\\n        for(int i=0;i<trees.size();i++){\\n            if(trees[i]!=NULL){\\n                tree_index[trees[i]->val]=i;\\n            }\\n        }\\n        //calculation min_max of each tree\\n        vector<pair<int,int>>min_max;\\n        calc_min_max(trees,min_max);\\n\\n        //calculating head of bst\\n        int head_ind=-1;\\n        calc_head_bst(trees,head_ind,tree_index);\\n        if(head_ind<0||head_ind>=trees.size())return NULL;\\n\\n        TreeNode* ans=buildTree(trees,min_max,tree_index,head_ind);\\n\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution { \\n    void calc_min_max(vector<TreeNode*>& trees,vector<pair<int,int>>&min_max){\\n        for(int i=0;i<trees.size();i++){\\n            TreeNode* leftd=trees[i];\\n            TreeNode* rightd=trees[i];\\n            int currmin=INT_MAX,currmax=INT_MIN;\\n            while(leftd!=NULL){\\n                currmin=min(currmin,leftd->val);\\n                leftd=leftd->left;\\n            }\\n            while(rightd!=NULL){\\n                currmax=max(currmax,rightd->val);\\n                rightd=rightd->right;\\n            }\\n            min_max.push_back({currmin,currmax});\\n        }\\n    }\\n\\n    void calc_head_bst(vector<TreeNode*>&trees,int &head_ind,map<int,int>&tree_index){\\n        int sum=0;\\n        unordered_set<int>values;\\n        for(int i=0;i<trees.size();i++){\\n            if(trees[i]==NULL)continue;\\n            sum+=i;\\n            queue<TreeNode*>q;\\n            q.push(trees[i]);\\n            while(!q.empty()){\\n                TreeNode* curr=q.front();\\n                q.pop();\\n                if(trees[i]!=curr){\\n                    if(values.count(curr->val)!=0){\\n                        head_ind=-1;\\n                        return;\\n                    }\\n                    values.insert(curr->val);\\n                }\\n                if(curr->left==NULL&&curr->right==NULL&&curr!=trees[i]&&tree_index.count(curr->val)!=0){\\n                    sum-=tree_index[curr->val];\\n                }\\n                if(curr->left!=NULL)q.push(curr->left);\\n                if(curr->right!=NULL)q.push(curr->right);\\n            }\\n        }\\n        head_ind=sum;\\n    }\\n    \\n    TreeNode* buildTree(vector<TreeNode*>&trees,vector<pair<int,int>>&min_max,map<int,int>&tree_index,int &head){\\n        int n=trees.size();\\n        vector<int>vis(n,0);\\n        vis[head]=1;\\n        queue<pair<TreeNode*,pair<int,int>>>qpp;\\n        qpp.push({trees[head],{INT_MIN,INT_MAX}});\\n        \\n        while(!qpp.empty()){\\n            TreeNode* curr=qpp.front().first;\\n            int minReq=qpp.front().second.first;\\n            int maxLim=qpp.front().second.second;\\n            qpp.pop();\\n            \\n            if(curr->left==NULL&&curr->right==NULL){\\n                int curr_val=curr->val;\\n                if(tree_index.count(curr_val)!=0){\\n                    int index=tree_index[curr_val];\\n                    if(vis[index]==1&&index!=head){\\n                        return NULL;\\n                    }\\n                    vis[index]=1;\\n                    if(min_max[index].first<=minReq||min_max[index].second>=maxLim){\\n                        return NULL;\\n                    }\\n                    \\n                    curr->left=trees[index]->left;\\n                    curr->right=trees[index]->right;\\n                }\\n            }\\n            if(curr->left!=NULL){\\n                qpp.push({curr->left,{minReq,curr->val}});\\n            }\\n            if(curr->right!=NULL){\\n                qpp.push({curr->right,{curr->val,maxLim}});\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(i!=head&&!vis[i]){\\n                return NULL;\\n            }\\n        }\\n        return trees[head];\\n    }\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,int>tree_index;\\n        for(int i=0;i<trees.size();i++){\\n            if(trees[i]!=NULL){\\n                tree_index[trees[i]->val]=i;\\n            }\\n        }\\n        //calculation min_max of each tree\\n        vector<pair<int,int>>min_max;\\n        calc_min_max(trees,min_max);\\n\\n        //calculating head of bst\\n        int head_ind=-1;\\n        calc_head_bst(trees,head_ind,tree_index);\\n        if(head_ind<0||head_ind>=trees.size())return NULL;\\n\\n        TreeNode* ans=buildTree(trees,min_max,tree_index,head_ind);\\n\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809888,
                "title": "beats-cpp-c-fastest-easy-to-unerstand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach :\\nTime complexity : O(n)\\n\\nSo, first I have inserted all the leaf nodes to parent <key,value> pairs are stored.\\n\\nThe the unordered map is stored to get the root of the tree having leaf value same as root2->val\\nHere in the image, 2 is root2 (tree[0]) and then I will find the root of the tree having a leaf node value as 2. So using unordered_map it becomes easy to find. So while searching I get the TreeNode* 3 (i.e. the root of leaf node value == 2)\\n\\nJoining Part :\\nSo to join a bst 1 to another bst 2, i will check if I\\'m adding the bst1 to left of bst2, then I have to check if the right of bst1 if smaller than root value, if it is smaller then add the bst1 to bst2 or else return NULL.\\n\\nSo in the Above example :\\nTaking (tree[0] and tree[1]) into consideration, tree[0] will be added to left of tree[1]. So I check if the right value of right of 2 is smaller than 3 (ie the root of tree[1]), here it does not exist so then add the tree[0] to tree[1].\\n\\nBelow example :\\nTaking (tree[0] and tree[1]) into consideration, tree[1] will be added to left of tree[0].\\nSo I check if the right value of right of 3 (tree[1]) is smaller than 5 (ie the root of tree[1]), here the value if 6>5, so return NULL\\n\\nSimilarly, do the checks while adding the bst to right, check if the value of bst1\\'s left is greater than the root of bst2.\\nAnd then finally after connecting the trees, check if there is only 1 single connected tree or not. If there is only one connected tree, then just check if it is a valid bst.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$  -->\\n\\n\\n> - Space complexity:O(N)\\n\\n---\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n---\\n\\n\\n---\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void collectNodes(unordered_map<int, TreeNode*>& mp, TreeNode* node) {\\n\\n        if(!node) return;\\n        mp[node->val] = node;\\n        collectNodes(mp, node->left);\\n        collectNodes(mp, node->right);\\n    }\\n\\n    void makeTree(unordered_map<int, TreeNode*>& mp, TreeNode*& node, int& cnt) {\\n\\n        if(!node) return;\\n        if(!node->left && !node->right && mp[node->val]) {\\n            node = mp[node->val];\\n            mp[node->val] = NULL;\\n            cnt++;\\n        }\\n        makeTree(mp, node->left, cnt);\\n        makeTree(mp, node->right, cnt);\\n    }\\n    \\n    bool validateBST(TreeNode* root, TreeNode* low, TreeNode* high) {\\n        \\n        if(!root) return true;\\n        if((low && root->val <= low->val) || \\n           (high && root->val >= high->val)) return false;\\n        \\n        return validateBST(root->left, low, root) && \\n                validateBST(root->right, root, high);\\n    }\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n         if(trees.size() == 1) {\\n            return validateBST(trees[0], NULL, NULL) ? trees[0] : NULL;\\n        }\\n\\n        unordered_map<int, TreeNode*> mp;\\n        for(auto& node: trees) {\\n            collectNodes(mp, node->left);\\n            collectNodes(mp, node->right);\\n        }\\n\\n        TreeNode* root = NULL;\\n        for(auto& node: trees) {\\n            if(mp.count(node->val)) mp[node->val] = node;\\n            else if(root) return NULL;\\n            else root = node;\\n        }\\n\\n        if(!root) return NULL;\\n\\n        int cnt = 0;\\n        makeTree(mp, root, cnt);\\n        if(cnt != mp.size()) return NULL;\\n        \\n        return validateBST(root, NULL, NULL) ? root : NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void collectNodes(unordered_map<int, TreeNode*>& mp, TreeNode* node) {\\n\\n        if(!node) return;\\n        mp[node->val] = node;\\n        collectNodes(mp, node->left);\\n        collectNodes(mp, node->right);\\n    }\\n\\n    void makeTree(unordered_map<int, TreeNode*>& mp, TreeNode*& node, int& cnt) {\\n\\n        if(!node) return;\\n        if(!node->left && !node->right && mp[node->val]) {\\n            node = mp[node->val];\\n            mp[node->val] = NULL;\\n            cnt++;\\n        }\\n        makeTree(mp, node->left, cnt);\\n        makeTree(mp, node->right, cnt);\\n    }\\n    \\n    bool validateBST(TreeNode* root, TreeNode* low, TreeNode* high) {\\n        \\n        if(!root) return true;\\n        if((low && root->val <= low->val) || \\n           (high && root->val >= high->val)) return false;\\n        \\n        return validateBST(root->left, low, root) && \\n                validateBST(root->right, root, high);\\n    }\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n         if(trees.size() == 1) {\\n            return validateBST(trees[0], NULL, NULL) ? trees[0] : NULL;\\n        }\\n\\n        unordered_map<int, TreeNode*> mp;\\n        for(auto& node: trees) {\\n            collectNodes(mp, node->left);\\n            collectNodes(mp, node->right);\\n        }\\n\\n        TreeNode* root = NULL;\\n        for(auto& node: trees) {\\n            if(mp.count(node->val)) mp[node->val] = node;\\n            else if(root) return NULL;\\n            else root = node;\\n        }\\n\\n        if(!root) return NULL;\\n\\n        int cnt = 0;\\n        makeTree(mp, root, cnt);\\n        if(cnt != mp.size()) return NULL;\\n        \\n        return validateBST(root, NULL, NULL) ? root : NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387203,
                "title": "just-implement-the-statements-given-in-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# UpVote\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        \\n        HashMap <Integer,TreeNode> map = new HashMap <Integer,TreeNode>();\\n\\n        for(int i = 0; i < trees.size(); i++)\\n        {\\n            if(map.containsKey(trees.get(i).val))\\n            {\\n                return null;\\n            }\\n\\n            map.put(trees.get(i).val, trees.get(i));\\n        }\\n\\n        TreeNode root = trees.get(0);\\n\\n        for(int i = 0; i < trees.size(); i++)\\n        {\\n            if(map.containsKey(trees.get(i).val) && dfs(trees.get(i), map))\\n            {\\n                root = trees.get(i);\\n\\n                map.put(root.val, root);\\n            }\\n        }\\n\\n        if(map.size() == 1 && root != null)\\n        {\\n            return check(root, Integer.MIN_VALUE, Integer.MAX_VALUE) == true ? root : null;\\n        }\\n\\n        return null;\\n    }\\n    \\n\\n    public boolean check(TreeNode root, int leftMin, int rightMin)\\n    {\\n        \\n        if(root == null)\\n        {\\n            return true;\\n        }\\n\\n        if(root.val <= leftMin || root.val >= rightMin)\\n        {\\n            return false;\\n        }\\n\\n        return check(root.left, leftMin, root.val) & check(root.right, root.val, rightMin);\\n    }\\n\\n    public boolean dfs(TreeNode node, HashMap <Integer,TreeNode> map)\\n    {\\n        boolean flag = false;\\n\\n        if(node.left != null)\\n        {\\n            if(map.containsKey(node.left.val))\\n            {\\n                node.left = map.get(node.left.val);\\n                map.remove(node.left.val);\\n                flag |= dfs(node.left, map);\\n                flag |= true;\\n            }\\n        }\\n        \\n        if(node.right != null)\\n        {\\n            if(map.containsKey(node.right.val))\\n            {\\n                node.right = map.get(node.right.val);\\n                map.remove(node.right.val);\\n                flag |= dfs(node.right, map);\\n                flag |= true;\\n            }\\n            \\n        }\\n\\n        return flag;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        \\n        HashMap <Integer,TreeNode> map = new HashMap <Integer,TreeNode>();\\n\\n        for(int i = 0; i < trees.size(); i++)\\n        {\\n            if(map.containsKey(trees.get(i).val))\\n            {\\n                return null;\\n            }\\n\\n            map.put(trees.get(i).val, trees.get(i));\\n        }\\n\\n        TreeNode root = trees.get(0);\\n\\n        for(int i = 0; i < trees.size(); i++)\\n        {\\n            if(map.containsKey(trees.get(i).val) && dfs(trees.get(i), map))\\n            {\\n                root = trees.get(i);\\n\\n                map.put(root.val, root);\\n            }\\n        }\\n\\n        if(map.size() == 1 && root != null)\\n        {\\n            return check(root, Integer.MIN_VALUE, Integer.MAX_VALUE) == true ? root : null;\\n        }\\n\\n        return null;\\n    }\\n    \\n\\n    public boolean check(TreeNode root, int leftMin, int rightMin)\\n    {\\n        \\n        if(root == null)\\n        {\\n            return true;\\n        }\\n\\n        if(root.val <= leftMin || root.val >= rightMin)\\n        {\\n            return false;\\n        }\\n\\n        return check(root.left, leftMin, root.val) & check(root.right, root.val, rightMin);\\n    }\\n\\n    public boolean dfs(TreeNode node, HashMap <Integer,TreeNode> map)\\n    {\\n        boolean flag = false;\\n\\n        if(node.left != null)\\n        {\\n            if(map.containsKey(node.left.val))\\n            {\\n                node.left = map.get(node.left.val);\\n                map.remove(node.left.val);\\n                flag |= dfs(node.left, map);\\n                flag |= true;\\n            }\\n        }\\n        \\n        if(node.right != null)\\n        {\\n            if(map.containsKey(node.right.val))\\n            {\\n                node.right = map.get(node.right.val);\\n                map.remove(node.right.val);\\n                flag |= dfs(node.right, map);\\n                flag |= true;\\n            }\\n            \\n        }\\n\\n        return flag;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239742,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn can_merge(trees: Vec<Option<Rc<RefCell<TreeNode>>>>) -> Option<Rc<RefCell<TreeNode>>> {\\n        use std::collections::{HashMap, HashSet};\\n        fn add_leaf(\\n            r: Option<Rc<RefCell<TreeNode>>>,\\n            leaves: &mut Vec<Option<Rc<RefCell<TreeNode>>>>,\\n            roots: &mut HashMap<i32, Option<Rc<RefCell<TreeNode>>>>,\\n            unique_vals: &mut HashSet<i32>,\\n        ) {\\n            if r.is_some() {\\n                let val = r.as_ref().unwrap().borrow().val;\\n                unique_vals.insert(val);\\n                if roots.contains_key(&val) {\\n                    leaves.push(r);\\n                }\\n            }\\n        }\\n\\n        fn valid_nodes(r: Option<Rc<RefCell<TreeNode>>>, min_left: i32, max_right: i32) -> usize {\\n            let val = r.as_ref().map(|r| r.borrow().val).unwrap_or(0);\\n            if r.is_none() || val <= min_left || val >= max_right {\\n                return 0;\\n            }\\n            let left = r.as_ref().unwrap().borrow().left.clone();\\n            let right = r.as_ref().unwrap().borrow().right.clone();\\n            let v_left = valid_nodes(left, min_left, val);\\n            let v_right = valid_nodes(right, val, max_right);\\n            1 + v_left + v_right\\n        }\\n\\n        let mut unique_vals = HashSet::new();\\n        let mut roots = HashMap::new();\\n        let mut leaves = Vec::new();\\n        for t in trees.iter() {\\n            let val = t.as_ref()?.borrow().val;\\n            roots.insert(val, t.clone());\\n        }\\n        for t in trees.iter() {\\n            let val = t.as_ref()?.borrow().val;\\n            let left = t.as_ref()?.borrow().left.clone();\\n            let right = t.as_ref()?.borrow().right.clone();\\n            unique_vals.insert(val);\\n            add_leaf(left, &mut leaves, &mut roots, &mut unique_vals);\\n            add_leaf(right, &mut leaves, &mut roots, &mut unique_vals);\\n        }\\n        for leaf in leaves {\\n            let val = leaf.as_ref()?.borrow().val;\\n            let root = roots.get_mut(&val)?;\\n            leaf.as_ref()?.borrow_mut().left = root.as_ref()?.borrow().left.clone();\\n            leaf.as_ref()?.borrow_mut().right = root.as_ref()?.borrow().right.clone();\\n            roots.remove(&val);\\n        }\\n        let first_node = roots.values().next().cloned()?;\\n        if roots.len() == 1 && valid_nodes(first_node.clone(), std::i32::MIN, std::i32::MAX) == unique_vals.len() {\\n            first_node\\n        } else {\\n            None\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn can_merge(trees: Vec<Option<Rc<RefCell<TreeNode>>>>) -> Option<Rc<RefCell<TreeNode>>> {\\n        use std::collections::{HashMap, HashSet};\\n        fn add_leaf(\\n            r: Option<Rc<RefCell<TreeNode>>>,\\n            leaves: &mut Vec<Option<Rc<RefCell<TreeNode>>>>,\\n            roots: &mut HashMap<i32, Option<Rc<RefCell<TreeNode>>>>,\\n            unique_vals: &mut HashSet<i32>,\\n        ) {\\n            if r.is_some() {\\n                let val = r.as_ref().unwrap().borrow().val;\\n                unique_vals.insert(val);\\n                if roots.contains_key(&val) {\\n                    leaves.push(r);\\n                }\\n            }\\n        }\\n\\n        fn valid_nodes(r: Option<Rc<RefCell<TreeNode>>>, min_left: i32, max_right: i32) -> usize {\\n            let val = r.as_ref().map(|r| r.borrow().val).unwrap_or(0);\\n            if r.is_none() || val <= min_left || val >= max_right {\\n                return 0;\\n            }\\n            let left = r.as_ref().unwrap().borrow().left.clone();\\n            let right = r.as_ref().unwrap().borrow().right.clone();\\n            let v_left = valid_nodes(left, min_left, val);\\n            let v_right = valid_nodes(right, val, max_right);\\n            1 + v_left + v_right\\n        }\\n\\n        let mut unique_vals = HashSet::new();\\n        let mut roots = HashMap::new();\\n        let mut leaves = Vec::new();\\n        for t in trees.iter() {\\n            let val = t.as_ref()?.borrow().val;\\n            roots.insert(val, t.clone());\\n        }\\n        for t in trees.iter() {\\n            let val = t.as_ref()?.borrow().val;\\n            let left = t.as_ref()?.borrow().left.clone();\\n            let right = t.as_ref()?.borrow().right.clone();\\n            unique_vals.insert(val);\\n            add_leaf(left, &mut leaves, &mut roots, &mut unique_vals);\\n            add_leaf(right, &mut leaves, &mut roots, &mut unique_vals);\\n        }\\n        for leaf in leaves {\\n            let val = leaf.as_ref()?.borrow().val;\\n            let root = roots.get_mut(&val)?;\\n            leaf.as_ref()?.borrow_mut().left = root.as_ref()?.borrow().left.clone();\\n            leaf.as_ref()?.borrow_mut().right = root.as_ref()?.borrow().right.clone();\\n            roots.remove(&val);\\n        }\\n        let first_node = roots.values().next().cloned()?;\\n        if roots.len() == 1 && valid_nodes(first_node.clone(), std::i32::MIN, std::i32::MAX) == unique_vals.len() {\\n            first_node\\n        } else {\\n            None\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3142584,
                "title": "c-hash-dfs-depth-first-search-leetcode-98-validate-binary-search-tree",
                "content": "# Code\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        if (trees.size() == 1 ) return trees[0];\\n        for (int i = 0; i < trees.size(); i++ ) {\\n            map_head_[trees[i]->val] = trees[i];\\n        }\\n\\n        for (int i = 0; i < trees.size(); i++ ) {\\n            buildLeaf(trees[i]);\\n        }\\n\\n        if (map_head_.size() == 1) {\\n            auto result = map_head_.begin()->second;\\n\\n            if (isValidBST(result)) {\\n                return result;\\n            }\\n        }\\n\\n        return nullptr;\\n    }\\n\\nprivate:\\n    unordered_map<int, TreeNode*> map_head_;\\n    unordered_set<int> history_;\\n    int isValidBST_cnt_ = 0;\\n\\n    TreeNode* buildLeaf(TreeNode* head) {\\n        if (!head) {\\n            return nullptr;\\n        }\\n\\n        history_.insert(head->val);\\n\\n        if (!head->left && !head->right) {\\n            if (map_head_.count(head->val) &&  \\n                head != map_head_[head->val]) {\\n                auto treeRoot = map_head_[head->val];\\n                map_head_.erase(head->val);\\n                return treeRoot;\\n            }\\n        }\\n        head->left = buildLeaf(head->left);\\n        head->right = buildLeaf(head->right);\\n\\n        return head;\\n    }\\n\\n    //  leetCode 98. Validate Binary Search Tree\\n    bool isValidBST(TreeNode* head) {\\n        TreeNode* prev = nullptr;\\n        return isValidBST(head, prev) && isValidBST_cnt_ == history_.size();\\n    }\\n\\n    bool isValidBST(TreeNode* head, TreeNode*& prev) {\\n        if (!head) {\\n            return true;\\n        }\\n\\n        isValidBST_cnt_++;\\n\\n        if (!isValidBST(head->left, prev)) {\\n            return false;\\n        }\\n        \\n        if (prev && prev->val >= head->val) {\\n            return false;\\n        }\\n\\n        prev = head;\\n        return isValidBST(head->right, prev);\\n    }\\n\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        if (trees.size() == 1 ) return trees[0];\\n        for (int i = 0; i < trees.size(); i++ ) {\\n            map_head_[trees[i]->val] = trees[i];\\n        }\\n\\n        for (int i = 0; i < trees.size(); i++ ) {\\n            buildLeaf(trees[i]);\\n        }\\n\\n        if (map_head_.size() == 1) {\\n            auto result = map_head_.begin()->second;\\n\\n            if (isValidBST(result)) {\\n                return result;\\n            }\\n        }\\n\\n        return nullptr;\\n    }\\n\\nprivate:\\n    unordered_map<int, TreeNode*> map_head_;\\n    unordered_set<int> history_;\\n    int isValidBST_cnt_ = 0;\\n\\n    TreeNode* buildLeaf(TreeNode* head) {\\n        if (!head) {\\n            return nullptr;\\n        }\\n\\n        history_.insert(head->val);\\n\\n        if (!head->left && !head->right) {\\n            if (map_head_.count(head->val) &&  \\n                head != map_head_[head->val]) {\\n                auto treeRoot = map_head_[head->val];\\n                map_head_.erase(head->val);\\n                return treeRoot;\\n            }\\n        }\\n        head->left = buildLeaf(head->left);\\n        head->right = buildLeaf(head->right);\\n\\n        return head;\\n    }\\n\\n    //  leetCode 98. Validate Binary Search Tree\\n    bool isValidBST(TreeNode* head) {\\n        TreeNode* prev = nullptr;\\n        return isValidBST(head, prev) && isValidBST_cnt_ == history_.size();\\n    }\\n\\n    bool isValidBST(TreeNode* head, TreeNode*& prev) {\\n        if (!head) {\\n            return true;\\n        }\\n\\n        isValidBST_cnt_++;\\n\\n        if (!isValidBST(head->left, prev)) {\\n            return false;\\n        }\\n        \\n        if (prev && prev->val >= head->val) {\\n            return false;\\n        }\\n\\n        prev = head;\\n        return isValidBST(head->right, prev);\\n    }\\n\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115463,
                "title": "swift-bfs",
                "content": "**BFS Approach (accepted answer)**\\n```\\nclass Solution {\\n    func canMerge(_ trees: [TreeNode?]) -> TreeNode? {\\n        var rootNodeLookup = [Int: TreeNode]()\\n        var childVals = Set<Int>()\\n        for tree in trees {\\n            guard let tree = tree else { continue }\\n            rootNodeLookup[tree.val] = tree\\n            if let left = tree.left, !childVals.insert(left.val).inserted {\\n                return nil // Fail: child val not unique\\n            }\\n            if let right = tree.right, !childVals.insert(right.val).inserted {\\n                return nil // Fail: child val not unique\\n            }\\n        }\\n        \\n        let potentialRoots = Set(rootNodeLookup.keys).subtracting(childVals)\\n        guard potentialRoots.count == 1 else { return nil } // Fail: not exactly one node is potential root\\n\\n        let rootNode = rootNodeLookup[potentialRoots.first!]!\\n        var leaves = [(rootNode, Int.min, Int.max)]\\n        var count = 0\\n        \\n        while !leaves.isEmpty {\\n            let oldLeaves = leaves\\n            leaves = []\\n            for entry in oldLeaves {\\n                let (leaf, lowerBound, upperBound) = entry\\n                guard lowerBound...upperBound ~= leaf.val else { return nil }  // Fail: current leaf value creates invalid BST\\n                if let rootNode = rootNodeLookup[leaf.val] {\\n                    if let left = rootNode.left {\\n                        leaf.left = left\\n                        leaves.append((left, lowerBound, min(upperBound, leaf.val)))\\n                    }\\n                    if let right = rootNode.right {\\n                        leaf.right = right\\n                        leaves.append((right, max(lowerBound, leaf.val), upperBound))\\n                    }\\n                    count += 1\\n                }\\n            }\\n        }\\n        \\n        return count == trees.count ? rootNode : nil\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func canMerge(_ trees: [TreeNode?]) -> TreeNode? {\\n        var rootNodeLookup = [Int: TreeNode]()\\n        var childVals = Set<Int>()\\n        for tree in trees {\\n            guard let tree = tree else { continue }\\n            rootNodeLookup[tree.val] = tree\\n            if let left = tree.left, !childVals.insert(left.val).inserted {\\n                return nil // Fail: child val not unique\\n            }\\n            if let right = tree.right, !childVals.insert(right.val).inserted {\\n                return nil // Fail: child val not unique\\n            }\\n        }\\n        \\n        let potentialRoots = Set(rootNodeLookup.keys).subtracting(childVals)\\n        guard potentialRoots.count == 1 else { return nil } // Fail: not exactly one node is potential root\\n\\n        let rootNode = rootNodeLookup[potentialRoots.first!]!\\n        var leaves = [(rootNode, Int.min, Int.max)]\\n        var count = 0\\n        \\n        while !leaves.isEmpty {\\n            let oldLeaves = leaves\\n            leaves = []\\n            for entry in oldLeaves {\\n                let (leaf, lowerBound, upperBound) = entry\\n                guard lowerBound...upperBound ~= leaf.val else { return nil }  // Fail: current leaf value creates invalid BST\\n                if let rootNode = rootNodeLookup[leaf.val] {\\n                    if let left = rootNode.left {\\n                        leaf.left = left\\n                        leaves.append((left, lowerBound, min(upperBound, leaf.val)))\\n                    }\\n                    if let right = rootNode.right {\\n                        leaf.right = right\\n                        leaves.append((right, max(lowerBound, leaf.val), upperBound))\\n                    }\\n                    count += 1\\n                }\\n            }\\n        }\\n        \\n        return count == trees.count ? rootNode : nil\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040147,
                "title": "simple-hash-map-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe first have to map every child\\'s value with it\\'s parent tree pointer so that again iterating we can join these .\\nWe also have to check if formed tree is BSt or not by taking it\\'s preOrder and see if it is in increasing order or not also we have to count nodes before and after tree making as if we will have cycles then we will not include those nodes in final tree according to algorithm .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nds; // this will store pre order of nodes formed\\n    void preOrd(TreeNode* r){ // function to do preorder\\n        if(r == NULL) return;\\n        preOrd(r->left);\\n        nds.push_back(r->val);\\n        preOrd(r->right);\\n    }\\n\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int nodes = 0; // this will store count of nodes \\n        map<int,TreeNode*> m; // for each value there will be 1 parent \\n        for(int i=0;i<trees.size();i++){\\n            auto r = trees[i];   nodes++;\\n            if(r->left){   nodes++;\\n                if(m.find(r->left->val) != m.end()) return NULL;\\n                m[r->left->val] = r;\\n            }\\n            if(r->right){   nodes++;\\n                if(m.find(r->right->val) != m.end()) return NULL;\\n                m[r->right->val] = r;\\n            }\\n        }\\n        TreeNode* ans = NULL; // initially ans is NULL\\n        for(int i=0;i<trees.size();i++){\\n            auto r = trees[i];\\n            if(m.find(r->val) == m.end()) continue; // if we do not find it\\'s parent then do not need to do anything\\n            // if we found it\\'s parent then we will replace values of it\\'s child\\n            if(m[r->val]->left && m[r->val]->left->val == r->val){ m[r->val]->left = r; trees[i] = NULL; }\\n            if(m[r->val]->right && m[r->val]->right->val == r->val){ m[r->val]->right = r; trees[i] = NULL; }\\n        }\\n        int cnt = 0; // this will count alone trees \\n        for(auto i: trees){\\n            if(i != NULL){\\n                ans = i;\\n                cnt++;\\n            }\\n        }\\n        if(cnt != 1) return NULL; // if not only 1 tree is made then we cannot form tree\\n        // Now we have to check for made tree is BST or not so do preorder and see if all nodes satisfy\\n        preOrd(ans); // do pre order\\n        // if after making successfull BST we will have nodes-(trees.size()-1) nodes count \\n        // so if we do not get this return NULL\\n        if(nodes-(trees.size()-1) != nds.size()) return NULL;\\n        // check for increasing order\\n        for(int i=0;i<nds.size()-1;i++){\\n            if(nds[i] >= nds[i+1]) return NULL;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nds; // this will store pre order of nodes formed\\n    void preOrd(TreeNode* r){ // function to do preorder\\n        if(r == NULL) return;\\n        preOrd(r->left);\\n        nds.push_back(r->val);\\n        preOrd(r->right);\\n    }\\n\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int nodes = 0; // this will store count of nodes \\n        map<int,TreeNode*> m; // for each value there will be 1 parent \\n        for(int i=0;i<trees.size();i++){\\n            auto r = trees[i];   nodes++;\\n            if(r->left){   nodes++;\\n                if(m.find(r->left->val) != m.end()) return NULL;\\n                m[r->left->val] = r;\\n            }\\n            if(r->right){   nodes++;\\n                if(m.find(r->right->val) != m.end()) return NULL;\\n                m[r->right->val] = r;\\n            }\\n        }\\n        TreeNode* ans = NULL; // initially ans is NULL\\n        for(int i=0;i<trees.size();i++){\\n            auto r = trees[i];\\n            if(m.find(r->val) == m.end()) continue; // if we do not find it\\'s parent then do not need to do anything\\n            // if we found it\\'s parent then we will replace values of it\\'s child\\n            if(m[r->val]->left && m[r->val]->left->val == r->val){ m[r->val]->left = r; trees[i] = NULL; }\\n            if(m[r->val]->right && m[r->val]->right->val == r->val){ m[r->val]->right = r; trees[i] = NULL; }\\n        }\\n        int cnt = 0; // this will count alone trees \\n        for(auto i: trees){\\n            if(i != NULL){\\n                ans = i;\\n                cnt++;\\n            }\\n        }\\n        if(cnt != 1) return NULL; // if not only 1 tree is made then we cannot form tree\\n        // Now we have to check for made tree is BST or not so do preorder and see if all nodes satisfy\\n        preOrd(ans); // do pre order\\n        // if after making successfull BST we will have nodes-(trees.size()-1) nodes count \\n        // so if we do not get this return NULL\\n        if(nodes-(trees.size()-1) != nds.size()) return NULL;\\n        // check for increasing order\\n        for(int i=0;i<nds.size()-1;i++){\\n            if(nds[i] >= nds[i+1]) return NULL;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901518,
                "title": "depth-first-search-to-merge-binary-tree-python",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Indentify your root tree from where merging will being .\\n2. Now from remaining trees , apply helper function to merge.\\n3. If final tree is valid BST then return tree else return None.\\n\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    is_merged = False\\n    def canMerge(self, trees):\\n        \"\"\"\\n        :type trees: List[TreeNode]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if len(trees) == 1:\\n            return trees[0]\\n\\n        #Find List of Leaf Nodes\\n        all_leaves_node = set()\\n        for tree in trees :\\n            if tree.left :\\n                all_leaves_node.add(tree.left.val)\\n            if tree.right :\\n                all_leaves_node.add(tree.right.val)    \\n\\n        # Find start point - root node for all other tress\\n        root = None \\n        for tree in trees:\\n            if tree.val not in all_leaves_node:\\n                root = tree\\n\\n        #If we do not find any root node.   \\n        if root is None :\\n             return None \\n\\n        \\n        # List of Remaining trees except root node tree\\n        list_of_remaining_tree = []\\n        for tree in trees :\\n            if tree.val != root.val :\\n                list_of_remaining_tree.append(tree)\\n        \\n\\n        # Dictionary of root node value and tree\\n        root_tree_dictionary = {}\\n        for tree in list_of_remaining_tree:\\n             root_tree_dictionary[tree.val] = tree\\n\\n        #Perform Merging of Tree\\n        self.helper(root,root_tree_dictionary)\\n\\n        # Finally check if it is a valid BST \\n        if self.check_valid_bst(root , float(\\'-inf\\') , float(\\'inf\\')) \\\\\\n            and len(root_tree_dictionary) == 0:\\n                return root\\n        else:\\n            return None # If not a valid BST then return empty tree\\n       \\n             \\n    def helper(self, root , root_tree_dictionary):     \\n        if root is None :\\n            return None \\n\\n        #if root node is found in dictionary then peform merge \\n        if root.val in root_tree_dictionary:\\n            tree = root_tree_dictionary[root.val]\\n            root.left = tree.left\\n            root.right = tree.right \\n            root_tree_dictionary.pop(root.val)\\n                \\n        left = self.helper(root.left, root_tree_dictionary)\\n        right = self.helper(root.right, root_tree_dictionary)\\n    \\n    # Function for checking if it is a valid BST \\n    def check_valid_bst(self,root, min_value , max_value) :\\n            return not root or min_value < root.val < max_value and \\\\\\n                    self.check_valid_bst(root.left, min_value, root.val) and \\\\\\n                    self.check_valid_bst(root.right, root.val, max_value)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    is_merged = False\\n    def canMerge(self, trees):\\n        \"\"\"\\n        :type trees: List[TreeNode]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if len(trees) == 1:\\n            return trees[0]\\n\\n        #Find List of Leaf Nodes\\n        all_leaves_node = set()\\n        for tree in trees :\\n            if tree.left :\\n                all_leaves_node.add(tree.left.val)\\n            if tree.right :\\n                all_leaves_node.add(tree.right.val)    \\n\\n        # Find start point - root node for all other tress\\n        root = None \\n        for tree in trees:\\n            if tree.val not in all_leaves_node:\\n                root = tree\\n\\n        #If we do not find any root node.   \\n        if root is None :\\n             return None \\n\\n        \\n        # List of Remaining trees except root node tree\\n        list_of_remaining_tree = []\\n        for tree in trees :\\n            if tree.val != root.val :\\n                list_of_remaining_tree.append(tree)\\n        \\n\\n        # Dictionary of root node value and tree\\n        root_tree_dictionary = {}\\n        for tree in list_of_remaining_tree:\\n             root_tree_dictionary[tree.val] = tree\\n\\n        #Perform Merging of Tree\\n        self.helper(root,root_tree_dictionary)\\n\\n        # Finally check if it is a valid BST \\n        if self.check_valid_bst(root , float(\\'-inf\\') , float(\\'inf\\')) \\\\\\n            and len(root_tree_dictionary) == 0:\\n                return root\\n        else:\\n            return None # If not a valid BST then return empty tree\\n       \\n             \\n    def helper(self, root , root_tree_dictionary):     \\n        if root is None :\\n            return None \\n\\n        #if root node is found in dictionary then peform merge \\n        if root.val in root_tree_dictionary:\\n            tree = root_tree_dictionary[root.val]\\n            root.left = tree.left\\n            root.right = tree.right \\n            root_tree_dictionary.pop(root.val)\\n                \\n        left = self.helper(root.left, root_tree_dictionary)\\n        right = self.helper(root.right, root_tree_dictionary)\\n    \\n    # Function for checking if it is a valid BST \\n    def check_valid_bst(self,root, min_value , max_value) :\\n            return not root or min_value < root.val < max_value and \\\\\\n                    self.check_valid_bst(root.left, min_value, root.val) and \\\\\\n                    self.check_valid_bst(root.right, root.val, max_value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2884454,
                "title": "c-hashmap-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, TreeNode*> root_mp, chld_mp;\\n        for(auto& n : trees) {\\n            if(n->left != nullptr) {\\n                if(chld_mp.find(n->left->val) != chld_mp.end()) return nullptr;\\n                chld_mp[n->left->val] = n->left;\\n            }\\n            if(n->right != nullptr) {\\n                if(chld_mp.find(n->right->val) != chld_mp.end()) return nullptr;\\n                chld_mp[n->right->val] = n->right;\\n            }\\n            root_mp[n->val] = n;\\n        }\\n\\n        TreeNode* res = nullptr;\\n        for(auto & [k, v] : root_mp) {\\n            if(chld_mp.find(k) == chld_mp.end()) {\\n                if(res != nullptr) return nullptr;\\n                res = v;\\n            }\\n        }\\n\\n        function<void(TreeNode*, TreeNode*, int, int)> dfs = [&](TreeNode* p, TreeNode* t, int l, int h) {\\n            if(t == nullptr) return;\\n            if(t->val <= l || t->val >= h) {\\n                res = nullptr;\\n                return;\\n            }\\n            int v = t->val;\\n            if(root_mp.find(v) == root_mp.end()) return;\\n            auto r = root_mp[v];\\n            root_mp.erase(r->val);\\n            if(p->left == t) p->left = r;\\n            else p->right = r;\\n            dfs(r, r->left, l, min(h, r->val));\\n            dfs(r, r->right, max(l, r->val), h);\\n        };\\n        if(res != nullptr) dfs(res, res->left, INT_MIN, res->val);\\n        if(res != nullptr) dfs(res, res->right, res->val, INT_MAX);\\n        return root_mp.size() == 1 ? res : nullptr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, TreeNode*> root_mp, chld_mp;\\n        for(auto& n : trees) {\\n            if(n->left != nullptr) {\\n                if(chld_mp.find(n->left->val) != chld_mp.end()) return nullptr;\\n                chld_mp[n->left->val] = n->left;\\n            }\\n            if(n->right != nullptr) {\\n                if(chld_mp.find(n->right->val) != chld_mp.end()) return nullptr;\\n                chld_mp[n->right->val] = n->right;\\n            }\\n            root_mp[n->val] = n;\\n        }\\n\\n        TreeNode* res = nullptr;\\n        for(auto & [k, v] : root_mp) {\\n            if(chld_mp.find(k) == chld_mp.end()) {\\n                if(res != nullptr) return nullptr;\\n                res = v;\\n            }\\n        }\\n\\n        function<void(TreeNode*, TreeNode*, int, int)> dfs = [&](TreeNode* p, TreeNode* t, int l, int h) {\\n            if(t == nullptr) return;\\n            if(t->val <= l || t->val >= h) {\\n                res = nullptr;\\n                return;\\n            }\\n            int v = t->val;\\n            if(root_mp.find(v) == root_mp.end()) return;\\n            auto r = root_mp[v];\\n            root_mp.erase(r->val);\\n            if(p->left == t) p->left = r;\\n            else p->right = r;\\n            dfs(r, r->left, l, min(h, r->val));\\n            dfs(r, r->right, max(l, r->val), h);\\n        };\\n        if(res != nullptr) dfs(res, res->left, INT_MIN, res->val);\\n        if(res != nullptr) dfs(res, res->right, res->val, INT_MAX);\\n        return root_mp.size() == 1 ? res : nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807443,
                "title": "python3",
                "content": "```\\nfrom typing import List, Optional\\n\\n\\nclass TreeNode:\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\n\\nclass Solution:\\n    def __init__(self):\\n        self.blacklist = set()\\n        self.value2node = {}\\n        self.operation_count = 0\\n\\n    def find_leaf(self, node, root):\\n        if not node:\\n            return\\n        \"\"\"\\n        Needs to make sure the only root node doesn\\'t get count as a leaf\\n        \"\"\"\\n        if not node.left and not node.right and node != root:\\n            self.blacklist.add(node.val)\\n        self.find_leaf(node.left, root)\\n        self.find_leaf(node.right, root)\\n\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        \"\"\"\\n        1. Find the root for the final BST:\\n            blacklist: all the leaf nodes\\n            whitelist: all the root nodes\\n\\n            This root node is unique. \\n\\n            Assume there are two nodes which are both roots, but neither of them exist in the leave nodes. \\n                Let\\'s say A is the final root and B is also can be the root(not exist in the leave nodes), the\\n                subtree with B as the root will not be able to merge into the final tree, but the problem require\\n                n - 1 operations for n trees, so all the subtree needs to be merged into the final big tree\\n\\n        2. build tree while checking if the bst is valid\\n            use recursive to return the validness of the bst\\n        3. Make sure all the tree have been used by count the times of merge operation and compare with the count of the trees\\n        \"\"\"\\n        root_count = 0\\n        return_root = None\\n\\n        for root in trees:\\n            self.find_leaf(root, root)\\n\\n        for root in trees:\\n            if root.val not in self.blacklist:\\n                return_root = root\\n                root_count += 1\\n            self.value2node[root.val] = root\\n\\n        # print(self.blacklist)\\n        # print(return_root)\\n        # print(self.value2node.keys())\\n\\n        if root_count != 1:\\n            return None\\n\\n        ok = self.build(return_root, float(\\'-inf\\'), float(\\'inf\\'), None, \\'\\')\\n        print(ok)\\n        print(self.operation_count)\\n        if ok and len(trees) - 1 == self.operation_count:\\n            return return_root\\n        else:\\n            return None\\n\\n    def build(self, node, min_v, max_v, parent, d) -> bool:\\n        if not node:\\n            return True\\n\\n        # print(min_v)\\n        # print(node.val)\\n        # print(max_v)\\n\\n        if node.val <= min_v or node.val >= max_v:\\n            return False\\n\\n        if node.left or node.right:\\n            return self.build(node.left, min_v, node.val, node, \\'left\\') and self.build(node.right, node.val, max_v,\\n                                                                                       node, \\'right\\')\\n        elif not node.left and not node.right and node.val in self.value2node:\\n            if d == \\'\\':\\n                \"\"\"\\n                When the root passed in with no direction, should just return True for this subtree\\n                \"\"\"\\n                return True\\n            self.operation_count += 1\\n            # print(node.val)\\n            if d == \\'left\\':\\n                parent.left = self.value2node[node.val]\\n                node = parent.left\\n                return self.build(node.left, min_v, node.val, node, \\'left\\') and self.build(node.right, node.val, max_v,\\n                                                                                           node, \\'right\\')\\n            elif d == \\'right\\':\\n                parent.right = self.value2node[node.val]\\n                node = parent.right\\n                return self.build(node.left, min_v, node.val, node, \\'left\\') and self.build(node.right, node.val, max_v,\\n                                                                                           node, \\'right\\')\\n        else:\\n            return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List, Optional\\n\\n\\nclass TreeNode:\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\n\\nclass Solution:\\n    def __init__(self):\\n        self.blacklist = set()\\n        self.value2node = {}\\n        self.operation_count = 0\\n\\n    def find_leaf(self, node, root):\\n        if not node:\\n            return\\n        \"\"\"\\n        Needs to make sure the only root node doesn\\'t get count as a leaf\\n        \"\"\"\\n        if not node.left and not node.right and node != root:\\n            self.blacklist.add(node.val)\\n        self.find_leaf(node.left, root)\\n        self.find_leaf(node.right, root)\\n\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        \"\"\"\\n        1. Find the root for the final BST:\\n            blacklist: all the leaf nodes\\n            whitelist: all the root nodes\\n\\n            This root node is unique. \\n\\n            Assume there are two nodes which are both roots, but neither of them exist in the leave nodes. \\n                Let\\'s say A is the final root and B is also can be the root(not exist in the leave nodes), the\\n                subtree with B as the root will not be able to merge into the final tree, but the problem require\\n                n - 1 operations for n trees, so all the subtree needs to be merged into the final big tree\\n\\n        2. build tree while checking if the bst is valid\\n            use recursive to return the validness of the bst\\n        3. Make sure all the tree have been used by count the times of merge operation and compare with the count of the trees\\n        \"\"\"\\n        root_count = 0\\n        return_root = None\\n\\n        for root in trees:\\n            self.find_leaf(root, root)\\n\\n        for root in trees:\\n            if root.val not in self.blacklist:\\n                return_root = root\\n                root_count += 1\\n            self.value2node[root.val] = root\\n\\n        # print(self.blacklist)\\n        # print(return_root)\\n        # print(self.value2node.keys())\\n\\n        if root_count != 1:\\n            return None\\n\\n        ok = self.build(return_root, float(\\'-inf\\'), float(\\'inf\\'), None, \\'\\')\\n        print(ok)\\n        print(self.operation_count)\\n        if ok and len(trees) - 1 == self.operation_count:\\n            return return_root\\n        else:\\n            return None\\n\\n    def build(self, node, min_v, max_v, parent, d) -> bool:\\n        if not node:\\n            return True\\n\\n        # print(min_v)\\n        # print(node.val)\\n        # print(max_v)\\n\\n        if node.val <= min_v or node.val >= max_v:\\n            return False\\n\\n        if node.left or node.right:\\n            return self.build(node.left, min_v, node.val, node, \\'left\\') and self.build(node.right, node.val, max_v,\\n                                                                                       node, \\'right\\')\\n        elif not node.left and not node.right and node.val in self.value2node:\\n            if d == \\'\\':\\n                \"\"\"\\n                When the root passed in with no direction, should just return True for this subtree\\n                \"\"\"\\n                return True\\n            self.operation_count += 1\\n            # print(node.val)\\n            if d == \\'left\\':\\n                parent.left = self.value2node[node.val]\\n                node = parent.left\\n                return self.build(node.left, min_v, node.val, node, \\'left\\') and self.build(node.right, node.val, max_v,\\n                                                                                           node, \\'right\\')\\n            elif d == \\'right\\':\\n                parent.right = self.value2node[node.val]\\n                node = parent.right\\n                return self.build(node.left, min_v, node.val, node, \\'left\\') and self.build(node.right, node.val, max_v,\\n                                                                                           node, \\'right\\')\\n        else:\\n            return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735280,
                "title": "c-hashmaps-with-explanation",
                "content": "This approach basically compares the leaves of every first tree with the root value of second tree stored in map and then append that second tree with the leaves of firsr tree.\\n```\\n//check for BST\\n    bool validate(TreeNode* root , pair<int,int>range){\\n        if(!root)\\n            return true;\\n        if( !(root->val > range.first && root->val < range.second) ){\\n            return false;\\n        }\\n\\n        bool left = validate(root->left , {range.first , root->val});\\n        bool right = validate(root->right, {root->val , range.second});\\n\\n        if(left && right){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        pair<int,int>range(INT_MIN , INT_MAX);\\n        return validate(root , range );\\n    }\\n    \\n    \\n    void solve(TreeNode* node , vector<TreeNode*>& trees ,unordered_map<int,int>&mp , int index){\\n        // if node is null\\n        if(!node)\\n            return;\\n        \\n        auto it = mp.find(node->val);\\n        // if we found same value of root as that of leaf\\n        //then append that root tree with leaf \\n        if(it != mp.end()){\\n            if(index == it->second || trees[it->second] == NULL)\\n                return;\\n            node->left = trees[it->second]->left;\\n            node->right = trees[it->second]->right;\\n            trees[it->second] = NULL;\\n            \\n            //then as we know that we added new children for this tree then check                   pair for these childrens too\\n            solve(node->left , trees , mp ,index);       \\n            solve(node->right , trees , mp , index);\\n        }\\n    }\\n    \\n\\t\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        // if there is only 1 tree then return that tree\\n        if(trees.size() == 1)\\n            return trees[0];\\n        \\n        unordered_map<int,int>mp;\\n        \\n        /*store root value along with their index accorind to trees vector in map\\n         see example first\\n           value index\\n            2       0\\n            3       1\\n            5       2\\n            */\\n        for(int i=0 ; i< trees.size() ; i++){\\n            mp[trees[i]->val] = i;\\n        }\\n        \\n        //at the end if all all trees are merged then only one not null value will be           there is trees vector that will be the answer\\n        //but if there are more than one not null the means those not null values               couldn\\'t be merged\\n        /* Here we will compare the leaves of roots one by one wiht the map values \\n            if found then means there is a pair whose leaves and root is same, so                 that means they can be merged.\\n            When merged then means got appended with leaf node, then vector element               of that tree becomes null, as that tree is merged with another.\\n        */\\n        \\n        for(int i=0 ; i < trees.size() ; i++){\\n            if(!trees[i]){\\n                continue;\\n            }\\n            // as there are no children so leave it and move to next\\n            if(trees[i]->left == NULL && trees[i]->right == NULL){\\n                continue;\\n            }\\n            \\n            //search for left leaf  -  root pair \\n            solve(trees[i]->left , trees , mp , i);\\n            \\n            //search for right leaf -  root pair \\n            solve(trees[i]->right , trees , mp , i);\\n        }\\n        \\n        //--------------------------------------------------------------------------\\n        //check if all elements in trees vector except one are NULL\\n        // if not then those not NULL elements could not be merged\\n        int count=0;TreeNode* result=NULL;\\n        for(int i =0 ; i < trees.size() ;i++){\\n            \\n            if(trees[i]){\\n                result = trees[i];\\n                count++;\\n            }    \\n            if(count == 2)\\n                return NULL;\\n        }\\n        \\n        //check for BST\\n        if(!isValidBST(result))\\n            return NULL;\\n        \\n        return result;\\n    }\\n```\\n![image](https://assets.leetcode.com/users/images/b9d98b12-ff5a-4f5f-aa16-f692b4a2ebc4_1666513935.780494.png)\\n",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\n//check for BST\\n    bool validate(TreeNode* root , pair<int,int>range){\\n        if(!root)\\n            return true;\\n        if( !(root->val > range.first && root->val < range.second) ){\\n            return false;\\n        }\\n\\n        bool left = validate(root->left , {range.first , root->val});\\n        bool right = validate(root->right, {root->val , range.second});\\n\\n        if(left && right){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        pair<int,int>range(INT_MIN , INT_MAX);\\n        return validate(root , range );\\n    }\\n    \\n    \\n    void solve(TreeNode* node , vector<TreeNode*>& trees ,unordered_map<int,int>&mp , int index){\\n        // if node is null\\n        if(!node)\\n            return;\\n        \\n        auto it = mp.find(node->val);\\n        // if we found same value of root as that of leaf\\n        //then append that root tree with leaf \\n        if(it != mp.end()){\\n            if(index == it->second || trees[it->second] == NULL)\\n                return;\\n            node->left = trees[it->second]->left;\\n            node->right = trees[it->second]->right;\\n            trees[it->second] = NULL;\\n            \\n            //then as we know that we added new children for this tree then check                   pair for these childrens too\\n            solve(node->left , trees , mp ,index);       \\n            solve(node->right , trees , mp , index);\\n        }\\n    }\\n    \\n\\t\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        // if there is only 1 tree then return that tree\\n        if(trees.size() == 1)\\n            return trees[0];\\n        \\n        unordered_map<int,int>mp;\\n        \\n        /*store root value along with their index accorind to trees vector in map\\n         see example first\\n           value index\\n            2       0\\n            3       1\\n            5       2\\n            */\\n        for(int i=0 ; i< trees.size() ; i++){\\n            mp[trees[i]->val] = i;\\n        }\\n        \\n        //at the end if all all trees are merged then only one not null value will be           there is trees vector that will be the answer\\n        //but if there are more than one not null the means those not null values               couldn\\'t be merged\\n        /* Here we will compare the leaves of roots one by one wiht the map values \\n            if found then means there is a pair whose leaves and root is same, so                 that means they can be merged.\\n            When merged then means got appended with leaf node, then vector element               of that tree becomes null, as that tree is merged with another.\\n        */\\n        \\n        for(int i=0 ; i < trees.size() ; i++){\\n            if(!trees[i]){\\n                continue;\\n            }\\n            // as there are no children so leave it and move to next\\n            if(trees[i]->left == NULL && trees[i]->right == NULL){\\n                continue;\\n            }\\n            \\n            //search for left leaf  -  root pair \\n            solve(trees[i]->left , trees , mp , i);\\n            \\n            //search for right leaf -  root pair \\n            solve(trees[i]->right , trees , mp , i);\\n        }\\n        \\n        //--------------------------------------------------------------------------\\n        //check if all elements in trees vector except one are NULL\\n        // if not then those not NULL elements could not be merged\\n        int count=0;TreeNode* result=NULL;\\n        for(int i =0 ; i < trees.size() ;i++){\\n            \\n            if(trees[i]){\\n                result = trees[i];\\n                count++;\\n            }    \\n            if(count == 2)\\n                return NULL;\\n        }\\n        \\n        //check for BST\\n        if(!isValidBST(result))\\n            return NULL;\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2716508,
                "title": "c-traverse-each-bst-leaf-node-with-help-of-a-hashtable-no-dfs-o-n-space-and-time",
                "content": "Some of the observations:\\n1. each BST root has unique value\\n2. let\\'s denote given BSTs with 1/2/3 nodes as BST-1/2/3. BST-1 cannot be used as leaf because no other root can attach to it. Only BST-2 and BST-3 leaf nodes can be used to attach another root.\\n3. in case two or more leaf nodes are equal, the result is invalid. Since merging with BSTs does not eliminate leaf from final tree, a tree with two or more equal nodes cannot be BST.\\n4. be careful with `cyclic merge`: a BST when merged to a parent tree, its leaf contains root value of the parent. For example [[10,5,12],[5,3,8],[3,null,10]]\\n\\nHere is the algorithm:\\nWe initialize a hashtable with given BSTs. Iterate on each leaf node, merge another BST and remove it from the hashtable when found. Equal leaf nodes at most can do 1 merge, as the non-first such leaf will not find the value from hashtable. `cyclic merge` components will disappear wholly from the hashtable. In the end, the hashtable might contain:\\n0 trees: `cyclic merge` exists and the whole BST disappeared, return NULL.\\n1 trees: `cyclic merge` might exist, or not. e.g., [[3,1],[1,3],[5,2,6]]. apply validBST() to count number of nodes in the result tree, when valid it should be total - (tree count - 1). \\n2 or more trees: cannot be merged as a single tree, return NULL;\\n```\\n\\t// return number of valid nodes in the tree\\n    int validBST(TreeNode* node, int lo, int hi) {\\n        if (node == NULL) {\\n            return 0;\\n        }\\n        \\n        if (!(lo < node->val && node->val < hi)) {\\n            return 0;\\n        }\\n        \\n        return 1 + validBST(node->left, lo, node->val) + validBST(node->right, node->val, hi);\\n    }\\n\\t\\n\\tTreeNode* canMerge(vector<TreeNode*>& trees) {\\n        // root value -> tree\\n        unordered_map<int, TreeNode*> table;\\n        for (auto tree : trees) {\\n            table[tree->val] = tree;\\n        }\\n        \\n        // approach 2\\n        int total = 0; // count of nodes in all unmerged bsts\\n        int bsts = trees.size(); // coount of trees\\n        for (int i = 0; i < trees.size(); i++) {\\n            TreeNode* t = trees[i];\\n            int val;\\n            if (t->left) {\\n                val = t->left->val;\\n                if (table.find(val) != table.end()) {\\n                    t->left = table[val];\\n                    table.erase(val);\\n                }\\n                \\n                total++;\\n            }\\n            \\n            if (t->right) {\\n                val = t->right->val;\\n                if (table.find(val) != table.end()) {\\n                    t->right = table[val];\\n                    table.erase(val);\\n                }\\n                \\n                total++;\\n            }\\n            \\n            total++;\\n        }\\n        \\n        \\n        // size can be 0, 1, or more\\n        if (table.size() != 1) {\\n            return NULL;\\n        }\\n        \\n        \\n        TreeNode* tree = table.begin()->second;\\n        int cnt = validBST(tree, 0, 50001);\\n        return cnt == total - (bsts - 1) ? tree : NULL;\\n    }\\n```",
                "solutionTags": [
                    "Hash Table",
                    "Binary Search Tree"
                ],
                "code": "```\\n\\t// return number of valid nodes in the tree\\n    int validBST(TreeNode* node, int lo, int hi) {\\n        if (node == NULL) {\\n            return 0;\\n        }\\n        \\n        if (!(lo < node->val && node->val < hi)) {\\n            return 0;\\n        }\\n        \\n        return 1 + validBST(node->left, lo, node->val) + validBST(node->right, node->val, hi);\\n    }\\n\\t\\n\\tTreeNode* canMerge(vector<TreeNode*>& trees) {\\n        // root value -> tree\\n        unordered_map<int, TreeNode*> table;\\n        for (auto tree : trees) {\\n            table[tree->val] = tree;\\n        }\\n        \\n        // approach 2\\n        int total = 0; // count of nodes in all unmerged bsts\\n        int bsts = trees.size(); // coount of trees\\n        for (int i = 0; i < trees.size(); i++) {\\n            TreeNode* t = trees[i];\\n            int val;\\n            if (t->left) {\\n                val = t->left->val;\\n                if (table.find(val) != table.end()) {\\n                    t->left = table[val];\\n                    table.erase(val);\\n                }\\n                \\n                total++;\\n            }\\n            \\n            if (t->right) {\\n                val = t->right->val;\\n                if (table.find(val) != table.end()) {\\n                    t->right = table[val];\\n                    table.erase(val);\\n                }\\n                \\n                total++;\\n            }\\n            \\n            total++;\\n        }\\n        \\n        \\n        // size can be 0, 1, or more\\n        if (table.size() != 1) {\\n            return NULL;\\n        }\\n        \\n        \\n        TreeNode* tree = table.begin()->second;\\n        int cnt = validBST(tree, 0, 50001);\\n        return cnt == total - (bsts - 1) ? tree : NULL;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2580139,
                "title": "c-dfs-solution-beats-90",
                "content": "```\\nclass Solution {\\n\\t//Map to store the index of the root, given its value\\n    unordered_map<int, int> mp; \\npublic:\\n\\t//Perform DFS and simultaneously build tree\\n    void dfs(vector<TreeNode*>& trees, vector<bool>& vis, TreeNode* node){\\n        if(node->left!=NULL && mp[node->left->val]>0){\\n            node->left = trees[mp[node->left->val]-1];\\n            vis[mp[node->left->val]-1] = true;\\n            mp[node->left->val] = 0;\\n            dfs(trees, vis, node->left);\\n        }\\n        if(node->right!=NULL && mp[node->right->val]>0){\\n            node->right = trees[mp[node->right->val]-1];\\n            vis[mp[node->right->val]-1] = true;\\n            mp[node->right->val] = 0;\\n            dfs(trees, vis, node->right);\\n        }\\n    }\\n    \\n\\t//Function to validate the BST formed. It checks for the conditions for a valid BST as given in question by doing DFS\\n    bool validate(TreeNode* root, int up = INT_MIN, int low = INT_MAX){\\n        if(root==NULL)\\n            return true;\\n        if(root->val >= low || root->val <= up)\\n            return false;\\n        return validate(root->left, up, root->val)&&validate(root->right, root->val, low);\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, int> ump;\\n        for(int i=0; i<trees.size(); i++){\\n            if(trees[i]->left != NULL)\\n                ump[trees[i]->left->val] = 1;\\n            if(trees[i]->right != NULL)\\n                ump[trees[i]->right->val] = 1;\\n        }\\n        for(int i=0; i<trees.size(); i++)\\n            mp[trees[i]->val] = i+1;\\n        \\n        vector<bool> vis(trees.size(), false);\\n        TreeNode* root = NULL;\\n        for(int i=0; i<trees.size(); i++){\\n            if(!ump[trees[i]->val]){\\n                vis[i] = true;\\n                root = trees[i];\\n                break;\\n            }\\n        }\\n        if(root==NULL)\\n            return NULL;\\n        mp[root->val] = 0;\\n        dfs(trees, vis, root);\\n        \\n        for(int i=0; i<vis.size(); i++)\\n            if(!vis[i])\\n                return NULL;\\n        \\n        if(validate(root))\\n            return root;\\n        \\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\t//Map to store the index of the root, given its value\\n    unordered_map<int, int> mp; \\npublic:\\n\\t//Perform DFS and simultaneously build tree\\n    void dfs(vector<TreeNode*>& trees, vector<bool>& vis, TreeNode* node){\\n        if(node->left!=NULL && mp[node->left->val]>0){\\n            node->left = trees[mp[node->left->val]-1];\\n            vis[mp[node->left->val]-1] = true;\\n            mp[node->left->val] = 0;\\n            dfs(trees, vis, node->left);\\n        }\\n        if(node->right!=NULL && mp[node->right->val]>0){\\n            node->right = trees[mp[node->right->val]-1];\\n            vis[mp[node->right->val]-1] = true;\\n            mp[node->right->val] = 0;\\n            dfs(trees, vis, node->right);\\n        }\\n    }\\n    \\n\\t//Function to validate the BST formed. It checks for the conditions for a valid BST as given in question by doing DFS\\n    bool validate(TreeNode* root, int up = INT_MIN, int low = INT_MAX){\\n        if(root==NULL)\\n            return true;\\n        if(root->val >= low || root->val <= up)\\n            return false;\\n        return validate(root->left, up, root->val)&&validate(root->right, root->val, low);\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, int> ump;\\n        for(int i=0; i<trees.size(); i++){\\n            if(trees[i]->left != NULL)\\n                ump[trees[i]->left->val] = 1;\\n            if(trees[i]->right != NULL)\\n                ump[trees[i]->right->val] = 1;\\n        }\\n        for(int i=0; i<trees.size(); i++)\\n            mp[trees[i]->val] = i+1;\\n        \\n        vector<bool> vis(trees.size(), false);\\n        TreeNode* root = NULL;\\n        for(int i=0; i<trees.size(); i++){\\n            if(!ump[trees[i]->val]){\\n                vis[i] = true;\\n                root = trees[i];\\n                break;\\n            }\\n        }\\n        if(root==NULL)\\n            return NULL;\\n        mp[root->val] = 0;\\n        dfs(trees, vis, root);\\n        \\n        for(int i=0; i<vis.size(); i++)\\n            if(!vis[i])\\n                return NULL;\\n        \\n        if(validate(root))\\n            return root;\\n        \\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573783,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        hashMap = defaultdict(int)\\n        \\n        def isValid(root: Optional[TreeNode], minimum: int, maximum: int) -> bool:\\n            if not root:\\n                return True\\n            if root.val <= minimum or root.val >= maximum:\\n                return False\\n            else:\\n                return isValid(root.left, minimum, root.val) and isValid(root.right, root.val, maximum)\\n            \\n        def helper(root: Optional[TreeNode], trees: List[TreeNode], minimum: int, maximum: int) -> Optional[TreeNode]:\\n            nonlocal hashMap\\n            if not root:\\n                return None\\n            if root.val in hashMap:\\n                x = hashMap[root.val]\\n                if isValid(trees[x - 1], minimum, maximum):\\n                    root = trees[x - 1]\\n                    del hashMap[root.val]\\n                else:\\n                    return root\\n            root.left = helper(root.left, trees, minimum, root.val);\\n            root.right = helper(root.right, trees, root.val, maximum)\\n            return root\\n        \\n        numTrees, hashMapAlt = len(trees), defaultdict(int)\\n        for i in range(numTrees):\\n            hashMap[trees[i].val] = i + 1\\n        for i in range(numTrees):\\n            hashMapAlt[trees[i].val] += 1\\n            if trees[i].left:\\n                hashMapAlt[trees[i].left.val] += 1\\n            if trees[i].right:\\n                hashMapAlt[trees[i].right.val] += 1\\n        root = None\\n        for treeNode in trees:\\n            if hashMapAlt[treeNode.val] == 1:\\n                if root is not None:\\n                    return None\\n                root = treeNode\\n        if not root:\\n            return None\\n        minimum, maximum = -float(\\'inf\\'), float(\\'inf\\')\\n        node = helper(root, trees, minimum, maximum)\\n        if len(hashMap) == 0:\\n            return node\\n        return None\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        hashMap = defaultdict(int)\\n        \\n        def isValid(root: Optional[TreeNode], minimum: int, maximum: int) -> bool:\\n            if not root:\\n                return True\\n            if root.val <= minimum or root.val >= maximum:\\n                return False\\n            else:\\n                return isValid(root.left, minimum, root.val) and isValid(root.right, root.val, maximum)\\n            \\n        def helper(root: Optional[TreeNode], trees: List[TreeNode], minimum: int, maximum: int) -> Optional[TreeNode]:\\n            nonlocal hashMap\\n            if not root:\\n                return None\\n            if root.val in hashMap:\\n                x = hashMap[root.val]\\n                if isValid(trees[x - 1], minimum, maximum):\\n                    root = trees[x - 1]\\n                    del hashMap[root.val]\\n                else:\\n                    return root\\n            root.left = helper(root.left, trees, minimum, root.val);\\n            root.right = helper(root.right, trees, root.val, maximum)\\n            return root\\n        \\n        numTrees, hashMapAlt = len(trees), defaultdict(int)\\n        for i in range(numTrees):\\n            hashMap[trees[i].val] = i + 1\\n        for i in range(numTrees):\\n            hashMapAlt[trees[i].val] += 1\\n            if trees[i].left:\\n                hashMapAlt[trees[i].left.val] += 1\\n            if trees[i].right:\\n                hashMapAlt[trees[i].right.val] += 1\\n        root = None\\n        for treeNode in trees:\\n            if hashMapAlt[treeNode.val] == 1:\\n                if root is not None:\\n                    return None\\n                root = treeNode\\n        if not root:\\n            return None\\n        minimum, maximum = -float(\\'inf\\'), float(\\'inf\\')\\n        node = helper(root, trees, minimum, maximum)\\n        if len(hashMap) == 0:\\n            return node\\n        return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467078,
                "title": "java-build-it-with-detailed-comments",
                "content": "```Java\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> root = new HashMap<>(); // root candidates\\n        Map<Integer, TreeNode> map = new HashMap<>(); // all nodes\\n        for (TreeNode t : trees){\\n            root.put(t.val, t);\\n            map.put(t.val, t);\\n        }\\n        for (TreeNode t : trees){ // root candidates can\\'t be a leave of some other nodes\\n            int L = t.left == null? 0 : t.left.val;\\n            int R = t.right== null? 0 : t.right.val;\\n            root.remove(L);\\n            root.remove(R);\\n        }\\n        if (root.size() != 1 || map.size() != trees.size()){ // we must have 1 node and no duplicate root values.\\n            return null;\\n        }\\n        int INF = (int)1e9;\\n        TreeNode r = root.values().iterator().next(); // this is our root\\n        return build(-INF, INF, r, map) && map.size() == 1? r : null; // try to build it, in the end, map should only have the root left.\\n    }\\n    \\n    private boolean build(int min, int max, TreeNode cur, Map<Integer, TreeNode> map){\\n        boolean ok = cur.val > min && cur.val < max; // must hold for BST\\n        if (cur.left != null){ // replace left node\\n            cur.left = map.getOrDefault(cur.left.val, cur.left);\\n            map.remove(cur.left.val);\\n            ok &= build(min, cur.val, cur.left, map);\\n        }\\n        if (cur.right != null){ // replace right node\\n            cur.right = map.getOrDefault(cur.right.val, cur.right);\\n            map.remove(cur.right.val);\\n            ok &= build(cur.val, max, cur.right, map);\\n        }\\n        return ok;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> root = new HashMap<>(); // root candidates\\n        Map<Integer, TreeNode> map = new HashMap<>(); // all nodes\\n        for (TreeNode t : trees){\\n            root.put(t.val, t);\\n            map.put(t.val, t);\\n        }\\n        for (TreeNode t : trees){ // root candidates can\\'t be a leave of some other nodes\\n            int L = t.left == null? 0 : t.left.val;\\n            int R = t.right== null? 0 : t.right.val;\\n            root.remove(L);\\n            root.remove(R);\\n        }\\n        if (root.size() != 1 || map.size() != trees.size()){ // we must have 1 node and no duplicate root values.\\n            return null;\\n        }\\n        int INF = (int)1e9;\\n        TreeNode r = root.values().iterator().next(); // this is our root\\n        return build(-INF, INF, r, map) && map.size() == 1? r : null; // try to build it, in the end, map should only have the root left.\\n    }\\n    \\n    private boolean build(int min, int max, TreeNode cur, Map<Integer, TreeNode> map){\\n        boolean ok = cur.val > min && cur.val < max; // must hold for BST\\n        if (cur.left != null){ // replace left node\\n            cur.left = map.getOrDefault(cur.left.val, cur.left);\\n            map.remove(cur.left.val);\\n            ok &= build(min, cur.val, cur.left, map);\\n        }\\n        if (cur.right != null){ // replace right node\\n            cur.right = map.getOrDefault(cur.right.val, cur.right);\\n            map.remove(cur.right.val);\\n            ok &= build(cur.val, max, cur.right, map);\\n        }\\n        return ok;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459260,
                "title": "c-hashmap-easy",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    \\n//     For keeping the track of BSTs\\n    unordered_map<int,int> mp;\\n   \\n//     Validate a BST\\n    bool isValid(TreeNode*root, int mini, int maxi){\\n        if(!root){\\n            return true;\\n        }\\n        if(root->val <= mini || root->val >= maxi){\\n            return false;\\n        }\\n        else{\\n            return isValid(root->left,mini,root->val) && isValid(root->right,root->val,maxi);\\n        }\\n    }\\n    \\n//     Helper function to Make the BST\\n     TreeNode* helper(TreeNode* root, vector<TreeNode*>& trees, int mini, int maxi){\\n        if(!root){\\n            return NULL;\\n        }\\n         \\n        if(mp.find(root->val)!=mp.end()){\\n            int x = mp[root->val];\\n            \\n            \\n            if(isValid(trees[x-1],mini,maxi)){\\n                root = trees[x-1];\\n                mp.erase(root->val);\\n            }\\n            else{\\n                return root;\\n            }\\n        }\\n        root->left = helper(root->left,trees,mini,root->val);\\n        root->right = helper(root->right,trees,root->val,maxi);\\n        \\n         return root;\\n    }\\n    \\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n = trees.size();\\n        for(int i = 0;i<n;i++){\\n            mp[trees[i]->val] = i+1;\\n        }\\n        unordered_map<int,int> mp1;\\n        \\n        for(int i = 0;i<n;i++){\\n            mp1[trees[i]->val]++;\\n            if(trees[i]->left){\\n                mp1[trees[i]->left->val]++;\\n            }\\n            if(trees[i]->right){\\n                mp1[trees[i]->right->val]++;\\n            }\\n        }\\n        \\n        TreeNode *root=NULL;\\n        for(auto &itr : trees){\\n            \\n            if(mp1[itr->val]==1){\\n                if(root!=NULL) return NULL;\\n                root=itr;\\n            }\\n            \\n        }\\n        \\n        if(!root){\\n            return NULL;\\n        }\\n        \\n        int mini = INT_MIN;\\n        int maxi = INT_MAX;\\n        auto y = helper(root,trees,mini,maxi);\\n        if(mp.size() == 0){\\n            return y;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n//     For keeping the track of BSTs\\n    unordered_map<int,int> mp;\\n   \\n//     Validate a BST\\n    bool isValid(TreeNode*root, int mini, int maxi){\\n        if(!root){\\n            return true;\\n        }\\n        if(root->val <= mini || root->val >= maxi){\\n            return false;\\n        }\\n        else{\\n            return isValid(root->left,mini,root->val) && isValid(root->right,root->val,maxi);\\n        }\\n    }\\n    \\n//     Helper function to Make the BST\\n     TreeNode* helper(TreeNode* root, vector<TreeNode*>& trees, int mini, int maxi){\\n        if(!root){\\n            return NULL;\\n        }\\n         \\n        if(mp.find(root->val)!=mp.end()){\\n            int x = mp[root->val];\\n            \\n            \\n            if(isValid(trees[x-1],mini,maxi)){\\n                root = trees[x-1];\\n                mp.erase(root->val);\\n            }\\n            else{\\n                return root;\\n            }\\n        }\\n        root->left = helper(root->left,trees,mini,root->val);\\n        root->right = helper(root->right,trees,root->val,maxi);\\n        \\n         return root;\\n    }\\n    \\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n = trees.size();\\n        for(int i = 0;i<n;i++){\\n            mp[trees[i]->val] = i+1;\\n        }\\n        unordered_map<int,int> mp1;\\n        \\n        for(int i = 0;i<n;i++){\\n            mp1[trees[i]->val]++;\\n            if(trees[i]->left){\\n                mp1[trees[i]->left->val]++;\\n            }\\n            if(trees[i]->right){\\n                mp1[trees[i]->right->val]++;\\n            }\\n        }\\n        \\n        TreeNode *root=NULL;\\n        for(auto &itr : trees){\\n            \\n            if(mp1[itr->val]==1){\\n                if(root!=NULL) return NULL;\\n                root=itr;\\n            }\\n            \\n        }\\n        \\n        if(!root){\\n            return NULL;\\n        }\\n        \\n        int mini = INT_MIN;\\n        int maxi = INT_MAX;\\n        auto y = helper(root,trees,mini,maxi);\\n        if(mp.size() == 0){\\n            return y;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446115,
                "title": "scala-i-believe-it-works-but-memory-limit-needs-to-be-adjusted",
                "content": "```\\n  object Solution {\\n\\n    def min(tree: TreeNode): Int = {\\n      if (tree.left == null) tree.value\\n      else min(tree.left)\\n    }\\n\\n    def max(tree: TreeNode): Int = {\\n      if (tree.right == null) tree.value\\n      else max(tree.right)\\n    }\\n\\n    def isBst(tree: TreeNode): Boolean = {\\n      if (tree == null) true\\n      else {\\n        val maxOnLeftLessThanRoot = if (tree.left == null) true else max(tree.left) < tree.value\\n        val minOnRightGreaterThanRoot = if (tree.right == null) true else min(tree.right) > tree.value\\n        isBst(tree.left) && isBst(tree.right) && maxOnLeftLessThanRoot && minOnRightGreaterThanRoot\\n      }\\n    }\\n\\n    def clone(tree: TreeNode): TreeNode = {\\n      if (tree == null) null\\n      else new TreeNode(tree.value, clone(tree.left), clone(tree.right))\\n    }\\n\\n    def merge(a: TreeNode, b: TreeNode): Option[TreeNode] = {\\n      if (a == null || b == null) None\\n      else if (a.value < b.value) {\\n        merge(a, b.left).map(new TreeNode(b.value, _, b.right))\\n      } else if (a.value > b.value) {\\n        merge(a, b.right).map(new TreeNode(b.value, b.left, _))\\n      } else Some(clone(a))\\n    }\\n    \\n    case class MergeFirst(result: TreeNode, found: Boolean, foundAt: Option[Int])\\n\\n    def mergeAny(tree: TreeNode, nodes: List[TreeNode]): Option[TreeNode] = {\\n      if (nodes.isEmpty) Some(tree)\\n      else {\\n        val MergeFirst(result, found, foundAt) = nodes.zipWithIndex.foldLeft(MergeFirst(tree, false, None)) {\\n          case (MergeFirst(a, false, _), (b, i)) =>\\n            val amb = merge(a, b)\\n            val bma = merge(b, a)\\n            if (amb.nonEmpty && isBst(amb.get)) MergeFirst(amb.get, true, Some(i))\\n            else if (bma.nonEmpty && isBst(bma.get)) MergeFirst(bma.get, true, Some(i))\\n            else MergeFirst(a, false, None)\\n          case (MergeFirst(r, true, fa), _) => MergeFirst(r, true, fa)\\n        }\\n\\n        if (!found) None\\n        else mergeAny(result, nodes.slice(0, foundAt.get) ::: nodes.slice(foundAt.get + 1, nodes.length))\\n      }\\n\\n    }\\n\\n    def canMerge(trees: List[TreeNode]): TreeNode = {\\n      val empty: TreeNode = null\\n      mergeAny(trees.head, trees.tail).getOrElse(empty)\\n    }\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  object Solution {\\n\\n    def min(tree: TreeNode): Int = {\\n      if (tree.left == null) tree.value\\n      else min(tree.left)\\n    }\\n\\n    def max(tree: TreeNode): Int = {\\n      if (tree.right == null) tree.value\\n      else max(tree.right)\\n    }\\n\\n    def isBst(tree: TreeNode): Boolean = {\\n      if (tree == null) true\\n      else {\\n        val maxOnLeftLessThanRoot = if (tree.left == null) true else max(tree.left) < tree.value\\n        val minOnRightGreaterThanRoot = if (tree.right == null) true else min(tree.right) > tree.value\\n        isBst(tree.left) && isBst(tree.right) && maxOnLeftLessThanRoot && minOnRightGreaterThanRoot\\n      }\\n    }\\n\\n    def clone(tree: TreeNode): TreeNode = {\\n      if (tree == null) null\\n      else new TreeNode(tree.value, clone(tree.left), clone(tree.right))\\n    }\\n\\n    def merge(a: TreeNode, b: TreeNode): Option[TreeNode] = {\\n      if (a == null || b == null) None\\n      else if (a.value < b.value) {\\n        merge(a, b.left).map(new TreeNode(b.value, _, b.right))\\n      } else if (a.value > b.value) {\\n        merge(a, b.right).map(new TreeNode(b.value, b.left, _))\\n      } else Some(clone(a))\\n    }\\n    \\n    case class MergeFirst(result: TreeNode, found: Boolean, foundAt: Option[Int])\\n\\n    def mergeAny(tree: TreeNode, nodes: List[TreeNode]): Option[TreeNode] = {\\n      if (nodes.isEmpty) Some(tree)\\n      else {\\n        val MergeFirst(result, found, foundAt) = nodes.zipWithIndex.foldLeft(MergeFirst(tree, false, None)) {\\n          case (MergeFirst(a, false, _), (b, i)) =>\\n            val amb = merge(a, b)\\n            val bma = merge(b, a)\\n            if (amb.nonEmpty && isBst(amb.get)) MergeFirst(amb.get, true, Some(i))\\n            else if (bma.nonEmpty && isBst(bma.get)) MergeFirst(bma.get, true, Some(i))\\n            else MergeFirst(a, false, None)\\n          case (MergeFirst(r, true, fa), _) => MergeFirst(r, true, fa)\\n        }\\n\\n        if (!found) None\\n        else mergeAny(result, nodes.slice(0, foundAt.get) ::: nodes.slice(foundAt.get + 1, nodes.length))\\n      }\\n\\n    }\\n\\n    def canMerge(trees: List[TreeNode]): TreeNode = {\\n      val empty: TreeNode = null\\n      mergeAny(trees.head, trees.tail).getOrElse(empty)\\n    }\\n  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421173,
                "title": "97-tc-passed-intuitive-approach",
                "content": "**Only 3% cases are not passed.\\n If anyone can improve this code then you are most welcome.**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    static bool comp(TreeNode* root1, TreeNode* root2){\\n        return root1->val < root2->val;\\n    }\\n    pair<int, int> get(TreeNode* root){\\n        int mini = INT_MAX;\\n        int maxi = INT_MIN;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            auto it = st.top();\\n            st.pop();\\n            mini = min(mini, it->val);\\n            maxi = max(maxi, it->val);\\n            \\n            if(it->left) st.push(it->left);\\n            if(it->right) st.push(it->right);\\n        } \\n        \\n        return {mini, maxi};\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        sort(trees.begin(), trees.end(), comp);\\n        unordered_map<int, pair<TreeNode*, pair<int, int>>> mp;\\n        unordered_set<TreeNode*> vis;\\n        for(auto it: trees){\\n            mp[it->val] = make_pair(it, get(it));\\n        }\\n        \\n        for(int i = 0; i < trees.size(); i++){\\n            if(1){\\n                TreeNode* leaf1 = NULL;\\n                TreeNode* leaf2 = NULL;\\n                pair<int, int> range_leaf1, range_leaf2;\\n                TreeNode* root = trees[i];\\n                if(root->left && root->right){\\n                    leaf1 = root->left;\\n                    range_leaf1.first = INT_MIN;\\n                    range_leaf1.second = root->val - 1; //inclusive\\n                    \\n                    leaf2 = root->right;\\n                    range_leaf2.first = root->val + 1;\\n                    range_leaf2.second = INT_MAX;\\n                }\\n                else if(root->left){\\n                    leaf1 = root->left;\\n                    range_leaf1.first = INT_MIN;\\n                    range_leaf1.second = root->val - 1; //inclusive\\n                }\\n                else if(root->right){\\n                    leaf2 = root->right;\\n                    range_leaf2.first = root->val + 1;\\n                    range_leaf2.second = INT_MAX;\\n                }\\n                \\n                \\n                if(leaf1){\\n                    if(mp.find(leaf1->val) != mp.end()){\\n                        if((range_leaf1.first <= mp[leaf1->val].second.first) &&( mp[leaf1->val].second.second <= range_leaf1.second)){\\n                            trees[i]->left = mp[leaf1->val].first;\\n                            mp[trees[i]->val].second.first = min(mp[trees[i]->val].second.first, mp[leaf1->val].second.first);\\n                            mp[trees[i]->val].second.second = max(mp[trees[i]->val].second.second, mp[leaf1->val].second.second);\\n                            mp.erase(leaf1->val);\\n                        }\\n                    }\\n                }\\n                if(leaf2){\\n                    if(mp.find(leaf2->val) != mp.end()){\\n                        if((range_leaf2.first <= mp[leaf2->val].second.first) &&( mp[leaf2->val].second.second <= range_leaf2.second)){\\n                            trees[i]->right = mp[leaf2->val].first;\\n                            mp[trees[i]->val].second.first = min(mp[trees[i]->val].second.first, mp[leaf2->val].second.first);\\n                            mp[trees[i]->val].second.second = max(mp[trees[i]->val].second.second, mp[leaf2->val].second.second);\\n                            mp.erase(leaf2->val);\\n                        }\\n                    }\\n                }\\n                \\n                \\n            }\\n        }\\n        if(mp.size() > 1) return NULL;\\n        return mp.begin()->second.first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    static bool comp(TreeNode* root1, TreeNode* root2){\\n        return root1->val < root2->val;\\n    }\\n    pair<int, int> get(TreeNode* root){\\n        int mini = INT_MAX;\\n        int maxi = INT_MIN;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            auto it = st.top();\\n            st.pop();\\n            mini = min(mini, it->val);\\n            maxi = max(maxi, it->val);\\n            \\n            if(it->left) st.push(it->left);\\n            if(it->right) st.push(it->right);\\n        } \\n        \\n        return {mini, maxi};\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        sort(trees.begin(), trees.end(), comp);\\n        unordered_map<int, pair<TreeNode*, pair<int, int>>> mp;\\n        unordered_set<TreeNode*> vis;\\n        for(auto it: trees){\\n            mp[it->val] = make_pair(it, get(it));\\n        }\\n        \\n        for(int i = 0; i < trees.size(); i++){\\n            if(1){\\n                TreeNode* leaf1 = NULL;\\n                TreeNode* leaf2 = NULL;\\n                pair<int, int> range_leaf1, range_leaf2;\\n                TreeNode* root = trees[i];\\n                if(root->left && root->right){\\n                    leaf1 = root->left;\\n                    range_leaf1.first = INT_MIN;\\n                    range_leaf1.second = root->val - 1; //inclusive\\n                    \\n                    leaf2 = root->right;\\n                    range_leaf2.first = root->val + 1;\\n                    range_leaf2.second = INT_MAX;\\n                }\\n                else if(root->left){\\n                    leaf1 = root->left;\\n                    range_leaf1.first = INT_MIN;\\n                    range_leaf1.second = root->val - 1; //inclusive\\n                }\\n                else if(root->right){\\n                    leaf2 = root->right;\\n                    range_leaf2.first = root->val + 1;\\n                    range_leaf2.second = INT_MAX;\\n                }\\n                \\n                \\n                if(leaf1){\\n                    if(mp.find(leaf1->val) != mp.end()){\\n                        if((range_leaf1.first <= mp[leaf1->val].second.first) &&( mp[leaf1->val].second.second <= range_leaf1.second)){\\n                            trees[i]->left = mp[leaf1->val].first;\\n                            mp[trees[i]->val].second.first = min(mp[trees[i]->val].second.first, mp[leaf1->val].second.first);\\n                            mp[trees[i]->val].second.second = max(mp[trees[i]->val].second.second, mp[leaf1->val].second.second);\\n                            mp.erase(leaf1->val);\\n                        }\\n                    }\\n                }\\n                if(leaf2){\\n                    if(mp.find(leaf2->val) != mp.end()){\\n                        if((range_leaf2.first <= mp[leaf2->val].second.first) &&( mp[leaf2->val].second.second <= range_leaf2.second)){\\n                            trees[i]->right = mp[leaf2->val].first;\\n                            mp[trees[i]->val].second.first = min(mp[trees[i]->val].second.first, mp[leaf2->val].second.first);\\n                            mp[trees[i]->val].second.second = max(mp[trees[i]->val].second.second, mp[leaf2->val].second.second);\\n                            mp.erase(leaf2->val);\\n                        }\\n                    }\\n                }\\n                \\n                \\n            }\\n        }\\n        if(mp.size() > 1) return NULL;\\n        return mp.begin()->second.first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327830,
                "title": "c-with-explanation",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void build(TreeNode* r,  unordered_map<TreeNode*, vector<TreeNode*>>& conn, int& num) {\\n        for(auto* n: conn[r]) {\\n            build(n, conn, num);\\n            if(r->left && r->left->val == n->val) {\\n                r->left = n;\\n                ++num;\\n            }\\n            if(r->right && r->right->val == n->val) {\\n                r->right = n;\\n                ++num;\\n            }           \\n        }\\n    }\\n    \\n    void preorder(TreeNode* r, vector<int>& v) {\\n        if(!r) return;\\n        preorder(r->left, v);\\n        v.push_back(r->val);\\n        preorder(r->right, v);\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n\\t\\t// Build a map that stores the val of each root as the key.\\n        unordered_map<int, TreeNode*> mp;\\n        for(auto* n: trees) mp[n->val] = n;\\n        \\n\\t\\t// For each root in trees, find out the other roots that it can connect to.\\n        unordered_map<TreeNode*, vector<TreeNode*>> conn;\\n        for(auto* n: trees) {\\n            if(n->left && mp.count(n->left->val)) {\\n                conn[n].push_back(mp[n->left->val]);\\n                mp.erase(n->left->val);\\n            }\\n            if(n->right && mp.count(n->right->val)) {\\n                conn[n].push_back(mp[n->right->val]);\\n                mp.erase(n->right->val);\\n            }            \\n        }\\n        \\n\\t\\t// After finding the connections, there should be only one root that is left (the root of the result BST).\\n        if(mp.empty() || mp.size() > 1) return nullptr;\\n\\n\\t\\t// Build the tree, note that the tree should include all the roots in trees.\\n        TreeNode* r = mp.begin()->second;\\n        int num = 1;\\n        build(r, conn, num);\\n        if(num != trees.size()) return nullptr;\\n        \\n\\t\\t// Pre-order traversal to make sure the result binary tree is BST.\\n        vector<int> v;\\n        preorder(r, v);\\n        for(int i=1; i<v.size(); ++i) {\\n            if(v[i] <= v[i-1]) return nullptr;\\n        }\\n        return r;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void build(TreeNode* r,  unordered_map<TreeNode*, vector<TreeNode*>>& conn, int& num) {\\n        for(auto* n: conn[r]) {\\n            build(n, conn, num);\\n            if(r->left && r->left->val == n->val) {\\n                r->left = n;\\n                ++num;\\n            }\\n            if(r->right && r->right->val == n->val) {\\n                r->right = n;\\n                ++num;\\n            }           \\n        }\\n    }\\n    \\n    void preorder(TreeNode* r, vector<int>& v) {\\n        if(!r) return;\\n        preorder(r->left, v);\\n        v.push_back(r->val);\\n        preorder(r->right, v);\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n\\t\\t// Build a map that stores the val of each root as the key.\\n        unordered_map<int, TreeNode*> mp;\\n        for(auto* n: trees) mp[n->val] = n;\\n        \\n\\t\\t// For each root in trees, find out the other roots that it can connect to.\\n        unordered_map<TreeNode*, vector<TreeNode*>> conn;\\n        for(auto* n: trees) {\\n            if(n->left && mp.count(n->left->val)) {\\n                conn[n].push_back(mp[n->left->val]);\\n                mp.erase(n->left->val);\\n            }\\n            if(n->right && mp.count(n->right->val)) {\\n                conn[n].push_back(mp[n->right->val]);\\n                mp.erase(n->right->val);\\n            }            \\n        }\\n        \\n\\t\\t// After finding the connections, there should be only one root that is left (the root of the result BST).\\n        if(mp.empty() || mp.size() > 1) return nullptr;\\n\\n\\t\\t// Build the tree, note that the tree should include all the roots in trees.\\n        TreeNode* r = mp.begin()->second;\\n        int num = 1;\\n        build(r, conn, num);\\n        if(num != trees.size()) return nullptr;\\n        \\n\\t\\t// Pre-order traversal to make sure the result binary tree is BST.\\n        vector<int> v;\\n        preorder(r, v);\\n        for(int i=1; i<v.size(); ++i) {\\n            if(v[i] <= v[i-1]) return nullptr;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293703,
                "title": "c-topological-sort-based-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    bool is_valid_bst = true;\\n    pair<int, int> f(TreeNode* root) {\\n        pair<int, int> cv = {root->val, root->val};\\n        if(root->left)  {\\n            auto v = f(root->left);\\n            if(v.first >= root->val || v.second >= root->val) is_valid_bst = false;\\n            cv.first = min(cv.first, v.first);\\n            cv.second = max(cv.second, v.second);\\n        }\\n        if(root->right)  {\\n            auto v = f(root->right);\\n            if(v.first <= root->val || v.second <= root->val) is_valid_bst = false;\\n            cv.first = min(cv.first, v.first);\\n            cv.second = max(cv.second, v.second);\\n        }\\n        return cv;\\n    }\\n    \\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n = trees.size();\\n        unordered_map<int, int>  heads;\\n        for(int i=0;i<n;i++) {\\n            if(heads.find(trees[i]->val) != heads.end()) return nullptr;\\n            \\n            heads[trees[i]->val] = i;\\n        }\\n        \\n        vector<pair<int, int>> graph(n, {-1, -1});\\n        vector<pair<int, bool>> parent_list(n, {-1, false});\\n        for(int i=0;i<n;i++) {\\n            auto v = trees[i];\\n            if(v->left){ \\n                if(heads.find(v->left->val) != heads.end()){\\n                    graph[i].first =  heads[v->left->val];\\n                    parent_list[heads[v->left->val]] = {i, true}; \\n                }\\n            }\\n\\n            if(v->right){ \\n                if(heads.find(v->right->val) != heads.end()){\\n                    graph[i].second =  heads[v->right->val];\\n                    parent_list[heads[v->right->val]] = {i, false}; \\n                }\\n            }\\n        }\\n        \\n        vector<int> degrees(n);\\n        for(int i=0;i<n;i++){\\n            auto v = graph[i];\\n            degrees[i] = (v.first != -1) + (v.second != -1);\\n        }\\n        \\n        queue<int> q;\\n        for(int i=0;i<n;i++) {\\n            if(degrees[i] == 0) q.push(i);\\n        }\\n        \\n        int merge_count = 0;\\n        TreeNode* main_parent;\\n        while(!q.empty()) {\\n            int cti = q.front();\\n            q.pop();\\n            main_parent = trees[cti];\\n            \\n            pair<int, int> parent_info = parent_list[cti];\\n            int pi = parent_info.first;\\n            int is_left = parent_info.second;\\n            if(pi != -1){\\n                if(is_left){\\n                    trees[pi]->left = trees[cti];\\n                }else {\\n                    trees[pi]->right = trees[cti];\\n                }\\n                degrees[pi]--;\\n                merge_count++;\\n                \\n                if(degrees[pi] == 0) q.push(pi);\\n                \\n            }    \\n        }\\n        \\n        if(merge_count != n - 1) return nullptr;\\n\\n        f(main_parent);\\n        \\n        return is_valid_bst ? main_parent : nullptr;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    bool is_valid_bst = true;\\n    pair<int, int> f(TreeNode* root) {\\n        pair<int, int> cv = {root->val, root->val};\\n        if(root->left)  {\\n            auto v = f(root->left);\\n            if(v.first >= root->val || v.second >= root->val) is_valid_bst = false;\\n            cv.first = min(cv.first, v.first);\\n            cv.second = max(cv.second, v.second);\\n        }\\n        if(root->right)  {\\n            auto v = f(root->right);\\n            if(v.first <= root->val || v.second <= root->val) is_valid_bst = false;\\n            cv.first = min(cv.first, v.first);\\n            cv.second = max(cv.second, v.second);\\n        }\\n        return cv;\\n    }\\n    \\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n = trees.size();\\n        unordered_map<int, int>  heads;\\n        for(int i=0;i<n;i++) {\\n            if(heads.find(trees[i]->val) != heads.end()) return nullptr;\\n            \\n            heads[trees[i]->val] = i;\\n        }\\n        \\n        vector<pair<int, int>> graph(n, {-1, -1});\\n        vector<pair<int, bool>> parent_list(n, {-1, false});\\n        for(int i=0;i<n;i++) {\\n            auto v = trees[i];\\n            if(v->left){ \\n                if(heads.find(v->left->val) != heads.end()){\\n                    graph[i].first =  heads[v->left->val];\\n                    parent_list[heads[v->left->val]] = {i, true}; \\n                }\\n            }\\n\\n            if(v->right){ \\n                if(heads.find(v->right->val) != heads.end()){\\n                    graph[i].second =  heads[v->right->val];\\n                    parent_list[heads[v->right->val]] = {i, false}; \\n                }\\n            }\\n        }\\n        \\n        vector<int> degrees(n);\\n        for(int i=0;i<n;i++){\\n            auto v = graph[i];\\n            degrees[i] = (v.first != -1) + (v.second != -1);\\n        }\\n        \\n        queue<int> q;\\n        for(int i=0;i<n;i++) {\\n            if(degrees[i] == 0) q.push(i);\\n        }\\n        \\n        int merge_count = 0;\\n        TreeNode* main_parent;\\n        while(!q.empty()) {\\n            int cti = q.front();\\n            q.pop();\\n            main_parent = trees[cti];\\n            \\n            pair<int, int> parent_info = parent_list[cti];\\n            int pi = parent_info.first;\\n            int is_left = parent_info.second;\\n            if(pi != -1){\\n                if(is_left){\\n                    trees[pi]->left = trees[cti];\\n                }else {\\n                    trees[pi]->right = trees[cti];\\n                }\\n                degrees[pi]--;\\n                merge_count++;\\n                \\n                if(degrees[pi] == 0) q.push(pi);\\n                \\n            }    \\n        }\\n        \\n        if(merge_count != n - 1) return nullptr;\\n\\n        f(main_parent);\\n        \\n        return is_valid_bst ? main_parent : nullptr;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195014,
                "title": "java-simple-solution-using-hashmap-and-dfs",
                "content": "class Solution {\\n    int outputNumberOfNodes = 0;\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        HashMap<Integer, TreeNode> root = new HashMap<>();\\n        HashMap<Integer, TreeNode> child = new HashMap<>();\\n        \\n        int numberOfNode = 0;\\n        for (int i=0; i<trees.size(); i++) {\\n            root.put(trees.get(i).val, trees.get(i));\\n            numberOfNode++;\\n            \\n            if (trees.get(i).left != null) {\\n                child.put(trees.get(i).left.val, trees.get(i).left);\\n                numberOfNode++;\\n            }\\n            \\n            if (trees.get(i).right != null) {\\n                child.put(trees.get(i).right.val, trees.get(i).right);\\n                numberOfNode++;\\n            }\\n        }\\n        \\n        TreeNode node = null;\\n        for (int i=0; i<trees.size(); i++) {\\n            if (child.containsKey(trees.get(i).val)) {\\n                numberOfNode--;\\n                TreeNode first = child.get(trees.get(i).val);\\n                first.left = trees.get(i).left;\\n                first.right = trees.get(i).right;\\n            }\\n            else {\\n                if (node == null) {\\n                    node = trees.get(i);\\n                }\\n                else {\\n                    return null;\\n                }\\n            }\\n        }\\n        \\n        return (isValid(node, Integer.MIN_VALUE, Integer.MAX_VALUE) && numberOfNode == outputNumberOfNodes) ? node : null;\\n    }\\n    \\n    public boolean isValid(TreeNode root, int min, int max) {\\n        if (root == null) {\\n            return true;\\n        }\\n        \\n        outputNumberOfNodes++;\\n        if ((root.val <= min || root.val >= max)) {\\n            return false;\\n        }\\n        \\n        return (isValid(root.left, min, root.val) && isValid(root.right, root.val, max));\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    int outputNumberOfNodes = 0;\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        HashMap<Integer, TreeNode> root = new HashMap<>();\\n        HashMap<Integer, TreeNode> child = new HashMap<>();\\n        \\n        int numberOfNode = 0;\\n        for (int i=0; i<trees.size(); i++) {\\n            root.put(trees.get(i).val, trees.get(i));\\n            numberOfNode++;\\n            \\n            if (trees.get(i).left != null) {\\n                child.put(trees.get(i).left.val, trees.get(i).left);\\n                numberOfNode++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2185575,
                "title": "python-observation-dfs-with-thought-process-when-being-asked-during-interviews",
                "content": "### Observation + DFS\\nFirst of all, let\\'s observe the constraints that might give hints to the solution. \\n* All of roots are unique. It means we can quickly locate which `root` to replace child with using hashmap, otherwise for the same value of child, we might have multiple choices.\\n* We need to do `n - 1` operations. It means the `roots` ends up with the only one root left which is the final root for the BST since we need remove one root from `roots` each time.\\n* The final number of `roots` is 1 means for each `roots[i]` except the final root, there is always a `roots[j]` such that either of children of `roots[j]` equals to the value of `roots[i]`. This is the most important key to crack this problem. So we can say the BST is not valid if this condition is not met.\\n* All of roots are valid BST. It means we can pick root from `roots` greedly as long as the value of either children is equals to the root.\\n\\nSo we can summary that the algorithm is that\\n1. Store the value of each root from `roots` in hashmap.\\n2. Iterate left and right child of each root and remove the corresponding root from `roots`\\n3. Return None if more than 1 root left in `roots`.\\n4. The left one is the final root we need to return\\n5. Replace the children of final root recursively.\\n\\nI started with interative way, and found it too difficult to write. The easiest way is to recursively replace the root, left and right children, then return the root.\\n\\nFianlly, pass in the range to the dfs as well, which is used to evaluate the BST property.\\n\\n```python\\ndef canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n\\troots = {tree.val: tree for tree in trees}\\n\\tfor tree in trees:\\n\\t\\tif tree.left and tree.left.val in roots:\\n\\t\\t\\troots.pop(tree.left.val)\\n\\t\\tif tree.right and tree.right.val in roots:\\n\\t\\t\\troots.pop(tree.right.val)\\n\\tif len(roots) != 1:     \\n\\t\\treturn None\\n\\t_, root = roots.popitem()\\n\\troots = {tree.val: tree for tree in trees}\\n\\t\\n\\tself.is_valid = True\\n\\tdef dfs(root, left, right):\\n\\t\\tif root:\\n\\t\\t\\tif root.val < left or root.val > right: \\n\\t\\t\\t\\tself.is_valid = False\\n\\t\\t\\t\\treturn None\\n\\t\\t\\tif root.val in roots:\\n\\t\\t\\t\\troot = roots.pop(root.val)\\n\\t\\t\\t\\troot.left = dfs(root.left, left, root.val - 1)\\n\\t\\t\\t\\troot.right = dfs(root.right, root.val + 1, right)\\n\\t\\treturn root \\n\\n\\tdfs(root, 0, float(\\'inf\\'))\\n\\treturn root if self.is_valid and not roots else None\\n```\\n\\n*Time Complexity*= **O(N)**\\n*Space Complexity* = **O(N)**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```python\\ndef canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n\\troots = {tree.val: tree for tree in trees}\\n\\tfor tree in trees:\\n\\t\\tif tree.left and tree.left.val in roots:\\n\\t\\t\\troots.pop(tree.left.val)\\n\\t\\tif tree.right and tree.right.val in roots:\\n\\t\\t\\troots.pop(tree.right.val)\\n\\tif len(roots) != 1:     \\n\\t\\treturn None\\n\\t_, root = roots.popitem()\\n\\troots = {tree.val: tree for tree in trees}\\n\\t\\n\\tself.is_valid = True\\n\\tdef dfs(root, left, right):\\n\\t\\tif root:\\n\\t\\t\\tif root.val < left or root.val > right: \\n\\t\\t\\t\\tself.is_valid = False\\n\\t\\t\\t\\treturn None\\n\\t\\t\\tif root.val in roots:\\n\\t\\t\\t\\troot = roots.pop(root.val)\\n\\t\\t\\t\\troot.left = dfs(root.left, left, root.val - 1)\\n\\t\\t\\t\\troot.right = dfs(root.right, root.val + 1, right)\\n\\t\\treturn root \\n\\n\\tdfs(root, 0, float(\\'inf\\'))\\n\\treturn root if self.is_valid and not roots else None\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2089038,
                "title": "simple-java-o-n-with-explanation-using-hashmap",
                "content": "```\\nclass Solution {\\n    int finalTreeCount = 0;  // This will be used for final reconciliation\\n\\n\\tpublic TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> rootMap = new HashMap<>(); \\n        Map<Integer, TreeNode> leafMap = new HashMap<>();\\n        int count = 0; \\n        // Find all the root nodes and leaf nodes\\n        for (TreeNode x : trees) {\\n            count++;\\n            rootMap.put(x.val, x);\\n            if (x.left != null) {\\n                count++;\\n                leafMap.put(x.left.val, x.left);\\n            }\\n            if (x.right != null) {\\n                count++;\\n                leafMap.put(x.right.val, x.right);\\n            }\\n        }\\n\\t\\t\\n        TreeNode result = null;\\n        for (TreeNode x : trees) {\\n            \\n            if (leafMap.containsKey(x.val)) {\\n                count--; // decrement the count, as one node merged\\n                TreeNode l = leafMap.get(x.val);\\n                l.left = x.left;\\n                l.right = x.right;\\n            } else {\\n                if (result == null) {\\n                    result = x;\\n                } else {\\n                    return null; // if we have already one final tree, then getting another one is an error.\\n                }\\n            }\\n        }\\n        return (isValidBST(result) && count == finalTreeCount) ? result : null;\\n    }\\n    \\n    private boolean isValidBST(TreeNode x) {\\n        if (x == null) return false;\\n        \\n        Deque<TreeNode> stack = new LinkedList<>();\\n        TreeNode curr = x;\\n        TreeNode prev = null;\\n        while(curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            curr = stack.pop();\\n            finalTreeCount++;\\n            \\n            if (prev != null && prev.val >= curr.val) {\\n                return false;\\n            }\\n            \\n            prev = curr;\\n            curr = curr.right;\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    int finalTreeCount = 0;  // This will be used for final reconciliation\\n\\n\\tpublic TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> rootMap = new HashMap<>(); \\n        Map<Integer, TreeNode> leafMap = new HashMap<>();\\n        int count = 0; \\n        // Find all the root nodes and leaf nodes\\n        for (TreeNode x : trees) {\\n            count++;\\n            rootMap.put(x.val, x);\\n            if (x.left != null) {\\n                count++;\\n                leafMap.put(x.left.val, x.left);\\n            }\\n            if (x.right != null) {\\n                count++;\\n                leafMap.put(x.right.val, x.right);\\n            }\\n        }\\n\\t\\t\\n        TreeNode result = null;\\n        for (TreeNode x : trees) {\\n            \\n            if (leafMap.containsKey(x.val)) {\\n                count--; // decrement the count, as one node merged\\n                TreeNode l = leafMap.get(x.val);\\n                l.left = x.left;\\n                l.right = x.right;\\n            } else {\\n                if (result == null) {\\n                    result = x;\\n                } else {\\n                    return null; // if we have already one final tree, then getting another one is an error.\\n                }\\n            }\\n        }\\n        return (isValidBST(result) && count == finalTreeCount) ? result : null;\\n    }\\n    \\n    private boolean isValidBST(TreeNode x) {\\n        if (x == null) return false;\\n        \\n        Deque<TreeNode> stack = new LinkedList<>();\\n        TreeNode curr = x;\\n        TreeNode prev = null;\\n        while(curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            curr = stack.pop();\\n            finalTreeCount++;\\n            \\n            if (prev != null && prev.val >= curr.val) {\\n                return false;\\n            }\\n            \\n            prev = curr;\\n            curr = curr.right;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1993949,
                "title": "c-with-comment-and-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    //O(N) \\n    pair<bool,pair<int,int>> check_bst(TreeNode* king){ //<true,<min,max>> if it is bst\\n    pair<bool,pair<int,int>> l,r;\\n    if(!(king->left) and !(king->right)) return make_pair(true,make_pair(king->val,king->val));\\n    if((king->left) and (king->right) ){\\n        l=check_bst(king->left);\\n        r=check_bst(king->right);\\n        if(!l.first or !r.first or l.second.second>=king->val or r.second.first<=king->val ) \\n            return make_pair(false,make_pair(king->val,king->val));\\n        return make_pair(true,make_pair(l.second.first,r.second.second));\\n    }\\n    if((king->left) and !(king->right) ){\\n        l=check_bst(king->left);\\n        if(!l.first  or l.second.second>=king->val ) \\n            return make_pair(false,make_pair(king->val,king->val));\\n        return make_pair(true,make_pair(l.second.first,king->val));\\n    }\\n    if(!(king->left) and (king->right) ){\\n        r=check_bst(king->right);\\n        if( !r.first  or r.second.first<=king->val ) \\n            return make_pair(false,make_pair(king->val,king->val));\\n        return make_pair(true,make_pair(king->val,r.second.second));\\n    }\\n        \\n    return make_pair(false,make_pair(king->val,king->val));\\n    }\\n    \\n    \\n    \\n    //O(N) make tree (use hash map for searching.)\\n    map<int,TreeNode*>  mp; // a mapping of head node value to head for tree in trees.   \\n    map<int,TreeNode*>::iterator itr;\\n    void maketree(TreeNode* king){\\n\\n    if(king->left) {\\n        itr= mp.find(king->left->val);  //O(1) enhancement due to hash map\\n        if(itr!=mp.end()){\\n            king->left = itr->second;   //attach the tree itr->second as left subtree of king\\n            mp.erase(itr);\\n            maketree(king->left);\\n        }   \\n    }\\n    if(king->right) {\\n        itr= mp.find(king->right->val);  //O(1) enhancement due to hash map\\n        if(itr!=mp.end()){\\n            king->right = itr->second;  //attach the tree itr->second as right subtree of king\\n            mp.erase(itr);\\n            maketree(king->right);\\n        }   \\n    }\\n    return;    \\n    }\\n      \\n    //return king as the head of merged tree, remove king from trees\\n    //return nullptr if failed\\n\\t//note: king is defined as the head of the final combined tree. \\n\\t//      No leaf node can have same value as king node.\\n    //O(N) using set\\n    TreeNode* find_king(vector<TreeNode*>& trees) {\\n    set<int> leaf;\\n    \\n    TreeNode* king;\\n    king=nullptr;\\n    vector<TreeNode*>::iterator t1,t2;\\n    \\n\\t//insert all the leaf values to set for speeding up of searching\\n    for(t1=trees.begin();t1!=trees.end();t1++){ \\n    if((*t1)->left) leaf.insert((*t1)->left->val);\\n    if((*t1)->right) leaf.insert((*t1)->right->val);   \\n    }\\n        \\n    for(t1=trees.begin();t1!=trees.end();t1++){ \\n    if(leaf.find((*t1)->val)==leaf.end()) {king=*t1;trees.erase(t1);return king;}   //O(1) due to hash \\n    }      \\n    return king;\\n    }\\n    \\n    //O(N) main program\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n    int n=trees.size();\\n    vector<TreeNode*>::iterator t1;\\n    \\n        \\n    //find_king O(N)\\n    start();\\n    TreeNode* king;\\n    king=find_king(trees);\\n    if(king==nullptr) return nullptr; //no king\\n    cout<<\"find_king: \";stop();\\n    \\n    //maketree O(N) \\n    start();\\n    for(t1=trees.begin();t1!=trees.end();t1++){\\n    mp[(*t1)->val]=*t1;\\n    } \\n    maketree( king);\\n    cout<<\"maketree: \";stop();\\n    \\n    //check_bst O(N)\\n    start();\\n    if (mp.size()!=0) {cout<<\"cannot form single tree.\\\\n\";return nullptr;}\\n    if(!check_bst(king).first) {cout<<\"check_bst: \";stop();return nullptr;}\\n    cout<<\"check_bst: \";stop();\\n    \\n    return king;\\n    }\\n    \\n    \\n    //for timing purpose\\n    std::chrono::high_resolution_clock::time_point tstart  ; \\n    void start(){\\n    tstart = chrono::high_resolution_clock::now();    \\n    return;\\n    }\\n    void stop(){\\n    auto stop = chrono::high_resolution_clock::now();\\n    auto duration = chrono::duration_cast<chrono::microseconds>(stop - tstart);\\n    cout<<\"*\"<<duration.count()<<\" ms\\\\n\";\\n    return ;\\n    }\\n    void sleep(){\\n    /* Simulating a long, heavy operation. */\\n\\n    using namespace std::chrono_literals;\\n    std::this_thread::sleep_for(1732ms);\\n    }\\n};```",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //O(N) \\n    pair<bool,pair<int,int>> check_bst(TreeNode* king){ //<true,<min,max>> if it is bst\\n    pair<bool,pair<int,int>> l,r;\\n    if(!(king->left) and !(king->right)) return make_pair(true,make_pair(king->val,king->val));\\n    if((king->left) and (king->right) ){\\n        l=check_bst(king->left);\\n        r=check_bst(king->right);\\n        if(!l.first or !r.first or l.second.second>=king->val or r.second.first<=king->val ) \\n            return make_pair(false,make_pair(king->val,king->val));\\n        return make_pair(true,make_pair(l.second.first,r.second.second));\\n    }\\n    if((king->left) and !(king->right) ){\\n        l=check_bst(king->left);\\n        if(!l.first  or l.second.second>=king->val ) \\n            return make_pair(false,make_pair(king->val,king->val));\\n        return make_pair(true,make_pair(l.second.first,king->val));\\n    }\\n    if(!(king->left) and (king->right) ){\\n        r=check_bst(king->right);\\n        if( !r.first  or r.second.first<=king->val ) \\n            return make_pair(false,make_pair(king->val,king->val));\\n        return make_pair(true,make_pair(king->val,r.second.second));\\n    }\\n        \\n    return make_pair(false,make_pair(king->val,king->val));\\n    }\\n    \\n    \\n    \\n    //O(N) make tree (use hash map for searching.)\\n    map<int,TreeNode*>  mp; // a mapping of head node value to head for tree in trees.   \\n    map<int,TreeNode*>::iterator itr;\\n    void maketree(TreeNode* king){\\n\\n    if(king->left) {\\n        itr= mp.find(king->left->val);  //O(1) enhancement due to hash map\\n        if(itr!=mp.end()){\\n            king->left = itr->second;   //attach the tree itr->second as left subtree of king\\n            mp.erase(itr);\\n            maketree(king->left);\\n        }   \\n    }\\n    if(king->right) {\\n        itr= mp.find(king->right->val);  //O(1) enhancement due to hash map\\n        if(itr!=mp.end()){\\n            king->right = itr->second;  //attach the tree itr->second as right subtree of king\\n            mp.erase(itr);\\n            maketree(king->right);\\n        }   \\n    }\\n    return;    \\n    }\\n      \\n    //return king as the head of merged tree, remove king from trees\\n    //return nullptr if failed\\n\\t//note: king is defined as the head of the final combined tree. \\n\\t//      No leaf node can have same value as king node.\\n    //O(N) using set\\n    TreeNode* find_king(vector<TreeNode*>& trees) {\\n    set<int> leaf;\\n    \\n    TreeNode* king;\\n    king=nullptr;\\n    vector<TreeNode*>::iterator t1,t2;\\n    \\n\\t//insert all the leaf values to set for speeding up of searching\\n    for(t1=trees.begin();t1!=trees.end();t1++){ \\n    if((*t1)->left) leaf.insert((*t1)->left->val);\\n    if((*t1)->right) leaf.insert((*t1)->right->val);   \\n    }\\n        \\n    for(t1=trees.begin();t1!=trees.end();t1++){ \\n    if(leaf.find((*t1)->val)==leaf.end()) {king=*t1;trees.erase(t1);return king;}   //O(1) due to hash \\n    }      \\n    return king;\\n    }\\n    \\n    //O(N) main program\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n    int n=trees.size();\\n    vector<TreeNode*>::iterator t1;\\n    \\n        \\n    //find_king O(N)\\n    start();\\n    TreeNode* king;\\n    king=find_king(trees);\\n    if(king==nullptr) return nullptr; //no king\\n    cout<<\"find_king: \";stop();\\n    \\n    //maketree O(N) \\n    start();\\n    for(t1=trees.begin();t1!=trees.end();t1++){\\n    mp[(*t1)->val]=*t1;\\n    } \\n    maketree( king);\\n    cout<<\"maketree: \";stop();\\n    \\n    //check_bst O(N)\\n    start();\\n    if (mp.size()!=0) {cout<<\"cannot form single tree.\\\\n\";return nullptr;}\\n    if(!check_bst(king).first) {cout<<\"check_bst: \";stop();return nullptr;}\\n    cout<<\"check_bst: \";stop();\\n    \\n    return king;\\n    }\\n    \\n    \\n    //for timing purpose\\n    std::chrono::high_resolution_clock::time_point tstart  ; \\n    void start(){\\n    tstart = chrono::high_resolution_clock::now();    \\n    return;\\n    }\\n    void stop(){\\n    auto stop = chrono::high_resolution_clock::now();\\n    auto duration = chrono::duration_cast<chrono::microseconds>(stop - tstart);\\n    cout<<\"*\"<<duration.count()<<\" ms\\\\n\";\\n    return ;\\n    }\\n    void sleep(){\\n    /* Simulating a long, heavy operation. */\\n\\n    using namespace std::chrono_literals;\\n    std::this_thread::sleep_for(1732ms);\\n    }\\n};```",
                "codeTag": "C++"
            },
            {
                "id": 1984182,
                "title": "c-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    const int nax = 5e4 + 1;\\n    bool validate(TreeNode* root, int left, int right, vector<bool>& vis) {\\n        if (root == nullptr) return true;\\n        vis[root->val] = false;\\n        if (root->val <= left || root->val >= right) return false;\\n        return validate(root->left, left, root->val, vis) & validate(root->right, root->val, right, vis);\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n = trees.size();\\n        vector<TreeNode*> roots(nax, nullptr);\\n        for (TreeNode* r : trees) {\\n            roots[r->val] = r;\\n        }\\n        vector<bool> notRoot(nax);\\n        vector<bool> vis(nax);\\n        for (TreeNode* r : trees) {\\n            vis[r->val] = true;\\n            if (r->left != nullptr) {\\n                vis[r->left->val] = true;\\n            }\\n            if (r->right != nullptr) {\\n                vis[r->right->val] = true;\\n            } \\n        }\\n        for (TreeNode* r : trees) {\\n            if (r->left != nullptr) {\\n                int val = r->left->val;\\n                if (roots[val] != nullptr && !notRoot[val]) {\\n                    delete r->left;\\n                    r->left = roots[val];\\n                    notRoot[val] = true;\\n                }\\n            }\\n            if (r->right != nullptr) {\\n                int val = r->right->val;\\n                if (roots[val] != nullptr && !notRoot[val]) {\\n                    delete r->right;\\n                    r->right = roots[val];\\n                    notRoot[val] = true;\\n                } \\n            }\\n        }\\n        int count = 0;\\n        TreeNode* root = nullptr;\\n        for (TreeNode* r : trees) {\\n            if (!notRoot[r->val]) {\\n                ++count;\\n                root = r;\\n            }\\n        }\\n        if (count > 1) return nullptr;\\n        if (!validate(root, -nax - 1, nax + 1, vis)) return nullptr;\\n        for (int i = 0; i < nax; i++) {\\n            if (vis[i]) return nullptr;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    const int nax = 5e4 + 1;\\n    bool validate(TreeNode* root, int left, int right, vector<bool>& vis) {\\n        if (root == nullptr) return true;\\n        vis[root->val] = false;\\n        if (root->val <= left || root->val >= right) return false;\\n        return validate(root->left, left, root->val, vis) & validate(root->right, root->val, right, vis);\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n = trees.size();\\n        vector<TreeNode*> roots(nax, nullptr);\\n        for (TreeNode* r : trees) {\\n            roots[r->val] = r;\\n        }\\n        vector<bool> notRoot(nax);\\n        vector<bool> vis(nax);\\n        for (TreeNode* r : trees) {\\n            vis[r->val] = true;\\n            if (r->left != nullptr) {\\n                vis[r->left->val] = true;\\n            }\\n            if (r->right != nullptr) {\\n                vis[r->right->val] = true;\\n            } \\n        }\\n        for (TreeNode* r : trees) {\\n            if (r->left != nullptr) {\\n                int val = r->left->val;\\n                if (roots[val] != nullptr && !notRoot[val]) {\\n                    delete r->left;\\n                    r->left = roots[val];\\n                    notRoot[val] = true;\\n                }\\n            }\\n            if (r->right != nullptr) {\\n                int val = r->right->val;\\n                if (roots[val] != nullptr && !notRoot[val]) {\\n                    delete r->right;\\n                    r->right = roots[val];\\n                    notRoot[val] = true;\\n                } \\n            }\\n        }\\n        int count = 0;\\n        TreeNode* root = nullptr;\\n        for (TreeNode* r : trees) {\\n            if (!notRoot[r->val]) {\\n                ++count;\\n                root = r;\\n            }\\n        }\\n        if (count > 1) return nullptr;\\n        if (!validate(root, -nax - 1, nax + 1, vis)) return nullptr;\\n        for (int i = 0; i < nax; i++) {\\n            if (vis[i]) return nullptr;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960168,
                "title": "python-clean-code",
                "content": "```\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        map = {t.val: t for t in trees}\\n        parents = set(map).difference(\\n            kid.val for t in trees for kid in (t.left, t.right) if kid\\n        )\\n        if len(parents) != 1:\\n            return None\\n\\n        root = map.pop(parents.pop())\\n\\n        q = deque([(root, float(\"-inf\"), float(\"inf\"))])\\n        while q:\\n            node, left, right = q.popleft()\\n            if not left < node.val < right:\\n                return\\n\\n            if node.left:\\n                node.left = map.pop(node.left.val, node.left)\\n                q.append((node.left, left, node.val))\\n\\n            if node.right:\\n                node.right = map.pop(node.right.val, node.right)\\n                q.append((node.right, node.val, right))\\n        if not map:\\n            return root\\n```",
                "solutionTags": [
                    "Queue",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        map = {t.val: t for t in trees}\\n        parents = set(map).difference(\\n            kid.val for t in trees for kid in (t.left, t.right) if kid\\n        )\\n        if len(parents) != 1:\\n            return None\\n\\n        root = map.pop(parents.pop())\\n\\n        q = deque([(root, float(\"-inf\"), float(\"inf\"))])\\n        while q:\\n            node, left, right = q.popleft()\\n            if not left < node.val < right:\\n                return\\n\\n            if node.left:\\n                node.left = map.pop(node.left.val, node.left)\\n                q.append((node.left, left, node.val))\\n\\n            if node.right:\\n                node.right = map.pop(node.right.val, node.right)\\n                q.append((node.right, node.val, right))\\n        if not map:\\n            return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958073,
                "title": "python-100-faster-use-dict-with-detailed-comment",
                "content": "**Idea**\\nFirst we build a leaf-value-to-root dict. If we found two leaves with the same value, return None.\\nThen we iterate the trees, if a tree has same value with other leaf(by checking if tree.val is in the dict), it can be merged into it. Otherwise it\\'s our root tree!\\nAfter we finish merging, check if the tree is a valid bst and node count is right.\\nDone.\\n\\n**Some Questions**\\n* Should we check if there are circles in the tree?\\n\\t* technically, yes. However, we have already make sure that won\\'t happen.\\n\\t* think these two cases: [[1,null,3],[3,1],[4,2]] and [[1,null,3],[3,1]]\\n\\t\\t* if circle appears, we will get an incomplete tree after the merging process, node counting will help us check it out.\\n\\t\\t* if circle appears during the merge, it won\\'t be the root node, so we don\\'t need to worry about infinite recursion during node counting\\n\\n**Complexity**\\n\\nTime complexity: O(N)\\nSpace complexity: O(N)\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def canMerge(self, trees):\\n        \"\"\"\\n        :type trees: List[TreeNode]\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        # check if root is a valid bst\\n        # l < root.val < r\\n        def _is_validate(root, l, r):\\n            if root is None:\\n                return True\\n            if root.val <= l or root.val >= r:\\n                return False\\n            if not _is_validate(root.left, l, min(root.val, r)):\\n                return False\\n            if not _is_validate(root.right, max(l, root.val), r):\\n                return False\\n            return True\\n        \\n        # calculate node count of root\\n        def _node_cnt(root):\\n            if root is None:\\n                return 0\\n            return 1 + _node_cnt(root.left) + _node_cnt(root.right)\\n        \\n        # m : {key : (root, direction)}\\n        # key if val of the leaf node, val is it\\'s root\\n        m = {}\\n        _total_node_cnt = 0\\n        for root in trees:\\n            _total_node_cnt += 1\\n            if root.left:\\n                if root.left.val in m:\\n                    # if there are two leaf nodes with the same val, trees cannot merge into one valid bst.\\n                    # because leaf values must STRICTLY less or greater than root.\\n                    return None\\n                m[root.left.val] = (root, \\'l\\')\\n                _total_node_cnt += 1\\n            if root.right:\\n                if root.right.val in m:\\n                    return None\\n                m[root.right.val] = (root, \\'r\\')\\n                _total_node_cnt += 1\\n        \\n        ret = None\\n        for root in trees:\\n            if root.val in m:\\n                # root can be merged into other tree\\n                r, dir_ = m[root.val]\\n                if dir_ == \\'l\\':\\n                    r.left = root\\n                else:\\n                    r.right = root\\n                # merge success, two nodes are merged into one.\\n                _total_node_cnt -= 1\\n            elif ret is not None:\\n                # only one tree(\"root tree\") cannot be merged, return None\\n                return None\\n            else:\\n                # if root cannot merge into other tree, we know it\\'s root of the answer\\n                ret = root\\n\\n        return ret if ret and _node_cnt(ret) == _total_node_cnt and _is_validate(ret, -999999, 999999) else None\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def canMerge(self, trees):\\n        \"\"\"\\n        :type trees: List[TreeNode]\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        # check if root is a valid bst\\n        # l < root.val < r\\n        def _is_validate(root, l, r):\\n            if root is None:\\n                return True\\n            if root.val <= l or root.val >= r:\\n                return False\\n            if not _is_validate(root.left, l, min(root.val, r)):\\n                return False\\n            if not _is_validate(root.right, max(l, root.val), r):\\n                return False\\n            return True\\n        \\n        # calculate node count of root\\n        def _node_cnt(root):\\n            if root is None:\\n                return 0\\n            return 1 + _node_cnt(root.left) + _node_cnt(root.right)\\n        \\n        # m : {key : (root, direction)}\\n        # key if val of the leaf node, val is it\\'s root\\n        m = {}\\n        _total_node_cnt = 0\\n        for root in trees:\\n            _total_node_cnt += 1\\n            if root.left:\\n                if root.left.val in m:\\n                    # if there are two leaf nodes with the same val, trees cannot merge into one valid bst.\\n                    # because leaf values must STRICTLY less or greater than root.\\n                    return None\\n                m[root.left.val] = (root, \\'l\\')\\n                _total_node_cnt += 1\\n            if root.right:\\n                if root.right.val in m:\\n                    return None\\n                m[root.right.val] = (root, \\'r\\')\\n                _total_node_cnt += 1\\n        \\n        ret = None\\n        for root in trees:\\n            if root.val in m:\\n                # root can be merged into other tree\\n                r, dir_ = m[root.val]\\n                if dir_ == \\'l\\':\\n                    r.left = root\\n                else:\\n                    r.right = root\\n                # merge success, two nodes are merged into one.\\n                _total_node_cnt -= 1\\n            elif ret is not None:\\n                # only one tree(\"root tree\") cannot be merged, return None\\n                return None\\n            else:\\n                # if root cannot merge into other tree, we know it\\'s root of the answer\\n                ret = root\\n\\n        return ret if ret and _node_cnt(ret) == _total_node_cnt and _is_validate(ret, -999999, 999999) else None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842567,
                "title": "c-solution",
                "content": "\\'\\'\\'\\nvoid helper(TreeNode* root, map<int, TreeNode*> &mp, set<int> &s)\\n    {\\n        if(root==NULL)\\n            return ;\\n        if(mp.size()==1)\\n            return;\\n        if(root->left!=NULL)\\n        {\\n            if(mp.find(root->left->val)!=mp.end())\\n            {\\n                root->left = mp[root->left->val];\\n                 mp.erase(root->left->val);\\n            }\\n           \\n        }\\n        if(root->right!=NULL)\\n        {\\n            if(mp.find(root->right->val)!=mp.end())\\n            {\\n                root->right = mp[root->right->val];\\n                mp.erase(root->right->val);\\n            }\\n        }\\n        helper(root->left, mp, s);\\n        helper(root->right, mp, s);\\n        \\n    }\\n    void isBST(TreeNode* root, int &prev, bool &flag)\\n    {\\n        if(root==NULL)\\n            return;\\n        isBST(root->left, prev, flag);\\n        if(prev!=-1)\\n        {\\n            if(prev>=root->val)\\n            {\\n                flag = false;\\n                return;\\n            }\\n            \\n        }\\n        prev = root->val;\\n        isBST(root->right, prev, flag);\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n    \\n        map<int, TreeNode*> mp;\\n        set<int> s;\\n        int i, n;\\n        n = trees.size();\\n        if(n==0)\\n            return NULL;\\n        if(n==1)\\n            return trees[0];\\n        for(i=0; i<n; i++)\\n        {\\n            TreeNode* temp = trees[i];\\n            if(temp!=NULL)\\n            {\\n                mp[temp->val] = temp;\\n            }\\n            if(temp->left)\\n            {\\n                s.insert(temp->left->val);\\n            }\\n            if(temp->right)\\n            {\\n                s.insert(temp->right->val);\\n            }\\n        }\\n        TreeNode* root = NULL;\\n        for(i=0; i<n; i++)\\n        {\\n            if(s.find(trees[i]->val)==s.end())\\n            {\\n                root= trees[i];\\n                break;\\n            }\\n        }\\n        helper(root, mp, s);\\n        if(mp.size()!=1)\\n            return NULL;\\n        bool flag = true;\\n        int prev = -1;\\n        isBST(root, prev , flag);\\n        if(flag)\\n            return root;\\n        else\\n            return NULL;\\n        \\n    }\\n\\t\\'\\'\\'",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "\\'\\'\\'\\nvoid helper(TreeNode* root, map<int, TreeNode*> &mp, set<int> &s)\\n    {\\n        if(root==NULL)\\n            return ;\\n        if(mp.size()==1)\\n            return;\\n        if(root->left!=NULL)\\n        {\\n            if(mp.find(root->left->val)!=mp.end())\\n            {\\n                root->left = mp[root->left->val];\\n                 mp.erase(root->left->val);\\n            }\\n           \\n        }\\n        if(root->right!=NULL)\\n        {\\n            if(mp.find(root->right->val)!=mp.end())\\n            {\\n                root->right = mp[root->right->val];\\n                mp.erase(root->right->val);\\n            }\\n        }\\n        helper(root->left, mp, s);\\n        helper(root->right, mp, s);\\n        \\n    }\\n    void isBST(TreeNode* root, int &prev, bool &flag)\\n    {\\n        if(root==NULL)\\n            return;\\n        isBST(root->left, prev, flag);\\n        if(prev!=-1)\\n        {\\n            if(prev>=root->val)\\n            {\\n                flag = false;\\n                return;\\n            }\\n            \\n        }\\n        prev = root->val;\\n        isBST(root->right, prev, flag);\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n    \\n        map<int, TreeNode*> mp;\\n        set<int> s;\\n        int i, n;\\n        n = trees.size();\\n        if(n==0)\\n            return NULL;\\n        if(n==1)\\n            return trees[0];\\n        for(i=0; i<n; i++)\\n        {\\n            TreeNode* temp = trees[i];\\n            if(temp!=NULL)\\n            {\\n                mp[temp->val] = temp;\\n            }\\n            if(temp->left)\\n            {\\n                s.insert(temp->left->val);\\n            }\\n            if(temp->right)\\n            {\\n                s.insert(temp->right->val);\\n            }\\n        }\\n        TreeNode* root = NULL;\\n        for(i=0; i<n; i++)\\n        {\\n            if(s.find(trees[i]->val)==s.end())\\n            {\\n                root= trees[i];\\n                break;\\n            }\\n        }\\n        helper(root, mp, s);\\n        if(mp.size()!=1)\\n            return NULL;\\n        bool flag = true;\\n        int prev = -1;\\n        isBST(root, prev , flag);\\n        if(flag)\\n            return root;\\n        else\\n            return NULL;\\n        \\n    }\\n\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1834916,
                "title": "intuitive-c-hashing-bst",
                "content": "It is simple for the trees that have only one node. they will not effect the overall tree after merging all the trees. But we just need to check if there is a possible place for them to be merged. If not, we return NULL.\\n\\nThe second observation is after merging 2 trees, one leaf node gets removed and count of trees also reduces by 1. \\n\\nThe third observation is after removing single noded trees, all the leave nodes must be unique. why? if it is not. there will be 2 instances of the node with same count in the final tree. \\n\\nWe create the final tree and check if the final tree is valid or not ( both BST properties and whether the final tree contains all the unique keys given as input)\\n\\n```\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode * root){\\n       return root->right==NULL and root->left==NULL; \\n    }\\n    \\n    bool addLeaves(TreeNode * root, unordered_map<int, TreeNode*> &map, unordered_set<int> &set){\\n       set.insert(root->val);\\n       if(isLeaf(root)){\\n          if(map.find(root->val)!=map.end()) {\\n              return false;\\n          }\\n          map[root->val] = root;\\n           return true;\\n       }\\n       else{\\n           if(root->left!=NULL){\\n               if(!addLeaves(root->left, map, set)){\\n                   return false;\\n               }\\n           }\\n           if(root->right!=NULL){\\n               if(!addLeaves(root->right, map, set)){\\n                   return false;\\n               }\\n           }\\n           return true;\\n       }\\n    }\\n    void merge(unordered_map<int, TreeNode *> &map, TreeNode * root){\\n        map[root->val]->left = root->left;\\n        map[root->val]->right = root->right;\\n        map.erase(map.find(root->val));\\n    }\\n    int countNodes(TreeNode * root){\\n        if(root==NULL){\\n           return 0; \\n        }\\n        else{\\n            return 1+countNodes(root->left) + countNodes(root->right);\\n        }\\n    }\\n    \\n    pair<int, int> isValid(TreeNode * root){\\n        if(isLeaf(root)){\\n            return {root->val, root->val};\\n        }\\n        \\n        else{\\n            int mn_, mx_;\\n            mn_ = root->val;\\n            mx_ = root->val;\\n            \\n            if(root->left!=NULL){\\n                pair<int, int> l = isValid(root->left);\\n                if(l.first==-1){\\n                    return l;\\n                }\\n                if(l.second>=root->val){\\n                   return {-1, -1} ;\\n                }\\n                else{\\n                    mn_ = l.first;\\n                }\\n            }\\n            if(root->right!=NULL){\\n                pair<int, int> r = isValid(root->right);\\n                if(r.first ==-1){\\n                    return r;\\n                }\\n                if(r.first<=root->val){\\n                    return  {-1, -1};\\n                }\\n                else{\\n                    mx_ = r.second;\\n                }\\n            }\\n            \\n            return {mn_, mx_};\\n        }\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& tree) {\\n        int n = tree.size();\\n        if(n==1){\\n            return tree[0];\\n        }\\n        int count = n;\\n        unordered_map<int, TreeNode*> leaves;\\n        unordered_set<int> all;\\n        for(int i=0;i<n;i++){\\n           if(!isLeaf(tree[i])) {\\n               if(!addLeaves(tree[i], leaves, all)){\\n                   return NULL;\\n               }\\n           }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(isLeaf(tree[i])){\\n                if(leaves.find(tree[i]->val)==leaves.end()){\\n                    return NULL;\\n                }\\n                else{\\n                    tree[i] = NULL;\\n                    count--;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            TreeNode * root = tree[i];\\n            if(root==NULL){\\n                continue;\\n            }\\n            if(leaves.find(root->val)!=leaves.end()){\\n                cout<<root->val<<endl;\\n                merge(leaves, root);\\n                count--;\\n                tree[i] = NULL;\\n            }\\n        }\\n        if(count!=1) {return NULL;}\\n        TreeNode * r =NULL;\\n        for(int i=0;i<n;i++){\\n            if(tree[i]!=NULL){\\n               r = tree[i] ;\\n                break;\\n            }\\n        }\\n        if(isValid(r).first!=-1 and countNodes(r)==all.size())\\n            return r;\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode * root){\\n       return root->right==NULL and root->left==NULL; \\n    }\\n    \\n    bool addLeaves(TreeNode * root, unordered_map<int, TreeNode*> &map, unordered_set<int> &set){\\n       set.insert(root->val);\\n       if(isLeaf(root)){\\n          if(map.find(root->val)!=map.end()) {\\n              return false;\\n          }\\n          map[root->val] = root;\\n           return true;\\n       }\\n       else{\\n           if(root->left!=NULL){\\n               if(!addLeaves(root->left, map, set)){\\n                   return false;\\n               }\\n           }\\n           if(root->right!=NULL){\\n               if(!addLeaves(root->right, map, set)){\\n                   return false;\\n               }\\n           }\\n           return true;\\n       }\\n    }\\n    void merge(unordered_map<int, TreeNode *> &map, TreeNode * root){\\n        map[root->val]->left = root->left;\\n        map[root->val]->right = root->right;\\n        map.erase(map.find(root->val));\\n    }\\n    int countNodes(TreeNode * root){\\n        if(root==NULL){\\n           return 0; \\n        }\\n        else{\\n            return 1+countNodes(root->left) + countNodes(root->right);\\n        }\\n    }\\n    \\n    pair<int, int> isValid(TreeNode * root){\\n        if(isLeaf(root)){\\n            return {root->val, root->val};\\n        }\\n        \\n        else{\\n            int mn_, mx_;\\n            mn_ = root->val;\\n            mx_ = root->val;\\n            \\n            if(root->left!=NULL){\\n                pair<int, int> l = isValid(root->left);\\n                if(l.first==-1){\\n                    return l;\\n                }\\n                if(l.second>=root->val){\\n                   return {-1, -1} ;\\n                }\\n                else{\\n                    mn_ = l.first;\\n                }\\n            }\\n            if(root->right!=NULL){\\n                pair<int, int> r = isValid(root->right);\\n                if(r.first ==-1){\\n                    return r;\\n                }\\n                if(r.first<=root->val){\\n                    return  {-1, -1};\\n                }\\n                else{\\n                    mx_ = r.second;\\n                }\\n            }\\n            \\n            return {mn_, mx_};\\n        }\\n    }\\n    \\n    TreeNode* canMerge(vector<TreeNode*>& tree) {\\n        int n = tree.size();\\n        if(n==1){\\n            return tree[0];\\n        }\\n        int count = n;\\n        unordered_map<int, TreeNode*> leaves;\\n        unordered_set<int> all;\\n        for(int i=0;i<n;i++){\\n           if(!isLeaf(tree[i])) {\\n               if(!addLeaves(tree[i], leaves, all)){\\n                   return NULL;\\n               }\\n           }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(isLeaf(tree[i])){\\n                if(leaves.find(tree[i]->val)==leaves.end()){\\n                    return NULL;\\n                }\\n                else{\\n                    tree[i] = NULL;\\n                    count--;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            TreeNode * root = tree[i];\\n            if(root==NULL){\\n                continue;\\n            }\\n            if(leaves.find(root->val)!=leaves.end()){\\n                cout<<root->val<<endl;\\n                merge(leaves, root);\\n                count--;\\n                tree[i] = NULL;\\n            }\\n        }\\n        if(count!=1) {return NULL;}\\n        TreeNode * r =NULL;\\n        for(int i=0;i<n;i++){\\n            if(tree[i]!=NULL){\\n               r = tree[i] ;\\n                break;\\n            }\\n        }\\n        if(isValid(r).first!=-1 and countNodes(r)==all.size())\\n            return r;\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1819537,
                "title": "simple-solution",
                "content": "class Solution {\\npublic:\\n    bool traverse(TreeNode* r, unordered_map<int, TreeNode*> &m, int min_left = INT_MIN, int max_right = INT_MAX) {\\n    if (r == nullptr) \\n        return true;\\n    if (r->val <= min_left || r->val >= max_right)\\n        return false;\\n    if (r->left == r->right) {\\n        auto it = m.find(r->val);\\n        if (it != end(m) && r != it->second) {\\n            r->left = it->second->left;\\n            r->right = it->second->right;\\n            m.erase(it);\\n        }\\n    }\\n    return traverse(r->left, m, min_left, r->val) && traverse(r->right, m, r->val, max_right);\\n}    \\nTreeNode* canMerge(vector<TreeNode*>& trees) {\\n    unordered_map<int, TreeNode*> m;\\n    unordered_map<int, int> cnt;\\n    for (auto &t : trees) {\\n        m[t->val] = t;\\n        ++cnt[t->val];\\n        ++cnt[t->left ? t->left->val : 0];\\n        ++cnt[t->right ? t->right->val : 0];\\n    }\\n    for (auto &t : trees)\\n        if (cnt[t->val] == 1)\\n            return traverse(t, m) && m.size() == 1 ? t : nullptr;\\n    return nullptr;\\n}\\n};",
                "solutionTags": [
                    "Tree"
                ],
                "code": "class Solution {\\npublic:\\n    bool traverse(TreeNode* r, unordered_map<int, TreeNode*> &m, int min_left = INT_MIN, int max_right = INT_MAX) {\\n    if (r == nullptr) \\n        return true;\\n    if (r->val <= min_left || r->val >= max_right)\\n        return false;\\n    if (r->left == r->right) {\\n        auto it = m.find(r->val);\\n        if (it != end(m) && r != it->second) {\\n            r->left = it->second->left;\\n            r->right = it->second->right;\\n            m.erase(it);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1780958,
                "title": "java-simple-bfs",
                "content": "~~~java\\n\\nclass Solution {\\n    Map<Integer, TreeNode> rootVals = new HashMap<>();\\n    \\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        TreeNode root = findRoot(trees);\\n        if (root == null) {\\n            return null;\\n        }\\n        \\n        for (TreeNode t : trees) {\\n            rootVals.put(t.val, t);\\n        }\\n        \\n        bfs(root);\\n        \\n        if (!isValidBST(root) || rootVals.size() != 1) {\\n            return null;\\n        }\\n        \\n        return root;\\n    }\\n    \\n    private TreeNode findRoot(List<TreeNode> trees) {\\n        TreeNode root = null;\\n        Map<Integer, Integer> valCnts = new HashMap<>();\\n        for (TreeNode t : trees) {\\n            valCnts.put(t.val, valCnts.getOrDefault(t.val, 0) + 1);\\n            if (t.left != null) {\\n                valCnts.put(t.left.val, valCnts.getOrDefault(t.left.val, 0) + 1);\\n            }\\n            if (t.right != null) {\\n                valCnts.put(t.right.val, valCnts.getOrDefault(t.right.val, 0) + 1);\\n            }\\n        }\\n        \\n        for (TreeNode t : trees) {\\n            if (valCnts.get(t.val) == 1) {\\n                if (root == null) {\\n                    root = t;\\n                } else {\\n                    return null;\\n                }\\n            }\\n        }\\n        \\n        return root;\\n    }\\n    \\n    private void bfs(TreeNode root) {\\n        Queue<TreeNode> q = new ArrayDeque<>();\\n        q.offer(root);\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode parent = q.poll();\\n                if (parent.left != null && rootVals.containsKey(parent.left.val)) {\\n                    TreeNode toConnect = rootVals.get(parent.left.val);\\n                    rootVals.remove(toConnect.val);\\n                    parent.left = toConnect;\\n                    q.offer(parent.left);\\n                }\\n                if (parent.right != null && rootVals.containsKey(parent.right.val)) {\\n                    TreeNode toConnect = rootVals.get(parent.right.val);\\n                    rootVals.remove(toConnect.val);\\n                    parent.right = toConnect;\\n                    q.offer(parent.right);\\n                }\\n            }\\n        }\\n    }\\n    \\n    private boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n    }\\n    \\n    private boolean isValidBST(TreeNode root, int min, int max) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val <= min || root.val >= max) {\\n            return false;\\n        }\\n        \\n        return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);\\n    }\\n}\\n\\n\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\n    Map<Integer, TreeNode> rootVals = new HashMap<>();\\n    \\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        TreeNode root = findRoot(trees);\\n        if (root == null) {\\n            return null;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1780098,
                "title": "javascript-hashmaps-root-to-value-mapping",
                "content": "A few things to keep in mind:\\n* **All root values are unique.**\\n* **To create a valid BST, all root values (except the final root) must map to exactly one leaf value (there cannot be multiple leaf values which are the same)**\\n----\\n1. Map roots to their matching leaves. Also keep track of the total count of nodes.\\n  This total count would have counted every single node once, so after joining into a valid BST, exactly n - 1 nodes would have been counted twice. \\n  So, we subtract n - 1 from our nodes count.\\n2. Get the root which doesn\\'t map to any leaf node, this is the final root.\\n3. Merge all the leaves -> roots together.\\n4. Validate the final tree. \\n----\\n**Time Complexity: O(n) 516ms\\nSpace Complexity: O(n) 79.1MB**\\n\\n```\\nvar canMerge = function(trees) {\\n  let leaves = new Map(), roots = new Set(), nodesCnt = 0, n = trees.length;\\n\\n  // map roots to matching leaves\\n  for (let tree of trees) {\\n    roots.add(tree.val);\\n    nodesCnt++;\\n    if (tree.left) {\\n      leaves.set(tree.left.val, tree); // save the parent/root so that we can replace it easily\\n      nodesCnt++;\\n    }\\n    if (tree.right) {\\n      leaves.set(tree.right.val, tree); // save the parent/root so that we can replace it easily\\n      nodesCnt++;\\n    }\\n  }\\n  nodesCnt = nodesCnt - (n - 1); // there are exactly n - 1 overlapping nodes counted\\n  \\n  // get the finalRoot\\n  let finalRoot = null;\\n  for (let tree of trees) {\\n    if (!leaves.has(tree.val)) {\\n      finalRoot = tree;\\n    }\\n  }\\n  \\n  for (let tree of trees) {\\n    if (tree !== finalRoot && leaves.has(tree.val)) {\\n      let leafParent = leaves.get(tree.val);\\n      if (leafParent.left && leafParent.left.val === tree.val) {\\n        leafParent.left = tree;\\n      } else {\\n        leafParent.right = tree;\\n      }\\n      roots.delete(tree.val); // after merging, delete the root. There should be exactly 1 root left at the end.\\n    }\\n  }\\n  // must be one root left, and node count must equal the total nodes\\n  return roots.size === 1 && countNodes(finalRoot) === nodesCnt ? finalRoot : null;\\n};\\n\\nfunction countNodes(root, min = -Infinity, max = Infinity) {\\n  if (!root) return 0;\\n  if (root.val <= min || root.val >= max) return 0;\\n  return 1 + countNodes(root.left, min, root.val) + countNodes(root.right, root.val, max);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canMerge = function(trees) {\\n  let leaves = new Map(), roots = new Set(), nodesCnt = 0, n = trees.length;\\n\\n  // map roots to matching leaves\\n  for (let tree of trees) {\\n    roots.add(tree.val);\\n    nodesCnt++;\\n    if (tree.left) {\\n      leaves.set(tree.left.val, tree); // save the parent/root so that we can replace it easily\\n      nodesCnt++;\\n    }\\n    if (tree.right) {\\n      leaves.set(tree.right.val, tree); // save the parent/root so that we can replace it easily\\n      nodesCnt++;\\n    }\\n  }\\n  nodesCnt = nodesCnt - (n - 1); // there are exactly n - 1 overlapping nodes counted\\n  \\n  // get the finalRoot\\n  let finalRoot = null;\\n  for (let tree of trees) {\\n    if (!leaves.has(tree.val)) {\\n      finalRoot = tree;\\n    }\\n  }\\n  \\n  for (let tree of trees) {\\n    if (tree !== finalRoot && leaves.has(tree.val)) {\\n      let leafParent = leaves.get(tree.val);\\n      if (leafParent.left && leafParent.left.val === tree.val) {\\n        leafParent.left = tree;\\n      } else {\\n        leafParent.right = tree;\\n      }\\n      roots.delete(tree.val); // after merging, delete the root. There should be exactly 1 root left at the end.\\n    }\\n  }\\n  // must be one root left, and node count must equal the total nodes\\n  return roots.size === 1 && countNodes(finalRoot) === nodesCnt ? finalRoot : null;\\n};\\n\\nfunction countNodes(root, min = -Infinity, max = Infinity) {\\n  if (!root) return 0;\\n  if (root.val <= min || root.val >= max) return 0;\\n  return 1 + countNodes(root.left, min, root.val) + countNodes(root.right, root.val, max);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1728235,
                "title": "go-inorder-traversal",
                "content": "Each BST can be considered a node in the merged tree, where leaves are edges toward other BSTs. With this viewpoint, construction of the tree (from the BSTs) is possible only if there is a single node (BST) which does not have an in-degree of zero.\\n\\nAt this point there may still not be a valid solution: two BSTs may point to each-other (`[2,1]`, `[1,2]`). To keep track of this, we mark each node as seen in a map.\\n\\nFinally, to validate the tree at the same time as its being constructed, merge BSTs in-order.\\n\\nFor this exercise I tried working with pointers to pointers just to practice. It could easily be replaced with more simple `if n.Left != nil` statements.\\n\\n```go\\nfunc canMerge(trees []*TreeNode) *TreeNode {\\n\\tindeg := make(map[int]int)\\n\\tnodes := make(map[int]*TreeNode)\\n\\n\\t// Helper for maybe counting indegrees / adding to global nodes map\\n\\tmaybeAdd := func(n *TreeNode) {\\n\\t\\tif n == nil {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tindeg[n.Val]++\\n\\t\\tif _, exists := nodes[n.Val]; !exists {\\n\\t\\t\\tnodes[n.Val] = n\\n\\t\\t}\\n\\t}\\n\\t// Count in-degrees and collect nodes into the nodes map\\n\\tfor _, t := range trees {\\n\\t\\tif _, exists := indeg[t.Val]; !exists {\\n\\t\\t\\tindeg[t.Val] = 0\\n\\t\\t}\\n\\t\\tnodes[t.Val] = t // overrides leaf node (if any)\\n\\t\\tmaybeAdd(t.Left)\\n\\t\\tmaybeAdd(t.Right)\\n\\t}\\n\\n\\t// Only one node should have an indegree of zero - the root\\n\\tvar root *TreeNode\\n\\tfor v, deg := range indeg {\\n\\t\\tif deg == 1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif root != nil {\\n\\t\\t\\treturn nil\\n\\t\\t}\\n\\t\\troot = nodes[v]\\n\\t}\\n\\n\\t// Perform inorder traversal of nodes, ensuring that each node is the node\\n\\t// in the nodes map. This will override leaf node addresses with the roots\\n\\t// they should be attached to\\n\\tseen := make(map[int]bool)\\n\\tmin := math.MinInt32\\n\\tvar inorder func(n **TreeNode) bool\\n\\tinorder = func(n **TreeNode) bool {\\n\\t\\tif (*n) == nil {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tseen[(*n).Val] = true\\n\\n\\t\\t// Replace current node (which may be a leaf) with 1. root, 2. leaf\\n\\t\\t// If it is the root itself, then this is a no-op\\n\\t\\tif m, exists := nodes[(*n).Val]; exists {\\n\\t\\t\\t*n = m // Replace pointers to this node with the map entry\\n\\t\\t}\\n\\n\\t\\tif !inorder(&((*n).Left)) {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\t// Check current node against min value\\n\\t\\tif (*n).Val <= min {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\t// Update lower bound based on the currently visited node\\n\\t\\t// this will work because we are performing in-order traversal\\n\\t\\tmin = (*n).Val\\n\\n\\t\\treturn inorder(&(*n).Right)\\n\\t}\\n\\n\\tif !inorder(&root) || len(seen) != len(nodes) {\\n\\t\\treturn nil\\n\\t}\\n\\treturn root\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc canMerge(trees []*TreeNode) *TreeNode {\\n\\tindeg := make(map[int]int)\\n\\tnodes := make(map[int]*TreeNode)\\n\\n\\t// Helper for maybe counting indegrees / adding to global nodes map\\n\\tmaybeAdd := func(n *TreeNode) {\\n\\t\\tif n == nil {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tindeg[n.Val]++\\n\\t\\tif _, exists := nodes[n.Val]; !exists {\\n\\t\\t\\tnodes[n.Val] = n\\n\\t\\t}\\n\\t}\\n\\t// Count in-degrees and collect nodes into the nodes map\\n\\tfor _, t := range trees {\\n\\t\\tif _, exists := indeg[t.Val]; !exists {\\n\\t\\t\\tindeg[t.Val] = 0\\n\\t\\t}\\n\\t\\tnodes[t.Val] = t // overrides leaf node (if any)\\n\\t\\tmaybeAdd(t.Left)\\n\\t\\tmaybeAdd(t.Right)\\n\\t}\\n\\n\\t// Only one node should have an indegree of zero - the root\\n\\tvar root *TreeNode\\n\\tfor v, deg := range indeg {\\n\\t\\tif deg == 1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif root != nil {\\n\\t\\t\\treturn nil\\n\\t\\t}\\n\\t\\troot = nodes[v]\\n\\t}\\n\\n\\t// Perform inorder traversal of nodes, ensuring that each node is the node\\n\\t// in the nodes map. This will override leaf node addresses with the roots\\n\\t// they should be attached to\\n\\tseen := make(map[int]bool)\\n\\tmin := math.MinInt32\\n\\tvar inorder func(n **TreeNode) bool\\n\\tinorder = func(n **TreeNode) bool {\\n\\t\\tif (*n) == nil {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tseen[(*n).Val] = true\\n\\n\\t\\t// Replace current node (which may be a leaf) with 1. root, 2. leaf\\n\\t\\t// If it is the root itself, then this is a no-op\\n\\t\\tif m, exists := nodes[(*n).Val]; exists {\\n\\t\\t\\t*n = m // Replace pointers to this node with the map entry\\n\\t\\t}\\n\\n\\t\\tif !inorder(&((*n).Left)) {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\t// Check current node against min value\\n\\t\\tif (*n).Val <= min {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\t// Update lower bound based on the currently visited node\\n\\t\\t// this will work because we are performing in-order traversal\\n\\t\\tmin = (*n).Val\\n\\n\\t\\treturn inorder(&(*n).Right)\\n\\t}\\n\\n\\tif !inorder(&root) || len(seen) != len(nodes) {\\n\\t\\treturn nil\\n\\t}\\n\\treturn root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1668572,
                "title": "java-bfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n List<Integer>  list = new ArrayList<>();\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Set<Integer> allVals = new HashSet<>();\\n        Set<Integer> set = new HashSet<>();\\n        HashMap<Integer,TreeNode> roots = new HashMap<>();\\n        for(TreeNode node : trees){\\n            roots.put(node.val,node);\\n            allVals.add(node.val);\\n            if(node.left!=null){\\n                set.add(node.left.val);\\n                allVals.add(node.left.val);\\n            }\\n            if(node.right!=null){\\n                set.add(node.right.val);\\n                allVals.add(node.right.val);\\n            }\\n        }\\n        Set<Integer> possibleRoots = new HashSet<>();\\n        for(TreeNode node : trees){\\n            if(!set.contains(node.val)){\\n                possibleRoots.add(node.val);\\n            }\\n        }\\n        if(possibleRoots.size()>1 || possibleRoots.isEmpty()){\\n            return null;\\n        }\\n        Integer root = possibleRoots.iterator().next();\\n        TreeNode mainRoot = roots.get(root);\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(roots.get(root));\\n        Set<Integer> visited = new HashSet<>();\\n        while(!queue.isEmpty()){\\n            TreeNode curr = queue.poll();\\n            if(curr!=null && !visited.contains(curr.val)){\\n                visited.add(curr.val);\\n                if(curr.left!=null && roots.containsKey(curr.left.val)){\\n                    curr.left = roots.get(curr.left.val);\\n                }\\n                if(curr.right!=null && roots.containsKey(curr.right.val)){\\n                    curr.right = roots.get(curr.right.val);\\n                }\\n                roots.remove(curr.val);\\n                queue.add(curr.left);\\n                queue.add(curr.right);\\n            }\\n        }\\n        dfs(mainRoot);\\n        for(int i =0;i+1<list.size();i++){\\n            if(list.get(i)>=list.get(i+1)){\\n                return null;\\n            }\\n        }\\n        Set<Integer> lVals = new HashSet<>(list);\\n        for(int num : allVals){\\n            if(!lVals.contains(num)){\\n                return null;\\n            }\\n        }\\n        return mainRoot;\\n    }\\n   \\n    \\n    void dfs(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        dfs(root.left);\\n        list.add(root.val);\\n        dfs(root.right);\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n List<Integer>  list = new ArrayList<>();\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Set<Integer> allVals = new HashSet<>();\\n        Set<Integer> set = new HashSet<>();\\n        HashMap<Integer,TreeNode> roots = new HashMap<>();\\n        for(TreeNode node : trees){\\n            roots.put(node.val,node);\\n            allVals.add(node.val);\\n            if(node.left!=null){\\n                set.add(node.left.val);\\n                allVals.add(node.left.val);\\n            }\\n            if(node.right!=null){\\n                set.add(node.right.val);\\n                allVals.add(node.right.val);\\n            }\\n        }\\n        Set<Integer> possibleRoots = new HashSet<>();\\n        for(TreeNode node : trees){\\n            if(!set.contains(node.val)){\\n                possibleRoots.add(node.val);\\n            }\\n        }\\n        if(possibleRoots.size()>1 || possibleRoots.isEmpty()){\\n            return null;\\n        }\\n        Integer root = possibleRoots.iterator().next();\\n        TreeNode mainRoot = roots.get(root);\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(roots.get(root));\\n        Set<Integer> visited = new HashSet<>();\\n        while(!queue.isEmpty()){\\n            TreeNode curr = queue.poll();\\n            if(curr!=null && !visited.contains(curr.val)){\\n                visited.add(curr.val);\\n                if(curr.left!=null && roots.containsKey(curr.left.val)){\\n                    curr.left = roots.get(curr.left.val);\\n                }\\n                if(curr.right!=null && roots.containsKey(curr.right.val)){\\n                    curr.right = roots.get(curr.right.val);\\n                }\\n                roots.remove(curr.val);\\n                queue.add(curr.left);\\n                queue.add(curr.right);\\n            }\\n        }\\n        dfs(mainRoot);\\n        for(int i =0;i+1<list.size();i++){\\n            if(list.get(i)>=list.get(i+1)){\\n                return null;\\n            }\\n        }\\n        Set<Integer> lVals = new HashSet<>(list);\\n        for(int num : allVals){\\n            if(!lVals.contains(num)){\\n                return null;\\n            }\\n        }\\n        return mainRoot;\\n    }\\n   \\n    \\n    void dfs(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        dfs(root.left);\\n        list.add(root.val);\\n        dfs(root.right);\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668267,
                "title": "easy-hash-map-bfs-implementation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool valid(TreeNode* x,int mn=INT_MIN,int mx=INT_MAX){\\n        if(!x) return 1;\\n        if(x->val<=mn or x->val>=mx) return 0;\\n        return (valid(x->left,mn,x->val)&valid(x->right,x->val,mx));\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        map<int,TreeNode*>t;\\n        map<int,int>cnt;\\n        for(TreeNode* x: trees){\\n            if(x) t[x->val]=x,cnt[x->val]++;\\n            if(x->left) cnt[x->left->val]++;\\n            if(x->right) cnt[x->right->val]++;\\n        }\\n        for(auto x: cnt){\\n            if(x.second==1 and t.count(x.first)){\\n                TreeNode* ans = t[x.first];\\n                queue<TreeNode*>q;\\n                q.push(ans);\\n                while(q.size()){\\n                    TreeNode* f=q.front();\\n                    q.pop();\\n                    if(!(f->left) and !(f->right)){\\n                        if(t.count(f->val) and t[f->val]!=f){\\n                            f->left=t[f->val]->left;\\n                            f->right=t[f->val]->right;\\n                            t.erase(f->val);\\n                        }\\n                    }\\n                    if(f->left) q.push(f->left);\\n                    if(f->right) q.push(f->right);\\n                }\\n                if(valid(ans)&&t.size()==1) return ans;   // check if the BST is valid or not\\n            }\\n        }\\n        TreeNode *tmp = NULL;\\n        return tmp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(TreeNode* x,int mn=INT_MIN,int mx=INT_MAX){\\n        if(!x) return 1;\\n        if(x->val<=mn or x->val>=mx) return 0;\\n        return (valid(x->left,mn,x->val)&valid(x->right,x->val,mx));\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        map<int,TreeNode*>t;\\n        map<int,int>cnt;\\n        for(TreeNode* x: trees){\\n            if(x) t[x->val]=x,cnt[x->val]++;\\n            if(x->left) cnt[x->left->val]++;\\n            if(x->right) cnt[x->right->val]++;\\n        }\\n        for(auto x: cnt){\\n            if(x.second==1 and t.count(x.first)){\\n                TreeNode* ans = t[x.first];\\n                queue<TreeNode*>q;\\n                q.push(ans);\\n                while(q.size()){\\n                    TreeNode* f=q.front();\\n                    q.pop();\\n                    if(!(f->left) and !(f->right)){\\n                        if(t.count(f->val) and t[f->val]!=f){\\n                            f->left=t[f->val]->left;\\n                            f->right=t[f->val]->right;\\n                            t.erase(f->val);\\n                        }\\n                    }\\n                    if(f->left) q.push(f->left);\\n                    if(f->right) q.push(f->right);\\n                }\\n                if(valid(ans)&&t.size()==1) return ans;   // check if the BST is valid or not\\n            }\\n        }\\n        TreeNode *tmp = NULL;\\n        return tmp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654034,
                "title": "javascript-solution",
                "content": "```\\nvar canMerge = function (trees) {\\n  mergeTrees(trees);\\n  const unmerged = trees.filter((p) => !p.merged);\\n  return unmerged.length > 1 ? null : unmerged[0];\\n};\\n\\nfunction mergeTrees(trees) {\\n  const leaves = extractAllLeaves(trees);\\n  for (let child of trees) {\\n    const possibleParents = leaves.get(child.val);\\n    if (!possibleParents) {\\n      continue;\\n    }\\n    for (let entry of possibleParents) {\\n      const root = entry.root;\\n      const leaf = entry.leaf;\\n      if (leaf == child || leaf == null) {\\n        continue;\\n      }\\n      tryMerge(root, leaf, child);\\n    }\\n  }\\n}\\n\\nfunction extractAllLeaves(trees) {\\n  const allLeaves = new Map();\\n  for (let tree of trees) {\\n    extractLeaves(tree);\\n    for (let [k, v] of tree.leaves.entries()) {\\n      allLeaves.set(k, (allLeaves.get(k) ?? []).concat(v));\\n    }\\n  }\\n  return allLeaves;\\n}\\nfunction tryMerge(parent, leaf, child) {\\n  if (!parent.ultimateRoot) {\\n    parent.ultimateRoot = parent;\\n  }\\n\\n  merge(parent, leaf, child);\\n\\n  if (validBst(parent.ultimateRoot)) {\\n    parent.ultimateRoot.leaves.delete(leaf.val);\\n    for (let [k, v] of child.leaves) {\\n      parent.ultimateRoot.leaves.set(k, v);\\n    }\\n  } else {\\n    undoMerge(leaf, child);\\n  }\\n}\\n\\nfunction validBst(\\n  root,\\n  min = Number.NEGATIVE_INFINITY,\\n  max = Number.POSITIVE_INFINITY\\n) {\\n  if (!root) return true;\\n  if (root.val <= min || root.val >= max) return false;\\n  return (\\n    validBst(root.left, min, Math.min(root.val, max)) &&\\n    validBst(root.right, Math.max(root.val, min), max)\\n  );\\n}\\n\\nfunction undoMerge(leaf, child) {\\n  leaf.left = null;\\n  leaf.right = null;\\n  child.ultimateRoot = child;\\n  child.merged = false;\\n}\\n\\nfunction merge(parent, leaf, child) {\\n  leaf.left = child.left;\\n  leaf.right = child.right;\\n  child.ultimateRoot = parent;\\n  child.merged = true;\\n}\\n\\nfunction extractLeaves(root) {\\n  if (root.leaves) return;\\n  root.leaves = new Map();\\n  dfs(root);\\n  function dfs(node) {\\n    if (!node) return;\\n    if (!node.left && !node.right) {\\n      root.leaves.set(node.val, { root, leaf: node });\\n    }\\n    dfs(node.left);\\n    dfs(node.right);\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canMerge = function (trees) {\\n  mergeTrees(trees);\\n  const unmerged = trees.filter((p) => !p.merged);\\n  return unmerged.length > 1 ? null : unmerged[0];\\n};\\n\\nfunction mergeTrees(trees) {\\n  const leaves = extractAllLeaves(trees);\\n  for (let child of trees) {\\n    const possibleParents = leaves.get(child.val);\\n    if (!possibleParents) {\\n      continue;\\n    }\\n    for (let entry of possibleParents) {\\n      const root = entry.root;\\n      const leaf = entry.leaf;\\n      if (leaf == child || leaf == null) {\\n        continue;\\n      }\\n      tryMerge(root, leaf, child);\\n    }\\n  }\\n}\\n\\nfunction extractAllLeaves(trees) {\\n  const allLeaves = new Map();\\n  for (let tree of trees) {\\n    extractLeaves(tree);\\n    for (let [k, v] of tree.leaves.entries()) {\\n      allLeaves.set(k, (allLeaves.get(k) ?? []).concat(v));\\n    }\\n  }\\n  return allLeaves;\\n}\\nfunction tryMerge(parent, leaf, child) {\\n  if (!parent.ultimateRoot) {\\n    parent.ultimateRoot = parent;\\n  }\\n\\n  merge(parent, leaf, child);\\n\\n  if (validBst(parent.ultimateRoot)) {\\n    parent.ultimateRoot.leaves.delete(leaf.val);\\n    for (let [k, v] of child.leaves) {\\n      parent.ultimateRoot.leaves.set(k, v);\\n    }\\n  } else {\\n    undoMerge(leaf, child);\\n  }\\n}\\n\\nfunction validBst(\\n  root,\\n  min = Number.NEGATIVE_INFINITY,\\n  max = Number.POSITIVE_INFINITY\\n) {\\n  if (!root) return true;\\n  if (root.val <= min || root.val >= max) return false;\\n  return (\\n    validBst(root.left, min, Math.min(root.val, max)) &&\\n    validBst(root.right, Math.max(root.val, min), max)\\n  );\\n}\\n\\nfunction undoMerge(leaf, child) {\\n  leaf.left = null;\\n  leaf.right = null;\\n  child.ultimateRoot = child;\\n  child.merged = false;\\n}\\n\\nfunction merge(parent, leaf, child) {\\n  leaf.left = child.left;\\n  leaf.right = child.right;\\n  child.ultimateRoot = parent;\\n  child.merged = true;\\n}\\n\\nfunction extractLeaves(root) {\\n  if (root.leaves) return;\\n  root.leaves = new Map();\\n  dfs(root);\\n  function dfs(node) {\\n    if (!node) return;\\n    if (!node.left && !node.right) {\\n      root.leaves.set(node.val, { root, leaf: node });\\n    }\\n    dfs(node.left);\\n    dfs(node.right);\\n  }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1653163,
                "title": "python-translation-of-votrubac-s-just-do-what-it-says",
                "content": "Giving full credit to: https://leetcode.com/problems/merge-bsts-to-create-single-bst/discuss/1330387/Just-do-what-it-says\\n\\n```\\nclass Solution:\\n    def traverse(self, node, dct, lower = float(\\'-inf\\'), upper = float(\\'inf\\')):\\n        if not node:\\n            return True\\n        val = node.val\\n        if not (lower < val < upper):\\n            return False\\n        if not node.left and not node.right:\\n            if val in dct:\\n                node.left = dct[val].left\\n                node.right = dct[val].right\\n                del dct[val]\\n        return self.traverse(node.left, dct, lower, val) and self.traverse(node.right, dct, val, upper)\\n\\t\\t\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        valCnt, rootDct = defaultdict(int), {}\\n        for t in trees:\\n            rootDct[t.val] = t\\n            valCnt[t.val] += 1\\n            for c in (t.left, t.right):\\n                if c:\\n                    valCnt[c.val] += 1\\n        for t in trees:\\n            if valCnt[t.val] == 1:\\n                if self.traverse(t, rootDct) and len(rootDct) <= 1:\\n                    return t\\n                else:\\n                    return None\\n        return None  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def traverse(self, node, dct, lower = float(\\'-inf\\'), upper = float(\\'inf\\')):\\n        if not node:\\n            return True\\n        val = node.val\\n        if not (lower < val < upper):\\n            return False\\n        if not node.left and not node.right:\\n            if val in dct:\\n                node.left = dct[val].left\\n                node.right = dct[val].right\\n                del dct[val]\\n        return self.traverse(node.left, dct, lower, val) and self.traverse(node.right, dct, val, upper)\\n\\t\\t\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n        valCnt, rootDct = defaultdict(int), {}\\n        for t in trees:\\n            rootDct[t.val] = t\\n            valCnt[t.val] += 1\\n            for c in (t.left, t.right):\\n                if c:\\n                    valCnt[c.val] += 1\\n        for t in trees:\\n            if valCnt[t.val] == 1:\\n                if self.traverse(t, rootDct) and len(rootDct) <= 1:\\n                    return t\\n                else:\\n                    return None\\n        return None  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598315,
                "title": "java-solution-using-hashtables-and-priority-queue",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n/*\\n\\nURL = https://leetcode.com/problems/merge-bsts-to-create-single-bst/ \\n1932. Merge BSTs to Create Single BST\\n\\nLet us leverage the invariant that node values in the node\\'s LST have value STRICTLY LESS than the root\\'s value\\nand nodes in the right subtree have value STRICTLY MORE than node\\'s value\\n\\nNote : we may be able to form \\n\\nHINT : leverage a hashmap\\n    -> store the min values and max values of BSTs ( seen in other problems ) \\n    \\nCOMPLEXITY\\nTime = ___\\nSpace = ___\\n\\nNode vals are known to be positives in range of [1,50000]\\n[[3],[3,1]] is luckily invalid anyways!\\n\\nTEST CASES\\n(A)[[2,1],[3,2,5],[5,4]] \\n(B) [[3],[4,3]]\\n    [4,3] = expected\\n(C)\\n(D)\\n(E)\\n\\nAlso this is a list, so deletion may or may not be possible. But a hashmap conversion also entails alacrity as well\\nNo two roots have same value -> we are in luck here too!\\nReturn null if a root is not able to be ascertained as well.\\nCount number of trees too ( hey you queue root ste handles this ! ) \\n\\n\\nRemember that we must maintain the count of operatinos here too\\n\\nStrategies : Hashtable, Queue, BFS ( Fringe-esque manner ) or DFS ( fringe-esque manner )\\n            I am unsure how binary search could help here though?\\n\\nYou forgot the case where the root may not even possess two children nodes ( e.g. 2L1 )\\nIn this case, we may get an overlap ( e.g. 2R3 )\\nThis is still a valid operation, and the fringe may have involved the root here as well. Exert caution now!\\n\\n*/\\nclass Solution \\n{\\n    \\n    public class Wrapper\\n    {\\n        public TreeNode node;\\n        public int min;\\n        public int max;\\n        \\n        public Wrapper()\\n        {\\n            this.node = null;\\n            min = 0;\\n            max = 50001; // ma of 50,000\\n            // min = Integer.MIN_VALUE;\\n            // max = Integer.MAX_VALUE;\\n        }\\n        \\n        // The \"this\" keyword is really a self-referential pointer in the hiding\\n        public Wrapper(TreeNode node, int min, int max)\\n        {\\n            this.node = node;\\n            this.min = min;\\n            this.max = max;\\n        }\\n    }\\n    \\n    // Range Info hashmap should be based on integers ... NOT on node addresses ( can cause a trip up with fringe analysis : leaf(1) != root(1) case ) \\n    public TreeNode canMerge(List<TreeNode> trees) \\n    {\\n        TreeNode newRoot = null;\\n        List<Wrapper> fringe = new ArrayList<Wrapper>();\\n        Queue<TreeNode> toExplore = new LinkedList<TreeNode>();  // abstract class needs a concrete class instantiation on the RHS\\n        HashMap<Integer, Wrapper> rangeInfo = new HashMap<Integer, Wrapper>();\\n        Set<Integer> rootSet = new HashSet<Integer>();\\n        \\n        if(trees == null || trees.size() == 0)\\n        {\\n            return null;\\n        }\\n        int n = trees.size();\\n        \\n        // [1] Initialize the HASHMAP with initialize range info for all rooted nodes\\n        // [2] In same for loop, add the nodes to the queue as well\\n        for(int i = 0; i < n; ++i)\\n        {\\n            TreeNode cur = trees.get(i);\\n            Wrapper metadata = new Wrapper();\\n            if(cur != null && !rangeInfo.containsKey(cur.val))\\n            {\\n                metadata.node = cur;\\n                if(cur.left != null)\\n                {\\n                    metadata.min = cur.left.val;\\n                }\\n                if(cur.right != null)\\n                {\\n                    metadata.max = cur.right.val;\\n                }\\n                rangeInfo.put(cur.val, metadata);\\n            }\\n            toExplore.add(cur);\\n        }\\n        // toExplore.add(toExplore.poll()); // Just add the first node to the end ( as we are already there anyways ) \\n        // System.out.printf(\"toExplore size = %d\\\\n\", toExplore.size());\\n        \\n        // [3] Initialize the fringe and first root node, along with the root set\\n        // Make sure the fringe itself is properly initialized here : we pass in these values later, depending on direction of add as well\\n        // Oh and make sure the root is part of the fringe set as well : hey we could get a bad case as well\\n        // But the root case begets much caution too ... as this fringe is not guaranteed its emptiness\\n        // One possibility : go fill that up, if possible , and then proceed with the legitimate fringe as expected\\n        // Wait we need not add the root to the fringe -> as the root trees differ, and a fringe must be a leaf\\n        // But what if the root HAS no leaves? \\n        // Well that is a special case indeed. Is in itself a frige at this point\\n        \\n        \\n        newRoot = toExplore.peek();\\n        if(newRoot.left == null && newRoot.right == null)\\n        {\\n            fringe.add(rangeInfo.get(newRoot.val));\\n        }\\n        if(newRoot.left != null)\\n        {\\n            fringe.add(new Wrapper(newRoot.left, 0, newRoot.val));\\n        }\\n        if(newRoot.right != null)\\n        {\\n            fringe.add(new Wrapper(newRoot.right, newRoot.val, 50001));\\n        }\\n        \\n        // [4] The meat of our algorithm here\\n//         List<Wrapper> fringe = new ArrayList<Wrapper>();\\n//         Queue<TreeNode> toExplore = new LinkedList<TreeNode>();  // abstract class needs a concrete class instantiation on the RHS\\n//         HashMap<TreeNode, Wrapper> rangeInfo = new HashMap<TreeNode, Wrapper>();\\n//         Set<TreeNode> rootSet = new HashSet<TreeNode>();\\n        \\n        // Handle null pointer exception later\\n        while(!toExplore.isEmpty())\\n        {\\n            while(!fringe.isEmpty())\\n            {\\n                // If either children are null : well hey, they are infinites too. Leverage that as well.\\n                // System.out.printf(\"Evaluating fringe\\\\n\");\\n                Wrapper fringeWrapper = fringe.remove(0);\\n                TreeNode fringeNode = fringeWrapper.node; \\n                if(fringeNode == newRoot)\\n                {\\n                    // System.out.printf(\"Fringe = new root\\\\n\");\\n                    continue; // ignore this case\\n                }\\n                // Go remove a former root, if we end up adding it anyways!\\n                if(rootSet.contains(fringeNode.val))\\n                {\\n                    // System.out.printf(\"Removing node [%d] from root set\\\\n\", fringeNode.val);\\n                    rootSet.remove(fringeNode.val);\\n                }\\n                int fringeMin = fringeWrapper.min;\\n                int fringeMax = fringeWrapper.max;\\n                if(rangeInfo.containsKey(fringeNode.val))\\n                {\\n                    // Now perform range tests , as an appends is a possibility here\\n                    // remember this : the append in itself is just the hashmaps left and right too : why not just port that over?\\n                    Wrapper connecteeMeta = rangeInfo.get(fringeNode.val);\\n                    TreeNode connectee = connecteeMeta.node;\\n                    int connecteeMin = connecteeMeta.min;\\n                    int connecteeMax = connecteeMeta.max;\\n                    \\n                    // Not sure about handling -INT_MIN, INT_MAX cases though. A bit lost there in the connection setup\\n                    // Handle as single child or dual child cases instead ( you incorporated flag values 0,50001 for this ) \\n                    // wait a second .. on the fringe, you may have a case where it has a flag as well. Shit\\n                    // If not, early halt with a null root\\n                    if(connecteeMin == 0 && connecteeMax == 50001)\\n                    {\\n                        // Either a left insert or a right inserst case here for a singleton root child :-O\\n                        // So just continue : this passes anyways!\\n                    }    \\n                    else if(connecteeMin == 0)\\n                    {\\n                        // System.out.printf(\"here @ connectee right single child case \\\\n\");\\n                        if(connecteeMax >= fringeMax)\\n                        {\\n                            return null;\\n                        }\\n                    }\\n                    else if ( connecteeMax == 50001)\\n                    {\\n                        if(connecteeMin <= fringeMin)\\n                        {\\n                            return null;\\n                        }\\n                    }\\n                    else\\n                    {\\n                         if (!( fringeMin <= connecteeMin && connecteeMax <= fringeMax ))\\n                         {\\n                            return null;\\n                         }\\n                    }\\n                                          \\n\\n                    // Wrapper fringeMeta = rangeInfo.get(fringeNode.val);\\n                    Wrapper fringeMeta = fringeWrapper;\\n                    fringeNode.left = connectee.left;\\n                    fringeNode.right = connectee.right;\\n                    TreeNode lst = fringeNode.left;\\n                    TreeNode rst = fringeNode.right;    \\n                    // System.out.printf(\"Removing fringe node val from range info = %d\\\\n\", fringeNode.val);\\n                    rangeInfo.remove(fringeNode.val); // we kick this mini BST out cuz it was concatenated here\\n                    \\n                    // Add the new fringe nodes now\\n                    // Update your fringe wrappers too! \\n                    if(lst != null) \\n                    {\\n                        Wrapper lstMeta = new Wrapper();\\n                        lstMeta.node = lst;\\n                        lstMeta.max = fringeNode.val;\\n                        if(fringeMeta.min < lst.val)\\n                            lstMeta.min = Math.max(0, fringeMeta.min);\\n                        else\\n                            lstMeta.min = 0;\\n                        fringe.add(lstMeta);\\n                    }\\n                    if(rst != null)\\n                    {\\n                        Wrapper rstMeta = new Wrapper();\\n                        rstMeta.node = rst;\\n                        rstMeta.min = fringeNode.val;\\n                        if(fringeMeta.max > rst.val)\\n                            rstMeta.max = Math.min(50001, fringeMeta.max);\\n                        else\\n                            rstMeta.max = 50001;\\n                        fringe.add(rstMeta);\\n                    }\\n                    \\n                    // Go update the root node\\'s range information now\\n                    // Note : aways update according to the fringe valies anyways : as the depths represent a property too!\\n                    // Oh but the root might also have a flag too. Be careful!\\n                    // RUN TIME BUG HERE\\n                    Wrapper rootMeta = rangeInfo.get(newRoot.val);\\n                    // Your trip up is taking place here!\\n                    if(connecteeMin != 0)\\n                        rootMeta.min = Math.min(rootMeta.min, connecteeMin);\\n                    if(connecteeMax != 50001)\\n                        rootMeta.max = Math.max(rootMeta.max, connecteeMax);\\n                    \\n                    // Check if we need a new root node now\\n                    if(fringe.isEmpty())\\n                    {\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            // Grow a seperate subtree, as the root set is empty here\\n            // If node in to explore has already been checked : go ahead and skip it.\\n            if(fringe.isEmpty())\\n            {\\n                if(!rootSet.contains(newRoot.val))\\n                {\\n                    rootSet.add(newRoot.val);\\n                }\\n\\n                while(true)\\n                {\\n                    // Incorporate terminating condition into loop logic\\n                    // We have a bug here BTW, as the root set was already added ahead of time. Prevent said add? \\n                    // Also the check is performed at incorrect location possibly? \\n                    if(toExplore.size() == rootSet.size())\\n                    {\\n                        if(rootSet.size() != 1)\\n                        {\\n                            return null;\\n                        }\\n                        return newRoot;               \\n                    }\\n                    TreeNode candidate = toExplore.remove();\\n                    if(candidate == newRoot)\\n                    {\\n                        toExplore.add(candidate);\\n                    }\\n                    else\\n                    {\\n                        if(!rangeInfo.containsKey(candidate.val))\\n                        {\\n                            continue;\\n                        }\\n                        else\\n                        {\\n                            newRoot = candidate;\\n                            toExplore.add(candidate);\\n                            break;\\n                        }\\n                    }\\n                }\\n                // Oh yeah we need a new fringe here too!\\n                // Amend this later on !\\n                if(newRoot.left == null && newRoot.right == null)\\n                {\\n                    fringe.add(rangeInfo.get(newRoot.val));\\n                }\\n                if(newRoot.left != null)\\n                {\\n                    fringe.add(new Wrapper(newRoot.left, 0, newRoot.val));\\n                }\\n                if(newRoot.right != null)\\n                {\\n                    fringe.add(new Wrapper(newRoot.right, newRoot.val, 50001));\\n                }\\n            }\\n        }\\n        if(rootSet.size() != 1)\\n        {\\n            return null;\\n        }\\n        return newRoot;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n/*\\n\\nURL = https://leetcode.com/problems/merge-bsts-to-create-single-bst/ \\n1932. Merge BSTs to Create Single BST\\n\\nLet us leverage the invariant that node values in the node\\'s LST have value STRICTLY LESS than the root\\'s value\\nand nodes in the right subtree have value STRICTLY MORE than node\\'s value\\n\\nNote : we may be able to form \\n\\nHINT : leverage a hashmap\\n    -> store the min values and max values of BSTs ( seen in other problems ) \\n    \\nCOMPLEXITY\\nTime = ___\\nSpace = ___\\n\\nNode vals are known to be positives in range of [1,50000]\\n[[3],[3,1]] is luckily invalid anyways!\\n\\nTEST CASES\\n(A)[[2,1],[3,2,5],[5,4]] \\n(B) [[3],[4,3]]\\n    [4,3] = expected\\n(C)\\n(D)\\n(E)\\n\\nAlso this is a list, so deletion may or may not be possible. But a hashmap conversion also entails alacrity as well\\nNo two roots have same value -> we are in luck here too!\\nReturn null if a root is not able to be ascertained as well.\\nCount number of trees too ( hey you queue root ste handles this ! ) \\n\\n\\nRemember that we must maintain the count of operatinos here too\\n\\nStrategies : Hashtable, Queue, BFS ( Fringe-esque manner ) or DFS ( fringe-esque manner )\\n            I am unsure how binary search could help here though?\\n\\nYou forgot the case where the root may not even possess two children nodes ( e.g. 2L1 )\\nIn this case, we may get an overlap ( e.g. 2R3 )\\nThis is still a valid operation, and the fringe may have involved the root here as well. Exert caution now!\\n\\n*/\\nclass Solution \\n{\\n    \\n    public class Wrapper\\n    {\\n        public TreeNode node;\\n        public int min;\\n        public int max;\\n        \\n        public Wrapper()\\n        {\\n            this.node = null;\\n            min = 0;\\n            max = 50001; // ma of 50,000\\n            // min = Integer.MIN_VALUE;\\n            // max = Integer.MAX_VALUE;\\n        }\\n        \\n        // The \"this\" keyword is really a self-referential pointer in the hiding\\n        public Wrapper(TreeNode node, int min, int max)\\n        {\\n            this.node = node;\\n            this.min = min;\\n            this.max = max;\\n        }\\n    }\\n    \\n    // Range Info hashmap should be based on integers ... NOT on node addresses ( can cause a trip up with fringe analysis : leaf(1) != root(1) case ) \\n    public TreeNode canMerge(List<TreeNode> trees) \\n    {\\n        TreeNode newRoot = null;\\n        List<Wrapper> fringe = new ArrayList<Wrapper>();\\n        Queue<TreeNode> toExplore = new LinkedList<TreeNode>();  // abstract class needs a concrete class instantiation on the RHS\\n        HashMap<Integer, Wrapper> rangeInfo = new HashMap<Integer, Wrapper>();\\n        Set<Integer> rootSet = new HashSet<Integer>();\\n        \\n        if(trees == null || trees.size() == 0)\\n        {\\n            return null;\\n        }\\n        int n = trees.size();\\n        \\n        // [1] Initialize the HASHMAP with initialize range info for all rooted nodes\\n        // [2] In same for loop, add the nodes to the queue as well\\n        for(int i = 0; i < n; ++i)\\n        {\\n            TreeNode cur = trees.get(i);\\n            Wrapper metadata = new Wrapper();\\n            if(cur != null && !rangeInfo.containsKey(cur.val))\\n            {\\n                metadata.node = cur;\\n                if(cur.left != null)\\n                {\\n                    metadata.min = cur.left.val;\\n                }\\n                if(cur.right != null)\\n                {\\n                    metadata.max = cur.right.val;\\n                }\\n                rangeInfo.put(cur.val, metadata);\\n            }\\n            toExplore.add(cur);\\n        }\\n        // toExplore.add(toExplore.poll()); // Just add the first node to the end ( as we are already there anyways ) \\n        // System.out.printf(\"toExplore size = %d\\\\n\", toExplore.size());\\n        \\n        // [3] Initialize the fringe and first root node, along with the root set\\n        // Make sure the fringe itself is properly initialized here : we pass in these values later, depending on direction of add as well\\n        // Oh and make sure the root is part of the fringe set as well : hey we could get a bad case as well\\n        // But the root case begets much caution too ... as this fringe is not guaranteed its emptiness\\n        // One possibility : go fill that up, if possible , and then proceed with the legitimate fringe as expected\\n        // Wait we need not add the root to the fringe -> as the root trees differ, and a fringe must be a leaf\\n        // But what if the root HAS no leaves? \\n        // Well that is a special case indeed. Is in itself a frige at this point\\n        \\n        \\n        newRoot = toExplore.peek();\\n        if(newRoot.left == null && newRoot.right == null)\\n        {\\n            fringe.add(rangeInfo.get(newRoot.val));\\n        }\\n        if(newRoot.left != null)\\n        {\\n            fringe.add(new Wrapper(newRoot.left, 0, newRoot.val));\\n        }\\n        if(newRoot.right != null)\\n        {\\n            fringe.add(new Wrapper(newRoot.right, newRoot.val, 50001));\\n        }\\n        \\n        // [4] The meat of our algorithm here\\n//         List<Wrapper> fringe = new ArrayList<Wrapper>();\\n//         Queue<TreeNode> toExplore = new LinkedList<TreeNode>();  // abstract class needs a concrete class instantiation on the RHS\\n//         HashMap<TreeNode, Wrapper> rangeInfo = new HashMap<TreeNode, Wrapper>();\\n//         Set<TreeNode> rootSet = new HashSet<TreeNode>();\\n        \\n        // Handle null pointer exception later\\n        while(!toExplore.isEmpty())\\n        {\\n            while(!fringe.isEmpty())\\n            {\\n                // If either children are null : well hey, they are infinites too. Leverage that as well.\\n                // System.out.printf(\"Evaluating fringe\\\\n\");\\n                Wrapper fringeWrapper = fringe.remove(0);\\n                TreeNode fringeNode = fringeWrapper.node; \\n                if(fringeNode == newRoot)\\n                {\\n                    // System.out.printf(\"Fringe = new root\\\\n\");\\n                    continue; // ignore this case\\n                }\\n                // Go remove a former root, if we end up adding it anyways!\\n                if(rootSet.contains(fringeNode.val))\\n                {\\n                    // System.out.printf(\"Removing node [%d] from root set\\\\n\", fringeNode.val);\\n                    rootSet.remove(fringeNode.val);\\n                }\\n                int fringeMin = fringeWrapper.min;\\n                int fringeMax = fringeWrapper.max;\\n                if(rangeInfo.containsKey(fringeNode.val))\\n                {\\n                    // Now perform range tests , as an appends is a possibility here\\n                    // remember this : the append in itself is just the hashmaps left and right too : why not just port that over?\\n                    Wrapper connecteeMeta = rangeInfo.get(fringeNode.val);\\n                    TreeNode connectee = connecteeMeta.node;\\n                    int connecteeMin = connecteeMeta.min;\\n                    int connecteeMax = connecteeMeta.max;\\n                    \\n                    // Not sure about handling -INT_MIN, INT_MAX cases though. A bit lost there in the connection setup\\n                    // Handle as single child or dual child cases instead ( you incorporated flag values 0,50001 for this ) \\n                    // wait a second .. on the fringe, you may have a case where it has a flag as well. Shit\\n                    // If not, early halt with a null root\\n                    if(connecteeMin == 0 && connecteeMax == 50001)\\n                    {\\n                        // Either a left insert or a right inserst case here for a singleton root child :-O\\n                        // So just continue : this passes anyways!\\n                    }    \\n                    else if(connecteeMin == 0)\\n                    {\\n                        // System.out.printf(\"here @ connectee right single child case \\\\n\");\\n                        if(connecteeMax >= fringeMax)\\n                        {\\n                            return null;\\n                        }\\n                    }\\n                    else if ( connecteeMax == 50001)\\n                    {\\n                        if(connecteeMin <= fringeMin)\\n                        {\\n                            return null;\\n                        }\\n                    }\\n                    else\\n                    {\\n                         if (!( fringeMin <= connecteeMin && connecteeMax <= fringeMax ))\\n                         {\\n                            return null;\\n                         }\\n                    }\\n                                          \\n\\n                    // Wrapper fringeMeta = rangeInfo.get(fringeNode.val);\\n                    Wrapper fringeMeta = fringeWrapper;\\n                    fringeNode.left = connectee.left;\\n                    fringeNode.right = connectee.right;\\n                    TreeNode lst = fringeNode.left;\\n                    TreeNode rst = fringeNode.right;    \\n                    // System.out.printf(\"Removing fringe node val from range info = %d\\\\n\", fringeNode.val);\\n                    rangeInfo.remove(fringeNode.val); // we kick this mini BST out cuz it was concatenated here\\n                    \\n                    // Add the new fringe nodes now\\n                    // Update your fringe wrappers too! \\n                    if(lst != null) \\n                    {\\n                        Wrapper lstMeta = new Wrapper();\\n                        lstMeta.node = lst;\\n                        lstMeta.max = fringeNode.val;\\n                        if(fringeMeta.min < lst.val)\\n                            lstMeta.min = Math.max(0, fringeMeta.min);\\n                        else\\n                            lstMeta.min = 0;\\n                        fringe.add(lstMeta);\\n                    }\\n                    if(rst != null)\\n                    {\\n                        Wrapper rstMeta = new Wrapper();\\n                        rstMeta.node = rst;\\n                        rstMeta.min = fringeNode.val;\\n                        if(fringeMeta.max > rst.val)\\n                            rstMeta.max = Math.min(50001, fringeMeta.max);\\n                        else\\n                            rstMeta.max = 50001;\\n                        fringe.add(rstMeta);\\n                    }\\n                    \\n                    // Go update the root node\\'s range information now\\n                    // Note : aways update according to the fringe valies anyways : as the depths represent a property too!\\n                    // Oh but the root might also have a flag too. Be careful!\\n                    // RUN TIME BUG HERE\\n                    Wrapper rootMeta = rangeInfo.get(newRoot.val);\\n                    // Your trip up is taking place here!\\n                    if(connecteeMin != 0)\\n                        rootMeta.min = Math.min(rootMeta.min, connecteeMin);\\n                    if(connecteeMax != 50001)\\n                        rootMeta.max = Math.max(rootMeta.max, connecteeMax);\\n                    \\n                    // Check if we need a new root node now\\n                    if(fringe.isEmpty())\\n                    {\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            // Grow a seperate subtree, as the root set is empty here\\n            // If node in to explore has already been checked : go ahead and skip it.\\n            if(fringe.isEmpty())\\n            {\\n                if(!rootSet.contains(newRoot.val))\\n                {\\n                    rootSet.add(newRoot.val);\\n                }\\n\\n                while(true)\\n                {\\n                    // Incorporate terminating condition into loop logic\\n                    // We have a bug here BTW, as the root set was already added ahead of time. Prevent said add? \\n                    // Also the check is performed at incorrect location possibly? \\n                    if(toExplore.size() == rootSet.size())\\n                    {\\n                        if(rootSet.size() != 1)\\n                        {\\n                            return null;\\n                        }\\n                        return newRoot;               \\n                    }\\n                    TreeNode candidate = toExplore.remove();\\n                    if(candidate == newRoot)\\n                    {\\n                        toExplore.add(candidate);\\n                    }\\n                    else\\n                    {\\n                        if(!rangeInfo.containsKey(candidate.val))\\n                        {\\n                            continue;\\n                        }\\n                        else\\n                        {\\n                            newRoot = candidate;\\n                            toExplore.add(candidate);\\n                            break;\\n                        }\\n                    }\\n                }\\n                // Oh yeah we need a new fringe here too!\\n                // Amend this later on !\\n                if(newRoot.left == null && newRoot.right == null)\\n                {\\n                    fringe.add(rangeInfo.get(newRoot.val));\\n                }\\n                if(newRoot.left != null)\\n                {\\n                    fringe.add(new Wrapper(newRoot.left, 0, newRoot.val));\\n                }\\n                if(newRoot.right != null)\\n                {\\n                    fringe.add(new Wrapper(newRoot.right, newRoot.val, 50001));\\n                }\\n            }\\n        }\\n        if(rootSet.size() != 1)\\n        {\\n            return null;\\n        }\\n        return newRoot;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564445,
                "title": "java-easy-solution-0-ms-faster-than-100-00",
                "content": "\\tprivate int sum = 0 ;\\n\\t\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return sum;\\n        if (low == high) return low;\\n\\n        if (low <= root.val && high <= root.val) {\\n            // look up left\\n            if (isInBetween(root, low, high)) sum += root.val;\\n            rangeSumBST(root.left, low, high);\\n\\n        } else if (low >= root.val && high >= root.val){\\n            // look up right\\n            if (isInBetween(root, low, high)) sum += root.val;\\n            rangeSumBST(root.right, low, high);\\n        } else {\\n            // look up all\\n            if (isInBetween(root, low, high)) sum += root.val;\\n            rangeSumBST(root.left, low, high);  rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n    private boolean isInBetween(TreeNode node, int low, int high){\\n        return node != null && node.val >= low && node.val <= high;\\n    }",
                "solutionTags": [],
                "code": "\\tprivate int sum = 0 ;\\n\\t\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return sum;\\n        if (low == high) return low;\\n\\n        if (low <= root.val && high <= root.val) {\\n            // look up left\\n            if (isInBetween(root, low, high)) sum += root.val;\\n            rangeSumBST(root.left, low, high);\\n\\n        } else if (low >= root.val && high >= root.val){\\n            // look up right\\n            if (isInBetween(root, low, high)) sum += root.val;\\n            rangeSumBST(root.right, low, high);\\n        } else {\\n            // look up all\\n            if (isInBetween(root, low, high)) sum += root.val;\\n            rangeSumBST(root.left, low, high);  rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n    private boolean isInBetween(TreeNode node, int low, int high){\\n        return node != null && node.val >= low && node.val <= high;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1561096,
                "title": "javascript-map-and-stack-100-faster",
                "content": "```\\nvar canMerge = function(trees) {\\n    let map = new Map(), leaves = [];\\n\\n    for (const tree of trees)\\n        map.set(tree.val, tree);\\n\\n    var addLeafNodes = (node, lowerBound, upperBound) => {\\n        node.right && leaves.push([node, \"right\", node.val, upperBound]);\\n        node.left && leaves.push([node, \"left\", lowerBound, node.val]);\\n    };\\n    \\n    var dfs = (root, child) =>\\n        root[child] === null ? root.val : dfs(root[child], child);\\n\\n    while (trees.length) {\\n        const cur = map.get(trees.pop().val);\\n        \\n        if (!cur) continue;\\n\\n        addLeafNodes(cur, -50001, 50001);\\n\\n        while (leaves.length) {\\n            const [node, child, lowerBound, upperBound] = leaves.pop();\\n            \\n            if (map.has(node[child].val)) {\\n                const leaf = map.get(node[child].val),\\n                      leftMostVal = dfs(leaf, \"left\"),\\n                      rightMostVal = dfs(leaf, \"right\");\\n\\n                if (upperBound > rightMostVal && lowerBound < leftMostVal) {\\n                    node[child] = leaf;\\n                    addLeafNodes(leaf, lowerBound, upperBound);\\n                    map.delete(leaf.val);\\n                }\\n            }\\n        }\\n    }\\n\\n    return map.size > 1 ? null : [...map][0][1];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar canMerge = function(trees) {\\n    let map = new Map(), leaves = [];\\n\\n    for (const tree of trees)\\n        map.set(tree.val, tree);\\n\\n    var addLeafNodes = (node, lowerBound, upperBound) => {\\n        node.right && leaves.push([node, \"right\", node.val, upperBound]);\\n        node.left && leaves.push([node, \"left\", lowerBound, node.val]);\\n    };\\n    \\n    var dfs = (root, child) =>\\n        root[child] === null ? root.val : dfs(root[child], child);\\n\\n    while (trees.length) {\\n        const cur = map.get(trees.pop().val);\\n        \\n        if (!cur) continue;\\n\\n        addLeafNodes(cur, -50001, 50001);\\n\\n        while (leaves.length) {\\n            const [node, child, lowerBound, upperBound] = leaves.pop();\\n            \\n            if (map.has(node[child].val)) {\\n                const leaf = map.get(node[child].val),\\n                      leftMostVal = dfs(leaf, \"left\"),\\n                      rightMostVal = dfs(leaf, \"right\");\\n\\n                if (upperBound > rightMostVal && lowerBound < leftMostVal) {\\n                    node[child] = leaf;\\n                    addLeafNodes(leaf, lowerBound, upperBound);\\n                    map.delete(leaf.val);\\n                }\\n            }\\n        }\\n    }\\n\\n    return map.size > 1 ? null : [...map][0][1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1474222,
                "title": "sime-easy-to-understand-o-n-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        if(trees.size() == 0)\\n            return NULL;\\n        unordered_map<int, TreeNode*> rootMap;\\n        unordered_set<int> nodeSet;\\n        for(TreeNode* root : trees)\\n        {\\n            nodeSet.insert(root->val);\\n            if(rootMap.find(root->val)!=rootMap.end())\\n                return NULL;\\n            rootMap[root->val] = root;\\n            if(root->left)\\n                nodeSet.insert(root->left->val);\\n            if(root->right)\\n                nodeSet.insert(root->right->val);\\n        }\\n        for(TreeNode* root : trees)\\n        {\\n            if(root->left)\\n            {\\n                if(rootMap.find(root->left->val)!=rootMap.end())\\n                {\\n                    if(rootMap[root->left->val] == NULL)\\n                        return NULL;\\n                    root->left = rootMap[root->left->val];\\n                    rootMap[root->left->val] = NULL;\\n                }\\n            }\\n            if(root->right)\\n            {\\n                if(rootMap.find(root->right->val)!=rootMap.end())\\n                {\\n                    if(rootMap[root->right->val] == NULL)\\n                        return NULL;\\n                    root->right = rootMap[root->right->val];\\n                    rootMap[root->right->val] = NULL;\\n                }\\n            }\\n        }\\n        TreeNode* newRoot = NULL;\\n        for(TreeNode* root : trees)\\n        {\\n            if(rootMap[root->val])\\n            {\\n                if(newRoot)\\n                    return NULL;\\n                newRoot = root;\\n            }\\n        }\\n        if(newRoot == NULL)\\n            return NULL;\\n        if(!verifyBST(newRoot, INT_MIN, INT_MAX))\\n            return NULL;\\n        if(!verifyCount(newRoot, nodeSet))\\n            return NULL;\\n        if(nodeSet.size() >0)\\n            return NULL;\\n        return newRoot;\\n\\n    }\\n    bool verifyBST(TreeNode* root, int mn, int mx)\\n    {\\n        if(root == NULL)\\n            return true;\\n        if(root->val < mn || root->val > mx)\\n            return false;\\n        return verifyBST(root->left, mn, min(mx, root->val)) && verifyBST(root->right, max(mn, root->val), mx);\\n    }\\n\\n    bool verifyCount(TreeNode* root, unordered_set<int>& nodeSet)\\n    {\\n        if(root == NULL)\\n            return true;\\n        if(nodeSet.find(root->val) == nodeSet.end())\\n            return false;\\n        nodeSet.erase(root->val);\\n        return verifyCount(root->left, nodeSet) && verifyCount(root->right, nodeSet);\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        if(trees.size() == 0)\\n            return NULL;\\n        unordered_map<int, TreeNode*> rootMap;\\n        unordered_set<int> nodeSet;\\n        for(TreeNode* root : trees)\\n        {\\n            nodeSet.insert(root->val);\\n            if(rootMap.find(root->val)!=rootMap.end())\\n                return NULL;\\n            rootMap[root->val] = root;\\n            if(root->left)\\n                nodeSet.insert(root->left->val);\\n            if(root->right)\\n                nodeSet.insert(root->right->val);\\n        }\\n        for(TreeNode* root : trees)\\n        {\\n            if(root->left)\\n            {\\n                if(rootMap.find(root->left->val)!=rootMap.end())\\n                {\\n                    if(rootMap[root->left->val] == NULL)\\n                        return NULL;\\n                    root->left = rootMap[root->left->val];\\n                    rootMap[root->left->val] = NULL;\\n                }\\n            }\\n            if(root->right)\\n            {\\n                if(rootMap.find(root->right->val)!=rootMap.end())\\n                {\\n                    if(rootMap[root->right->val] == NULL)\\n                        return NULL;\\n                    root->right = rootMap[root->right->val];\\n                    rootMap[root->right->val] = NULL;\\n                }\\n            }\\n        }\\n        TreeNode* newRoot = NULL;\\n        for(TreeNode* root : trees)\\n        {\\n            if(rootMap[root->val])\\n            {\\n                if(newRoot)\\n                    return NULL;\\n                newRoot = root;\\n            }\\n        }\\n        if(newRoot == NULL)\\n            return NULL;\\n        if(!verifyBST(newRoot, INT_MIN, INT_MAX))\\n            return NULL;\\n        if(!verifyCount(newRoot, nodeSet))\\n            return NULL;\\n        if(nodeSet.size() >0)\\n            return NULL;\\n        return newRoot;\\n\\n    }\\n    bool verifyBST(TreeNode* root, int mn, int mx)\\n    {\\n        if(root == NULL)\\n            return true;\\n        if(root->val < mn || root->val > mx)\\n            return false;\\n        return verifyBST(root->left, mn, min(mx, root->val)) && verifyBST(root->right, max(mn, root->val), mx);\\n    }\\n\\n    bool verifyCount(TreeNode* root, unordered_set<int>& nodeSet)\\n    {\\n        if(root == NULL)\\n            return true;\\n        if(nodeSet.find(root->val) == nodeSet.end())\\n            return false;\\n        nodeSet.erase(root->val);\\n        return verifyCount(root->left, nodeSet) && verifyCount(root->right, nodeSet);\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441258,
                "title": "c-greedy-like-solution",
                "content": "```\\nbool compareAffinity(pair<TreeNode*, int> &a, pair<TreeNode*, int> &b){\\n    return (a.second < b.second);\\n}\\n\\nclass Solution {\\n    unordered_map<int, TreeNode*> setOfTrees;\\n    \\n    void dfs(TreeNode* &curr, TreeNode* root){\\n        if(curr == NULL)\\n            return;\\n        \\n        if(curr->left == NULL && curr->right == NULL){\\n            if(setOfTrees.find(curr->val) != setOfTrees.end() && setOfTrees[curr->val] != curr \\n               && setOfTrees[curr->val] != root){\\n                curr = setOfTrees[curr->val];\\n                setOfTrees.erase(curr->val);\\n            }\\n        }\\n        \\n        dfs(curr->left, root);\\n        dfs(curr->right, root);\\n    }\\n    \\n    int leafAffinity(TreeNode* curr){\\n        if(curr == NULL)\\n            return 0;\\n        \\n        if(curr->left == NULL && curr->right == NULL && \\n                setOfTrees.find(curr->val) != setOfTrees.end()){\\n            return 1;\\n        }\\n        \\n        return leafAffinity(curr->left) + leafAffinity(curr->right);\\n    }\\n\\n    bool isBST(TreeNode* node, int min, int max)\\n    {\\n        if (node==NULL)\\n            return true;\\n\\n        if (node->val < min || node->val > max)\\n            return false;\\n\\n        return isBST(node->left, min, node->val-1) && \\n                isBST(node->right, node->val+1, max); \\n    }\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        for(auto t: trees)\\n            setOfTrees[t->val] = t;\\n        \\n        vector<pair<TreeNode*, int>> treesT;\\n        \\n        for(auto t: trees)\\n            treesT.push_back(make_pair(t, leafAffinity(t)));\\n        \\n        sort(treesT.begin(), treesT.end(), compareAffinity);\\n        \\n        for(int i=0; i<treesT.size(); i++){\\n            if(setOfTrees.find(treesT[i].first->val) != setOfTrees.end())\\n                dfs(treesT[i].first, treesT[i].first);\\n        }\\n        \\n        if(setOfTrees.size() > 1)\\n            return NULL;\\n        \\n        if(isBST(setOfTrees.begin()->second, INT_MIN, INT_MAX))\\n            return setOfTrees.begin()->second;\\n        else return NULL;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool compareAffinity(pair<TreeNode*, int> &a, pair<TreeNode*, int> &b){\\n    return (a.second < b.second);\\n}\\n\\nclass Solution {\\n    unordered_map<int, TreeNode*> setOfTrees;\\n    \\n    void dfs(TreeNode* &curr, TreeNode* root){\\n        if(curr == NULL)\\n            return;\\n        \\n        if(curr->left == NULL && curr->right == NULL){\\n            if(setOfTrees.find(curr->val) != setOfTrees.end() && setOfTrees[curr->val] != curr \\n               && setOfTrees[curr->val] != root){\\n                curr = setOfTrees[curr->val];\\n                setOfTrees.erase(curr->val);\\n            }\\n        }\\n        \\n        dfs(curr->left, root);\\n        dfs(curr->right, root);\\n    }\\n    \\n    int leafAffinity(TreeNode* curr){\\n        if(curr == NULL)\\n            return 0;\\n        \\n        if(curr->left == NULL && curr->right == NULL && \\n                setOfTrees.find(curr->val) != setOfTrees.end()){\\n            return 1;\\n        }\\n        \\n        return leafAffinity(curr->left) + leafAffinity(curr->right);\\n    }\\n\\n    bool isBST(TreeNode* node, int min, int max)\\n    {\\n        if (node==NULL)\\n            return true;\\n\\n        if (node->val < min || node->val > max)\\n            return false;\\n\\n        return isBST(node->left, min, node->val-1) && \\n                isBST(node->right, node->val+1, max); \\n    }\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        for(auto t: trees)\\n            setOfTrees[t->val] = t;\\n        \\n        vector<pair<TreeNode*, int>> treesT;\\n        \\n        for(auto t: trees)\\n            treesT.push_back(make_pair(t, leafAffinity(t)));\\n        \\n        sort(treesT.begin(), treesT.end(), compareAffinity);\\n        \\n        for(int i=0; i<treesT.size(); i++){\\n            if(setOfTrees.find(treesT[i].first->val) != setOfTrees.end())\\n                dfs(treesT[i].first, treesT[i].first);\\n        }\\n        \\n        if(setOfTrees.size() > 1)\\n            return NULL;\\n        \\n        if(isBST(setOfTrees.begin()->second, INT_MIN, INT_MAX))\\n            return setOfTrees.begin()->second;\\n        else return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437247,
                "title": "open-only-to-read-approach-tle-473-474-test-case-passed",
                "content": "Problem: https://leetcode.com/problems/merge-bsts-to-create-single-bst/\\nApproach:\\nTime Complexity: O(n)  \\nAuxillary Space: O(n)\\n**Note: This approach was not able to pass all test cases but its optimzation will if you are able to optimize it do let me know. Thank you !** \\nHere first we traverse the trees vector and for each particular bst we try to merge it with another bst which has same root->val equal to one of the leaves value.\\nNow we try to combining the current root leave by new bst by assigning left and right of new root then  we also check for valid bst for its child.\\nIt may be possible that the after merging the new subtree it is not following the property of bst.\\n\\n**Merging:**\\nHere while traversing through a tree we are checking if its current not is not a root of other tree.\\nIf found we assign new root child to current node and mark the node which is merged in merge vector so that we don\\'t process it again and update that root value in mp.\\nWhenever merging is successful we increment counter, as we have valid answer only when all n-1 nodes are merged.\\n\\n**Checking Valid Bst:**\\n* We first assume that our root value can be in between range lower and higher (INT_MIN and INT_MAX for root).\\nThen at each step we check the root value is in range.\\nThen we check this recursively for each child.\\n* For left subtree all the values in it should be less than root value so the lower is equal to INT_MIN but higher is equal to root value.\\n* For right child subtree all the values in it should be more than the root value so the lower is equal to root value and higher is equal to INT_MAX.\\n\\n**Helper datastructures:**\\n* Here one map which store root value and its corresponding index in trees vector. (mp)\\n* A vector is used to track which bst are merged and avoid their processing. (merge)\\n* A counter variable which is used to count the number of bst which are merged. (count)\\n* A bool variable if at any instance if after merging the tree is not following bst property the it should inform this and stop further recursive calls. (flag) \\n\\n**Code:**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    vector<bool> merge;\\n    int count=0;\\n    bool flag=true;\\n    void validBst(int l,int h,TreeNode *root,vector<TreeNode*>&trees)\\n    {\\n        if(!flag) return;\\n        if(!root) return;\\n        //if root val in present in mp then there is another root with same value in trees vector \\n        if(mp.find(root->val)!=mp.end()&&root->left==nullptr&&root->right==nullptr)\\n        {\\n            \\n            int idx=mp[root->val];\\n            TreeNode* temp=trees[idx];\\n            if(temp!=root)// if the bst only contains 1 element i.e root to avoid unneccsary count \\n            {\\n                count++;\\n                root->left=temp->left;\\n                root->right=temp->right;\\n                trees[idx]=root;\\n                merge[idx]=false;\\n            }\\n        }\\n        if(l<root->val&&root->val<h)// checking for valid bst\\n        {\\n            validBst(l,root->val,root->left,trees);\\n            if(!flag) return;\\n            validBst(root->val,h,root->right,trees);\\n            return;\\n        }\\n        flag=false; // if not valid bst\\n        return;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n=trees.size();\\n        merge=vector<bool>(n,true); // to keep track of merge bst\\n        for(int i=0;i<n;i++) // Store index of root->val \\n        {\\n            mp[trees[i]->val]=i;\\n        }\\n        for(int i=0;i<n;i++) //traverse trees vector\\n        {\\n            if(!flag)\\n                break;\\n            if(!merge[i]) continue;// Do not process merged bst\\n            validBst(INT_MIN,INT_MAX,trees[i],trees);\\n        }\\n        if(count+1==n&&flag)// count equal to number of trees merged\\n        {\\n            count=0;\\n            TreeNode * temp;\\n            for(int i=0;i<n;i++)\\n            {// If tree is not merge then it must the root of the main in which other trees are merge\\n                if(merge[i]) {\\n                    temp=trees[i];\\n                    count++;\\n                    if(count>1)// then it means more than one tree is left unmerged\\n                        return nullptr;\\n                    }           \\n            }\\n            return temp;\\n        }\\n        return nullptr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    vector<bool> merge;\\n    int count=0;\\n    bool flag=true;\\n    void validBst(int l,int h,TreeNode *root,vector<TreeNode*>&trees)\\n    {\\n        if(!flag) return;\\n        if(!root) return;\\n        //if root val in present in mp then there is another root with same value in trees vector \\n        if(mp.find(root->val)!=mp.end()&&root->left==nullptr&&root->right==nullptr)\\n        {\\n            \\n            int idx=mp[root->val];\\n            TreeNode* temp=trees[idx];\\n            if(temp!=root)// if the bst only contains 1 element i.e root to avoid unneccsary count \\n            {\\n                count++;\\n                root->left=temp->left;\\n                root->right=temp->right;\\n                trees[idx]=root;\\n                merge[idx]=false;\\n            }\\n        }\\n        if(l<root->val&&root->val<h)// checking for valid bst\\n        {\\n            validBst(l,root->val,root->left,trees);\\n            if(!flag) return;\\n            validBst(root->val,h,root->right,trees);\\n            return;\\n        }\\n        flag=false; // if not valid bst\\n        return;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        int n=trees.size();\\n        merge=vector<bool>(n,true); // to keep track of merge bst\\n        for(int i=0;i<n;i++) // Store index of root->val \\n        {\\n            mp[trees[i]->val]=i;\\n        }\\n        for(int i=0;i<n;i++) //traverse trees vector\\n        {\\n            if(!flag)\\n                break;\\n            if(!merge[i]) continue;// Do not process merged bst\\n            validBst(INT_MIN,INT_MAX,trees[i],trees);\\n        }\\n        if(count+1==n&&flag)// count equal to number of trees merged\\n        {\\n            count=0;\\n            TreeNode * temp;\\n            for(int i=0;i<n;i++)\\n            {// If tree is not merge then it must the root of the main in which other trees are merge\\n                if(merge[i]) {\\n                    temp=trees[i];\\n                    count++;\\n                    if(count>1)// then it means more than one tree is left unmerged\\n                        return nullptr;\\n                    }           \\n            }\\n            return temp;\\n        }\\n        return nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416434,
                "title": "simple-efficient-c-greedy-verification",
                "content": "1) Each of (1-3)-BSTs produced by any valid decomposition of a valid BST is bound to have unique roots and unique children. Therefore, the original BST can be reconstructed by greedily replacing leaves with input/intermediate BSTs.\\n2) Verify that we ended up with one valid BST containing all unique input nodes once.\\n\\nO(bst_count)\\n\\n```\\nclass Solution {\\n    static constexpr int n = 50001;\\n    int counts[n]{};\\n    \\n    bool is_valid(TreeNode *t, int l, int r) {\\n        if (t == nullptr)\\n            return true;\\n        --counts[t->val];\\n        return t->val > l && t->val < r\\n            && is_valid(t->left, l, t->val)\\n            && is_valid(t->right, t->val, r);\\n    }\\n    \\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        TreeNode *roots[n]{}, *root = nullptr;\\n        for (auto *tree : trees) {\\n            roots[tree->val] = tree;\\n            counts[tree->val] = 1;\\n            if (tree->left != nullptr)\\n                counts[tree->left->val] = 1;\\n            if (tree->right != nullptr)\\n                counts[tree->right->val] = 1;\\n        }\\n        for (auto *tree : trees) {\\n            if (tree->left != nullptr && roots[tree->left->val] != nullptr) {\\n                tree->left = roots[tree->left->val];\\n                roots[tree->left->val] = nullptr;\\n            }\\n            if (tree->right != nullptr && roots[tree->right->val] != nullptr) {\\n                tree->right = roots[tree->right->val];\\n                roots[tree->right->val] = nullptr;\\n            }\\n        }\\n        for (int i = 0; i < n; ++i)\\n            if (roots[i] != nullptr) {\\n                if (root != nullptr)\\n                    return nullptr;\\n                root = roots[i];\\n            }\\n        return is_valid(root, 0, n)\\n            && all_of(counts, counts + n, [] (int x) { return x == 0; })\\n            ? root\\n            : nullptr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static constexpr int n = 50001;\\n    int counts[n]{};\\n    \\n    bool is_valid(TreeNode *t, int l, int r) {\\n        if (t == nullptr)\\n            return true;\\n        --counts[t->val];\\n        return t->val > l && t->val < r\\n            && is_valid(t->left, l, t->val)\\n            && is_valid(t->right, t->val, r);\\n    }\\n    \\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        TreeNode *roots[n]{}, *root = nullptr;\\n        for (auto *tree : trees) {\\n            roots[tree->val] = tree;\\n            counts[tree->val] = 1;\\n            if (tree->left != nullptr)\\n                counts[tree->left->val] = 1;\\n            if (tree->right != nullptr)\\n                counts[tree->right->val] = 1;\\n        }\\n        for (auto *tree : trees) {\\n            if (tree->left != nullptr && roots[tree->left->val] != nullptr) {\\n                tree->left = roots[tree->left->val];\\n                roots[tree->left->val] = nullptr;\\n            }\\n            if (tree->right != nullptr && roots[tree->right->val] != nullptr) {\\n                tree->right = roots[tree->right->val];\\n                roots[tree->right->val] = nullptr;\\n            }\\n        }\\n        for (int i = 0; i < n; ++i)\\n            if (roots[i] != nullptr) {\\n                if (root != nullptr)\\n                    return nullptr;\\n                root = roots[i];\\n            }\\n        return is_valid(root, 0, n)\\n            && all_of(counts, counts + n, [] (int x) { return x == 0; })\\n            ? root\\n            : nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414959,
                "title": "python-stack-o-n",
                "content": "it is a good problem on the tree construction.\\nso, this question states that we need to add the root of another tree to the current tree if it have any leaf node whose value is equal to the value of root.\\nthis also tell us that there is only one root that occur once , inorder to make only one bst . if there are more than one root present that occur only once than we can not make the single bst or tree.\\nthe second thing that we want to take care is that if the tree formed has used all the root or not.\\nthe third thing is that the tree formed is valid or not .\\nAPPORACH ->\\nso for taking the care of first case we use two list frequency and the root dict.\\nif the value of the any node is one we will increase the value of unique nodes(a varible that will store it) and take its corrosponding root as  our tree\\'s root that we will return at the end . but if that varible storing the unique root is not equal to 1  then we can not make the single tree.\\nfor the second case we will use the varible that will have the number of roots , and decrement the count by 1.\\ncode->\\n```\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        def valid(t):\\n            l=[]\\n            def tr (t):\\n                if t!=None:\\n                    tr (t.left)\\n                    l.append(t.val)\\n                    tr (t.right)\\n            tr (t)\\n            # checking the inorder traversal is sorted or not \\n            for i in range(len(l)-1):\\n                if (l[i]<l[i+1]):\\n                    pass\\n                else:\\n                    return False \\n            return True\\n        # f for frequency and d for roots storing\\n        d , f=defaultdict(int), defaultdict(int)\\n        for i in range(len(trees)):\\n            if trees[i]==None:continue\\n            d[trees[i].val] =trees[i]\\n            f[trees[i].val]+=1\\n\\n            if trees[i].left!=None:\\n                f[trees[i].left.val]+=1\\n                \\n            if trees[i].right!=None:\\n                f[trees[i].right.val]+=1\\n        rc=0 # it is for unique root count\\n        mc=len(d) # the number of roots left \\n        l=[]\\n        for i in f.keys():\\n            if f[i]==1 and d[i]!=0:\\n                rc+=1\\n                root=d[i]\\n                d[i]=0\\n                mc-=1\\n        if rc!=1:return None \\n        if root.left!=None:\\n            l.append((root,\"l\",root.left.val))\\n        if root.right !=None:\\n            l.append((root,\"r\",root.right.val))\\n        #single tree formation    \\n        while l:\\n            p,s,va=l.pop()\\n            curr=-1\\n            if d[va]!=0:\\n                if s==\"l\":\\n                    p.left=d[va]\\n                    curr=p.left\\n                    \\n                else:\\n                    p.right =d[va]\\n                    curr=p.right\\n                d[va]=0\\n                mc-=1\\n            if curr==-1:\\n                continue \\n            if curr.left!=None:\\n                l.append((curr,\"l\",curr.left.val))\\n                \\n            if curr.right!=None:\\n                l.append((curr,\"r\",curr.right.val))\\n                \\n        if mc==0 and valid (root):return root\\n        return None \\n                \\n                  \\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        def valid(t):\\n            l=[]\\n            def tr (t):\\n                if t!=None:\\n                    tr (t.left)\\n                    l.append(t.val)\\n                    tr (t.right)\\n            tr (t)\\n            # checking the inorder traversal is sorted or not \\n            for i in range(len(l)-1):\\n                if (l[i]<l[i+1]):\\n                    pass\\n                else:\\n                    return False \\n            return True\\n        # f for frequency and d for roots storing\\n        d , f=defaultdict(int), defaultdict(int)\\n        for i in range(len(trees)):\\n            if trees[i]==None:continue\\n            d[trees[i].val] =trees[i]\\n            f[trees[i].val]+=1\\n\\n            if trees[i].left!=None:\\n                f[trees[i].left.val]+=1\\n                \\n            if trees[i].right!=None:\\n                f[trees[i].right.val]+=1\\n        rc=0 # it is for unique root count\\n        mc=len(d) # the number of roots left \\n        l=[]\\n        for i in f.keys():\\n            if f[i]==1 and d[i]!=0:\\n                rc+=1\\n                root=d[i]\\n                d[i]=0\\n                mc-=1\\n        if rc!=1:return None \\n        if root.left!=None:\\n            l.append((root,\"l\",root.left.val))\\n        if root.right !=None:\\n            l.append((root,\"r\",root.right.val))\\n        #single tree formation    \\n        while l:\\n            p,s,va=l.pop()\\n            curr=-1\\n            if d[va]!=0:\\n                if s==\"l\":\\n                    p.left=d[va]\\n                    curr=p.left\\n                    \\n                else:\\n                    p.right =d[va]\\n                    curr=p.right\\n                d[va]=0\\n                mc-=1\\n            if curr==-1:\\n                continue \\n            if curr.left!=None:\\n                l.append((curr,\"l\",curr.left.val))\\n                \\n            if curr.right!=None:\\n                l.append((curr,\"r\",curr.right.val))\\n                \\n        if mc==0 and valid (root):return root\\n        return None \\n                \\n                  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410066,
                "title": "python3-recursive-tree-building-solution",
                "content": "```\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        roots, leaves, loners, n = {}, {}, set(), len(trees)\\n        if n == 1:\\n            return trees[0]\\n        for tree in trees:\\n            if not tree.left and not tree.right:\\n                loners.add(tree.val)\\n                continue\\n            roots[tree.val] = tree\\n            for node in [tree.left, tree.right]:\\n                if node:\\n                    if node.val in leaves:\\n                        return None\\n                    leaves[node.val] = node\\n                \\n        for loner in loners:\\n            if loner not in leaves and loner not in roots:\\n                return None\\n            \\n        orphan = None\\n        for val, tree in roots.items():\\n            if val not in leaves:\\n                if orphan:\\n                    return None\\n                orphan = tree\\n        if not orphan:\\n            return None\\n        \\n        def build(node, small, big):\\n            nonlocal roots\\n            if not node:\\n                return True\\n            if small >= node.val or node.val >= big:\\n                return False\\n            \\n            if node.val in roots:\\n                node.left, node.right = roots[node.val].left, roots[node.val].right\\n                del roots[node.val]\\n            return build(node.left, small, node.val) and build(node.right, node.val, big)\\n        del roots[orphan.val]\\n        result = build(orphan.left, -inf, orphan.val) and build(orphan.right, orphan.val, inf)\\n        return orphan if result and not roots.keys() else None\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        roots, leaves, loners, n = {}, {}, set(), len(trees)\\n        if n == 1:\\n            return trees[0]\\n        for tree in trees:\\n            if not tree.left and not tree.right:\\n                loners.add(tree.val)\\n                continue\\n            roots[tree.val] = tree\\n            for node in [tree.left, tree.right]:\\n                if node:\\n                    if node.val in leaves:\\n                        return None\\n                    leaves[node.val] = node\\n                \\n        for loner in loners:\\n            if loner not in leaves and loner not in roots:\\n                return None\\n            \\n        orphan = None\\n        for val, tree in roots.items():\\n            if val not in leaves:\\n                if orphan:\\n                    return None\\n                orphan = tree\\n        if not orphan:\\n            return None\\n        \\n        def build(node, small, big):\\n            nonlocal roots\\n            if not node:\\n                return True\\n            if small >= node.val or node.val >= big:\\n                return False\\n            \\n            if node.val in roots:\\n                node.left, node.right = roots[node.val].left, roots[node.val].right\\n                del roots[node.val]\\n            return build(node.left, small, node.val) and build(node.right, node.val, big)\\n        del roots[orphan.val]\\n        result = build(orphan.left, -inf, orphan.val) and build(orphan.right, orphan.val, inf)\\n        return orphan if result and not roots.keys() else None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345851,
                "title": "python-using-dictionaries-easy-to-understand",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nimport collections\\ndef inorder(root, par, treeNode):\\n    if root==None:\\n        return []\\n    l = inorder(root.left, root, treeNode)\\n    r = inorder(root.right, root, treeNode)\\n    if len(l)==0 and len(r)==0:\\n        return [(root.val, treeNode, par, True)]\\n    return l+[(root.val, treeNode, par, False)]+r\\n\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        if len(trees)==1:\\n            return trees[0]\\n        leafToNode = {}\\n        minMaxVal = {}\\n        rootToLeaf = collections.defaultdict(list)\\n        for t in trees:\\n            x = inorder(t, None, t)\\n            for a, b, c, d in x:\\n                if d and c!=None:\\n                    if a in leafToNode:\\n                        return None\\n                    leafToNode[a] = [b, c]\\n                    rootToLeaf[t].append(a)\\n            minMaxVal[t] = [x[0][0], x[-1][0]]\\n        ans = None\\n        for t in trees:\\n            if t.val in leafToNode:\\n                treeNode, par = leafToNode[t.val]\\n                if t.val<par.val:\\n                    if minMaxVal[t][1]>=par.val:\\n                        return None\\n                    else:\\n                        par.left = t\\n                else:\\n                    if minMaxVal[t][0]<=par.val:\\n                        return None\\n                    else:\\n                        par.right = t\\n                if t.val>treeNode.val:\\n                    if minMaxVal[t][0]<=treeNode.val: return None\\n                    minMaxVal[treeNode][1] = max(minMaxVal[t][1], minMaxVal[treeNode][1])\\n                else:\\n                    if minMaxVal[t][1]>=treeNode.val: return None\\n                    minMaxVal[treeNode][0] = min(minMaxVal[t][0], minMaxVal[treeNode][0])\\n                for leaf in rootToLeaf[t]:\\n                    if leaf in leafToNode:\\n                        leafToNode[leaf][0] = treeNode\\n                del leafToNode[t.val]\\n            elif ans==None:\\n                ans = t\\n            else:\\n                return None\\n        return ans\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        if len(trees)==1:\\n            return trees[0]\\n        leafToNode = {}",
                "codeTag": "Java"
            },
            {
                "id": 1344093,
                "title": "slower-but-simpler-we-can-do-naive-merging-and-compare-with-sorting",
                "content": "If BSTs can be merged, it will end up being a valid BST, which means that we can do a in-order traversal to get the sorted elements.\\nTherefore, we can simply try our best to merge, and see if the final in-order traversal result matches the sorted values.\\n\\n- With a valid final BST, all the values will be unique.\\n- We still need to implement merging correctly, but we don\\'t have to maitain extra info during merging, e.g. the min_left value of a node.\\n- Since we do extra sorting, the time complexity will be O(NlgN) instead of O(N).\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void merge(TreeNode *child, unordered_map<int, TreeNode*> &roots) {\\n        if (!child)\\n            return;\\n        if (roots.count(child->val) == 0)\\n            return;\\n        TreeNode *r = roots[child->val];\\n        child->left = r->left;\\n        child->right = r->right;\\n        roots.erase(child->val);\\n        merge(r->left, roots);\\n        merge(r->right, roots);\\n    }\\n\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, TreeNode*> roots;\\n        unordered_map<int, int> cnt;\\n        for (auto &t : trees) {\\n            roots[t->val] = t;\\n            ++cnt[t->val];\\n            ++cnt[t->left ? t->left->val : 0];\\n            ++cnt[t->right ? t->right->val : 0];\\n        }\\n        TreeNode *ans = nullptr;\\n        for (auto &t : trees) {\\n            if (cnt[t->val] == 1) {\\n                roots.erase(t->val);\\n                merge(t->left, roots);\\n                merge(t->right, roots);\\n                ans = t;\\n                break;\\n            }\\n        }\\n        if (!ans)\\n            return nullptr;\\n\\n        vector<int> trav;\\n        traverse(ans, trav);\\n        set<int> uniqs;\\n        for (auto &t : trees) {\\n            uniqs.insert(t->val);\\n            if (t->left) uniqs.insert(t->left->val);\\n            if (t->right) uniqs.insert(t->right->val);\\n        }\\n        vector<int> uniq_vec(uniqs.begin(), uniqs.end());\\n        std::sort(uniq_vec.begin(), uniq_vec.end());\\n        if (trav != uniq_vec)\\n            return nullptr;\\n\\n        return ans;\\n    }\\n    void traverse(TreeNode *r, vector<int> &v) {\\n        if (r->left)\\n            traverse(r->left, v);\\n        v.push_back(r->val);\\n        if (r->right)\\n            traverse(r->right, v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void merge(TreeNode *child, unordered_map<int, TreeNode*> &roots) {\\n        if (!child)\\n            return;\\n        if (roots.count(child->val) == 0)\\n            return;\\n        TreeNode *r = roots[child->val];\\n        child->left = r->left;\\n        child->right = r->right;\\n        roots.erase(child->val);\\n        merge(r->left, roots);\\n        merge(r->right, roots);\\n    }\\n\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, TreeNode*> roots;\\n        unordered_map<int, int> cnt;\\n        for (auto &t : trees) {\\n            roots[t->val] = t;\\n            ++cnt[t->val];\\n            ++cnt[t->left ? t->left->val : 0];\\n            ++cnt[t->right ? t->right->val : 0];\\n        }\\n        TreeNode *ans = nullptr;\\n        for (auto &t : trees) {\\n            if (cnt[t->val] == 1) {\\n                roots.erase(t->val);\\n                merge(t->left, roots);\\n                merge(t->right, roots);\\n                ans = t;\\n                break;\\n            }\\n        }\\n        if (!ans)\\n            return nullptr;\\n\\n        vector<int> trav;\\n        traverse(ans, trav);\\n        set<int> uniqs;\\n        for (auto &t : trees) {\\n            uniqs.insert(t->val);\\n            if (t->left) uniqs.insert(t->left->val);\\n            if (t->right) uniqs.insert(t->right->val);\\n        }\\n        vector<int> uniq_vec(uniqs.begin(), uniqs.end());\\n        std::sort(uniq_vec.begin(), uniq_vec.end());\\n        if (trav != uniq_vec)\\n            return nullptr;\\n\\n        return ans;\\n    }\\n    void traverse(TreeNode *r, vector<int> &v) {\\n        if (r->left)\\n            traverse(r->left, v);\\n        v.push_back(r->val);\\n        if (r->right)\\n            traverse(r->right, v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339875,
                "title": "c-1932-merge-bsts-to-create-single-bst",
                "content": "\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, int> freq; \\n        stack<TreeNode*> stk; \\n        \\n        for (auto& tree : trees) {\\n            stk.push(tree); \\n            while (stk.size()) {\\n                TreeNode* node = stk.top(); stk.pop(); \\n                if (node) {\\n                    ++freq[node->val]; \\n                    stk.push(node->left); \\n                    stk.push(node->right); \\n                }\\n            }\\n        }\\n        \\n        int cnt = 0; \\n        TreeNode* root = NULL; \\n        unordered_map<int, TreeNode*> mp; \\n        \\n        for (auto& tree : trees) {\\n            mp[tree->val] = tree; \\n            if (freq[tree->val] & 1) {\\n                ++cnt; \\n                root = tree; \\n            }\\n        }\\n        \\n        if (cnt != 1) return NULL; \\n        \\n        stk.push(root); \\n        int total = trees.size(); \\n        while (stk.size()) {\\n            TreeNode* node = stk.top(); stk.pop(); \\n            if (node->left && !node->left->left && !node->left->right && mp.count(node->left->val)) {\\n                node->left = mp[node->left->val]; \\n                --total; \\n            }\\n            if (node->right && !node->right->left && !node->right->right && mp.count(node->right->val)) {\\n                node->right = mp[node->right->val]; \\n                --total; \\n            }\\n            if (node->left) stk.push(node->left); \\n            if (node->right) stk.push(node->right); \\n        }\\n        \\n        if (total != 1) return NULL; \\n        \\n        int prev = INT_MIN; \\n        TreeNode* node = root; \\n        while (stk.size() || node) {\\n            if (node) {\\n                stk.push(node); \\n                node = node->left; \\n            } else {\\n                node = stk.top(); stk.pop(); \\n                if (prev >= node->val) return NULL; \\n                prev = node->val; \\n                node = node->right; \\n            }\\n        }\\n        return root; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, int> freq; \\n        stack<TreeNode*> stk; \\n        \\n        for (auto& tree : trees) {\\n            stk.push(tree); \\n            while (stk.size()) {\\n                TreeNode* node = stk.top(); stk.pop(); \\n                if (node) {\\n                    ++freq[node->val]; \\n                    stk.push(node->left); \\n                    stk.push(node->right); \\n                }\\n            }\\n        }\\n        \\n        int cnt = 0; \\n        TreeNode* root = NULL; \\n        unordered_map<int, TreeNode*> mp; \\n        \\n        for (auto& tree : trees) {\\n            mp[tree->val] = tree; \\n            if (freq[tree->val] & 1) {\\n                ++cnt; \\n                root = tree; \\n            }\\n        }\\n        \\n        if (cnt != 1) return NULL; \\n        \\n        stk.push(root); \\n        int total = trees.size(); \\n        while (stk.size()) {\\n            TreeNode* node = stk.top(); stk.pop(); \\n            if (node->left && !node->left->left && !node->left->right && mp.count(node->left->val)) {\\n                node->left = mp[node->left->val]; \\n                --total; \\n            }\\n            if (node->right && !node->right->left && !node->right->right && mp.count(node->right->val)) {\\n                node->right = mp[node->right->val]; \\n                --total; \\n            }\\n            if (node->left) stk.push(node->left); \\n            if (node->right) stk.push(node->right); \\n        }\\n        \\n        if (total != 1) return NULL; \\n        \\n        int prev = INT_MIN; \\n        TreeNode* node = root; \\n        while (stk.size() || node) {\\n            if (node) {\\n                stk.push(node); \\n                node = node->left; \\n            } else {\\n                node = stk.top(); stk.pop(); \\n                if (prev >= node->val) return NULL; \\n                prev = node->val; \\n                node = node->right; \\n            }\\n        }\\n        return root; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339448,
                "title": "need-help-on-this-tle",
                "content": "What i am trying to do is map root value to address for easy access. Then, for every root, i dfs to its leaves and try to find if map contains a root with value same as the leaf. If yes, i merge and continue dfs on the updated tree. However, i have noticed in cases like\\n[5,4] [6,5] [7,6] [8,7], my code keeps on iterating the tree on every addition in vain. What can i do to stop it? I read tuts here, but i am having problem grasping them and i am more concerned about the problem of my solution since that is what came in my head. THANKYOU\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    unordered_map<int, TreeNode*> mp;\\n    bool getout=false;\\npublic:\\n    \\n    bool validateBST(TreeNode* root,int min=INT_MIN,int max=INT_MAX)\\n    {\\n        if(!root)\\n            return true;\\n        \\n        return (root->val > min && root->val < max && validateBST(root->left,min,root->val) && validateBST(root->right,root->val,max));\\n    }\\n    bool isLeaf(TreeNode* root)\\n    {\\n        if(!root->left && !root->right)\\n            return true;\\n        return false;\\n    }\\n    void dfs(TreeNode* root,int forbiddenVal)\\n    {\\n        if(!root)\\n            return;\\n        if(root->left && isLeaf(root->left) && forbiddenVal!=root->left->val && mp.find(root->left->val)!=mp.end())\\n        {\\n            auto it = mp.find(root->left->val);\\n            TreeNode *child = root->left,*childHead = it->second;\\n            child->left = childHead->left;\\n            child->right = childHead->right;\\n            mp.erase(it);\\n            \\n        }\\n        dfs(root->left,forbiddenVal);\\n        if(root->right && isLeaf(root->right) && forbiddenVal!=root->right->val && mp.find(root->right->val)!=mp.end())\\n        {\\n            auto it = mp.find(root->right->val);\\n            TreeNode *child = root->right,*childHead = it->second;\\n            child->left = childHead->left;\\n            child->right = childHead->right;\\n            mp.erase(it);\\n        }\\n        dfs(root->right,forbiddenVal);\\n    }\\n    \\n    //MAIN FUNC\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        \\n        \\n        for(int i=0;i<trees.size();i++)\\n        {\\n            mp.insert({trees[i]->val,trees[i]});\\n        }\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            if(mp.find(trees[i]->val)!=mp.end())\\n                dfs(trees[i],trees[i]->val);\\n            //if(!validBST)\\n        }\\n        \\n        if(mp.size()!=1 or !validateBST(mp.begin()->second))\\n            return NULL;\\n        \\n        return mp.begin()->second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    unordered_map<int, TreeNode*> mp;\\n    bool getout=false;\\npublic:\\n    \\n    bool validateBST(TreeNode* root,int min=INT_MIN,int max=INT_MAX)\\n    {\\n        if(!root)\\n            return true;\\n        \\n        return (root->val > min && root->val < max && validateBST(root->left,min,root->val) && validateBST(root->right,root->val,max));\\n    }\\n    bool isLeaf(TreeNode* root)\\n    {\\n        if(!root->left && !root->right)\\n            return true;\\n        return false;\\n    }\\n    void dfs(TreeNode* root,int forbiddenVal)\\n    {\\n        if(!root)\\n            return;\\n        if(root->left && isLeaf(root->left) && forbiddenVal!=root->left->val && mp.find(root->left->val)!=mp.end())\\n        {\\n            auto it = mp.find(root->left->val);\\n            TreeNode *child = root->left,*childHead = it->second;\\n            child->left = childHead->left;\\n            child->right = childHead->right;\\n            mp.erase(it);\\n            \\n        }\\n        dfs(root->left,forbiddenVal);\\n        if(root->right && isLeaf(root->right) && forbiddenVal!=root->right->val && mp.find(root->right->val)!=mp.end())\\n        {\\n            auto it = mp.find(root->right->val);\\n            TreeNode *child = root->right,*childHead = it->second;\\n            child->left = childHead->left;\\n            child->right = childHead->right;\\n            mp.erase(it);\\n        }\\n        dfs(root->right,forbiddenVal);\\n    }\\n    \\n    //MAIN FUNC\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        \\n        \\n        for(int i=0;i<trees.size();i++)\\n        {\\n            mp.insert({trees[i]->val,trees[i]});\\n        }\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            if(mp.find(trees[i]->val)!=mp.end())\\n                dfs(trees[i],trees[i]->val);\\n            //if(!validBST)\\n        }\\n        \\n        if(mp.size()!=1 or !validateBST(mp.begin()->second))\\n            return NULL;\\n        \\n        return mp.begin()->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338716,
                "title": "python3-build-tree-and-check-for-order",
                "content": "\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        freq = defaultdict(int)\\n        for tree in trees: \\n            stack = [tree]\\n            while stack: \\n                x = stack.pop()\\n                if x: \\n                    freq[x.val] += 1\\n                    stack.append(x.left)\\n                    stack.append(x.right)\\n        \\n        cnt, root = 0, None\\n        mp = {}\\n        for tree in trees: \\n            if freq[tree.val] & 1: cnt, root = cnt+1, tree\\n            mp[tree.val] = tree\\n        if cnt != 1: return None \\n        \\n        stack = [(root, None, 0)]\\n        total = len(trees)\\n        while stack: \\n            node, parent, left = stack.pop()\\n            if not node.left and not node.right and node.val in mp: \\n                total -= 1\\n                if not parent: \\n                    if len(trees) > 1: return None \\n                    return root\\n                if left: parent.left = node = mp[node.val]\\n                else: parent.right = node = mp[node.val]\\n            if node.left: stack.append((node.left, node, 1))\\n            if node.right: stack.append((node.right, node, 0))\\n        \\n        if total > 1: return None \\n        \\n        # in-order traversal \\n        prev = -inf\\n        node = root \\n        stack = []\\n        while stack or node: \\n            if node: \\n                stack.append(node)\\n                node = node.left \\n            else: \\n                node = stack.pop()\\n                if prev >= node.val: return None\\n                prev = node.val\\n                node = node.right\\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        freq = defaultdict(int)\\n        for tree in trees: \\n            stack = [tree]\\n            while stack: \\n                x = stack.pop()\\n                if x: \\n                    freq[x.val] += 1\\n                    stack.append(x.left)\\n                    stack.append(x.right)\\n        \\n        cnt, root = 0, None\\n        mp = {}\\n        for tree in trees: \\n            if freq[tree.val] & 1: cnt, root = cnt+1, tree\\n            mp[tree.val] = tree\\n        if cnt != 1: return None \\n        \\n        stack = [(root, None, 0)]\\n        total = len(trees)\\n        while stack: \\n            node, parent, left = stack.pop()\\n            if not node.left and not node.right and node.val in mp: \\n                total -= 1\\n                if not parent: \\n                    if len(trees) > 1: return None \\n                    return root\\n                if left: parent.left = node = mp[node.val]\\n                else: parent.right = node = mp[node.val]\\n            if node.left: stack.append((node.left, node, 1))\\n            if node.right: stack.append((node.right, node, 0))\\n        \\n        if total > 1: return None \\n        \\n        # in-order traversal \\n        prev = -inf\\n        node = root \\n        stack = []\\n        while stack or node: \\n            if node: \\n                stack.append(node)\\n                node = node.left \\n            else: \\n                node = stack.pop()\\n                if prev >= node.val: return None\\n                prev = node.val\\n                node = node.right\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1336378,
                "title": "literally-do-what-it-says-clear-python-solution",
                "content": "Simple solution, but with one small trick.\\n\\nWhat we do is just select a root, then verify it\\'s a BST or not using standard way;\\nIf it can form a BST, we\\'ll construct this BST (you can also construct the BST during verification as we will only verify once).\\nWhen we verify or construct BST, we use a reverse query {root value->tree index} from td to quickly find the corresponding tree.\\nThe trick is how to select the root node.\\n\\nAs mentioned in question, if we want to merge all BST to one BST, all root nodes of small BSTs must **appear twice** (as someone else\\'s leaf node) except one node, this node is the root of merged BST.\\n\\nWe use a counter dict **cnt**, which remembers how many times a node appears, then we just need find the node with cnt[val]==1.\\nLeaf node will also have cnt[val]==1 as it\\'s not someone\\'s parent, but it\\'s not a root node from trees[i].\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        minval=-1\\n        maxval=5*(10**4)+1\\n        td={}\\n        def check_bst(root,curr_set,minv,maxv):\\n            if(root is None):\\n                return True\\n            if(root.val<minv or root.val>maxv):\\n                return False\\n            a1=True\\n            if(root.left is not None):\\n                if(root.left.val not in td):# end of search, finish construct left\\n                    if(root.left.val<minv):\\n                        return False\\n                    else:\\n                        pass\\n                else:\\n                    i = td[root.left.val]\\n                    curr_set.add(i)\\n                    lnode=trees[i]\\n                    root.left=lnode\\n                    a1=check_bst(lnode,curr_set,minv,root.val-1)\\n                \\n            a2=True\\n            if(root.right is not None):\\n                if(root.right.val not in td):\\n                    if(root.right.val>maxv):\\n                        return False\\n                    else:\\n                        pass\\n                else:\\n                    i = td[root.right.val]\\n                    curr_set.add(i)\\n                    rnode=trees[i]\\n                    root.right=rnode\\n                    a2=check_bst(rnode,curr_set,root.val+1,maxv)\\n            if(a1 == True and a2 == True):\\n                return True\\n            return False\\n        cnt={}\\n        for i,tree in enumerate(trees):\\n            val=tree.val\\n            if(val not in cnt):\\n                cnt[val]=0\\n            cnt[val]+=1\\n            \\n            lval=None\\n            rval=None\\n            if(tree.left is not None):\\n                lval=tree.left.val\\n                if(lval not in cnt):\\n                    cnt[lval]=0\\n                cnt[lval]+=1\\n            if(tree.right is not None):\\n                rval=tree.right.val\\n                if(rval not in cnt):\\n                    cnt[rval]=0\\n                cnt[rval]+=1\\n            \\n            td[val]=i\\n        for i,tree in enumerate(trees):\\n            #try trees[i] as root\\n            st=set()\\n            st.add(i)\\n            if(cnt[tree.val]==1):#only one root has count==1, other root count>=2\\n                rslt = check_bst(tree,st,minval,maxval)\\n                if(rslt == True and len(st)==len(trees)):\\n                    #build_bst(tree)\\n                    return tree\\n                else:\\n                    return None\\n        return None\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        minval=-1\\n        maxval=5*(10**4)+1\\n        td={}\\n        def check_bst(root,curr_set,minv,maxv):\\n            if(root is None):\\n                return True\\n            if(root.val<minv or root.val>maxv):\\n                return False\\n            a1=True\\n            if(root.left is not None):\\n                if(root.left.val not in td):# end of search, finish construct left\\n                    if(root.left.val<minv):\\n                        return False\\n                    else:\\n                        pass\\n                else:\\n                    i = td[root.left.val]\\n                    curr_set.add(i)\\n                    lnode=trees[i]\\n                    root.left=lnode\\n                    a1=check_bst(lnode,curr_set,minv,root.val-1)\\n                \\n            a2=True\\n            if(root.right is not None):\\n                if(root.right.val not in td):\\n                    if(root.right.val>maxv):\\n                        return False\\n                    else:\\n                        pass\\n                else:\\n                    i = td[root.right.val]\\n                    curr_set.add(i)\\n                    rnode=trees[i]\\n                    root.right=rnode\\n                    a2=check_bst(rnode,curr_set,root.val+1,maxv)\\n            if(a1 == True and a2 == True):\\n                return True\\n            return False\\n        cnt={}\\n        for i,tree in enumerate(trees):\\n            val=tree.val\\n            if(val not in cnt):\\n                cnt[val]=0\\n            cnt[val]+=1\\n            \\n            lval=None\\n            rval=None\\n            if(tree.left is not None):\\n                lval=tree.left.val\\n                if(lval not in cnt):\\n                    cnt[lval]=0\\n                cnt[lval]+=1\\n            if(tree.right is not None):\\n                rval=tree.right.val\\n                if(rval not in cnt):\\n                    cnt[rval]=0\\n                cnt[rval]+=1\\n            \\n            td[val]=i\\n        for i,tree in enumerate(trees):\\n            #try trees[i] as root\\n            st=set()\\n            st.add(i)\\n            if(cnt[tree.val]==1):#only one root has count==1, other root count>=2\\n                rslt = check_bst(tree,st,minval,maxval)\\n                if(rslt == True and len(st)==len(trees)):\\n                    #build_bst(tree)\\n                    return tree\\n                else:\\n                    return None\\n        return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1336000,
                "title": "wrong-answer",
                "content": "For the input - [[2,null,3],[1,null,3],[3,2]]\\nWhy isn\\'t the following a correct answer - [1,null,3,2,null,null,3] ? It\\'s a valid BST.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1335819,
                "title": "python-stack-99-99",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        # trivial, single BST\\n        if len(trees) == 1:\\n            return trees[0]\\n        # build a dictionary of tree by root\\n        treesByRoot = dict()\\n        # keep track of all leaves\\n        leafSet = set()\\n        # put single nodes root-leaves separately\\n        singles = set()\\n        # sort out all trees populate 3 strucutures above\\n        for root in trees:\\n            if root.left is None and root.right is None:\\n                singles.add(root.val)\\n            else:\\n                treesByRoot[root.val] = root\\n                if root.left is not None:\\n                    if root.left.val in leafSet:\\n                        return None\\n                    leafSet.add(root.left.val)\\n\\n                if root.right is not None:\\n                    if root.right.val in leafSet:\\n                        return None\\n                    leafSet.add(root.right.val)\\n        # any single node must be a leaf somewhere, sanity check\\n        # single tree case was eliminated at the beginning\\n        if not singles.issubset(leafSet):\\n            return None\\n        \\n        # find a root of the resulting tree, must be on leaf anywhere and must be only one such root\\n        resultRoot = None\\n        for root in trees:\\n            if root.val not in leafSet:\\n                if resultRoot is None:\\n                    resultRoot = root\\n                else:\\n                    # second root found, impossible to build a tree\\n                    return None\\n        # no root found, impossible to build a tree\\n        if resultRoot is None:\\n            return None\\n        # remove the tree from the root dic\\n        del treesByRoot[resultRoot.val]\\n        # use a stack to walk down the tree and grow the brachnes as needed\\n        # also keep track of lower/upper bounds to make sure our BST is valid\\n        st = [(resultRoot, -math.inf, math.inf)]\\n        while st:\\n            # get the last subtree\\n            cur, lb, ub = st.pop()\\n            # grow the left branch if possible\\n            if cur.left is not None:\\n                v = cur.left.val\\n                if v <= lb or v >= ub:\\n                    # BST bound violation\\n                    return None\\n                try:\\n                    # grow the left branch if possible\\n                    t = treesByRoot[v]\\n                    del treesByRoot[v]\\n                    cur.left = t\\n                    # put the new branch to the stack, with new upper bound as it grew left\\n                    st.append((t, lb, cur.val))\\n                except KeyError:\\n                    pass\\n            # analogous for the right\\n            if cur.right is not None:\\n                v = cur.right.val\\n                if v <= lb or v >= ub:\\n                    return None\\n                try:\\n                    # grow the right branch if possible\\n                    t = treesByRoot[v]\\n                    del treesByRoot[v]\\n                    cur.right = t\\n                    # put the new branch to the stack, with new upper lower as it grew right\\n                    st.append((t, cur.val, ub))\\n                except KeyError:\\n                    pass\\n                \\n        \\n        # if not all subtrees are used, then no single BST result\\n        if treesByRoot:\\n            return None\\n        else:\\n            return resultRoot\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        # trivial, single BST\\n        if len(trees) == 1:\\n            return trees[0]\\n        # build a dictionary of tree by root\\n        treesByRoot = dict()\\n        # keep track of all leaves\\n        leafSet = set()\\n        # put single nodes root-leaves separately\\n        singles = set()\\n        # sort out all trees populate 3 strucutures above\\n        for root in trees:\\n            if root.left is None and root.right is None:\\n                singles.add(root.val)\\n            else:\\n                treesByRoot[root.val] = root\\n                if root.left is not None:\\n                    if root.left.val in leafSet:\\n                        return None\\n                    leafSet.add(root.left.val)\\n\\n                if root.right is not None:\\n                    if root.right.val in leafSet:\\n                        return None\\n                    leafSet.add(root.right.val)\\n        # any single node must be a leaf somewhere, sanity check\\n        # single tree case was eliminated at the beginning\\n        if not singles.issubset(leafSet):\\n            return None\\n        \\n        # find a root of the resulting tree, must be on leaf anywhere and must be only one such root\\n        resultRoot = None\\n        for root in trees:\\n            if root.val not in leafSet:\\n                if resultRoot is None:\\n                    resultRoot = root\\n                else:\\n                    # second root found, impossible to build a tree\\n                    return None\\n        # no root found, impossible to build a tree\\n        if resultRoot is None:\\n            return None\\n        # remove the tree from the root dic\\n        del treesByRoot[resultRoot.val]\\n        # use a stack to walk down the tree and grow the brachnes as needed\\n        # also keep track of lower/upper bounds to make sure our BST is valid\\n        st = [(resultRoot, -math.inf, math.inf)]\\n        while st:\\n            # get the last subtree\\n            cur, lb, ub = st.pop()\\n            # grow the left branch if possible\\n            if cur.left is not None:\\n                v = cur.left.val\\n                if v <= lb or v >= ub:\\n                    # BST bound violation\\n                    return None\\n                try:\\n                    # grow the left branch if possible\\n                    t = treesByRoot[v]\\n                    del treesByRoot[v]\\n                    cur.left = t\\n                    # put the new branch to the stack, with new upper bound as it grew left\\n                    st.append((t, lb, cur.val))\\n                except KeyError:\\n                    pass\\n            # analogous for the right\\n            if cur.right is not None:\\n                v = cur.right.val\\n                if v <= lb or v >= ub:\\n                    return None\\n                try:\\n                    # grow the right branch if possible\\n                    t = treesByRoot[v]\\n                    del treesByRoot[v]\\n                    cur.right = t\\n                    # put the new branch to the stack, with new upper lower as it grew right\\n                    st.append((t, cur.val, ub))\\n                except KeyError:\\n                    pass\\n                \\n        \\n        # if not all subtrees are used, then no single BST result\\n        if treesByRoot:\\n            return None\\n        else:\\n            return resultRoot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335528,
                "title": "c-solution-but-messy",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int counter=0;\\n    bool isbst(TreeNode* root, int maxi, int mini){\\n        if(root==nullptr) return true;\\n        counter++;\\n        if(root->val> maxi || root->val < mini) return false;\\n        \\n        \\n        bool ans= isbst(root->left, root->val, mini) && isbst(root->right, maxi,root->val);\\n        return ans;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        \\n        unordered_map<int,pair<int ,TreeNode*> > mp;  //left, right node map\\n        unordered_map<int,int> mp2; //to count unique nodes so that we can check at the end the size of bst returned by ans\\n        int total=0;\\n        for(int i=0;i<trees.size();i++){\\n            if(trees[i]!=nullptr){\\n                if(mp2[trees[i]->val]==0) total++;\\n                mp2[trees[i]->val]=1; //help in counting unique nodes\\n                if(trees[i]->left){\\n                    if(mp2[trees[i]->left->val]==0) total++;\\n                    mp2[trees[i]->left->val]=1;\\n                    if(mp[trees[i]->left->val].first!=0){\\n                        return nullptr; //if already exist in map return nullptr\\n                    }\\n                    mp[trees[i]->left->val].first=1;\\n                    mp[trees[i]->left->val].second=trees[i];\\n                    \\n                    if( mp[trees[i]->val].first!=0 && mp[trees[i]->val].second->val ==trees[i]->left->val) return nullptr; //checks whether there is a loop ((null,1,3), (3,1,null),(2,4)) type loop\\n                }\\n                if(trees[i]->right){\\n                    if(mp2[trees[i]->right->val]==0) total++;\\n                    mp2[trees[i]->right->val]=1;\\n                    \\n                    if(mp[trees[i]->right->val].first!=0){\\n                        return nullptr;\\n                    }\\n                    mp[trees[i]->right->val].first=2;\\n                    mp[trees[i]->right->val].second=trees[i];\\n                    \\n                    if( mp[trees[i]->val].first!=0 && mp[trees[i]->val].second->val ==trees[i]->right->val) return nullptr;\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        int cont=0;\\n\\n        TreeNode* ans=nullptr;\\n        for(int i=0;i<trees.size(); i++){\\n            if(mp[trees[i]->val].first==0){\\n                ans=trees[i];\\n                cont++;\\n            }\\n            else if(mp[trees[i]->val].first==1){\\n                mp[trees[i]->val].second->left=trees[i];\\n                mp[trees[i]->val].first=0;\\n            }\\n            else if(mp[trees[i]->val].first==2){\\n                mp[trees[i]->val].second->right=trees[i];\\n                 mp[trees[i]->val].first=0;\\n            }\\n            \\n            if(cont>=2) return nullptr;\\n        }\\n        \\n        if(isbst(ans,500000,-1)){\\n            if(total!=counter) return nullptr;\\n                return ans;\\n        } \\n        \\n        \\n        return nullptr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int counter=0;\\n    bool isbst(TreeNode* root, int maxi, int mini){\\n        if(root==nullptr) return true;\\n        counter++;\\n        if(root->val> maxi || root->val < mini) return false;\\n        \\n        \\n        bool ans= isbst(root->left, root->val, mini) && isbst(root->right, maxi,root->val);\\n        return ans;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        \\n        unordered_map<int,pair<int ,TreeNode*> > mp;  //left, right node map\\n        unordered_map<int,int> mp2; //to count unique nodes so that we can check at the end the size of bst returned by ans\\n        int total=0;\\n        for(int i=0;i<trees.size();i++){\\n            if(trees[i]!=nullptr){\\n                if(mp2[trees[i]->val]==0) total++;\\n                mp2[trees[i]->val]=1; //help in counting unique nodes\\n                if(trees[i]->left){\\n                    if(mp2[trees[i]->left->val]==0) total++;\\n                    mp2[trees[i]->left->val]=1;\\n                    if(mp[trees[i]->left->val].first!=0){\\n                        return nullptr; //if already exist in map return nullptr\\n                    }\\n                    mp[trees[i]->left->val].first=1;\\n                    mp[trees[i]->left->val].second=trees[i];\\n                    \\n                    if( mp[trees[i]->val].first!=0 && mp[trees[i]->val].second->val ==trees[i]->left->val) return nullptr; //checks whether there is a loop ((null,1,3), (3,1,null),(2,4)) type loop\\n                }\\n                if(trees[i]->right){\\n                    if(mp2[trees[i]->right->val]==0) total++;\\n                    mp2[trees[i]->right->val]=1;\\n                    \\n                    if(mp[trees[i]->right->val].first!=0){\\n                        return nullptr;\\n                    }\\n                    mp[trees[i]->right->val].first=2;\\n                    mp[trees[i]->right->val].second=trees[i];\\n                    \\n                    if( mp[trees[i]->val].first!=0 && mp[trees[i]->val].second->val ==trees[i]->right->val) return nullptr;\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        int cont=0;\\n\\n        TreeNode* ans=nullptr;\\n        for(int i=0;i<trees.size(); i++){\\n            if(mp[trees[i]->val].first==0){\\n                ans=trees[i];\\n                cont++;\\n            }\\n            else if(mp[trees[i]->val].first==1){\\n                mp[trees[i]->val].second->left=trees[i];\\n                mp[trees[i]->val].first=0;\\n            }\\n            else if(mp[trees[i]->val].first==2){\\n                mp[trees[i]->val].second->right=trees[i];\\n                 mp[trees[i]->val].first=0;\\n            }\\n            \\n            if(cont>=2) return nullptr;\\n        }\\n        \\n        if(isbst(ans,500000,-1)){\\n            if(total!=counter) return nullptr;\\n                return ans;\\n        } \\n        \\n        \\n        return nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334278,
                "title": "easy-to-understand-java-solution-bfs-looping",
                "content": "```\\nint prev = Integer.MIN_VALUE;\\n    public boolean isValid(TreeNode root){\\n        if(root != null){\\n            if(!isValid(root.left)) return false;\\n            if(root.val<=prev) return false;\\n            prev=root.val;\\n            return isValid(root.right);\\n        }\\n        return true;\\n    }\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> map = new HashMap<>();\\n        for(TreeNode node:trees)\\n            map.put(node.val, node);\\n        Set<Integer> merged = new HashSet<>(); // If root is already merged with other, can\\'t use that\\n        for(TreeNode node:trees){\\n            if(!merged.contains(node.val)){\\n                Set<Integer> set = new HashSet<>(); // If child is already one of the roots \\n                set.add(node.val);\\n                Queue<TreeNode> queue = new LinkedList<>();\\n                queue.add(node);\\n                while(!queue.isEmpty()){\\n                    TreeNode n = queue.remove();\\n                    if(n.left!=null && map.containsKey(n.left.val) && !set.contains(n.left.val) && !merged.contains(n.left.val)){\\n                        n.left = map.get(n.left.val);\\n                        set.add(n.left.val);\\n                        merged.add(n.left.val);\\n                        queue.add(n.left);\\n                    }\\n                    if(n.right!=null && map.containsKey(n.right.val) && !set.contains(n.right.val) && !merged.contains(n.right.val)){\\n                        n.right=map.get(n.right.val);\\n                        set.add(n.right.val);\\n                        merged.add(n.right.val);\\n                        queue.add(n.right);\\n                    }\\n                }\\n            }\\n        }\\n        int cnt=0;\\n        TreeNode ans=null;\\n        for(TreeNode node:trees){\\n            if(!merged.contains(node.val)){\\n                cnt++;\\n                ans=node;\\n            }\\n            if(cnt>1) return null;\\n        }\\n        System.out.println(cnt);\\n        if(isValid(ans)) return ans;\\n        System.out.println(\"Invalid\");\\n        return null;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nint prev = Integer.MIN_VALUE;\\n    public boolean isValid(TreeNode root){\\n        if(root != null){\\n            if(!isValid(root.left)) return false;\\n            if(root.val<=prev) return false;\\n            prev=root.val;\\n            return isValid(root.right);\\n        }\\n        return true;\\n    }\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> map = new HashMap<>();\\n        for(TreeNode node:trees)\\n            map.put(node.val, node);\\n        Set<Integer> merged = new HashSet<>(); // If root is already merged with other, can\\'t use that\\n        for(TreeNode node:trees){\\n            if(!merged.contains(node.val)){\\n                Set<Integer> set = new HashSet<>(); // If child is already one of the roots \\n                set.add(node.val);\\n                Queue<TreeNode> queue = new LinkedList<>();\\n                queue.add(node);\\n                while(!queue.isEmpty()){\\n                    TreeNode n = queue.remove();\\n                    if(n.left!=null && map.containsKey(n.left.val) && !set.contains(n.left.val) && !merged.contains(n.left.val)){\\n                        n.left = map.get(n.left.val);\\n                        set.add(n.left.val);\\n                        merged.add(n.left.val);\\n                        queue.add(n.left);\\n                    }\\n                    if(n.right!=null && map.containsKey(n.right.val) && !set.contains(n.right.val) && !merged.contains(n.right.val)){\\n                        n.right=map.get(n.right.val);\\n                        set.add(n.right.val);\\n                        merged.add(n.right.val);\\n                        queue.add(n.right);\\n                    }\\n                }\\n            }\\n        }\\n        int cnt=0;\\n        TreeNode ans=null;\\n        for(TreeNode node:trees){\\n            if(!merged.contains(node.val)){\\n                cnt++;\\n                ans=node;\\n            }\\n            if(cnt>1) return null;\\n        }\\n        System.out.println(cnt);\\n        if(isValid(ans)) return ans;\\n        System.out.println(\"Invalid\");\\n        return null;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1334013,
                "title": "easy-java-with-comments-36ms",
                "content": "```\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> mapRoots  = new HashMap<>();\\n        Map<Integer, TreeNode> mapLeaves  = new HashMap<>();\\n        \\n        //check all trees and hashMap all available roots and leaves \\n        for(TreeNode node : trees){\\n            mapRoots.put(node.val, node);\\n            if(node.left != null){\\n                if(mapLeaves.containsKey(node.left.val)) //different nodes can\\'t refer to the same node -> abnormal BST\\n                    return null;\\n                mapLeaves.put(node.left.val, node.left);\\n            }\\n            if(node.right != null){\\n                if(mapLeaves.containsKey(node.right.val)) //different nodes can\\'t refer to the same node -> abnormal BST\\n                    return null;\\n                mapLeaves.put(node.right.val, node.right);\\n            }\\n        }\\n        \\n        TreeNode rootRes = null;\\n        int count = trees.size();\\n        \\n        //find potential root-result of the merged entire tree\\n        //that is node without any references from the parent leaf nodes\\n        for(TreeNode node : trees){\\n            if(!mapLeaves.containsKey(node.val)){ \\n                rootRes = node;\\n                break;\\n            }     \\n        }\\n        \\n        //if there are no nodes like that -> abnormal BST\\n        if(rootRes==null)\\n            return rootRes;\\n          \\n        Queue<TreeNode> q = new LinkedList<>();\\n        \\n        //put root-result leaves into queue\\n        if(rootRes.left != null)\\n            q.offer(rootRes.left);\\n        if(rootRes.right != null)\\n            q.offer(rootRes.right);\\n        count--;\\n        \\n        while(!q.isEmpty()){\\n            //get leaf from the queue and check if there is correponding available root\\n            TreeNode leaf = q.poll();\\n            TreeNode root = mapRoots.get(leaf.val);\\n            if(root != null){\\n                //there is root matched to leaf, so let\\'s merge it\\n                count--;\\n                leaf.left  = root.left;\\n                leaf.right = root.right;\\n                //add new leaves into the queue\\n                if(root.left != null)\\n                    q.offer(root.left);\\n                if(root.right != null)\\n                    q.offer(root.right);\\n            }\\n        }\\n        \\n        prev=0;\\n        //if we have merged all inputed trees and that is valid BST by values, then return rootRes\\n        return count==0 && recSanity(rootRes) ? rootRes : null;\\n    }\\n    \\n    private int prev;\\n    private boolean recSanity(TreeNode node){\\n        if(node==null)\\n            return true;\\n\\n        if(!recSanity(node.left))\\n            return false;\\n\\n        if(prev >= node.val)\\n            return false;\\n        prev = node.val;\\n        \\n        return  recSanity(node.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        Map<Integer, TreeNode> mapRoots  = new HashMap<>();\\n        Map<Integer, TreeNode> mapLeaves  = new HashMap<>();\\n        \\n        //check all trees and hashMap all available roots and leaves \\n        for(TreeNode node : trees){\\n            mapRoots.put(node.val, node);\\n            if(node.left != null){\\n                if(mapLeaves.containsKey(node.left.val)) //different nodes can\\'t refer to the same node -> abnormal BST\\n                    return null;\\n                mapLeaves.put(node.left.val, node.left);\\n            }\\n            if(node.right != null){\\n                if(mapLeaves.containsKey(node.right.val)) //different nodes can\\'t refer to the same node -> abnormal BST\\n                    return null;\\n                mapLeaves.put(node.right.val, node.right);\\n            }\\n        }\\n        \\n        TreeNode rootRes = null;\\n        int count = trees.size();\\n        \\n        //find potential root-result of the merged entire tree\\n        //that is node without any references from the parent leaf nodes\\n        for(TreeNode node : trees){\\n            if(!mapLeaves.containsKey(node.val)){ \\n                rootRes = node;\\n                break;\\n            }     \\n        }\\n        \\n        //if there are no nodes like that -> abnormal BST\\n        if(rootRes==null)\\n            return rootRes;\\n          \\n        Queue<TreeNode> q = new LinkedList<>();\\n        \\n        //put root-result leaves into queue\\n        if(rootRes.left != null)\\n            q.offer(rootRes.left);\\n        if(rootRes.right != null)\\n            q.offer(rootRes.right);\\n        count--;\\n        \\n        while(!q.isEmpty()){\\n            //get leaf from the queue and check if there is correponding available root\\n            TreeNode leaf = q.poll();\\n            TreeNode root = mapRoots.get(leaf.val);\\n            if(root != null){\\n                //there is root matched to leaf, so let\\'s merge it\\n                count--;\\n                leaf.left  = root.left;\\n                leaf.right = root.right;\\n                //add new leaves into the queue\\n                if(root.left != null)\\n                    q.offer(root.left);\\n                if(root.right != null)\\n                    q.offer(root.right);\\n            }\\n        }\\n        \\n        prev=0;\\n        //if we have merged all inputed trees and that is valid BST by values, then return rootRes\\n        return count==0 && recSanity(rootRes) ? rootRes : null;\\n    }\\n    \\n    private int prev;\\n    private boolean recSanity(TreeNode node){\\n        if(node==null)\\n            return true;\\n\\n        if(!recSanity(node.left))\\n            return false;\\n\\n        if(prev >= node.val)\\n            return false;\\n        prev = node.val;\\n        \\n        return  recSanity(node.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333368,
                "title": "python-it-is-not-the-best-solution-but-at-least-easy-to-understand",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        \\n        def isValidBST(root: TreeNode) -> bool:\\n            def recursive(root, minimum, maximum):\\n                if root == None:\\n                    return True\\n                elif minimum < root.val < maximum:\\n                    return recursive(root.left, minimum, root.val) and recursive(root.right, root.val, maximum)\\n                else:\\n                    return False\\n            return recursive(root, float(\"-inf\"), float(\"+inf\"))\\n        \\n        # If two trees have the same values we need to return None because it is not possible to build a bst\\n        trees_values = set()\\n        for tree in trees:\\n            a = [tree.val]\\n            if tree.left != None:\\n                a.append(tree.left.val)\\n            if tree.right != None:\\n                a.append(tree.right.val)\\n            \\n            a.sort()\\n            \\n            if tuple(a) in trees_values:\\n                return None\\n            else:\\n                trees_values.add(tuple(a))\\n        \\n        # Obtain the children\\n        children = {}\\n        for i, tree in enumerate(trees):\\n            if tree.left != None:\\n                if tree.left.val in children:\\n                    return None\\n                else:\\n                    children[tree.left.val] = [\"l\", i]\\n            \\n            if tree.right != None:\\n                if tree.right.val in children:\\n                    return None\\n                else:\\n                    children[tree.right.val] = [\"r\", i]\\n        \\n        # Swap childrens with roots of other trees\\n        possible_roots = set([i for i in range(len(trees))])\\n        for i, tree in enumerate(trees):\\n            if tree.val in children:\\n                p, index = children[tree.val]\\n                if p == \"l\":\\n                    trees[index].left = tree\\n                else:\\n                    trees[index].right = tree\\n                \\n                # The root that we are checking can\\'t be our root\\n                possible_roots.remove(i)\\n                \\n        \\n        # There can be only a unique solution\\n        if len(possible_roots) == 1:\\n            index = possible_roots.pop()\\n            # Check if BST\\n            if isValidBST(trees[index]):\\n                return trees[index]\\n            \\n        return None\\n        \\n                \\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        \\n        def isValidBST(root: TreeNode) -> bool:\\n            def recursive(root, minimum, maximum):\\n                if root == None:\\n                    return True\\n                elif minimum < root.val < maximum:\\n                    return recursive(root.left, minimum, root.val) and recursive(root.right, root.val, maximum)\\n                else:\\n                    return False\\n            return recursive(root, float(\"-inf\"), float(\"+inf\"))\\n        \\n        # If two trees have the same values we need to return None because it is not possible to build a bst\\n        trees_values = set()\\n        for tree in trees:\\n            a = [tree.val]\\n            if tree.left != None:\\n                a.append(tree.left.val)\\n            if tree.right != None:\\n                a.append(tree.right.val)\\n            \\n            a.sort()\\n            \\n            if tuple(a) in trees_values:\\n                return None\\n            else:\\n                trees_values.add(tuple(a))\\n        \\n        # Obtain the children\\n        children = {}\\n        for i, tree in enumerate(trees):\\n            if tree.left != None:\\n                if tree.left.val in children:\\n                    return None\\n                else:\\n                    children[tree.left.val] = [\"l\", i]\\n            \\n            if tree.right != None:\\n                if tree.right.val in children:\\n                    return None\\n                else:\\n                    children[tree.right.val] = [\"r\", i]\\n        \\n        # Swap childrens with roots of other trees\\n        possible_roots = set([i for i in range(len(trees))])\\n        for i, tree in enumerate(trees):\\n            if tree.val in children:\\n                p, index = children[tree.val]\\n                if p == \"l\":\\n                    trees[index].left = tree\\n                else:\\n                    trees[index].right = tree\\n                \\n                # The root that we are checking can\\'t be our root\\n                possible_roots.remove(i)\\n                \\n        \\n        # There can be only a unique solution\\n        if len(possible_roots) == 1:\\n            index = possible_roots.pop()\\n            # Check if BST\\n            if isValidBST(trees[index]):\\n                return trees[index]\\n            \\n        return None\\n        \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332382,
                "title": "python-3-short-and-simple-with-comments",
                "content": "**Key insight about binary search trees**\\n1) There cannot be repeated values\\n2) We can build a binary seach tree recursively keeping track of the lower bound and upper bound of values while connecting nodes\\n```\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        m = {t.val: t for t in trees}                   # Map of val -> tree that we will extract all nodes from\\n        c = Counter()\\n        for t in trees: \\n            if t.left: c[t.left.val] += 1\\n            if t.right: c[t.right.val] += 1\\n        if any(v > 1 for v in c.values()): return None  # BST has no repeated values\\n        \\n        roots = [t for t in trees if t.val not in c]    # Root value cannot be a leaf value because BST has no repeated values\\n        if len(roots) != 1: return None                 # We can only have one root\\n        root = m.pop(roots[0].val)                      # Remove root from map\\n        \\n        def build(n, lb, rb):                           # Recursive function to build out tree\\n            if (n.left and n.left.val < lb) or (n.right and n.right.val > rb): return False  \\n            if n.left and n.left.val in m: \\n                n.left = m.pop(n.left.val)\\n                if not build(n.left, lb, n.val): return False\\n            if n.right and n.right.val in m: \\n                n.right = m.pop(n.right.val)\\n                if not build(n.right, n.val, rb): return False\\n            return True\\n        \\n        if not build(root, -inf, inf) or m: return None # If build ever returns False or there are still nodes in m, somethings not right\\n        return root",
                "solutionTags": [],
                "code": "class Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        m = {t.val: t for t in trees}",
                "codeTag": "Java"
            },
            {
                "id": 1332164,
                "title": "go-poorly-implemented-answer-verification-causes-correct-solution-to-time-out",
                "content": "I found it took ~4s to verify the correctness of my returned tree for a huge test case, while the actually runtime of my code only took less than a second. As a result, my solution exceeded time limit.\\n\\nHad to translate my Go code to Python to pass all test cases.\\n\\nPlease fix!\\n\\nGo:\\n```go\\nfunc canMerge(trees []*TreeNode) *TreeNode {\\n\\tvalToNode := make(map[int]*TreeNode)\\n\\tvalCounter := make(map[int]int)\\n\\tn := len(trees)\\n\\tops := n - 1 // should take exactly n-1 operations\\n\\n\\tfor _, t := range trees {\\n\\t\\tvalToNode[t.Val] = t\\n\\t\\tvalCounter[t.Val] = 1\\n\\t}\\n\\tfor _, t := range trees {\\n\\t\\tif t.Left != nil {\\n\\t\\t\\tif _, ok := valCounter[t.Left.Val]; ok {\\n\\t\\t\\t\\tvalCounter[t.Left.Val]++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif t.Right != nil {\\n\\t\\t\\tif _, ok := valCounter[t.Right.Val]; ok {\\n\\t\\t\\t\\tvalCounter[t.Right.Val]++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvar root *TreeNode\\n\\tfor val, node := range valToNode {\\n\\t\\tif valCounter[val] == 1 {\\n\\t\\t\\troot = node\\n\\t\\t}\\n\\t}\\n\\n\\tstack := make([]*TreeNode, 0)\\n\\tprev := math.MinInt32\\n\\tnode := root\\n\\tfor node != nil || len(stack) != 0 {\\n\\t\\tfor node != nil {\\n\\t\\t\\tstack = append(stack, node)\\n\\t\\t\\tif node.Left != nil {\\n\\t\\t\\t\\tif child, ok := valToNode[node.Left.Val]; ok {\\n\\t\\t\\t\\t\\tnode.Left = child\\n\\t\\t\\t\\t\\tops--\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.Left\\n\\t\\t}\\n\\t\\tnode = stack[len(stack)-1]\\n\\t\\tstack = stack[:len(stack)-1]\\n\\t\\tif node.Val <= prev {\\n\\t\\t\\treturn nil\\n\\t\\t}\\n\\t\\tprev = node.Val\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tif child, ok := valToNode[node.Right.Val]; ok {\\n\\t\\t\\t\\tnode.Right = child\\n\\t\\t\\t\\tops--\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tnode = node.Right\\n\\t}\\n\\n\\tif ops > 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\treturn root\\n}\\n```\\n\\nPython:\\n```python\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        m = {}\\n        cnt = collections.Counter()\\n        l = len(trees)\\n        ops = l-1\\n        \\n        for t in trees:\\n            m[t.val] = t\\n            cnt[t.val] += 1\\n            \\n        for t in trees:\\n            if t.left:\\n                cnt[t.left.val] += 1\\n            if t.right:\\n                cnt[t.right.val] += 1\\n        \\n        root = None\\n        for k, v in m.items():\\n            if cnt[k] == 1:\\n                root = v\\n        \\n        stack = list()\\n        prev = -2147483648\\n        node = root\\n        while node or len(stack) != 0:\\n            while node:\\n                stack.append(node)\\n                if node.left and node.left.val in m:\\n                    node.left = m[node.left.val]\\n                    ops -= 1\\n                node = node.left\\n            node = stack.pop()\\n            if node.val <= prev:\\n                return None\\n            prev = node.val\\n            if node.right and node.right.val in m:\\n                node.right = m[node.right.val]\\n                ops -= 1\\n            node = node.right\\n                    \\n        if ops > 0:\\n            return None\\n        \\n        return root\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc canMerge(trees []*TreeNode) *TreeNode {\\n\\tvalToNode := make(map[int]*TreeNode)\\n\\tvalCounter := make(map[int]int)\\n\\tn := len(trees)\\n\\tops := n - 1 // should take exactly n-1 operations\\n\\n\\tfor _, t := range trees {\\n\\t\\tvalToNode[t.Val] = t\\n\\t\\tvalCounter[t.Val] = 1\\n\\t}\\n\\tfor _, t := range trees {\\n\\t\\tif t.Left != nil {\\n\\t\\t\\tif _, ok := valCounter[t.Left.Val]; ok {\\n\\t\\t\\t\\tvalCounter[t.Left.Val]++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif t.Right != nil {\\n\\t\\t\\tif _, ok := valCounter[t.Right.Val]; ok {\\n\\t\\t\\t\\tvalCounter[t.Right.Val]++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvar root *TreeNode\\n\\tfor val, node := range valToNode {\\n\\t\\tif valCounter[val] == 1 {\\n\\t\\t\\troot = node\\n\\t\\t}\\n\\t}\\n\\n\\tstack := make([]*TreeNode, 0)\\n\\tprev := math.MinInt32\\n\\tnode := root\\n\\tfor node != nil || len(stack) != 0 {\\n\\t\\tfor node != nil {\\n\\t\\t\\tstack = append(stack, node)\\n\\t\\t\\tif node.Left != nil {\\n\\t\\t\\t\\tif child, ok := valToNode[node.Left.Val]; ok {\\n\\t\\t\\t\\t\\tnode.Left = child\\n\\t\\t\\t\\t\\tops--\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.Left\\n\\t\\t}\\n\\t\\tnode = stack[len(stack)-1]\\n\\t\\tstack = stack[:len(stack)-1]\\n\\t\\tif node.Val <= prev {\\n\\t\\t\\treturn nil\\n\\t\\t}\\n\\t\\tprev = node.Val\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tif child, ok := valToNode[node.Right.Val]; ok {\\n\\t\\t\\t\\tnode.Right = child\\n\\t\\t\\t\\tops--\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tnode = node.Right\\n\\t}\\n\\n\\tif ops > 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\treturn root\\n}\\n```\n```python\\nclass Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        m = {}\\n        cnt = collections.Counter()\\n        l = len(trees)\\n        ops = l-1\\n        \\n        for t in trees:\\n            m[t.val] = t\\n            cnt[t.val] += 1\\n            \\n        for t in trees:\\n            if t.left:\\n                cnt[t.left.val] += 1\\n            if t.right:\\n                cnt[t.right.val] += 1\\n        \\n        root = None\\n        for k, v in m.items():\\n            if cnt[k] == 1:\\n                root = v\\n        \\n        stack = list()\\n        prev = -2147483648\\n        node = root\\n        while node or len(stack) != 0:\\n            while node:\\n                stack.append(node)\\n                if node.left and node.left.val in m:\\n                    node.left = m[node.left.val]\\n                    ops -= 1\\n                node = node.left\\n            node = stack.pop()\\n            if node.val <= prev:\\n                return None\\n            prev = node.val\\n            if node.right and node.right.val in m:\\n                node.right = m[node.right.val]\\n                ops -= 1\\n            node = node.right\\n                    \\n        if ops > 0:\\n            return None\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331256,
                "title": "c-hash-map-commented-code",
                "content": "```\\nclass Solution {\\n    //check if tree is BST or not\\n    bool isvalidBST(TreeNode* root,int mn,int mx){\\n        if(root==nullptr) return true;\\n        if(root->val<=mn || root->val>=mx) return false;\\n        return isvalidBST(root->left,mn,root->val) && isvalidBST(root->right,root->val,mx) ;\\n    }\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,TreeNode*> m1;\\n        vector<int> m2(50001,0);\\n        \\n        // store ptr corresponding to values\\n        // store values cnt, so can take cnt=1 as root;\\n        for(int i=0;i<trees.size();i++){\\n            m1[trees[i]->val]=trees[i];\\n            m2[trees[i]->val]++;\\n            if(trees[i]->left!=nullptr) m2[trees[i]->left->val]++;\\n            if((trees[i]->right!=nullptr)) m2[trees[i]->right->val]++;\\n        }\\n        // find one root such that cnt=1; So, nonode can be merged with this.\\n        TreeNode* root=NULL;\\n        for(int i=0;i<trees.size();i++){\\n            if(m2[trees[i]->val]==1){\\n                root=trees[i];\\n                break;\\n            }\\n        }\\n        \\n        // making Tree\\n        queue<TreeNode*> leaves;\\n        leaves.push(root);\\n        while(!leaves.empty() && !m1.empty()){\\n            // get one leaf on current tree\\n            TreeNode* leaf = leaves.front(); leaves.pop();\\n            auto it= leaf==nullptr?end(m1):m1.find(leaf->val);\\n            \\n            // if we can\\'t attach to it\\n            if(it==end(m1)) continue;\\n            \\n            // add left, right to current tree leaf\\n            leaf->left=it->second->left;\\n            leaf->right=it->second->right;\\n            \\n            // erase used trees\\n            m1.erase(it);\\n            \\n            // put new leaves made in queue \\n            if(leaf->left!=nullptr) leaves.push(leaf->left);\\n            if((leaf->right!=nullptr)) leaves.push(leaf->right);\\n        }\\n        \\n        // check if every root is used and tree made is BST\\n        return (m1.empty() && isvalidBST(root,INT_MIN,INT_MAX))?root:nullptr;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //check if tree is BST or not\\n    bool isvalidBST(TreeNode* root,int mn,int mx){\\n        if(root==nullptr) return true;\\n        if(root->val<=mn || root->val>=mx) return false;\\n        return isvalidBST(root->left,mn,root->val) && isvalidBST(root->right,root->val,mx) ;\\n    }\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,TreeNode*> m1;\\n        vector<int> m2(50001,0);\\n        \\n        // store ptr corresponding to values\\n        // store values cnt, so can take cnt=1 as root;\\n        for(int i=0;i<trees.size();i++){\\n            m1[trees[i]->val]=trees[i];\\n            m2[trees[i]->val]++;\\n            if(trees[i]->left!=nullptr) m2[trees[i]->left->val]++;\\n            if((trees[i]->right!=nullptr)) m2[trees[i]->right->val]++;\\n        }\\n        // find one root such that cnt=1; So, nonode can be merged with this.\\n        TreeNode* root=NULL;\\n        for(int i=0;i<trees.size();i++){\\n            if(m2[trees[i]->val]==1){\\n                root=trees[i];\\n                break;\\n            }\\n        }\\n        \\n        // making Tree\\n        queue<TreeNode*> leaves;\\n        leaves.push(root);\\n        while(!leaves.empty() && !m1.empty()){\\n            // get one leaf on current tree\\n            TreeNode* leaf = leaves.front(); leaves.pop();\\n            auto it= leaf==nullptr?end(m1):m1.find(leaf->val);\\n            \\n            // if we can\\'t attach to it\\n            if(it==end(m1)) continue;\\n            \\n            // add left, right to current tree leaf\\n            leaf->left=it->second->left;\\n            leaf->right=it->second->right;\\n            \\n            // erase used trees\\n            m1.erase(it);\\n            \\n            // put new leaves made in queue \\n            if(leaf->left!=nullptr) leaves.push(leaf->left);\\n            if((leaf->right!=nullptr)) leaves.push(leaf->right);\\n        }\\n        \\n        // check if every root is used and tree made is BST\\n        return (m1.empty() && isvalidBST(root,INT_MIN,INT_MAX))?root:nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330874,
                "title": "c-bottom-up-approach-post-order-traversal-unordered-map",
                "content": "class Solution {\\npublic:\\n\\n    unordered_map<int,TreeNode*> mapping;\\n    bool bst=true;\\n    TreeNode* merge(TreeNode*root,TreeNode*actual_root,int left=INT_MIN,int right=INT_MAX){\\n        if(!root){\\n            return nullptr;\\n        }\\n        if(!bst){\\n            return root;\\n        }\\n        if(root->val<=left or root->val>=right){\\n            bst=false;\\n            return root;\\n        }\\n        root->left=merge(root->left,actual_root,left,root->val);\\n        root->right=merge(root->right,actual_root,root->val,right);\\n        if(!root->left and !root->right){\\n            if(mapping.find(root->val)!=mapping.end() and mapping.at(root->val)!=root and mapping.at(root->val)!=actual_root){\\n                root=mapping[root->val];\\n                mapping.erase(root->val);\\n                return merge(root,actual_root,left,right);\\n            }\\n            \\n        }\\n        return root;\\n    }\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        for(auto&it:trees){\\n            mapping[it->val]=it;\\n        }\\n        TreeNode*ans=nullptr;\\n        for(auto&it:mapping){\\n            merge(it.second,it.second);\\n            ans=it.second;\\n            if(!bst){\\n                return nullptr;\\n            }\\n        }\\n        if(mapping.size()>1){\\n            return nullptr;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    unordered_map<int,TreeNode*> mapping;\\n    bool bst=true;\\n    TreeNode* merge(TreeNode*root,TreeNode*actual_root,int left=INT_MIN,int right=INT_MAX){\\n        if(!root){\\n            return nullptr;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1330811,
                "title": "c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,TreeNode*>mp;\\n        unordered_map<TreeNode*,pair<int,int>>vals;\\n        for(int i=0;i<trees.size();i++){\\n            int right=trees[i]->right==NULL?trees[i]->val:trees[i]->right->val;\\n            int left=trees[i]->left==NULL?trees[i]->val:trees[i]->left->val;\\n            vals[trees[i]]=make_pair(left,right);\\n            \\n            if(trees[i]->left){\\n                mp[trees[i]->left->val]=trees[i];\\n            }\\n            if(trees[i]->right){\\n                mp[trees[i]->right->val]=trees[i];\\n            }\\n        }\\n        bool flag=0;\\n        // int count=0;\\n        TreeNode* root=NULL;\\n        for(int i=0;i<trees.size();i++){\\n            // cout<<trees[i]->val<<endl;\\n            if(mp.find(trees[i]->val)!=mp.end()){\\n                TreeNode* node=mp[trees[i]->val];\\n                if(trees[i]->val<node->val){\\n                    int check=vals[trees[i]].second;\\n                    // cout<<check<<endl;\\n                    if(check<node->val){\\n                        node->left=trees[i];\\n                        vals[node].first=vals[trees[i]].first;\\n                    }\\n                    else return NULL;\\n                }\\n                else{\\n                   int check=vals[trees[i]].first;\\n                    \\n                    if(check>node->val){\\n                        node->right=trees[i];\\n                        vals[node].second=vals[trees[i]].second;\\n                    }\\n                    else return NULL;\\n                }\\n                mp.erase(trees[i]->val);\\n            }\\n            else{\\n                if(flag) return NULL;\\n                else{\\n                    flag=1;\\n                    root=trees[i];\\n                }\\n            }\\n            \\n            \\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int,TreeNode*>mp;\\n        unordered_map<TreeNode*,pair<int,int>>vals;\\n        for(int i=0;i<trees.size();i++){\\n            int right=trees[i]->right==NULL?trees[i]->val:trees[i]->right->val;\\n            int left=trees[i]->left==NULL?trees[i]->val:trees[i]->left->val;\\n            vals[trees[i]]=make_pair(left,right);\\n            \\n            if(trees[i]->left){\\n                mp[trees[i]->left->val]=trees[i];\\n            }\\n            if(trees[i]->right){\\n                mp[trees[i]->right->val]=trees[i];\\n            }\\n        }\\n        bool flag=0;\\n        // int count=0;\\n        TreeNode* root=NULL;\\n        for(int i=0;i<trees.size();i++){\\n            // cout<<trees[i]->val<<endl;\\n            if(mp.find(trees[i]->val)!=mp.end()){\\n                TreeNode* node=mp[trees[i]->val];\\n                if(trees[i]->val<node->val){\\n                    int check=vals[trees[i]].second;\\n                    // cout<<check<<endl;\\n                    if(check<node->val){\\n                        node->left=trees[i];\\n                        vals[node].first=vals[trees[i]].first;\\n                    }\\n                    else return NULL;\\n                }\\n                else{\\n                   int check=vals[trees[i]].first;\\n                    \\n                    if(check>node->val){\\n                        node->right=trees[i];\\n                        vals[node].second=vals[trees[i]].second;\\n                    }\\n                    else return NULL;\\n                }\\n                mp.erase(trees[i]->val);\\n            }\\n            else{\\n                if(flag) return NULL;\\n                else{\\n                    flag=1;\\n                    root=trees[i];\\n                }\\n            }\\n            \\n            \\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1330540,
                "title": "o-n-time-and-space-find-bst-root-and-build-it-recursively-python",
                "content": "### Approach\\nThree main steps:\\n1. All root values should be at leaf of some tree in given trees, except exactly one. This one is the root of the BST we want to build. We can find this BST root with the help of a few map data structures that will take O(n) space.\\n2. Start building the BST recursively from the BST root. Mark the merged trees as deleted, which will also help detect any cycles.\\n3. Check to make sure that all trees except the BST root are marked as deleted and the BST we built is valid.\\n\\n### Time and Space Complexity\\n* `O(n)` time\\n\\t* We have to do a constant number of passes over the given trees list, each pass taking `O(1)` time\\n* `O(n)` space\\n\\t* We use 3 maps and a set each taking `O(n)` space, \\n\\t* We also use `O(n)` stack space to build the BST recursively\\n```\\n            \\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        \\n        val2root = defaultdict()    # to find root tree node from value\\n        rootIndex = defaultdict()   # to find index of a root in trees from value\\n        leaf2root = defaultdict()   # to find tree to replace the leaf with\\n        deleted = set()             # to track deleted tree indices\\n        \\n        # build the data structures\\n        for idx, tree in enumerate(trees):\\n            if tree.left:\\n                leaf2root[tree.left.val] = tree\\n            if tree.right:\\n                leaf2root[tree.right.val] = tree\\n            rootIndex[tree.val] = idx\\n            val2root[tree.val] = tree\\n        \\n        # find the root of the bst to build\\n\\n        bst_root = [tree for tree in trees if tree.val not in leaf2root]\\n        \\n        if not bst_root: return None        # found no bst root\\n        if len(bst_root) > 1: return None   # found more than one bst roots\\n        \\n        def build(node):\\n            assert(node)\\n            # build left if valid\\n            if node.left and node.left.val in val2root:\\n                if rootIndex[node.left.val] in deleted: \\n                    raise Exception(\"cycle\")\\n                node.left = val2root[node.left.val]\\n                deleted.add(rootIndex[node.left.val])\\n                build(node.left)\\n                \\n            # build right if valid\\n            if node.right and node.right.val in val2root:\\n                if rootIndex[node.right.val] in deleted: \\n                    raise Exception(\"cycle\")\\n                node.right = val2root[node.right.val]     \\n                deleted.add(rootIndex[node.right.val])\\n                build(node.right)\\n        \\n        try:\\n            build(bst_root[0])\\n        except:\\n            return None\\n        \\n        def isValidBST(root: TreeNode, minVal = -math.inf, maxVal = math.inf) -> bool:\\n            return not root or minVal < root.val < maxVal and \\\\\\n                    isValidBST(root.left, minVal, root.val) and \\\\\\n                    isValidBST(root.right, root.val, maxVal)\\n    \\n        survivors = sum([1 for i in range(len(trees)) if i not in deleted])\\n        \\n        return bst_root[0] if survivors == 1 and isValidBST(bst_root[0]) else None\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n            \\n    def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n        \\n        val2root = defaultdict()    # to find root tree node from value\\n        rootIndex = defaultdict()   # to find index of a root in trees from value\\n        leaf2root = defaultdict()   # to find tree to replace the leaf with\\n        deleted = set()             # to track deleted tree indices\\n        \\n        # build the data structures\\n        for idx, tree in enumerate(trees):\\n            if tree.left:\\n                leaf2root[tree.left.val] = tree\\n            if tree.right:\\n                leaf2root[tree.right.val] = tree\\n            rootIndex[tree.val] = idx\\n            val2root[tree.val] = tree\\n        \\n        # find the root of the bst to build\\n\\n        bst_root = [tree for tree in trees if tree.val not in leaf2root]\\n        \\n        if not bst_root: return None        # found no bst root\\n        if len(bst_root) > 1: return None   # found more than one bst roots\\n        \\n        def build(node):\\n            assert(node)\\n            # build left if valid\\n            if node.left and node.left.val in val2root:\\n                if rootIndex[node.left.val] in deleted: \\n                    raise Exception(\"cycle\")\\n                node.left = val2root[node.left.val]\\n                deleted.add(rootIndex[node.left.val])\\n                build(node.left)\\n                \\n            # build right if valid\\n            if node.right and node.right.val in val2root:\\n                if rootIndex[node.right.val] in deleted: \\n                    raise Exception(\"cycle\")\\n                node.right = val2root[node.right.val]     \\n                deleted.add(rootIndex[node.right.val])\\n                build(node.right)\\n        \\n        try:\\n            build(bst_root[0])\\n        except:\\n            return None\\n        \\n        def isValidBST(root: TreeNode, minVal = -math.inf, maxVal = math.inf) -> bool:\\n            return not root or minVal < root.val < maxVal and \\\\\\n                    isValidBST(root.left, minVal, root.val) and \\\\\\n                    isValidBST(root.right, root.val, maxVal)\\n    \\n        survivors = sum([1 for i in range(len(trees)) if i not in deleted])\\n        \\n        return bst_root[0] if survivors == 1 and isValidBST(bst_root[0]) else None\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1330363,
                "title": "c-using-map-with-explanation",
                "content": "### Intuition\\nFor true to be valid, following conditions must be true:\\n* tree must have only 1 root.\\n* tree must be BST.\\n* tree must include all the nodes.\\n\\n### Solution\\n- maintain a map with node values to node for all child nodes. This map will help up find parent, given any value.\\n- find root, root won\\'t have any parent.\\n- iterate though the trees and update parent of each tree.\\n- finally validate that root is a bst and contains all nodes.\\n\\n### Complexity\\n- Time:` O(|trees|)`\\n- Space: `O(|trees|)`\\n\\n### Code\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, TreeNode*> child; // child node value to pointer map\\n        // add all child nodes to map\\n        for(auto &tree: trees) {\\n            if (tree->left) {\\n                child[tree->left->val] = tree->left;\\n            }\\n            if (tree->right) {\\n                child[tree->right->val] = tree->right;\\n            }\\n        }\\n        TreeNode* root = NULL;\\n        // parent of tree node is child[tree.val]\\n        // update parent->left as tree->left && parent->right as tree->right\\n        for(auto &tree: trees) {\\n            if (!child.count(tree->val)) { // root node won\\'t be a child\\n                if (root != NULL) { // there can\\'t be 2 root nodes\\n                    return NULL;\\n                }\\n                root = tree;\\n                continue;\\n            }\\n            child[tree->val]->left = tree->left;\\n            child[tree->val]->right = tree->right;\\n        }\\n        if (isValidBST(root, child)) {\\n            return root;\\n        }\\n        return NULL;\\n    }\\n    \\n    // regular BST validation + check if all nodes are visited\\n    // child.size() should contain all nodes except root node\\n    // total visited nodes must equal child.size()+1\\n    bool isValidBST(TreeNode* root, unordered_map<int, TreeNode*>& child) {\\n        int visited = 0;\\n        stack<TreeNode*> s;\\n        long long curMin = INT_MIN;\\n        curMin--;\\n        while(root!=NULL || !s.empty()) {\\n            while(root!=NULL) {\\n                visited++;\\n                s.push(root);\\n                root = root->left;\\n            }\\n            if (curMin >= s.top()->val) {\\n                return false;\\n            }\\n            curMin = s.top()->val;\\n            root = s.top()->right;\\n            s.pop();\\n        }\\n        return visited == child.size()+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        unordered_map<int, TreeNode*> child; // child node value to pointer map\\n        // add all child nodes to map\\n        for(auto &tree: trees) {\\n            if (tree->left) {\\n                child[tree->left->val] = tree->left;\\n            }\\n            if (tree->right) {\\n                child[tree->right->val] = tree->right;\\n            }\\n        }\\n        TreeNode* root = NULL;\\n        // parent of tree node is child[tree.val]\\n        // update parent->left as tree->left && parent->right as tree->right\\n        for(auto &tree: trees) {\\n            if (!child.count(tree->val)) { // root node won\\'t be a child\\n                if (root != NULL) { // there can\\'t be 2 root nodes\\n                    return NULL;\\n                }\\n                root = tree;\\n                continue;\\n            }\\n            child[tree->val]->left = tree->left;\\n            child[tree->val]->right = tree->right;\\n        }\\n        if (isValidBST(root, child)) {\\n            return root;\\n        }\\n        return NULL;\\n    }\\n    \\n    // regular BST validation + check if all nodes are visited\\n    // child.size() should contain all nodes except root node\\n    // total visited nodes must equal child.size()+1\\n    bool isValidBST(TreeNode* root, unordered_map<int, TreeNode*>& child) {\\n        int visited = 0;\\n        stack<TreeNode*> s;\\n        long long curMin = INT_MIN;\\n        curMin--;\\n        while(root!=NULL || !s.empty()) {\\n            while(root!=NULL) {\\n                visited++;\\n                s.push(root);\\n                root = root->left;\\n            }\\n            if (curMin >= s.top()->val) {\\n                return false;\\n            }\\n            curMin = s.top()->val;\\n            root = s.top()->right;\\n            s.pop();\\n        }\\n        return visited == child.size()+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1716619,
                "content": [
                    {
                        "username": "saransh24",
                        "content": " `class Solution {\\nprivate:\\n    void convertInDll(TreeNode* root,TreeNode* &head){\\n        if(!root) return;\\n\\n        convertInDll(root->right,head);\\n        root->right = head;\\n        if(head) head->left = root;\\n        head = root;\\n        convertInDll(root->left,head);\\n    }\\n\\n    TreeNode* mergeDll(TreeNode* l1,TreeNode* l2){\\n        TreeNode* head=NULL;\\n        TreeNode* tail=NULL;\\n\\n        while(l1 && l2){\\n            if(l1->val < l2->val){\\n                if(!head){\\n                    head=l1;\\n                    tail=l1;\\n                    l1=l1->right;\\n                }\\n                else{\\n                    tail->right=l1;\\n                    l1->left=tail;\\n                    tail=l1;\\n                    l1=l1->right;\\n                }\\n            }\\n            else{\\n                if(!head){\\n                    head=l2;\\n                    tail=l2;\\n                    l2=l2->right;\\n                }\\n                else{\\n                    tail->right=l2;\\n                    l2->left=tail;\\n                    tail=l2;\\n                    l2=l2->right;\\n                }\\n            }\\n        }\\n\\n        while(l1){\\n            if(!head){\\n                head=l1;\\n                tail=l1;\\n                l1=l1->right;\\n            }\\n            else{\\n                tail->right=l1;\\n                l1->left=tail;\\n                tail=l1;\\n                l1=l1->right;    \\n            }\\n            \\n        }\\n        while(l2){\\n            if(!head){\\n                head=l2;\\n                tail=l2;\\n                l2=l2->right;\\n            }\\n            else{\\n                tail->right=l2;\\n                l2->left=tail;\\n                tail=l2;\\n                l2=l2->right;\\n            }\\n        }\\n\\n        return head;\\n    }\\n\\n    int count(TreeNode* head){\\n        int n=0;\\n        TreeNode* temp=head;\\n        while(temp){\\n            n++;\\n            temp=temp->right;\\n        }\\n        return n;\\n    }\\n\\n    TreeNode* convertDllToBST(TreeNode* &head,int n){\\n        if(n<=0 || !head) return NULL;\\n\\n        TreeNode* left = convertDllToBST(head,n/2);\\n\\n        TreeNode* root = head;\\n        root->left=left;\\n        head=head->right;\\n\\n        root->right = convertDllToBST(head,n-(n/2)-1);\\n\\n        return root;\\n    }\\n\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        TreeNode* l1=NULL;\\n        int i=0;\\n        // while(i<trees.size() && trees[i]==NULL) i++;\\n        // if(i==trees.size()) return NULL;\\n        while(i<trees.size()){\\n            TreeNode* root = trees[i++];\\n            TreeNode* head=NULL;\\n            convertInDll(root,head);\\n            head->left=NULL;\\n            l1 = mergeDll(l1,head);\\n        }\\n        return convertDllToBST(l1,count(l1));\\n    }\\n};`\\n\\nPlease tell what is wrong in this code"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "If u got this question in a interview, they don\\'t want to hire u."
                    },
                    {
                        "username": "SprihaAnand",
                        "content": "why is the testcase \\n[[6,4],[7,6],[5,null,7]] returning emty array?"
                    }
                ]
            },
            {
                "id": 2003145,
                "content": [
                    {
                        "username": "saransh24",
                        "content": " `class Solution {\\nprivate:\\n    void convertInDll(TreeNode* root,TreeNode* &head){\\n        if(!root) return;\\n\\n        convertInDll(root->right,head);\\n        root->right = head;\\n        if(head) head->left = root;\\n        head = root;\\n        convertInDll(root->left,head);\\n    }\\n\\n    TreeNode* mergeDll(TreeNode* l1,TreeNode* l2){\\n        TreeNode* head=NULL;\\n        TreeNode* tail=NULL;\\n\\n        while(l1 && l2){\\n            if(l1->val < l2->val){\\n                if(!head){\\n                    head=l1;\\n                    tail=l1;\\n                    l1=l1->right;\\n                }\\n                else{\\n                    tail->right=l1;\\n                    l1->left=tail;\\n                    tail=l1;\\n                    l1=l1->right;\\n                }\\n            }\\n            else{\\n                if(!head){\\n                    head=l2;\\n                    tail=l2;\\n                    l2=l2->right;\\n                }\\n                else{\\n                    tail->right=l2;\\n                    l2->left=tail;\\n                    tail=l2;\\n                    l2=l2->right;\\n                }\\n            }\\n        }\\n\\n        while(l1){\\n            if(!head){\\n                head=l1;\\n                tail=l1;\\n                l1=l1->right;\\n            }\\n            else{\\n                tail->right=l1;\\n                l1->left=tail;\\n                tail=l1;\\n                l1=l1->right;    \\n            }\\n            \\n        }\\n        while(l2){\\n            if(!head){\\n                head=l2;\\n                tail=l2;\\n                l2=l2->right;\\n            }\\n            else{\\n                tail->right=l2;\\n                l2->left=tail;\\n                tail=l2;\\n                l2=l2->right;\\n            }\\n        }\\n\\n        return head;\\n    }\\n\\n    int count(TreeNode* head){\\n        int n=0;\\n        TreeNode* temp=head;\\n        while(temp){\\n            n++;\\n            temp=temp->right;\\n        }\\n        return n;\\n    }\\n\\n    TreeNode* convertDllToBST(TreeNode* &head,int n){\\n        if(n<=0 || !head) return NULL;\\n\\n        TreeNode* left = convertDllToBST(head,n/2);\\n\\n        TreeNode* root = head;\\n        root->left=left;\\n        head=head->right;\\n\\n        root->right = convertDllToBST(head,n-(n/2)-1);\\n\\n        return root;\\n    }\\n\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        TreeNode* l1=NULL;\\n        int i=0;\\n        // while(i<trees.size() && trees[i]==NULL) i++;\\n        // if(i==trees.size()) return NULL;\\n        while(i<trees.size()){\\n            TreeNode* root = trees[i++];\\n            TreeNode* head=NULL;\\n            convertInDll(root,head);\\n            head->left=NULL;\\n            l1 = mergeDll(l1,head);\\n        }\\n        return convertDllToBST(l1,count(l1));\\n    }\\n};`\\n\\nPlease tell what is wrong in this code"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "If u got this question in a interview, they don\\'t want to hire u."
                    },
                    {
                        "username": "SprihaAnand",
                        "content": "why is the testcase \\n[[6,4],[7,6],[5,null,7]] returning emty array?"
                    }
                ]
            },
            {
                "id": 2000607,
                "content": [
                    {
                        "username": "saransh24",
                        "content": " `class Solution {\\nprivate:\\n    void convertInDll(TreeNode* root,TreeNode* &head){\\n        if(!root) return;\\n\\n        convertInDll(root->right,head);\\n        root->right = head;\\n        if(head) head->left = root;\\n        head = root;\\n        convertInDll(root->left,head);\\n    }\\n\\n    TreeNode* mergeDll(TreeNode* l1,TreeNode* l2){\\n        TreeNode* head=NULL;\\n        TreeNode* tail=NULL;\\n\\n        while(l1 && l2){\\n            if(l1->val < l2->val){\\n                if(!head){\\n                    head=l1;\\n                    tail=l1;\\n                    l1=l1->right;\\n                }\\n                else{\\n                    tail->right=l1;\\n                    l1->left=tail;\\n                    tail=l1;\\n                    l1=l1->right;\\n                }\\n            }\\n            else{\\n                if(!head){\\n                    head=l2;\\n                    tail=l2;\\n                    l2=l2->right;\\n                }\\n                else{\\n                    tail->right=l2;\\n                    l2->left=tail;\\n                    tail=l2;\\n                    l2=l2->right;\\n                }\\n            }\\n        }\\n\\n        while(l1){\\n            if(!head){\\n                head=l1;\\n                tail=l1;\\n                l1=l1->right;\\n            }\\n            else{\\n                tail->right=l1;\\n                l1->left=tail;\\n                tail=l1;\\n                l1=l1->right;    \\n            }\\n            \\n        }\\n        while(l2){\\n            if(!head){\\n                head=l2;\\n                tail=l2;\\n                l2=l2->right;\\n            }\\n            else{\\n                tail->right=l2;\\n                l2->left=tail;\\n                tail=l2;\\n                l2=l2->right;\\n            }\\n        }\\n\\n        return head;\\n    }\\n\\n    int count(TreeNode* head){\\n        int n=0;\\n        TreeNode* temp=head;\\n        while(temp){\\n            n++;\\n            temp=temp->right;\\n        }\\n        return n;\\n    }\\n\\n    TreeNode* convertDllToBST(TreeNode* &head,int n){\\n        if(n<=0 || !head) return NULL;\\n\\n        TreeNode* left = convertDllToBST(head,n/2);\\n\\n        TreeNode* root = head;\\n        root->left=left;\\n        head=head->right;\\n\\n        root->right = convertDllToBST(head,n-(n/2)-1);\\n\\n        return root;\\n    }\\n\\npublic:\\n    TreeNode* canMerge(vector<TreeNode*>& trees) {\\n        TreeNode* l1=NULL;\\n        int i=0;\\n        // while(i<trees.size() && trees[i]==NULL) i++;\\n        // if(i==trees.size()) return NULL;\\n        while(i<trees.size()){\\n            TreeNode* root = trees[i++];\\n            TreeNode* head=NULL;\\n            convertInDll(root,head);\\n            head->left=NULL;\\n            l1 = mergeDll(l1,head);\\n        }\\n        return convertDllToBST(l1,count(l1));\\n    }\\n};`\\n\\nPlease tell what is wrong in this code"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "If u got this question in a interview, they don\\'t want to hire u."
                    },
                    {
                        "username": "SprihaAnand",
                        "content": "why is the testcase \\n[[6,4],[7,6],[5,null,7]] returning emty array?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Check if String Is Decomposable Into Value-Equal Substrings",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Confirmation Rate",
        "question_content": "<p>Table: <code>Signups</code></p>\n\n<pre>\n+----------------+----------+\n| Column Name    | Type     |\n+----------------+----------+\n| user_id        | int      |\n| time_stamp     | datetime |\n+----------------+----------+\nuser_id is the column of unique values for this table.\nEach row contains information about the signup time for the user with ID user_id.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Confirmations</code></p>\n\n<pre>\n+----------------+----------+\n| Column Name    | Type     |\n+----------------+----------+\n| user_id        | int      |\n| time_stamp     | datetime |\n| action         | ENUM     |\n+----------------+----------+\n(user_id, time_stamp) is the primary key (combination of columns with unique values) for this table.\nuser_id is a foreign key (reference column) to the Signups table.\naction is an ENUM (category) of the type (&#39;confirmed&#39;, &#39;timeout&#39;)\nEach row of this table indicates that the user with ID user_id requested a confirmation message at time_stamp and that confirmation message was either confirmed (&#39;confirmed&#39;) or expired without confirming (&#39;timeout&#39;).\n</pre>\n\n<p>&nbsp;</p>\n\n<p>The <strong>confirmation rate</strong> of a user is the number of <code>&#39;confirmed&#39;</code> messages divided by the total number of requested confirmation messages. The confirmation rate of a user that did not request any confirmation messages is <code>0</code>. Round the confirmation rate to <strong>two decimal</strong> places.</p>\n\n<p>Write a solution to find the <strong>confirmation rate</strong> of each user.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nSignups table:\n+---------+---------------------+\n| user_id | time_stamp          |\n+---------+---------------------+\n| 3       | 2020-03-21 10:16:13 |\n| 7       | 2020-01-04 13:57:59 |\n| 2       | 2020-07-29 23:09:44 |\n| 6       | 2020-12-09 10:39:37 |\n+---------+---------------------+\nConfirmations table:\n+---------+---------------------+-----------+\n| user_id | time_stamp          | action    |\n+---------+---------------------+-----------+\n| 3       | 2021-01-06 03:30:46 | timeout   |\n| 3       | 2021-07-14 14:00:00 | timeout   |\n| 7       | 2021-06-12 11:57:29 | confirmed |\n| 7       | 2021-06-13 12:58:28 | confirmed |\n| 7       | 2021-06-14 13:59:27 | confirmed |\n| 2       | 2021-01-22 00:00:00 | confirmed |\n| 2       | 2021-02-28 23:59:59 | timeout   |\n+---------+---------------------+-----------+\n<strong>Output:</strong> \n+---------+-------------------+\n| user_id | confirmation_rate |\n+---------+-------------------+\n| 6       | 0.00              |\n| 3       | 0.00              |\n| 7       | 1.00              |\n| 2       | 0.50              |\n+---------+-------------------+\n<strong>Explanation:</strong> \nUser 6 did not request any confirmation messages. The confirmation rate is 0.\nUser 3 made 2 requests and both timed out. The confirmation rate is 0.\nUser 7 made 3 requests and all were confirmed. The confirmation rate is 1.\nUser 2 made 2 requests where one was confirmed and the other timed out. The confirmation rate is 1 / 2 = 0.5.\n</pre>\n",
        "solutions": [
            {
                "id": 3563481,
                "title": "92-beats-easy-code-with-explanation-must-read",
                "content": "\\n\\n# Approach\\n- left join `Signups` table with `Confirmations` table group by user_id.\\n- we have to display `user_id` and `confirmation_rate` :\\n1. user_id will be simply displayed.\\n2. to display confirmation_rate , we need to find average using aggregation function avg(), here using if clause we specified that if action is `confirmed` we count it as 1 and else if `null or timeout` we will count it as 0. \\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate\\nfrom Signups as s left join Confirmations as c on s.user_id= c.user_id group by user_id;\\n\\n\\n\\n```\\n# Request\\n**Please upvote if you find it helpful**\\n![meme.png](https://assets.leetcode.com/users/images/647f77b9-8a52-41d1-9fde-104782a9fc5b_1685122990.4751306.png)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate\\nfrom Signups as s left join Confirmations as c on s.user_id= c.user_id group by user_id;\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3580090,
                "title": "attention-coders-step-by-step-explanation-with-optimum-approach-beats-96",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nThe problem asks us to calculate the confirmation rate for each user. The confirmation rate is determined by the number of confirmed actions divided by the total number of actions for each user.\\n# Approach\\n1. We start by selecting the user_id column from the Signups table and calculate the confirmation rate using the AVG function.\\n1. In the calculation of the confirmation rate, we use a conditional statement (IF) to check if the action in the Confirmations table is \\'confirmed\\'. If it is, we assign a value of 1; otherwise, we assign a value of 0.\\n1. We round the calculated average confirmation rate to two decimal places using the ROUND function.\\n1. To associate signups with their respective confirmations, we perform a left join between the Signups and Confirmations tables using the user_id column.\\n1. Finally, we group the results by user_id using the GROUP BY clause to get the confirmation rate for each individual user.\\n# Complexity\\n- Time complexity:\\nThe time complexity of your solution depends on the size of the tables involved and the indexes available. In this case, we need to scan through the tables and perform calculations for each user. Therefore, the time complexity can be considered $$O(N)$$, where N is the total number of rows in the tables.\\n\\n- Space complexity:\\nThe space complexity is determined by the number of distinct user_id values and the size of the result set. As the query processes the data, it needs memory to store the intermediate results during the join and aggregation. So, the space complexity can be considered $$O(M)$$, where M is the number of distinct user_id values.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT s.user_id, \\n  ROUND(AVG(IF(c.action=\\'confirmed\\',1,0)),2) as confirmation_rate \\nFROM Signups s\\nLEFT JOIN Confirmations c using (user_id)\\nGROUP BY s.user_id\\n\\n```\\n\\n***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/e9808694-53da-4edd-9db3-a64e3c4ec816_1685477644.632369.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT s.user_id, \\n  ROUND(AVG(IF(c.action=\\'confirmed\\',1,0)),2) as confirmation_rate \\nFROM Signups s\\nLEFT JOIN Confirmations c using (user_id)\\nGROUP BY s.user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1341952,
                "title": "avg-case-when-for-any-sql",
                "content": "```\\nSELECT \\n  s.user_id,\\n  ROUND(AVG(CASE WHEN action = \\'confirmed\\' THEN 1.00 ELSE 0.00 END),2) AS confirmation_rate\\nFROM Signups s LEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT \\n  s.user_id,\\n  ROUND(AVG(CASE WHEN action = \\'confirmed\\' THEN 1.00 ELSE 0.00 END),2) AS confirmation_rate\\nFROM Signups s LEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3863062,
                "title": "100-easy-fast-clean-solution",
                "content": "IF THIS WILL BE HELPFUL TO YOU, PLEASE UPVOTE !\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT S.user_id, ROUND(AVG(CASE WHEN (C.action=\\'confirmed\\') THEN 1 \\n\\nELSE 0 END),2) AS confirmation_rate FROM Signups S LEFT OUTER JOIN \\n\\nConfirmations C ON S.user_id=C.user_id GROUP BY S.user_id\\n\\n```\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/769071e5-3113-490f-8742-b2a4d76e302d_1691214514.690642.jpeg)\\n\\n",
                "solutionTags": [
                    "Oracle",
                    "Database"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT S.user_id, ROUND(AVG(CASE WHEN (C.action=\\'confirmed\\') THEN 1 \\n\\nELSE 0 END),2) AS confirmation_rate FROM Signups S LEFT OUTER JOIN \\n\\nConfirmations C ON S.user_id=C.user_id GROUP BY S.user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3692519,
                "title": "sum-count-round",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse left join and conditional stmts\\n\\n\\n# Code\\n```\\nselect s.user_id,round(sum(if(c.action=\"confirmed\",1,0)) / count(*),2) \\nas confirmation_rate from Signups s \\nleft join Confirmations c on s.user_id=c.user_id \\ngroup by s.user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s.user_id,round(sum(if(c.action=\"confirmed\",1,0)) / count(*),2) \\nas confirmation_rate from Signups s \\nleft join Confirmations c on s.user_id=c.user_id \\ngroup by s.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1599081,
                "title": "mysql-simple-sum-and-left-join",
                "content": "\\n```\\nselect\\n    s.user_id,\\n    ifnull(round(sum(action=\\'confirmed\\')/sum(action=\\'confirmed\\' or action=\\'timeout\\'), 2), 0) as confirmation_rate\\nfrom signups s\\nleft join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id\\n```",
                "solutionTags": [],
                "code": "```\\nselect\\n    s.user_id,\\n    ifnull(round(sum(action=\\'confirmed\\')/sum(action=\\'confirmed\\' or action=\\'timeout\\'), 2), 0) as confirmation_rate\\nfrom signups s\\nleft join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3558663,
                "title": "clean-implementation-using-left-join-group-by-cast-round",
                "content": "Honestly, this problem took a lot of my time searching the right commands and implementing them. Follow along to understand what I learned during implementation! \\n\\n# Code\\n``` MS_SQL []\\nSELECT              s.user_id,\\nROUND(CAST(COUNT(CASE WHEN action = \\'confirmed\\' THEN 1 ELSE NULL END) AS FLOAT) / COUNT(*), 2) as confirmation_rate\\nFROM                Signups s\\nLEFT JOIN     Confirmations c\\nON                  s.user_id = c.user_id\\nGROUP BY            s.user_id\\n```\\n# Approach\\n\\n1. Since we need **all the values including NULL**, we have to use a `LEFT JOIN` with all values from Signups table.\\n2. For the purpose of finding `COUNT`, we have to group the id. Therefore, we use a `GROUP BY on s.user_id`.\\n3. To find the required **confirmation rate**, divide the rows with `action = \\'confirmed\\'` by all the rows for the grouped s.user_id.\\n4. To find the rows with a given value, we use \\n`COUNT(CASE WHEN <condition> THEN x ELSE y END)`\\n5. Do not use `ELSE 0`. COUNT returns the count of rows with a value and \\'0\\' is a value. So the output will be nothing but **COUNT(*)**. \\n6. The `output of INT / INT is INT`. Therefore, we have to cast/convert one of the value to a FLOAT/DECIMAL/NUMERIC. We do that using \\n`CAST(val as FLOAT)`\\n7. Finally, round the value to 2 decimal places using\\n`ROUND(val, 2)`\\n\\n##### I like checking out other approaches, drop in your approach for me and others to refer!",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "``` MS_SQL []\\nSELECT              s.user_id,\\nROUND(CAST(COUNT(CASE WHEN action = \\'confirmed\\' THEN 1 ELSE NULL END) AS FLOAT) / COUNT(*), 2) as confirmation_rate\\nFROM                Signups s\\nLEFT JOIN     Confirmations c\\nON                  s.user_id = c.user_id\\nGROUP BY            s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1408103,
                "title": "mysql-left-join",
                "content": "\\n```\\nSELECT \\n    user_id,\\n    ROUND(AVG(IF(action = \\'confirmed\\', 1, 0)), 2) AS confirmation_rate\\nFROM Signups LEFT JOIN Confirmations USING (user_id)\\nGROUP BY 1\\nORDER BY 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n    user_id,\\n    ROUND(AVG(IF(action = \\'confirmed\\', 1, 0)), 2) AS confirmation_rate\\nFROM Signups LEFT JOIN Confirmations USING (user_id)\\nGROUP BY 1\\nORDER BY 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3710142,
                "title": "super-easy-solution",
                "content": "# Code\\n```\\nselect s.user_id ,CASE WHEN c.time_stamp is NULL  then 0.00\\nelse ROUND(sum(c.action=\\'confirmed\\')/COUNT(*),2)\\nEND AS confirmation_rate \\nfrom Signups s\\nleft join Confirmations  c\\non s.user_id =c.user_id \\ngroup by s.user_id \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s.user_id ,CASE WHEN c.time_stamp is NULL  then 0.00\\nelse ROUND(sum(c.action=\\'confirmed\\')/COUNT(*),2)\\nEND AS confirmation_rate \\nfrom Signups s\\nleft join Confirmations  c\\non s.user_id =c.user_id \\ngroup by s.user_id \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3534393,
                "title": "easy-ms-sql-server-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n![image.png](https://assets.leetcode.com/users/images/85e59c3a-bbf9-4f97-a68b-8b4b8486c91f_1684323045.7926881.png)\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nSELECT\\n  s.user_id,\\n  ROUND(SUM(CASE\\n    WHEN c.action = \\'confirmed\\' THEN 1\\n    WHEN s.time_stamp IS NULL THEN 0.00\\n    ELSE 0\\n  END) / COUNT(*), 2) AS confirmation_rate\\nFROM signups s\\nLEFT JOIN confirmations c\\n  ON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nSELECT\\n  s.user_id,\\n  ROUND(SUM(CASE\\n    WHEN c.action = \\'confirmed\\' THEN 1\\n    WHEN s.time_stamp IS NULL THEN 0.00\\n    ELSE 0\\n  END) / COUNT(*), 2) AS confirmation_rate\\nFROM signups s\\nLEFT JOIN confirmations c\\n  ON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067334,
                "title": "beats-99-32-solutions",
                "content": "# Complexity\\n- Time complexity: 1096ms\\n- Space complexity: 0.00MB\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT s.user_id,\\n      ROUND((AVG(CASE\\n          WHEN action=\\'confirmed\\' THEN 1\\n          ELSE 0\\n          END)),2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id=c.user_id\\nGROUP BY user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT s.user_id,\\n      ROUND((AVG(CASE\\n          WHEN action=\\'confirmed\\' THEN 1\\n          ELSE 0\\n          END)),2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id=c.user_id\\nGROUP BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3802930,
                "title": "using-round-and-case-when",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT user_id,\\nROUND(AVG(CASE WHEN action = \\'confirmed\\' THEN 1 ELSE 0 END),2) \\nAS confirmation_rate from Confirmations\\nright join Signups using (user_id)  \\ngroup by user_id  \\n```\\n![1qivbn.jpg](https://assets.leetcode.com/users/images/a169dbd7-b34d-4a99-8359-a8a813239d9a_1689869293.2703924.jpeg)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT user_id,\\nROUND(AVG(CASE WHEN action = \\'confirmed\\' THEN 1 ELSE 0 END),2) \\nAS confirmation_rate from Confirmations\\nright join Signups using (user_id)  \\ngroup by user_id  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3634650,
                "title": "heh-simple-solution-using-agregate-functions",
                "content": "\\n```\\nselect s.user_id, round(avg(case when(c.action=\\'confirmed\\') then 1 else 0 end),2) as confirmation_rate from Signups s left join Confirmations c \\non s.user_id=c.user_id group by s.user_id\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect s.user_id, round(avg(case when(c.action=\\'confirmed\\') then 1 else 0 end),2) as confirmation_rate from Signups s left join Confirmations c \\non s.user_id=c.user_id group by s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4028966,
                "title": "mysql-easy-solution-left-join-case-when",
                "content": "\\n# Approach\\n\\nAs we are interested in confirmation rate of all the users\\nfrom the signups table , we should prefer using left join here to include every single user_id at the end group by user_id \\'s for individual result\\n\\n-- for calculating confirmation - \\n\\nformula is = total confimed / total request\\n\\n(where total request = total confirmed + total timeout)\\n\\neach grouped by user_id \\'s\\n\\nif you find this Helpful , Please Upvote !!\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect s.user_id ,\\n\\nRound(\\n \\n  sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*)\\n  ,2\\n) as confirmation_rate\\n\\nfrom signups s left join\\nconfirmations c on s.user_id = c.user_id\\ngroup by s.user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect s.user_id ,\\n\\nRound(\\n \\n  sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*)\\n  ,2\\n) as confirmation_rate\\n\\nfrom signups s left join\\nconfirmations c on s.user_id = c.user_id\\ngroup by s.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3817972,
                "title": "mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n# Write your MySQL query statement below\\n\\nselect\\ns.user_id,\\nround(sum(case when action = \\'confirmed\\' then 1 else 0 end) / count(1) , 2) as confirmation_rate\\nfrom Signups s left join Confirmations c on s.user_id = c.user_id group by user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n# Write your MySQL query statement below\\n\\nselect\\ns.user_id,\\nround(sum(case when action = \\'confirmed\\' then 1 else 0 end) / count(1) , 2) as confirmation_rate\\nfrom Signups s left join Confirmations c on s.user_id = c.user_id group by user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3723160,
                "title": "easy-code-my-solution",
                "content": "\\n# Code\\n```\\nselect s.user_id, CASE WHEN c.time_stamp is null\\nthen 0.00\\nelse round(sum(c.action=\\'confirmed\\')/count(*),2)\\nend as confirmation_rate\\nfrom Signups s\\nleft join Confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s.user_id, CASE WHEN c.time_stamp is null\\nthen 0.00\\nelse round(sum(c.action=\\'confirmed\\')/count(*),2)\\nend as confirmation_rate\\nfrom Signups s\\nleft join Confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3608649,
                "title": "mysql-solution-for-confirmation-rate-problem",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nThe solution uses a JOIN operation to combine the Signups and Confirmations tables based on the user_id column. It then calculates the confirmation rate for each user by dividing the count of confirmed requests by the total count of requests. The solution handles cases where a user has not made any confirmation requests by considering a total count of 1 and a confirmed count of 0.\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n1. The main query selects the user_id column from the Signups table and performs a LEFT JOIN with a subquery.\\r\\n1. The subquery calculates the total count of confirmation requests (total_count) and the count of confirmed requests (confirmed_count) for each user in the Confirmations table using GROUP BY and the COUNT and SUM functions.\\r\\n1. The COALESCE function is used to handle NULL values in the counts and replace them with appropriate default values (1 for total count and 0 for confirmed count).\\r\\n1. The confirmation rate is then calculated by dividing the confirmed count by the total count, and the result is rounded to two decimal places using the ROUND function.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\nThe time complexity of the solution depends on the size of the Signups and Confirmations tables. Let\\'s assume n is the number of rows in the Signups table and m is the number of rows in the Confirmations table. The subquery in the JOIN operation has a complexity of O(m), and the JOIN operation itself has a complexity of O(n + m). Overall, the time complexity of the solution can be considered as O(n + m).\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\nThe space complexity of the solution is determined by the size of the result set. Since the query returns the confirmation rate for each user, the space required to store the result will be proportional to the number of users. Therefore, the space complexity can be considered as O(n), where n is the number of users.\\r\\n\\r\\n# Code\\r\\n```\\r\\n# Write your MySQL query statement below\\r\\n# SELECT s.user_id, IFNULL(CONF.confirmation_rate, 0) AS confirmation_rate\\r\\n# FROM Signups AS s\\r\\n# LEFT JOIN (\\r\\n#     SELECT c.user_id, COUNT(c.action) AS total_requests,\\r\\n#            SUM(c.action = \\'confirmed\\') / COUNT(c.action) AS confirmation_rate\\r\\n#     FROM Confirmations AS c\\r\\n#     GROUP BY c.user_id\\r\\n# ) AS CONF ON s.user_id = CONF.user_id;\\r\\n\\r\\nSELECT\\r\\n    s.user_id,\\r\\n    ROUND(COALESCE(c.confirmed_count, 0) / COALESCE(c.total_count, 1), 2) AS confirmation_rate\\r\\nFROM\\r\\n    Signups s\\r\\nLEFT JOIN\\r\\n    (\\r\\n        SELECT\\r\\n            user_id,\\r\\n            COUNT(*) AS total_count,\\r\\n            SUM(action = \\'confirmed\\') AS confirmed_count\\r\\n        FROM\\r\\n            Confirmations\\r\\n        GROUP BY\\r\\n            user_id\\r\\n    ) c ON s.user_id = c.user_id;\\r\\n\\r\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\r\\n# Write your MySQL query statement below\\r\\n# SELECT s.user_id, IFNULL(CONF.confirmation_rate, 0) AS confirmation_rate\\r\\n# FROM Signups AS s\\r\\n# LEFT JOIN (\\r\\n#     SELECT c.user_id, COUNT(c.action) AS total_requests,\\r\\n#            SUM(c.action = \\'confirmed\\') / COUNT(c.action) AS confirmation_rate\\r\\n#     FROM Confirmations AS c\\r\\n#     GROUP BY c.user_id\\r\\n# ) AS CONF ON s.user_id = CONF.user_id;\\r\\n\\r\\nSELECT\\r\\n    s.user_id,\\r\\n    ROUND(COALESCE(c.confirmed_count, 0) / COALESCE(c.total_count, 1), 2) AS confirmation_rate\\r\\nFROM\\r\\n    Signups s\\r\\nLEFT JOIN\\r\\n    (\\r\\n        SELECT\\r\\n            user_id,\\r\\n            COUNT(*) AS total_count,\\r\\n            SUM(action = \\'confirmed\\') AS confirmed_count\\r\\n        FROM\\r\\n            Confirmations\\r\\n        GROUP BY\\r\\n            user_id\\r\\n    ) c ON s.user_id = c.user_id;\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587478,
                "title": "postgres-oracle-easy-solution-through-coalesce-statement-beats-35",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEasy solution that uses Coalesce and aggregate functions in postgres/oracle dbms. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis approach consists of two main parts - \\n\\n1.  Firsly we take out \"statuses\" - whether our user is confirmed or not. Because our `Confirmations` table does not contain all possible users, we are using auxiliary table - `Signups`. And then we simply need to perform `LEFT JOIN`.\\n2. Secondly we group our result by using aggregate function and `COALESCE`. This function is just a straightforward way of `CASE` - if we do not have the appropriate confirmation action (**NULL**) then this function will return 0.\\n\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT \\n  s.user_id, \\n  COALESCE(\\n    ROUND(AVG(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END), 2),\\n    0\\n  ) AS confirmation_rate\\nFROM \\n  Signups s \\n  LEFT OUTER JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id;\\n\\n```",
                "solutionTags": [
                    "Oracle",
                    "Database"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT \\n  s.user_id, \\n  COALESCE(\\n    ROUND(AVG(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END), 2),\\n    0\\n  ) AS confirmation_rate\\nFROM \\n  Signups s \\n  LEFT OUTER JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585274,
                "title": "same-query-for-3-db-using-left-join-and-switch-case",
                "content": "1. left join needed to list down each singups entry.\\n2. group by signup user_id so that we can process per user_id available in signups\\n3. use switch case to count confirmed event as 1, else 0.\\n\\n# Code\\n```\\nselect s.user_id,round(avg(case when c.action=\\'confirmed\\' then 1.00 else 0.00 end),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect s.user_id,round(avg(case when c.action=\\'confirmed\\' then 1.00 else 0.00 end),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3575298,
                "title": "easy-to-understand-mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id,\\nround(avg(case when action=\"confirmed\" then 1.00 else 0.00 end),2)\\nas confirmation_rate \\nfrom signups s left join confirmations c on s.user_id=c.user_id\\ngroup by s.user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id,\\nround(avg(case when action=\"confirmed\" then 1.00 else 0.00 end),2)\\nas confirmation_rate \\nfrom signups s left join confirmations c on s.user_id=c.user_id\\ngroup by s.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4007488,
                "title": "using-left-join-case-window-function",
                "content": "\\n\\n\\n# Code\\n```\\nSELECT DISTINCT s.user_id\\n\\t,round(sum(CASE \\n\\t\\t\\t\\tWHEN c.action = \\'confirmed\\'\\n\\t\\t\\t\\t\\tTHEN 1\\n\\t\\t\\t\\tELSE 0\\n\\t\\t\\t\\tEND) OVER (PARTITION BY user_id) / count(*) OVER (PARTITION BY user_id), 2) AS confirmation_rate\\nFROM Signups AS s\\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT s.user_id\\n\\t,round(sum(CASE \\n\\t\\t\\t\\tWHEN c.action = \\'confirmed\\'\\n\\t\\t\\t\\t\\tTHEN 1\\n\\t\\t\\t\\tELSE 0\\n\\t\\t\\t\\tEND) OVER (PARTITION BY user_id) / count(*) OVER (PARTITION BY user_id), 2) AS confirmation_rate\\nFROM Signups AS s\\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3981207,
                "title": "easy-to-understand-solution-with-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Perform a LEFT JOIN between the Signups table and the Confirmations table using user_id as the matching column.\\n2. Calculate the total number of \\'confirmed\\' messages for each user and the total number of requested confirmation messages for each user using SUM and COUNT functions respectively.\\n3. Use the IFNULL function to handle cases where a user did not request any confirmation messages (set confirmation rate to 0.00).\\n4. Use the ROUND function to round the confirmation rate to two decimal places.\\n5. Group the results by user_id.\\n\\n\\n# Complexity\\n- Time complexity: **O(N + M)**, where** N** is the number of rows in the Signups table and **M** is the number of rows in the Confirmations table.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(N)**, where **N** is the number of rows in the Signups table\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT s.user_id,\\n       IFNULL(\\n           ROUND(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / COUNT(c.user_id), 2),\\n           0.00\\n       ) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT s.user_id,\\n       IFNULL(\\n           ROUND(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / COUNT(c.user_id), 2),\\n           0.00\\n       ) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3847760,
                "title": "beats-89-76-of-users-with-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect S.user_id\\n, round(\\n    avg(case when action = \\'confirmed\\' then 1 else 0 end),\\n    2) as confirmation_rate\\nfrom Signups S left join Confirmations C on \\nS.user_id=C.user_id\\ngroup by S.user_id\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect S.user_id\\n, round(\\n    avg(case when action = \\'confirmed\\' then 1 else 0 end),\\n    2) as confirmation_rate\\nfrom Signups S left join Confirmations C on \\nS.user_id=C.user_id\\ngroup by S.user_id\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3600882,
                "title": "simple-sql-solution-sss",
                "content": "# Code\\n```\\nSelect \\n    s.user_id, \\n    round(avg(case when c.action = \\'confirmed\\' then 1.00 else 0.00 end), 2) as confirmation_rate\\nfrom signups s left\\njoin confirmations c \\n#on s.user_id = c.user_id\\nusing (user_id)\\ngroup by s.user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect \\n    s.user_id, \\n    round(avg(case when c.action = \\'confirmed\\' then 1.00 else 0.00 end), 2) as confirmation_rate\\nfrom signups s left\\njoin confirmations c \\n#on s.user_id = c.user_id\\nusing (user_id)\\ngroup by s.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3574094,
                "title": "easy-join-and-sub-query-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect s.user_id,case \\nwhen c.confirmation_rate is null then 0 else c.confirmation_rate \\nend as confirmation_rate\\nfrom signups s left join ( \\nselect user_id, round(avg(rate),2) confirmation_rate from\\n(select *, case\\nwhen action=\"timeout\" then 0 else 1 \\nend as rate\\nfrom confirmations)a\\ngroup by user_id)c on s.user_id=c.user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect s.user_id,case \\nwhen c.confirmation_rate is null then 0 else c.confirmation_rate \\nend as confirmation_rate\\nfrom signups s left join ( \\nselect user_id, round(avg(rate),2) confirmation_rate from\\n(select *, case\\nwhen action=\"timeout\" then 0 else 1 \\nend as rate\\nfrom confirmations)a\\ngroup by user_id)c on s.user_id=c.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3564592,
                "title": "sql-round-coalesce-sum-count-left-join-easy-solution",
                "content": "# Intuition\\nFirst, we connected the Signups table with the Confirmations table using a left join. The main work is to prepare the confirmation_rate column. After grouping user_ids, the number of those whose action is \"confirmed\" is divided by the total number of actions. then we coalesce the partition so that it doesn\\'t return null. we round the division so that it returns with 2 digits of precision after the point\\n\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/8f01bd92-266b-4d07-852b-bdb8978c67b5_1685095384.4712029.png)\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect\\ns.user_id,\\nround(coalesce(sum(case when action = \\'confirmed\\' then 1 end) / count(action) ,0),2) as confirmation_rate\\nfrom Signups s left join Confirmations c on s.user_id = c.user_id\\ngroup by s.user_id\\n\\n\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect\\ns.user_id,\\nround(coalesce(sum(case when action = \\'confirmed\\' then 1 end) / count(action) ,0),2) as confirmation_rate\\nfrom Signups s left join Confirmations c on s.user_id = c.user_id\\ngroup by s.user_id\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3547166,
                "title": "mysql-easy-and-clean-sum-join",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect\\ns.user_id,\\nround(sum(case when action = \\'confirmed\\' then 1 else 0 end) / count(1) , 2) as confirmation_rate\\nfrom Signups s left join Confirmations c on s.user_id = c.user_id\\ngroup by user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect\\ns.user_id,\\nround(sum(case when action = \\'confirmed\\' then 1 else 0 end) / count(1) , 2) as confirmation_rate\\nfrom Signups s left join Confirmations c on s.user_id = c.user_id\\ngroup by user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519921,
                "title": "easy-to-understand-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\n\\nselect \\n    a.user_id, \\n\\n    case when b.user_id is null then 0\\n    else \\n    round(sum(case when action = \\'confirmed\\' then 1 else 0 end) / cast(count(b.user_id) as float),2 )\\n    end as confirmation_rate\\n\\n\\nfrom signups a\\nleft join confirmations b\\non a.user_id = b.user_id\\n\\ngroup by a.user_id, b.user_id\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\n\\nselect \\n    a.user_id, \\n\\n    case when b.user_id is null then 0\\n    else \\n    round(sum(case when action = \\'confirmed\\' then 1 else 0 end) / cast(count(b.user_id) as float),2 )\\n    end as confirmation_rate\\n\\n\\nfrom signups a\\nleft join confirmations b\\non a.user_id = b.user_id\\n\\ngroup by a.user_id, b.user_id\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3438572,
                "title": "solution-with-simple-join-count-sql-server",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n\\r\\nWITH CTE AS (\\r\\n      SELECT\\r\\n        user_id,\\r\\n        (COUNT(CASE WHEN action = \\'confirmed\\' THEN 1 ELSE NULL END) / \\r\\n        CAST(COUNT(user_id) AS DECIMAL(10,2))) [confirmation_rate]\\r\\n      FROM\\r\\n        Confirmations\\r\\n      GROUP BY\\r\\n        user_id\\r\\n)\\r\\nSELECT\\r\\n  T2.user_id,\\r\\n  ROUND(ISNULL([confirmation_rate],0),2) [confirmation_rate]\\r\\nFROM\\r\\n  CTE T1\\r\\nRIGHT JOIN\\r\\n  Signups T2 ON T1.user_id = T2.user_id\\r\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n\\r\\nWITH CTE AS (\\r\\n      SELECT\\r\\n        user_id,\\r\\n        (COUNT(CASE WHEN action = \\'confirmed\\' THEN 1 ELSE NULL END) / \\r\\n        CAST(COUNT(user_id) AS DECIMAL(10,2))) [confirmation_rate]\\r\\n      FROM\\r\\n        Confirmations\\r\\n      GROUP BY\\r\\n        user_id\\r\\n)\\r\\nSELECT\\r\\n  T2.user_id,\\r\\n  ROUND(ISNULL([confirmation_rate],0),2) [confirmation_rate]\\r\\nFROM\\r\\n  CTE T1\\r\\nRIGHT JOIN\\r\\n  Signups T2 ON T1.user_id = T2.user_id\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2431167,
                "title": "mysql-with-cte-sum-case-statement-left-join-group-by-good-luck",
                "content": "```\\n# Write your MySQL query statement below\\n/**\\nTwo Tables: Signups/Confirmations\\n\\nuser_id is the primary key for Signups table.\\nSignups table contains information about the signup time for the user with ID user_id.\\n\\n(user_id, time_stamp) is the primary key for Confirmations table.\\nConfirmations table indicates that the user with ID user_id requested a confirmation message at time_stamp and that confirmation message was either confirmed (\\'confirmed\\') or expired without confirming (\\'timeout\\').\\n\\nPROBLEM: \\n    find the confirmation rate of each user\\n    confirmation rate of a user is the number of \\'confirmed\\' messages divided by the total number of requested confirmation messages.\\n    ROUND(,2)\\n    \\nSTEPS:\\n    WITH CTE find the number of userid who action is confirmed and total no\\n    SUM(CASE statement) & COUNT(no of actions)\\n    ROUND(,2)\\n    IFNULL(,0)\\n*/\\n\\nWITH CTE AS\\n(\\nSELECT \\n    user_id,\\n    SUM(CASE WHEN action = \\'confirmed\\' THEN 1 ELSE 0 END) AS totalConfirmed,\\n    COUNT(action) AS totalAction\\nFROM Confirmations\\nGROUP BY user_id\\n)\\n\\nSELECT\\n    S.user_id,\\n    ROUND(IFNULL(SUM(totalConfirmed/totalAction),0),2) AS confirmation_rate\\nFROM Signups S\\nLEFT JOIN CTE C\\nON S.user_id = C.user_id\\nGROUP BY 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n/**\\nTwo Tables: Signups/Confirmations\\n\\nuser_id is the primary key for Signups table.\\nSignups table contains information about the signup time for the user with ID user_id.\\n\\n(user_id, time_stamp) is the primary key for Confirmations table.\\nConfirmations table indicates that the user with ID user_id requested a confirmation message at time_stamp and that confirmation message was either confirmed (\\'confirmed\\') or expired without confirming (\\'timeout\\').\\n\\nPROBLEM: \\n    find the confirmation rate of each user\\n    confirmation rate of a user is the number of \\'confirmed\\' messages divided by the total number of requested confirmation messages.\\n    ROUND(,2)\\n    \\nSTEPS:\\n    WITH CTE find the number of userid who action is confirmed and total no\\n    SUM(CASE statement) & COUNT(no of actions)\\n    ROUND(,2)\\n    IFNULL(,0)\\n*/\\n\\nWITH CTE AS\\n(\\nSELECT \\n    user_id,\\n    SUM(CASE WHEN action = \\'confirmed\\' THEN 1 ELSE 0 END) AS totalConfirmed,\\n    COUNT(action) AS totalAction\\nFROM Confirmations\\nGROUP BY user_id\\n)\\n\\nSELECT\\n    S.user_id,\\n    ROUND(IFNULL(SUM(totalConfirmed/totalAction),0),2) AS confirmation_rate\\nFROM Signups S\\nLEFT JOIN CTE C\\nON S.user_id = C.user_id\\nGROUP BY 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2260389,
                "title": "mysql-solution-without-case-end",
                "content": "```\\nselect s.user_id, round(ifnull(sum(c.action = \\'confirmed\\') / count(c.action), 0), 2) as confirmation_rate\\nfrom Signups s\\nleft join Confirmations c\\non s.user_id = c.user_id\\ngroup by 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s.user_id, round(ifnull(sum(c.action = \\'confirmed\\') / count(c.action), 0), 2) as confirmation_rate\\nfrom Signups s\\nleft join Confirmations c\\non s.user_id = c.user_id\\ngroup by 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2060181,
                "title": "must-know-mysql-avg-queries-for-interviews",
                "content": "These types of questions are pretty common in interviews, please do pay attention to the easy solutions like using AVG specially when the interviwer needs quick answers\\n\\n```\\nselect \\n    s.user_id,\\n    ifnull(round(avg(action = \\'confirmed\\'),2),0) as confirmation_rate\\nfrom Signups s\\nleft join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id\\n```",
                "solutionTags": [],
                "code": "```\\nselect \\n    s.user_id,\\n    ifnull(round(avg(action = \\'confirmed\\'),2),0) as confirmation_rate\\nfrom Signups s\\nleft join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1483341,
                "title": "simple-mysql-solution",
                "content": "```\\nselect s.user_id,round(avg(case when action=\\'confirmed\\' then 1 else 0 end),2)\\nas confirmation_rate from Signups s left join Confirmations c on s.user_id = c.user_id  group by s.user_id",
                "solutionTags": [],
                "code": "```\\nselect s.user_id,round(avg(case when action=\\'confirmed\\' then 1 else 0 end),2)\\nas confirmation_rate from Signups s left join Confirmations c on s.user_id = c.user_id  group by s.user_id",
                "codeTag": "Unknown"
            },
            {
                "id": 3981879,
                "title": "best-solutions-more-easy-to-understand",
                "content": "Here is my solution guys :)\\r\\n\\r\\n# Code\\r\\n```\\r\\nWITH cte AS (\\r\\n    SELECT a.user_id,\\r\\n           CASE WHEN b.action = \\'confirmed\\' THEN 1 ELSE 0 END AS confirmed_user,\\r\\n           CASE WHEN b.action = \\'timeout\\' THEN 1 ELSE 0 END AS timeout_user\\r\\n    FROM Signups a\\r\\n    LEFT JOIN Confirmations b ON a.user_id = b.user_id\\r\\n),\\r\\ncte2 AS (\\r\\n    SELECT user_id, \\r\\n           SUM(confirmed_user) AS total_confirmed,\\r\\n           SUM(timeout_user) AS total_timeout,\\r\\n           SUM(confirmed_user + timeout_user) AS total_request\\r\\n    FROM cte\\r\\n    GROUP BY user_id\\r\\n)\\r\\nSELECT user_id, \\r\\n       ROUND(SUM(IFNULL(total_confirmed / total_request, 0)), 2) AS CONFIRMATION_RATE\\r\\nFROM cte2\\r\\nGROUP BY user_id;\\r\\n\\r\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\r\\nWITH cte AS (\\r\\n    SELECT a.user_id,\\r\\n           CASE WHEN b.action = \\'confirmed\\' THEN 1 ELSE 0 END AS confirmed_user,\\r\\n           CASE WHEN b.action = \\'timeout\\' THEN 1 ELSE 0 END AS timeout_user\\r\\n    FROM Signups a\\r\\n    LEFT JOIN Confirmations b ON a.user_id = b.user_id\\r\\n),\\r\\ncte2 AS (\\r\\n    SELECT user_id, \\r\\n           SUM(confirmed_user) AS total_confirmed,\\r\\n           SUM(timeout_user) AS total_timeout,\\r\\n           SUM(confirmed_user + timeout_user) AS total_request\\r\\n    FROM cte\\r\\n    GROUP BY user_id\\r\\n)\\r\\nSELECT user_id, \\r\\n       ROUND(SUM(IFNULL(total_confirmed / total_request, 0)), 2) AS CONFIRMATION_RATE\\r\\nFROM cte2\\r\\nGROUP BY user_id;\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3926112,
                "title": "beats-98-users",
                "content": "# Intuition\\n<!-- The best way was to visualize the entire data as 1 dataset after joining -->\\n\\n# Approach\\n<!-- once the data was readble, start making iff statement to match the requirement -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- I did it first with sum and count and case statement. Later used iif and avg to reduce time complexity  -->\\n\\n- Space complexity:\\n<!-- use the right functions to reduce the space and time complexity -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nselect s.user_id,round(avg(iif(c.action=\\'confirmed\\',cast(1 as float),0)),2) as confirmation_rate \\nfrom Signups s\\nleft join\\nConfirmations c\\non s.user_id=c.user_id\\ngroup by s.user_id\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nselect s.user_id,round(avg(iif(c.action=\\'confirmed\\',cast(1 as float),0)),2) as confirmation_rate \\nfrom Signups s\\nleft join\\nConfirmations c\\non s.user_id=c.user_id\\ngroup by s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3615663,
                "title": "join-sub-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nselect su.user_id,confirmation_rate =\\nROUND((select count(*)from Confirmations sub \\n where su.user_id=sub.user_id and sub.action=\\'confirmed\\' )/(count(*)+0.0),2)\\nfrom Signups su left outer join Confirmations cu\\non su.user_id=cu.user_id\\ngroup by su.user_id\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect su.user_id,confirmation_rate =\\nROUND((select count(*)from Confirmations sub \\n where su.user_id=sub.user_id and sub.action=\\'confirmed\\' )/(count(*)+0.0),2)\\nfrom Signups su left outer join Confirmations cu\\non su.user_id=cu.user_id\\ngroup by su.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591566,
                "title": "easy-mysql-solution-with-explanation-best-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We need to find the number of times when the action=\\'confirmed\\' out of the total number of actions.\\n- For that, we take **average with an if condition such that the value is 1 if action=\\'confirmed\\' and 0 otherwise, and then round the answer upto 2 decimals**.\\n-  We then group the output by the user_id in the Signups table so that it includess all the users.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. In the SELECT statement, we retrieve the user_id from Signups and the confirmation_rate from Conifrmations such that the **confirmation_rate is equal to the number of times when the action=\\'confirmed\\' out of the total number of actions.**\\n2. In the FROM statement, we take a **LEFT OUTER JOIN on user_id with Signups on the LEFT SIDE** so that every user who ever signed up is included in the output.\\n3. The **GROUP BY clause** groups the action according to the user_id of all the users who signed up.\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT S.user_id, ROUND(AVG(if(C.action=\\'confirmed\\',1,0)),2) as confirmation_rate\\nFROM Signups as S LEFT OUTER JOIN Confirmations as C\\nON S.user_id = C.user_id\\nGROUP BY S.user_id;\\n```\\n# Note\\nPlease upvote if you find my solution helpful. If you have any doubts, suggestion or want to discuss any solution, comment it. If you wish to discuss other related topics, feel free to message me on LinkedIn, https://leetcode.com/prathams29/",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT S.user_id, ROUND(AVG(if(C.action=\\'confirmed\\',1,0)),2) as confirmation_rate\\nFROM Signups as S LEFT OUTER JOIN Confirmations as C\\nON S.user_id = C.user_id\\nGROUP BY S.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495670,
                "title": "oracle-simple-solution-using-avg-case-when",
                "content": "\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT T1.USER_ID, \\nROUND(AVG(CASE WHEN T2.ACTION = \\'confirmed\\' THEN 1.00 ELSE 0.00 END), 2) AS CONFIRMATION_RATE\\nFROM SIGNUPS T1\\nLEFT JOIN\\nCONFIRMATIONS T2\\nON T1.USER_ID = T2.USER_ID\\nGROUP BY T1.USER_ID;\\n\\n\\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT T1.USER_ID, \\nROUND(AVG(CASE WHEN T2.ACTION = \\'confirmed\\' THEN 1.00 ELSE 0.00 END), 2) AS CONFIRMATION_RATE\\nFROM SIGNUPS T1\\nLEFT JOIN\\nCONFIRMATIONS T2\\nON T1.USER_ID = T2.USER_ID\\nGROUP BY T1.USER_ID;\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3470141,
                "title": "with-case-and-average-method",
                "content": "# Intuition\\nJoin the both the tables(Signups and Confirmation) and find the total confirmation and signups\\n# Approach\\nAfter left joining both the tables use CASE to get the user_id with count of confirmations and then find the average to get the confirmation rate\\n\\n\\n# Code\\n```\\nselect s.user_id as user_id,\\n      ROUND(AVG(case WHEN action =\\'confirmed\\' THEN 1.00 ELSE 0.00 END),2) as confirmation_rate\\nfrom Signups s\\nLEFT JOIN Confirmations c ON\\ns.user_id = c.user_id\\ngroup by user_id\\n\\n```\\n\\n# Another Method\\nI am adding an another way of approch to get confirmation_rate using with and case expression\\n\\nHere finding a table with total confirmation count and total signups for each user and joining both the tables (Signups and Confirmation).\\n\\n# Code\\n```\\nWITH  confirmation_rate_table as \\n\\t(select s.user_id as user_id, count(action) as total_signups,\\n      SUM(case WHEN action =\\'confirmed\\' THEN 1.00 ELSE 0.00 END) as confirmation_count\\n  from Signups s\\n  LEFT JOIN Confirmations c ON\\n  s.user_id = c.user_id\\n  group by user_id)\\n\\n SELECT user_id, \\n  (case WHEN confirmation_count != 0 then (confirmation_count/total_signups) ELSE 0 END) as confirmation_rate\\nfrom  confirmation_rate_table\\n\\n```\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s.user_id as user_id,\\n      ROUND(AVG(case WHEN action =\\'confirmed\\' THEN 1.00 ELSE 0.00 END),2) as confirmation_rate\\nfrom Signups s\\nLEFT JOIN Confirmations c ON\\ns.user_id = c.user_id\\ngroup by user_id\\n\\n```\n```\\nWITH  confirmation_rate_table as \\n\\t(select s.user_id as user_id, count(action) as total_signups,\\n      SUM(case WHEN action =\\'confirmed\\' THEN 1.00 ELSE 0.00 END) as confirmation_count\\n  from Signups s\\n  LEFT JOIN Confirmations c ON\\n  s.user_id = c.user_id\\n  group by user_id)\\n\\n SELECT user_id, \\n  (case WHEN confirmation_count != 0 then (confirmation_count/total_signups) ELSE 0 END) as confirmation_rate\\nfrom  confirmation_rate_table\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1788268,
                "title": "mysql-easy-to-understand-beats-95",
                "content": "```\\nselect \\n    s.user_id,\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end)/count(*),2) as confirmation_rate\\nfrom Signups s\\nleft join Confirmations c\\non s.user_id = c.user_id\\ngroup by 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect \\n    s.user_id,\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end)/count(*),2) as confirmation_rate\\nfrom Signups s\\nleft join Confirmations c\\non s.user_id = c.user_id\\ngroup by 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1749757,
                "title": "mysql-quick-and-simple-solution-with-left-join",
                "content": "```\\nselect\\n    s.user_id,\\n    round( sum(case when action=\"confirmed\" then 1 else 0 end) / count(1), 2) confirmation_rate\\nfrom Signups s\\nleft join Confirmations c on s.user_id = c.user_id\\ngroup by s.user_id;\\n```\\n\\nResults:\\n![image](https://assets.leetcode.com/users/images/4eed6f16-4612-4328-8ed0-b74c70090dd9_1644144960.9699397.png)\\n",
                "solutionTags": [],
                "code": "```\\nselect\\n    s.user_id,\\n    round( sum(case when action=\"confirmed\" then 1 else 0 end) / count(1), 2) confirmation_rate\\nfrom Signups s\\nleft join Confirmations c on s.user_id = c.user_id\\ngroup by s.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1698726,
                "title": "easy-mysql-solution-left-join-group-by",
                "content": "SELECT s.user_id,\\nROUND(IFNULL(SUM(CASE WHEN c.action = \"confirmed\" THEN 1 ELSE 0 END)/\\nCOUNT(c.time_stamp),0),2) AS confirmation_rate\\nFROM Signups AS s\\nLEFT JOIN Confirmations AS c\\nON s.user_id = c.user_id \\nGROUP BY s.user_id",
                "solutionTags": [],
                "code": "SELECT s.user_id,\\nROUND(IFNULL(SUM(CASE WHEN c.action = \"confirmed\" THEN 1 ELSE 0 END)/\\nCOUNT(c.time_stamp),0),2) AS confirmation_rate\\nFROM Signups AS s\\nLEFT JOIN Confirmations AS c\\nON s.user_id = c.user_id \\nGROUP BY s.user_id",
                "codeTag": "Unknown"
            },
            {
                "id": 1698029,
                "title": "one-subquery",
                "content": "```\\nselect \\n    user_id,\\n    round(avg(case when action = \\'confirmed\\' then 1 else 0 end),2) as confirmation_rate\\n\\nfrom(select \\n    s.user_id,\\n    c.action\\nfrom Signups as s left join Confirmations as c on s.user_id = c.user_id    \\n    ) as temp\\n    \\ngroup by user_id\\n```",
                "solutionTags": [],
                "code": "```\\nselect \\n    user_id,\\n    round(avg(case when action = \\'confirmed\\' then 1 else 0 end),2) as confirmation_rate\\n\\nfrom(select \\n    s.user_id,\\n    c.action\\nfrom Signups as s left join Confirmations as c on s.user_id = c.user_id    \\n    ) as temp\\n    \\ngroup by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1688529,
                "title": "solution",
                "content": "select s.user_id as user_id, ifnull(confirmation_rate,0) as confirmation_rate\\nfrom Signups s\\nleft join\\n(select user_id, round(sum(case action when \"confirmed\" then 1 else 0 end)/count(user_id),2) as confirmation_rate\\nfrom Confirmations\\ngroup by user_id) t\\non s.user_id = t.user_id",
                "solutionTags": [],
                "code": "select s.user_id as user_id, ifnull(confirmation_rate,0) as confirmation_rate\\nfrom Signups s\\nleft join\\n(select user_id, round(sum(case action when \"confirmed\" then 1 else 0 end)/count(user_id),2) as confirmation_rate\\nfrom Confirmations\\ngroup by user_id) t\\non s.user_id = t.user_id",
                "codeTag": "Unknown"
            },
            {
                "id": 1667894,
                "title": "avg-action-confirmed-easy-sql",
                "content": "```\\n\\nselect\\nuser_id,\\nifnull(round(avg(action = \\'confirmed\\'),2),0.00) as confirmation_rate\\nfrom \\nSignups s \\nleft join Confirmations c\\nusing(user_id)\\ngroup by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n\\nselect\\nuser_id,\\nifnull(round(avg(action = \\'confirmed\\'),2),0.00) as confirmation_rate\\nfrom \\nSignups s \\nleft join Confirmations c\\nusing(user_id)\\ngroup by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1594905,
                "title": "simple-join-and-case",
                "content": "```\\nSELECT\\n    s.user_id,\\n    CAST(SUM(CASE WHEN action = \\'confirmed\\' THEN 1 ELSE 0 END) / COUNT(*) AS DECIMAL(10,2)) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c  ON s.user_id = c.user_id\\nGROUP BY user_id\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    s.user_id,\\n    CAST(SUM(CASE WHEN action = \\'confirmed\\' THEN 1 ELSE 0 END) / COUNT(*) AS DECIMAL(10,2)) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c  ON s.user_id = c.user_id\\nGROUP BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1502070,
                "title": "should-time-stamp-in-signups-alway-be-earlier-than-that-in-confirmations",
                "content": "I had a where clause in my original answer\\n`WHERE sign.time_stamp<=comf.time_stamp OR comf.time_stamp is NULL`\\nbecause logically a user should sign up first then can be able to request confirmation. It failed in the test case below\\n```\\n{\"headers\": {\"Signups\": [\"user_id\", \"time_stamp\"],\\n             \"Confirmations\": [\"user_id\", \"time_stamp\", \"action\"]}, \\n    \"rows\": {\"Signups\": [[14, \"2020-02-26 17:32:52\"], [10, \"2021-07-28 03:12:22\"], \\n                        [5, \"2021-09-14 08:34:18\"], [6, \"2021-03-25 11:31:06\"], \\n                        [7, \"2021-01-31 08:00:29\"], [3, \"2020-12-02 18:04:14\"], \\n                        [8, \"2020-03-07 20:51:35\"]], \\n            \"Confirmations\": [[5, \"2021-10-11 13:40:45\", \"confirmed\"], \\n                        [5, \"2020-01-15 22:35:44\", \"timeout\"], \\n                        [10, \"2021-12-20 00:54:03\", \"confirmed\"], \\n                        [6, \"2020-05-13 14:14:30\", \"confirmed\"], \\n                        [8, \"2021-09-09 04:00:12\", \"confirmed\"], \\n                        [14, \"2021-07-20 17:53:59\", \"timeout\"], \\n                        [14, \"2021-12-19 11:44:53\", \"timeout\"]]\\n                }\\n    }\\n```\\n\\nWhat should be the confirmation rate for user #5, `1.00` or `0.50`? Can anyone help me understand the probelm statement?",
                "solutionTags": [],
                "code": "```\\n{\"headers\": {\"Signups\": [\"user_id\", \"time_stamp\"],\\n             \"Confirmations\": [\"user_id\", \"time_stamp\", \"action\"]}, \\n    \"rows\": {\"Signups\": [[14, \"2020-02-26 17:32:52\"], [10, \"2021-07-28 03:12:22\"], \\n                        [5, \"2021-09-14 08:34:18\"], [6, \"2021-03-25 11:31:06\"], \\n                        [7, \"2021-01-31 08:00:29\"], [3, \"2020-12-02 18:04:14\"], \\n                        [8, \"2020-03-07 20:51:35\"]], \\n            \"Confirmations\": [[5, \"2021-10-11 13:40:45\", \"confirmed\"], \\n                        [5, \"2020-01-15 22:35:44\", \"timeout\"], \\n                        [10, \"2021-12-20 00:54:03\", \"confirmed\"], \\n                        [6, \"2020-05-13 14:14:30\", \"confirmed\"], \\n                        [8, \"2021-09-09 04:00:12\", \"confirmed\"], \\n                        [14, \"2021-07-20 17:53:59\", \"timeout\"], \\n                        [14, \"2021-12-19 11:44:53\", \"timeout\"]]\\n                }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1492555,
                "title": "mysql-solution",
                "content": "```\\nselect s.user_id, round(ifnull(sum(case when action is null then 0\\n                         when action = \\'confirmed\\' then 1\\n                         else 0 end)/count(action), 0),2) as confirmation_rate\\nfrom Signups s \\nleft join Confirmations c \\non s.user_id = c.user_id \\ngroup by s.user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s.user_id, round(ifnull(sum(case when action is null then 0\\n                         when action = \\'confirmed\\' then 1\\n                         else 0 end)/count(action), 0),2) as confirmation_rate\\nfrom Signups s \\nleft join Confirmations c \\non s.user_id = c.user_id \\ngroup by s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4092492,
                "title": "simple-solution-to-relatively-tough-probelem",
                "content": "# Intuition\\nThink of calculating  an action score for each user \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nwith cte as (select Signups.user_id, action, \\ncase \\n     \\n    when action = \\'confirmed\\' then 1\\n    else 0\\n    end\\nas action_score \\nfrom Signups left outer join Confirmations on Signups.user_id=Confirmations.user_id)\\n\\nselect user_id, round(sum(action_score)/count(*),2) as confirmation_rate from cte group by user_id order by confirmation_rate\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nwith cte as (select Signups.user_id, action, \\ncase \\n     \\n    when action = \\'confirmed\\' then 1\\n    else 0\\n    end\\nas action_score \\nfrom Signups left outer join Confirmations on Signups.user_id=Confirmations.user_id)\\n\\nselect user_id, round(sum(action_score)/count(*),2) as confirmation_rate from cte group by user_id order by confirmation_rate\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4092309,
                "title": "simple-pandas-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef confirmation_rate(signups: pd.DataFrame, confirmations: pd.DataFrame) -> pd.DataFrame:\\n    confirmations[\\'confirmation_rate\\'] = confirmations[\\'action\\'].apply(lambda x:1 if x == \\'confirmed\\' else 0)\\n    avg_conf = confirmations[[\\'user_id\\',\\'confirmation_rate\\']].groupby(\\'user_id\\')[\\'confirmation_rate\\'].mean().round(2).reset_index()\\n    output = pd.merge(signups[\\'user_id\\'],avg_conf,how=\\'left\\').fillna(0)  \\n    return output\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef confirmation_rate(signups: pd.DataFrame, confirmations: pd.DataFrame) -> pd.DataFrame:\\n    confirmations[\\'confirmation_rate\\'] = confirmations[\\'action\\'].apply(lambda x:1 if x == \\'confirmed\\' else 0)\\n    avg_conf = confirmations[[\\'user_id\\',\\'confirmation_rate\\']].groupby(\\'user_id\\')[\\'confirmation_rate\\'].mean().round(2).reset_index()\\n    output = pd.merge(signups[\\'user_id\\'],avg_conf,how=\\'left\\').fillna(0)  \\n    return output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4092246,
                "title": "solution-with-one-select-using-avg-and-case-when",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple solution using few select.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe use of case when is important to work with the AVG() function.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* work with MySql, Oracle and SQL Server */\\nSELECT S.user_id,\\n        ROUND(AVG(CASE WHEN C.action = \\'confirmed\\' THEN 1.0 ELSE 0.0 END),2) as confirmation_rate \\nFROM Signups S\\n        LEFT JOIN Confirmations C ON S.user_id = C.user_id\\nGROUP BY S.user_id \\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\n/* work with MySql, Oracle and SQL Server */\\nSELECT S.user_id,\\n        ROUND(AVG(CASE WHEN C.action = \\'confirmed\\' THEN 1.0 ELSE 0.0 END),2) as confirmation_rate \\nFROM Signups S\\n        LEFT JOIN Confirmations C ON S.user_id = C.user_id\\nGROUP BY S.user_id \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4091739,
                "title": "beats-98-of-the-users",
                "content": "# Intuition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT s.user_id, IFNULL (ROUND(SUM(IF(c.action = \"confirmed\",1,0))/COUNT(c.action),2),0) confirmation_rate\\n\\nFROM signups s\\nLEFT JOIN confirmations c\\nON s.user_id = c.user_id\\nGROUP BY 1",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "# Intuition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT s.user_id, IFNULL (ROUND(SUM(IF(c.action = \"confirmed\",1,0))/COUNT(c.action),2),0) confirmation_rate\\n\\nFROM signups s\\nLEFT JOIN confirmations c\\nON s.user_id = c.user_id\\nGROUP BY 1",
                "codeTag": "Unknown"
            },
            {
                "id": 4090700,
                "title": "easy-solution-using-left-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect user_id , round(sum(case when action = \"confirmed\" then 1 else 0 end)/count(*),2) as confirmation_rate from \\n\\n        (select s.user_id , c.action from Signups s left join Confirmations c on s.user_id = c.user_id) as sd group by user_id;\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect user_id , round(sum(case when action = \"confirmed\" then 1 else 0 end)/count(*),2) as confirmation_rate from \\n\\n        (select s.user_id , c.action from Signups s left join Confirmations c on s.user_id = c.user_id) as sd group by user_id;\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4090673,
                "title": "using-left-join-case-when",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id,\\nround(count(case when action = \\'confirmed\\' then 1 end)/\\ncount(s.user_id),2) as confirmation_rate\\nfrom Signups s\\nleft join Confirmations c\\non c.user_id = s.user_id\\ngroup by s.user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id,\\nround(count(case when action = \\'confirmed\\' then 1 end)/\\ncount(s.user_id),2) as confirmation_rate\\nfrom Signups s\\nleft join Confirmations c\\non c.user_id = s.user_id\\ngroup by s.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4090165,
                "title": "oracle-pandas-95-faster-beats-clean-solution",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Oracle Code\\n```\\n/* Write your PL/SQL query statement below */\\n\\nselect s.user_id ,round(avg(case when c.action=\\'confirmed\\' then 1 else 0 end),2) confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id\\n```\\n\\n# Pandas Code\\n```\\ndef confirmation_rate(signups: pd.DataFrame, confirmations: pd.DataFrame) -> pd.DataFrame:\\n    confirmations = confirmations.groupby(\\'user_id\\').agg(\\n        confirmation_rate = (\\'action\\',lambda x:round(mean([i==\\'confirmed\\' for i in x]),2))\\n    ).reset_index()\\n    return signups.merge(confirmations,\\'left\\',\\'user_id\\').fillna(0)[[\\'user_id\\',\\'confirmation_rate\\']]\\n```\\n\\n",
                "solutionTags": [
                    "Oracle",
                    "Pandas"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\n\\nselect s.user_id ,round(avg(case when c.action=\\'confirmed\\' then 1 else 0 end),2) confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id\\n```\n```\\ndef confirmation_rate(signups: pd.DataFrame, confirmations: pd.DataFrame) -> pd.DataFrame:\\n    confirmations = confirmations.groupby(\\'user_id\\').agg(\\n        confirmation_rate = (\\'action\\',lambda x:round(mean([i==\\'confirmed\\' for i in x]),2))\\n    ).reset_index()\\n    return signups.merge(confirmations,\\'left\\',\\'user_id\\').fillna(0)[[\\'user_id\\',\\'confirmation_rate\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4089717,
                "title": "straight-forward-solution-beats-100",
                "content": "\\n```\\nselect\\n    a.user_id, case when b.confirmed_count/a.total_count is null then 0 else round(1.0*b.confirmed_count/a.total_count, 2) end as confirmation_rate\\nfrom (\\n    select\\n        s.user_id, count(c.action) total_count\\n    from signups s\\n    left join confirmations c\\n    on s.user_id = c.user_id\\n    group by  s.user_id\\n) a\\nleft join\\n(\\n    select\\n        s.user_id, c.action, count(*) confirmed_count\\n    from signups s\\n    left join confirmations c\\n    on s.user_id = c.user_id\\n    group by  s.user_id, c.action\\n    having c.action = \\'confirmed\\'\\n) b\\non a.user_id = b.user_id\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect\\n    a.user_id, case when b.confirmed_count/a.total_count is null then 0 else round(1.0*b.confirmed_count/a.total_count, 2) end as confirmation_rate\\nfrom (\\n    select\\n        s.user_id, count(c.action) total_count\\n    from signups s\\n    left join confirmations c\\n    on s.user_id = c.user_id\\n    group by  s.user_id\\n) a\\nleft join\\n(\\n    select\\n        s.user_id, c.action, count(*) confirmed_count\\n    from signups s\\n    left join confirmations c\\n    on s.user_id = c.user_id\\n    group by  s.user_id, c.action\\n    having c.action = \\'confirmed\\'\\n) b\\non a.user_id = b.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4088604,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT \\n    s.user_id\\n    , ROUND(AVG(IF(c.action = \"confirmed\", 1, 0)), 2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n    s.user_id\\n    , ROUND(AVG(IF(c.action = \"confirmed\", 1, 0)), 2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4088105,
                "title": "complex-solution-took-me-1-hour-to-solve-upvote-please",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect s.user_id,round(nvl(rpj.con,0)/NVL(NULLIF(nvl(rpj.con,0)+nvl(rpj.tim,0),0), 1),2) confirmation_rate\\nfrom (select r.user_id,r.con,rp.tim from (select user_id,count(*) con from (select * from confirmations where action=\\'confirmed\\') p group by user_id) r\\nfull outer join\\n(select user_id,count(*) tim from (select * from confirmations where action=\\'timeout\\') p group by user_id) rp on r.user_id=rp.user_id) rpj\\nright join\\nsignups s on s.user_id=rpj.user_id\\n;\\n\\n\\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect s.user_id,round(nvl(rpj.con,0)/NVL(NULLIF(nvl(rpj.con,0)+nvl(rpj.tim,0),0), 1),2) confirmation_rate\\nfrom (select r.user_id,r.con,rp.tim from (select user_id,count(*) con from (select * from confirmations where action=\\'confirmed\\') p group by user_id) r\\nfull outer join\\n(select user_id,count(*) tim from (select * from confirmations where action=\\'timeout\\') p group by user_id) rp on r.user_id=rp.user_id) rpj\\nright join\\nsignups s on s.user_id=rpj.user_id\\n;\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4086710,
                "title": "easy-beast-86",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nleft joins\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id, round(coalesce(C.confirmed/(coalesce(T.timeouts, 0) + C.confirmed),0),2) as confirmation_rate\\nfrom Signups s\\nleft join (select \\nuser_id, count(action) as timeouts \\nfrom Confirmations where action = \\'timeout\\'\\nGroup by user_id\\n) as T on s.user_id = T.user_id\\nleft join (Select \\nuser_id, count(action) as confirmed\\nfrom Confirmations where action = \\'confirmed\\'\\nGroup by user_id\\n) as C on C.user_id = s.user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id, round(coalesce(C.confirmed/(coalesce(T.timeouts, 0) + C.confirmed),0),2) as confirmation_rate\\nfrom Signups s\\nleft join (select \\nuser_id, count(action) as timeouts \\nfrom Confirmations where action = \\'timeout\\'\\nGroup by user_id\\n) as T on s.user_id = T.user_id\\nleft join (Select \\nuser_id, count(action) as confirmed\\nfrom Confirmations where action = \\'confirmed\\'\\nGroup by user_id\\n) as C on C.user_id = s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4086154,
                "title": "beats-97-92-solutions",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf you dont have function \"If\" in your dbms.\\n# Complexity\\n- Time complexity: 1121ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id, \\nround(coalesce(sum(case when action=\\'confirmed\\' then 1 else 0 end)/sum(case when action is not null then 1 else null end),0), 2) as confirmation_rate \\nfrom Signups s \\nleft join Confirmations c on s.user_id=c.user_id\\ngroup by s.user_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id, \\nround(coalesce(sum(case when action=\\'confirmed\\' then 1 else 0 end)/sum(case when action is not null then 1 else null end),0), 2) as confirmation_rate \\nfrom Signups s \\nleft join Confirmations c on s.user_id=c.user_id\\ngroup by s.user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4086138,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate\\nfrom Signups as s left join Confirmations as c on s.user_id= c.user_id group by user_id;\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate\\nfrom Signups as s left join Confirmations as c on s.user_id= c.user_id group by user_id;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4085962,
                "title": "pandas-solution-straightforward-but-only-45",
                "content": "# Intuition\\nSQL mindset. Join first, assign values to generated confirmation_rate column. then calculate the average and round.\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef confirmation_rate(signups: pd.DataFrame, confirmations: pd.DataFrame) -> pd.DataFrame:\\n  df = pd.merge(signups, confirmations, how = \\'left\\', on = \\'user_id\\')\\n  df.loc[df[\\'action\\'] == \\'confirmed\\', \\'confirmation_rate\\'] = 1\\n  df.loc[df[\\'action\\'] != \\'confirmed\\', \\'confirmation_rate\\'] = 0\\n  grouped = df[[\\'user_id\\', \\'confirmation_rate\\']].groupby(\\'user_id\\').mean().reset_index().round(2)\\n  return grouped\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef confirmation_rate(signups: pd.DataFrame, confirmations: pd.DataFrame) -> pd.DataFrame:\\n  df = pd.merge(signups, confirmations, how = \\'left\\', on = \\'user_id\\')\\n  df.loc[df[\\'action\\'] == \\'confirmed\\', \\'confirmation_rate\\'] = 1\\n  df.loc[df[\\'action\\'] != \\'confirmed\\', \\'confirmation_rate\\'] = 0\\n  grouped = df[[\\'user_id\\', \\'confirmation_rate\\']].groupby(\\'user_id\\').mean().reset_index().round(2)\\n  return grouped\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4083171,
                "title": "left-join-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT s.user_id, \\nROUND(AVG(CASE\\nWHEN c.action=\\'confirmed\\' THEN 1\\nELSE 0\\nEND),2) AS confirmation_rate\\nFROM Signups s \\nLEFT JOIN Confirmations c\\nON s.user_id=c.user_id\\nGROUP BY user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT s.user_id, \\nROUND(AVG(CASE\\nWHEN c.action=\\'confirmed\\' THEN 1\\nELSE 0\\nEND),2) AS confirmation_rate\\nFROM Signups s \\nLEFT JOIN Confirmations c\\nON s.user_id=c.user_id\\nGROUP BY user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081835,
                "title": "built-using-basics",
                "content": "with table2 as(\\nwith table1 as(\\nselect s.user_id , count(action) over(partition by c.user_id) as tot , case\\nwhen action = \\'timeout\\' then 0\\nwhen action = \\'confirmed\\' then 1\\nend as act\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id)\\nselect distinct user_id , tot, sum(act) over(partition by user_id) as action from table1)\\nselect user_id , round(ifnull(action / tot,0),2) as confirmation_rate\\nfrom table2;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "with table2 as(\\nwith table1 as(\\nselect s.user_id , count(action) over(partition by c.user_id) as tot , case\\nwhen action = \\'timeout\\' then 0\\nwhen action = \\'confirmed\\' then 1\\nend as act\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id)\\nselect distinct user_id , tot, sum(act) over(partition by user_id) as action from table1)\\nselect user_id , round(ifnull(action / tot,0),2) as confirmation_rate\\nfrom table2;",
                "codeTag": "Unknown"
            },
            {
                "id": 4079977,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT t1.user_id,\\n  IFNULL(\\n    ROUND(\\n      (\\n        (SELECT COUNT(t2.user_id) FROM Confirmations t2 WHERE t2.user_id = t1.user_id AND t2.action = \\'confirmed\\') /\\n        (SELECT COUNT(t3.user_id) FROM Confirmations t3 WHERE t3.user_id = t1.user_id)\\n      ),\\n      2  -- Number of decimal places\\n    ),\\n    0\\n  ) AS confirmation_rate\\nFROM Signups t1;\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT t1.user_id,\\n  IFNULL(\\n    ROUND(\\n      (\\n        (SELECT COUNT(t2.user_id) FROM Confirmations t2 WHERE t2.user_id = t1.user_id AND t2.action = \\'confirmed\\') /\\n        (SELECT COUNT(t3.user_id) FROM Confirmations t3 WHERE t3.user_id = t1.user_id)\\n      ),\\n      2  -- Number of decimal places\\n    ),\\n    0\\n  ) AS confirmation_rate\\nFROM Signups t1;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4079397,
                "title": "easiest-way-to-solve-this-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect a.user_id,round(avg(if(b.action = \"confirmed\",1,0)),2) as confirmation_rate\\nfrom Signups a \\nleft join Confirmations b on a.user_id = b.user_id\\ngroup by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect a.user_id,round(avg(if(b.action = \"confirmed\",1,0)),2) as confirmation_rate\\nfrom Signups a \\nleft join Confirmations b on a.user_id = b.user_id\\ngroup by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4079215,
                "title": "left-join-in-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg( CASE WHEN c.action = \\'confirmed\\' THEN 1.0 ELSE 0.0 END),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg( CASE WHEN c.action = \\'confirmed\\' THEN 1.0 ELSE 0.0 END),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078667,
                "title": "sql-left-join-and-group-by",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT \\n    s.user_id, \\n    round(\\n        avg(\\n            CASE\\n                WHEN c.action = \\'confirmed\\' THEN 1.0\\n                ELSE 0.0\\n            END\\n        )\\n        , 2\\n    ) as confirmation_rate\\nFROM Signups AS s\\nLEFT JOIN Confirmations AS c ON c.user_id = s.user_id\\nGROUP BY s.user_id\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n    s.user_id, \\n    round(\\n        avg(\\n            CASE\\n                WHEN c.action = \\'confirmed\\' THEN 1.0\\n                ELSE 0.0\\n            END\\n        )\\n        , 2\\n    ) as confirmation_rate\\nFROM Signups AS s\\nLEFT JOIN Confirmations AS c ON c.user_id = s.user_id\\nGROUP BY s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078618,
                "title": "handle-plsql-not-able-to-divide-by-0",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nwith cte as (\\nselect \\ns.user_id \\n, count(case when c.action = \\'confirmed\\' then c.action end) confirmed\\n, count(c.action) actions \\nfrom signups s left join confirmations c on s.user_id = c.user_id\\ngroup by s.user_id\\n)\\nselect user_id\\n, case when actions = 0 then 0.00 else round(confirmed/actions,2) end confirmation_rate\\nfrom cte\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nwith cte as (\\nselect \\ns.user_id \\n, count(case when c.action = \\'confirmed\\' then c.action end) confirmed\\n, count(c.action) actions \\nfrom signups s left join confirmations c on s.user_id = c.user_id\\ngroup by s.user_id\\n)\\nselect user_id\\n, case when actions = 0 then 0.00 else round(confirmed/actions,2) end confirmation_rate\\nfrom cte\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078227,
                "title": "that-s-hell-of-a-solution-for-me",
                "content": "# Code\\n```\\nWITH conf AS (\\n    SELECT user_id, COUNT(*) AS num\\n    FROM Confirmations \\n    GROUP BY user_id, action\\n    HAVING action = \\'confirmed\\'\\n),\\nwhole AS (\\n    SELECT user_id, COUNT(*) AS num\\n    FROM Signups s LEFT JOIN Confirmations c USING(user_id)\\n    GROUP BY s.user_id\\n)\\n\\nSELECT user_id, ROUND(COALESCE(c.num/w.num,0),2) AS confirmation_rate\\nFROM whole w LEFT JOIN conf c USING (user_id)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nWITH conf AS (\\n    SELECT user_id, COUNT(*) AS num\\n    FROM Confirmations \\n    GROUP BY user_id, action\\n    HAVING action = \\'confirmed\\'\\n),\\nwhole AS (\\n    SELECT user_id, COUNT(*) AS num\\n    FROM Signups s LEFT JOIN Confirmations c USING(user_id)\\n    GROUP BY s.user_id\\n)\\n\\nSELECT user_id, ROUND(COALESCE(c.num/w.num,0),2) AS confirmation_rate\\nFROM whole w LEFT JOIN conf c USING (user_id)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078185,
                "title": "beats-98-56-solutions-2-ways-easy-code-with-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. LEFT JOIN ```Signups``` table with ```Confirmations``` table on ```user_id```.\\n2. GROUP BY ```user_id```.\\n3. To display user_id we can simply use ```user_id``` field from ```Singup``` table.\\n4. To calculate ```confirmation_rate```, we can use below 2 approachs (in a way both are same):\\n    -  1st Approcah: Using ```AVG()```, ```ROUND``` and ```CASE```\\n        -  It counts how many times a user\\'s actions were \\'confirmed\\' (which have a value of 1) and counts how many total actions that user took. Then, it calculates the average of those 1s and 0s, which gives the percentage of \\'confirmed\\' actions. And finally, it rounds that percentage to two decimal places using ```ROUND``` function.\\n        - `ROUND(AVG(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END), 2) as confirmation_rate`\\n        \\n    -  2nd Approcah: Using ```coalesce()```, ```COUNT```, ```ROUND``` and ```CASE```\\n        - Here, we are calulating confirmation rate for a user by finding the ratio of the number of \\'confirmed\\' actions to the total number of actions that user has taken. Also, to handles cases where there are no actions like in case of ```user_id = 6```, ```coalesce``` fuction is being used. Finally, it rounds that percentage to two decimal places using ```ROUND``` function.\\n        - `ROUND(coalesce(COUNT(CASE WHEN c.action = \\'confirmed\\' THEN 1 END)/COUNT(action),0), 2) as confirmation_rate`\\n\\n# Complexity\\n- Time complexity: 1042 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 0.00MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Solution 1\\nSELECT s.user_id, \\n        ROUND(AVG(\\n            CASE \\n                WHEN c.action = \\'confirmed\\' \\n                THEN 1 ELSE 0 \\n            END), 2) as confirmation_rate \\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id\\n\\n# Solution 2\\nSELECT s.user_id, \\n        ROUND(\\n            COALESCE(\\n                COUNT(CASE WHEN c.action = \\'confirmed\\' THEN 1 END)\\n                /COUNT(action),0), 2) \\n        as confirmation_rate \\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```Signups```\n```Confirmations```\n```user_id```\n```user_id```\n```user_id```\n```Singup```\n```confirmation_rate```\n```AVG()```\n```ROUND```\n```CASE```\n```ROUND```\n```coalesce()```\n```COUNT```\n```ROUND```\n```CASE```\n```user_id = 6```\n```coalesce```\n```ROUND```\n```\\n# Solution 1\\nSELECT s.user_id, \\n        ROUND(AVG(\\n            CASE \\n                WHEN c.action = \\'confirmed\\' \\n                THEN 1 ELSE 0 \\n            END), 2) as confirmation_rate \\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id\\n\\n# Solution 2\\nSELECT s.user_id, \\n        ROUND(\\n            COALESCE(\\n                COUNT(CASE WHEN c.action = \\'confirmed\\' THEN 1 END)\\n                /COUNT(action),0), 2) \\n        as confirmation_rate \\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4077706,
                "title": "pandas-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef confirmation_rate(signups: pd.DataFrame, confirmations: pd.DataFrame) -> pd.DataFrame:\\n    df = signups.merge(confirmations, how = \\'left\\', on=\\'user_id\\')\\n    df1 = df.groupby(\\'user_id\\')[\\'action\\'].apply(lambda x: (x ==\\'confirmed\\').sum()/len(x) if not x.empty else 0).round(2).reset_index(name=\\'confirmation_rate\\')\\n    return df1\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef confirmation_rate(signups: pd.DataFrame, confirmations: pd.DataFrame) -> pd.DataFrame:\\n    df = signups.merge(confirmations, how = \\'left\\', on=\\'user_id\\')\\n    df1 = df.groupby(\\'user_id\\')[\\'action\\'].apply(lambda x: (x ==\\'confirmed\\').sum()/len(x) if not x.empty else 0).round(2).reset_index(name=\\'confirmation_rate\\')\\n    return df1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4077020,
                "title": "another-solution",
                "content": "an  easy solution of the novice for novices....\\n  \\n  \\n\\t\\t   select aa.user_id, \\n\\t\\t\\t\\t\\tcase when bb.confirmation_rate is null then 0\\n\\t\\t\\t\\t\\telse bb.confirmation_rate end as confirmation_rate\\n\\t\\t\\tfrom Signups aa\\n\\t\\t\\tleft outer join\\n\\t\\t\\t(\\n\\n\\t\\t\\t\\tselect user_id, \\n\\t\\t\\t\\t\\t   round(nvl(sum(case when action= \\'confirmed\\' then 1 else 0 end)/count(action),0),2) as confirmation_rate\\n\\t\\t\\t\\tfrom Confirmations\\n\\t\\t\\t\\tgroup by user_id\\n\\t\\t\\t) bb\\n\\t\\t\\ton aa.user_id = bb.user_id\\n",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "an  easy solution of the novice for novices....\\n  \\n  \\n\\t\\t   select aa.user_id, \\n\\t\\t\\t\\t\\tcase when bb.confirmation_rate is null then 0\\n\\t\\t\\t\\t\\telse bb.confirmation_rate end as confirmation_rate\\n\\t\\t\\tfrom Signups aa\\n\\t\\t\\tleft outer join\\n\\t\\t\\t(\\n\\n\\t\\t\\t\\tselect user_id, \\n\\t\\t\\t\\t\\t   round(nvl(sum(case when action= \\'confirmed\\' then 1 else 0 end)/count(action),0),2) as confirmation_rate\\n\\t\\t\\t\\tfrom Confirmations\\n\\t\\t\\t\\tgroup by user_id\\n\\t\\t\\t) bb\\n\\t\\t\\ton aa.user_id = bb.user_id\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 4074438,
                "title": "mssql",
                "content": "# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nselect\\n    s.user_id,\\n    round(\\n        case\\n             when isnull(conf,0)+isnull(timeout,0)=0\\n                then 0\\n                else 1.0*conf/(conf+timeout)\\n        end\\n    , 2) as confirmation_rate\\nfrom Signups s\\nleft join (\\n    select\\n        user_id,\\n        sum(case when action=\\'timeout\\' then 1 else 0 end) as timeout,\\n        sum(case when action=\\'confirmed\\' then 1 else 0 end) as conf\\n    from Confirmations\\n    group by user_id\\n) as aa\\non s.user_id=aa.user_id\\n```",
                "solutionTags": [
                    "MS SQL Server",
                    "Database"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nselect\\n    s.user_id,\\n    round(\\n        case\\n             when isnull(conf,0)+isnull(timeout,0)=0\\n                then 0\\n                else 1.0*conf/(conf+timeout)\\n        end\\n    , 2) as confirmation_rate\\nfrom Signups s\\nleft join (\\n    select\\n        user_id,\\n        sum(case when action=\\'timeout\\' then 1 else 0 end) as timeout,\\n        sum(case when action=\\'confirmed\\' then 1 else 0 end) as conf\\n    from Confirmations\\n    group by user_id\\n) as aa\\non s.user_id=aa.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074385,
                "title": "beats-99-32",
                "content": "# Complexity\\n- Time complexity: 1082ms\\n - Space complexity: 0.00MB\\n\\n# Code\\n```\\nSELECT\\n    s.user_id,\\n    IFNULL(ROUND(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/COUNT(*),2),0) AS confirmation_rate\\nFROM signups s\\nLEFT JOIN confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    s.user_id,\\n    IFNULL(ROUND(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/COUNT(*),2),0) AS confirmation_rate\\nFROM signups s\\nLEFT JOIN confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4073621,
                "title": "easy-mysql-solution",
                "content": "\\n\\n# Code\\n```\\nselect s.user_id, \\n-- confirmations\\nround((sum(case when action = \\'confirmed\\' then 1 else 0 end))  \\n/\\n-- total\\n(sum(case when action=\"a\" then 0 else 1 end )),2) as confirmation_rate\\nfrom signups s\\nleft join confirmations c\\nusing(user_id)\\ngroup by s.user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s.user_id, \\n-- confirmations\\nround((sum(case when action = \\'confirmed\\' then 1 else 0 end))  \\n/\\n-- total\\n(sum(case when action=\"a\" then 0 else 1 end )),2) as confirmation_rate\\nfrom signups s\\nleft join confirmations c\\nusing(user_id)\\ngroup by s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072827,
                "title": "sql-query-to-calculate-user-confirmation-rates",
                "content": "# Intuition\\nThe problem involves calculating a confirmation rate for users based on their signups and confirmation actions in a database. We need to join the \"Signups\" and \"Confirmations\" tables and calculate the confirmation rate for each user.\\n\\n# Approach\\nWe\\'ll use a SQL query to join the \"Signups\" table (aliased as \\'s\\') with the \"Confirmations\" table (aliased as \\'c\\') using the \\'user_id\\' as the common key.\\n\\nIn the SELECT statement, we\\'ll calculate the confirmation rate for each user using a CASE statement. If there are confirmation actions (\\'confirmed\\') for a user, we\\'ll calculate the rate as the count of \\'confirmed\\' actions divided by the total count of actions. We\\'ll round the result to two decimal places. If there are no confirmation actions, we\\'ll set the rate to 0.\\n\\nWe\\'ll use DISTINCT to ensure we get only unique user_id and confirmation_rate pairs.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this SQL query depends on the size of the \"Signups\" and \"Confirmations\" tables and the efficiency of the database engine\\'s query execution. In general, it would be $$O(N*M)$$, where N is the number of rows in the \"Signups\" table, and M is the number of rows in the \"Confirmations\" table.\\n\\n- Space complexity:\\nThe space complexity is primarily determined by the memory used to store the result set. In this case, the result set will have a row for each user with their user_id and confirmation_rate, so the space complexity is $$O(N)$$, where N is the number of distinct users in the \"Signups\" table.\\n\\n# Code\\n```\\nSELECT DISTINCT s.user_id,\\n        CASE \\n            WHEN c.action IS NULL THEN 0\\n            WHEN c.action IS NOT NULL THEN ROUND((SELECT count(action)\\n                                          FROM Confirmations\\n                                          WHERE user_id = s.user_id\\n                                          AND action = \\'confirmed\\') / \\n                                          (SELECT count(action)\\n                                           FROM Confirmations\\n                                           WHERE user_id = s.user_id), 2)\\n        END AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id = c.user_id\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT DISTINCT s.user_id,\\n        CASE \\n            WHEN c.action IS NULL THEN 0\\n            WHEN c.action IS NOT NULL THEN ROUND((SELECT count(action)\\n                                          FROM Confirmations\\n                                          WHERE user_id = s.user_id\\n                                          AND action = \\'confirmed\\') / \\n                                          (SELECT count(action)\\n                                           FROM Confirmations\\n                                           WHERE user_id = s.user_id), 2)\\n        END AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id = c.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072700,
                "title": "beats-96-86-of-users-with-mysql",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nwith cte1 as(\\nselect s.user_id, c.action from Signups s left join Confirmations c on s.user_id = c.user_id),\\n\\ncte2 as(\\nselect *,\\ncount(user_id) over(partition by user_id) as cnt,\\n# case when action = \\'timeout\\' then 1 else 0 end as timeout_flag,\\ncase when action = \\'confirmed \\' then 1 else 0 end as conf_flag\\nfrom cte1),\\n\\ncte3 as(\\nselect user_id, round(sum(conf_flag) /count(user_id),2) as confirmation_rate from cte2 group by user_id)\\n\\nselect * from cte3\\n# select user_id, sum(confirmation_rate) as confirmation_rate from cte3 group by user_id\\n# order by confirmation_rate\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith cte1 as(\\nselect s.user_id, c.action from Signups s left join Confirmations c on s.user_id = c.user_id),\\n\\ncte2 as(\\nselect *,\\ncount(user_id) over(partition by user_id) as cnt,\\n# case when action = \\'timeout\\' then 1 else 0 end as timeout_flag,\\ncase when action = \\'confirmed \\' then 1 else 0 end as conf_flag\\nfrom cte1),\\n\\ncte3 as(\\nselect user_id, round(sum(conf_flag) /count(user_id),2) as confirmation_rate from cte2 group by user_id)\\n\\nselect * from cte3\\n# select user_id, sum(confirmation_rate) as confirmation_rate from cte3 group by user_id\\n# order by confirmation_rate\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070733,
                "title": "left-join-group-by-and-coalesce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first count all action per user signup, join and count. \\nsecond, search for confirmed action per user, use case when\\nthird, group by left table field, (Signups.user_id). \\nnote:\\n    it did not work if you group by right table. Confirmations.user_id\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect \\n  s.user_id, \\n  coalesce(\\n    round(sum(\\n      case when c.action = \\'confirmed\\' then 1 else 0 end\\n    ) / count(c.action),2), \\n    0.00\\n  ) confirmation_rate \\nfrom \\n  Signups s \\n  left join Confirmations c on s.user_id = c.user_id \\ngroup by \\n  s.user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect \\n  s.user_id, \\n  coalesce(\\n    round(sum(\\n      case when c.action = \\'confirmed\\' then 1 else 0 end\\n    ) / count(c.action),2), \\n    0.00\\n  ) confirmation_rate \\nfrom \\n  Signups s \\n  left join Confirmations c on s.user_id = c.user_id \\ngroup by \\n  s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070287,
                "title": "99-beats-using-case-and-left-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to create a new column turning \"timeout\" to 0 and \"confirmed\" to 1. Then use COALESCE to turn null into 0 as well. The SUM() function calculate the total number of confirmed case for each user id, and COUNT() function calculate the total number of sign ups for each user id. GROUP at the end to show the outcome\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT s.user_id,\\n  ROUND((SUM(COALESCE(CASE WHEN action IN (\\'timeout\\')\\n    THEN \\'0\\'\\n    WHEN action = \\'confirmed\\'\\n    THEN \\'1\\'\\n  END  ,0))) /\\n  COUNT(s.user_id),2) AS confirmation_rate\\nFROM Signups AS s\\nLEFT JOIN Confirmations As c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT s.user_id,\\n  ROUND((SUM(COALESCE(CASE WHEN action IN (\\'timeout\\')\\n    THEN \\'0\\'\\n    WHEN action = \\'confirmed\\'\\n    THEN \\'1\\'\\n  END  ,0))) /\\n  COUNT(s.user_id),2) AS confirmation_rate\\nFROM Signups AS s\\nLEFT JOIN Confirmations As c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070277,
                "title": "use-case-when-and-left-join",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT s.user_id,\\n  ROUND((SUM(COALESCE(CASE WHEN action IN (\\'timeout\\')\\n    THEN \\'0\\'\\n    WHEN action = \\'confirmed\\'\\n    THEN \\'1\\'\\n  END  ,0))) /\\n  COUNT(s.user_id),2) AS confirmation_rate\\nFROM Signups AS s\\nLEFT JOIN Confirmations As c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT s.user_id,\\n  ROUND((SUM(COALESCE(CASE WHEN action IN (\\'timeout\\')\\n    THEN \\'0\\'\\n    WHEN action = \\'confirmed\\'\\n    THEN \\'1\\'\\n  END  ,0))) /\\n  COUNT(s.user_id),2) AS confirmation_rate\\nFROM Signups AS s\\nLEFT JOIN Confirmations As c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070087,
                "title": "case-count-group-with-cte",
                "content": "# Intuition\\n The idea is to create a new table that has everybody\\'s confirmation rate with the use of CTE\\n\\n# Approach\\n\\n- `Count (user_id)` to find out how many requests made by each `user_id`\\n- then use `count` with a `case` to find out the number of confirmed sessions\\n- Divide the two in a new column to to find the confirmation_rate\\n\\n# Complexity\\n- Time complexity:\\n99.7% better\\n\\n- Space complexity:\\n0 MBS\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n-- find confirmation rate of each user \\n\\nwith details as (\\nselect user_id, \\n       count(user_id) as no_of_requests, \\n      -- count(case when action =\\'timeout\\' then 0 end) as no_timeout,\\n       count(case when action =\\'confirmed\\' then 1 end) as no_confirmed,\\n       round(count(case when action =\\'confirmed\\' then 1 end)  / count(user_id),2) as confirmation_rate\\n\\nfrom confirmations \\ngroup by 1\\n\\n) select s.user_id\\n         ,case when confirmation_rate is null then 0 else confirmation_rate end as confirmation_rate\\n\\n   from signups s\\n   left join details d\\n   on s.user_id = d.user_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n-- find confirmation rate of each user \\n\\nwith details as (\\nselect user_id, \\n       count(user_id) as no_of_requests, \\n      -- count(case when action =\\'timeout\\' then 0 end) as no_timeout,\\n       count(case when action =\\'confirmed\\' then 1 end) as no_confirmed,\\n       round(count(case when action =\\'confirmed\\' then 1 end)  / count(user_id),2) as confirmation_rate\\n\\nfrom confirmations \\ngroup by 1\\n\\n) select s.user_id\\n         ,case when confirmation_rate is null then 0 else confirmation_rate end as confirmation_rate\\n\\n   from signups s\\n   left join details d\\n   on s.user_id = d.user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4069585,
                "title": "ms-sql-server-solution",
                "content": "SELECT s.user_id, ROUND(SUM(CAST(IIF(c.action = \\'confirmed\\',1,0) AS FLOAT)) / CAST(COUNT(s.user_id) AS FLOAT), 2) AS confirmation_rate FROM Signups s\\nLEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id;",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "SELECT s.user_id, ROUND(SUM(CAST(IIF(c.action = \\'confirmed\\',1,0) AS FLOAT)) / CAST(COUNT(s.user_id) AS FLOAT), 2) AS confirmation_rate FROM Signups s\\nLEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id;",
                "codeTag": "Unknown"
            },
            {
                "id": 4065724,
                "title": "confirmation-rate-solution-in-sql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nROUND & AVG keywords\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(M)\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT S.USER_ID, ROUND(AVG(IF(C.ACTION = \"CONFIRMED\", 1, 0)), 2) AS CONFIRMATION_RATE\\nFROM SIGNUPS S\\nLEFT JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\nGROUP BY USER_ID\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/0c7be364-2a58-4c35-bbb0-9a795c37c3e9_1695147832.9752522.jpeg)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT S.USER_ID, ROUND(AVG(IF(C.ACTION = \"CONFIRMED\", 1, 0)), 2) AS CONFIRMATION_RATE\\nFROM SIGNUPS S\\nLEFT JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\nGROUP BY USER_ID\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4064165,
                "title": "96-beats-using-only-left-join",
                "content": "\\n# Approach\\nLeft Join signups table with confirmation table. However, we create confirmation table twice, one for calculating total number of success (here confirmations) and another for calculating the total number of requests. The Coalesce function is applied so as to return confirmation_rate as zero when there is no confirmation at all.\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id, Coalesce(round(T.number_confirmed/U.total_requested, 2),0) as confirmation_rate\\nfrom Signups s Left Join (select user_id, count(*) as number_confirmed from Confirmations where action = \\'confirmed\\' group by user_id) T on s.user_id = T.user_id Left Join (select user_id, count(*) as total_requested from Confirmations group by user_id) as U on s.user_id = U.user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id, Coalesce(round(T.number_confirmed/U.total_requested, 2),0) as confirmation_rate\\nfrom Signups s Left Join (select user_id, count(*) as number_confirmed from Confirmations where action = \\'confirmed\\' group by user_id) T on s.user_id = T.user_id Left Join (select user_id, count(*) as total_requested from Confirmations group by user_id) as U on s.user_id = U.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4063186,
                "title": "mysql-solution-beats-97-75",
                "content": "# Approach\\nFirst we **left** join Signups and Confirmations, then we substitute the `timeout`, `null` and `confirmed` in `Confirmations` for `0` and `1`.\\n\\nThen we round the average of action (1s and 0s) to 2 decimals.\\nWe group by userid when averaging.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT user_id, ROUND(AVG(action), 2) AS confirmation_rate FROM (\\n  SELECT Signups.user_id, CASE WHEN action = \\'confirmed\\' THEN 1 ELSE 0 END AS action FROM Signups\\n  LEFT JOIN Confirmations ON Confirmations.user_id = Signups.user_id\\n) AS t\\nGROUP BY user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT user_id, ROUND(AVG(action), 2) AS confirmation_rate FROM (\\n  SELECT Signups.user_id, CASE WHEN action = \\'confirmed\\' THEN 1 ELSE 0 END AS action FROM Signups\\n  LEFT JOIN Confirmations ON Confirmations.user_id = Signups.user_id\\n) AS t\\nGROUP BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062999,
                "title": "using-cte",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nWith nom as (Select user_id, count(*) as usercount from Confirmations where action = \\'confirmed\\' group by user_id),\\ndenom as (Select user_id, count(*) as totalcount from Confirmations group by user_id),\\nconf_rate as (Select nom.user_id ,  usercount/totalcount as rate from nom join denom on nom.user_id = denom.user_id)\\nSelect s.user_id , case when c.rate is null then 0.00 else round(c.rate,2) end as confirmation_rate\\nfrom Signups s \\nleft join conf_rate c on s.user_id = c.user_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWith nom as (Select user_id, count(*) as usercount from Confirmations where action = \\'confirmed\\' group by user_id),\\ndenom as (Select user_id, count(*) as totalcount from Confirmations group by user_id),\\nconf_rate as (Select nom.user_id ,  usercount/totalcount as rate from nom join denom on nom.user_id = denom.user_id)\\nSelect s.user_id , case when c.rate is null then 0.00 else round(c.rate,2) end as confirmation_rate\\nfrom Signups s \\nleft join conf_rate c on s.user_id = c.user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4061702,
                "title": "top-90-simple-solution-with-left-join",
                "content": "# Explanation\\nFirst we are selecting the user id since we want to know the confirmation rate of each user. Then we select the rounded average of whether or not the action is confirmed in the confirmations table. If the action is confirmed, we return 1, otherwise zero. This list of numbers is what we are taking the average of. We use LEFT JOIN between the Signups table and Confirmations table on the user id. Then we group by user id to get ony one result for every user_id. **Make sure to like if you found this useful**.\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT s.user_id, ROUND(AVG(if(c.action = \\'confirmed\\', 1, 0)), 2) AS confirmation_rate\\nFROM Signups AS s LEFT JOIN Confirmations AS c ON s.user_id = c.user_id\\nGROUP BY user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT s.user_id, ROUND(AVG(if(c.action = \\'confirmed\\', 1, 0)), 2) AS confirmation_rate\\nFROM Signups AS s LEFT JOIN Confirmations AS c ON s.user_id = c.user_id\\nGROUP BY user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4060723,
                "title": "simple-soln-using-grp-by-left-join-and-avg-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id,ifnull(round(avg(action=\\'confirmed\\'),2),0) confirmation_rate from signups s left join confirmations c on c.user_id=s.user_id group by s.user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id,ifnull(round(avg(action=\\'confirmed\\'),2),0) confirmation_rate from signups s left join confirmations c on c.user_id=s.user_id group by s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4060143,
                "title": "easy-solution-using-aggregation-and-left-joins",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect Signups.user_id,  ROUND(AVG(IF(Confirmations.action=\\'confirmed\\',1,0)),2) as confirmation_rate  from Signups left join Confirmations  on Signups.user_id=Confirmations.user_id\\ngroup by Signups.user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect Signups.user_id,  ROUND(AVG(IF(Confirmations.action=\\'confirmed\\',1,0)),2) as confirmation_rate  from Signups left join Confirmations  on Signups.user_id=Confirmations.user_id\\ngroup by Signups.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4059947,
                "title": "simple-beginner-friendly-using-temp-table-beats-80-of-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create a temp table from Confimations containing user_id and count of confirmed actions.\\n2. Left join signups and temp table on user_id and divide confirmed count by total count.\\n3. Used coalesce to handle null values and round to make output up to two decimal places\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith cnf as (\\n  select user_id, case when action = \\'confirmed\\' then 1 else 0 end as cnt\\n  from Confirmations\\n)\\nselect s.user_id, round(coalesce(sum(cnt) / count(1), 0),2) as confirmation_rate\\nfrom Signups s\\nleft join cnf c\\non s.user_id = c.user_id\\ngroup by s.user_id\\n\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith cnf as (\\n  select user_id, case when action = \\'confirmed\\' then 1 else 0 end as cnt\\n  from Confirmations\\n)\\nselect s.user_id, round(coalesce(sum(cnt) / count(1), 0),2) as confirmation_rate\\nfrom Signups s\\nleft join cnf c\\non s.user_id = c.user_id\\ngroup by s.user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057047,
                "title": "beats-99-69",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith t as(\\nSELECT c.user_id as c_user,s.user_id as s_user, (case when action =\"timeout\" THEN \\'0\\'\\n                        when action =\"confirmed\" THEN \\'1\\' \\n                     END) AS cr\\nFROM signups s\\nleft join confirmations c\\nON s.user_id = c.user_id)\\n\\nSELECT s_user AS user_id , ifnull(ROUND(sum(cr)/count(c_user),2),0) as confirmation_rate\\nfrom t\\ngroup by s_user\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith t as(\\nSELECT c.user_id as c_user,s.user_id as s_user, (case when action =\"timeout\" THEN \\'0\\'\\n                        when action =\"confirmed\" THEN \\'1\\' \\n                     END) AS cr\\nFROM signups s\\nleft join confirmations c\\nON s.user_id = c.user_id)\\n\\nSELECT s_user AS user_id , ifnull(ROUND(sum(cr)/count(c_user),2),0) as confirmation_rate\\nfrom t\\ngroup by s_user\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4056955,
                "title": "using-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect s.user_id,CASE WHEN c.time_stamp IS NULL THEN 0.00\\nELSE Round(SUM(c.action=\\'confirmed\\')/count(*),2) END AS confirmation_rate\\nFrom signups s\\nleft join confirmations c\\non s.user_id=c.user_id\\ngroup by user_id \\nORDER BY  USER_id DESC\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s.user_id,CASE WHEN c.time_stamp IS NULL THEN 0.00\\nELSE Round(SUM(c.action=\\'confirmed\\')/count(*),2) END AS confirmation_rate\\nFrom signups s\\nleft join confirmations c\\non s.user_id=c.user_id\\ngroup by user_id \\nORDER BY  USER_id DESC\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4056568,
                "title": "easiest-way-to-solve-using-window-function",
                "content": "\\n\\n# Code\\n```\\nSELECT distinct a.user_id,\\n       ROUND(AVG(CASE WHEN b.action = \\'confirmed\\' THEN 1 ELSE 0 END)\\n          OVER (PARTITION BY user_id),2) AS confirmation_rate\\nFROM signups a\\nLEFT JOIN confirmations b ON a.user_id = b.user_id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT distinct a.user_id,\\n       ROUND(AVG(CASE WHEN b.action = \\'confirmed\\' THEN 1 ELSE 0 END)\\n          OVER (PARTITION BY user_id),2) AS confirmation_rate\\nFROM signups a\\nLEFT JOIN confirmations b ON a.user_id = b.user_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055431,
                "title": "sql-beats-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith conf_rate as (select c.user_id, \\n\\n ( \\n     \\n    ROUND(( COUNT(CASE WHEN c.action = \\'confirmed\\' THEN c.user_id END )\\n     / (COUNT(c.user_id) ) ) , 2)\\n \\n \\n ) AS confirmation_rate\\nfrom Confirmations c\\nGROUP BY c.user_id\\n\\n\\n)\\n\\nselect s.user_id, IFNULL(cr.confirmation_rate, 0) AS confirmation_rate from Signups s\\nleft OUTER JOIN conf_rate cr on cr.user_id = s.user_id \\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith conf_rate as (select c.user_id, \\n\\n ( \\n     \\n    ROUND(( COUNT(CASE WHEN c.action = \\'confirmed\\' THEN c.user_id END )\\n     / (COUNT(c.user_id) ) ) , 2)\\n \\n \\n ) AS confirmation_rate\\nfrom Confirmations c\\nGROUP BY c.user_id\\n\\n\\n)\\n\\nselect s.user_id, IFNULL(cr.confirmation_rate, 0) AS confirmation_rate from Signups s\\nleft OUTER JOIN conf_rate cr on cr.user_id = s.user_id \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055097,
                "title": "beats-100-00-join-case-when-statement",
                "content": "# Code\\n\\n\\n```sql []\\nselect\\na.user_id,\\nround(coalesce(sum(\\n        case when b.action = \\'confirmed\\' \\n            then 1 \\n          else 0 \\n        end)/count(b.action), 0),2) as confirmation_rate \\nfrom\\nSignups a\\nleft join Confirmations b\\non a.user_id = b.user_id\\ngroup by a.user_id\\norder by 1\\n```\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql []\\nselect\\na.user_id,\\nround(coalesce(sum(\\n        case when b.action = \\'confirmed\\' \\n            then 1 \\n          else 0 \\n        end)/count(b.action), 0),2) as confirmation_rate \\nfrom\\nSignups a\\nleft join Confirmations b\\non a.user_id = b.user_id\\ngroup by a.user_id\\norder by 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4054342,
                "title": "simple-approach-without-using-cte",
                "content": "# Code\\n```\\nselect s.user_id, \\nround(sum(case \\nwhen c.action = \\'confirmed\\'\\nthen 1 else 0 end)/count(*),2) as confirmation_rate\\nfrom signups s\\nleft join confirmations c on c.user_id=s.user_id\\ngroup by user_id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s.user_id, \\nround(sum(case \\nwhen c.action = \\'confirmed\\'\\nthen 1 else 0 end)/count(*),2) as confirmation_rate\\nfrom signups s\\nleft join confirmations c on c.user_id=s.user_id\\ngroup by user_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4053821,
                "title": "explanation-and-solution-beats-100",
                "content": "\\n# Approach\\nUsing IFNULL to detect Null values in the confirmation_rate and replace it with 0.\\n\\nAction = \"confirmed\" finds all \"confirmed\" action and avg() counts the average of it after that I rounded them to 2 decimal place by Round(avg(),2) to satisfied the required result and test cases.\\n\\nGroup by user_id so it did not show any duplication of the user_id\\n\\n# Code\\n```\\nSelect S.user_id, IFNULL(Round(avg(action = \"confirmed\"),2),0) as confirmation_rate\\nFrom Signups as S\\nLeft Join Confirmations as C On S.user_id = C.user_id\\nGroup by S.user_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect S.user_id, IFNULL(Round(avg(action = \"confirmed\"),2),0) as confirmation_rate\\nFrom Signups as S\\nLeft Join Confirmations as C On S.user_id = C.user_id\\nGroup by S.user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4053655,
                "title": "confirmation-rate-mysql",
                "content": "\\n\\n# Approach\\nPlease upvote if you like the approach\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect user_id, round(sum(action_confirmed)/count(action),2) as confirmation_rate\\nFrom (\\nselect s.user_id,\\ncase when action=\\'confirmed\\' then 1  \\n     when NULLIF(c.action, 0.00) IS NULL then 0 \\n     else 0 end as action_confirmed , \\ncase when action is null then 0 else action end as action\\nfrom Signups s left join Confirmations c on s.user_id=c.user_id \\n)a\\ngroup by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect user_id, round(sum(action_confirmed)/count(action),2) as confirmation_rate\\nFrom (\\nselect s.user_id,\\ncase when action=\\'confirmed\\' then 1  \\n     when NULLIF(c.action, 0.00) IS NULL then 0 \\n     else 0 end as action_confirmed , \\ncase when action is null then 0 else action end as action\\nfrom Signups s left join Confirmations c on s.user_id=c.user_id \\n)a\\ngroup by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4053223,
                "title": "beats-83-easy-solution-using-left-join-case-statement",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n\\nSELECT \\n  s.user_id,\\n  ROUND(SUM(CASE \\n              WHEN action = \"timeout\" OR action IS NULL \\n              THEN 0 ELSE 1 END)/COUNT(*),2) AS confirmation_rate \\nFROM signups s\\nLEFT JOIN confirmations c\\nON s.user_id = c.user_id\\nGROUP BY 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\nSELECT \\n  s.user_id,\\n  ROUND(SUM(CASE \\n              WHEN action = \"timeout\" OR action IS NULL \\n              THEN 0 ELSE 1 END)/COUNT(*),2) AS confirmation_rate \\nFROM signups s\\nLEFT JOIN confirmations c\\nON s.user_id = c.user_id\\nGROUP BY 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4052999,
                "title": "99-13-beats-using-subquery",
                "content": "\\n# Code\\n```\\nSELECT s.user_id, ROUND(COALESCE(cr.confirmation_rate, 0),2) AS confirmation_rate\\nFROM\\n(SELECT cc.user_id, (cc.total_confirmed/ca.total_action) AS confirmation_rate\\nFROM (SELECT user_id, COUNT(user_id) AS total_action \\n      FROM confirmations\\n      GROUP BY user_id) AS ca\\nINNER JOIN (SELECT user_id, action, COUNT(action) AS total_confirmed \\n            FROM confirmations\\n            WHERE action = \"confirmed\"\\n            GROUP BY user_id, action) AS cc\\nON ca.user_id = cc.user_id\\nGROUP BY cc.user_id) AS cr\\nRIGHT JOIN signups s\\nON s.user_id = cr.user_id\\nORDER BY confirmation_rate ASC\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT s.user_id, ROUND(COALESCE(cr.confirmation_rate, 0),2) AS confirmation_rate\\nFROM\\n(SELECT cc.user_id, (cc.total_confirmed/ca.total_action) AS confirmation_rate\\nFROM (SELECT user_id, COUNT(user_id) AS total_action \\n      FROM confirmations\\n      GROUP BY user_id) AS ca\\nINNER JOIN (SELECT user_id, action, COUNT(action) AS total_confirmed \\n            FROM confirmations\\n            WHERE action = \"confirmed\"\\n            GROUP BY user_id, action) AS cc\\nON ca.user_id = cc.user_id\\nGROUP BY cc.user_id) AS cr\\nRIGHT JOIN signups s\\nON s.user_id = cr.user_id\\nORDER BY confirmation_rate ASC\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049851,
                "title": "cte-method-99-6",
                "content": "# Intuition\\nUse CTE (Common Table Expression) to create temporary tables and make queries on these tables.\\n\\n# Approach\\n- `ct` table: count the numbers of each user\\'s confirmed messages.\\n- `tt` table: count the numbers of each user\\'s total messages.\\n- `cf` table: calculate the confirmation_rate of each user.\\n- Finally, `signups` left join `cf` to collect all users\\' id, and used CASE to fill out the NULL one with 0.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nWITH ct AS (SELECT user_id, action, COUNT(*) AS num\\n        FROM confirmations\\n        WHERE action = \\'confirmed\\'\\n        GROUP BY user_id, action),\\n     tt AS (SELECT user_id, COUNT(*) AS total\\n        FROM confirmations\\n        GROUP BY user_id),\\n     cf AS (SELECT ct.user_id AS user_id, ROUND(ct.num / tt.total,2) AS rate\\n        FROM ct\\n        JOIN tt\\n        ON ct.user_id = tt.user_id)\\n\\nSELECT s.user_id AS user_id,\\n        CASE \\n            WHEN cf.rate IS NULL THEN 0 \\n            ELSE cf.rate \\n        END AS confirmation_rate\\nFROM signups s\\nLEFT JOIN cf\\nON s.user_id = cf.user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWITH ct AS (SELECT user_id, action, COUNT(*) AS num\\n        FROM confirmations\\n        WHERE action = \\'confirmed\\'\\n        GROUP BY user_id, action),\\n     tt AS (SELECT user_id, COUNT(*) AS total\\n        FROM confirmations\\n        GROUP BY user_id),\\n     cf AS (SELECT ct.user_id AS user_id, ROUND(ct.num / tt.total,2) AS rate\\n        FROM ct\\n        JOIN tt\\n        ON ct.user_id = tt.user_id)\\n\\nSELECT s.user_id AS user_id,\\n        CASE \\n            WHEN cf.rate IS NULL THEN 0 \\n            ELSE cf.rate \\n        END AS confirmation_rate\\nFROM signups s\\nLEFT JOIN cf\\nON s.user_id = cf.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049301,
                "title": "oracle-solution-with-egg-functions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect \\n    s.user_id, nvl(c.con_rate,0) confirmation_rate \\nfrom \\n    Signups s \\n    left join \\n    (select user_id, \\n    round(sum(decode(action, \\'confirmed\\', 1, 0)) / count(action),2) con_rate\\n    from Confirmations\\n    group by user_id\\n    ) c\\non s.user_id = c.user_id\\n\\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect \\n    s.user_id, nvl(c.con_rate,0) confirmation_rate \\nfrom \\n    Signups s \\n    left join \\n    (select user_id, \\n    round(sum(decode(action, \\'confirmed\\', 1, 0)) / count(action),2) con_rate\\n    from Confirmations\\n    group by user_id\\n    ) c\\non s.user_id = c.user_id\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047854,
                "title": "case-coalesce-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> work out the columns needed to calculate the rate, so count of actions per user, count of confirmations per user.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT s.user_id,\\ncoalesce(ROUND((SUM(CASE\\n              WHEN action = \\'confirmed\\' THEN 1.00\\n              ELSE 0.00\\n            END)/COUNT(c.action)), 2), 0)AS confirmation_rate\\nFROM Confirmations c\\nRIGHT JOIN Signups s\\nON c.user_id = s.user_id\\nGROUP BY s.user_id\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT s.user_id,\\ncoalesce(ROUND((SUM(CASE\\n              WHEN action = \\'confirmed\\' THEN 1.00\\n              ELSE 0.00\\n            END)/COUNT(c.action)), 2), 0)AS confirmation_rate\\nFROM Confirmations c\\nRIGHT JOIN Signups s\\nON c.user_id = s.user_id\\nGROUP BY s.user_id\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4046584,
                "title": "simple-and-intuitive-mysql-code-beats-91",
                "content": "## Intuition\\n- Simply merge two tables by user_id\\n- By definition,  the confirmation rate is the number of \\'confirmed\\' messages divided by the total number of requested confirmation messages. \\n- We can separately calculate \\n    - the number of \\'confirmed\\' messages by ``` sum(if(action = \\'confirmed\\',1,0) ```\\n    - the total number of requested confirmation messages by ```count(action)```\\n- The very last thing is simply to divided these two numbers: ``` sum(if(action = \\'confirmed\\',1,0))/count(action) ```\\n### Additional notes\\n- Use COALESCE function to capture the cases where the total number of requests is 0\\n- round the confirmation rate to two digits using ROUND function \\n\\n\\n# Hope you like it!!!\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id, round(COALESCE(sum(if(action = \\'confirmed\\',1,0))/count(action),0),2) as confirmation_rate from signups as s\\nleft join confirmations as c \\non s.user_id = c.user_id\\ngroup by s.user_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "``` sum(if(action = \\'confirmed\\',1,0) ```\n```count(action)```\n``` sum(if(action = \\'confirmed\\',1,0))/count(action) ```\n```\\n# Write your MySQL query statement below\\nselect s.user_id, round(COALESCE(sum(if(action = \\'confirmed\\',1,0))/count(action),0),2) as confirmation_rate from signups as s\\nleft join confirmations as c \\non s.user_id = c.user_id\\ngroup by s.user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4043949,
                "title": "not-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect user_id , round(sum(x)/count(user_id),2) confirmation_rate from (\\n     select s.user_id, action,\\n         ( CASE\\n          when action = \\'confirmed\\' then 1 else 0 end) x\\n     from Signups s left join Confirmations C \\n    on s.user_id = c.user_id) a\\ngroup by user_id\\norder by confirmation_rate\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect user_id , round(sum(x)/count(user_id),2) confirmation_rate from (\\n     select s.user_id, action,\\n         ( CASE\\n          when action = \\'confirmed\\' then 1 else 0 end) x\\n     from Signups s left join Confirmations C \\n    on s.user_id = c.user_id) a\\ngroup by user_id\\norder by confirmation_rate\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4043139,
                "title": "mysql-solution",
                "content": "# Code\\n```\\nwith ft as (\\n    select s.user_id, action\\n    from Signups s\\n    left join Confirmations c\\n    on s.user_id = c.user_id\\n)\\nselect user_id, \\n    round(avg(if(action = \\'confirmed\\', 1, 0)), 2) as confirmation_rate\\nfrom ft\\ngroup by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith ft as (\\n    select s.user_id, action\\n    from Signups s\\n    left join Confirmations c\\n    on s.user_id = c.user_id\\n)\\nselect user_id, \\n    round(avg(if(action = \\'confirmed\\', 1, 0)), 2) as confirmation_rate\\nfrom ft\\ngroup by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4040249,
                "title": "97-04-beats-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect s.user_id,round(sum(case when action = \\'confirmed\\' then 1 else 0 end)/count(s.user_id),2) as confirmation_rate\\nfrom signups s\\nleft join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect s.user_id,round(sum(case when action = \\'confirmed\\' then 1 else 0 end)/count(s.user_id),2) as confirmation_rate\\nfrom signups s\\nleft join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4039419,
                "title": "sql-if-xxx-1-0-0-0",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(if(c.action=\\'confirmed\\', 1, 0)), 2) as confirmation_rate\\nfrom signups as s\\nleft join confirmations as c\\non s.user_id = c.user_id\\ngroup by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(if(c.action=\\'confirmed\\', 1, 0)), 2) as confirmation_rate\\nfrom signups as s\\nleft join confirmations as c\\non s.user_id = c.user_id\\ngroup by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4039417,
                "title": "sql-case-when-xxx-then-x-else-y-end",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(case when action = \\'confirmed\\' then 1.00 else 0.00 end), 2) as confirmation_rate\\nfrom signups as s\\nleft join confirmations as c\\non s.user_id = c.user_id\\ngroup by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(case when action = \\'confirmed\\' then 1.00 else 0.00 end), 2) as confirmation_rate\\nfrom signups as s\\nleft join confirmations as c\\non s.user_id = c.user_id\\ngroup by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4038274,
                "title": "beats-91-80-very-simple-mysql-querry-with-end-to-end-code-breakdown-explanation",
                "content": "# Intuition\\n1. **Main Query Structure:**\\n   - Your main query starts with a SELECT statement to retrieve specific columns from your result set.\\n   - You\\'re selecting `T1.USER_ID` (from the Signups table) and a calculated value `IFNULL(ROUND(T2.CONFIRMATION_RATE, 2), 0)` as `CONFIRMATION_RATE`.\\n\\n2. **The Subquery (T2):**\\n   - The subquery calculates the confirmation rate for each user in the Confirmations table. It groups the data by `USER_ID`.\\n   - Inside the subquery:\\n     - You use a conditional SUM to count the number of \\'confirmed\\' actions for each user.\\n     - You use COUNT to count all actions (both \\'confirmed\\' and \\'timeout\\') for each user.\\n     - You calculate the confirmation rate by dividing the count of \\'confirmed\\' actions by the total count of actions. The `IFNULL` function handles the case where a user didn\\'t have any actions, setting their rate to 0.\\n\\n3. **Left Join (T1 LEFT JOIN T2):**\\n   - You perform a LEFT JOIN between the Signups table (`T1`) and the subquery result (`T2`) using the `USER_ID` column as the joining condition.\\n   - This LEFT JOIN ensures that all users from the Signups table are included in the result, even if they didn\\'t have any confirmation actions in the Confirmations table.\\n\\n4. **Rounding and Handling NULLs:**\\n   - The `ROUND` function rounds the `CONFIRMATION_RATE` to two decimal places.\\n   - The `IFNULL` function ensures that users who didn\\'t have any confirmation actions (resulting in NULL in the subquery) have their `CONFIRMATION_RATE` set to 0 in the final result.\\n\\nOverall, your SQL code is well-structured and efficiently calculates the confirmation rate for each user, rounding it to two decimal places, and handling cases where users had no confirmation actions. It produces a result that meets the requirements of the problem statement.\\n\\n# Approach\\n1. **Main Query Structure:**\\n   - Your main query begins with a SELECT statement to specify the columns you want in the result.\\n   - You\\'re selecting `T1.USER_ID` from the Signups table and a calculated value `IFNULL(ROUND(T2.CONFIRMATION_RATE, 2), 0)` as `CONFIRMATION_RATE`.\\n\\n2. **Subquery for Confirmation Rates (T2):**\\n   - Inside the subquery:\\n     - You calculate the confirmation rate for each user in the Confirmations table.\\n     - The subquery groups the data by `USER_ID`, creating a separate calculation for each user.\\n     - You use a conditional SUM to count the number of \\'confirmed\\' actions for each user.\\n     - You use COUNT to count all actions (both \\'confirmed\\' and \\'timeout\\') for each user.\\n     - You calculate the confirmation rate by dividing the count of \\'confirmed\\' actions by the total count of actions.\\n     - The `IFNULL` function handles cases where a user didn\\'t have any actions, setting their rate to 0.\\n\\n3. **Left Join (T1 LEFT JOIN T2):**\\n   - You perform a LEFT JOIN operation between the Signups table (`T1`) and the subquery result (`T2`) using the `USER_ID` column as the joining condition.\\n   - This LEFT JOIN ensures that all users from the Signups table are included in the result, even if they didn\\'t have any confirmation actions in the Confirmations table.\\n\\n4. **Rounding and Handling NULLs:**\\n   - In the SELECT statement, you apply the `ROUND` function to round the `CONFIRMATION_RATE` to two decimal places.\\n   - The `IFNULL` function is used to handle cases where users had no confirmation actions in the subquery, which would result in NULL values. In such cases, their `CONFIRMATION_RATE` is set to 0 in the final result.\\n\\nThis approach efficiently calculates the confirmation rate for each user, rounds it to two decimal places, and ensures that users without any confirmation actions are considered with a confirmation rate of 0. The query structure is well-organized and meets the requirements of the problem statement.\\n\\n# Complexity\\nThe complexity of your SQL query can be analyzed in terms of time and space complexity:\\n\\n1. **Time Complexity**:\\n\\n   - **Subquery**: The subquery calculates the confirmation rate for each user by grouping and aggregating data from the Confirmations table. The time complexity of this subquery is O(N), where N is the number of rows in the Confirmations table.\\n\\n   - **Join Operation**: The LEFT JOIN operation between the Signups table and the subquery result also has a time complexity of O(N), where N is the number of rows in the Signups table.\\n\\n   - **Overall Time Complexity**: The overall time complexity of your query is primarily determined by the subquery and the join operation. It is O(N) in the worst case, where N is the number of rows in the larger of the two tables (Confirmations or Signups).\\n\\n2. **Space Complexity**:\\n\\n   - **Subquery Result**: The subquery result includes the calculated confirmation rates for each user. The space complexity of storing this result is also O(N), where N is the number of distinct users.\\n\\n   - **Final Result**: The final result of your query consists of the user IDs and their corresponding confirmation rates, which is also O(N) in terms of space complexity.\\n\\nIn summary, your SQL query has a time complexity of O(N) and a space complexity of O(N), where N represents the number of distinct users in the dataset. The query efficiently processes the data to calculate the confirmation rates while using memory proportional to the number of distinct users.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT T1.USER_ID, IFNULL(ROUND(T2.CONFIRMATION_RATE,2), 0) AS CONFIRMATION_RATE\\nFROM\\n  SIGNUPS T1 LEFT JOIN (\\n              SELECT\\n                USER_ID,\\n                IFNULL(SUM(CASE WHEN ACTION=\\'CONFIRMED\\' THEN 1 ELSE 0 END) / COUNT(USER_ID), 0) AS CONFIRMATION_RATE\\n              FROM\\n                CONFIRMATIONS\\n              GROUP BY\\n                USER_ID\\n  )T2\\n  USING(USER_ID)\\n;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT T1.USER_ID, IFNULL(ROUND(T2.CONFIRMATION_RATE,2), 0) AS CONFIRMATION_RATE\\nFROM\\n  SIGNUPS T1 LEFT JOIN (\\n              SELECT\\n                USER_ID,\\n                IFNULL(SUM(CASE WHEN ACTION=\\'CONFIRMED\\' THEN 1 ELSE 0 END) / COUNT(USER_ID), 0) AS CONFIRMATION_RATE\\n              FROM\\n                CONFIRMATIONS\\n              GROUP BY\\n                USER_ID\\n  )T2\\n  USING(USER_ID)\\n;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035082,
                "title": "99-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT\\n    s.user_id, ROUND(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/(COUNT(*)),2) AS confirmation_rate\\nFROM\\n    Signups s LEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id\\nORDER BY confirmation_rate\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    s.user_id, ROUND(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/(COUNT(*)),2) AS confirmation_rate\\nFROM\\n    Signups s LEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id\\nORDER BY confirmation_rate\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035075,
                "title": "using-left-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate\\nfrom Signups as s \\nleft join Confirmations as c \\non s.user_id= c.user_id \\ngroup by user_id;\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate\\nfrom Signups as s \\nleft join Confirmations as c \\non s.user_id= c.user_id \\ngroup by user_id;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035000,
                "title": "this-is-the-correct-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nSELECT Table1.USER_ID,\\nROUND(AVG(CASE WHEN Table2.ACTION = \\'confirmed\\' THEN 1.00 ELSE 0.00 END), 2) AS CONFIRMATION_RATE\\nFROM SIGNUPS Table1\\nleft JOIN\\nCONFIRMATIONS Table2\\nON Table1.USER_ID = Table2.USER_ID\\nGROUP BY Table1.USER_ID;\\n\\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n\\nSELECT Table1.USER_ID,\\nROUND(AVG(CASE WHEN Table2.ACTION = \\'confirmed\\' THEN 1.00 ELSE 0.00 END), 2) AS CONFIRMATION_RATE\\nFROM SIGNUPS Table1\\nleft JOIN\\nCONFIRMATIONS Table2\\nON Table1.USER_ID = Table2.USER_ID\\nGROUP BY Table1.USER_ID;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034999,
                "title": "this-is-the-correct-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nSELECT Table1.USER_ID,\\nROUND(AVG(CASE WHEN Table2.ACTION = \\'confirmed\\' THEN 1.00 ELSE 0.00 END), 2) AS CONFIRMATION_RATE\\nFROM SIGNUPS Table1\\nleft JOIN\\nCONFIRMATIONS Table2\\nON Table1.USER_ID = Table2.USER_ID\\nGROUP BY Table1.USER_ID;\\n\\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n\\nSELECT Table1.USER_ID,\\nROUND(AVG(CASE WHEN Table2.ACTION = \\'confirmed\\' THEN 1.00 ELSE 0.00 END), 2) AS CONFIRMATION_RATE\\nFROM SIGNUPS Table1\\nleft JOIN\\nCONFIRMATIONS Table2\\nON Table1.USER_ID = Table2.USER_ID\\nGROUP BY Table1.USER_ID;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034403,
                "title": "mysql",
                "content": "\\n\\n# Code\\n```\\nSELECT S.USER_ID, \\nIFNULL(ROUND(( (SELECT COUNT(*) FROM CONFIRMATIONS C2 WHERE C2.USER_ID = S.USER_ID AND C2.ACTION = \\'CONFIRMED\\') / (SELECT COUNT(*) FROM CONFIRMATIONS C2 WHERE C2.USER_ID = S.USER_ID) ), 2), 0) AS CONFIRMATION_RATE\\nFROM SIGNUPS S LEFT OUTER JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\nGROUP BY S.USER_ID; \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT S.USER_ID, \\nIFNULL(ROUND(( (SELECT COUNT(*) FROM CONFIRMATIONS C2 WHERE C2.USER_ID = S.USER_ID AND C2.ACTION = \\'CONFIRMED\\') / (SELECT COUNT(*) FROM CONFIRMATIONS C2 WHERE C2.USER_ID = S.USER_ID) ), 2), 0) AS CONFIRMATION_RATE\\nFROM SIGNUPS S LEFT OUTER JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\nGROUP BY S.USER_ID; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034088,
                "title": "confirmation-rate",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate\\nfrom Signups as s left join Confirmations as c on s.user_id= c.user_id group by user_id;\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate\\nfrom Signups as s left join Confirmations as c on s.user_id= c.user_id group by user_id;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4030953,
                "title": "ms-pl-and-my-sql-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGet Average and round it\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEach Language has its own way of `if`, `iif`, but `CASE WHEN` works for all them\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nYou can use first code example for any provided SQL lang.\\nthe second and third ones are for `MySQL` and `T-SQL`\\n``` SQL []\\n/* Write your PL/SQL query statement below */\\nSELECT\\n  s.user_id,\\n  round(avg(\\n    CASE\\n      WHEN action=\\'confirmed\\' THEN 1\\n      ELSE 0.0\\n    END), 2) confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```\\n``` SQL []\\n# Write your MySQL query statement below\\nSELECT\\n  s.user_id,\\n  round(avg(if(c.action=\"confirmed\",1,0)),2) confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```\\n``` SQL []\\n/* Write your T-SQL query statement below */\\nSELECT\\n  s.user_id,\\n  round(avg(iif(c.action=\\'confirmed\\', 1, 0.0)), 2) confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle",
                    "Database"
                ],
                "code": "``` SQL []\\n/* Write your PL/SQL query statement below */\\nSELECT\\n  s.user_id,\\n  round(avg(\\n    CASE\\n      WHEN action=\\'confirmed\\' THEN 1\\n      ELSE 0.0\\n    END), 2) confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```\n``` SQL []\\n# Write your MySQL query statement below\\nSELECT\\n  s.user_id,\\n  round(avg(if(c.action=\"confirmed\",1,0)),2) confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```\n``` SQL []\\n/* Write your T-SQL query statement below */\\nSELECT\\n  s.user_id,\\n  round(avg(iif(c.action=\\'confirmed\\', 1, 0.0)), 2) confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c ON s.user_id = c.user_id\\nGROUP BY s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4030485,
                "title": "easy-solution-brute-force",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\n\\n\\nSELECT s.user_id, \\n    ROUND(\\n        IFNULL(\\n        (SELECT COUNT(IF(action=\"confirmed\", 1, NULL))/COUNT(*) FROM confirmations WHERE user_id = s.user_id),\\n             0),\\n         2) \\n    as confirmation_rate \\nFROM signups s;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\nSELECT s.user_id, \\n    ROUND(\\n        IFNULL(\\n        (SELECT COUNT(IF(action=\"confirmed\", 1, NULL))/COUNT(*) FROM confirmations WHERE user_id = s.user_id),\\n             0),\\n         2) \\n    as confirmation_rate \\nFROM signups s;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4028609,
                "title": "confirmation-rate",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect distinct\\n    s.user_id,\\n    round(\\n    coalesce(\\n    coalesce(\\n    (\\n        select\\n            count(c1.user_id)\\n        from\\n            confirmations c1\\n        where\\n            c1.action in (\\'confirmed\\') and\\n            c1.user_id = c.user_id\\n    ),0) /\\n    coalesce(\\n    (\\n        select\\n            count(c1.user_id)\\n        from\\n            confirmations c1\\n        where\\n            c1.user_id = c.user_id\\n    ),0),0),2) as confirmation_rate\\nfrom\\n    signups s left join\\n    confirmations c \\n    on s.user_id = c.user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect distinct\\n    s.user_id,\\n    round(\\n    coalesce(\\n    coalesce(\\n    (\\n        select\\n            count(c1.user_id)\\n        from\\n            confirmations c1\\n        where\\n            c1.action in (\\'confirmed\\') and\\n            c1.user_id = c.user_id\\n    ),0) /\\n    coalesce(\\n    (\\n        select\\n            count(c1.user_id)\\n        from\\n            confirmations c1\\n        where\\n            c1.user_id = c.user_id\\n    ),0),0),2) as confirmation_rate\\nfrom\\n    signups s left join\\n    confirmations c \\n    on s.user_id = c.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4028581,
                "title": "beats-68-73-of-users-with-ms-sql-server",
                "content": "# Intuition\\nTo divide each result set into smaller tables and then join them together to get the final result.\\n\\n# Approach\\n1. create a table with alias \\'a\\' from confirmations where action = \\'confirmed\\' with column as confirmed_action_count\\n2. create a table with alias \\'b\\' from confirmations with column as action_count where there is no where clause\\n3. inner join tables \\'a\\' and \\'b\\' to create a table \\'c\\' by now you will have columns user_id, confirmed_action_count, action_count under table called \\'c\\'\\n4. create a table with alias \\'d\\' from signups do a left join with the \\'c\\' table and calculate the confirmation_rate as per the provided logic. I\\'ve used cast function to convert the columns to float to get the decimal values, the isnull function is to convert the null from left join to 0. And, round function is to round the final result upto 2 decimals.\\n\\nPls up vote if this logic helped you understand the problem in a easier way.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nselect d.user_id, \\nround(isnull(cast(confirmed_action_count as float) / cast(action_count as float),0),2) confirmation_rate\\nfrom signups d\\nleft join\\n(select a.user_id, confirmed_action_count, action_count\\nfrom \\n(select user_id,count(*) confirmed_action_count\\nfrom confirmations\\nwhere action = \\'confirmed\\'\\ngroup by user_id\\n) a\\njoin \\n(select user_id,count(*) action_count\\nfrom confirmations\\ngroup by user_id\\n) b\\non a.user_id = b.user_id) c\\non d.user_id = c.user_id\\n```",
                "solutionTags": [
                    "MS SQL Server",
                    "Database"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect d.user_id, \\nround(isnull(cast(confirmed_action_count as float) / cast(action_count as float),0),2) confirmation_rate\\nfrom signups d\\nleft join\\n(select a.user_id, confirmed_action_count, action_count\\nfrom \\n(select user_id,count(*) confirmed_action_count\\nfrom confirmations\\nwhere action = \\'confirmed\\'\\ngroup by user_id\\n) a\\njoin \\n(select user_id,count(*) action_count\\nfrom confirmations\\ngroup by user_id\\n) b\\non a.user_id = b.user_id) c\\non d.user_id = c.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4024558,
                "title": "using-cte-and-case-function-beats-92-34-of-users-with-mysql",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith base as (\\nselect s.user_id,s.time_stamp as signup_time,c.time_stamp as confirmation_time, c.action,\\ncase when c.action = \\'confirmed\\' then 1 else 0 end as is_confirmed,\\n1 as requests\\nfrom Signups s left join Confirmations c on s.user_id = c.user_id)\\n\\nselect user_id, round(sum(is_confirmed)/sum(requests),2) as confirmation_rate\\nfrom base \\ngroup by 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith base as (\\nselect s.user_id,s.time_stamp as signup_time,c.time_stamp as confirmation_time, c.action,\\ncase when c.action = \\'confirmed\\' then 1 else 0 end as is_confirmed,\\n1 as requests\\nfrom Signups s left join Confirmations c on s.user_id = c.user_id)\\n\\nselect user_id, round(sum(is_confirmed)/sum(requests),2) as confirmation_rate\\nfrom base \\ngroup by 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4023946,
                "title": "with-left-join-group-by-easy-solution-beats-92",
                "content": "\\n# Approach\\nFirst, perform left join Signups with Confirmations table and group by user_id to calculate average of action=\\'confirmed\\', round up to 2 decimal places.\\n\\nYou need to write ifnull condition to handle null values.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id, round(ifnull(avg(c.action=\\'confirmed\\'), 0), 2) as confirmation_rate \\nfrom Signups s\\nleft join Confirmations c\\non s.user_id = c.user_id\\ngroup by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id, round(ifnull(avg(c.action=\\'confirmed\\'), 0), 2) as confirmation_rate \\nfrom Signups s\\nleft join Confirmations c\\non s.user_id = c.user_id\\ngroup by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4022833,
                "title": "using-left-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id,round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate from Signups as s \\nleft join Confirmations as c\\non s.user_id = c.user_id\\ngroup by s.user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id,round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate from Signups as s \\nleft join Confirmations as c\\non s.user_id = c.user_id\\ngroup by s.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4021922,
                "title": "cte-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nwith cte1 as (SELECT user_id,\\ncount(*) as a\\nfrom confirmations\\ngroup by user_id),\\ncte as( select user_id, count(action) as b\\nfrom confirmations\\nwhere action like \\'confirmed\\' \\ngroup by user_id ),\\ncte2 as (Select a.user_id, isnull(a,0) as a, isnull(b,0) as b\\nfrom Signups as a\\nLeft join cte1 as b \\non a.user_id = b.user_id\\nleft join cte as c\\non a.user_id = c.user_id)\\n\\nselect user_id, case \\nwhen  a = 0 then 0\\nelse round(b*1.00/a,2) \\nend as confirmation_rate\\nfrom cte2 \\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nwith cte1 as (SELECT user_id,\\ncount(*) as a\\nfrom confirmations\\ngroup by user_id),\\ncte as( select user_id, count(action) as b\\nfrom confirmations\\nwhere action like \\'confirmed\\' \\ngroup by user_id ),\\ncte2 as (Select a.user_id, isnull(a,0) as a, isnull(b,0) as b\\nfrom Signups as a\\nLeft join cte1 as b \\non a.user_id = b.user_id\\nleft join cte as c\\non a.user_id = c.user_id)\\n\\nselect user_id, case \\nwhen  a = 0 then 0\\nelse round(b*1.00/a,2) \\nend as confirmation_rate\\nfrom cte2 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4020797,
                "title": "mysql-solution-beats-99-5",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCalculate total transactions and count where transactions were confirmed. The ratio is confirmation rate\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nLinear\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith main as\\n(\\nselect \\n    s.user_id\\n    ,count(distinct c.time_stamp) as tot_txns\\n    ,count(case when c.action = \\'confirmed\\' then 1 else null end) as confirmed_txns\\nfrom    \\n    Signups s\\nleft join \\n    Confirmations c\\non  s.user_id = c.user_id    \\ngroup by\\n    s.user_id\\n)\\n\\nselect\\n    user_id\\n    ,case when confirmed_txns = 0 then 0 else round(confirmed_txns / tot_txns,2) end as confirmation_rate \\nfrom main\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith main as\\n(\\nselect \\n    s.user_id\\n    ,count(distinct c.time_stamp) as tot_txns\\n    ,count(case when c.action = \\'confirmed\\' then 1 else null end) as confirmed_txns\\nfrom    \\n    Signups s\\nleft join \\n    Confirmations c\\non  s.user_id = c.user_id    \\ngroup by\\n    s.user_id\\n)\\n\\nselect\\n    user_id\\n    ,case when confirmed_txns = 0 then 0 else round(confirmed_txns / tot_txns,2) end as confirmation_rate \\nfrom main\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4018683,
                "title": "easy-solution-using-left-join-and-case-expression",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT s.user_id, ROUND(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / COUNT(*), 2) confirmation_rate\\nFROM signups s\\nLEFT JOIN confirmations c\\nON c.user_id = s.user_id\\nGROUP BY s.user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT s.user_id, ROUND(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / COUNT(*), 2) confirmation_rate\\nFROM signups s\\nLEFT JOIN confirmations c\\nON c.user_id = s.user_id\\nGROUP BY s.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4016756,
                "title": "confirmation-rate-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect s.user_id,round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate from Signups as s left join confirmations as c on s.user_id = c.user_id group by user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect s.user_id,round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate from Signups as s left join confirmations as c on s.user_id = c.user_id group by user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4016416,
                "title": "surprisingly-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thoughts is just following the logic from task descriptions\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThat is: SUM of \\'confirmed\\' divided by COUNT of actions, using ROUND to get formatted decimal points, and COALESCE for \\'null\\' to 0.\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect \\n  s.user_id, \\n  coalesce(\\n    round(sum(c.action=\\'confirmed\\')/count(c.action), 2), 0\\n  ) as confirmation_rate\\nfrom signups s \\nleft join confirmations c\\non s.user_id = c.user_id\\ngroup by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect \\n  s.user_id, \\n  coalesce(\\n    round(sum(c.action=\\'confirmed\\')/count(c.action), 2), 0\\n  ) as confirmation_rate\\nfrom signups s \\nleft join confirmations c\\non s.user_id = c.user_id\\ngroup by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013994,
                "title": "super-simplified-using-subquery-and-left-join-ms-sql-server",
                "content": "# Code\\n```\\n/* Write your T-SQL query statement below */\\nSELECT s.user_id, \\nROUND(ISNULL(c.confirmation_rate, 0), 2) as confirmation_rate\\nFROM Signups s\\nLEFT JOIN  (\\n                SELECT \\n                user_id, \\n                AVG(\\n                    CASE \\n                        WHEN action = \\'confirmed\\' THEN 1.00\\n                        ELSE 0.00\\n                    END\\n                    ) as confirmation_rate\\n                FROM Confirmations\\n                GROUP BY user_id\\n            ) c\\nON s.user_id = c.user_id\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT s.user_id, \\nROUND(ISNULL(c.confirmation_rate, 0), 2) as confirmation_rate\\nFROM Signups s\\nLEFT JOIN  (\\n                SELECT \\n                user_id, \\n                AVG(\\n                    CASE \\n                        WHEN action = \\'confirmed\\' THEN 1.00\\n                        ELSE 0.00\\n                    END\\n                    ) as confirmation_rate\\n                FROM Confirmations\\n                GROUP BY user_id\\n            ) c\\nON s.user_id = c.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013815,
                "title": "naive-solution-without-using-case-when",
                "content": "# Intuition\\nFind confirmed in a table, find total in other table, join and find ratio of two.\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\n\\nselect x.user_id, round(confirm/total,2) confirmation_rate from (select s.user_id, count(*) total from\\nsignups s left join confirmations c on s.user_id = c.user_id group by s.user_id) x\\njoin\\n(select s.user_id, count(c.user_id) confirm from signups s left join (select * from confirmations where action = \\'confirmed\\') c on s.user_id = c.user_id group by s.user_id) y on x.user_id = y.user_id;\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\n\\nselect x.user_id, round(confirm/total,2) confirmation_rate from (select s.user_id, count(*) total from\\nsignups s left join confirmations c on s.user_id = c.user_id group by s.user_id) x\\njoin\\n(select s.user_id, count(c.user_id) confirm from signups s left join (select * from confirmations where action = \\'confirmed\\') c on s.user_id = c.user_id group by s.user_id) y on x.user_id = y.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013747,
                "title": "turn-2-string-conditions-into-0-1-and-use-avg-to-calculate-the-rate",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n(select user_id, 0 as confirmation_rate from Signups\\nwhere user_id not in(select distinct user_id from Confirmations))\\nunion\\n(select user_id, round(AVG(num),2) as confirmation_rate\\nfrom (select user_id,\\ncase when action=\\'timeout\\' then 0 else 1 end as num\\nfrom Confirmations) as temp\\ngroup by user_id)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n(select user_id, 0 as confirmation_rate from Signups\\nwhere user_id not in(select distinct user_id from Confirmations))\\nunion\\n(select user_id, round(AVG(num),2) as confirmation_rate\\nfrom (select user_id,\\ncase when action=\\'timeout\\' then 0 else 1 end as num\\nfrom Confirmations) as temp\\ngroup by user_id)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013312,
                "title": "first-post",
                "content": "# Intuition\\n1. Problem is really simple we simply need to find out the mean confirmed actions, we can use AVG() function.\\n2. Then if we need to find out about each user_id we use group by\\n3. And finally we need to include every user_id irrespective of submitting any request or not so we will do left join on SIGNUPS to include every user_id.\\n\\n# Approach\\nApproach 1:\\n1. First I started by simple select user_id, then we use a IF(condition,if_true then this value,if_false then this value) -> to return 1 for confirmed and 0 for everything else simple.\\n2. Then we input all this into an AVG() function and apply left join on SIGNUPS table so that each and every user_id is include in the result set irrespective of if it has submitted a confirmation request or not. \\n3. Then we go back to the select statement and there specify which user_id we need to use, if we use confiramtion\\'s c.user_id then only the user id which submitted a request will appear in the result set and it will exclude user_id = 6 because it never submitted a confirmation request but we are specified to return a 0 for a user_id which didn\\'t send a confirmation request so we\\'ll use SIGNUPS s.user_id it will include all the userids \\n4. Finally we will group by the same user_id and we\\'ll get the result.  \\n\\nApproach 2:\\n1. We can do the same by using CASE,SUM,COUNT; if someone is not familiar with the IF() function. Q U E R Y -> SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/COUNT(*)\\n2. Logic is the same here, only different functions are used.\\n# Complexity\\nTo be honest I don\\'t really have any knowledge about time and complexitiy :), but i do try to optimize my queries wherever i can. \\n\\n# Code\\n```\\nApproach 1:\\nselect s.user_id, \\nround(avg(if(c.action = \\'confirmed\\',1,0)),2) as confirmation_rate\\nfrom Signups s left join Confirmations c \\non s.user_id = c.user_id \\ngroup by s.user_id\\n```\\n```\\nApproach 2:\\nselect s.user_id, sum(case when c.action = \\'confirmed\\' then 1 else 0 end)/count(*) as confirmation_rate\\nfrom Signups s left join Confirmations c \\non s.user_id = c.user_id\\ngroup by s.user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nApproach 1:\\nselect s.user_id, \\nround(avg(if(c.action = \\'confirmed\\',1,0)),2) as confirmation_rate\\nfrom Signups s left join Confirmations c \\non s.user_id = c.user_id \\ngroup by s.user_id\\n```\n```\\nApproach 2:\\nselect s.user_id, sum(case when c.action = \\'confirmed\\' then 1 else 0 end)/count(*) as confirmation_rate\\nfrom Signups s left join Confirmations c \\non s.user_id = c.user_id\\ngroup by s.user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013229,
                "title": "simple-2-liner-mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate\\nfrom Signups as s left join Confirmations as c on s.user_id= c.user_id group by user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.user_id, round(avg(if(c.action=\"confirmed\",1,0)),2) as confirmation_rate\\nfrom Signups as s left join Confirmations as c on s.user_id= c.user_id group by user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4012109,
                "title": "easy-solution-no-cte",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT \\n    s.user_id, \\n    COALESCE(ROUND(sum(if(c.action=\\'confirmed\\',1,0))/count(c.user_id),2),0) as confirmation_rate \\nFROM Signups s\\nLEFT JOIN Confirmations c\\n    USING (user_id)\\nGROUP BY s.user_id \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n    s.user_id, \\n    COALESCE(ROUND(sum(if(c.action=\\'confirmed\\',1,0))/count(c.user_id),2),0) as confirmation_rate \\nFROM Signups s\\nLEFT JOIN Confirmations c\\n    USING (user_id)\\nGROUP BY s.user_id \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4012099,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPlease Upvote if this solution seemed helpful.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith cte as (Select user_id, count(*) as confirmed_action\\nfrom confirmations\\nwhere action =\\'confirmed\\'\\ngroup by user_id),\\n\\ncte2 as\\n(Select user_id, count(*) as total_action\\nfrom confirmations\\ngroup by user_id)\\n\\nSelect s.user_id, round(coalesce (c.confirmed_action/c2.total_action,0),2) as confirmation_rate\\nfrom signups as s left join cte as c \\non s.user_id = c.user_id left join cte2 as c2\\non c.user_id = c2.user_id;\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith cte as (Select user_id, count(*) as confirmed_action\\nfrom confirmations\\nwhere action =\\'confirmed\\'\\ngroup by user_id),\\n\\ncte2 as\\n(Select user_id, count(*) as total_action\\nfrom confirmations\\ngroup by user_id)\\n\\nSelect s.user_id, round(coalesce (c.confirmed_action/c2.total_action,0),2) as confirmation_rate\\nfrom signups as s left join cte as c \\non s.user_id = c.user_id left join cte2 as c2\\non c.user_id = c2.user_id;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4009066,
                "title": "ms-sql-server-solution-should-work-in-any-other-sql-db-engine",
                "content": "# Intuition\\nCreate a total_count and a count_of_confirmed. Return the \\ncount_of_confirmed divided by total_count\\n\\n# Approach\\nI did it as I described before, only had to check on how to do a floating point division that also only had 2 decimal places.\\n\\n\\n# Code\\n```\\nWITH val AS\\n(\\n SELECT s.user_id \\n        , count(CASE WHEN c.action=\\'confirmed\\' THEN c.action ELSE NULL END) AS count_confirmed\\n        , count(c.action) AS count_all\\n FROM signups s\\n LEFT JOIN confirmations c ON s.user_id = c.user_id\\n GROUP BY s.user_id\\n)\\nSELECT user_id\\n     , CASE WHEN count_confirmed = 0 THEN 0\\n       ELSE CAST(CAST(count_confirmed AS NUMERIC) / count_all AS NUMERIC(10,2))\\n       END AS confirmation_rate\\n FROM val;\\n\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nWITH val AS\\n(\\n SELECT s.user_id \\n        , count(CASE WHEN c.action=\\'confirmed\\' THEN c.action ELSE NULL END) AS count_confirmed\\n        , count(c.action) AS count_all\\n FROM signups s\\n LEFT JOIN confirmations c ON s.user_id = c.user_id\\n GROUP BY s.user_id\\n)\\nSELECT user_id\\n     , CASE WHEN count_confirmed = 0 THEN 0\\n       ELSE CAST(CAST(count_confirmed AS NUMERIC) / count_all AS NUMERIC(10,2))\\n       END AS confirmation_rate\\n FROM val;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4007503,
                "title": "simple-solution-with-and-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncalculate confirmation rate for all users and merge with users who signup.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith q as (\\nselect user_id, round(sum(IF(action=\\'confirmed\\', 1, 0)) / count(user_id), 2) confirmation_rate\\nfrom confirmations a\\ngroup by user_id\\n),\\nw as (\\n  select distinct user_id\\n  from signups\\n)\\nselect user_id, ifnull(confirmation_rate, 0) confirmation_rate from w\\nleft join q\\nusing(user_id)\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith q as (\\nselect user_id, round(sum(IF(action=\\'confirmed\\', 1, 0)) / count(user_id), 2) confirmation_rate\\nfrom confirmations a\\ngroup by user_id\\n),\\nw as (\\n  select distinct user_id\\n  from signups\\n)\\nselect user_id, ifnull(confirmation_rate, 0) confirmation_rate from w\\nleft join q\\nusing(user_id)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4007434,
                "title": "mysql-detailed-explaination-easy",
                "content": "## Intuition\\nTo calculate the confirmation rate for each user, we need to consider the \\'confirmed\\' and \\'timeout\\' actions for each user in the \"Confirmations\" table. We can achieve this by joining the \"Signups\" and \"Confirmations\" tables and then calculating the ratio of \\'confirmed\\' actions to the total number of actions for each user.\\n\\n## Approach\\n```sql\\n-- Write your MySQL query statement below\\nselect s.user_id , round(ifnull(count(case when action = \\'confirmed\\' then 1 else NULL end) / count(action), 0), 2) as confirmation_rate\\nfrom Signups as s \\nleft join Confirmations as c \\non s.user_id = c.user_id \\ngroup by s.user_id;\\n```\\n\\n## Query Explanation\\nWe start by performing a `LEFT JOIN` between the \"Signups\" and \"Confirmations\" tables, using the \"user_id\" column as the join condition. This join combines each user\\'s sign-up information with their confirmation records (if any). \\n\\nNext, we use conditional aggregation to count the number of \\'confirmed\\' actions for each user (`count(case when action = \\'confirmed\\' then 1 else NULL end)`) and the total number of actions (`count(action)`). We then calculate the confirmation rate by dividing the count of \\'confirmed\\' actions by the total count of actions for each user. We use the `ROUND` function to round the result to two decimal places.\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\n-- Write your MySQL query statement below\\nselect s.user_id , round(ifnull(count(case when action = \\'confirmed\\' then 1 else NULL end) / count(action), 0), 2) as confirmation_rate\\nfrom Signups as s \\nleft join Confirmations as c \\non s.user_id = c.user_id \\ngroup by s.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4006699,
                "title": "ms-sql-server-solution",
                "content": "\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nSELECT A.user_id, ROUND((SELECT COUNT(C.user_id) FROM Confirmations C WHERE C.action = \\'confirmed\\' AND  C.user_id = A.user_id)*1.0/COUNT(A.user_id),2) AS confirmation_rate\\nFROM Signups A\\nLEFT JOIN Confirmations B\\nON A.user_id = B.user_id\\nGROUP BY A.user_id ORDER BY confirmation_rate\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT A.user_id, ROUND((SELECT COUNT(C.user_id) FROM Confirmations C WHERE C.action = \\'confirmed\\' AND  C.user_id = A.user_id)*1.0/COUNT(A.user_id),2) AS confirmation_rate\\nFROM Signups A\\nLEFT JOIN Confirmations B\\nON A.user_id = B.user_id\\nGROUP BY A.user_id ORDER BY confirmation_rate\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4000002,
                "title": "attention-here-different-from-others-solution-using-ifnull-round-and-sum",
                "content": "PLEASE UPVOTE IF MY SOLUTION IS HELPFUL \\n\\n# Code\\n```\\nselect s.user_id , ifnull(round(sum(action = \\'confirmed\\')/count(*),2), 0.00) as confirmation_rate\\nfrom Signups s \\nleft join Confirmations c on s.user_id = c.user_id \\ngroup by s.user_id \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s.user_id , ifnull(round(sum(action = \\'confirmed\\')/count(*),2), 0.00) as confirmation_rate\\nfrom Signups s \\nleft join Confirmations c on s.user_id = c.user_id \\ngroup by s.user_id \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3998483,
                "title": "best-solution-using-window-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSelect user_id , \\nRound(IFNULL(confirmed/total,0),2) as confirmation_rate\\nfrom (\\nSelect s.user_id,\\nsum(case when action = \\'confirmed\\' then 1  else 0 end) as confirmed,\\ncount(action) as total\\nfrom signups s\\nleft outer join Confirmations c\\non s.user_id = c.user_id\\ngroup by 1\\n) a  group by 1\\norder by confirmation_rate\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect user_id , \\nRound(IFNULL(confirmed/total,0),2) as confirmation_rate\\nfrom (\\nSelect s.user_id,\\nsum(case when action = \\'confirmed\\' then 1  else 0 end) as confirmed,\\ncount(action) as total\\nfrom signups s\\nleft outer join Confirmations c\\non s.user_id = c.user_id\\ngroup by 1\\n) a  group by 1\\norder by confirmation_rate\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3998431,
                "title": "best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSelect user_id , \\nRound(IFNULL(confirmed/total,0),2) as confirmation_rate\\nfrom (\\nSelect s.user_id,\\nsum(case when action = \\'confirmed\\' then 1  else 0 end) as confirmed,\\ncount(action) as total\\nfrom signups s\\nleft outer join Confirmations c\\non s.user_id = c.user_id\\ngroup by 1\\n) a\\norder by confirmation_rate\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect user_id , \\nRound(IFNULL(confirmed/total,0),2) as confirmation_rate\\nfrom (\\nSelect s.user_id,\\nsum(case when action = \\'confirmed\\' then 1  else 0 end) as confirmed,\\ncount(action) as total\\nfrom signups s\\nleft outer join Confirmations c\\non s.user_id = c.user_id\\ngroup by 1\\n) a\\norder by confirmation_rate\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3996504,
                "title": "beats-97-using-ctes-and-flag",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n--main cte joins both table to ge user_id, actinon and flagged action to check if confirmed\\nwith main as(\\n  select \\n    a.user_id,\\n    b.action,\\n    case \\n      when action=\\'confirmed\\' then 1\\n      else 0\\n    end as action_flag\\n  from signups a\\n  left join confirmations b\\n  on a.user_id=b.user_id\\n),\\n--t_cnt cte counts the total count of action by each user\\nt_cnt as(\\nselect \\n  a.user_id,\\n  count(b.action) total_action_cnt\\nfrom signups a\\nleft join confirmations b \\non a.user_id=b.user_id \\ngroup by a.user_id)\\n\\n--just calculating rest needed.\\nselect \\n  m.user_id,\\n  case when t.total_action_cnt <> 0 then round(cast(sum(m.action_flag) as float)/t.total_action_cnt,2) \\n  else 0 end as confirmation_rate\\nfrom main m\\ninner join t_cnt t\\non m.user_id=t.user_id\\ngroup by m.user_id,t.total_action_cnt;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n--main cte joins both table to ge user_id, actinon and flagged action to check if confirmed\\nwith main as(\\n  select \\n    a.user_id,\\n    b.action,\\n    case \\n      when action=\\'confirmed\\' then 1\\n      else 0\\n    end as action_flag\\n  from signups a\\n  left join confirmations b\\n  on a.user_id=b.user_id\\n),\\n--t_cnt cte counts the total count of action by each user\\nt_cnt as(\\nselect \\n  a.user_id,\\n  count(b.action) total_action_cnt\\nfrom signups a\\nleft join confirmations b \\non a.user_id=b.user_id \\ngroup by a.user_id)\\n\\n--just calculating rest needed.\\nselect \\n  m.user_id,\\n  case when t.total_action_cnt <> 0 then round(cast(sum(m.action_flag) as float)/t.total_action_cnt,2) \\n  else 0 end as confirmation_rate\\nfrom main m\\ninner join t_cnt t\\non m.user_id=t.user_id\\ngroup by m.user_id,t.total_action_cnt;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3996498,
                "title": "solution-using-round-count-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nSELECT cts.user_id,ROUND(COUNT (CASE WHEN cts.action=\\'confirmed\\' THEN 1 ELSE NULL END)/CAST(COUNT(cts.user_id) AS DECIMAL(10,2)) ,2)AS confirmation_rate   \\nFROM (select s.user_id,c.action  FROM Signups s LEFT JOIN Confirmations c ON s.user_id=c.user_id) AS cts \\nGROUP BY cts.user_id;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT cts.user_id,ROUND(COUNT (CASE WHEN cts.action=\\'confirmed\\' THEN 1 ELSE NULL END)/CAST(COUNT(cts.user_id) AS DECIMAL(10,2)) ,2)AS confirmation_rate   \\nFROM (select s.user_id,c.action  FROM Signups s LEFT JOIN Confirmations c ON s.user_id=c.user_id) AS cts \\nGROUP BY cts.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3995357,
                "title": "easy-mysql-solution",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n\\n\\nSELECT s_up.user_id , \\nROUND(SUM(CASE\\n   WHEN action = \"confirmed\" THEN 1\\n   ELSE 0\\nEND)/ COUNT(s_up.user_id ),2) AS confirmation_rate\\nFROM Signups s_up\\nLEFT JOIN Confirmations conf\\nON s_up.user_id = conf.user_id\\nGROUP BY s_up.user_id \\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\n\\nSELECT s_up.user_id , \\nROUND(SUM(CASE\\n   WHEN action = \"confirmed\" THEN 1\\n   ELSE 0\\nEND)/ COUNT(s_up.user_id ),2) AS confirmation_rate\\nFROM Signups s_up\\nLEFT JOIN Confirmations conf\\nON s_up.user_id = conf.user_id\\nGROUP BY s_up.user_id \\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3994152,
                "title": "calculation-without-using-case-or-subqueries",
                "content": "pair in mind that \\n```\\nROUND(SUM(action = \\'confirmed\\') / COUNT(user_id), 2)\\n```\\nis the same as \\n```\\nROUND(AVG(action = \\'confirmed\\'), 2)\\n```\\n\\n# Code\\n```\\nSELECT\\n    user_id,\\n    IFNULL(\\n        ROUND(AVG(action = \\'confirmed\\'), 2)\\n    , 0) AS confirmation_rate\\nFROM\\n    Signups\\nLEFT JOIN\\n    Confirmations USING(user_id)\\nGROUP BY user_id\\n```",
                "solutionTags": [
                    "MySQL",
                    "Oracle",
                    "Database"
                ],
                "code": "```\\nROUND(SUM(action = \\'confirmed\\') / COUNT(user_id), 2)\\n```\n```\\nROUND(AVG(action = \\'confirmed\\'), 2)\\n```\n```\\nSELECT\\n    user_id,\\n    IFNULL(\\n        ROUND(AVG(action = \\'confirmed\\'), 2)\\n    , 0) AS confirmation_rate\\nFROM\\n    Signups\\nLEFT JOIN\\n    Confirmations USING(user_id)\\nGROUP BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3993994,
                "title": "beats-100",
                "content": "# Approach\\nIn this query:\\n\\nWe use the SUM and COUNT functions to calculate the total number of confirmed messages and the total number of requested confirmation messages for each user within the JOINed data.\\n\\nWe use the CASE statement to count confirmed messages.\\n\\nTo handle cases where a user didn\\'t request any confirmation messages (denominator being 0), we use NULLIF to avoid division by zero and IFNULL to return 0 as the confirmation rate in such cases.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT s.user_id,\\n       IFNULL(ROUND(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(*), 0), 2), 0) as confirmation_rate \\nFROM Signups as s\\nLEFT JOIN Confirmations as c ON s.user_id = c.user_id\\nGROUP BY s.user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT s.user_id,\\n       IFNULL(ROUND(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(*), 0), 2), 0) as confirmation_rate \\nFROM Signups as s\\nLEFT JOIN Confirmations as c ON s.user_id = c.user_id\\nGROUP BY s.user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3991966,
                "title": "using-unions-mysql",
                "content": "``` mysql\\nselect user_id, 0 as confirmation_rate from Signups where user_id not in \\n(\\n    select user_id from Confirmations\\n)\\n\\nunion\\n\\nselect user_id, round(sum(if(action=\\'confirmed\\',1,0))/count(action), 2)  as confirmation_rate from Confirmations\\ngroup by user_id;\\n\\n```",
                "solutionTags": [],
                "code": "``` mysql\\nselect user_id, 0 as confirmation_rate from Signups where user_id not in \\n(\\n    select user_id from Confirmations\\n)\\n\\nunion\\n\\nselect user_id, round(sum(if(action=\\'confirmed\\',1,0))/count(action), 2)  as confirmation_rate from Confirmations\\ngroup by user_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3989892,
                "title": "sql-solution",
                "content": "\\n\\n# Code\\n```\\nSELECT s.user_id, \\n    ROUND(AVG(\\n        CASE \\n            WHEN (c.action=\\'confirmed\\') THEN 1 \\n            ELSE 0 \\n        END),\\n    2) AS confirmation_rate\\nFROM Signups AS s\\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\\nGROUP BY s.user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT s.user_id, \\n    ROUND(AVG(\\n        CASE \\n            WHEN (c.action=\\'confirmed\\') THEN 1 \\n            ELSE 0 \\n        END),\\n    2) AS confirmation_rate\\nFROM Signups AS s\\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\\nGROUP BY s.user_id;\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 2017044,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 1883879,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 1906306,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 1576198,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 1976268,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 1969793,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 2071979,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 2070893,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 2063275,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 2057643,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 2017044,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 1883879,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 1906306,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 1576198,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 1976268,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 1969793,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 2071979,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 2070893,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 2063275,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 2057643,
                "content": [
                    {
                        "username": "iprince",
                        "content": "Step 1: First try to solve only for confirmations table i.e., for user_id 3, 7 and 2.  (Hint is written below)\nStep 2: One you get the concept of step 1, then refresh and start again. Left join both the tables, and use the concept of step 1.\n\nHint: For step 1, use group by to make groups of 3, 7 and 2. Then use sum/count(*) in select.\nsomething like this: \"sum(action='confirmed')/count( * )\"\n\nPlease upvote guys for those who are looking for hints rather than answers."
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a \\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "towhidulrazu",
                        "content": "Nice and clean thinking!"
                    },
                    {
                        "username": "akhilesh1412",
                        "content": "WITH cte AS (\\nSELECT s.user_id AS user_id, COUNT(*) tot_cnt, \\n      SUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nFROM Signups s LEFT JOIN Confirmations c\\nON s.user_id = c.user_id\\nGROUP BY s.user_id) \\n\\nSELECT user_id, ROUND(con_cnt / tot_cnt,2) AS confirmation_rate\\nFROM cte"
                    },
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cte as (\\n\\tSelect user_id, \\n\\tCASE WHEN action = \\'confirmed\\' then 1 END as confirmed,\\n\\t1 as total\\n\\tfrom Confirmations\\n\\t)\\n\\tSelect user_id, ROUND(COALESCE(sum(confirmed)/sum(total),0),2)  confirmation_rate from cte\\n\\tright join Signups using (user_id)\\n\\tgroup by user_id\\n\\t\\n\\t## With AVG\\n\\t\\n\\tSelect user_id, \\n\\tROUND(AVG(CASE WHEN action = \\'confirmed\\' then 1 ELSE 0 END),2) as confirmation_rate\\n\\tfrom Confirmations\\n\\tright join Signups using (user_id)  \\n\\tgroup by user_id"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "WITH totals AS\\n(\\n    SELECT\\n    user_id,\\n    SUM(CASE WHEN Action = \\'confirmed\\' THEN 1 ELSE 0 END) numerator,\\n    COUNT(*) denominator\\n    FROM Confirmations\\n    GROUP BY user_id\\n)\\n\\nSELECT\\n    su.user_id,\\n    ISNULL(ROUND(CAST(numerator AS DECIMAL) / CAST(denominator AS DECIMAL),2),0) as confirmation_rate\\nFROM signups su\\nLEFT JOIN totals con ON con.user_id = su.user_id"
                    },
                    {
                        "username": "sa3doni2714",
                        "content": "SELECT\\n  s.user_id,\\n  ROUND(COALESCE(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END) / NULLIF(COUNT(c.user_id), 0), 0), 2) AS confirmation_rate\\nFROM\\n  Signups s\\nLEFT JOIN\\n  Confirmations c ON s.user_id = c.user_id\\nGROUP BY\\n  s.user_id;\\n"
                    },
                    {
                        "username": "workingjay2010",
                        "content": "One of the toughest query I have done"
                    },
                    {
                        "username": "user8428J",
                        "content": "select t.user_id, round(COALESCE(con_cnt/total,0),2) as confirmation_rate\\nfrom\\n(select s.user_id,\\nSUM(case when action!=\"\" then 1 else 0 end) as total,\\nSUM(CASE WHEN action = \"confirmed\" THEN 1 ELSE 0 END) AS con_cnt\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id) as t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "96% beat if you want to find solution: \\n# Write your MySQL query statement below\\nselect s.user_id as user_id,\\n    case when \\n        count(*) = 0 then 0\\n    else\\n    round(sum(case when c.action = \\'confirmed\\' then 1 else 0 end) / count(*),2)\\n    end as confirmation_rate\\nfrom signups s left join confirmations c\\non s.user_id = c.user_id\\ngroup by s.user_id"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select A.user_id, round(avg(counting),2) as confirmation_rate\\nfrom(\\nselect s.user_id as user_id ,c.action as rate,\\ncase\\nwhen c.action =\\'timeout\\' or c.action is null \\nthen 0 \\nelse 1  \\nend as counting\\nfrom signups s left outer join confirmations c \\non(s.user_id=c.user_id) )A\\ngroup by A.user_id ;"
                    }
                ]
            },
            {
                "id": 2056306,
                "content": [
                    {
                        "username": "srjefers",
                        "content": "** ORACLE **\\n```\\n/* Write your PL/SQL query statement below */\\nwith actions_total as (\\n    select \\n        s.user_id,\\n        sum(case \\n            when c.user_id is null then 1\\n            else 0\\n        end) as no_action,\\n        sum(case \\n            when c.action = \\'timeout\\' then 1\\n            else 0\\n        end) as timeout_action,\\n        sum(case \\n            when c.action = \\'confirmed\\' then 1\\n            else 0\\n        end) as confirmed_action\\n    from Signups s\\n    left join Confirmations c \\n        on c.user_id = s.user_id\\n    group by s.user_id\\n),\\nfinal as (   \\n    select \\n        user_id,\\n        round(confirmed_action / (confirmed_action + timeout_action + no_action),2) as confirmation_rate\\n    from actions_total\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "no3",
                        "content": "SELECT s.user_id, round(Coalesce(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON c.user_id = s.user_id\\nGROUP BY s.user_id\\nORDER BY confirmation_rate\\n"
                    },
                    {
                        "username": "chetansinh",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a\\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "himsm",
                        "content": "with t1\\nas (select user_id, count(action) conf_cnt\\nfrom confirmations\\nwhere action=\\'confirmed\\'\\ngroup by user_id),\\n\\nt2\\nas (select user_id, count(*) totlcnt\\nfrom confirmations\\ngroup by user_id),\\n\\nt3 as (select s.user_id user_id, coalesce(conf_cnt,0) as confirm_cnt,coalesce(totlcnt,1) as total_cnt\\nfrom signups s\\nleft join t1\\non s.user_id=t1.user_id\\nleft join t2\\non s.user_id=t2.user_id\\ngroup by s.user_id)\\n\\nselect t3.user_id, confirm_cnt/total_cnt confirmation_rate\\nfrom t3\\ngroup by t3.user_id;\\n\\n\\nquery is running correctly, but not getting submitted."
                    },
                    {
                        "username": "subashini_Senthilkumar",
                        "content": "with cte1 as(select user_id, count(user_id) as o from confirmations group by user_id),\\ncte2 as (select user_id, count(user_id) as oc from confirmations where action = \\'confirmed\\' group by user_id),\\ncte3 as (select cte1.user_id, oc/o as cr from cte1 left join cte2 on cte1.user_id = cte2.user_id)\\n\\nselect s.user_id, (case when cr is null then 0 else round(cr,2) end) as confirmation_rate from signups s left join cte3 c on s.user_id = c.user_id"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT\\nS.USER_ID,\\nROUND((COUNT(CASE WHEN C.ACTION=\\'confirmed\\' THEN 1 END)/count(*)),2) AS confirmation_rate\\nFROM SIGNUPS S\\nLEFT JOIN CONFIRMATIONS C\\nON S.USER_ID=C.USER_ID\\nGROUP BY S.USER_ID"
                    },
                    {
                        "username": "Omkarakandekar",
                        "content": "SELECT s.user_id, \n       IFNULL(SUM(CASE WHEN c.action = 'confirmed' THEN 1 ELSE 0 END) / COUNT(s.user_id), 0) AS confirmation_rate\nFROM Signups AS s\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\nGROUP BY s.user_id;\n\n\n#this is showing me error ..plz help me\n "
                    },
                    {
                        "username": "Vaibhav2002",
                        "content": "Could Somebody please tell me why I am able to use COALESCE to convert null to 0 but not able to use ISNULL function instead ?\\n\\n  `SELECT s.user_id, \\nCOALESCE(ROUND((SELECT COUNT(*) FROM Confirmations c1 WHERE action = \\'confirmed\\' AND c.user_id = c1.user_id) / (SELECT COUNT(*) FROM Confirmations c2 WHERE c.user_id = c2.user_id), 2), 0) AS confirmation_rate FROM Signups s LEFT JOIN Confirmations c USING(user_id) GROUP BY user_id`"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Simple Joins:\\n```\\nSELECT user_id,\\n       ROUND(IFNULL(IFNULL(t.conf, 0)/IFNULL(t1.total, 0), 0), 2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN (\\n             (SELECT COUNT(*) AS total,\\n                     user_id AS x_user_id\\n              FROM Confirmations\\n              GROUP BY user_id) AS t1\\n           LEFT JOIN\\n             (SELECT COUNT(*) AS conf,\\n                     user_id AS y_user_id\\n              FROM Confirmations\\n              WHERE action=\"confirmed\"\\n              GROUP BY user_id) AS t ON t1.x_user_id=t.y_user_id) ON t1.x_user_id=s.user_id\\n```"
                    },
                    {
                        "username": "abhijitpaul0212",
                        "content": "select s.user_id, round(ifnull(avg(action=\\'confirmed\\'),0),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;"
                    }
                ]
            },
            {
                "id": 2053941,
                "content": [
                    {
                        "username": "srjefers",
                        "content": "** ORACLE **\\n```\\n/* Write your PL/SQL query statement below */\\nwith actions_total as (\\n    select \\n        s.user_id,\\n        sum(case \\n            when c.user_id is null then 1\\n            else 0\\n        end) as no_action,\\n        sum(case \\n            when c.action = \\'timeout\\' then 1\\n            else 0\\n        end) as timeout_action,\\n        sum(case \\n            when c.action = \\'confirmed\\' then 1\\n            else 0\\n        end) as confirmed_action\\n    from Signups s\\n    left join Confirmations c \\n        on c.user_id = s.user_id\\n    group by s.user_id\\n),\\nfinal as (   \\n    select \\n        user_id,\\n        round(confirmed_action / (confirmed_action + timeout_action + no_action),2) as confirmation_rate\\n    from actions_total\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "no3",
                        "content": "SELECT s.user_id, round(Coalesce(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON c.user_id = s.user_id\\nGROUP BY s.user_id\\nORDER BY confirmation_rate\\n"
                    },
                    {
                        "username": "chetansinh",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a\\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "himsm",
                        "content": "with t1\\nas (select user_id, count(action) conf_cnt\\nfrom confirmations\\nwhere action=\\'confirmed\\'\\ngroup by user_id),\\n\\nt2\\nas (select user_id, count(*) totlcnt\\nfrom confirmations\\ngroup by user_id),\\n\\nt3 as (select s.user_id user_id, coalesce(conf_cnt,0) as confirm_cnt,coalesce(totlcnt,1) as total_cnt\\nfrom signups s\\nleft join t1\\non s.user_id=t1.user_id\\nleft join t2\\non s.user_id=t2.user_id\\ngroup by s.user_id)\\n\\nselect t3.user_id, confirm_cnt/total_cnt confirmation_rate\\nfrom t3\\ngroup by t3.user_id;\\n\\n\\nquery is running correctly, but not getting submitted."
                    },
                    {
                        "username": "subashini_Senthilkumar",
                        "content": "with cte1 as(select user_id, count(user_id) as o from confirmations group by user_id),\\ncte2 as (select user_id, count(user_id) as oc from confirmations where action = \\'confirmed\\' group by user_id),\\ncte3 as (select cte1.user_id, oc/o as cr from cte1 left join cte2 on cte1.user_id = cte2.user_id)\\n\\nselect s.user_id, (case when cr is null then 0 else round(cr,2) end) as confirmation_rate from signups s left join cte3 c on s.user_id = c.user_id"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT\\nS.USER_ID,\\nROUND((COUNT(CASE WHEN C.ACTION=\\'confirmed\\' THEN 1 END)/count(*)),2) AS confirmation_rate\\nFROM SIGNUPS S\\nLEFT JOIN CONFIRMATIONS C\\nON S.USER_ID=C.USER_ID\\nGROUP BY S.USER_ID"
                    },
                    {
                        "username": "Omkarakandekar",
                        "content": "SELECT s.user_id, \n       IFNULL(SUM(CASE WHEN c.action = 'confirmed' THEN 1 ELSE 0 END) / COUNT(s.user_id), 0) AS confirmation_rate\nFROM Signups AS s\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\nGROUP BY s.user_id;\n\n\n#this is showing me error ..plz help me\n "
                    },
                    {
                        "username": "Vaibhav2002",
                        "content": "Could Somebody please tell me why I am able to use COALESCE to convert null to 0 but not able to use ISNULL function instead ?\\n\\n  `SELECT s.user_id, \\nCOALESCE(ROUND((SELECT COUNT(*) FROM Confirmations c1 WHERE action = \\'confirmed\\' AND c.user_id = c1.user_id) / (SELECT COUNT(*) FROM Confirmations c2 WHERE c.user_id = c2.user_id), 2), 0) AS confirmation_rate FROM Signups s LEFT JOIN Confirmations c USING(user_id) GROUP BY user_id`"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Simple Joins:\\n```\\nSELECT user_id,\\n       ROUND(IFNULL(IFNULL(t.conf, 0)/IFNULL(t1.total, 0), 0), 2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN (\\n             (SELECT COUNT(*) AS total,\\n                     user_id AS x_user_id\\n              FROM Confirmations\\n              GROUP BY user_id) AS t1\\n           LEFT JOIN\\n             (SELECT COUNT(*) AS conf,\\n                     user_id AS y_user_id\\n              FROM Confirmations\\n              WHERE action=\"confirmed\"\\n              GROUP BY user_id) AS t ON t1.x_user_id=t.y_user_id) ON t1.x_user_id=s.user_id\\n```"
                    },
                    {
                        "username": "abhijitpaul0212",
                        "content": "select s.user_id, round(ifnull(avg(action=\\'confirmed\\'),0),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;"
                    }
                ]
            },
            {
                "id": 2049002,
                "content": [
                    {
                        "username": "srjefers",
                        "content": "** ORACLE **\\n```\\n/* Write your PL/SQL query statement below */\\nwith actions_total as (\\n    select \\n        s.user_id,\\n        sum(case \\n            when c.user_id is null then 1\\n            else 0\\n        end) as no_action,\\n        sum(case \\n            when c.action = \\'timeout\\' then 1\\n            else 0\\n        end) as timeout_action,\\n        sum(case \\n            when c.action = \\'confirmed\\' then 1\\n            else 0\\n        end) as confirmed_action\\n    from Signups s\\n    left join Confirmations c \\n        on c.user_id = s.user_id\\n    group by s.user_id\\n),\\nfinal as (   \\n    select \\n        user_id,\\n        round(confirmed_action / (confirmed_action + timeout_action + no_action),2) as confirmation_rate\\n    from actions_total\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "no3",
                        "content": "SELECT s.user_id, round(Coalesce(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON c.user_id = s.user_id\\nGROUP BY s.user_id\\nORDER BY confirmation_rate\\n"
                    },
                    {
                        "username": "chetansinh",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a\\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "himsm",
                        "content": "with t1\\nas (select user_id, count(action) conf_cnt\\nfrom confirmations\\nwhere action=\\'confirmed\\'\\ngroup by user_id),\\n\\nt2\\nas (select user_id, count(*) totlcnt\\nfrom confirmations\\ngroup by user_id),\\n\\nt3 as (select s.user_id user_id, coalesce(conf_cnt,0) as confirm_cnt,coalesce(totlcnt,1) as total_cnt\\nfrom signups s\\nleft join t1\\non s.user_id=t1.user_id\\nleft join t2\\non s.user_id=t2.user_id\\ngroup by s.user_id)\\n\\nselect t3.user_id, confirm_cnt/total_cnt confirmation_rate\\nfrom t3\\ngroup by t3.user_id;\\n\\n\\nquery is running correctly, but not getting submitted."
                    },
                    {
                        "username": "subashini_Senthilkumar",
                        "content": "with cte1 as(select user_id, count(user_id) as o from confirmations group by user_id),\\ncte2 as (select user_id, count(user_id) as oc from confirmations where action = \\'confirmed\\' group by user_id),\\ncte3 as (select cte1.user_id, oc/o as cr from cte1 left join cte2 on cte1.user_id = cte2.user_id)\\n\\nselect s.user_id, (case when cr is null then 0 else round(cr,2) end) as confirmation_rate from signups s left join cte3 c on s.user_id = c.user_id"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT\\nS.USER_ID,\\nROUND((COUNT(CASE WHEN C.ACTION=\\'confirmed\\' THEN 1 END)/count(*)),2) AS confirmation_rate\\nFROM SIGNUPS S\\nLEFT JOIN CONFIRMATIONS C\\nON S.USER_ID=C.USER_ID\\nGROUP BY S.USER_ID"
                    },
                    {
                        "username": "Omkarakandekar",
                        "content": "SELECT s.user_id, \n       IFNULL(SUM(CASE WHEN c.action = 'confirmed' THEN 1 ELSE 0 END) / COUNT(s.user_id), 0) AS confirmation_rate\nFROM Signups AS s\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\nGROUP BY s.user_id;\n\n\n#this is showing me error ..plz help me\n "
                    },
                    {
                        "username": "Vaibhav2002",
                        "content": "Could Somebody please tell me why I am able to use COALESCE to convert null to 0 but not able to use ISNULL function instead ?\\n\\n  `SELECT s.user_id, \\nCOALESCE(ROUND((SELECT COUNT(*) FROM Confirmations c1 WHERE action = \\'confirmed\\' AND c.user_id = c1.user_id) / (SELECT COUNT(*) FROM Confirmations c2 WHERE c.user_id = c2.user_id), 2), 0) AS confirmation_rate FROM Signups s LEFT JOIN Confirmations c USING(user_id) GROUP BY user_id`"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Simple Joins:\\n```\\nSELECT user_id,\\n       ROUND(IFNULL(IFNULL(t.conf, 0)/IFNULL(t1.total, 0), 0), 2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN (\\n             (SELECT COUNT(*) AS total,\\n                     user_id AS x_user_id\\n              FROM Confirmations\\n              GROUP BY user_id) AS t1\\n           LEFT JOIN\\n             (SELECT COUNT(*) AS conf,\\n                     user_id AS y_user_id\\n              FROM Confirmations\\n              WHERE action=\"confirmed\"\\n              GROUP BY user_id) AS t ON t1.x_user_id=t.y_user_id) ON t1.x_user_id=s.user_id\\n```"
                    },
                    {
                        "username": "abhijitpaul0212",
                        "content": "select s.user_id, round(ifnull(avg(action=\\'confirmed\\'),0),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;"
                    }
                ]
            },
            {
                "id": 2046927,
                "content": [
                    {
                        "username": "srjefers",
                        "content": "** ORACLE **\\n```\\n/* Write your PL/SQL query statement below */\\nwith actions_total as (\\n    select \\n        s.user_id,\\n        sum(case \\n            when c.user_id is null then 1\\n            else 0\\n        end) as no_action,\\n        sum(case \\n            when c.action = \\'timeout\\' then 1\\n            else 0\\n        end) as timeout_action,\\n        sum(case \\n            when c.action = \\'confirmed\\' then 1\\n            else 0\\n        end) as confirmed_action\\n    from Signups s\\n    left join Confirmations c \\n        on c.user_id = s.user_id\\n    group by s.user_id\\n),\\nfinal as (   \\n    select \\n        user_id,\\n        round(confirmed_action / (confirmed_action + timeout_action + no_action),2) as confirmation_rate\\n    from actions_total\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "no3",
                        "content": "SELECT s.user_id, round(Coalesce(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON c.user_id = s.user_id\\nGROUP BY s.user_id\\nORDER BY confirmation_rate\\n"
                    },
                    {
                        "username": "chetansinh",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a\\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "himsm",
                        "content": "with t1\\nas (select user_id, count(action) conf_cnt\\nfrom confirmations\\nwhere action=\\'confirmed\\'\\ngroup by user_id),\\n\\nt2\\nas (select user_id, count(*) totlcnt\\nfrom confirmations\\ngroup by user_id),\\n\\nt3 as (select s.user_id user_id, coalesce(conf_cnt,0) as confirm_cnt,coalesce(totlcnt,1) as total_cnt\\nfrom signups s\\nleft join t1\\non s.user_id=t1.user_id\\nleft join t2\\non s.user_id=t2.user_id\\ngroup by s.user_id)\\n\\nselect t3.user_id, confirm_cnt/total_cnt confirmation_rate\\nfrom t3\\ngroup by t3.user_id;\\n\\n\\nquery is running correctly, but not getting submitted."
                    },
                    {
                        "username": "subashini_Senthilkumar",
                        "content": "with cte1 as(select user_id, count(user_id) as o from confirmations group by user_id),\\ncte2 as (select user_id, count(user_id) as oc from confirmations where action = \\'confirmed\\' group by user_id),\\ncte3 as (select cte1.user_id, oc/o as cr from cte1 left join cte2 on cte1.user_id = cte2.user_id)\\n\\nselect s.user_id, (case when cr is null then 0 else round(cr,2) end) as confirmation_rate from signups s left join cte3 c on s.user_id = c.user_id"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT\\nS.USER_ID,\\nROUND((COUNT(CASE WHEN C.ACTION=\\'confirmed\\' THEN 1 END)/count(*)),2) AS confirmation_rate\\nFROM SIGNUPS S\\nLEFT JOIN CONFIRMATIONS C\\nON S.USER_ID=C.USER_ID\\nGROUP BY S.USER_ID"
                    },
                    {
                        "username": "Omkarakandekar",
                        "content": "SELECT s.user_id, \n       IFNULL(SUM(CASE WHEN c.action = 'confirmed' THEN 1 ELSE 0 END) / COUNT(s.user_id), 0) AS confirmation_rate\nFROM Signups AS s\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\nGROUP BY s.user_id;\n\n\n#this is showing me error ..plz help me\n "
                    },
                    {
                        "username": "Vaibhav2002",
                        "content": "Could Somebody please tell me why I am able to use COALESCE to convert null to 0 but not able to use ISNULL function instead ?\\n\\n  `SELECT s.user_id, \\nCOALESCE(ROUND((SELECT COUNT(*) FROM Confirmations c1 WHERE action = \\'confirmed\\' AND c.user_id = c1.user_id) / (SELECT COUNT(*) FROM Confirmations c2 WHERE c.user_id = c2.user_id), 2), 0) AS confirmation_rate FROM Signups s LEFT JOIN Confirmations c USING(user_id) GROUP BY user_id`"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Simple Joins:\\n```\\nSELECT user_id,\\n       ROUND(IFNULL(IFNULL(t.conf, 0)/IFNULL(t1.total, 0), 0), 2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN (\\n             (SELECT COUNT(*) AS total,\\n                     user_id AS x_user_id\\n              FROM Confirmations\\n              GROUP BY user_id) AS t1\\n           LEFT JOIN\\n             (SELECT COUNT(*) AS conf,\\n                     user_id AS y_user_id\\n              FROM Confirmations\\n              WHERE action=\"confirmed\"\\n              GROUP BY user_id) AS t ON t1.x_user_id=t.y_user_id) ON t1.x_user_id=s.user_id\\n```"
                    },
                    {
                        "username": "abhijitpaul0212",
                        "content": "select s.user_id, round(ifnull(avg(action=\\'confirmed\\'),0),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;"
                    }
                ]
            },
            {
                "id": 2043773,
                "content": [
                    {
                        "username": "srjefers",
                        "content": "** ORACLE **\\n```\\n/* Write your PL/SQL query statement below */\\nwith actions_total as (\\n    select \\n        s.user_id,\\n        sum(case \\n            when c.user_id is null then 1\\n            else 0\\n        end) as no_action,\\n        sum(case \\n            when c.action = \\'timeout\\' then 1\\n            else 0\\n        end) as timeout_action,\\n        sum(case \\n            when c.action = \\'confirmed\\' then 1\\n            else 0\\n        end) as confirmed_action\\n    from Signups s\\n    left join Confirmations c \\n        on c.user_id = s.user_id\\n    group by s.user_id\\n),\\nfinal as (   \\n    select \\n        user_id,\\n        round(confirmed_action / (confirmed_action + timeout_action + no_action),2) as confirmation_rate\\n    from actions_total\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "no3",
                        "content": "SELECT s.user_id, round(Coalesce(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON c.user_id = s.user_id\\nGROUP BY s.user_id\\nORDER BY confirmation_rate\\n"
                    },
                    {
                        "username": "chetansinh",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a\\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "himsm",
                        "content": "with t1\\nas (select user_id, count(action) conf_cnt\\nfrom confirmations\\nwhere action=\\'confirmed\\'\\ngroup by user_id),\\n\\nt2\\nas (select user_id, count(*) totlcnt\\nfrom confirmations\\ngroup by user_id),\\n\\nt3 as (select s.user_id user_id, coalesce(conf_cnt,0) as confirm_cnt,coalesce(totlcnt,1) as total_cnt\\nfrom signups s\\nleft join t1\\non s.user_id=t1.user_id\\nleft join t2\\non s.user_id=t2.user_id\\ngroup by s.user_id)\\n\\nselect t3.user_id, confirm_cnt/total_cnt confirmation_rate\\nfrom t3\\ngroup by t3.user_id;\\n\\n\\nquery is running correctly, but not getting submitted."
                    },
                    {
                        "username": "subashini_Senthilkumar",
                        "content": "with cte1 as(select user_id, count(user_id) as o from confirmations group by user_id),\\ncte2 as (select user_id, count(user_id) as oc from confirmations where action = \\'confirmed\\' group by user_id),\\ncte3 as (select cte1.user_id, oc/o as cr from cte1 left join cte2 on cte1.user_id = cte2.user_id)\\n\\nselect s.user_id, (case when cr is null then 0 else round(cr,2) end) as confirmation_rate from signups s left join cte3 c on s.user_id = c.user_id"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT\\nS.USER_ID,\\nROUND((COUNT(CASE WHEN C.ACTION=\\'confirmed\\' THEN 1 END)/count(*)),2) AS confirmation_rate\\nFROM SIGNUPS S\\nLEFT JOIN CONFIRMATIONS C\\nON S.USER_ID=C.USER_ID\\nGROUP BY S.USER_ID"
                    },
                    {
                        "username": "Omkarakandekar",
                        "content": "SELECT s.user_id, \n       IFNULL(SUM(CASE WHEN c.action = 'confirmed' THEN 1 ELSE 0 END) / COUNT(s.user_id), 0) AS confirmation_rate\nFROM Signups AS s\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\nGROUP BY s.user_id;\n\n\n#this is showing me error ..plz help me\n "
                    },
                    {
                        "username": "Vaibhav2002",
                        "content": "Could Somebody please tell me why I am able to use COALESCE to convert null to 0 but not able to use ISNULL function instead ?\\n\\n  `SELECT s.user_id, \\nCOALESCE(ROUND((SELECT COUNT(*) FROM Confirmations c1 WHERE action = \\'confirmed\\' AND c.user_id = c1.user_id) / (SELECT COUNT(*) FROM Confirmations c2 WHERE c.user_id = c2.user_id), 2), 0) AS confirmation_rate FROM Signups s LEFT JOIN Confirmations c USING(user_id) GROUP BY user_id`"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Simple Joins:\\n```\\nSELECT user_id,\\n       ROUND(IFNULL(IFNULL(t.conf, 0)/IFNULL(t1.total, 0), 0), 2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN (\\n             (SELECT COUNT(*) AS total,\\n                     user_id AS x_user_id\\n              FROM Confirmations\\n              GROUP BY user_id) AS t1\\n           LEFT JOIN\\n             (SELECT COUNT(*) AS conf,\\n                     user_id AS y_user_id\\n              FROM Confirmations\\n              WHERE action=\"confirmed\"\\n              GROUP BY user_id) AS t ON t1.x_user_id=t.y_user_id) ON t1.x_user_id=s.user_id\\n```"
                    },
                    {
                        "username": "abhijitpaul0212",
                        "content": "select s.user_id, round(ifnull(avg(action=\\'confirmed\\'),0),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;"
                    }
                ]
            },
            {
                "id": 2042174,
                "content": [
                    {
                        "username": "srjefers",
                        "content": "** ORACLE **\\n```\\n/* Write your PL/SQL query statement below */\\nwith actions_total as (\\n    select \\n        s.user_id,\\n        sum(case \\n            when c.user_id is null then 1\\n            else 0\\n        end) as no_action,\\n        sum(case \\n            when c.action = \\'timeout\\' then 1\\n            else 0\\n        end) as timeout_action,\\n        sum(case \\n            when c.action = \\'confirmed\\' then 1\\n            else 0\\n        end) as confirmed_action\\n    from Signups s\\n    left join Confirmations c \\n        on c.user_id = s.user_id\\n    group by s.user_id\\n),\\nfinal as (   \\n    select \\n        user_id,\\n        round(confirmed_action / (confirmed_action + timeout_action + no_action),2) as confirmation_rate\\n    from actions_total\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "no3",
                        "content": "SELECT s.user_id, round(Coalesce(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON c.user_id = s.user_id\\nGROUP BY s.user_id\\nORDER BY confirmation_rate\\n"
                    },
                    {
                        "username": "chetansinh",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a\\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "himsm",
                        "content": "with t1\\nas (select user_id, count(action) conf_cnt\\nfrom confirmations\\nwhere action=\\'confirmed\\'\\ngroup by user_id),\\n\\nt2\\nas (select user_id, count(*) totlcnt\\nfrom confirmations\\ngroup by user_id),\\n\\nt3 as (select s.user_id user_id, coalesce(conf_cnt,0) as confirm_cnt,coalesce(totlcnt,1) as total_cnt\\nfrom signups s\\nleft join t1\\non s.user_id=t1.user_id\\nleft join t2\\non s.user_id=t2.user_id\\ngroup by s.user_id)\\n\\nselect t3.user_id, confirm_cnt/total_cnt confirmation_rate\\nfrom t3\\ngroup by t3.user_id;\\n\\n\\nquery is running correctly, but not getting submitted."
                    },
                    {
                        "username": "subashini_Senthilkumar",
                        "content": "with cte1 as(select user_id, count(user_id) as o from confirmations group by user_id),\\ncte2 as (select user_id, count(user_id) as oc from confirmations where action = \\'confirmed\\' group by user_id),\\ncte3 as (select cte1.user_id, oc/o as cr from cte1 left join cte2 on cte1.user_id = cte2.user_id)\\n\\nselect s.user_id, (case when cr is null then 0 else round(cr,2) end) as confirmation_rate from signups s left join cte3 c on s.user_id = c.user_id"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT\\nS.USER_ID,\\nROUND((COUNT(CASE WHEN C.ACTION=\\'confirmed\\' THEN 1 END)/count(*)),2) AS confirmation_rate\\nFROM SIGNUPS S\\nLEFT JOIN CONFIRMATIONS C\\nON S.USER_ID=C.USER_ID\\nGROUP BY S.USER_ID"
                    },
                    {
                        "username": "Omkarakandekar",
                        "content": "SELECT s.user_id, \n       IFNULL(SUM(CASE WHEN c.action = 'confirmed' THEN 1 ELSE 0 END) / COUNT(s.user_id), 0) AS confirmation_rate\nFROM Signups AS s\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\nGROUP BY s.user_id;\n\n\n#this is showing me error ..plz help me\n "
                    },
                    {
                        "username": "Vaibhav2002",
                        "content": "Could Somebody please tell me why I am able to use COALESCE to convert null to 0 but not able to use ISNULL function instead ?\\n\\n  `SELECT s.user_id, \\nCOALESCE(ROUND((SELECT COUNT(*) FROM Confirmations c1 WHERE action = \\'confirmed\\' AND c.user_id = c1.user_id) / (SELECT COUNT(*) FROM Confirmations c2 WHERE c.user_id = c2.user_id), 2), 0) AS confirmation_rate FROM Signups s LEFT JOIN Confirmations c USING(user_id) GROUP BY user_id`"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Simple Joins:\\n```\\nSELECT user_id,\\n       ROUND(IFNULL(IFNULL(t.conf, 0)/IFNULL(t1.total, 0), 0), 2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN (\\n             (SELECT COUNT(*) AS total,\\n                     user_id AS x_user_id\\n              FROM Confirmations\\n              GROUP BY user_id) AS t1\\n           LEFT JOIN\\n             (SELECT COUNT(*) AS conf,\\n                     user_id AS y_user_id\\n              FROM Confirmations\\n              WHERE action=\"confirmed\"\\n              GROUP BY user_id) AS t ON t1.x_user_id=t.y_user_id) ON t1.x_user_id=s.user_id\\n```"
                    },
                    {
                        "username": "abhijitpaul0212",
                        "content": "select s.user_id, round(ifnull(avg(action=\\'confirmed\\'),0),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;"
                    }
                ]
            },
            {
                "id": 2035629,
                "content": [
                    {
                        "username": "srjefers",
                        "content": "** ORACLE **\\n```\\n/* Write your PL/SQL query statement below */\\nwith actions_total as (\\n    select \\n        s.user_id,\\n        sum(case \\n            when c.user_id is null then 1\\n            else 0\\n        end) as no_action,\\n        sum(case \\n            when c.action = \\'timeout\\' then 1\\n            else 0\\n        end) as timeout_action,\\n        sum(case \\n            when c.action = \\'confirmed\\' then 1\\n            else 0\\n        end) as confirmed_action\\n    from Signups s\\n    left join Confirmations c \\n        on c.user_id = s.user_id\\n    group by s.user_id\\n),\\nfinal as (   \\n    select \\n        user_id,\\n        round(confirmed_action / (confirmed_action + timeout_action + no_action),2) as confirmation_rate\\n    from actions_total\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "no3",
                        "content": "SELECT s.user_id, round(Coalesce(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON c.user_id = s.user_id\\nGROUP BY s.user_id\\nORDER BY confirmation_rate\\n"
                    },
                    {
                        "username": "chetansinh",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a\\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "himsm",
                        "content": "with t1\\nas (select user_id, count(action) conf_cnt\\nfrom confirmations\\nwhere action=\\'confirmed\\'\\ngroup by user_id),\\n\\nt2\\nas (select user_id, count(*) totlcnt\\nfrom confirmations\\ngroup by user_id),\\n\\nt3 as (select s.user_id user_id, coalesce(conf_cnt,0) as confirm_cnt,coalesce(totlcnt,1) as total_cnt\\nfrom signups s\\nleft join t1\\non s.user_id=t1.user_id\\nleft join t2\\non s.user_id=t2.user_id\\ngroup by s.user_id)\\n\\nselect t3.user_id, confirm_cnt/total_cnt confirmation_rate\\nfrom t3\\ngroup by t3.user_id;\\n\\n\\nquery is running correctly, but not getting submitted."
                    },
                    {
                        "username": "subashini_Senthilkumar",
                        "content": "with cte1 as(select user_id, count(user_id) as o from confirmations group by user_id),\\ncte2 as (select user_id, count(user_id) as oc from confirmations where action = \\'confirmed\\' group by user_id),\\ncte3 as (select cte1.user_id, oc/o as cr from cte1 left join cte2 on cte1.user_id = cte2.user_id)\\n\\nselect s.user_id, (case when cr is null then 0 else round(cr,2) end) as confirmation_rate from signups s left join cte3 c on s.user_id = c.user_id"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT\\nS.USER_ID,\\nROUND((COUNT(CASE WHEN C.ACTION=\\'confirmed\\' THEN 1 END)/count(*)),2) AS confirmation_rate\\nFROM SIGNUPS S\\nLEFT JOIN CONFIRMATIONS C\\nON S.USER_ID=C.USER_ID\\nGROUP BY S.USER_ID"
                    },
                    {
                        "username": "Omkarakandekar",
                        "content": "SELECT s.user_id, \n       IFNULL(SUM(CASE WHEN c.action = 'confirmed' THEN 1 ELSE 0 END) / COUNT(s.user_id), 0) AS confirmation_rate\nFROM Signups AS s\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\nGROUP BY s.user_id;\n\n\n#this is showing me error ..plz help me\n "
                    },
                    {
                        "username": "Vaibhav2002",
                        "content": "Could Somebody please tell me why I am able to use COALESCE to convert null to 0 but not able to use ISNULL function instead ?\\n\\n  `SELECT s.user_id, \\nCOALESCE(ROUND((SELECT COUNT(*) FROM Confirmations c1 WHERE action = \\'confirmed\\' AND c.user_id = c1.user_id) / (SELECT COUNT(*) FROM Confirmations c2 WHERE c.user_id = c2.user_id), 2), 0) AS confirmation_rate FROM Signups s LEFT JOIN Confirmations c USING(user_id) GROUP BY user_id`"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Simple Joins:\\n```\\nSELECT user_id,\\n       ROUND(IFNULL(IFNULL(t.conf, 0)/IFNULL(t1.total, 0), 0), 2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN (\\n             (SELECT COUNT(*) AS total,\\n                     user_id AS x_user_id\\n              FROM Confirmations\\n              GROUP BY user_id) AS t1\\n           LEFT JOIN\\n             (SELECT COUNT(*) AS conf,\\n                     user_id AS y_user_id\\n              FROM Confirmations\\n              WHERE action=\"confirmed\"\\n              GROUP BY user_id) AS t ON t1.x_user_id=t.y_user_id) ON t1.x_user_id=s.user_id\\n```"
                    },
                    {
                        "username": "abhijitpaul0212",
                        "content": "select s.user_id, round(ifnull(avg(action=\\'confirmed\\'),0),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;"
                    }
                ]
            },
            {
                "id": 2024904,
                "content": [
                    {
                        "username": "srjefers",
                        "content": "** ORACLE **\\n```\\n/* Write your PL/SQL query statement below */\\nwith actions_total as (\\n    select \\n        s.user_id,\\n        sum(case \\n            when c.user_id is null then 1\\n            else 0\\n        end) as no_action,\\n        sum(case \\n            when c.action = \\'timeout\\' then 1\\n            else 0\\n        end) as timeout_action,\\n        sum(case \\n            when c.action = \\'confirmed\\' then 1\\n            else 0\\n        end) as confirmed_action\\n    from Signups s\\n    left join Confirmations c \\n        on c.user_id = s.user_id\\n    group by s.user_id\\n),\\nfinal as (   \\n    select \\n        user_id,\\n        round(confirmed_action / (confirmed_action + timeout_action + no_action),2) as confirmation_rate\\n    from actions_total\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "no3",
                        "content": "SELECT s.user_id, round(Coalesce(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON c.user_id = s.user_id\\nGROUP BY s.user_id\\nORDER BY confirmation_rate\\n"
                    },
                    {
                        "username": "chetansinh",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a\\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "himsm",
                        "content": "with t1\\nas (select user_id, count(action) conf_cnt\\nfrom confirmations\\nwhere action=\\'confirmed\\'\\ngroup by user_id),\\n\\nt2\\nas (select user_id, count(*) totlcnt\\nfrom confirmations\\ngroup by user_id),\\n\\nt3 as (select s.user_id user_id, coalesce(conf_cnt,0) as confirm_cnt,coalesce(totlcnt,1) as total_cnt\\nfrom signups s\\nleft join t1\\non s.user_id=t1.user_id\\nleft join t2\\non s.user_id=t2.user_id\\ngroup by s.user_id)\\n\\nselect t3.user_id, confirm_cnt/total_cnt confirmation_rate\\nfrom t3\\ngroup by t3.user_id;\\n\\n\\nquery is running correctly, but not getting submitted."
                    },
                    {
                        "username": "subashini_Senthilkumar",
                        "content": "with cte1 as(select user_id, count(user_id) as o from confirmations group by user_id),\\ncte2 as (select user_id, count(user_id) as oc from confirmations where action = \\'confirmed\\' group by user_id),\\ncte3 as (select cte1.user_id, oc/o as cr from cte1 left join cte2 on cte1.user_id = cte2.user_id)\\n\\nselect s.user_id, (case when cr is null then 0 else round(cr,2) end) as confirmation_rate from signups s left join cte3 c on s.user_id = c.user_id"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT\\nS.USER_ID,\\nROUND((COUNT(CASE WHEN C.ACTION=\\'confirmed\\' THEN 1 END)/count(*)),2) AS confirmation_rate\\nFROM SIGNUPS S\\nLEFT JOIN CONFIRMATIONS C\\nON S.USER_ID=C.USER_ID\\nGROUP BY S.USER_ID"
                    },
                    {
                        "username": "Omkarakandekar",
                        "content": "SELECT s.user_id, \n       IFNULL(SUM(CASE WHEN c.action = 'confirmed' THEN 1 ELSE 0 END) / COUNT(s.user_id), 0) AS confirmation_rate\nFROM Signups AS s\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\nGROUP BY s.user_id;\n\n\n#this is showing me error ..plz help me\n "
                    },
                    {
                        "username": "Vaibhav2002",
                        "content": "Could Somebody please tell me why I am able to use COALESCE to convert null to 0 but not able to use ISNULL function instead ?\\n\\n  `SELECT s.user_id, \\nCOALESCE(ROUND((SELECT COUNT(*) FROM Confirmations c1 WHERE action = \\'confirmed\\' AND c.user_id = c1.user_id) / (SELECT COUNT(*) FROM Confirmations c2 WHERE c.user_id = c2.user_id), 2), 0) AS confirmation_rate FROM Signups s LEFT JOIN Confirmations c USING(user_id) GROUP BY user_id`"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Simple Joins:\\n```\\nSELECT user_id,\\n       ROUND(IFNULL(IFNULL(t.conf, 0)/IFNULL(t1.total, 0), 0), 2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN (\\n             (SELECT COUNT(*) AS total,\\n                     user_id AS x_user_id\\n              FROM Confirmations\\n              GROUP BY user_id) AS t1\\n           LEFT JOIN\\n             (SELECT COUNT(*) AS conf,\\n                     user_id AS y_user_id\\n              FROM Confirmations\\n              WHERE action=\"confirmed\"\\n              GROUP BY user_id) AS t ON t1.x_user_id=t.y_user_id) ON t1.x_user_id=s.user_id\\n```"
                    },
                    {
                        "username": "abhijitpaul0212",
                        "content": "select s.user_id, round(ifnull(avg(action=\\'confirmed\\'),0),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;"
                    }
                ]
            },
            {
                "id": 2024269,
                "content": [
                    {
                        "username": "srjefers",
                        "content": "** ORACLE **\\n```\\n/* Write your PL/SQL query statement below */\\nwith actions_total as (\\n    select \\n        s.user_id,\\n        sum(case \\n            when c.user_id is null then 1\\n            else 0\\n        end) as no_action,\\n        sum(case \\n            when c.action = \\'timeout\\' then 1\\n            else 0\\n        end) as timeout_action,\\n        sum(case \\n            when c.action = \\'confirmed\\' then 1\\n            else 0\\n        end) as confirmed_action\\n    from Signups s\\n    left join Confirmations c \\n        on c.user_id = s.user_id\\n    group by s.user_id\\n),\\nfinal as (   \\n    select \\n        user_id,\\n        round(confirmed_action / (confirmed_action + timeout_action + no_action),2) as confirmation_rate\\n    from actions_total\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "no3",
                        "content": "SELECT s.user_id, round(Coalesce(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON c.user_id = s.user_id\\nGROUP BY s.user_id\\nORDER BY confirmation_rate\\n"
                    },
                    {
                        "username": "chetansinh",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a\\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "himsm",
                        "content": "with t1\\nas (select user_id, count(action) conf_cnt\\nfrom confirmations\\nwhere action=\\'confirmed\\'\\ngroup by user_id),\\n\\nt2\\nas (select user_id, count(*) totlcnt\\nfrom confirmations\\ngroup by user_id),\\n\\nt3 as (select s.user_id user_id, coalesce(conf_cnt,0) as confirm_cnt,coalesce(totlcnt,1) as total_cnt\\nfrom signups s\\nleft join t1\\non s.user_id=t1.user_id\\nleft join t2\\non s.user_id=t2.user_id\\ngroup by s.user_id)\\n\\nselect t3.user_id, confirm_cnt/total_cnt confirmation_rate\\nfrom t3\\ngroup by t3.user_id;\\n\\n\\nquery is running correctly, but not getting submitted."
                    },
                    {
                        "username": "subashini_Senthilkumar",
                        "content": "with cte1 as(select user_id, count(user_id) as o from confirmations group by user_id),\\ncte2 as (select user_id, count(user_id) as oc from confirmations where action = \\'confirmed\\' group by user_id),\\ncte3 as (select cte1.user_id, oc/o as cr from cte1 left join cte2 on cte1.user_id = cte2.user_id)\\n\\nselect s.user_id, (case when cr is null then 0 else round(cr,2) end) as confirmation_rate from signups s left join cte3 c on s.user_id = c.user_id"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT\\nS.USER_ID,\\nROUND((COUNT(CASE WHEN C.ACTION=\\'confirmed\\' THEN 1 END)/count(*)),2) AS confirmation_rate\\nFROM SIGNUPS S\\nLEFT JOIN CONFIRMATIONS C\\nON S.USER_ID=C.USER_ID\\nGROUP BY S.USER_ID"
                    },
                    {
                        "username": "Omkarakandekar",
                        "content": "SELECT s.user_id, \n       IFNULL(SUM(CASE WHEN c.action = 'confirmed' THEN 1 ELSE 0 END) / COUNT(s.user_id), 0) AS confirmation_rate\nFROM Signups AS s\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\nGROUP BY s.user_id;\n\n\n#this is showing me error ..plz help me\n "
                    },
                    {
                        "username": "Vaibhav2002",
                        "content": "Could Somebody please tell me why I am able to use COALESCE to convert null to 0 but not able to use ISNULL function instead ?\\n\\n  `SELECT s.user_id, \\nCOALESCE(ROUND((SELECT COUNT(*) FROM Confirmations c1 WHERE action = \\'confirmed\\' AND c.user_id = c1.user_id) / (SELECT COUNT(*) FROM Confirmations c2 WHERE c.user_id = c2.user_id), 2), 0) AS confirmation_rate FROM Signups s LEFT JOIN Confirmations c USING(user_id) GROUP BY user_id`"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Simple Joins:\\n```\\nSELECT user_id,\\n       ROUND(IFNULL(IFNULL(t.conf, 0)/IFNULL(t1.total, 0), 0), 2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN (\\n             (SELECT COUNT(*) AS total,\\n                     user_id AS x_user_id\\n              FROM Confirmations\\n              GROUP BY user_id) AS t1\\n           LEFT JOIN\\n             (SELECT COUNT(*) AS conf,\\n                     user_id AS y_user_id\\n              FROM Confirmations\\n              WHERE action=\"confirmed\"\\n              GROUP BY user_id) AS t ON t1.x_user_id=t.y_user_id) ON t1.x_user_id=s.user_id\\n```"
                    },
                    {
                        "username": "abhijitpaul0212",
                        "content": "select s.user_id, round(ifnull(avg(action=\\'confirmed\\'),0),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;"
                    }
                ]
            },
            {
                "id": 2021469,
                "content": [
                    {
                        "username": "srjefers",
                        "content": "** ORACLE **\\n```\\n/* Write your PL/SQL query statement below */\\nwith actions_total as (\\n    select \\n        s.user_id,\\n        sum(case \\n            when c.user_id is null then 1\\n            else 0\\n        end) as no_action,\\n        sum(case \\n            when c.action = \\'timeout\\' then 1\\n            else 0\\n        end) as timeout_action,\\n        sum(case \\n            when c.action = \\'confirmed\\' then 1\\n            else 0\\n        end) as confirmed_action\\n    from Signups s\\n    left join Confirmations c \\n        on c.user_id = s.user_id\\n    group by s.user_id\\n),\\nfinal as (   \\n    select \\n        user_id,\\n        round(confirmed_action / (confirmed_action + timeout_action + no_action),2) as confirmation_rate\\n    from actions_total\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "no3",
                        "content": "SELECT s.user_id, round(Coalesce(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups s\\nLEFT JOIN Confirmations c\\nON c.user_id = s.user_id\\nGROUP BY s.user_id\\nORDER BY confirmation_rate\\n"
                    },
                    {
                        "username": "chetansinh",
                        "content": "SELECT a.user_id, round(ifnull(avg(action = \\'confirmed\\'), 0),2) as confirmation_rate\\nFROM Signups a\\nLEFT JOIN Confirmations b\\nON a.user_id = b.user_id\\nGROUP BY a.user_id"
                    },
                    {
                        "username": "himsm",
                        "content": "with t1\\nas (select user_id, count(action) conf_cnt\\nfrom confirmations\\nwhere action=\\'confirmed\\'\\ngroup by user_id),\\n\\nt2\\nas (select user_id, count(*) totlcnt\\nfrom confirmations\\ngroup by user_id),\\n\\nt3 as (select s.user_id user_id, coalesce(conf_cnt,0) as confirm_cnt,coalesce(totlcnt,1) as total_cnt\\nfrom signups s\\nleft join t1\\non s.user_id=t1.user_id\\nleft join t2\\non s.user_id=t2.user_id\\ngroup by s.user_id)\\n\\nselect t3.user_id, confirm_cnt/total_cnt confirmation_rate\\nfrom t3\\ngroup by t3.user_id;\\n\\n\\nquery is running correctly, but not getting submitted."
                    },
                    {
                        "username": "subashini_Senthilkumar",
                        "content": "with cte1 as(select user_id, count(user_id) as o from confirmations group by user_id),\\ncte2 as (select user_id, count(user_id) as oc from confirmations where action = \\'confirmed\\' group by user_id),\\ncte3 as (select cte1.user_id, oc/o as cr from cte1 left join cte2 on cte1.user_id = cte2.user_id)\\n\\nselect s.user_id, (case when cr is null then 0 else round(cr,2) end) as confirmation_rate from signups s left join cte3 c on s.user_id = c.user_id"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT\\nS.USER_ID,\\nROUND((COUNT(CASE WHEN C.ACTION=\\'confirmed\\' THEN 1 END)/count(*)),2) AS confirmation_rate\\nFROM SIGNUPS S\\nLEFT JOIN CONFIRMATIONS C\\nON S.USER_ID=C.USER_ID\\nGROUP BY S.USER_ID"
                    },
                    {
                        "username": "Omkarakandekar",
                        "content": "SELECT s.user_id, \n       IFNULL(SUM(CASE WHEN c.action = 'confirmed' THEN 1 ELSE 0 END) / COUNT(s.user_id), 0) AS confirmation_rate\nFROM Signups AS s\nLEFT JOIN Confirmations AS c ON s.user_id = c.user_id\nGROUP BY s.user_id;\n\n\n#this is showing me error ..plz help me\n "
                    },
                    {
                        "username": "Vaibhav2002",
                        "content": "Could Somebody please tell me why I am able to use COALESCE to convert null to 0 but not able to use ISNULL function instead ?\\n\\n  `SELECT s.user_id, \\nCOALESCE(ROUND((SELECT COUNT(*) FROM Confirmations c1 WHERE action = \\'confirmed\\' AND c.user_id = c1.user_id) / (SELECT COUNT(*) FROM Confirmations c2 WHERE c.user_id = c2.user_id), 2), 0) AS confirmation_rate FROM Signups s LEFT JOIN Confirmations c USING(user_id) GROUP BY user_id`"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Simple Joins:\\n```\\nSELECT user_id,\\n       ROUND(IFNULL(IFNULL(t.conf, 0)/IFNULL(t1.total, 0), 0), 2) AS confirmation_rate\\nFROM Signups s\\nLEFT JOIN (\\n             (SELECT COUNT(*) AS total,\\n                     user_id AS x_user_id\\n              FROM Confirmations\\n              GROUP BY user_id) AS t1\\n           LEFT JOIN\\n             (SELECT COUNT(*) AS conf,\\n                     user_id AS y_user_id\\n              FROM Confirmations\\n              WHERE action=\"confirmed\"\\n              GROUP BY user_id) AS t ON t1.x_user_id=t.y_user_id) ON t1.x_user_id=s.user_id\\n```"
                    },
                    {
                        "username": "abhijitpaul0212",
                        "content": "select s.user_id, round(ifnull(avg(action=\\'confirmed\\'),0),2) as confirmation_rate from Signups s left join Confirmations c on s.user_id=c.user_id group by s.user_id;"
                    }
                ]
            },
            {
                "id": 2015971,
                "content": [
                    {
                        "username": "Schnedarb",
                        "content": "The question states \"Return the result table in any order\" which is NOT TRUE. \\n\\nThis output is \"wrong\" \\n| user_id | confirmation_rate |\\n| ------- | ----------------- |\\n| 3       | 0                 |\\n| 6       | 0                 |\\n| 7       | 1                 |\\n| 2       | 0.5               |"
                    },
                    {
                        "username": "r_roy",
                        "content": "SELECT\\n    a.user_id,\\n    IFNULL(\\n        ROUND (IFNULL(\\n            NULLIF(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/COUNT(*), 0),\\n            0\\n        ) ,2),\\n        0\\n    ) AS confirmation_rate\\nFROM signups a\\nLEFT JOIN confirmations c ON a.user_id = c.user_id\\nGROUP BY a.user_id;\\n\\n\\nI have a doubt here, wont this cause Division by 0 error?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Create script for this question does not work in MS Sql Server. What is the alternative to Enum in T-SQL? "
                    },
                    {
                        "username": "katyayanialisha",
                        "content": "select Signups.user_id , round(sum(IF(confirmations.action=\"confirmed\",1,0))/count(confirmations.action),2) as  confirmations_rate  from Signups join Confirmations\\non \\nSignups.user_id=Confirmations.user_id group by Confirmations.user_id\\n\\n\\nWHAT AM I DOING WRONG HERE?"
                    },
                    {
                        "username": "jaijaria032001",
                        "content": "did the same thing.\\n"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select\\nUser_id,\\nifnull(\\nround(\\nsum(case when action=\"confirmed\" then 1 else 0 end)/count(action),2),0) as confirmation_rate \\n from \\n(SELECT s.user_id,c.action FROM Signups s \\nleft join\\nConfirmations c on \\ns.user_id=c.user_id)a\\ngroup by user_id"
                    },
                    {
                        "username": "Tuchdov",
                        "content": "**anyone know what that means?**\nexecute command denied to user 'student'@'%' for routine 'c.action'\n\nthis was my code (spoilers ahead)\n-\n-\n- `select s.user_id, round(avg(if(c.action(\"confirmed\"),1,0)),2) as confirmation_rate\nfrom Signups s\nleft join Confirmations c on c.user_id = s.user_id\ngroup by s.user_id;`"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Try c.action=\"confirmed\" inside if"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "select sp.user_id, round(coalesce(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)/(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)+sum(case when ct.action=\\'timeout\\' then 1 else 0 end)),0),2) as confirmation_rate from signups sp\\n    left join confirmations ct on sp.user_id=ct.user_id\\n    group by sp.user_id"
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "I see that input is wrong as I run the query for confirmations\\n"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select Signups.user_id,ROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2)  as confirmation_rate from Signups left join Confirmations on Signups.user_id = Confirmations.user_id group by Signups.user_id;\\nit\\'s working properly."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Why can\\'t we use ifnull instead of coalesce?\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "SELECT USER_ID,\\nROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2) AS confirmation_rate\\nFROM(\\nSELECT \\n      S.USER_ID,\\n      C.ACTION\\nFROM SIGNUPS S LEFT JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\n)tmp\\nGROUP BY USER_ID"
                    }
                ]
            },
            {
                "id": 2015052,
                "content": [
                    {
                        "username": "Schnedarb",
                        "content": "The question states \"Return the result table in any order\" which is NOT TRUE. \\n\\nThis output is \"wrong\" \\n| user_id | confirmation_rate |\\n| ------- | ----------------- |\\n| 3       | 0                 |\\n| 6       | 0                 |\\n| 7       | 1                 |\\n| 2       | 0.5               |"
                    },
                    {
                        "username": "r_roy",
                        "content": "SELECT\\n    a.user_id,\\n    IFNULL(\\n        ROUND (IFNULL(\\n            NULLIF(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/COUNT(*), 0),\\n            0\\n        ) ,2),\\n        0\\n    ) AS confirmation_rate\\nFROM signups a\\nLEFT JOIN confirmations c ON a.user_id = c.user_id\\nGROUP BY a.user_id;\\n\\n\\nI have a doubt here, wont this cause Division by 0 error?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Create script for this question does not work in MS Sql Server. What is the alternative to Enum in T-SQL? "
                    },
                    {
                        "username": "katyayanialisha",
                        "content": "select Signups.user_id , round(sum(IF(confirmations.action=\"confirmed\",1,0))/count(confirmations.action),2) as  confirmations_rate  from Signups join Confirmations\\non \\nSignups.user_id=Confirmations.user_id group by Confirmations.user_id\\n\\n\\nWHAT AM I DOING WRONG HERE?"
                    },
                    {
                        "username": "jaijaria032001",
                        "content": "did the same thing.\\n"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select\\nUser_id,\\nifnull(\\nround(\\nsum(case when action=\"confirmed\" then 1 else 0 end)/count(action),2),0) as confirmation_rate \\n from \\n(SELECT s.user_id,c.action FROM Signups s \\nleft join\\nConfirmations c on \\ns.user_id=c.user_id)a\\ngroup by user_id"
                    },
                    {
                        "username": "Tuchdov",
                        "content": "**anyone know what that means?**\nexecute command denied to user 'student'@'%' for routine 'c.action'\n\nthis was my code (spoilers ahead)\n-\n-\n- `select s.user_id, round(avg(if(c.action(\"confirmed\"),1,0)),2) as confirmation_rate\nfrom Signups s\nleft join Confirmations c on c.user_id = s.user_id\ngroup by s.user_id;`"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Try c.action=\"confirmed\" inside if"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "select sp.user_id, round(coalesce(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)/(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)+sum(case when ct.action=\\'timeout\\' then 1 else 0 end)),0),2) as confirmation_rate from signups sp\\n    left join confirmations ct on sp.user_id=ct.user_id\\n    group by sp.user_id"
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "I see that input is wrong as I run the query for confirmations\\n"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select Signups.user_id,ROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2)  as confirmation_rate from Signups left join Confirmations on Signups.user_id = Confirmations.user_id group by Signups.user_id;\\nit\\'s working properly."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Why can\\'t we use ifnull instead of coalesce?\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "SELECT USER_ID,\\nROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2) AS confirmation_rate\\nFROM(\\nSELECT \\n      S.USER_ID,\\n      C.ACTION\\nFROM SIGNUPS S LEFT JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\n)tmp\\nGROUP BY USER_ID"
                    }
                ]
            },
            {
                "id": 1993948,
                "content": [
                    {
                        "username": "Schnedarb",
                        "content": "The question states \"Return the result table in any order\" which is NOT TRUE. \\n\\nThis output is \"wrong\" \\n| user_id | confirmation_rate |\\n| ------- | ----------------- |\\n| 3       | 0                 |\\n| 6       | 0                 |\\n| 7       | 1                 |\\n| 2       | 0.5               |"
                    },
                    {
                        "username": "r_roy",
                        "content": "SELECT\\n    a.user_id,\\n    IFNULL(\\n        ROUND (IFNULL(\\n            NULLIF(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/COUNT(*), 0),\\n            0\\n        ) ,2),\\n        0\\n    ) AS confirmation_rate\\nFROM signups a\\nLEFT JOIN confirmations c ON a.user_id = c.user_id\\nGROUP BY a.user_id;\\n\\n\\nI have a doubt here, wont this cause Division by 0 error?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Create script for this question does not work in MS Sql Server. What is the alternative to Enum in T-SQL? "
                    },
                    {
                        "username": "katyayanialisha",
                        "content": "select Signups.user_id , round(sum(IF(confirmations.action=\"confirmed\",1,0))/count(confirmations.action),2) as  confirmations_rate  from Signups join Confirmations\\non \\nSignups.user_id=Confirmations.user_id group by Confirmations.user_id\\n\\n\\nWHAT AM I DOING WRONG HERE?"
                    },
                    {
                        "username": "jaijaria032001",
                        "content": "did the same thing.\\n"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select\\nUser_id,\\nifnull(\\nround(\\nsum(case when action=\"confirmed\" then 1 else 0 end)/count(action),2),0) as confirmation_rate \\n from \\n(SELECT s.user_id,c.action FROM Signups s \\nleft join\\nConfirmations c on \\ns.user_id=c.user_id)a\\ngroup by user_id"
                    },
                    {
                        "username": "Tuchdov",
                        "content": "**anyone know what that means?**\nexecute command denied to user 'student'@'%' for routine 'c.action'\n\nthis was my code (spoilers ahead)\n-\n-\n- `select s.user_id, round(avg(if(c.action(\"confirmed\"),1,0)),2) as confirmation_rate\nfrom Signups s\nleft join Confirmations c on c.user_id = s.user_id\ngroup by s.user_id;`"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Try c.action=\"confirmed\" inside if"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "select sp.user_id, round(coalesce(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)/(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)+sum(case when ct.action=\\'timeout\\' then 1 else 0 end)),0),2) as confirmation_rate from signups sp\\n    left join confirmations ct on sp.user_id=ct.user_id\\n    group by sp.user_id"
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "I see that input is wrong as I run the query for confirmations\\n"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select Signups.user_id,ROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2)  as confirmation_rate from Signups left join Confirmations on Signups.user_id = Confirmations.user_id group by Signups.user_id;\\nit\\'s working properly."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Why can\\'t we use ifnull instead of coalesce?\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "SELECT USER_ID,\\nROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2) AS confirmation_rate\\nFROM(\\nSELECT \\n      S.USER_ID,\\n      C.ACTION\\nFROM SIGNUPS S LEFT JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\n)tmp\\nGROUP BY USER_ID"
                    }
                ]
            },
            {
                "id": 1969294,
                "content": [
                    {
                        "username": "Schnedarb",
                        "content": "The question states \"Return the result table in any order\" which is NOT TRUE. \\n\\nThis output is \"wrong\" \\n| user_id | confirmation_rate |\\n| ------- | ----------------- |\\n| 3       | 0                 |\\n| 6       | 0                 |\\n| 7       | 1                 |\\n| 2       | 0.5               |"
                    },
                    {
                        "username": "r_roy",
                        "content": "SELECT\\n    a.user_id,\\n    IFNULL(\\n        ROUND (IFNULL(\\n            NULLIF(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/COUNT(*), 0),\\n            0\\n        ) ,2),\\n        0\\n    ) AS confirmation_rate\\nFROM signups a\\nLEFT JOIN confirmations c ON a.user_id = c.user_id\\nGROUP BY a.user_id;\\n\\n\\nI have a doubt here, wont this cause Division by 0 error?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Create script for this question does not work in MS Sql Server. What is the alternative to Enum in T-SQL? "
                    },
                    {
                        "username": "katyayanialisha",
                        "content": "select Signups.user_id , round(sum(IF(confirmations.action=\"confirmed\",1,0))/count(confirmations.action),2) as  confirmations_rate  from Signups join Confirmations\\non \\nSignups.user_id=Confirmations.user_id group by Confirmations.user_id\\n\\n\\nWHAT AM I DOING WRONG HERE?"
                    },
                    {
                        "username": "jaijaria032001",
                        "content": "did the same thing.\\n"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select\\nUser_id,\\nifnull(\\nround(\\nsum(case when action=\"confirmed\" then 1 else 0 end)/count(action),2),0) as confirmation_rate \\n from \\n(SELECT s.user_id,c.action FROM Signups s \\nleft join\\nConfirmations c on \\ns.user_id=c.user_id)a\\ngroup by user_id"
                    },
                    {
                        "username": "Tuchdov",
                        "content": "**anyone know what that means?**\nexecute command denied to user 'student'@'%' for routine 'c.action'\n\nthis was my code (spoilers ahead)\n-\n-\n- `select s.user_id, round(avg(if(c.action(\"confirmed\"),1,0)),2) as confirmation_rate\nfrom Signups s\nleft join Confirmations c on c.user_id = s.user_id\ngroup by s.user_id;`"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Try c.action=\"confirmed\" inside if"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "select sp.user_id, round(coalesce(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)/(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)+sum(case when ct.action=\\'timeout\\' then 1 else 0 end)),0),2) as confirmation_rate from signups sp\\n    left join confirmations ct on sp.user_id=ct.user_id\\n    group by sp.user_id"
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "I see that input is wrong as I run the query for confirmations\\n"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select Signups.user_id,ROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2)  as confirmation_rate from Signups left join Confirmations on Signups.user_id = Confirmations.user_id group by Signups.user_id;\\nit\\'s working properly."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Why can\\'t we use ifnull instead of coalesce?\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "SELECT USER_ID,\\nROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2) AS confirmation_rate\\nFROM(\\nSELECT \\n      S.USER_ID,\\n      C.ACTION\\nFROM SIGNUPS S LEFT JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\n)tmp\\nGROUP BY USER_ID"
                    }
                ]
            },
            {
                "id": 1958983,
                "content": [
                    {
                        "username": "Schnedarb",
                        "content": "The question states \"Return the result table in any order\" which is NOT TRUE. \\n\\nThis output is \"wrong\" \\n| user_id | confirmation_rate |\\n| ------- | ----------------- |\\n| 3       | 0                 |\\n| 6       | 0                 |\\n| 7       | 1                 |\\n| 2       | 0.5               |"
                    },
                    {
                        "username": "r_roy",
                        "content": "SELECT\\n    a.user_id,\\n    IFNULL(\\n        ROUND (IFNULL(\\n            NULLIF(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/COUNT(*), 0),\\n            0\\n        ) ,2),\\n        0\\n    ) AS confirmation_rate\\nFROM signups a\\nLEFT JOIN confirmations c ON a.user_id = c.user_id\\nGROUP BY a.user_id;\\n\\n\\nI have a doubt here, wont this cause Division by 0 error?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Create script for this question does not work in MS Sql Server. What is the alternative to Enum in T-SQL? "
                    },
                    {
                        "username": "katyayanialisha",
                        "content": "select Signups.user_id , round(sum(IF(confirmations.action=\"confirmed\",1,0))/count(confirmations.action),2) as  confirmations_rate  from Signups join Confirmations\\non \\nSignups.user_id=Confirmations.user_id group by Confirmations.user_id\\n\\n\\nWHAT AM I DOING WRONG HERE?"
                    },
                    {
                        "username": "jaijaria032001",
                        "content": "did the same thing.\\n"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select\\nUser_id,\\nifnull(\\nround(\\nsum(case when action=\"confirmed\" then 1 else 0 end)/count(action),2),0) as confirmation_rate \\n from \\n(SELECT s.user_id,c.action FROM Signups s \\nleft join\\nConfirmations c on \\ns.user_id=c.user_id)a\\ngroup by user_id"
                    },
                    {
                        "username": "Tuchdov",
                        "content": "**anyone know what that means?**\nexecute command denied to user 'student'@'%' for routine 'c.action'\n\nthis was my code (spoilers ahead)\n-\n-\n- `select s.user_id, round(avg(if(c.action(\"confirmed\"),1,0)),2) as confirmation_rate\nfrom Signups s\nleft join Confirmations c on c.user_id = s.user_id\ngroup by s.user_id;`"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Try c.action=\"confirmed\" inside if"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "select sp.user_id, round(coalesce(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)/(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)+sum(case when ct.action=\\'timeout\\' then 1 else 0 end)),0),2) as confirmation_rate from signups sp\\n    left join confirmations ct on sp.user_id=ct.user_id\\n    group by sp.user_id"
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "I see that input is wrong as I run the query for confirmations\\n"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select Signups.user_id,ROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2)  as confirmation_rate from Signups left join Confirmations on Signups.user_id = Confirmations.user_id group by Signups.user_id;\\nit\\'s working properly."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Why can\\'t we use ifnull instead of coalesce?\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "SELECT USER_ID,\\nROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2) AS confirmation_rate\\nFROM(\\nSELECT \\n      S.USER_ID,\\n      C.ACTION\\nFROM SIGNUPS S LEFT JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\n)tmp\\nGROUP BY USER_ID"
                    }
                ]
            },
            {
                "id": 1958503,
                "content": [
                    {
                        "username": "Schnedarb",
                        "content": "The question states \"Return the result table in any order\" which is NOT TRUE. \\n\\nThis output is \"wrong\" \\n| user_id | confirmation_rate |\\n| ------- | ----------------- |\\n| 3       | 0                 |\\n| 6       | 0                 |\\n| 7       | 1                 |\\n| 2       | 0.5               |"
                    },
                    {
                        "username": "r_roy",
                        "content": "SELECT\\n    a.user_id,\\n    IFNULL(\\n        ROUND (IFNULL(\\n            NULLIF(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/COUNT(*), 0),\\n            0\\n        ) ,2),\\n        0\\n    ) AS confirmation_rate\\nFROM signups a\\nLEFT JOIN confirmations c ON a.user_id = c.user_id\\nGROUP BY a.user_id;\\n\\n\\nI have a doubt here, wont this cause Division by 0 error?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Create script for this question does not work in MS Sql Server. What is the alternative to Enum in T-SQL? "
                    },
                    {
                        "username": "katyayanialisha",
                        "content": "select Signups.user_id , round(sum(IF(confirmations.action=\"confirmed\",1,0))/count(confirmations.action),2) as  confirmations_rate  from Signups join Confirmations\\non \\nSignups.user_id=Confirmations.user_id group by Confirmations.user_id\\n\\n\\nWHAT AM I DOING WRONG HERE?"
                    },
                    {
                        "username": "jaijaria032001",
                        "content": "did the same thing.\\n"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select\\nUser_id,\\nifnull(\\nround(\\nsum(case when action=\"confirmed\" then 1 else 0 end)/count(action),2),0) as confirmation_rate \\n from \\n(SELECT s.user_id,c.action FROM Signups s \\nleft join\\nConfirmations c on \\ns.user_id=c.user_id)a\\ngroup by user_id"
                    },
                    {
                        "username": "Tuchdov",
                        "content": "**anyone know what that means?**\nexecute command denied to user 'student'@'%' for routine 'c.action'\n\nthis was my code (spoilers ahead)\n-\n-\n- `select s.user_id, round(avg(if(c.action(\"confirmed\"),1,0)),2) as confirmation_rate\nfrom Signups s\nleft join Confirmations c on c.user_id = s.user_id\ngroup by s.user_id;`"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Try c.action=\"confirmed\" inside if"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "select sp.user_id, round(coalesce(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)/(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)+sum(case when ct.action=\\'timeout\\' then 1 else 0 end)),0),2) as confirmation_rate from signups sp\\n    left join confirmations ct on sp.user_id=ct.user_id\\n    group by sp.user_id"
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "I see that input is wrong as I run the query for confirmations\\n"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select Signups.user_id,ROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2)  as confirmation_rate from Signups left join Confirmations on Signups.user_id = Confirmations.user_id group by Signups.user_id;\\nit\\'s working properly."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Why can\\'t we use ifnull instead of coalesce?\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "SELECT USER_ID,\\nROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2) AS confirmation_rate\\nFROM(\\nSELECT \\n      S.USER_ID,\\n      C.ACTION\\nFROM SIGNUPS S LEFT JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\n)tmp\\nGROUP BY USER_ID"
                    }
                ]
            },
            {
                "id": 1931188,
                "content": [
                    {
                        "username": "Schnedarb",
                        "content": "The question states \"Return the result table in any order\" which is NOT TRUE. \\n\\nThis output is \"wrong\" \\n| user_id | confirmation_rate |\\n| ------- | ----------------- |\\n| 3       | 0                 |\\n| 6       | 0                 |\\n| 7       | 1                 |\\n| 2       | 0.5               |"
                    },
                    {
                        "username": "r_roy",
                        "content": "SELECT\\n    a.user_id,\\n    IFNULL(\\n        ROUND (IFNULL(\\n            NULLIF(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/COUNT(*), 0),\\n            0\\n        ) ,2),\\n        0\\n    ) AS confirmation_rate\\nFROM signups a\\nLEFT JOIN confirmations c ON a.user_id = c.user_id\\nGROUP BY a.user_id;\\n\\n\\nI have a doubt here, wont this cause Division by 0 error?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Create script for this question does not work in MS Sql Server. What is the alternative to Enum in T-SQL? "
                    },
                    {
                        "username": "katyayanialisha",
                        "content": "select Signups.user_id , round(sum(IF(confirmations.action=\"confirmed\",1,0))/count(confirmations.action),2) as  confirmations_rate  from Signups join Confirmations\\non \\nSignups.user_id=Confirmations.user_id group by Confirmations.user_id\\n\\n\\nWHAT AM I DOING WRONG HERE?"
                    },
                    {
                        "username": "jaijaria032001",
                        "content": "did the same thing.\\n"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select\\nUser_id,\\nifnull(\\nround(\\nsum(case when action=\"confirmed\" then 1 else 0 end)/count(action),2),0) as confirmation_rate \\n from \\n(SELECT s.user_id,c.action FROM Signups s \\nleft join\\nConfirmations c on \\ns.user_id=c.user_id)a\\ngroup by user_id"
                    },
                    {
                        "username": "Tuchdov",
                        "content": "**anyone know what that means?**\nexecute command denied to user 'student'@'%' for routine 'c.action'\n\nthis was my code (spoilers ahead)\n-\n-\n- `select s.user_id, round(avg(if(c.action(\"confirmed\"),1,0)),2) as confirmation_rate\nfrom Signups s\nleft join Confirmations c on c.user_id = s.user_id\ngroup by s.user_id;`"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Try c.action=\"confirmed\" inside if"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "select sp.user_id, round(coalesce(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)/(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)+sum(case when ct.action=\\'timeout\\' then 1 else 0 end)),0),2) as confirmation_rate from signups sp\\n    left join confirmations ct on sp.user_id=ct.user_id\\n    group by sp.user_id"
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "I see that input is wrong as I run the query for confirmations\\n"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select Signups.user_id,ROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2)  as confirmation_rate from Signups left join Confirmations on Signups.user_id = Confirmations.user_id group by Signups.user_id;\\nit\\'s working properly."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Why can\\'t we use ifnull instead of coalesce?\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "SELECT USER_ID,\\nROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2) AS confirmation_rate\\nFROM(\\nSELECT \\n      S.USER_ID,\\n      C.ACTION\\nFROM SIGNUPS S LEFT JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\n)tmp\\nGROUP BY USER_ID"
                    }
                ]
            },
            {
                "id": 1913477,
                "content": [
                    {
                        "username": "Schnedarb",
                        "content": "The question states \"Return the result table in any order\" which is NOT TRUE. \\n\\nThis output is \"wrong\" \\n| user_id | confirmation_rate |\\n| ------- | ----------------- |\\n| 3       | 0                 |\\n| 6       | 0                 |\\n| 7       | 1                 |\\n| 2       | 0.5               |"
                    },
                    {
                        "username": "r_roy",
                        "content": "SELECT\\n    a.user_id,\\n    IFNULL(\\n        ROUND (IFNULL(\\n            NULLIF(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/COUNT(*), 0),\\n            0\\n        ) ,2),\\n        0\\n    ) AS confirmation_rate\\nFROM signups a\\nLEFT JOIN confirmations c ON a.user_id = c.user_id\\nGROUP BY a.user_id;\\n\\n\\nI have a doubt here, wont this cause Division by 0 error?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Create script for this question does not work in MS Sql Server. What is the alternative to Enum in T-SQL? "
                    },
                    {
                        "username": "katyayanialisha",
                        "content": "select Signups.user_id , round(sum(IF(confirmations.action=\"confirmed\",1,0))/count(confirmations.action),2) as  confirmations_rate  from Signups join Confirmations\\non \\nSignups.user_id=Confirmations.user_id group by Confirmations.user_id\\n\\n\\nWHAT AM I DOING WRONG HERE?"
                    },
                    {
                        "username": "jaijaria032001",
                        "content": "did the same thing.\\n"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select\\nUser_id,\\nifnull(\\nround(\\nsum(case when action=\"confirmed\" then 1 else 0 end)/count(action),2),0) as confirmation_rate \\n from \\n(SELECT s.user_id,c.action FROM Signups s \\nleft join\\nConfirmations c on \\ns.user_id=c.user_id)a\\ngroup by user_id"
                    },
                    {
                        "username": "Tuchdov",
                        "content": "**anyone know what that means?**\nexecute command denied to user 'student'@'%' for routine 'c.action'\n\nthis was my code (spoilers ahead)\n-\n-\n- `select s.user_id, round(avg(if(c.action(\"confirmed\"),1,0)),2) as confirmation_rate\nfrom Signups s\nleft join Confirmations c on c.user_id = s.user_id\ngroup by s.user_id;`"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Try c.action=\"confirmed\" inside if"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "select sp.user_id, round(coalesce(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)/(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)+sum(case when ct.action=\\'timeout\\' then 1 else 0 end)),0),2) as confirmation_rate from signups sp\\n    left join confirmations ct on sp.user_id=ct.user_id\\n    group by sp.user_id"
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "I see that input is wrong as I run the query for confirmations\\n"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select Signups.user_id,ROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2)  as confirmation_rate from Signups left join Confirmations on Signups.user_id = Confirmations.user_id group by Signups.user_id;\\nit\\'s working properly."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Why can\\'t we use ifnull instead of coalesce?\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "SELECT USER_ID,\\nROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2) AS confirmation_rate\\nFROM(\\nSELECT \\n      S.USER_ID,\\n      C.ACTION\\nFROM SIGNUPS S LEFT JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\n)tmp\\nGROUP BY USER_ID"
                    }
                ]
            },
            {
                "id": 1866770,
                "content": [
                    {
                        "username": "Schnedarb",
                        "content": "The question states \"Return the result table in any order\" which is NOT TRUE. \\n\\nThis output is \"wrong\" \\n| user_id | confirmation_rate |\\n| ------- | ----------------- |\\n| 3       | 0                 |\\n| 6       | 0                 |\\n| 7       | 1                 |\\n| 2       | 0.5               |"
                    },
                    {
                        "username": "r_roy",
                        "content": "SELECT\\n    a.user_id,\\n    IFNULL(\\n        ROUND (IFNULL(\\n            NULLIF(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/COUNT(*), 0),\\n            0\\n        ) ,2),\\n        0\\n    ) AS confirmation_rate\\nFROM signups a\\nLEFT JOIN confirmations c ON a.user_id = c.user_id\\nGROUP BY a.user_id;\\n\\n\\nI have a doubt here, wont this cause Division by 0 error?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Create script for this question does not work in MS Sql Server. What is the alternative to Enum in T-SQL? "
                    },
                    {
                        "username": "katyayanialisha",
                        "content": "select Signups.user_id , round(sum(IF(confirmations.action=\"confirmed\",1,0))/count(confirmations.action),2) as  confirmations_rate  from Signups join Confirmations\\non \\nSignups.user_id=Confirmations.user_id group by Confirmations.user_id\\n\\n\\nWHAT AM I DOING WRONG HERE?"
                    },
                    {
                        "username": "jaijaria032001",
                        "content": "did the same thing.\\n"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select\\nUser_id,\\nifnull(\\nround(\\nsum(case when action=\"confirmed\" then 1 else 0 end)/count(action),2),0) as confirmation_rate \\n from \\n(SELECT s.user_id,c.action FROM Signups s \\nleft join\\nConfirmations c on \\ns.user_id=c.user_id)a\\ngroup by user_id"
                    },
                    {
                        "username": "Tuchdov",
                        "content": "**anyone know what that means?**\nexecute command denied to user 'student'@'%' for routine 'c.action'\n\nthis was my code (spoilers ahead)\n-\n-\n- `select s.user_id, round(avg(if(c.action(\"confirmed\"),1,0)),2) as confirmation_rate\nfrom Signups s\nleft join Confirmations c on c.user_id = s.user_id\ngroup by s.user_id;`"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Try c.action=\"confirmed\" inside if"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "select sp.user_id, round(coalesce(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)/(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)+sum(case when ct.action=\\'timeout\\' then 1 else 0 end)),0),2) as confirmation_rate from signups sp\\n    left join confirmations ct on sp.user_id=ct.user_id\\n    group by sp.user_id"
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "I see that input is wrong as I run the query for confirmations\\n"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select Signups.user_id,ROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2)  as confirmation_rate from Signups left join Confirmations on Signups.user_id = Confirmations.user_id group by Signups.user_id;\\nit\\'s working properly."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Why can\\'t we use ifnull instead of coalesce?\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "SELECT USER_ID,\\nROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2) AS confirmation_rate\\nFROM(\\nSELECT \\n      S.USER_ID,\\n      C.ACTION\\nFROM SIGNUPS S LEFT JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\n)tmp\\nGROUP BY USER_ID"
                    }
                ]
            },
            {
                "id": 1860583,
                "content": [
                    {
                        "username": "Schnedarb",
                        "content": "The question states \"Return the result table in any order\" which is NOT TRUE. \\n\\nThis output is \"wrong\" \\n| user_id | confirmation_rate |\\n| ------- | ----------------- |\\n| 3       | 0                 |\\n| 6       | 0                 |\\n| 7       | 1                 |\\n| 2       | 0.5               |"
                    },
                    {
                        "username": "r_roy",
                        "content": "SELECT\\n    a.user_id,\\n    IFNULL(\\n        ROUND (IFNULL(\\n            NULLIF(SUM(CASE WHEN c.action = \\'confirmed\\' THEN 1 ELSE 0 END)/COUNT(*), 0),\\n            0\\n        ) ,2),\\n        0\\n    ) AS confirmation_rate\\nFROM signups a\\nLEFT JOIN confirmations c ON a.user_id = c.user_id\\nGROUP BY a.user_id;\\n\\n\\nI have a doubt here, wont this cause Division by 0 error?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Create script for this question does not work in MS Sql Server. What is the alternative to Enum in T-SQL? "
                    },
                    {
                        "username": "katyayanialisha",
                        "content": "select Signups.user_id , round(sum(IF(confirmations.action=\"confirmed\",1,0))/count(confirmations.action),2) as  confirmations_rate  from Signups join Confirmations\\non \\nSignups.user_id=Confirmations.user_id group by Confirmations.user_id\\n\\n\\nWHAT AM I DOING WRONG HERE?"
                    },
                    {
                        "username": "jaijaria032001",
                        "content": "did the same thing.\\n"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select\\nUser_id,\\nifnull(\\nround(\\nsum(case when action=\"confirmed\" then 1 else 0 end)/count(action),2),0) as confirmation_rate \\n from \\n(SELECT s.user_id,c.action FROM Signups s \\nleft join\\nConfirmations c on \\ns.user_id=c.user_id)a\\ngroup by user_id"
                    },
                    {
                        "username": "Tuchdov",
                        "content": "**anyone know what that means?**\nexecute command denied to user 'student'@'%' for routine 'c.action'\n\nthis was my code (spoilers ahead)\n-\n-\n- `select s.user_id, round(avg(if(c.action(\"confirmed\"),1,0)),2) as confirmation_rate\nfrom Signups s\nleft join Confirmations c on c.user_id = s.user_id\ngroup by s.user_id;`"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Try c.action=\"confirmed\" inside if"
                    },
                    {
                        "username": "Dsowmya",
                        "content": "select sp.user_id, round(coalesce(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)/(sum(case when ct.action=\\'confirmed\\' then 1 else 0 end)+sum(case when ct.action=\\'timeout\\' then 1 else 0 end)),0),2) as confirmation_rate from signups sp\\n    left join confirmations ct on sp.user_id=ct.user_id\\n    group by sp.user_id"
                    },
                    {
                        "username": "divyakakarla93",
                        "content": "I see that input is wrong as I run the query for confirmations\\n"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select Signups.user_id,ROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2)  as confirmation_rate from Signups left join Confirmations on Signups.user_id = Confirmations.user_id group by Signups.user_id;\\nit\\'s working properly."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Why can\\'t we use ifnull instead of coalesce?\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "SELECT USER_ID,\\nROUND(COALESCE(SUM(CASE WHEN ACTION = \\'confirmed\\' then 1 END)/COUNT(*),0),2) AS confirmation_rate\\nFROM(\\nSELECT \\n      S.USER_ID,\\n      C.ACTION\\nFROM SIGNUPS S LEFT JOIN CONFIRMATIONS C\\nON S.USER_ID = C.USER_ID\\n)tmp\\nGROUP BY USER_ID"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Number of Words You Can Type",
        "question_content": "<p>There is a malfunctioning keyboard where some letter keys do not work. All other keys on the keyboard work properly.</p>\n\n<p>Given a string <code>text</code> of words separated by a single space (no leading or trailing spaces) and a string <code>brokenLetters</code> of all <strong>distinct</strong> letter keys that are broken, return <em>the <strong>number of words</strong> in</em> <code>text</code> <em>you can fully type using this keyboard</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> text = &quot;hello world&quot;, brokenLetters = &quot;ad&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> We cannot type &quot;world&quot; because the &#39;d&#39; key is broken.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> text = &quot;leet code&quot;, brokenLetters = &quot;lt&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> We cannot type &quot;leet&quot; because the &#39;l&#39; and &#39;t&#39; keys are broken.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> text = &quot;leet code&quot;, brokenLetters = &quot;e&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> We cannot type either word because the &#39;e&#39; key is broken.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= brokenLetters.length &lt;= 26</code></li>\n\t<li><code>text</code> consists of words separated by a single space without any leading or trailing spaces.</li>\n\t<li>Each word only consists of lowercase English letters.</li>\n\t<li><code>brokenLetters</code> consists of <strong>distinct</strong> lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1344926,
                "title": "hash-set-or-array",
                "content": "#### Array\\nUsing a boolean array instead of hash set. See the original hash set solution below.\\n\\n**C++**\\n```cpp\\nint canBeTypedWords(string text, string brokenLetters) {\\n    bool broken[26] = {};\\n    for (auto ch : brokenLetters)\\n        broken[ch - \\'a\\'] = true;\\n    int res = 0, cnt = 0;\\n    for (auto ch : text)\\n        if (ch == \\' \\') {\\n            res += cnt == 0;\\n            cnt = 0;\\n        }\\n        else\\n            cnt += broken[ch - \\'a\\'];\\n    return res + (cnt == 0);\\n}\\n```\\n\\n#### Hash Set\\n**C++**\\n```cpp\\nint canBeTypedWords(string text, string brokenLetters) {\\n    unordered_set<int> broken(begin(brokenLetters), end(brokenLetters));\\n    int res = 0;\\n    for (int i = 0, cnt = 0; i <= text.size(); ++i)\\n        if (i == text.size() || text[i] == \\' \\') {\\n            res += cnt == 0;\\n            cnt = 0;\\n        }\\n        else if(cnt == 0)\\n            cnt += broken.count(text[i]);\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint canBeTypedWords(string text, string brokenLetters) {\\n    bool broken[26] = {};\\n    for (auto ch : brokenLetters)\\n        broken[ch - \\'a\\'] = true;\\n    int res = 0, cnt = 0;\\n    for (auto ch : text)\\n        if (ch == \\' \\') {\\n            res += cnt == 0;\\n            cnt = 0;\\n        }\\n        else\\n            cnt += broken[ch - \\'a\\'];\\n    return res + (cnt == 0);\\n}\\n```\n```cpp\\nint canBeTypedWords(string text, string brokenLetters) {\\n    unordered_set<int> broken(begin(brokenLetters), end(brokenLetters));\\n    int res = 0;\\n    for (int i = 0, cnt = 0; i <= text.size(); ++i)\\n        if (i == text.size() || text[i] == \\' \\') {\\n            res += cnt == 0;\\n            cnt = 0;\\n        }\\n        else if(cnt == 0)\\n            cnt += broken.count(text[i]);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1345078,
                "title": "c-self-expalanatory-o-n-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        vector<int> ch(26,0);\\n\\t\\t// store the broken letters in ch vector\\n        for(char c: brokenLetters){\\n            ch[c-\\'a\\']=1;\\n        }\\n        int cnt=0,ans=0;\\n\\t\\t//traversing the text string\\n        for(int i=0;i<text.length();i++){\\n\\t\\t    //if char is \\' \\' means that we got a new word\\n            if(text[i]==\\' \\'){\\n\\t\\t\\t    // cnt remain 0 means that there is no broken letter in this word\\n                if(cnt==0) ans++;\\n                cnt=0; //reinitialize cnt to 0 as new word start from here\\n            }else if(ch[text[i]-\\'a\\']==1){ //if char is present in ch then just increment the cnt\\n                    cnt++;\\n            }\\n        }\\n\\t\\t//for last word in string\\n        if(cnt==0) ans++;\\n        return ans;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        vector<int> ch(26,0);\\n\\t\\t// store the broken letters in ch vector\\n        for(char c: brokenLetters){\\n            ch[c-\\'a\\']=1;\\n        }\\n        int cnt=0,ans=0;\\n\\t\\t//traversing the text string\\n        for(int i=0;i<text.length();i++){\\n\\t\\t    //if char is \\' \\' means that we got a new word\\n            if(text[i]==\\' \\'){\\n\\t\\t\\t    // cnt remain 0 means that there is no broken letter in this word\\n                if(cnt==0) ans++;\\n                cnt=0; //reinitialize cnt to 0 as new word start from here\\n            }else if(ch[text[i]-\\'a\\']==1){ //if char is present in ch then just increment the cnt\\n                    cnt++;\\n            }\\n        }\\n\\t\\t//for last word in string\\n        if(cnt==0) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345025,
                "title": "bit-mask-o-n",
                "content": "**Approach:**\\n`mask` of a string means it will create a mask which will tell what are the characters persent in it.\\n```\\nLet\\'s say mask = xxxxx  ( binary representation, where x will be either 0 or 1 )\\n\\t\\t\\t\\t \\u2191\\u2191\\u2191\\u2191\\u2191\\n\\t\\t\\t\\t edbca\\nSo if any character will be persent, it\\'s corresponding bit will become 1 in mask.\\n\\nSay word is \"accd\" , here \\'a\\', \\'c\\', \\'d\\' characters persent so its mask will be\\n00...01101\\n\\u2191\\u2191...\\u2191\\u2191\\u2191\\u2191\\u2191\\n--...edcba\\n```\\n\\n* Create a mask of broken word\\n* Create mask of `curr` current word\\n* Whenever we encounter a space ` ` means current word is completed\\n* 1.  So compare mask of broken word and current word\\n* 2. If any word in broken word and current word is common then we can not type that word\\n* 3. So increase the count of word which can be typed only when there is no common character ``` i.e ( curr & broken) == 0```\\n* 4. Finally don\\'t forget to reset your current mask\\n\\n\\n**C++ Code**\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int mask(string s)\\n    {\\n        int ans = 0;\\n        for(int i=0;i<s.size();i++)\\n            ans = ans | (1<<(int(s[i] - \\'a\\')));\\n        return ans;\\n    }\\n    int canBeTypedWords(string text, string brokenL) {\\n        int broken = mask(brokenL);\\n        int ans = 0, curr = 0;\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(text[i] == \\' \\')\\n            {\\n                if((curr & broken) == 0) ans++;\\n                curr = 0;\\n            }\\n            else\\n                curr = curr | ( 1 <<(text[i]-\\'a\\'));\\n        }\\n        if((curr & broken) == 0) ans++;\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python Code**\\nThanks to @495 for python solution\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        def bitset(word):\\n            masks = [1 << (ord(x)-ord(\\'a\\')) for x in word]\\n            return functools.reduce(lambda a,b: a|b, masks, 0)\\n        \\n        brokenSet = bitset(brokenLetters)\\n        return sum(1 for word in text.split() if bitset(word) & brokenSet == 0)\\n```",
                "solutionTags": [],
                "code": "```\\nLet\\'s say mask = xxxxx  ( binary representation, where x will be either 0 or 1 )\\n\\t\\t\\t\\t \\u2191\\u2191\\u2191\\u2191\\u2191\\n\\t\\t\\t\\t edbca\\nSo if any character will be persent, it\\'s corresponding bit will become 1 in mask.\\n\\nSay word is \"accd\" , here \\'a\\', \\'c\\', \\'d\\' characters persent so its mask will be\\n00...01101\\n\\u2191\\u2191...\\u2191\\u2191\\u2191\\u2191\\u2191\\n--...edcba\\n```\n``` i.e ( curr & broken) == 0```\n```cpp\\nclass Solution {\\npublic:\\n    int mask(string s)\\n    {\\n        int ans = 0;\\n        for(int i=0;i<s.size();i++)\\n            ans = ans | (1<<(int(s[i] - \\'a\\')));\\n        return ans;\\n    }\\n    int canBeTypedWords(string text, string brokenL) {\\n        int broken = mask(brokenL);\\n        int ans = 0, curr = 0;\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(text[i] == \\' \\')\\n            {\\n                if((curr & broken) == 0) ans++;\\n                curr = 0;\\n            }\\n            else\\n                curr = curr | ( 1 <<(text[i]-\\'a\\'));\\n        }\\n        if((curr & broken) == 0) ans++;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        def bitset(word):\\n            masks = [1 << (ord(x)-ord(\\'a\\')) for x in word]\\n            return functools.reduce(lambda a,b: a|b, masks, 0)\\n        \\n        brokenSet = bitset(brokenLetters)\\n        return sum(1 for word in text.split() if bitset(word) & brokenSet == 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344940,
                "title": "java-python-3-easy-code-w-brief-analysis",
                "content": "**Method 1: HashSet**\\n\\n```java\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        Set<Character> no = new HashSet<>();\\n        for (char c : brokenLetters.toCharArray()) {\\n            no.add(c);\\n        }\\n        int cnt = 0;\\n        outer:\\n        for (String word : text.split(\"\\\\\\\\s\")) {\\n            for (char c : word.toCharArray()) {\\n                if (no.contains(c)) {\\n                    continue outer;\\n                }\\n            }\\n            ++cnt;\\n        }\\n        return cnt;\\n    }\\n```\\n```python\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        no, cnt = set(brokenLetters), 0\\n        for word in text.split():\\n            if all(c not in no for c in word):\\n                cnt += 1\\n        return cnt\\n```\\n\\n----\\n\\n\\nCredit to **@midingoyi** for the following code:\\n\\n```python\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        \\n        def fun(s: Set) -> int:\\n            return 0 if set(brokenLetters).intersection(s) else 1\\n        \\n        word_sets = map(set, text.split())\\n        return sum((map(fun, word_sets))) \\n```\\n\\n---\\n\\n**Method 2: Bit Manipulation**\\n\\n```java\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int cnt = 0, mask = 0;\\n        for (int i = 0; i < brokenLetters.length(); ++i) {\\n            mask |= 1 << brokenLetters.charAt(i) - \\'a\\';\\n        }\\n        final int broken = mask;\\n        for (String word : text.split(\"\\\\\\\\s\")) {\\n            if (word.chars().allMatch(c -> (broken & (1 << c - \\'a\\')) == 0)) {\\n                ++cnt;\\n            }\\n        }\\n        return cnt;\\n    }\\n```\\n\\n```python\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        mask = functools.reduce(lambda x, y: x | 1 << ord(y) - ord(\\'a\\'), brokenLetters, 0)\\n        return sum(1 for word in text.split() if all(((1 << ord(c) - ord(\\'a\\')) & mask) == 0 for c in word))\\n```\\n\\n----\\n\\n**Analysis:**\\n\\nTime: `O(m * n)`, space: `O(brokenLetters)` (or `O(1)` if regard `brokenLetters` as constant), where `m` is the average size of the words, `n` is the # of words in the `text` and `brokenLetters` is the size of the brokenLetters.\\n\\n",
                "solutionTags": [],
                "code": "```java\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        Set<Character> no = new HashSet<>();\\n        for (char c : brokenLetters.toCharArray()) {\\n            no.add(c);\\n        }\\n        int cnt = 0;\\n        outer:\\n        for (String word : text.split(\"\\\\\\\\s\")) {\\n            for (char c : word.toCharArray()) {\\n                if (no.contains(c)) {\\n                    continue outer;\\n                }\\n            }\\n            ++cnt;\\n        }\\n        return cnt;\\n    }\\n```\n```python\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        no, cnt = set(brokenLetters), 0\\n        for word in text.split():\\n            if all(c not in no for c in word):\\n                cnt += 1\\n        return cnt\\n```\n```python\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        \\n        def fun(s: Set) -> int:\\n            return 0 if set(brokenLetters).intersection(s) else 1\\n        \\n        word_sets = map(set, text.split())\\n        return sum((map(fun, word_sets))) \\n```\n```java\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int cnt = 0, mask = 0;\\n        for (int i = 0; i < brokenLetters.length(); ++i) {\\n            mask |= 1 << brokenLetters.charAt(i) - \\'a\\';\\n        }\\n        final int broken = mask;\\n        for (String word : text.split(\"\\\\\\\\s\")) {\\n            if (word.chars().allMatch(c -> (broken & (1 << c - \\'a\\')) == 0)) {\\n                ++cnt;\\n            }\\n        }\\n        return cnt;\\n    }\\n```\n```python\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        mask = functools.reduce(lambda x, y: x | 1 << ord(y) - ord(\\'a\\'), brokenLetters, 0)\\n        return sum(1 for word in text.split() if all(((1 << ord(c) - ord(\\'a\\')) & mask) == 0 for c in word))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1355349,
                "title": "easy-fast-python-solutions-2-approaches-28ms-32ms-faster-than-93",
                "content": "# Easy, Fast Python Solutions (2 Approaches - 28ms, 32ms; Faster than 93%)\\n## Approach 1 - Using Sets\\n**Runtime: 28 ms, faster than 93% of Python3 online submissions for Maximum Number of Words You Can Type.**\\n**Memory Usage: 14.4 MB**\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        text = text.split()\\n        length = len(text)\\n        brokenLetters = set(brokenLetters)\\n\\n        for word in text:\\n            for char in word:\\n                if char in brokenLetters:\\n                    length -= 1\\n                    break\\n\\t\\t\\t\\t\\t\\n        return length\\n```\\n\\n\\n## Approach 2 - Using Lists\\n**Runtime: 32 ms, faster than 82% of Python3 online submissions for Maximum Number of Words You Can Type.**\\n**Memory Usage: 14.4 MB**\\n\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        text = text.split()\\n        length = len(text)\\n        brokenLetters = list(brokenLetters)\\n\\t\\t\\n        for i in text:\\n            temp = 0\\n            for j in i:\\n                if j in brokenLetters:\\n                    temp -= 1\\n                    break\\n            if temp < 0:\\n                length -= 1\\n\\t\\t\\t\\t\\n        return length\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        text = text.split()\\n        length = len(text)\\n        brokenLetters = set(brokenLetters)\\n\\n        for word in text:\\n            for char in word:\\n                if char in brokenLetters:\\n                    length -= 1\\n                    break\\n\\t\\t\\t\\t\\t\\n        return length\\n```\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        text = text.split()\\n        length = len(text)\\n        brokenLetters = list(brokenLetters)\\n\\t\\t\\n        for i in text:\\n            temp = 0\\n            for j in i:\\n                if j in brokenLetters:\\n                    temp -= 1\\n                    break\\n            if temp < 0:\\n                length -= 1\\n\\t\\t\\t\\t\\n        return length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344961,
                "title": "simple-c-code-no-hash-no-stringstream-explained-with-intuition",
                "content": "**Intuition:**\\nThe word which is just ended, if that contains any letter of \\'brokenLetter\\' string, we do not increment the result in that case, and if it does not contain any letter of \\'brokenLetter\\' string, we increment the result.\\n```\\nint canBeTypedWords(string text, string bl) \\n{\\n\\tbool isBadWord = 0; //Initially, we assume the word can be typed, so it is not a bad word.\\n\\tint res =0; //this will store result i.e. no of words that can be typed.\\n\\tfor (int i=0; i<text.length(); i++)  //we traverse the whole text string\\n\\t{\\n\\t    //and if we find any character of brokenLetter in current word, it becomes a bad word, \\n        //so res is not updated in this case.\\n\\t\\tfor (int j=0; j<bl.length(); j++) \\n\\t\\t\\tif (text[i]==bl[j])  isBadWord = 1;\\n\\t\\t\\t\\n\\t\\t//However if we hit space or hit the end of the string\\n\\t\\tif (text[i]==\\' \\' || i==text.length()-1)\\n\\t\\t{\\n\\t\\t\\tif (isBadWord==0) res++;  //if the word just ended is not bad word, increase the result by one\\n\\t\\t\\telse isBadWord=0;  //else reset isBadWord = 0 for the next word.\\n\\t\\t}\\n\\t}\\n\\treturn res;     //return the result.\\n}\\n```\\nIf we use STL string find function:\\n```\\nint canBeTypedWords(string text, string bl) \\n{\\n\\tbool isBadWord = 0; //Initially, we assume the word can be typed, so it is not a bad word.\\n\\tint res =0; //this will store result i.e. no of words that can be typed.\\n\\tfor (int i=0; i<text.length(); i++)  //we traverse the whole text string\\n\\t{\\n\\t    //and if we find any character of brokenLetter in current word, it becomes a bad word, \\n        //so res is not updated in this case.\\n\\t\\tif(bl.find(text[i]) != string::npos) isBadWord = 1; \\n        \\n\\t\\t//However if we hit space or hit the end of the string\\n\\t\\tif (text[i]==\\' \\' || i==text.length()-1)\\n\\t\\t{\\n\\t\\t\\tif (isBadWord==0) res++;  //if the word just ended is not bad word, increase the result by one\\n\\t\\t\\telse isBadWord=0;  //else reset isBadWord = 0 for the next word.\\n\\t\\t}\\n\\t}\\n\\treturn res;     //return the result.\\n}\\n```\\n**Please Upvote if found Helpful, so that other coders can get benefit too!**",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nint canBeTypedWords(string text, string bl) \\n{\\n\\tbool isBadWord = 0; //Initially, we assume the word can be typed, so it is not a bad word.\\n\\tint res =0; //this will store result i.e. no of words that can be typed.\\n\\tfor (int i=0; i<text.length(); i++)  //we traverse the whole text string\\n\\t{\\n\\t    //and if we find any character of brokenLetter in current word, it becomes a bad word, \\n        //so res is not updated in this case.\\n\\t\\tfor (int j=0; j<bl.length(); j++) \\n\\t\\t\\tif (text[i]==bl[j])  isBadWord = 1;\\n\\t\\t\\t\\n\\t\\t//However if we hit space or hit the end of the string\\n\\t\\tif (text[i]==\\' \\' || i==text.length()-1)\\n\\t\\t{\\n\\t\\t\\tif (isBadWord==0) res++;  //if the word just ended is not bad word, increase the result by one\\n\\t\\t\\telse isBadWord=0;  //else reset isBadWord = 0 for the next word.\\n\\t\\t}\\n\\t}\\n\\treturn res;     //return the result.\\n}\\n```\n```\\nint canBeTypedWords(string text, string bl) \\n{\\n\\tbool isBadWord = 0; //Initially, we assume the word can be typed, so it is not a bad word.\\n\\tint res =0; //this will store result i.e. no of words that can be typed.\\n\\tfor (int i=0; i<text.length(); i++)  //we traverse the whole text string\\n\\t{\\n\\t    //and if we find any character of brokenLetter in current word, it becomes a bad word, \\n        //so res is not updated in this case.\\n\\t\\tif(bl.find(text[i]) != string::npos) isBadWord = 1; \\n        \\n\\t\\t//However if we hit space or hit the end of the string\\n\\t\\tif (text[i]==\\' \\' || i==text.length()-1)\\n\\t\\t{\\n\\t\\t\\tif (isBadWord==0) res++;  //if the word just ended is not bad word, increase the result by one\\n\\t\\t\\telse isBadWord=0;  //else reset isBadWord = 0 for the next word.\\n\\t\\t}\\n\\t}\\n\\treturn res;     //return the result.\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1345084,
                "title": "java-1-line",
                "content": "```java\\npublic int canBeTypedWords(String text, String broken) {\\n   return (int) Arrays.stream(text.split(\" \")).filter(s -> s.chars().allMatch(c -> broken.indexOf(c) == -1)).count();\\n}",
                "solutionTags": [],
                "code": "```java\\npublic int canBeTypedWords(String text, String broken) {\\n   return (int) Arrays.stream(text.split(\" \")).filter(s -> s.chars().allMatch(c -> broken.indexOf(c) == -1)).count();\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1345057,
                "title": "c-stringstream-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        vector<int> ch(26,0);\\n        //store the broken letters\\n        for(char c: brokenLetters){\\n            ch[c-\\'a\\']=1;\\n        }\\n        // breaking text into word using string stream\\n        stringstream s(text); // Used for breaking words\\n        string word; // to store individual words\\n  \\n        int count = 0,flag=0;\\n        while (s >> word){\\n            flag=0;\\n            for(char &c: word){\\n                //if the word contains a broken letter mark flag=1\\n                if(ch[c-\\'a\\']==1){\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            //if flag is 0 which means that there is no broken letter in word so increase the count\\n            if(flag==0)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        vector<int> ch(26,0);\\n        //store the broken letters\\n        for(char c: brokenLetters){\\n            ch[c-\\'a\\']=1;\\n        }\\n        // breaking text into word using string stream\\n        stringstream s(text); // Used for breaking words\\n        string word; // to store individual words\\n  \\n        int count = 0,flag=0;\\n        while (s >> word){\\n            flag=0;\\n            for(char &c: word){\\n                //if the word contains a broken letter mark flag=1\\n                if(ch[c-\\'a\\']==1){\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            //if flag is 0 which means that there is no broken letter in word so increase the count\\n            if(flag==0)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1353222,
                "title": "python-3-easy-1-line-using-set",
                "content": "1-line version. Count it if there is no common characters between the word and the broken letters:\\n```\\ndef canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return sum(not set(word) & set(brokenLetters) for word in text.split())\\n```\\n\\nLonger version. Equivalent to above, but may be easier to understand:\\n```\\ndef canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        res = 0\\n        for word in text.split():\\n            if not set(word) & set(brokenLetters):\\n                res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return sum(not set(word) & set(brokenLetters) for word in text.split())\\n```\n```\\ndef canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        res = 0\\n        for word in text.split():\\n            if not set(word) & set(brokenLetters):\\n                res += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1347370,
                "title": "c-set-commented",
                "content": "```\\n\\n    int canBeTypedWords(string text, string broken) {\\n        \\n        int n = text.length(), m = broken.length();\\n        int i = 0, j = 0;\\n        int res = 0;\\n        \\n        unordered_set<char> s;\\n        //putting broken into set for easy access\\n        for(char c : broken) s.insert(c);\\n        \\n        //looping through text\\n        while(i<n){\\n        int cnt = 0;\\n        //looping through words\\n        while(i<n && text[i]!=\\' \\'){\\n            char c = text[i];\\n            //if any character in the word is broken \\n            if(s.find(c)!=s.end())\\n                cnt++;\\n            i++;\\n        }\\n        //if no broken char found in word\\n        if(cnt==0) res++;\\n            \\n        i++;\\n        }\\n        \\n        return res;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    int canBeTypedWords(string text, string broken) {\\n        \\n        int n = text.length(), m = broken.length();\\n        int i = 0, j = 0;\\n        int res = 0;\\n        \\n        unordered_set<char> s;\\n        //putting broken into set for easy access\\n        for(char c : broken) s.insert(c);\\n        \\n        //looping through text\\n        while(i<n){\\n        int cnt = 0;\\n        //looping through words\\n        while(i<n && text[i]!=\\' \\'){\\n            char c = text[i];\\n            //if any character in the word is broken \\n            if(s.find(c)!=s.end())\\n                cnt++;\\n            i++;\\n        }\\n        //if no broken char found in word\\n        if(cnt==0) res++;\\n            \\n        i++;\\n        }\\n        \\n        return res;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1346183,
                "title": "c-o-n-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        \\n        vector<int> vec(26,0);\\n        for(int i=0;i<brokenLetters.size();i++)\\n        {\\n            vec[brokenLetters[i]-\\'a\\']=1;\\n        }\\n        int count = 0;\\n        bool flag = true;\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(text[i]==\\' \\')\\n            {\\n                if(flag==true)              // if flag=true, i.e. the word before space is not broken, so count++; \\n                    count++;\\n                \\n                flag = true;\\n            }\\n            else\\n            {\\n                if(vec[text[i]-\\'a\\']!=0)\\n                {\\n                    flag = false;           //if char found, flag = false, word cannot be counted\\n                }\\n            }\\n            \\n        }\\n        if(flag==true)           // for the last word\\n            count++;\\n        return count;\\n    }\\n};\\n```\\n\\nTime Complexity - O(N)\\nSpace Complexity - O(1) // constant array of size 26\\n\\n\\nPlz upvote if you like it.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        \\n        vector<int> vec(26,0);\\n        for(int i=0;i<brokenLetters.size();i++)\\n        {\\n            vec[brokenLetters[i]-\\'a\\']=1;\\n        }\\n        int count = 0;\\n        bool flag = true;\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(text[i]==\\' \\')\\n            {\\n                if(flag==true)              // if flag=true, i.e. the word before space is not broken, so count++; \\n                    count++;\\n                \\n                flag = true;\\n            }\\n            else\\n            {\\n                if(vec[text[i]-\\'a\\']!=0)\\n                {\\n                    flag = false;           //if char found, flag = false, word cannot be counted\\n                }\\n            }\\n            \\n        }\\n        if(flag==true)           // for the last word\\n            count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344880,
                "title": "easy-c-o-n-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string broken) {\\n        \\n        //store the current broken letters  in an array \\n        vector<int> freq(26,0);\\n        for(int i=0;i<broken.length();i++)\\n            freq[broken[i]-\\'a\\']++;\\n        \\n        //stores if the current word in text is broken or not\\n        bool isBroken=false;\\n        //the words which we can type\\n        int count=0;\\n        for(int i=0;i<text.length();i++)\\n        {\\n            if(text[i]==\\' \\')\\n            {\\n                //the previous can be typed\\n                if(!isBroken)\\n                    count++;\\n                isBroken=false;\\n                \\n            }\\n            else{\\n                //if the word contains a broken letter mark isBroken=true\\n                if(freq[text[i]-\\'a\\']!=0)\\n                    isBroken=true;\\n            }\\n        }\\n        //for the last word in text\\n        if(!isBroken)\\n            count++;\\n        return count;\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string broken) {\\n        \\n        //store the current broken letters  in an array \\n        vector<int> freq(26,0);\\n        for(int i=0;i<broken.length();i++)\\n            freq[broken[i]-\\'a\\']++;\\n        \\n        //stores if the current word in text is broken or not\\n        bool isBroken=false;\\n        //the words which we can type\\n        int count=0;\\n        for(int i=0;i<text.length();i++)\\n        {\\n            if(text[i]==\\' \\')\\n            {\\n                //the previous can be typed\\n                if(!isBroken)\\n                    count++;\\n                isBroken=false;\\n                \\n            }\\n            else{\\n                //if the word contains a broken letter mark isBroken=true\\n                if(freq[text[i]-\\'a\\']!=0)\\n                    isBroken=true;\\n            }\\n        }\\n        //for the last word in text\\n        if(!isBroken)\\n            count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349839,
                "title": "easy-java-1ms-100-comments",
                "content": "```\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n\\t    //split text into separate words without spaces\\n        String[] words = text.split(\" \");    \\n        int[] buf = new int[\\'z\\'-\\'a\\'+1];\\n        int res=words.length;\\n        \\n\\t\\t//store all broken characters\\n        for(char ch : brokenLetters.toCharArray())\\n            buf[ch-\\'a\\']=1;\\n        \\n\\t\\t//check word-by-word\\n        for(String word : words)\\n            for(char ch : word.toCharArray()) // check character by character\\n                if(buf[ch-\\'a\\']!=0){ //if we face character from broken list, then  reduce RES and stop checking this word\\n                    res--;\\n                    break;\\n                }   \\n\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n\\t    //split text into separate words without spaces\\n        String[] words = text.split(\" \");    \\n        int[] buf = new int[\\'z\\'-\\'a\\'+1];\\n        int res=words.length;\\n        \\n\\t\\t//store all broken characters\\n        for(char ch : brokenLetters.toCharArray())\\n            buf[ch-\\'a\\']=1;\\n        \\n\\t\\t//check word-by-word\\n        for(String word : words)\\n            for(char ch : word.toCharArray()) // check character by character\\n                if(buf[ch-\\'a\\']!=0){ //if we face character from broken list, then  reduce RES and stop checking this word\\n                    res--;\\n                    break;\\n                }   \\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1345133,
                "title": "c-solution-using-stringstream-and-set",
                "content": "Step by step procedure:\\n1. Atfirst, we store all the characters of the **broken** string in the set.\\n2. Using stringstream, we can access each word from **text** string.\\n3. We will increment the **cnt** variable for each word in the string text and check whether each character in **word** string is present in set,if it is present then decrement the **cnt**(which indicates that word includes atleast 1 broken character).\\n4. Finally return the **cnt** variable which indicates number of words in the string **text** that can be fullytped.\\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string broken){\\n        set<char>s;\\n        int cnt=0;\\n        for(int i=0;i<broken.length();i++)\\n\\t\\t{\\n            s.insert(broken[i]);\\n        }\\n        stringstream ss(text);\\n        string word;\\n        while(ss >> word)\\n\\t\\t{\\n            cnt++;\\n           for(int i=0;i<word.length();i++)\\n\\t\\t   {\\n              if(s.find(word[i])!=s.end())\\n\\t\\t\\t  {\\n                  cnt--;\\n                  break;\\n              }\\n           }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\nDo upvote,if you find it helpful !!!!",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string broken){\\n        set<char>s;\\n        int cnt=0;\\n        for(int i=0;i<broken.length();i++)\\n\\t\\t{\\n            s.insert(broken[i]);\\n        }\\n        stringstream ss(text);\\n        string word;\\n        while(ss >> word)\\n\\t\\t{\\n            cnt++;\\n           for(int i=0;i<word.length();i++)\\n\\t\\t   {\\n              if(s.find(word[i])!=s.end())\\n\\t\\t\\t  {\\n                  cnt--;\\n                  break;\\n              }\\n           }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777876,
                "title": "python-3-simple-set-intersection-2-lines-beats-89",
                "content": "```python3 []\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        broken = set(brokenLetters)\\n        return sum(not set(w) & broken for w in text.split())\\n```\\n```python3 []\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        res, broken = 0, set(brokenLetters)\\n        for w in text.split():\\n            if not set(w) & broken:\\n                res += 1\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        broken = set(brokenLetters)\\n        return sum(not set(w) & broken for w in text.split())\\n```\n```python3 []\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        res, broken = 0, set(brokenLetters)\\n        for w in text.split():\\n            if not set(w) & broken:\\n                res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580360,
                "title": "java-string-straightforward-solution",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String arr[] = text.split(\" \");\\n        int count=0;\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=0;j<brokenLetters.length();j++){\\n                if(arr[i].contains(Character.toString(brokenLetters.charAt(j)))){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return arr.length-count;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String arr[] = text.split(\" \");\\n        int count=0;\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=0;j<brokenLetters.length();j++){\\n                if(arr[i].contains(Character.toString(brokenLetters.charAt(j)))){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return arr.length-count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1771234,
                "title": "easy-cpp-code-beginner-friendly-no-complex-coding",
                "content": "```\"leet code\", brokenLetters = \"lt\"``` //EXAMPLE WE ARE TAKING\\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        vector<string> temp;\\n        istringstream ss(text);\\n        string word;\\n        while( ss >> word ) temp.push_back(word);\\n        bool freq[26] = {false};\\n        for( auto c : brokenLetters ) freq[c-\\'a\\'] = true;\\n        int totalword = temp.size();\\n        for( int i = 0 ; i < temp.size() ; i++ )\\n        {\\n            for( auto c : temp[i] )\\n                if( freq[c-\\'a\\'] )\\n                {\\n                    totalword--;\\n                    break;\\n                }\\n        }\\n        return totalword;\\n    }\\n};\\n```\\n**STEP 1** - FROM STRING \"TEXT\" FILTER OUT WORDS OUT OF WHOLE SENTENCES ( **SPLIT FUNCTION C++**) AND STORING THEM IN VECTOR\\n```\\nvector<string> temp;\\n        istringstream ss(text);\\n        string word;\\n\\t\\twhile( ss >> word ) temp.push_back(word);\\n```\\nOUTPUT OF THESE 4 LINES WOULD LIKE BE VECTOR [ \"leet\", \"code\"]\\n**STEP 2** MAINTAIN AN ARRAY FOR THE BROKEN LETTER OF KEYBOARD\\n```\\n        bool freq[26] = {false};\\n        for( auto c : brokenLetters ) freq[c-\\'a\\'] = true;\\n```\\nAN ARRAY IS BEING ALLOTTED WITH SIZE OF 26 (REPRESENTING ALL 26 ENGLISH ALPHABETS) INITIALLY FALSE BUT AFTER STEP 2 , **TRUE** IS PLACED WHERE THE RESPECTIVE BROKEN APLHABETS PRESENT.\\n\\n**STEP 3** FINALLY THE LAST STEP , HERE WE ARE JUST ITERATIVE OVER TEMP VECTOR( OBTAINED FROM STEP 1) THAT WHICH WORD CONTAINS THE FORBIDDEN APLHABETS, USING **IF** LOOP FOR CHECKING EACH LETTER WITH THE FREQ ARRAY AND IS FOUND THEN BREAK INNER LOOP THERE ITSELF AND DECREASE THE COUNT OF TOTALWORDS AND CONTINUING WITH THE REST OF THE WORDS\\n```\\n        int totalword = temp.size();\\n        for( int i = 0 ; i < temp.size() ; i++ )\\n        {\\n            for( auto c : temp[i] )\\n                if( freq[c-\\'a\\'] )\\n                {\\n                    totalword--;\\n                    break;\\n                }\\n        }\\n        return totalword;\\n```\\nThank you if you have stayed this far. I tried my best to keep it simple and if someone want to discuss please let me know. Keep working hard . Do solve more programming question everyday.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\"leet code\", brokenLetters = \"lt\"```\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        vector<string> temp;\\n        istringstream ss(text);\\n        string word;\\n        while( ss >> word ) temp.push_back(word);\\n        bool freq[26] = {false};\\n        for( auto c : brokenLetters ) freq[c-\\'a\\'] = true;\\n        int totalword = temp.size();\\n        for( int i = 0 ; i < temp.size() ; i++ )\\n        {\\n            for( auto c : temp[i] )\\n                if( freq[c-\\'a\\'] )\\n                {\\n                    totalword--;\\n                    break;\\n                }\\n        }\\n        return totalword;\\n    }\\n};\\n```\n```\\nvector<string> temp;\\n        istringstream ss(text);\\n        string word;\\n\\t\\twhile( ss >> word ) temp.push_back(word);\\n```\n```\\n        bool freq[26] = {false};\\n        for( auto c : brokenLetters ) freq[c-\\'a\\'] = true;\\n```\n```\\n        int totalword = temp.size();\\n        for( int i = 0 ; i < temp.size() ; i++ )\\n        {\\n            for( auto c : temp[i] )\\n                if( freq[c-\\'a\\'] )\\n                {\\n                    totalword--;\\n                    break;\\n                }\\n        }\\n        return totalword;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414751,
                "title": "simple-string-tokenizer-java-sol",
                "content": "```\\nimport java.io.*;\\nimport java.util.*;\\nclass Solution \\n{\\n    public int canBeTypedWords(String text, String broken) \\n    {\\n        StringTokenizer st = new StringTokenizer(text);\\n        int cnt=0;\\n        while(st.hasMoreTokens())\\n        {\\n            String wd=st.nextToken();\\n            cnt+=check(wd,broken);\\n        }\\n        return cnt;\\n    }\\n    public int check(String wd, String broken)\\n    {\\n        for(int i=0;i<broken.length();i++)\\n        {\\n            for(int j=0;j<wd.length();j++)\\n            {\\n                if(wd.charAt(j)==broken.charAt(i))\\n                    return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.io.*;\\nimport java.util.*;\\nclass Solution \\n{\\n    public int canBeTypedWords(String text, String broken) \\n    {\\n        StringTokenizer st = new StringTokenizer(text);\\n        int cnt=0;\\n        while(st.hasMoreTokens())\\n        {\\n            String wd=st.nextToken();\\n            cnt+=check(wd,broken);\\n        }\\n        return cnt;\\n    }\\n    public int check(String wd, String broken)\\n    {\\n        for(int i=0;i<broken.length();i++)\\n        {\\n            for(int j=0;j<wd.length();j++)\\n            {\\n                if(wd.charAt(j)==broken.charAt(i))\\n                    return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407834,
                "title": "c-c-simple-and-easy-solution-0ms-faster-than-100",
                "content": "**C++:**\\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        vector<char> broken(26, 0);\\n        for (auto c : brokenLetters) broken[c - \\'a\\']++;\\n        \\n        \\n        int res = 0, count = 0;\\n        for (int i = 0; i < text.size(); i++) {\\n            if (text[i] == \\' \\') {\\n                if (count == 0) res++; // end of word and no broken letters\\n                count = 0;\\n                continue;\\n            }\\n            \\n            if (broken[text[i] - \\'a\\']) count++;\\n        }\\n        \\n        if (!count) res++; // For last word\\n        \\n        return res;\\n    }\\n};\\n```\\n**C:**\\n```\\nint canBeTypedWords(char * text, char * brokenLetters) {\\n    int broken[26] = {0};\\n    char* ptr = brokenLetters;\\n    while (*ptr) broken[*ptr++ - \\'a\\']++;\\n\\n    ptr = text;\\n    int res = 0, count = 0;\\n    while (*ptr) {\\n        if (*ptr == \\' \\') {\\n            if (count == 0) res++; // end of word and no broken letters\\n            count = 0;\\n            ptr++;\\n            continue;\\n        }\\n        \\n        if (broken[*ptr - \\'a\\']) count++;\\n        ptr++;\\n    }\\n\\n    if (!count) res++; // For last word\\n\\n    return res;\\n}\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        vector<char> broken(26, 0);\\n        for (auto c : brokenLetters) broken[c - \\'a\\']++;\\n        \\n        \\n        int res = 0, count = 0;\\n        for (int i = 0; i < text.size(); i++) {\\n            if (text[i] == \\' \\') {\\n                if (count == 0) res++; // end of word and no broken letters\\n                count = 0;\\n                continue;\\n            }\\n            \\n            if (broken[text[i] - \\'a\\']) count++;\\n        }\\n        \\n        if (!count) res++; // For last word\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nint canBeTypedWords(char * text, char * brokenLetters) {\\n    int broken[26] = {0};\\n    char* ptr = brokenLetters;\\n    while (*ptr) broken[*ptr++ - \\'a\\']++;\\n\\n    ptr = text;\\n    int res = 0, count = 0;\\n    while (*ptr) {\\n        if (*ptr == \\' \\') {\\n            if (count == 0) res++; // end of word and no broken letters\\n            count = 0;\\n            ptr++;\\n            continue;\\n        }\\n        \\n        if (broken[*ptr - \\'a\\']) count++;\\n        ptr++;\\n    }\\n\\n    if (!count) res++; // For last word\\n\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346740,
                "title": "python-straightforward-solution",
                "content": "```\\nclass Solution(object):\\n    def canBeTypedWords(self, text, brokenLetters):\\n        \"\"\"\\n        :type text: str\\n        :type brokenLetters: str\\n        :rtype: int\\n        \"\"\"\\n        text = text.split(\" \")\\n        if not brokenLetters:\\n            return len(text)\\n        \\n        brokenLetters = set(brokenLetters)\\n        ans = 0\\n        for word in text:\\n            new_set = set(word)\\n            if not new_set.intersection(brokenLetters):\\n                ans += 1     \\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def canBeTypedWords(self, text, brokenLetters):\\n        \"\"\"\\n        :type text: str\\n        :type brokenLetters: str\\n        :rtype: int\\n        \"\"\"\\n        text = text.split(\" \")\\n        if not brokenLetters:\\n            return len(text)\\n        \\n        brokenLetters = set(brokenLetters)\\n        ans = 0\\n        for word in text:\\n            new_set = set(word)\\n            if not new_set.intersection(brokenLetters):\\n                ans += 1     \\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369997,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity: O(n*m)\\n  n: length of the text\\n  m: length of brokenLetters\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool check_letters(char c, string s)\\n    {\\n        for (int i = 0; i < s.size(); i++)\\n            if (s[i] == c)\\n                return true;\\n        return false;\\n    }\\n\\n    int canBeTypedWords(string text, string brokenLetters) {\\n    string word;\\n    vector<string> words;\\n    for (int i = 0; i < text.size(); i++)\\n    {\\n        if (text[i] != \\' \\')\\n            word.push_back(text[i]);\\n        if (text[i] == \\' \\' || i == text.size() - 1)\\n        {\\n            words.push_back(word);\\n            word = \"\";\\n        }\\n    }\\n    int count = 0;\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        bool letter_present = false;\\n        for (int j = 0; j < brokenLetters.size(); j++)\\n            if (check_letters(brokenLetters[j], words[i]))\\n            {\\n                letter_present = true;\\n                break;\\n            }\\n        if (!letter_present)\\n            count++;\\n    }\\n    return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool check_letters(char c, string s)\\n    {\\n        for (int i = 0; i < s.size(); i++)\\n            if (s[i] == c)\\n                return true;\\n        return false;\\n    }\\n\\n    int canBeTypedWords(string text, string brokenLetters) {\\n    string word;\\n    vector<string> words;\\n    for (int i = 0; i < text.size(); i++)\\n    {\\n        if (text[i] != \\' \\')\\n            word.push_back(text[i]);\\n        if (text[i] == \\' \\' || i == text.size() - 1)\\n        {\\n            words.push_back(word);\\n            word = \"\";\\n        }\\n    }\\n    int count = 0;\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        bool letter_present = false;\\n        for (int j = 0; j < brokenLetters.size(); j++)\\n            if (check_letters(brokenLetters[j], words[i]))\\n            {\\n                letter_present = true;\\n                break;\\n            }\\n        if (!letter_present)\\n            count++;\\n    }\\n    return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165112,
                "title": "1-ms-java-solution-100-faster",
                "content": "# Code\\n```\\nclass Solution {\\n    int ans = 0;\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        Set<Character> set = new HashSet();\\n        for (char c : brokenLetters.toCharArray()) set.add(c);\\n\\n        String [] arr = text.split(\" \");\\n\\n        for (int i = 0; i < arr.length; i++) traverse(arr[i], set);\\n        return ans;\\n    }\\n\\n    public void traverse(String s, Set<Character> set) {\\n        for (int i = 0; i < s.length(); i++) \\n            if (set.contains(s.charAt(i))) return;\\n        ans++;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        Set<Character> set = new HashSet();\\n        for (char c : brokenLetters.toCharArray()) set.add(c);\\n\\n        String [] arr = text.split(\" \");\\n\\n        for (int i = 0; i < arr.length; i++) traverse(arr[i], set);\\n        return ans;\\n    }\\n\\n    public void traverse(String s, Set<Character> set) {\\n        for (int i = 0; i < s.length(); i++) \\n            if (set.contains(s.charAt(i))) return;\\n        ans++;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102510,
                "title": "c-solution-using-hashset-char-and-two-foreach-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing HashSet was the first idea to detect any letters in the brokenLetters since all the letters are unique and there is no need to keep track of the frequency of any of them.  \\n\\nAs for the option of iterating through all letters in text, I chose to use the string.Split() for simpler code of checking each word in the text and each letter of the word - thus using two ForEach loops.\\n\\nThe count of all words that can be typed without any of the broken letters, I chose to use a boolean flag to determine whether to count or not.\\n\\nThe final count value is the answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI initialized the HashSet, simply passing the brokenLetters string as the argument of instantiation syntax of the set.\\n\\nI then split the text into an array of strings, each element representing a word.\\n\\nUsing two foreach loops (not using for loop since  index of the letters is not needed), iterate through the array using the outer forloop and iterate through all letters of a given word the inner forloop.  If any one of the broken letters is found, the boolean flag is used to exclude the particular word from being counted.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CanBeTypedWords(string text, string brokenLetters) {\\n\\n        var set = new HashSet<char>(brokenLetters);\\n        bool isBroken = false;\\n        int count = 0;\\n\\n        string[] arr = text.Split(\" \");\\n        \\n        foreach (var s in arr)\\n        {\\n            isBroken = false;\\n            foreach (var c in s)\\n            {\\n                if (set.Contains(c)) isBroken = true;\\n            }\\n            if (!isBroken) count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CanBeTypedWords(string text, string brokenLetters) {\\n\\n        var set = new HashSet<char>(brokenLetters);\\n        bool isBroken = false;\\n        int count = 0;\\n\\n        string[] arr = text.Split(\" \");\\n        \\n        foreach (var s in arr)\\n        {\\n            isBroken = false;\\n            foreach (var c in s)\\n            {\\n                if (set.Contains(c)) isBroken = true;\\n            }\\n            if (!isBroken) count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832369,
                "title": "python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, b: str) -> int:\\n        output = 0\\n        text = text.split()\\n        brokenLetters = list(b)\\n        for elem in text:\\n            if any(v in brokenLetters for v in elem):\\n                continue\\n            else:\\n                output += 1\\n        return output\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, b: str) -> int:\\n        output = 0\\n        text = text.split()\\n        brokenLetters = list(b)\\n        for elem in text:\\n            if any(v in brokenLetters for v in elem):\\n                continue\\n            else:\\n                output += 1\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554624,
                "title": "4-ms-ez-java-solution",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String bl) {\\n        String[] list = text.split(\" \");\\n        String[] chars = bl.split(\"\");\\n        int ans = 0;\\n        for(String ls: list) {\\n            for(int j = 0; j != bl.length(); ++j) {\\n                if (ls.contains(chars[j])) {\\n                    ans--;\\n                    break;\\n                }\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String bl) {\\n        String[] list = text.split(\" \");\\n        String[] chars = bl.split(\"\");\\n        int ans = 0;\\n        for(String ls: list) {\\n            for(int j = 0; j != bl.length(); ++j) {\\n                if (ls.contains(chars[j])) {\\n                    ans--;\\n                    break;\\n                }\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227006,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 1;\\n        boolean isBad = false;\\n        for (char c : text.toCharArray()) {\\n            if (c == \\' \\') {\\n                isBad = false;\\n                count++;\\n            } else {\\n                if (!isBad && brokenLetters.indexOf(c) != -1) {\\n                    isBad = true;\\n                    count--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 1;\\n        boolean isBad = false;\\n        for (char c : text.toCharArray()) {\\n            if (c == \\' \\') {\\n                isBad = false;\\n                count++;\\n            } else {\\n                if (!isBad && brokenLetters.indexOf(c) != -1) {\\n                    isBad = true;\\n                    count--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195713,
                "title": "c-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int arr[26]={0};\\n        \\n        for(int i=0;i<brokenLetters.length();i++)\\n        {\\n            arr[brokenLetters[i]-\\'a\\']++;\\n        }\\n        \\n        int count=0,n=text.length();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(text[i]==\\' \\' || ( i==n-1 && arr[text[i]-\\'a\\']==0))\\n                  count++;\\n            else if(arr[text[i]-\\'a\\'] !=0)\\n                {\\n                    while(text[i]!=\\' \\' &&  i!=n-1)\\n                        i++;\\n                }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int arr[26]={0};\\n        \\n        for(int i=0;i<brokenLetters.length();i++)\\n        {\\n            arr[brokenLetters[i]-\\'a\\']++;\\n        }\\n        \\n        int count=0,n=text.length();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(text[i]==\\' \\' || ( i==n-1 && arr[text[i]-\\'a\\']==0))\\n                  count++;\\n            else if(arr[text[i]-\\'a\\'] !=0)\\n                {\\n                    while(text[i]!=\\' \\' &&  i!=n-1)\\n                        i++;\\n                }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2184099,
                "title": "javascript-easy",
                "content": "```\\nvar canBeTypedWords = function(text, brokenLetters) {\\n    \\n    let count = 0;\\n    let arrs = text.split(\\' \\');\\n    let hash = {};\\n    \\n    for(let i=0; i<brokenLetters.length; i++) {\\n        hash[brokenLetters[i]] = true;\\n    }\\n    \\n    for(let i=0; i<arrs.length; i++) {\\n        let word = arrs[i];\\n        let flag = true;\\n        for(let j=0; j<word.length; j++) {\\n            let letter = word[j];\\n            if(hash[letter]){\\n                flag = false;\\n                break;\\n            }\\n        }\\n        if(flag == true) {\\n            count++;\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canBeTypedWords = function(text, brokenLetters) {\\n    \\n    let count = 0;\\n    let arrs = text.split(\\' \\');\\n    let hash = {};\\n    \\n    for(let i=0; i<brokenLetters.length; i++) {\\n        hash[brokenLetters[i]] = true;\\n    }\\n    \\n    for(let i=0; i<arrs.length; i++) {\\n        let word = arrs[i];\\n        let flag = true;\\n        for(let j=0; j<word.length; j++) {\\n            let letter = word[j];\\n            if(hash[letter]){\\n                flag = false;\\n                break;\\n            }\\n        }\\n        if(flag == true) {\\n            count++;\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1860723,
                "title": "python-45-ms-solution-good-for-beginners",
                "content": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        words = text.split()\\n        count = 0\\n        flag = 0\\n        for i in words:\\n            for j in brokenLetters:\\n                if j in i:\\n                    flag = 1\\n                    break\\n            if flag == 0:\\n                count += 1\\n            flag = 0\\n        return count",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        words = text.split()\\n        count = 0\\n        flag = 0\\n        for i in words:\\n            for j in brokenLetters:\\n                if j in i:\\n                    flag = 1\\n                    break\\n            if flag == 0:\\n                count += 1\\n            flag = 0\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 1562882,
                "title": "javascript-easy-3-line-solution-w-explanation",
                "content": "```\\nvar canBeTypedWords = function(text, brokenLetters) {\\n    const lettersArr = brokenLetters.split(\\'\\') \\n    const checker = word => !lettersArr.some(letter => word.includes(letter)); \\n    return text.split(\\' \\').filter(checker).length\\n};\\n```\\n\\n1. ``    const lettersArr = brokenLetters.split(\\'\\') `` split string of broken letters into an array of letters\\n2. ``const checker = word => !lettersArr.some(letter => word.includes(letter)); `` function to check if a word includes letters from the lettersArr\\n3. `` return text.split(\\' \\').filter(checker).length;`` split string into array of words, filter it using the checker function, and return the length",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canBeTypedWords = function(text, brokenLetters) {\\n    const lettersArr = brokenLetters.split(\\'\\') \\n    const checker = word => !lettersArr.some(letter => word.includes(letter)); \\n    return text.split(\\' \\').filter(checker).length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1347140,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int c=0,k=1;\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_map<char,bool>map;\\n        for(auto i:brokenLetters)\\n            map[i]=true;\\n        \\n        for(int i=0;i<text.length();i++)\\n            if(text[i]==\\' \\')\\n                k++;\\n        \\n        stringstream iss(text);\\n        string word;\\n        \\n        while(iss >> word) {\\n            for(int i=0;i<word.size();i++){\\n               if(map[word[i]]==true){\\n                    k--;\\n                     break;   \\n               }\\n            } \\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int c=0,k=1;\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_map<char,bool>map;\\n        for(auto i:brokenLetters)\\n            map[i]=true;\\n        \\n        for(int i=0;i<text.length();i++)\\n            if(text[i]==\\' \\')\\n                k++;\\n        \\n        stringstream iss(text);\\n        string word;\\n        \\n        while(iss >> word) {\\n            for(int i=0;i<word.size();i++){\\n               if(map[word[i]]==true){\\n                    k--;\\n                     break;   \\n               }\\n            } \\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345012,
                "title": "java-hashset",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        Set<Character> brokenLettersSet=new HashSet<>();\\n        for (char brokenLetter: brokenLetters.toCharArray()){\\n            brokenLettersSet.add(brokenLetter);\\n        }\\n        boolean curCan=true;\\n        int res=0;\\n        for (char ch:text.toCharArray()){\\n            if (ch==\\' \\'){\\n                if (curCan){\\n                    res++;\\n                } else {\\n                    curCan=true;\\n                }\\n            }\\n            if (brokenLettersSet.contains(ch)){\\n                curCan=false;\\n            }\\n        }\\n        if (curCan){\\n            res++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        Set<Character> brokenLettersSet=new HashSet<>();\\n        for (char brokenLetter: brokenLetters.toCharArray()){\\n            brokenLettersSet.add(brokenLetter);\\n        }\\n        boolean curCan=true;\\n        int res=0;\\n        for (char ch:text.toCharArray()){\\n            if (ch==\\' \\'){\\n                if (curCan){\\n                    res++;\\n                } else {\\n                    curCan=true;\\n                }\\n            }\\n            if (brokenLettersSet.contains(ch)){\\n                curCan=false;\\n            }\\n        }\\n        if (curCan){\\n            res++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344924,
                "title": "c-break-the-text-into-words-and-check-for-each-word",
                "content": "- Break the text string with spaces and store in an vector / array\\n- For each word in the array traverse through each character and check if in the brokenLetters\\n\\n```\\nclass Solution {\\npublic:\\n  vector<string> breakWithSpaces(string str) {\\n    vector<string> words;\\n    string word = \"\";\\n    for(auto x : str) {\\n        if(x == \\' \\') {\\n            words.push_back(word);\\n            word = \"\";\\n        }\\n        else {\\n            word = word + x;\\n        }\\n    }\\n    words.push_back(word);\\n    return words;\\n  }\\n  \\n  int canBeTypedWords(string text, string brokenLetters) {\\n    vector<string> words;\\n    int wordCount = 0;\\n    words = breakWithSpaces(text);\\n    \\n    for(int i = 0; i < words.size(); i++) {\\n      bool cantPrint = false;\\n      \\n      for(char textLetter : words[i]) {\\n        for(char brokenLetter : brokenLetters){\\n          if(brokenLetter == textLetter) {\\n            cantPrint = true;\\n            break;\\n          }\\n        }\\n      }\\n      \\n      if(!cantPrint)\\n          wordCount++;\\n    }\\n    return wordCount;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<string> breakWithSpaces(string str) {\\n    vector<string> words;\\n    string word = \"\";\\n    for(auto x : str) {\\n        if(x == \\' \\') {\\n            words.push_back(word);\\n            word = \"\";\\n        }\\n        else {\\n            word = word + x;\\n        }\\n    }\\n    words.push_back(word);\\n    return words;\\n  }\\n  \\n  int canBeTypedWords(string text, string brokenLetters) {\\n    vector<string> words;\\n    int wordCount = 0;\\n    words = breakWithSpaces(text);\\n    \\n    for(int i = 0; i < words.size(); i++) {\\n      bool cantPrint = false;\\n      \\n      for(char textLetter : words[i]) {\\n        for(char brokenLetter : brokenLetters){\\n          if(brokenLetter == textLetter) {\\n            cantPrint = true;\\n            break;\\n          }\\n        }\\n      }\\n      \\n      if(!cantPrint)\\n          wordCount++;\\n    }\\n    return wordCount;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344918,
                "title": "c-easy-to-understand",
                "content": "In this we will find the strings before spaces (for the last string we have to take care).\\nfor every string just check if the characters of brokenLetters are present or not.\\nif not present then increment the count.\\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        string a=\"\";\\n        int count=0;\\n//         check for every string before space\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(text[i]==\\' \\')\\n              {\\n               \\n                int flag=1;\\n//                 checking for every string if the character of brokenLetters are present or not.\\n                 for(int j=0;j<brokenLetters.size();j++)\\n                 {\\n                     for(int k=0;k<a.size();k++)\\n                     {\\n                         if(brokenLetters[j]==a[k])\\n                            { flag=0;\\n                              break;\\n                            }\\n                     }\\n                     if(flag==0)\\n                     break;\\n                 }\\n                cout<<flag<<endl;\\n                if(flag==1)\\n                    count++;\\n                 a=\"\";\\n              }\\n            else a=a+text[i];\\n        }\\n//         this is for the last string \\n//        as there is not space at last/\\n                 int flag=1;\\n                 for(int j=0;j<brokenLetters.size();j++)\\n                 {\\n                     for(int k=0;k<a.size();k++)\\n                     {\\n                         if(brokenLetters[j]==a[k])\\n                            { flag=0;\\n                              break;\\n                            }\\n                     }\\n                     if(flag==0)\\n                     break;\\n                 }\\n                cout<<flag<<endl;\\n                if(flag==1)\\n                    count++;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        string a=\"\";\\n        int count=0;\\n//         check for every string before space\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(text[i]==\\' \\')\\n              {\\n               \\n                int flag=1;\\n//                 checking for every string if the character of brokenLetters are present or not.\\n                 for(int j=0;j<brokenLetters.size();j++)\\n                 {\\n                     for(int k=0;k<a.size();k++)\\n                     {\\n                         if(brokenLetters[j]==a[k])\\n                            { flag=0;\\n                              break;\\n                            }\\n                     }\\n                     if(flag==0)\\n                     break;\\n                 }\\n                cout<<flag<<endl;\\n                if(flag==1)\\n                    count++;\\n                 a=\"\";\\n              }\\n            else a=a+text[i];\\n        }\\n//         this is for the last string \\n//        as there is not space at last/\\n                 int flag=1;\\n                 for(int j=0;j<brokenLetters.size();j++)\\n                 {\\n                     for(int k=0;k<a.size();k++)\\n                     {\\n                         if(brokenLetters[j]==a[k])\\n                            { flag=0;\\n                              break;\\n                            }\\n                     }\\n                     if(flag==0)\\n                     break;\\n                 }\\n                cout<<flag<<endl;\\n                if(flag==1)\\n                    count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3177076,
                "title": "o-n-solution-with-set-explanation-python-faster-than-others",
                "content": "\\n```\\ncounter = 0\\nfor i in text.split():\\n    #{\\'a\\',\\'b\\'}.intersection(\\'a\\') is equal to {\\'a\\'} \\n    #according to this if this expression returned empty set then we\\'ll increment\\n    if set(brokenLetters).intersection(set(i)) == set():\\n        counter+=1\\nreturn counter\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ncounter = 0\\nfor i in text.split():\\n    #{\\'a\\',\\'b\\'}.intersection(\\'a\\') is equal to {\\'a\\'} \\n    #according to this if this expression returned empty set then we\\'ll increment\\n    if set(brokenLetters).intersection(set(i)) == set():\\n        counter+=1\\nreturn counter\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2971347,
                "title": "p3-1-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return sum(1 for word in text.split() if len(set(word) & set(brokenLetters)) == 0 )\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return sum(1 for word in text.split() if len(set(word) & set(brokenLetters)) == 0 )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711818,
                "title": "c-100-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int brokenLettersIdx [26] = {};\\n        int canTypeWords = 0;\\n        for (char c : brokenLetters) {\\n            brokenLettersIdx[c-\\'a\\'] = 1;\\n        }\\n\\t\\t\\n        for (int i = 0; i < text.length(); i++) {\\n            int brk = 0;\\n            while (i < text.length() && text[i] != \\' \\') {\\n                if (brokenLettersIdx[text[i]-\\'a\\'] == 1) {\\n                    brk++;\\n                }\\n                i++;\\n            }\\n            if (brk == 0) {\\n                canTypeWords++;\\n            }\\n        }\\n        return canTypeWords;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int brokenLettersIdx [26] = {};\\n        int canTypeWords = 0;\\n        for (char c : brokenLetters) {\\n            brokenLettersIdx[c-\\'a\\'] = 1;\\n        }\\n\\t\\t\\n        for (int i = 0; i < text.length(); i++) {\\n            int brk = 0;\\n            while (i < text.length() && text[i] != \\' \\') {\\n                if (brokenLettersIdx[text[i]-\\'a\\'] == 1) {\\n                    brk++;\\n                }\\n                i++;\\n            }\\n            if (brk == 0) {\\n                canTypeWords++;\\n            }\\n        }\\n        return canTypeWords;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2553716,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Hashset***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(Constant)***\\n\\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string str, string bad) {\\n        \\n        int n = str.size();\\n        \\n        // insert the not working characters into set\\n        \\n        unordered_set<char> s;\\n        \\n        for(auto x : bad)\\n        {\\n            s.insert(x);\\n        }\\n        \\n        int count = 0;\\n        \\n        int i = 0;\\n        \\n        while(i < n)\\n        {\\n            bool flag = true;\\n            \\n            while(i < n && str[i] != \\' \\')\\n            {\\n                // if any of the character in word is not working mark flag to false\\n                \\n                if(s.count(str[i]))\\n                {\\n                    flag = false;\\n                }\\n                \\n                i++;\\n            }\\n            \\n            // if all the characters in the word are working\\n            \\n            if(flag)\\n            {\\n                count++;\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string str, string bad) {\\n        \\n        int n = str.size();\\n        \\n        // insert the not working characters into set\\n        \\n        unordered_set<char> s;\\n        \\n        for(auto x : bad)\\n        {\\n            s.insert(x);\\n        }\\n        \\n        int count = 0;\\n        \\n        int i = 0;\\n        \\n        while(i < n)\\n        {\\n            bool flag = true;\\n            \\n            while(i < n && str[i] != \\' \\')\\n            {\\n                // if any of the character in word is not working mark flag to false\\n                \\n                if(s.count(str[i]))\\n                {\\n                    flag = false;\\n                }\\n                \\n                i++;\\n            }\\n            \\n            // if all the characters in the word are working\\n            \\n            if(flag)\\n            {\\n                count++;\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501634,
                "title": "python-faster-than-95-86-less-memory-than-95-74",
                "content": "This is a simple solution in Python 3, which invokes a list comprehension. Details in docstring:\\n\\n```python\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        \"\"\"\\n        This function looks at the number of words which can be typed, when\\n        considering the broken letters. The function firstly assigns output as \\n        0, followed by splitting the text into words, and the brokenLetters into a \\n        List. For each element in the text, if any brokenLetter element exists\\n        within the element, no value is increased on output, otherwise output is\\n        incremented by 1.\\n        \\n        :param text: the text to be evaluated. (str)\\n        :param brokenLetters: the letters which are broken. (str)\\n        :returns output: the number of words which can be formed. (int)\\n        \"\"\"\\n        output = 0\\n        text = text.split()\\n        brokenLetters = list(brokenLetters)\\n        for elem in text:\\n            if any(v in brokenLetters for v in elem):\\n                continue\\n            else:\\n                output += 1\\n        return output",
                "solutionTags": [],
                "code": "This is a simple solution in Python 3, which invokes a list comprehension. Details in docstring:\\n\\n```python\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        \"\"\"\\n        This function looks at the number of words which can be typed, when\\n        considering the broken letters. The function firstly assigns output as \\n        0, followed by splitting the text into words, and the brokenLetters into a \\n        List. For each element in the text, if any brokenLetter element exists\\n        within the element, no value is increased on output, otherwise output is\\n        incremented by 1.\\n        \\n        :param text: the text to be evaluated. (str)\\n        :param brokenLetters: the letters which are broken. (str)\\n        :returns output: the number of words which can be formed. (int)\\n        \"\"\"\\n        output = 0\\n        text = text.split()\\n        brokenLetters = list(brokenLetters)\\n        for elem in text:\\n            if any(v in brokenLetters for v in elem):\\n                continue\\n            else:\\n                output += 1\\n        return output",
                "codeTag": "Java"
            },
            {
                "id": 2279972,
                "title": "python-set",
                "content": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        brokenLetters = set(brokenLetters)\\n        res = 0\\n        for word in text.split():\\n            if set(word) - brokenLetters == set(word):\\n                res += 1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        brokenLetters = set(brokenLetters)\\n        res = 0\\n        for word in text.split():\\n            if set(word) - brokenLetters == set(word):\\n                res += 1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2236748,
                "title": "using-set-properties",
                "content": "\\tclass Solution:\\n\\t\\tdef canBeTypedWords(self, text: str, bL: str) -> int:\\n\\t\\t\\treturn sum(1 for w in text.split() if not set(w)&set(bL))",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef canBeTypedWords(self, text: str, bL: str) -> int:\\n\\t\\t\\treturn sum(1 for w in text.split() if not set(w)&set(bL))",
                "codeTag": "Java"
            },
            {
                "id": 1793557,
                "title": "java-2-methods-explained",
                "content": "**Idea:**\\n* Convert `brokenLetters` to a set of chars\\n* Split text into words and if any word contains a broken letter then that can\\'t be typed\\n\\n**Method 1:** Using split\\n> **T/S:** O(m + n)/O(m + n), where m = size(text), n = size(brokenLetters)\\n```\\npublic int canBeTypedWords(String text, String brokenLetters) {\\n\\tvar broken = setOf(brokenLetters);\\n\\tvar words = text.split(\" \");\\n\\tvar count = words.length;\\n\\t\\n\\tfor (var word : words)\\n\\t\\tfor (var i = 0; i < word.length(); i++)\\n\\t\\t\\tif (broken.contains(word.charAt(i))) {\\n\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\treturn count;\\n}\\n\\nprivate Set<Character> setOf(String brokenLetters) {\\n\\tvar broken = new HashSet<Character>();\\n\\tfor (var i = 0; i < brokenLetters.length(); i++)\\n\\t\\tbroken.add(brokenLetters.charAt(i));\\n\\treturn broken;\\n}\\n```\\n\\n**Method 2:** Without using `split`\\n> **T/S:** O(m + n)/O(n)\\n```\\npublic int canBeTypedWords(String text, String brokenLetters) {\\n\\tvar broken = setOf(brokenLetters);\\n\\tvar count = 0;\\n\\n\\tfor (var i = 0; i < text.length(); i++) {\\n\\t\\tvar hasBrokenLetter = false;\\n\\t\\t\\n\\t\\twhile (i < text.length() && !Character.isSpaceChar(text.charAt(i)))\\n\\t\\t\\tif (broken.contains(text.charAt(i++)) && !hasBrokenLetter)\\n\\t\\t\\t\\thasBrokenLetter = true;\\n\\t\\t\\n\\t\\tif (!hasBrokenLetter)\\n\\t\\t\\tcount++;\\n\\t}\\n\\treturn count;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int canBeTypedWords(String text, String brokenLetters) {\\n\\tvar broken = setOf(brokenLetters);\\n\\tvar words = text.split(\" \");\\n\\tvar count = words.length;\\n\\t\\n\\tfor (var word : words)\\n\\t\\tfor (var i = 0; i < word.length(); i++)\\n\\t\\t\\tif (broken.contains(word.charAt(i))) {\\n\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\treturn count;\\n}\\n\\nprivate Set<Character> setOf(String brokenLetters) {\\n\\tvar broken = new HashSet<Character>();\\n\\tfor (var i = 0; i < brokenLetters.length(); i++)\\n\\t\\tbroken.add(brokenLetters.charAt(i));\\n\\treturn broken;\\n}\\n```\n```\\npublic int canBeTypedWords(String text, String brokenLetters) {\\n\\tvar broken = setOf(brokenLetters);\\n\\tvar count = 0;\\n\\n\\tfor (var i = 0; i < text.length(); i++) {\\n\\t\\tvar hasBrokenLetter = false;\\n\\t\\t\\n\\t\\twhile (i < text.length() && !Character.isSpaceChar(text.charAt(i)))\\n\\t\\t\\tif (broken.contains(text.charAt(i++)) && !hasBrokenLetter)\\n\\t\\t\\t\\thasBrokenLetter = true;\\n\\t\\t\\n\\t\\tif (!hasBrokenLetter)\\n\\t\\t\\tcount++;\\n\\t}\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1685655,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        s=[]\\n        text=text.split()\\n        for i in text:\\n            for j in i:\\n                if j in brokenLetters:\\n                    break\\n            else:\\n                s.append(i)\\n        return len(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        s=[]\\n        text=text.split()\\n        for i in text:\\n            for j in i:\\n                if j in brokenLetters:\\n                    break\\n            else:\\n                s.append(i)\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575386,
                "title": "c-faster-than-100-explanation",
                "content": "Concepts used\\n* In c++ all strings are terminatd by \\'\\\\0\\'\\n* If a broken letter is encountered next letters of word will not matter\\n```c++\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        std::vector<int> bl(27);\\n        for(auto &&i : brokenLetters){\\n            if(i == \\' \\') continue;\\n            bl[(i-\\'a\\')]++;\\n        }\\n\\t\\t\\n        int w = 0;\\n\\t\\t// note \\'<=\\'\\n        for(int i=0; i<=text.length();i++){\\n            if(text[i] == \\' \\' || text[i] == \\'\\\\0\\'){\\n                w++;\\n                continue;\\n            }\\n\\n            if(bl[text[i]-\\'a\\']!=0){    //broken letter\\n                while(i < text.length()){\\n                    if(text[i]==\\' \\') {break;}\\n                    i++;\\n                }\\n            }\\n        }\\n        return w;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        std::vector<int> bl(27);\\n        for(auto &&i : brokenLetters){\\n            if(i == \\' \\') continue;\\n            bl[(i-\\'a\\')]++;\\n        }\\n\\t\\t\\n        int w = 0;\\n\\t\\t// note \\'<=\\'\\n        for(int i=0; i<=text.length();i++){\\n            if(text[i] == \\' \\' || text[i] == \\'\\\\0\\'){\\n                w++;\\n                continue;\\n            }\\n\\n            if(bl[text[i]-\\'a\\']!=0){    //broken letter\\n                while(i < text.length()){\\n                    if(text[i]==\\' \\') {break;}\\n                    i++;\\n                }\\n            }\\n        }\\n        return w;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507535,
                "title": "2-line-solutions-in-python",
                "content": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        text = text.split()\\n        return len(text) - sum(any(c in w for c in brokenLetters) for w in text)\\n```\\nnot quite different with `set`:\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        bls = set(brokenLetters)\\n        return sum(not set(w) & bls for w in text.split())\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        text = text.split()\\n        return len(text) - sum(any(c in w for c in brokenLetters) for w in text)\\n```\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        bls = set(brokenLetters)\\n        return sum(not set(w) & bls for w in text.split())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1484560,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\tvar canBeTypedWords = function(text, brokenLetters) {\\n\\t\\tconst textSplit = text.split(\\' \\');\\n\\t\\tconst brokenLetterSplit =  brokenLetters.split(\\'\\');\\n\\n\\t\\treturn textSplit.filter(word => {\\n\\t\\t\\treturn brokenLetterSplit.every(broken => !word.includes(broken));\\n\\t\\t}).length;\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar canBeTypedWords = function(text, brokenLetters) {\\n\\t\\tconst textSplit = text.split(\\' \\');\\n\\t\\tconst brokenLetterSplit =  brokenLetters.split(\\'\\');\\n\\n\\t\\treturn textSplit.filter(word => {\\n\\t\\t\\treturn brokenLetterSplit.every(broken => !word.includes(broken));\\n\\t\\t}).length;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 1400472,
                "title": "c-o-n-commented-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int ans=0, n=text.size();\\n        bool flag=true;\\n        unordered_map<char,int> m;\\n        //count frequency of  brokenLetters\\n        for(auto i:brokenLetters) m[i]++;\\n        \\n        for(int i=0;i<n;i++){\\n            if(m[text[i]]>0)  //if char found in map, flag = false, word cannot be counted\\n                flag=false;\\n            else if(text[i]==\\' \\')\\n            {\\n                if(flag)    // if flag=true, i.e. the word before space is not broken, so ans++; \\n                    ans++;\\n                flag=true;\\n            }\\n            \\n        }\\n        \\n        if(flag)   // for the last word\\n            ans++;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\nTime Complexity - O(N)\\n\\nPlz upvote if you like it.\\nHappy Coding!\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int ans=0, n=text.size();\\n        bool flag=true;\\n        unordered_map<char,int> m;\\n        //count frequency of  brokenLetters\\n        for(auto i:brokenLetters) m[i]++;\\n        \\n        for(int i=0;i<n;i++){\\n            if(m[text[i]]>0)  //if char found in map, flag = false, word cannot be counted\\n                flag=false;\\n            else if(text[i]==\\' \\')\\n            {\\n                if(flag)    // if flag=true, i.e. the word before space is not broken, so ans++; \\n                    ans++;\\n                flag=true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1370603,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int canBeTypedWords(String t, String b) {\\n        t=t.trim();\\n        String a[]=new String[t.length()];\\n        int i,j=0,k=0;\\n        for(i=0;i<t.length();i++)\\n        {\\n            if(t.charAt(i)==\\' \\')\\n            {\\n                a[j++]=t.substring(k,i);\\n                k=i+1;\\n            }\\n        }\\n        a[j++]=t.substring(k);\\n        for(i=0;i<b.length();i++)\\n        {\\n            for(k=0;k<j;k++)\\n            {\\n                if(a[k].contains(String.valueOf(b.charAt(i))))\\n                {\\n                    a[k]=\"\";\\n                }\\n            }\\n        }\\n        k=0;\\n        for(i=0;i<j;i++)\\n        {\\n            if(a[i].length()==0)\\n                k++;\\n        }\\n        return j-k;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int canBeTypedWords(String t, String b) {\\n        t=t.trim();\\n        String a[]=new String[t.length()];\\n        int i,j=0,k=0;\\n        for(i=0;i<t.length();i++)\\n        {\\n            if(t.charAt(i)==\\' \\')\\n            {\\n                a[j++]=t.substring(k,i);\\n                k=i+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1358762,
                "title": "map-approach-simple-and-concise",
                "content": "So i basically saved the character which are defected in a map then traversed the initial string and if no defective is found then count++ and finally returned count\\n\\n```\\nint canBeTypedWords(string t, string s) \\n    {\\n        int count=0;\\n        unordered_map<char,int> m;\\n        for(int i=0;i<s.size();i++)\\n            m[s[i]]++;\\n        bool check=true;\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(t[i]==\\' \\')\\n            {\\n                if(check)\\n                    count++;\\n                check=true;\\n            }\\n            else if(m[t[i]]>0)\\n                check=false;\\n        }\\n        if(check)\\n            count++;\\n        return count;\\n    }\\n```\\nthe last count++ is done because there will not be any \\' \\' empty char in end to check if it is correct or not \\n\\n\\n\\nI hope you understood the aboce code and query can be asked in comment section i will be happy to answer that\\n\\nDo UPVOTE if you understood the code \\nHappy Leetcoding:)",
                "solutionTags": [],
                "code": "```\\nint canBeTypedWords(string t, string s) \\n    {\\n        int count=0;\\n        unordered_map<char,int> m;\\n        for(int i=0;i<s.size();i++)\\n            m[s[i]]++;\\n        bool check=true;\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(t[i]==\\' \\')\\n            {\\n                if(check)\\n                    count++;\\n                check=true;\\n            }\\n            else if(m[t[i]]>0)\\n                check=false;\\n        }\\n        if(check)\\n            count++;\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1357399,
                "title": "swift-variant-of-solution",
                "content": "*<- Please vote if my solution was helpful to you.*\\n```\\nclass Solution {\\n    func canBeTypedWords(_ text: String, _ brokenLetters: String) -> Int {\\n\\t\\tvar arr = text.split(separator: \" \")    \\n        for char in brokenLetters {\\n            arr = arr.filter {!$0.contains(char)}    \\n        }\\n        return arr.count\\t\\t\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func canBeTypedWords(_ text: String, _ brokenLetters: String) -> Int {\\n\\t\\tvar arr = text.split(separator: \" \")    \\n        for char in brokenLetters {\\n            arr = arr.filter {!$0.contains(char)}    \\n        }\\n        return arr.count\\t\\t\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1353581,
                "title": "c-one-line-linq",
                "content": "```\\npublic int CanBeTypedWords2(string text, string brokenLetters) \\n        => text.Split(\\' \\').Count(w => !w.Intersect(brokenLetters).Any());        \\n```",
                "solutionTags": [],
                "code": "```\\npublic int CanBeTypedWords2(string text, string brokenLetters) \\n        => text.Split(\\' \\').Count(w => !w.Intersect(brokenLetters).Any());        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1347787,
                "title": "rust-solution-with-array",
                "content": "```\\nimpl Solution {\\n    pub fn can_be_typed_words(text: String, broken_letters: String) -> i32 {\\n        let broken_hash = broken_letters\\n            .into_bytes()\\n            .iter()\\n            .fold([false; 26], |mut acc, &b| {\\n                acc[(b - b\\'a\\') as usize] = true;\\n                acc\\n            });\\n\\n        text.split_ascii_whitespace()\\n            .filter(|&s| {\\n                s.as_bytes()\\n                    .iter()\\n                    .all(|&b| !broken_hash[(b - b\\'a\\') as usize])\\n            })\\n            .count() as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn can_be_typed_words(text: String, broken_letters: String) -> i32 {\\n        let broken_hash = broken_letters\\n            .into_bytes()\\n            .iter()\\n            .fold([false; 26], |mut acc, &b| {\\n                acc[(b - b\\'a\\') as usize] = true;\\n                acc\\n            });\\n\\n        text.split_ascii_whitespace()\\n            .filter(|&s| {\\n                s.as_bytes()\\n                    .iter()\\n                    .all(|&b| !broken_hash[(b - b\\'a\\') as usize])\\n            })\\n            .count() as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1347135,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n      \\n    void jiyan(string s,vector<string>&v){\\n        string st;\\n                \\n        for(auto i:s){\\n            if(i==\\' \\'){\\n                v.push_back(st);\\n                st=\"\";\\n            }\\n            else\\n                st+=i;\\n        }\\n        v.push_back(st);\\n        \\n    }\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_map<char,bool>map;\\n        for(auto i:brokenLetters)\\n            map[i]=true;\\n        vector<string>v;\\n        jiyan(text,v);\\n        int k=v.size();\\n        for(auto i:v)\\n            for(auto j:i)\\n                if(map[j]){\\n                    k--;break;\\n                }\\n             \\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      \\n    void jiyan(string s,vector<string>&v){\\n        string st;\\n                \\n        for(auto i:s){\\n            if(i==\\' \\'){\\n                v.push_back(st);\\n                st=\"\";\\n            }\\n            else\\n                st+=i;\\n        }\\n        v.push_back(st);\\n        \\n    }\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_map<char,bool>map;\\n        for(auto i:brokenLetters)\\n            map[i]=true;\\n        vector<string>v;\\n        jiyan(text,v);\\n        int k=v.size();\\n        for(auto i:v)\\n            for(auto j:i)\\n                if(map[j]){\\n                    k--;break;\\n                }\\n             \\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345353,
                "title": "easy-and-simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String br) {\\n        String ar[]=text.split(\" \");\\n        int c=0,j=0;\\n        while(j<ar.length)\\n            {\\n        for(int i=0;i<br.length();i++)\\n        {\\n            char ch=br.charAt(i);\\n            \\n                if(ar[j].contains(ch+\"\"))\\n                {\\n                    c++;\\n\\n                    break;\\n                }\\n                    \\n            }\\n                 j++;\\n        }\\n        return ar.length-c;\\n        \\n    }\\n}\\n```\\n**Please upvote if you like it :)**\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String br) {\\n        String ar[]=text.split(\" \");\\n        int c=0,j=0;\\n        while(j<ar.length)\\n            {\\n        for(int i=0;i<br.length();i++)\\n        {\\n            char ch=br.charAt(i);\\n            \\n                if(ar[j].contains(ch+\"\"))\\n                {\\n                    c++;\\n\\n                    break;\\n                }\\n                    \\n            }\\n                 j++;\\n        }\\n        return ar.length-c;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344929,
                "title": "c-using-stringstream",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_set<char> st(begin(brokenLetters), end(brokenLetters));\\n        \\n        int count = 0;\\n        stringstream ss(text);\\n        \\n        string word;\\n        bool found = true;\\n        while(ss >> word) {\\n            found = true;\\n            for(char &ch : word) {\\n                if(st.find(ch) != end(st)) {\\n                    found = false;\\n                    break;\\n                }\\n            }\\n            if(found) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_set<char> st(begin(brokenLetters), end(brokenLetters));\\n        \\n        int count = 0;\\n        stringstream ss(text);\\n        \\n        string word;\\n        bool found = true;\\n        while(ss >> word) {\\n            found = true;\\n            for(char &ch : word) {\\n                if(st.find(ch) != end(st)) {\\n                    found = false;\\n                    break;\\n                }\\n            }\\n            if(found) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344873,
                "title": "a-few-solutions",
                "content": "Return the count of filtered words from the input `text` which do *not* contain any characters from the array of broken letters `A`, ie. we use an unordered set `X` for O(1) lookups.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun canBeTypedWords(text: String, A: String): Int {\\n        var X = A.toCharArray().toSet()\\n        return text.split(\" \").filter{ it.toCharArray().all{ !X.contains(it) } }.size\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet canBeTypedWords = (text, A, X = new Set(A)) => text.split(\\' \\').filter(word => word.split(\\'\\').every(c => !X.has(c))).length;\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, A: str) -> int:\\n        X = set(A)\\n        return len([word for word in text.split(\\' \\') if all(c not in X for c in word)])\\n```\\n\\n*C++* (emplace back)\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<char>;\\n    int canBeTypedWords(string text, string A, VS words = {}, int cnt = 0) {\\n        Set X{ A.begin(), A.end() };\\n        istringstream is{ text };\\n        for (string word; is >> word; words.emplace_back(word));\\n        for (auto& word: words)\\n            cnt += all_of(word.begin(), word.end(), [&](auto c) { return X.find(c) == X.end(); });\\n        return cnt;\\n    }\\n};\\n```\\n\\n*C++* (istream iterator)\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<char>;\\n    int canBeTypedWords(string text, string A, VS words = {}, int cnt = 0) {\\n        Set X{ A.begin(), A.end() };\\n        istringstream is{ text };\\n        copy(istream_iterator<string>(is), istream_iterator<string>(), back_inserter(words));\\n        for (auto& word: words)\\n            cnt += all_of(word.begin(), word.end(), [&](auto c) { return X.find(c) == X.end(); });\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun canBeTypedWords(text: String, A: String): Int {\\n        var X = A.toCharArray().toSet()\\n        return text.split(\" \").filter{ it.toCharArray().all{ !X.contains(it) } }.size\\n    }\\n}\\n```\n```\\nlet canBeTypedWords = (text, A, X = new Set(A)) => text.split(\\' \\').filter(word => word.split(\\'\\').every(c => !X.has(c))).length;\\n```\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, A: str) -> int:\\n        X = set(A)\\n        return len([word for word in text.split(\\' \\') if all(c not in X for c in word)])\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<char>;\\n    int canBeTypedWords(string text, string A, VS words = {}, int cnt = 0) {\\n        Set X{ A.begin(), A.end() };\\n        istringstream is{ text };\\n        for (string word; is >> word; words.emplace_back(word));\\n        for (auto& word: words)\\n            cnt += all_of(word.begin(), word.end(), [&](auto c) { return X.find(c) == X.end(); });\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<char>;\\n    int canBeTypedWords(string text, string A, VS words = {}, int cnt = 0) {\\n        Set X{ A.begin(), A.end() };\\n        istringstream is{ text };\\n        copy(istream_iterator<string>(is), istream_iterator<string>(), back_inserter(words));\\n        for (auto& word: words)\\n            cnt += all_of(word.begin(), word.end(), [&](auto c) { return X.find(c) == X.end(); });\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344871,
                "title": "python-easy-to-understand-solution",
                "content": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        #making a list of words from text string\\n        words = text.split()\\n        \\n        #counting total words\\n        res = len(words)\\n        \\n        for word in words:\\n            for brokenLetter in brokenLetters:\\n                \\n                #if the word contains a brokenletter reduce the total count by one\\n                if brokenLetter in word:\\n                    res -= 1\\n                    break\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        #making a list of words from text string\\n        words = text.split()\\n        \\n        #counting total words\\n        res = len(words)\\n        \\n        for word in words:\\n            for brokenLetter in brokenLetters:\\n                \\n                #if the word contains a brokenletter reduce the total count by one\\n                if brokenLetter in word:\\n                    res -= 1\\n                    break\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023364,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        count = 0\\n\\n        for word in text.split(\" \"):\\n            check = True\\n            for char in brokenLetters:\\n                if char in word:\\n                    check = False\\n            \\n            if check:\\n                count += 1\\n        \\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        count = 0\\n\\n        for word in text.split(\" \"):\\n            check = True\\n            for char in brokenLetters:\\n                if char in word:\\n                    check = False\\n            \\n            if check:\\n                count += 1\\n        \\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842028,
                "title": "golang",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nfunc canBeTypedWords(text string, brokenLetters string) int {\\n  badLetters := 0\\n  i := 0\\n  ans := 0\\n\\n  for i < len(text) {\\n    if strings.ContainsAny(brokenLetters, string(text[i])) {\\n      badLetters++\\n    }\\n    if text[i] == 32 || i == len(text)-1 {\\n      if badLetters == 0 {\\n        ans++\\n      }\\n      badLetters = 0\\n    }\\n    i++\\n  }\\n  return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "String"
                ],
                "code": "```\\nfunc canBeTypedWords(text string, brokenLetters string) int {\\n  badLetters := 0\\n  i := 0\\n  ans := 0\\n\\n  for i < len(text) {\\n    if strings.ContainsAny(brokenLetters, string(text[i])) {\\n      badLetters++\\n    }\\n    if text[i] == 32 || i == len(text)-1 {\\n      if badLetters == 0 {\\n        ans++\\n      }\\n      badLetters = 0\\n    }\\n    i++\\n  }\\n  return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3645405,
                "title": "easy-beginners-approach",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String[] temp= text.split(\" \");\\n        HashSet<Integer> set= new HashSet<>();\\n        for(int i=0;i<brokenLetters.length();i++){\\n            char c= brokenLetters.charAt(i);\\n            for(int j=0;j<temp.length;j++){\\n                \\n                if(temp[j].contains(Character.toString(c))) set.add(j);\\n            }\\n        }\\n\\nreturn temp.length-set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String[] temp= text.split(\" \");\\n        HashSet<Integer> set= new HashSet<>();\\n        for(int i=0;i<brokenLetters.length();i++){\\n            char c= brokenLetters.charAt(i);\\n            for(int j=0;j<temp.length;j++){\\n                \\n                if(temp[j].contains(Character.toString(c))) set.add(j);\\n            }\\n        }\\n\\nreturn temp.length-set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573705,
                "title": "maximum-number-of-words-you-can-type-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int i, j, flag=0, count=0;\\n        for(i=0 ; i<text.length() ; i++)\\n        {\\n            if(text[i]==\\' \\' && flag==0)\\n            {\\n                count++;\\n            }\\n            else if(text[i]==\\' \\')\\n            {\\n                flag=0;\\n            }\\n            else if(flag==0)\\n            {\\n                for(j=0 ; j<brokenLetters.length() ; j++)\\n                {\\n                    if(text[i]==brokenLetters[j])\\n                    {\\n                        flag=1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        if(flag==0)\\n            count++;\\n        return count;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/95d945e2-387e-4255-96b8-951335a2c9fe_1685331837.093088.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int i, j, flag=0, count=0;\\n        for(i=0 ; i<text.length() ; i++)\\n        {\\n            if(text[i]==\\' \\' && flag==0)\\n            {\\n                count++;\\n            }\\n            else if(text[i]==\\' \\')\\n            {\\n                flag=0;\\n            }\\n            else if(flag==0)\\n            {\\n                for(j=0 ; j<brokenLetters.length() ; j++)\\n                {\\n                    if(text[i]==brokenLetters[j])\\n                    {\\n                        flag=1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        if(flag==0)\\n            count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340498,
                "title": "java-using-arraylist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n   int c=0,ans=0;\\n  for(String s:text.split(\" \")){\\n        ArrayList<Character> aa=new ArrayList<>();\\n        c=0;\\n      for(char ch:s.toCharArray()){\\n         aa.add(ch);\\n      }\\n      for(char ch:brokenLetters.toCharArray()){\\n          if(aa.contains(ch))\\n          c++;\\n      }\\n      if(c==0)\\n      ans++;\\n\\n  }\\n  return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n   int c=0,ans=0;\\n  for(String s:text.split(\" \")){\\n        ArrayList<Character> aa=new ArrayList<>();\\n        c=0;\\n      for(char ch:s.toCharArray()){\\n         aa.add(ch);\\n      }\\n      for(char ch:brokenLetters.toCharArray()){\\n          if(aa.contains(ch))\\n          c++;\\n      }\\n      if(c==0)\\n      ans++;\\n\\n  }\\n  return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221440,
                "title": "python-without-using-set",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        ans = 0\\n        \\n        for i in text.split(\" \"):\\n            for j in i:\\n                if j in brokenLetters:\\n                    ans -= 1\\n                    break\\n            ans += 1\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        ans = 0\\n        \\n        for i in text.split(\" \"):\\n            for j in i:\\n                if j in brokenLetters:\\n                    ans -= 1\\n                    break\\n            ans += 1\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680080,
                "title": "c-100-faster",
                "content": "```\\nclass Solution {\\n   public:\\n    int canBeTypedWords(string text, string letters) {\\n        bool hash[26] = {0};\\n        int i, count = 0;\\n        for (i = 0; i < letters.size(); i++) hash[letters[i] - \\'a\\'] = true;\\n\\n        bool flag = true;\\n        for (i = 0; i < text.length(); i++) {\\n            if (text[i] == \\' \\') {\\n                if (flag) count++;\\n                flag = true;\\n            } else if (hash[text[i] - \\'a\\'])\\n                flag = false;\\n        }\\n        return i == text.length() && flag ? count + 1 : count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n   public:\\n    int canBeTypedWords(string text, string letters) {\\n        bool hash[26] = {0};\\n        int i, count = 0;\\n        for (i = 0; i < letters.size(); i++) hash[letters[i] - \\'a\\'] = true;\\n\\n        bool flag = true;\\n        for (i = 0; i < text.length(); i++) {\\n            if (text[i] == \\' \\') {\\n                if (flag) count++;\\n                flag = true;\\n            } else if (hash[text[i] - \\'a\\'])\\n                flag = false;\\n        }\\n        return i == text.length() && flag ? count + 1 : count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645033,
                "title": "cpp-o-n-simple-loop-with-comments-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int brokenLettersIdx [26] = {};\\n        int canTypeWords = 0;\\n\\t\\t// Indexing the broken keys\\n        for (char c : brokenLetters) {\\n            brokenLettersIdx[c-\\'a\\'] = 1;\\n        }\\n\\t\\t\\n\\t\\t// - Looping through words\\n\\t\\t// - For each word, count the number of broken keys\\n\\t\\t// - 1. If number of broken keys == 0\\n\\t\\t// -     Increments canTypeWords by one\\n\\t\\t//-  2. Otherwise continue\\n        for (int i = 0; i < text.length(); i++) {\\n            int brk = 0;\\n            while (i < text.length() && text[i] != \\' \\') {\\n                if (brokenLettersIdx[text[i]-\\'a\\'] == 1) {\\n                    brk++;\\n                }\\n                i++;\\n            }\\n            if (brk == 0) {\\n                canTypeWords++;\\n            }\\n        }\\n        return canTypeWords;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int brokenLettersIdx [26] = {};\\n        int canTypeWords = 0;\\n\\t\\t// Indexing the broken keys\\n        for (char c : brokenLetters) {\\n            brokenLettersIdx[c-\\'a\\'] = 1;\\n        }\\n\\t\\t\\n\\t\\t// - Looping through words\\n\\t\\t// - For each word, count the number of broken keys\\n\\t\\t// - 1. If number of broken keys == 0\\n\\t\\t// -     Increments canTypeWords by one\\n\\t\\t//-  2. Otherwise continue\\n        for (int i = 0; i < text.length(); i++) {\\n            int brk = 0;\\n            while (i < text.length() && text[i] != \\' \\') {\\n                if (brokenLettersIdx[text[i]-\\'a\\'] == 1) {\\n                    brk++;\\n                }\\n                i++;\\n            }\\n            if (brk == 0) {\\n                canTypeWords++;\\n            }\\n        }\\n        return canTypeWords;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2604394,
                "title": "c-beginner-friendly-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int len1=text.length();\\n        int len2=brokenLetters.length();\\n        unordered_map<char,int> mp;\\n        int count=0;\\n        int flag=-1;\\n        int point=0;\\n        for(int i=0;i<len2;i++)\\n        {\\n            mp[brokenLetters[i]]++;\\n        }\\n        for(int i=0;i<len1;i++)\\n        {\\n            if(mp.find(text[i])!=mp.end())\\n                flag=1;\\n            if(text[i]==\\' \\'&& flag==-1)\\n            {\\n                flag=-1;\\n                count++;\\n            }\\n            else if(text[i]==\\' \\'&& flag==1)\\n            {\\n                flag=-1;\\n            }\\n        }\\n        if(flag==-1)\\n            count++;\\n        return count;\\n    }\\n};\\n```\\nplease upvote",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int len1=text.length();\\n        int len2=brokenLetters.length();\\n        unordered_map<char,int> mp;\\n        int count=0;\\n        int flag=-1;\\n        int point=0;\\n        for(int i=0;i<len2;i++)\\n        {\\n            mp[brokenLetters[i]]++;\\n        }\\n        for(int i=0;i<len1;i++)\\n        {\\n            if(mp.find(text[i])!=mp.end())\\n                flag=1;\\n            if(text[i]==\\' \\'&& flag==-1)\\n            {\\n                flag=-1;\\n                count++;\\n            }\\n            else if(text[i]==\\' \\'&& flag==1)\\n            {\\n                flag=-1;\\n            }\\n        }\\n        if(flag==-1)\\n            count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572527,
                "title": "c-without-map-most-optimal-code",
                "content": "```\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        vector<bool> broken(26, false);\\n        for(int i=0; i<brokenLetters.size(); i++){\\n            broken[brokenLetters[i] - \\'a\\'] = true;\\n        }\\n        bool t = true;\\n        int ans=0;\\n        \\n        for(int i=0; i<text.size(); i++){\\n            \\n            if(isspace(text[i])){\\n                if(t == true) ans++;\\n                 t = true;\\n            }\\n            else if(broken[text[i] - \\'a\\']) t = false;          \\n        }\\n        if(t) ans++;\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        vector<bool> broken(26, false);\\n        for(int i=0; i<brokenLetters.size(); i++){\\n            broken[brokenLetters[i] - \\'a\\'] = true;\\n        }\\n        bool t = true;\\n        int ans=0;\\n        \\n        for(int i=0; i<text.size(); i++){\\n            \\n            if(isspace(text[i])){\\n                if(t == true) ans++;\\n                 t = true;\\n            }\\n            else if(broken[text[i] - \\'a\\']) t = false;          \\n        }\\n        if(t) ans++;\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2563220,
                "title": "i-bet-you-will-not-find-this-solution-anywhere",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        text+= \" \";\\n        HashMap<Character,Integer> hm = new HashMap<>();\\n        for(int i = 0;i<brokenLetters.length();i++){\\n            hm.put(brokenLetters.charAt(i),hm.getOrDefault(brokenLetters.charAt(i),0)+1);\\n        }\\n        int count = 0;\\n        int ans = 0;\\n        for(int i = 0;i<text.length();i++){\\n            char ch = text.charAt(i);\\n            if(hm.containsKey(ch)){\\n                count++;\\n            }\\n            if((ch == \\' \\' && count == 0) ||(text.charAt(i) == \\' \\') && (count == 0)){\\n                ans+= 1;\\n            }\\n            if(ch == \\' \\' && count!=0){\\n                count = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        text+= \" \";\\n        HashMap<Character,Integer> hm = new HashMap<>();\\n        for(int i = 0;i<brokenLetters.length();i++){\\n            hm.put(brokenLetters.charAt(i),hm.getOrDefault(brokenLetters.charAt(i),0)+1);\\n        }\\n        int count = 0;\\n        int ans = 0;\\n        for(int i = 0;i<text.length();i++){\\n            char ch = text.charAt(i);\\n            if(hm.containsKey(ch)){\\n                count++;\\n            }\\n            if((ch == \\' \\' && count == 0) ||(text.charAt(i) == \\' \\') && (count == 0)){\\n                ans+= 1;\\n            }\\n            if(ch == \\' \\' && count!=0){\\n                count = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510079,
                "title": "python-solution-with-sets",
                "content": "\\n\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        ans = 0\\n        brSet = set(brokenLetters)\\n        for w in text.split():\\n            if brSet.isdisjoint(set(w)):\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        ans = 0\\n        brSet = set(brokenLetters)\\n        for w in text.split():\\n            if brSet.isdisjoint(set(w)):\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455654,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int count=0;\\n        text+=\" \";\\n        string res;\\n        bool istrue;\\n        vector<string>sk;\\n        for(auto i:text){\\n            if(isalpha(i)){\\n                res+=i;\\n            }\\n            else{\\n                for(auto j:brokenLetters){\\n                    auto found=res.find(j);\\n                    if(found!=string::npos){\\n                        istrue=false;\\n                        break;\\n                    }\\n                    else{\\n                        istrue=true;\\n                    }\\n                }\\n                if(istrue==true){\\n                    sk.push_back(res);\\n                }\\n                \\n                res.clear();\\n            }\\n        }\\n        \\n  \\n        count=sk.size();\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int count=0;\\n        text+=\" \";\\n        string res;\\n        bool istrue;\\n        vector<string>sk;\\n        for(auto i:text){\\n            if(isalpha(i)){\\n                res+=i;\\n            }\\n            else{\\n                for(auto j:brokenLetters){\\n                    auto found=res.find(j);\\n                    if(found!=string::npos){\\n                        istrue=false;\\n                        break;\\n                    }\\n                    else{\\n                        istrue=true;\\n                    }\\n                }\\n                if(istrue==true){\\n                    sk.push_back(res);\\n                }\\n                \\n                res.clear();\\n            }\\n        }\\n        \\n  \\n        count=sk.size();\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373075,
                "title": "typescript-javascript-a-one-liner-with-fastest-runtime-100-00",
                "content": "As you\\'re having multiple characters to check a condition against, consider using *Array.prototype.some()*.\\n```\\nfunction canBeTypedWords(text: string, brokenLetters: string): number {\\n  return text.split(\\' \\').reduce((prev, cur) => brokenLetters.split(\\'\\').some(a => cur.indexOf(a) > -1) ? prev : prev + 1, 0);\\n}\\n```\\nLet me know if you have any questions. Please hit upvote if you find it useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "String"
                ],
                "code": "```\\nfunction canBeTypedWords(text: string, brokenLetters: string): number {\\n  return text.split(\\' \\').reduce((prev, cur) => brokenLetters.split(\\'\\').some(a => cur.indexOf(a) > -1) ? prev : prev + 1, 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2369790,
                "title": "c-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int n=brokenLetters.size();\\n        int bl[26]={0};\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            bl[brokenLetters[i]-\\'a\\']++;\\n        }\\n        int flag=0;\\n        for(int i=0;i<text.size();i++)\\n        {\\n                if(text[i]!=\\' \\' && bl[text[i]-\\'a\\']==1)\\n                {\\n                    flag=1;\\n                }\\n                else if(text[i]==\\' \\')\\n                {\\n                    if(flag==0)\\n                    {\\n                        count++;\\n                    }\\n                    flag=0;\\n                }\\n        }\\n        if(flag==0)\\n        {\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int n=brokenLetters.size();\\n        int bl[26]={0};\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            bl[brokenLetters[i]-\\'a\\']++;\\n        }\\n        int flag=0;\\n        for(int i=0;i<text.size();i++)\\n        {\\n                if(text[i]!=\\' \\' && bl[text[i]-\\'a\\']==1)\\n                {\\n                    flag=1;\\n                }\\n                else if(text[i]==\\' \\')\\n                {\\n                    if(flag==0)\\n                    {\\n                        count++;\\n                    }\\n                    flag=0;\\n                }\\n        }\\n        if(flag==0)\\n        {\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276401,
                "title": "c-sets-logical-approach",
                "content": "![image](https://assets.leetcode.com/users/images/4dcc4554-7549-48fe-bdc7-b97fa0e53493_1657706859.8209372.png)\\n\\n**n==bl.size() && m==t.size()\\nT->O(n * logn +m * log n) && S->O(n) **\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint canBeTypedWords(string t, string bl) {\\n\\t\\t\\tset<char>s;\\n\\t\\t\\tbool f=true;\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(auto i:bl)s.insert(i);\\n\\t\\t\\tfor(int i=0;i<t.size();i++){\\n\\t\\t\\t\\tif(t[i]==\\' \\'){\\n\\t\\t\\t\\t\\tif(f)count++;\\n\\t\\t\\t\\t\\tf=true;\\n\\t\\t\\t\\t}    \\n\\t\\t\\t\\tif(s.find(t[i])!=s.end())f=false;\\n\\t\\t\\t}\\n\\t\\t\\tif(f)count++;\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint canBeTypedWords(string t, string bl) {\\n\\t\\t\\tset<char>s;\\n\\t\\t\\tbool f=true;\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(auto i:bl)s.insert(i);\\n\\t\\t\\tfor(int i=0;i<t.size();i++){\\n\\t\\t\\t\\tif(t[i]==\\' \\'){\\n\\t\\t\\t\\t\\tif(f)count++;\\n\\t\\t\\t\\t\\tf=true;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2208909,
                "title": "python-1-liner",
                "content": "```py\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return len([i for i in text.split(\\' \\') if len(set(i).intersection(brokenLetters))==0])\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return len([i for i in text.split(\\' \\') if len(set(i).intersection(brokenLetters))==0])\\n",
                "codeTag": "Java"
            },
            {
                "id": 2152951,
                "title": "python-1-liner",
                "content": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return sum (1 for word in text.split() if all(char not in list(brokenLetters) for char in word))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return sum (1 for word in text.split() if all(char not in list(brokenLetters) for char in word))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125075,
                "title": "javascript-2-liners-regexp",
                "content": "**Long Vers.**\\n```\\nvar canBeTypedWords = function(text, brokenLetters) {\\n    let regexp=\"[\"+brokenLetters+\"]\\\\+\"\\n    let word=text.split(\" \"), count=0;\\n    for(let i=0; i<word.length; i++){\\n        let work=true;\\n\\t\\t// if matches, means word[i] contains malfunction letters.\\n        if(word[i].match(regexp)){work=false};\\n        if(work){count++};\\n    }\\n    return count;\\n};\\n```\\n\\n**Short Vers.**\\n```\\nvar canBeTypedWords = function(text, brokenLetters) {\\n    let word=text.split(\" \");\\n\\t// accumulate wordcount that doesn\\'t match.\\n    return word.reduce((acc, curr)=>acc+!curr.match(\"[\"+brokenLetters+\"]\\\\+\"), 0);\\n};\\n```\\n\\nThanks for your reading and **up-voting** :)\\n\\n**\\u2B50 Check [HERE](https://github.com/Lynn19950915/LeetCode_King) for my full Leetcode Notes ~**\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canBeTypedWords = function(text, brokenLetters) {\\n    let regexp=\"[\"+brokenLetters+\"]\\\\+\"\\n    let word=text.split(\" \"), count=0;\\n    for(let i=0; i<word.length; i++){\\n        let work=true;\\n\\t\\t// if matches, means word[i] contains malfunction letters.\\n        if(word[i].match(regexp)){work=false};\\n        if(work){count++};\\n    }\\n    return count;\\n};\\n```\n```\\nvar canBeTypedWords = function(text, brokenLetters) {\\n    let word=text.split(\" \");\\n\\t// accumulate wordcount that doesn\\'t match.\\n    return word.reduce((acc, curr)=>acc+!curr.match(\"[\"+brokenLetters+\"]\\\\+\"), 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2094848,
                "title": "java-solution-very-easy",
                "content": "```\\nclass Solution {\\n\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 0;\\n        HashSet<Character> set = new HashSet<>();\\n        for (int i = 0; i < brokenLetters.length(); i++) set.add(brokenLetters.charAt(i));\\n        String res[] = text.split(\" \");\\n        for (String s : res) {\\n            for (char ch : s.toCharArray()) {\\n                if (set.contains(ch)) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return res.length - count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 0;\\n        HashSet<Character> set = new HashSet<>();\\n        for (int i = 0; i < brokenLetters.length(); i++) set.add(brokenLetters.charAt(i));\\n        String res[] = text.split(\" \");\\n        for (String s : res) {\\n            for (char ch : s.toCharArray()) {\\n                if (set.contains(ch)) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return res.length - count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093968,
                "title": "c-simple-fast-solution-0ms",
                "content": "Hi guys! \\nHere\\'s my solution for this problem. It\\'s pretty straight forward and the code is commented in detail. \\nIt works like a charm for space & time complexity (0ms and 6mb), so I decided to share it.\\nHope you enjoy! \\n\\n```\\nint canBeTypedWords(string text, string broken) {\\n        \\n        //as every word is separated by a single space, the total number of words is the number of spaces + 1\\n        int n_words = count(text.begin(), text.end(), \\' \\')+1; \\n        \\n        //we iterate through all of the chars in the text string\\n        for(int i = 0; i < text.length(); i++){\\n            \\n            //and for all of the chars in the broken string\\n            for(int j = 0;  j < broken.length(); j++)\\n                \\n                if(text[i] == broken[j]){\\n                    //if any chars is in common we reduce the number of words by 1 \\n                    n_words--; \\n                    \\n                    //and we iterate i until it finds the next word or the end of the string.\\n                    for(; i < text.length() && text[i] != \\' \\'; i++);\\n                }\\n                    \\n        }\\n        //we just return the number of words left. \\n        return n_words;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint canBeTypedWords(string text, string broken) {\\n        \\n        //as every word is separated by a single space, the total number of words is the number of spaces + 1\\n        int n_words = count(text.begin(), text.end(), \\' \\')+1; \\n        \\n        //we iterate through all of the chars in the text string\\n        for(int i = 0; i < text.length(); i++){\\n            \\n            //and for all of the chars in the broken string\\n            for(int j = 0;  j < broken.length(); j++)\\n                \\n                if(text[i] == broken[j]){\\n                    //if any chars is in common we reduce the number of words by 1 \\n                    n_words--; \\n                    \\n                    //and we iterate i until it finds the next word or the end of the string.\\n                    for(; i < text.length() && text[i] != \\' \\'; i++);\\n                }\\n                    \\n        }\\n        //we just return the number of words left. \\n        return n_words;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084515,
                "title": "java-using-set",
                "content": "```\\npublic int canBeTypedWords(String text, String brokenLetters) {\\n        int i=0;\\n        String[] arr=text.split(\" \");\\n        Set<Character>st=new HashSet<>();\\n        for(char c:brokenLetters.toCharArray()){\\n\\n            st.add(c);\\n        }\\n        for(String s:arr){\\n\\n            if(cont(s,st)){\\n\\n                i++;\\n            }\\n        }\\n        return i;\\n        \\n    }\\n    boolean cont(String s,Set<Character>st){\\n\\n        for(char c:s.toCharArray()){\\n\\n            if(st.contains(c)) return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int canBeTypedWords(String text, String brokenLetters) {\\n        int i=0;\\n        String[] arr=text.split(\" \");\\n        Set<Character>st=new HashSet<>();\\n        for(char c:brokenLetters.toCharArray()){\\n\\n            st.add(c);\\n        }\\n        for(String s:arr){\\n\\n            if(cont(s,st)){\\n\\n                i++;\\n            }\\n        }\\n        return i;\\n        \\n    }\\n    boolean cont(String s,Set<Character>st){\\n\\n        for(char c:s.toCharArray()){\\n\\n            if(st.contains(c)) return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2054075,
                "title": "java-easy-hash-map-count-break",
                "content": "**Brute Force**\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 0;\\n        String[] splt = text.split(\" \");\\n        for(String s :splt){\\n            boolean flag = true;\\n            for(char c : brokenLetters.toCharArray()){\\n                if(s.contains(Character.toString(c))){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n```java\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int result = 0;\\n        int count = 0;\\n        String[] splt = text.split(\" \");\\n        Map<Character,Integer> map = new HashMap<>();\\n\\t\\t// Store broken Letter in the hashmap\\n        for(Character c : brokenLetters.toCharArray()){\\n            map.put(c, 1);\\n        }\\n\\t\\t// pick one by one String and compare with the map\\n        for(String s : splt){\\n            for(int i = 0; i < s.length(); i++){\\n                char c = s.charAt(i);\\n\\t\\t\\t\\t// if break letter contains then break loop \\n                if(map.containsKey(c)){\\n                    count = 0;\\n                    break;\\n                }else{\\n                    count++;\\n                }\\n            }\\n\\t\\t\\t// check length of word and count is same or not.\\n\\t\\t\\t// if same count 1 with the result\\n            if(count == s.length()){\\n                result++;\\n                count = 0;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n**More Optimized**\\n\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String[] splt = text.split(\" \");\\n        int count  = 0;\\n        Map<Character,Integer> map = new HashMap<>();\\n        \\n        for(Character c : brokenLetters.toCharArray()){\\n            map.put(c,1);\\n        }\\n\\n        for(String s : splt){\\n            boolean flag = true;\\n            for(int i = 0;i < s.length(); i++){\\n                if(map.containsKey(s.charAt(i))){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                count++;\\n            }\\n        }\\n        return count;\\n        }  \\n    }",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 0;\\n        String[] splt = text.split(\" \");\\n        for(String s :splt){\\n            boolean flag = true;\\n            for(char c : brokenLetters.toCharArray()){\\n                if(s.contains(Character.toString(c))){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int result = 0;\\n        int count = 0;\\n        String[] splt = text.split(\" \");\\n        Map<Character,Integer> map = new HashMap<>();\\n\\t\\t// Store broken Letter in the hashmap\\n        for(Character c : brokenLetters.toCharArray()){\\n            map.put(c, 1);\\n        }\\n\\t\\t// pick one by one String and compare with the map\\n        for(String s : splt){\\n            for(int i = 0; i < s.length(); i++){\\n                char c = s.charAt(i);\\n\\t\\t\\t\\t// if break letter contains then break loop \\n                if(map.containsKey(c)){\\n                    count = 0;\\n                    break;\\n                }else{\\n                    count++;\\n                }\\n            }\\n\\t\\t\\t// check length of word and count is same or not.\\n\\t\\t\\t// if same count 1 with the result\\n            if(count == s.length()){\\n                result++;\\n                count = 0;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886112,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        HashSet<Character>hs=new HashSet<>();\\n        for(int i=0;i<brokenLetters.length();i++)\\n            hs.add(brokenLetters.charAt(i));\\n        String s=\"\";\\n        int v=0,count=0;\\n        for(int i=0;i<text.length();i++)\\n        {\\n            char ch=text.charAt(i);\\n            if(hs.contains(ch))\\n                v=1;\\n            if(ch==\\' \\')\\n            {\\n                if(v==0)\\n                    ++count;\\n                v=0;\\n            }\\n        }\\n        if(v==0)\\n            ++count;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        HashSet<Character>hs=new HashSet<>();\\n        for(int i=0;i<brokenLetters.length();i++)\\n            hs.add(brokenLetters.charAt(i));\\n        String s=\"\";\\n        int v=0,count=0;\\n        for(int i=0;i<text.length();i++)\\n        {\\n            char ch=text.charAt(i);\\n            if(hs.contains(ch))\\n                v=1;\\n            if(ch==\\' \\')\\n            {\\n                if(v==0)\\n                    ++count;\\n                v=0;\\n            }\\n        }\\n        if(v==0)\\n            ++count;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845569,
                "title": "c-simple-code-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_set<char>uset;\\n        for(char c : brokenLetters) uset.insert(c);\\n        int ans = 0;\\n        int isBroken = 0;\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(uset.find(text[i]) != uset.end())\\n                isBroken = 1;\\n            if(text[i] == \\' \\' || i == text.size()-1)\\n            {\\n                if(isBroken) isBroken = 0;\\n                else ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_set<char>uset;\\n        for(char c : brokenLetters) uset.insert(c);\\n        int ans = 0;\\n        int isBroken = 0;\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(uset.find(text[i]) != uset.end())\\n                isBroken = 1;\\n            if(text[i] == \\' \\' || i == text.size()-1)\\n            {\\n                if(isBroken) isBroken = 0;\\n                else ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1717468,
                "title": "beginner-friendly-java-solution",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String words[] = text.split(\" \");\\n        int count = 0;\\n        for(String word : words){\\n            for(int i=0; i<word.length(); i++){\\n                if(brokenLetters.contains(word.charAt(i) + \"\")){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return words.length - count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String words[] = text.split(\" \");\\n        int count = 0;\\n        for(String word : words){\\n            for(int i=0; i<word.length(); i++){\\n                if(brokenLetters.contains(word.charAt(i) + \"\")){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return words.length - count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684385,
                "title": "rust-set-filter",
                "content": "```rust\\nimpl Solution {\\n    pub fn can_be_typed_words(text: String, broken_letters: String) -> i32 {\\n        let set = broken_letters.chars().collect::<std::collections::HashSet<_>>();\\n        \\n        text.split_whitespace().filter(|word| word.chars().all(|c| !set.contains(&c))).count() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn can_be_typed_words(text: String, broken_letters: String) -> i32 {\\n        let set = broken_letters.chars().collect::<std::collections::HashSet<_>>();\\n        \\n        text.split_whitespace().filter(|word| word.chars().all(|c| !set.contains(&c))).count() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1673731,
                "title": "2-c-solutions-using-string-stream-class-and-hashmaps",
                "content": "*The time complexity of both the solutions is O(text.size())*\\n\\n**Solution 1: Using Simple string methods and maps**\\n*SC = O(brokenletters.size())*\\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_set<char>us(brokenLetters.begin(), brokenLetters.end());\\n        int ans = 0;\\n        int i = 0;\\n        \\n        while(i<text.size()){\\n            int flag = true;\\n            while(i<text.size() and text[i] !=\\' \\'){\\n                if(us.find(text[i]) != us.end()){\\n                    flag = false;\\n                }\\n                i++;\\n            }\\n            \\n            if(flag){\\n                ans++;\\n            }\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Solution 2: Using Stringstream class and map**\\n*SC = O(text.size() + brokenLetter.size())*\\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_set<char>us(brokenLetters.begin(), brokenLetters.end());\\n        int ans = 0;\\n        \\n        stringstream str(text);\\n        \\n        while(1){\\n            string word;\\n            getline(str, word, \\' \\');\\n            \\n            if(word.empty()){\\n                break;\\n            }\\n            \\n            else{\\n                int flag = true;\\n                for(char x: word){\\n                    if(us.find(x) != us.end()){\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                if(flag){\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n***Feel free to ask any doubts regarding the second approach and do upvote if you liked it***",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_set<char>us(brokenLetters.begin(), brokenLetters.end());\\n        int ans = 0;\\n        int i = 0;\\n        \\n        while(i<text.size()){\\n            int flag = true;\\n            while(i<text.size() and text[i] !=\\' \\'){\\n                if(us.find(text[i]) != us.end()){\\n                    flag = false;\\n                }\\n                i++;\\n            }\\n            \\n            if(flag){\\n                ans++;\\n            }\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_set<char>us(brokenLetters.begin(), brokenLetters.end());\\n        int ans = 0;\\n        \\n        stringstream str(text);\\n        \\n        while(1){\\n            string word;\\n            getline(str, word, \\' \\');\\n            \\n            if(word.empty()){\\n                break;\\n            }\\n            \\n            else{\\n                int flag = true;\\n                for(char x: word){\\n                    if(us.find(x) != us.end()){\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                if(flag){\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665398,
                "title": "c-runtime-0-ms-memory-usage-7-2-mb",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int ret = 0;\\n        bool isBroken;\\n        std::vector<string> words;\\n        std::vector<char> chars;\\n        split(words, text);\\n        for(char& b : brokenLetters)\\n            chars.push_back(b);\\n        \\n        for(string& w : words) {\\n            isBroken = false;\\n            for(char& s : w) {\\n                if (isBroken)\\n                    break;\\n                for(char& c : chars) {\\n                    if(c==s) {\\n                        ret++;\\n                        isBroken = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return words.size()-ret;\\n    }\\n    void split(vector<string>& words, string& text){\\n        string tmp;\\n        for(int i=0; i<text.size(); i++){\\n            if(text[i] != \\' \\')\\n                tmp+=text[i];\\n            else{\\n                words.push_back(tmp);\\n                tmp=\"\";\\n            }\\n        }\\n        words.push_back(tmp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int ret = 0;\\n        bool isBroken;\\n        std::vector<string> words;\\n        std::vector<char> chars;\\n        split(words, text);\\n        for(char& b : brokenLetters)\\n            chars.push_back(b);\\n        \\n        for(string& w : words) {\\n            isBroken = false;\\n            for(char& s : w) {\\n                if (isBroken)\\n                    break;\\n                for(char& c : chars) {\\n                    if(c==s) {\\n                        ret++;\\n                        isBroken = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return words.size()-ret;\\n    }\\n    void split(vector<string>& words, string& text){\\n        string tmp;\\n        for(int i=0; i<text.size(); i++){\\n            if(text[i] != \\' \\')\\n                tmp+=text[i];\\n            else{\\n                words.push_back(tmp);\\n                tmp=\"\";\\n            }\\n        }\\n        words.push_back(tmp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645193,
                "title": "java-runtime-2ms-faster-than-80-2",
                "content": "Approach:\\n1. Use inner for loop \\'j\\' to check if it reached the end of \\'brokenLetters\\' string. It means that the current word being checked from \\'words[]\\', doesnot have any of the characters from broken letters.\\nThen, increment count for each iteration.\\n2. Count represents the count of words that have passed the check. Hence, return \\'count\\' as output.\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {        \\n        String words[] = text.split(\" \");\\n        if (brokenLetters.length() == 0) {\\n              return words.length;\\n        }\\n        int count = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            for (int j = 0; j < brokenLetters.length(); j++) {\\n              if (words[i].indexOf(brokenLetters.charAt(j)) != -1){\\n                  break;\\n              }\\n              if (j == brokenLetters.length() - 1){\\n                  count++;\\n              }\\n            }\\n        }\\n        return count; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {        \\n        String words[] = text.split(\" \");\\n        if (brokenLetters.length() == 0) {\\n              return words.length;\\n        }\\n        int count = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            for (int j = 0; j < brokenLetters.length(); j++) {\\n              if (words[i].indexOf(brokenLetters.charAt(j)) != -1){\\n                  break;\\n              }\\n              if (j == brokenLetters.length() - 1){\\n                  count++;\\n              }\\n            }\\n        }\\n        return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1619928,
                "title": "faster-than-97-24ms-python-3",
                "content": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        res = 0\\n        for word in text.split():\\n            for ch in brokenLetters:\\n                if ch in word:\\n                    break\\n            else:\\n                res+=1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        res = 0\\n        for word in text.split():\\n            for ch in brokenLetters:\\n                if ch in word:\\n                    break\\n            else:\\n                res+=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588371,
                "title": "python-easy-solution-with-explanation",
                "content": "Here in this code we first break the text sentence into single words and store it in a list .\\nThen we iterate over every word from that list , and check if any letter from that particular word lies in the brokenLetters or not .\\nIf any letter does not lie from that word in the brokenLetters string then we increase the count value and return the count value at the end .\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        l=list(map(str,text.split()))\\n        count=0\\n        for i in l:\\n            flag=True\\n            for j in i:\\n                if j in brokenLetters:\\n                    flag=False\\n                    break\\n            if flag==True:\\n                count+=1\\n        return(count)\\n```\\nIf u understood the code then plz...UPVOTE",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        l=list(map(str,text.split()))\\n        count=0\\n        for i in l:\\n            flag=True\\n            for j in i:\\n                if j in brokenLetters:\\n                    flag=False\\n                    break\\n            if flag==True:\\n                count+=1\\n        return(count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486175,
                "title": "java-solution-using-hashset",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 0;\\n        HashSet<Character> set = new HashSet<>();\\n        for (char c : brokenLetters.toCharArray())\\n            set.add(c);\\n        \\n        String[] subText = text.split(\" \");\\n        for (String singleText : subText) {\\n            int check = 0;\\n            for (char c : singleText.toCharArray()) {\\n                if (set.contains(c)) {\\n                    check = 1;\\n                    break;\\n                } \\n            }\\n            if (check == 0)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 0;\\n        HashSet<Character> set = new HashSet<>();\\n        for (char c : brokenLetters.toCharArray())\\n            set.add(c);\\n        \\n        String[] subText = text.split(\" \");\\n        for (String singleText : subText) {\\n            int check = 0;\\n            for (char c : singleText.toCharArray()) {\\n                if (set.contains(c)) {\\n                    check = 1;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1482884,
                "title": "java-o-n-2",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String words[] = text.split(\" \");\\n        char bks[] = brokenLetters.toCharArray();\\n        int count = words.length;\\n        \\n        for(int i=0;i<bks.length;i++)\\n            for(int j=0;j<words.length;j++)\\n                if(words[j].indexOf(bks[i]) != -1){\\n                    words[j] = \"\";\\n                    count--;\\n                }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String words[] = text.split(\" \");\\n        char bks[] = brokenLetters.toCharArray();\\n        int count = words.length;\\n        \\n        for(int i=0;i<bks.length;i++)\\n            for(int j=0;j<words.length;j++)\\n                if(words[j].indexOf(bks[i]) != -1){\\n                    words[j] = \"\";\\n                    count--;\\n                }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481620,
                "title": "easy-java-solution",
                "content": "***please upvote if you find this helpful.***\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        \\n        int count = 0;\\n        String[] arr = text.split(\" \");\\n        HashSet<Character> hs = new HashSet<>();\\n        \\n        for(int i=0;i<brokenLetters.length();i++) {\\n            hs.add(brokenLetters.charAt(i));\\n        }\\n        \\n        for(int i=0;i<arr.length;i++) {\\n            \\n            String str = arr[i];\\n            boolean canForm = true;\\n            \\n            for(int j=0;j<str.length();j++) {\\n                \\n                if(hs.contains(str.charAt(j))) {\\n                 canForm = false;\\n                 }\\n            \\n                if(j == str.length()-1 && canForm) {\\n                  count++;\\n                  }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        \\n        int count = 0;\\n        String[] arr = text.split(\" \");\\n        HashSet<Character> hs = new HashSet<>();\\n        \\n        for(int i=0;i<brokenLetters.length();i++) {\\n            hs.add(brokenLetters.charAt(i));\\n        }\\n        \\n        for(int i=0;i<arr.length;i++) {\\n            \\n            String str = arr[i];\\n            boolean canForm = true;\\n            \\n            for(int j=0;j<str.length();j++) {\\n                \\n                if(hs.contains(str.charAt(j))) {\\n                 canForm = false;\\n                 }\\n            \\n                if(j == str.length()-1 && canForm) {\\n                  count++;\\n                  }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1475917,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 0;\\n        String arr[] = text.split(\" \");\\n        for(String s:arr) {\\n            for(char c:brokenLetters.toCharArray()) {\\n                if(s.contains(Character.toString(c))) {\\n                    count++;\\n                    break;\\n                }     \\n            }\\n        }\\n        return arr.length - count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 0;\\n        String arr[] = text.split(\" \");\\n        for(String s:arr) {\\n            for(char c:brokenLetters.toCharArray()) {\\n                if(s.contains(Character.toString(c))) {\\n                    count++;\\n                    break;\\n                }     \\n            }\\n        }\\n        return arr.length - count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472671,
                "title": "javascript-js",
                "content": "```\\n/**\\n * @param {string} text\\n * @param {string} brokenLetters\\n * @return {number}\\n */\\nvar canBeTypedWords = function (text, brokenLetters) {\\n  let a = text.split(\" \");\\n  let b = brokenLetters.split(\"\");\\n  let c = new Set();\\n\\n  for (let i = 0; i < a.length; i++) {\\n    for (let j = 0; j < b.length; j++) {\\n      if (a[i].includes(b[j])) {\\n        c.add(i);\\n      }\\n    }\\n  }\\n\\n  return a.length - c.size;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} text\\n * @param {string} brokenLetters\\n * @return {number}\\n */\\nvar canBeTypedWords = function (text, brokenLetters) {\\n  let a = text.split(\" \");\\n  let b = brokenLetters.split(\"\");\\n  let c = new Set();\\n\\n  for (let i = 0; i < a.length; i++) {\\n    for (let j = 0; j < b.length; j++) {\\n      if (a[i].includes(b[j])) {\\n        c.add(i);\\n      }\\n    }\\n  }\\n\\n  return a.length - c.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1461200,
                "title": "javascript-without-array-iterate-over-string",
                "content": "Felt like doing this one without the usual `.split(\\' \\')`. \\n\\n```\\n    let wordCount = 0\\n    let hasBroken = false\\n    let word = \\'\\'\\n    \\n    for(let i = 0; i < text.length; i++) {\\n        if(text[i] !== \\' \\') {\\n            word += text[i]\\n            \\n            if(!hasBroken && brokenLetters.includes(text[i])) {\\n                hasBroken = true\\n            }\\n            \\n            if(i < text.length - 1) {\\n                continue\\n            }\\n        }\\n        \\n        if(word.length && !hasBroken) {\\n            wordCount++\\n        }\\n        \\n        word = \\'\\'\\n        hasBroken = false\\n    }\\n    \\n    return wordCount\\n```",
                "solutionTags": [],
                "code": "```\\n    let wordCount = 0\\n    let hasBroken = false\\n    let word = \\'\\'\\n    \\n    for(let i = 0; i < text.length; i++) {\\n        if(text[i] !== \\' \\') {\\n            word += text[i]\\n            \\n            if(!hasBroken && brokenLetters.includes(text[i])) {\\n                hasBroken = true\\n            }\\n            \\n            if(i < text.length - 1) {\\n                continue\\n            }\\n        }\\n        \\n        if(word.length && !hasBroken) {\\n            wordCount++\\n        }\\n        \\n        word = \\'\\'\\n        hasBroken = false\\n    }\\n    \\n    return wordCount\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1443923,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        List<String> list=new ArrayList<>();\\n\\t\\tString[] textSplit= text.split(\" \");\\n\\t\\tfor (String x : textSplit) {\\n\\t\\t\\tfor(char c:brokenLetters.toCharArray()) {\\n\\t\\t\\t\\tint index=x.indexOf(c);\\n\\t\\t\\t\\tif(index!=-1) {\\n\\t\\t\\t\\t\\tlist.add(x);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n        return Math.abs(list.size()-textSplit.length);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        List<String> list=new ArrayList<>();\\n\\t\\tString[] textSplit= text.split(\" \");\\n\\t\\tfor (String x : textSplit) {\\n\\t\\t\\tfor(char c:brokenLetters.toCharArray()) {\\n\\t\\t\\t\\tint index=x.indexOf(c);\\n\\t\\t\\t\\tif(index!=-1) {\\n\\t\\t\\t\\t\\tlist.add(x);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n        return Math.abs(list.size()-textSplit.length);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442067,
                "title": "java-solution-without-string-methods-7ms-with-string-methods-1ms",
                "content": "Without string methods\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int table[] = new int[26];\\n        \\n        for(int i=0; i<brokenLetters.length(); ++i)\\n            table[brokenLetters.charAt(i) % 97]++;\\n        \\n        int len = 0, i = 0, k = 0, ans = 0;\\n        \\n        while(i < text.length()) {\\n            if(text.charAt(i) == \\' \\') {\\n                if(len == i-k)\\n                    ans++;\\n\\n                k = i+1;\\n                len = 0;\\n            }\\n                \\n            else if(table[text.charAt(i) % 97] == 0)\\n                len++;\\n            \\n            i++;\\n        }\\n        \\n        if(len == i-k)\\n            ans++;\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nWith string methods\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {        \\n        char temp[] = brokenLetters.toCharArray();\\n        int ans = 0;\\n        \\n        for(String str : text.split(\" \")) {\\n            boolean flag = false;\\n            \\n            for(int i=0; i<temp.length; ++i) {\\n                if(str.indexOf(temp[i]) >= 0) {\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(!flag)\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int table[] = new int[26];\\n        \\n        for(int i=0; i<brokenLetters.length(); ++i)\\n            table[brokenLetters.charAt(i) % 97]++;\\n        \\n        int len = 0, i = 0, k = 0, ans = 0;\\n        \\n        while(i < text.length()) {\\n            if(text.charAt(i) == \\' \\') {\\n                if(len == i-k)\\n                    ans++;\\n\\n                k = i+1;\\n                len = 0;\\n            }\\n                \\n            else if(table[text.charAt(i) % 97] == 0)\\n                len++;\\n            \\n            i++;\\n        }\\n        \\n        if(len == i-k)\\n            ans++;\\n        \\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {        \\n        char temp[] = brokenLetters.toCharArray();\\n        int ans = 0;\\n        \\n        for(String str : text.split(\" \")) {\\n            boolean flag = false;\\n            \\n            for(int i=0; i<temp.length; ++i) {\\n                if(str.indexOf(temp[i]) >= 0) {\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(!flag)\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431260,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        ls,c=text.split(),0\\n        for i in ls:\\n            for j in brokenLetters:\\n                if j in i:\\n\\t\\t\\t\\t\\tbreak\\n            else:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        ls,c=text.split(),0\\n        for i in ls:\\n            for j in brokenLetters:\\n                if j in i:\\n\\t\\t\\t\\t\\tbreak\\n            else:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406833,
                "title": "java-hash-set-simple-easysolution",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        HashSet<Character>set= new HashSet<>();\\n        for(char c:brokenLetters.toCharArray())\\n            set.add(c);\\n        \\n        text+=\" \";\\n        String[]arr= text.split(\" \");\\n        int res=0;\\n        for(var s:arr)\\n        {\\n            int c=0;\\n            for(var ch:s.toCharArray())\\n            {\\n                if(set.contains(ch))\\n                {c=1;\\n                 break;}\\n            }\\n            if(c==0)\\n                res++;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        HashSet<Character>set= new HashSet<>();\\n        for(char c:brokenLetters.toCharArray())\\n            set.add(c);\\n        \\n        text+=\" \";\\n        String[]arr= text.split(\" \");\\n        int res=0;\\n        for(var s:arr)\\n        {\\n            int c=0;\\n            for(var ch:s.toCharArray())\\n            {\\n                if(set.contains(ch))\\n                {c=1;\\n                 break;}",
                "codeTag": "Java"
            },
            {
                "id": 1399715,
                "title": "java-easy-to-understand",
                "content": "```\\n public int canBeTypedWords(String text, String brokenLetters) {\\n        Set<Character> brokenSet = new HashSet<>();\\n        String[] words = text.split(\" \");\\n        int count = words.length;\\n        \\n        if(brokenLetters.length() == 0) {\\n            return count;\\n        }\\n        \\n        for(char ch: brokenLetters.toCharArray()) {\\n            brokenSet.add(ch);\\n        }\\n        \\n        for(String word: words) {\\n            for(char ch: word.toCharArray()) {\\n                if(brokenSet.contains(ch)) {\\n                    count--;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n\\t\\n\\t\\n\\t\\n\\tTime Complexity - O(m * n) (m is the size of text and n is the size of word with maximum length in text)\\n\\tSpace complexity - O(n) - n is the size of brokenLetters",
                "solutionTags": [],
                "code": "```\\n public int canBeTypedWords(String text, String brokenLetters) {\\n        Set<Character> brokenSet = new HashSet<>();\\n        String[] words = text.split(\" \");\\n        int count = words.length;\\n        \\n        if(brokenLetters.length() == 0) {\\n            return count;\\n        }\\n        \\n        for(char ch: brokenLetters.toCharArray()) {\\n            brokenSet.add(ch);\\n        }\\n        \\n        for(String word: words) {\\n            for(char ch: word.toCharArray()) {\\n                if(brokenSet.contains(ch)) {\\n                    count--;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n\\t\\n\\t\\n\\t\\n\\tTime Complexity - O(m * n) (m is the size of text and n is the size of word with maximum length in text)\\n\\tSpace complexity - O(n) - n is the size of brokenLetters",
                "codeTag": "Unknown"
            },
            {
                "id": 1390945,
                "title": "kotlin-in-one-line",
                "content": "```\\nclass Solution {\\n    fun canBeTypedWords(text: String, brokenLetters: String): Int {\\n        return text.split(\" \").filter { word -> word.none { ch ->  brokenLetters.contains(ch) }}.count()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun canBeTypedWords(text: String, brokenLetters: String): Int {\\n        return text.split(\" \").filter { word -> word.none { ch ->  brokenLetters.contains(ch) }}.count()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381862,
                "title": "javascript-easy-and-faster-than-98-64ms",
                "content": "Let me know if you have any doubts. I try to answer/help.\\n\\nPlease upvote if you liked the solution.\\n```\\nvar canBeTypedWords = function(text, brokenLetters) {\\n  const textArr = text.split(\\' \\');\\n  const brokenLettersArr = [...brokenLetters];\\n  return textArr.filter((e) => {\\n    return brokenLettersArr.every((letter) => !e.includes(letter));\\n  }).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canBeTypedWords = function(text, brokenLetters) {\\n  const textArr = text.split(\\' \\');\\n  const brokenLettersArr = [...brokenLetters];\\n  return textArr.filter((e) => {\\n    return brokenLettersArr.every((letter) => !e.includes(letter));\\n  }).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1378877,
                "title": "python-easy-code-using-set",
                "content": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        result = len(text.split())\\n        set2 = set(brokenLetters)\\n        for i in text.split():\\n            set1 = set(i)\\n            if set1&set2:result -= 1\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        result = len(text.split())\\n        set2 = set(brokenLetters)\\n        for i in text.split():\\n            set1 = set(i)\\n            if set1&set2:result -= 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372781,
                "title": "c-easy-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int words=0;\\n        for(int i=1;i<text.length();i++)\\n        {\\n            if((text[i]==\\' \\'&&text[i-1]!=\\' \\')||(i==(text.length()-1)))\\n            {\\n                words++;\\n            }\\n        }\\n            for(int i=0;i<text.length();i++)\\n            {\\n                int j=0;\\n                while(j<brokenLetters.length())\\n                {\\n                    if(text[i]==brokenLetters[j])\\n                    {\\n                        words--;\\n                        while(text[i]!=\\' \\'&&i<text.length())\\n                            i++;\\n                    }\\n                    j++;\\n                }\\n            }\\n        \\n        return words;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int words=0;\\n        for(int i=1;i<text.length();i++)\\n        {\\n            if((text[i]==\\' \\'&&text[i-1]!=\\' \\')||(i==(text.length()-1)))\\n            {\\n                words++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1361373,
                "title": "cpp-o-n-unordered-sets-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_set<char> b;\\n        for(char c:brokenLetters ){\\n            b.insert(c);\\n        }\\n        int count=0, n=text.size();\\n        int defects=0;\\n        for(int i=0; i<n; i++){\\n            \\n            \\n            if(b.find(text[i])!=b.end()){\\n                defects++;\\n            }\\n            if(text[i]==\\' \\' || i==n-1){\\n                if(defects==0)count++;\\n                defects=0;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_set<char> b;\\n        for(char c:brokenLetters ){\\n            b.insert(c);\\n        }\\n        int count=0, n=text.size();\\n        int defects=0;\\n        for(int i=0; i<n; i++){\\n            \\n            \\n            if(b.find(text[i])!=b.end()){\\n                defects++;\\n            }\\n            if(text[i]==\\' \\' || i==n-1){\\n                if(defects==0)count++;\\n                defects=0;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354007,
                "title": "simple-python-with-for-loop",
                "content": "```\\n\\nclass Solution(object):\\n    def canBeTypedWords(self, text, brokenLetters):\\n        \"\"\"\\n        :type text: str\\n        :type brokenLetters: str\\n        :rtype: int\\n        \"\"\"\\n        res = len(text.split())\\n        \\n        for w in text.split():\\n            for c in brokenLetters:\\n                if c in w:\\n                    res -= 1\\n                    break\\n                \\n        return res \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution(object):\\n    def canBeTypedWords(self, text, brokenLetters):\\n        \"\"\"\\n        :type text: str\\n        :type brokenLetters: str\\n        :rtype: int\\n        \"\"\"\\n        res = len(text.split())\\n        \\n        for w in text.split():\\n            for c in brokenLetters:\\n                if c in w:\\n                    res -= 1\\n                    break\\n                \\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351411,
                "title": "shrt",
                "content": "```\\n    public int CanBeTypedWords(string text, string brokenLetters)\\n        => text.Split(\\' \\').Count(w => !w.Any(brokenLetters.Contains));\\n```",
                "solutionTags": [],
                "code": "```\\n    public int CanBeTypedWords(string text, string brokenLetters)\\n        => text.Split(\\' \\').Count(w => !w.Any(brokenLetters.Contains));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1347802,
                "title": "javascript-intuitive-100-faster-60-ms",
                "content": "Runtime: 60 ms, faster than 100.00% of JavaScript online submissions for Maximum Number of Words You Can Type.\\nMemory Usage: 40.5 MB, less than 100.00% of JavaScript online submissions for Maximum Number of Words You Can Type.\\n\\n```\\n// Break sentence into words and filter out words that pass the test\\nconst canBeTypedWords = (text, broken) =>\\n\\ttext.split(\\' \\').filter((word) => isValidWord(word, broken)).length;\\n\\nconst isValidWord = (word, broken) =>\\n\\t[...word].some((char) => broken.includes(char)) === true;\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// Break sentence into words and filter out words that pass the test\\nconst canBeTypedWords = (text, broken) =>\\n\\ttext.split(\\' \\').filter((word) => isValidWord(word, broken)).length;\\n\\nconst isValidWord = (word, broken) =>\\n\\t[...word].some((char) => broken.includes(char)) === true;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1347592,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        map<char, int> brokenmp;\\n        for(auto i: brokenLetters){\\n            brokenmp[i] = 1;\\n        }\\n        int counter = 0;\\n        string space = \"\";\\n        for(int i=0; i<text.size(); i++){\\n           if(brokenmp[text[i]] == 1 & text[i] != \\' \\' & space != \"broken\"){\\n               space = \"broken\";\\n           }else if(text[i] == \\' \\'){\\n               if(space != \"broken\"){\\n                   counter += 1;\\n               }\\n               space = \"\";\\n           } \\n           if(i+1==text.size() & space != \"broken\"){\\n               counter += 1;\\n           } \\n        }\\n        return counter;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        map<char, int> brokenmp;\\n        for(auto i: brokenLetters){\\n            brokenmp[i] = 1;\\n        }\\n        int counter = 0;\\n        string space = \"\";\\n        for(int i=0; i<text.size(); i++){\\n           if(brokenmp[text[i]] == 1 & text[i] != \\' \\' & space != \"broken\"){\\n               space = \"broken\";\\n           }else if(text[i] == \\' \\'){\\n               if(space != \"broken\"){\\n                   counter += 1;\\n               }\\n               space = \"\";\\n           } \\n           if(i+1==text.size() & space != \"broken\"){\\n               counter += 1;\\n           } \\n        }\\n        return counter;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347412,
                "title": "python3-two-lines-using-set",
                "content": "```python\\ndef canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        brokenLetters = set(brokenLetters)\\n        return sum(len(brokenLetters.intersection(t)) == 0 for t in text.split())\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        brokenLetters = set(brokenLetters)\\n        return sum(len(brokenLetters.intersection(t)) == 0 for t in text.split())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1346394,
                "title": "why-software-guys-are-too-cheap-to-afford-a-working-keyboard",
                "content": "```scala\\n  def canBeTypedWords(text: String, bl: String): Int = {\\n\\n    val set = bl.toCharArray().toSet\\n    import scala.util.control.Breaks._\\n    text.split(\" \").count(x => {\\n      var ok = true \\n      breakable{\\n        x.toCharArray().foreach(c=>{\\n          if(set contains c){\\n            ok = false \\n            break()\\n          }\\n        })\\n        \\n      }\\n      ok\\n    })\\n  }\\n```",
                "solutionTags": [],
                "code": "```scala\\n  def canBeTypedWords(text: String, bl: String): Int = {\\n\\n    val set = bl.toCharArray().toSet\\n    import scala.util.control.Breaks._\\n    text.split(\" \").count(x => {\\n      var ok = true \\n      breakable{\\n        x.toCharArray().foreach(c=>{\\n          if(set contains c){\\n            ok = false \\n            break()\\n          }\\n        })\\n        \\n      }\\n      ok\\n    })\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1346066,
                "title": "python-solution-with-any",
                "content": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        l= list(brokenLetters)\\n        wrds= text.strip().split()\\n        c=0\\n        for i in wrds:\\n            if any(item in l for item in i):\\n                pass\\n            else:\\n                c=c+1\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        l= list(brokenLetters)\\n        wrds= text.strip().split()\\n        c=0\\n        for i in wrds:\\n            if any(item in l for item in i):\\n                pass\\n            else:\\n                c=c+1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345844,
                "title": "java-solution-using-indexoff-with-comments",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String s[]=text.split(\" \");   //get words from str \\n        int count=0,fin=0;        \\n     for(int i=0;i<s.length;i++)  // eg take hello\\n    {     count=0;\\n        for(char c1:brokenLetters.toCharArray())  //check each character from borkenLetter \"ad\" taking  char \\'a\\' first\\n          {     \\n             if(s[i].indexOf(c1)==-1)  //if char \\'a\\' not found in hello\\n              count++;                  // increase count\\n           }\\n         if(count==brokenLetters.length()) \\n//main condition check if both the chars \\'a\\' && \\'d\\' are not present in hello then increease fin++;\\n             fin++;\\n        }\\n        return fin;\\n    }\\n}\\n```\\n**Hope It Helps.**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String s[]=text.split(\" \");   //get words from str \\n        int count=0,fin=0;        \\n     for(int i=0;i<s.length;i++)  // eg take hello\\n    {     count=0;\\n        for(char c1:brokenLetters.toCharArray())  //check each character from borkenLetter \"ad\" taking  char \\'a\\' first\\n          {     \\n             if(s[i].indexOf(c1)==-1)  //if char \\'a\\' not found in hello\\n              count++;                  // increase count\\n           }\\n         if(count==brokenLetters.length()) \\n//main condition check if both the chars \\'a\\' && \\'d\\' are not present in hello then increease fin++;\\n             fin++;\\n        }\\n        return fin;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345677,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String b) {\\n        boolean a[] = new boolean[26];\\n        for(char x:b.toCharArray()){a[x-\\'a\\']=true;}\\n        text+=\" \";\\n        boolean should=true;\\n        int res=0;\\n        for(char x:text.toCharArray()){\\n            if(x==\\' \\'){\\n                if(should){res++;}\\n                should=true;\\n            }\\n            else{\\n                if(a[x-\\'a\\']){should=false;}\\n            }\\n        }\\n        return res;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String b) {\\n        boolean a[] = new boolean[26];\\n        for(char x:b.toCharArray()){a[x-\\'a\\']=true;}\\n        text+=\" \";\\n        boolean should=true;\\n        int res=0;\\n        for(char x:text.toCharArray()){\\n            if(x==\\' \\'){\\n                if(should){res++;}\\n                should=true;\\n            }\\n            else{\\n                if(a[x-\\'a\\']){should=false;}\\n            }\\n        }\\n        return res;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345478,
                "title": "unordered-map-o-n-c",
                "content": "int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_map<char,int> mp;\\n        int count=0;\\n        for(int i=0;i<brokenLetters.size();i++)\\n            mp[brokenLetters[i]]++;\\n        bool ok=true;\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(text[i]==\\' \\'){\\n                if(ok)\\n                count++;\\n                else\\n                ok=true;\\n            }\\n            else{\\n                if(mp.find(text[i])!=mp.end())\\n                    ok=false;\\n            }\\n        }\\n        if(ok)\\n            count++;\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "int canBeTypedWords(string text, string brokenLetters) {\\n        unordered_map<char,int> mp;\\n        int count=0;\\n        for(int i=0;i<brokenLetters.size();i++)\\n            mp[brokenLetters[i]]++;\\n        bool ok=true;\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(text[i]==\\' \\'){\\n                if(ok)\\n                count++;\\n                else\\n                ok=true;\\n            }\\n            else{\\n                if(mp.find(text[i])!=mp.end())\\n                    ok=false;\\n            }\\n        }\\n        if(ok)\\n            count++;\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1345272,
                "title": "java-o-1-space",
                "content": "```\\nclass Solution {\\n\\tpublic int canBeTypedWords(String text, String brokenLetters) {\\n\\t\\tString words[] = text.split(\" \");\\n\\t\\tchar frequency[] = new char[26];\\n\\t\\tint count = 0;\\n\\n\\t\\tfor (char c: brokenLetters.toCharArray()) {\\n\\t\\t\\tfrequency[c - \\'a\\']++;\\n\\t\\t}\\n\\n\\t\\tfor (String word: words) {\\n\\t\\t\\tboolean flag = false;\\n\\n\\t\\t\\tfor (char c: word.toCharArray()) {\\n\\t\\t\\t\\tif (frequency[c - \\'a\\'] == 1) {\\n\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (!flag) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic int canBeTypedWords(String text, String brokenLetters) {\\n\\t\\tString words[] = text.split(\" \");\\n\\t\\tchar frequency[] = new char[26];\\n\\t\\tint count = 0;\\n\\n\\t\\tfor (char c: brokenLetters.toCharArray()) {\\n\\t\\t\\tfrequency[c - \\'a\\']++;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1345034,
                "title": "easy-and-best-solution-c-less-memory-used",
                "content": "```\\n//PLEASE UPVOTE IF YOU LIKE IT\\n\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int len=text.length();\\n        int len1=brokenLetters.length();\\n        vector<int> mp(26,0);\\n        for(int i=0;i<len1;i++)\\n        {\\n            mp[brokenLetters[i]-\\'a\\']=1;      \\n        }\\n        int count=0;\\n        int flag=1;\\n        for(int i=0;i<len;i++)\\n        {\\n            flag=1;\\n            char ch=text[i];\\n            while(ch!=\\' \\' and i<len)\\n            {\\n                 \\n                if(mp[text[i]-\\'a\\']==1)\\n                {\\n                   flag=0; \\n                }\\n                 i++; \\n                ch=text[i];\\n            }\\n            if(flag==1)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//PLEASE UPVOTE IF YOU LIKE IT\\n\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int len=text.length();\\n        int len1=brokenLetters.length();\\n        vector<int> mp(26,0);\\n        for(int i=0;i<len1;i++)\\n        {\\n            mp[brokenLetters[i]-\\'a\\']=1;      \\n        }\\n        int count=0;\\n        int flag=1;\\n        for(int i=0;i<len;i++)\\n        {\\n            flag=1;\\n            char ch=text[i];\\n            while(ch!=\\' \\' and i<len)\\n            {\\n                 \\n                if(mp[text[i]-\\'a\\']==1)\\n                {\\n                   flag=0; \\n                }\\n                 i++; \\n                ch=text[i];\\n            }\\n            if(flag==1)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344993,
                "title": "java-brute-force-approach",
                "content": "```\\npublic int canBeTypedWords(String text, String brokenLetters) {\\n\\t// split into words based on whitespaces (question specifies using just 1 whitespace to mark out words)\\n\\tString[] words = text.split(\" \");\\n\\tint c = words.length;\\n\\tfor (String word : words) {\\n\\t\\tfor (char curr : brokenLetters.toCharArray()) {\\n\\t\\t// doesn\\'t contain the word, decrement and stop iterating\\n\\t\\t\\tif (word.contains(curr + \"\")) {\\n\\t\\t\\t\\tc--;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn c;\\n    }\\n```\\nA direct approach that I took in midst of attempting the competition. This may not be the optimal approach, just an ordinary 1st attempt instinctive solution.\\n\\nOptimised Brute-force, using a hashset to record all broken letters\\n```\\npublic int canBeTypedWords(String text, String brokenLetters) {\\n        // split into words based on whitespaces (question specifies using just 1 whitespace to mark out words)\\n        String[] words = text.split(\" \");\\n        int c = words.length;\\n\\t\\t// cache all broken letters \\n        HashSet<Character> letters = new HashSet<>();\\n        for (int i = 0; i < brokenLetters.length(); i++) letters.add(brokenLetters.charAt(i));\\n\\t\\t// Iterate, technically should be O(n) runtime\\n        for (String word : words) {\\n            for (int i = 0; i < word.length(); i++) {\\n                if (letters.contains(word.charAt(i))){\\n                    c--;\\n                    break;\\n                }\\n            }\\n        }\\n        return c;\\n}\\n```\\nRuntime: O(n), Space: O(n)",
                "solutionTags": [],
                "code": "```\\npublic int canBeTypedWords(String text, String brokenLetters) {\\n\\t// split into words based on whitespaces (question specifies using just 1 whitespace to mark out words)\\n\\tString[] words = text.split(\" \");\\n\\tint c = words.length;\\n\\tfor (String word : words) {\\n\\t\\tfor (char curr : brokenLetters.toCharArray()) {\\n\\t\\t// doesn\\'t contain the word, decrement and stop iterating\\n\\t\\t\\tif (word.contains(curr + \"\")) {\\n\\t\\t\\t\\tc--;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn c;\\n    }\\n```\n```\\npublic int canBeTypedWords(String text, String brokenLetters) {\\n        // split into words based on whitespaces (question specifies using just 1 whitespace to mark out words)\\n        String[] words = text.split(\" \");\\n        int c = words.length;\\n\\t\\t// cache all broken letters \\n        HashSet<Character> letters = new HashSet<>();\\n        for (int i = 0; i < brokenLetters.length(); i++) letters.add(brokenLetters.charAt(i));\\n\\t\\t// Iterate, technically should be O(n) runtime\\n        for (String word : words) {\\n            for (int i = 0; i < word.length(); i++) {\\n                if (letters.contains(word.charAt(i))){\\n                    c--;\\n                    break;\\n                }\\n            }\\n        }\\n        return c;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1344945,
                "title": "java-easy-self-explained",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String str[]=text.split(\" \");\\n        int count=0;\\n        for(String a:str){\\n            for(Character b:brokenLetters.toCharArray()){\\n                if(a.indexOf(b)!=-1){\\n                    count++;\\n                    break;\\n                }\\n         return str.length-count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String str[]=text.split(\" \");\\n        int count=0;\\n        for(String a:str){\\n            for(Character b:brokenLetters.toCharArray()){\\n                if(a.indexOf(b)!=-1){\\n                    count++;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1344942,
                "title": "using-stringstream-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string br) {\\n        set<char>st;\\n        for(auto a:br)\\n        {\\n            st.insert(a);\\n        }\\n        \\n        stringstream s(text);\\n        string word;  \\n        int count = 0;\\n        while (s >> word)\\n        {\\n            bool flag=0;\\n            for(auto a:word)\\n            {\\n                if(st.find(a)!=st.end())\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)count++;\\n        }\\n        return count;    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string br) {\\n        set<char>st;\\n        for(auto a:br)\\n        {\\n            st.insert(a);\\n        }\\n        \\n        stringstream s(text);\\n        string word;  \\n        int count = 0;\\n        while (s >> word)\\n        {\\n            bool flag=0;\\n            for(auto a:word)\\n            {\\n                if(st.find(a)!=st.end())\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)count++;\\n        }\\n        return count;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344904,
                "title": "java-solution-using-hashset",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 0;\\n        String[] words = text.split(\"\\\\\\\\s+\");\\n        HashSet<Character> set = new HashSet<>();\\n        \\n        for(int i = 0; i < brokenLetters.length(); i++){\\n            set.add(brokenLetters.charAt(i));\\n        }\\n        \\n        outerloop:\\n        for(int i = 0; i < words.length; i++){\\n            for(int j = 0; j < words[i].length(); j++){\\n                if(set.contains(words[i].charAt(j))){\\n                    continue outerloop;\\n                }\\n            }\\n            count++;\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 0;\\n        String[] words = text.split(\"\\\\\\\\s+\");\\n        HashSet<Character> set = new HashSet<>();\\n        \\n        for(int i = 0; i < brokenLetters.length(); i++){\\n            set.add(brokenLetters.charAt(i));\\n        }\\n        \\n        outerloop:\\n        for(int i = 0; i < words.length; i++){\\n            for(int j = 0; j < words[i].length(); j++){\\n                if(set.contains(words[i].charAt(j))){\\n                    continue outerloop;\\n                }\\n            }\\n            count++;\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344901,
                "title": "python-one-liner",
                "content": "```python\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return sum(sum([l in set(brokenLetters) for l in word]) == 0 for word in text.split(\\' \\'))\\n```\\n\\n- Couldn\\'t solve problem 3 in the contest so I came up with this",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return sum(sum([l in set(brokenLetters) for l in word]) == 0 for word in text.split(\\' \\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083631,
                "title": "c-100-faster-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\tint canBeTypedWords(string text, string brokenLetters) {\\n\\n\\t\\tint hash[26] = {0};\\n\\n\\t\\tfor (int i = 0; i < brokenLetters.size(); ++i)\\n\\t\\t{\\n\\t\\t\\thash[brokenLetters[i] - 97] = 1;\\n\\t\\t}\\n\\n\\n\\t\\tint index = 0;\\n\\n\\t\\tint ans = 0;\\n\\n\\t\\tint inputSize = text.size();\\n\\n\\t\\twhile (index < inputSize) {\\n\\n\\t\\t\\tif (text[index] == \\' \\') {\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\n\\t\\t\\telse if (hash[text[index] - 97]) {\\n\\t\\t\\t\\twhile (text[index] != \\' \\' && index < inputSize) {\\n\\t\\t\\t\\t\\tindex++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (index == inputSize) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\telse if (index == inputSize - 1) {\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tindex++;\\n\\n\\t\\t}\\n\\t\\treturn ans;\\n\\n\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\tint canBeTypedWords(string text, string brokenLetters) {\\n\\n\\t\\tint hash[26] = {0};\\n\\n\\t\\tfor (int i = 0; i < brokenLetters.size(); ++i)\\n\\t\\t{\\n\\t\\t\\thash[brokenLetters[i] - 97] = 1;\\n\\t\\t}\\n\\n\\n\\t\\tint index = 0;\\n\\n\\t\\tint ans = 0;\\n\\n\\t\\tint inputSize = text.size();\\n\\n\\t\\twhile (index < inputSize) {\\n\\n\\t\\t\\tif (text[index] == \\' \\') {\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\n\\t\\t\\telse if (hash[text[index] - 97]) {\\n\\t\\t\\t\\twhile (text[index] != \\' \\' && index < inputSize) {\\n\\t\\t\\t\\t\\tindex++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (index == inputSize) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\telse if (index == inputSize - 1) {\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tindex++;\\n\\n\\t\\t}\\n\\t\\treturn ans;\\n\\n\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080611,
                "title": "easy-cpp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string s, string bb) {\\n        int cnt=0,i=0,n=s.size();;\\n        unordered_map<char,int>mp;\\n        for(auto i:bb) mp[i]++;\\n        while(i<n){\\n            int flag=0;\\n            while(s[i]!=\\' \\' and i<n){\\n                if(mp.find(s[i])!=mp.end()) flag=1;\\n                i++;\\n            }\\n            i++;\\n            if(flag==0) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string s, string bb) {\\n        int cnt=0,i=0,n=s.size();;\\n        unordered_map<char,int>mp;\\n        for(auto i:bb) mp[i]++;\\n        while(i<n){\\n            int flag=0;\\n            while(s[i]!=\\' \\' and i<n){\\n                if(mp.find(s[i])!=mp.end()) flag=1;\\n                i++;\\n            }\\n            i++;\\n            if(flag==0) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079350,
                "title": "check-each-individual-word-for-the-presence-of-broken-letters",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String[] str=text.split(\" \");\\n        int count=0;\\n        for(int i=0;i<str.length;i++)\\n        {\\n            count++;\\n            for(int j=0;j<brokenLetters.length();j++)\\n            {\\n                if(str[i].indexOf(brokenLetters.charAt(j))!=-1)\\n                {\\n                    count--;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String[] str=text.split(\" \");\\n        int count=0;\\n        for(int i=0;i<str.length;i++)\\n        {\\n            count++;\\n            for(int j=0;j<brokenLetters.length();j++)\\n            {\\n                if(str[i].indexOf(brokenLetters.charAt(j))!=-1)\\n                {\\n                    count--;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073677,
                "title": "minimum-memory-and-speedy-with-set-on-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        res = 0\\n        l = text.split(\\' \\')\\n        br = set(brokenLetters)\\n        for i in l:\\n            s_i = set(i)\\n            if len(s_i - br) == len(s_i):\\n                res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        res = 0\\n        l = text.split(\\' \\')\\n        br = set(brokenLetters)\\n        for i in l:\\n            s_i = set(i)\\n            if len(s_i - br) == len(s_i):\\n                res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070193,
                "title": "sample-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code aims to count the number of words in a given text that can be typed using a keyboard, given a set of broken letters. A word is considered typable if it does not contain any of the broken letters.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Split the input text into an array of words using the space character as the delimiter. Store the array of words in the strs variable.\\n\\n2. Convert the brokenLetters string into a character array chars.\\n\\n3. Initialize a variable total to store the total number of typable words. Set total initially to the total number of words in the strs array.\\n\\n4. Iterate through each word str in the strs array.\\n\\n5. For each word, iterate through each character ch in the chars array.\\n\\n6. Check if the character ch exists in the word str using the indexOf method. If it exists (i.e., str.indexOf(ch) != -1), it means the word contains a broken letter. In this case, decrement the total count and break out of the inner loop.\\n\\n7. After processing all words, return the final value of total, which represents the count of words that can be typed without using any broken letters.\\n# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwhere **n** is the number of words in the input text (length of strs), and **m** is the average length of a word.\\n- Space complexity: O(m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwhere **m** is the length of the brokenLetters string.\\n# Code\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        var strs = text.split(\" \");\\n        var chars = brokenLetters.toCharArray();\\n        var total = strs.length;\\n\\n        for (var str : strs){\\n            for (var ch : chars){\\n                if (str.indexOf(ch) != -1){\\n                    total--;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return total;\\n    }\\n}\\n```\\n![Frame 76.png](https://assets.leetcode.com/users/images/1d20c9ee-8051-42a7-949c-86dcc074ca85_1695245121.4193192.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        var strs = text.split(\" \");\\n        var chars = brokenLetters.toCharArray();\\n        var total = strs.length;\\n\\n        for (var str : strs){\\n            for (var ch : chars){\\n                if (str.indexOf(ch) != -1){\\n                    total--;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070101,
                "title": "beautiful-solution-using-stringstream-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int count=0;\\n        int map[26]={0};\\n        for(const auto& x:brokenLetters){\\n            map[x-\\'a\\']++;\\n        }\\n        stringstream s(text);\\n        string word;\\n        while(s>>word){\\n            bool isCan=true;\\n            for(char letter:word){\\n                if(map[letter-\\'a\\']>0){\\n                    isCan=false;\\n                    break;\\n                }\\n            }\\n            if(isCan){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int count=0;\\n        int map[26]={0};\\n        for(const auto& x:brokenLetters){\\n            map[x-\\'a\\']++;\\n        }\\n        stringstream s(text);\\n        string word;\\n        while(s>>word){\\n            bool isCan=true;\\n            for(char letter:word){\\n                if(map[letter-\\'a\\']>0){\\n                    isCan=false;\\n                    break;\\n                }\\n            }\\n            if(isCan){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060693,
                "title": "a-little-complex-but-fast-with-for-3x-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 43ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 42.24MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} text\\n * @param {string} brokenLetters\\n * @return {number}\\n */\\nvar canBeTypedWords = function(text, brokenLetters) {\\n    let Arr = [];\\n    let counter = 0;\\n    let condition = false;\\n    Arr = text.split(\" \");\\n    for(let i = 0;i < Arr.length;i++){\\n        for(let k = 0;k < Arr[i].length;k++){\\n            for(let j = 0;j < brokenLetters.length;j++){\\n                if(Arr[i][k] == brokenLetters[j]){\\n                    counter++;\\n                    condition = true;\\n                    break;\\n                }\\n            }\\n            if(condition == true){\\n                condition = false;\\n                break;\\n            }\\n        }\\n    }\\n    return Arr.length - counter;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} text\\n * @param {string} brokenLetters\\n * @return {number}\\n */\\nvar canBeTypedWords = function(text, brokenLetters) {\\n    let Arr = [];\\n    let counter = 0;\\n    let condition = false;\\n    Arr = text.split(\" \");\\n    for(let i = 0;i < Arr.length;i++){\\n        for(let k = 0;k < Arr[i].length;k++){\\n            for(let j = 0;j < brokenLetters.length;j++){\\n                if(Arr[i][k] == brokenLetters[j]){\\n                    counter++;\\n                    condition = true;\\n                    break;\\n                }\\n            }\\n            if(condition == true){\\n                condition = false;\\n                break;\\n            }\\n        }\\n    }\\n    return Arr.length - counter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057620,
                "title": "java-intuitive-with-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        Set<Character> brokenSet = new HashSet();\\n        for (int i = 0; i < brokenLetters.length(); i++) {\\n            brokenSet.add(brokenLetters.charAt(i));\\n        }\\n\\n        String[] strSplit = text.split(\" \");\\n        int count = strSplit.length;\\n        for (String s : strSplit) {\\n            for (int i = 0; i < s.length(); i++) {\\n                if (brokenSet.contains(s.charAt(i))) {\\n                    count--;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        Set<Character> brokenSet = new HashSet();\\n        for (int i = 0; i < brokenLetters.length(); i++) {\\n            brokenSet.add(brokenLetters.charAt(i));\\n        }\\n\\n        String[] strSplit = text.split(\" \");\\n        int count = strSplit.length;\\n        for (String s : strSplit) {\\n            for (int i = 0; i < s.length(); i++) {\\n                if (brokenSet.contains(s.charAt(i))) {\\n                    count--;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056624,
                "title": "python-one-liner-beats-92-35-runtime-100-00-memory",
                "content": "# Python3 Code\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return sum(1 for i in text.split(\\' \\') if not any(j in i for j in brokenLetters))\\n```\\n\\n![Screenshot 2023-09-17 222614.png](https://assets.leetcode.com/users/images/2e3477dc-502f-4eba-b318-9ac589ded0ed_1694969808.1623027.png)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return sum(1 for i in text.split(\\' \\') if not any(j in i for j in brokenLetters))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054256,
                "title": "beats-91-38-of-users-with-python",
                "content": "# Intuition\\n![Screen Shot 2566-09-17 at 10.10.41.png](https://assets.leetcode.com/users/images/1d6b8eda-02c1-4db9-862d-c2dca8578709_1694927553.975569.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def canBeTypedWords(self, text, brokenLetters):\\n        cound = 0\\n        for i in text.split():\\n            soft_cound = 0\\n            for j in brokenLetters:\\n                if j not in i:\\n                    soft_cound+=1\\n            if len(brokenLetters) == soft_cound:\\n                cound+=1\\n        return cound\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def canBeTypedWords(self, text, brokenLetters):\\n        cound = 0\\n        for i in text.split():\\n            soft_cound = 0\\n            for j in brokenLetters:\\n                if j not in i:\\n                    soft_cound+=1\\n            if len(brokenLetters) == soft_cound:\\n                cound+=1\\n        return cound\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052847,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) \\n    {\\n        String[] arr=text.split(\" \");\\n        int n=arr.length;\\n        int total=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int count=0;\\n            HashMap<Character,Integer> map=new HashMap<>();\\n            int m=arr[i].length();\\n            String s=arr[i];\\n            for(int j=0;j<m;j++)\\n            {\\n                map.put(s.charAt(j),map.getOrDefault(s.charAt(j),0)+1);\\n            }\\n            for(int k=0;k<brokenLetters.length();k++)\\n            {\\n                if(!map.containsKey(brokenLetters.charAt(k)))\\n                {\\n                   count++; \\n                }\\n            }\\n            if(count==brokenLetters.length())\\n            {\\n                total++;\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) \\n    {\\n        String[] arr=text.split(\" \");\\n        int n=arr.length;\\n        int total=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int count=0;\\n            HashMap<Character,Integer> map=new HashMap<>();\\n            int m=arr[i].length();\\n            String s=arr[i];\\n            for(int j=0;j<m;j++)\\n            {\\n                map.put(s.charAt(j),map.getOrDefault(s.charAt(j),0)+1);\\n            }\\n            for(int k=0;k<brokenLetters.length();k++)\\n            {\\n                if(!map.containsKey(brokenLetters.charAt(k)))\\n                {\\n                   count++; \\n                }\\n            }\\n            if(count==brokenLetters.length())\\n            {\\n                total++;\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048921,
                "title": "multiple-approach-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc canBeTypedWords(text string, brokenLetters string) int {\\n    // chekc if brokerLetters sub string present in the text string\\n    // divide text into multiple sub array based on delimeter\\n    // newText := strings.Split(text, \" \")\\n    // count:=0\\n    // for _,word := range newText {\\n    //     // found := false\\n    //     if strings.ContainsAny(brokenLetters, word) {\\n    //         count++\\n    //     }\\n    //     // for _, char := range word {\\n    //     //     for _, bl := range brokenLetters {\\n    //     //         if char == bl {\\n    //     //             count++\\n    //     //             found = true\\n    //     //             break\\n    //     //         }\\n    //     //     }\\n    //     //     if found == true {\\n    //     //         break\\n    //     //     }\\n    //     // }\\n    // }\\n    // return len(newText) - count\\n\\n\\tbrokenMap := make(map[string]bool)\\n\\tfor _, v := range brokenLetters {\\n\\t\\tif _, ok := brokenMap[fmt.Sprintf(\"%c\", v)]; !ok {\\n\\t\\t\\tbrokenMap[fmt.Sprintf(\"%c\", v)] = true\\n\\t\\t}\\n\\t}\\n\\n\\tcount := 0\\n\\tallcount := 1\\n\\tvar alreadyProcessed = false\\n\\tfor i := 0; i < len(text); i++ {\\n\\t\\t// skip first iteration\\n\\t\\tif string(text[i]) == \" \" {\\n\\t\\t\\tallcount++\\n\\t\\t\\talreadyProcessed = false\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif alreadyProcessed == false {\\n\\t\\t\\tif _, ok := brokenMap[string(text[i])]; ok {\\n\\t\\t\\t\\talreadyProcessed = true\\n\\t\\t\\t\\tcount++\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t}\\n\\treturn allcount - count\\n\\n\\n    // prevIndex := -1\\n    // var found bool\\n    // for _,v := range brokenLetters {\\n    //     for index,b := range newText {\\n    //         if prevIndex == index {\\n    //             continue\\n    //         }\\n    //         // // if v belongs to text then we can not type\\n    //         for _,p := range b {\\n    //             if v == p {\\n    //                 count++\\n    //                 prevIndex = index\\n    //                 found = true\\n    //                 break\\n    //             }\\n    //         }\\n    //         if found == true {\\n    //             break\\n    //         }\\n    //     }\\n    // }\\n    // if (len(newText) - count) <0 {\\n    //     return 0\\n    // }\\n    // return len(newText) - count\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc canBeTypedWords(text string, brokenLetters string) int {\\n    // chekc if brokerLetters sub string present in the text string\\n    // divide text into multiple sub array based on delimeter\\n    // newText := strings.Split(text, \" \")\\n    // count:=0\\n    // for _,word := range newText {\\n    //     // found := false\\n    //     if strings.ContainsAny(brokenLetters, word) {\\n    //         count++\\n    //     }\\n    //     // for _, char := range word {\\n    //     //     for _, bl := range brokenLetters {\\n    //     //         if char == bl {\\n    //     //             count++\\n    //     //             found = true\\n    //     //             break\\n    //     //         }\\n    //     //     }\\n    //     //     if found == true {\\n    //     //         break\\n    //     //     }\\n    //     // }\\n    // }\\n    // return len(newText) - count\\n\\n\\tbrokenMap := make(map[string]bool)\\n\\tfor _, v := range brokenLetters {\\n\\t\\tif _, ok := brokenMap[fmt.Sprintf(\"%c\", v)]; !ok {\\n\\t\\t\\tbrokenMap[fmt.Sprintf(\"%c\", v)] = true\\n\\t\\t}\\n\\t}\\n\\n\\tcount := 0\\n\\tallcount := 1\\n\\tvar alreadyProcessed = false\\n\\tfor i := 0; i < len(text); i++ {\\n\\t\\t// skip first iteration\\n\\t\\tif string(text[i]) == \" \" {\\n\\t\\t\\tallcount++\\n\\t\\t\\talreadyProcessed = false\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif alreadyProcessed == false {\\n\\t\\t\\tif _, ok := brokenMap[string(text[i])]; ok {\\n\\t\\t\\t\\talreadyProcessed = true\\n\\t\\t\\t\\tcount++\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t}\\n\\treturn allcount - count\\n\\n\\n    // prevIndex := -1\\n    // var found bool\\n    // for _,v := range brokenLetters {\\n    //     for index,b := range newText {\\n    //         if prevIndex == index {\\n    //             continue\\n    //         }\\n    //         // // if v belongs to text then we can not type\\n    //         for _,p := range b {\\n    //             if v == p {\\n    //                 count++\\n    //                 prevIndex = index\\n    //                 found = true\\n    //                 break\\n    //             }\\n    //         }\\n    //         if found == true {\\n    //             break\\n    //         }\\n    //     }\\n    // }\\n    // if (len(newText) - count) <0 {\\n    //     return 0\\n    // }\\n    // return len(newText) - count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047816,
                "title": "89-runtime-97-memory-without-set",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/92f1b25a-d6dc-45e1-b736-71ee360b103f_1694782201.0270524.png)\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        counter: int = 0\\n\\n        for word in text.split():\\n            for char in word:\\n                if char in brokenLetters:\\n                    break\\n            else:\\n                counter += 1\\n\\n        return counter\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        counter: int = 0\\n\\n        for word in text.split():\\n            for char in word:\\n                if char in brokenLetters:\\n                    break\\n            else:\\n                counter += 1\\n\\n        return counter\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046553,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} text\\n * @param {string} brokenLetters\\n * @return {number}\\n */\\nvar canBeTypedWords = function(text, brokenLetters) {\\n  let count=0;\\n  text=text.split(\" \");\\n  const len=text.length;\\n  for(let i=0;i<len;i++){\\n    inner:for(let j=0;j<brokenLetters.length;j++){\\n      if(text[i].includes(brokenLetters[j])){\\n         count++;\\n         break inner;\\n      }\\n    }\\n  }\\n  return len-count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} text\\n * @param {string} brokenLetters\\n * @return {number}\\n */\\nvar canBeTypedWords = function(text, brokenLetters) {\\n  let count=0;\\n  text=text.split(\" \");\\n  const len=text.length;\\n  for(let i=0;i<len;i++){\\n    inner:for(let j=0;j<brokenLetters.length;j++){\\n      if(text[i].includes(brokenLetters[j])){\\n         count++;\\n         break inner;\\n      }\\n    }\\n  }\\n  return len-count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4039511,
                "title": "python-solution-using-hashmap",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        text = text.split()\\n        size = len(text)\\n        broken_map = Counter(brokenLetters)\\n        hash_map = Counter(text)\\n\\n\\n        for word in text:\\n            broken = False\\n            for c in word:\\n                if c in broken_map:\\n                    broken = True\\n                    break\\n\\n            if broken:\\n                size -= 1\\n        return size\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        text = text.split()\\n        size = len(text)\\n        broken_map = Counter(brokenLetters)\\n        hash_map = Counter(text)\\n\\n\\n        for word in text:\\n            broken = False\\n            for c in word:\\n                if c in broken_map:\\n                    broken = True\\n                    break\\n\\n            if broken:\\n                size -= 1\\n        return size\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029958,
                "title": "java-less-optimize-solution-90-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n2) --> Worst Case\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(text.length())\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    boolean check(String str, String s){\\n        Set<Character> set = new HashSet<>();\\n        for(int i=0; i<s.length(); i++) set.add(s.charAt(i));\\n\\n        for(int i=0; i<str.length(); i++){\\n            if(set.contains(str.charAt(i))) return false;\\n        }\\n        return true;\\n    }\\n\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String [] arr = text.split(\" \");\\n\\n        int count=0;\\n        for(int i=0; i<arr.length; i++){\\n            if(check(arr[i], brokenLetters)){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    boolean check(String str, String s){\\n        Set<Character> set = new HashSet<>();\\n        for(int i=0; i<s.length(); i++) set.add(s.charAt(i));\\n\\n        for(int i=0; i<str.length(); i++){\\n            if(set.contains(str.charAt(i))) return false;\\n        }\\n        return true;\\n    }\\n\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String [] arr = text.split(\" \");\\n\\n        int count=0;\\n        for(int i=0; i<arr.length; i++){\\n            if(check(arr[i], brokenLetters)){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022411,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 0;\\n        String[] arr = text.split(\" \");\\n        \\n        for(String str : arr) {\\n            boolean contains = false;\\n            for(int i = 0; i < str.length(); i++) {\\n                if(brokenLetters.contains(String.valueOf(str.charAt(i)))) {\\n                    contains = true;\\n                    break;\\n                }\\n            }\\n            if(!contains) count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        int count = 0;\\n        String[] arr = text.split(\" \");\\n        \\n        for(String str : arr) {\\n            boolean contains = false;\\n            for(int i = 0; i < str.length(); i++) {\\n                if(brokenLetters.contains(String.valueOf(str.charAt(i)))) {\\n                    contains = true;\\n                    break;\\n                }\\n            }\\n            if(!contains) count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021995,
                "title": "solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        c=0\\n        l=text.split()\\n        f=1\\n        for i in l:\\n            for j in i:\\n                if j in brokenLetters:\\n                    f=0\\n                    break\\n            if(f):\\n                c+=1\\n            f=1\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        c=0\\n        l=text.split()\\n        f=1\\n        for i in l:\\n            for j in i:\\n                if j in brokenLetters:\\n                    f=0\\n                    break\\n            if(f):\\n                c+=1\\n            f=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020077,
                "title": "the-fastest-in-dart",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n * m)\\n- Space complexity:\\nO(n * m)\\n# Code\\n```\\nclass Solution {\\n  int canBeTypedWords(String text, String brokenLetters) {\\n  int count=0;\\n  List<String> ls=text.split(\\' \\');\\n  List<String> lsa=brokenLetters.split(\\'\\');\\n  for(String s in ls)\\n  {\\n    int c=lsa.length;\\n      for(String ss in lsa)\\n      {\\n\\n          if(!s.contains(ss))\\n          c--;\\n         \\n      }\\n      if(c==0)\\n      count++;\\n\\n  }\\n  return count;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int canBeTypedWords(String text, String brokenLetters) {\\n  int count=0;\\n  List<String> ls=text.split(\\' \\');\\n  List<String> lsa=brokenLetters.split(\\'\\');\\n  for(String s in ls)\\n  {\\n    int c=lsa.length;\\n      for(String ss in lsa)\\n      {\\n\\n          if(!s.contains(ss))\\n          c--;\\n         \\n      }\\n      if(c==0)\\n      count++;\\n\\n  }\\n  return count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018912,
                "title": "c-beats-100-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        vector<bool>arr(26,false);\\n        for(int i = 0;i < brokenLetters.length();i++)\\n            arr[brokenLetters[i] - \\'a\\'] = true;\\n        int ans = 0;\\n        for(int j = 0;j < text.length();j++){\\n            bool flag = true;\\n            while(j < text.length() && text[j] != \\' \\')\\n                if(arr[text[j++] - \\'a\\'])\\n                    flag = false;\\n            if(flag)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        vector<bool>arr(26,false);\\n        for(int i = 0;i < brokenLetters.length();i++)\\n            arr[brokenLetters[i] - \\'a\\'] = true;\\n        int ans = 0;\\n        for(int j = 0;j < text.length();j++){\\n            bool flag = true;\\n            while(j < text.length() && text[j] != \\' \\')\\n                if(arr[text[j++] - \\'a\\'])\\n                    flag = false;\\n            if(flag)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014886,
                "title": "2ms-easy-code-string",
                "content": "# Code\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n    int count = 0;\\n        String[] words = text.split(\" \");\\n        \\n        for (String word : words) {\\n            boolean canType = true;\\n            for (char c : brokenLetters.toCharArray()) {\\n                if (word.indexOf(c) != -1) {\\n                    canType = false;\\n                    break; // No need to continue checking if a broken letter is found in the word\\n                }\\n            }\\n            if (canType) {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n    int count = 0;\\n        String[] words = text.split(\" \");\\n        \\n        for (String word : words) {\\n            boolean canType = true;\\n            for (char c : brokenLetters.toCharArray()) {\\n                if (word.indexOf(c) != -1) {\\n                    canType = false;\\n                    break; // No need to continue checking if a broken letter is found in the word\\n                }\\n            }\\n            if (canType) {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007663,
                "title": "my-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n  public int canBeTypedWords(String text, String brokenLetters) {\\n    String[] splited = text.split(\"\\\\\\\\s+\");\\n    int response = splited.length;\\n\\n    for (String word : splited) {\\n      for (char ch : brokenLetters.toCharArray()) {\\n        if (word.indexOf(ch) != -1) {\\n          response--;\\n          break;\\n        }\\n      }\\n    }\\n\\n    return response;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int canBeTypedWords(String text, String brokenLetters) {\\n    String[] splited = text.split(\"\\\\\\\\s+\");\\n    int response = splited.length;\\n\\n    for (String word : splited) {\\n      for (char ch : brokenLetters.toCharArray()) {\\n        if (word.indexOf(ch) != -1) {\\n          response--;\\n          break;\\n        }\\n      }\\n    }\\n\\n    return response;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006097,
                "title": "one-line-solution-using-list-comprehensions-and-intersections-of-sets",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return  len(text.split(\\' \\')) - sum([1 for w in text.split(\\' \\') if len(set(brokenLetters).intersection(set(w))) != 0])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        return  len(text.split(\\' \\')) - sum([1 for w in text.split(\\' \\') if len(set(brokenLetters).intersection(set(w))) != 0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996801,
                "title": "beats-100-in-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int count=0;\\n        unordered_map<char,int>v;\\n        for(int i=0;i<brokenLetters.length();i++)\\n        {\\n            v[brokenLetters[i]]++;\\n        }\\n        string temp=\"\";\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(text[i]==\\' \\' || i==text.size()-1)\\n            {\\n                int flag=0;\\n                if(i==text.size()-1)\\n                {\\n                    temp+=text[i];\\n                }\\n                for(int i=0;i<temp.size();i++)\\n                {\\n                    if(v[temp[i]]==1)\\n                    {\\n                        flag=1;\\n                        break;\\n\\n                    }\\n                      \\n                }\\n                if(flag==0) count++;\\n                temp=\"\";\\n            }\\n            else \\n            {\\n                temp+=text[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canBeTypedWords(string text, string brokenLetters) {\\n        int count=0;\\n        unordered_map<char,int>v;\\n        for(int i=0;i<brokenLetters.length();i++)\\n        {\\n            v[brokenLetters[i]]++;\\n        }\\n        string temp=\"\";\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(text[i]==\\' \\' || i==text.size()-1)\\n            {\\n                int flag=0;\\n                if(i==text.size()-1)\\n                {\\n                    temp+=text[i];\\n                }\\n                for(int i=0;i<temp.size();i++)\\n                {\\n                    if(v[temp[i]]==1)\\n                    {\\n                        flag=1;\\n                        break;\\n\\n                    }\\n                      \\n                }\\n                if(flag==0) count++;\\n                temp=\"\";\\n            }\\n            else \\n            {\\n                temp+=text[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992700,
                "title": "set-easy-just-read-it-it-once-you-will-get-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        Set<Character> hs= new HashSet<>();\\n        for(int i=0;i<brokenLetters.length();i++){\\n          char ch=brokenLetters.charAt(i);\\n          hs.add(ch);          \\n        }\\n        int count= 0 ;        \\n        String[]a =text.split(\" \") ;\\n        for(int i = 0 ; i<a.length;i++){\\n            String s= a[i]; \\n            for(int j=0 ; j<s.length();j++){\\n                if(hs.contains(s.charAt(j))){\\n                    count++; \\n                    break; \\n                }                \\n            }             \\n        }\\n        return a.length-count; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        Set<Character> hs= new HashSet<>();\\n        for(int i=0;i<brokenLetters.length();i++){\\n          char ch=brokenLetters.charAt(i);\\n          hs.add(ch);          \\n        }\\n        int count= 0 ;        \\n        String[]a =text.split(\" \") ;\\n        for(int i = 0 ; i<a.length;i++){\\n            String s= a[i]; \\n            for(int j=0 ; j<s.length();j++){\\n                if(hs.contains(s.charAt(j))){\\n                    count++; \\n                    break; \\n                }                \\n            }             \\n        }\\n        return a.length-count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988486,
                "title": "solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        a=list(text.split(\\' \\'))\\n        b=0\\n        c=[]\\n        for i in brokenLetters :\\n            if i not in c :\\n                c.append(i)\\n        for i in range(0,len(a)) :\\n            d=0\\n            for j in range(0,len(c)) :\\n                if c[j] in a[i] :\\n                    d+=1\\n                if d>=1 :\\n                    break\\n            if d==0 :\\n                b+=1\\n        return b\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        a=list(text.split(\\' \\'))\\n        b=0\\n        c=[]\\n        for i in brokenLetters :\\n            if i not in c :\\n                c.append(i)\\n        for i in range(0,len(a)) :\\n            d=0\\n            for j in range(0,len(c)) :\\n                if c[j] in a[i] :\\n                    d+=1\\n                if d>=1 :\\n                    break\\n            if d==0 :\\n                b+=1\\n        return b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984109,
                "title": "java-bruteforce-solution-maximum-number-of-words-you-can-type",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String[] typedWord = text.split(\" \");\\n        int total = typedWord.length;\\n        for(int i=0; i<typedWord.length; i++){\\n            for(int j=0; j<brokenLetters.length(); j++){\\n                if(typedWord[i].contains(brokenLetters.charAt(j)+\"\")){\\n                    total--;\\n                    break;\\n                }\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String[] typedWord = text.split(\" \");\\n        int total = typedWord.length;\\n        for(int i=0; i<typedWord.length; i++){\\n            for(int j=0; j<brokenLetters.length(); j++){\\n                if(typedWord[i].contains(brokenLetters.charAt(j)+\"\")){\\n                    total--;\\n                    break;\\n                }\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974841,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreate a hashmap of broken letters and iterate over the letters of the word in the given text, if a letter is found in hashmap then it is not possible to type. assume all the words are possible to type when you start, and subtract words which are not possible on the go.\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        \\n        String[] words = text.split(\" \");\\n        int totalWordsPossible = words.length;\\n\\n        if(brokenLetters.length() ==0 ){\\n            return totalWordsPossible;\\n        }\\n\\n        HashMap<Character, Integer> map = new HashMap<>();\\n\\n        for(int i=0; i<brokenLetters.length(); i++){\\n            char letter = brokenLetters.charAt(i);\\n            map.put(letter, map.getOrDefault(letter, 0)+1);\\n        }\\n\\n        for( String word : words){         \\n            for( Character letter : word.toCharArray()){         \\n                if(map.containsKey(letter)){               \\n                    totalWordsPossible--;\\n                    break;\\n                }      \\n            }       \\n        }\\n\\n        return totalWordsPossible;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        \\n        String[] words = text.split(\" \");\\n        int totalWordsPossible = words.length;\\n\\n        if(brokenLetters.length() ==0 ){\\n            return totalWordsPossible;\\n        }\\n\\n        HashMap<Character, Integer> map = new HashMap<>();\\n\\n        for(int i=0; i<brokenLetters.length(); i++){\\n            char letter = brokenLetters.charAt(i);\\n            map.put(letter, map.getOrDefault(letter, 0)+1);\\n        }\\n\\n        for( String word : words){         \\n            for( Character letter : word.toCharArray()){         \\n                if(map.containsKey(letter)){               \\n                    totalWordsPossible--;\\n                    break;\\n                }      \\n            }       \\n        }\\n\\n        return totalWordsPossible;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1779437,
                "content": [
                    {
                        "username": "harishp13",
                        "content": "class Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n          String s[] = text.split(\" \");\\n        int c = s.length;\\n        for (int i = 0; i < s.length; i++) {\\n            String l = s[i];\\n            int o=0;\\n            for (int m = 0; m < brokenLetters.length(); m++) {\\n                for (int j = 0; j < l.length(); j++) {\\n                    if (l.charAt(j) == brokenLetters.charAt(m))\\n                        o++;\\n                }\\n                }if(o!=0){\\n                c--;\\n            }\\n        }return c;\\n    }\\n}"
                    }
                ]
            }
        ]
    },
    {
        "title": "Add Minimum Number of Rungs",
        "question_content": "<p>You are given a <strong>strictly increasing</strong> integer array <code>rungs</code> that represents the <strong>height</strong> of rungs on a ladder. You are currently on the <strong>floor</strong> at height <code>0</code>, and you want to reach the last rung.</p>\n\n<p>You are also given an integer <code>dist</code>. You can only climb to the next highest rung if the distance between where you are currently at (the floor or on a rung) and the next rung is <strong>at most</strong> <code>dist</code>. You are able to insert rungs at any positive <strong>integer</strong> height if a rung is not already there.</p>\n\n<p>Return <em>the <strong>minimum</strong> number of rungs that must be added to the ladder in order for you to climb to the last rung.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> rungs = [1,3,5,10], dist = 2\n<strong>Output:</strong> 2\n<strong>Explanation:\n</strong>You currently cannot reach the last rung.\nAdd rungs at heights 7 and 8 to climb this ladder. \nThe ladder will now have rungs at [1,3,5,<u>7</u>,<u>8</u>,10].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> rungs = [3,6,8,10], dist = 3\n<strong>Output:</strong> 0\n<strong>Explanation:</strong>\nThis ladder can be climbed without adding additional rungs.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> rungs = [3,4,6,7], dist = 2\n<strong>Output:</strong> 1\n<strong>Explanation:</strong>\nYou currently cannot reach the first rung from the ground.\nAdd a rung at height 1 to climb this ladder.\nThe ladder will now have rungs at [<u>1</u>,3,4,6,7].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rungs.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= rungs[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= dist &lt;= 10<sup>9</sup></code></li>\n\t<li><code>rungs</code> is <strong>strictly increasing</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1344941,
                "title": "java-c-python-straight-forward",
                "content": "# **Explanation**\\nCompare the previous height `pre` and the current height `a`,\\nwe need `(a - pre - 1) / dist` extra rungs.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int addRungs(int[] A, int dist) {\\n        int pre = 0, res = 0;\\n        for (int a: A) {\\n            res += (a - pre - 1) / dist;\\n            pre = a;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int addRungs(vector<int>& A, int dist) {\\n        int pre = 0, res = 0;\\n        for (int a: A) {\\n            res += (a - pre - 1) / dist;\\n            pre = a;\\n        }\\n        return res;\\n    }\\n```\\n**Python**\\n```py\\n    def addRungs(self, A, dist):\\n        pre = res = 0\\n        for a in A:\\n            res += (a - pre - 1) / dist\\n            pre = a\\n        return res\\n```\\n**Python 1-line for fun**\\n```py\\n    def addRungs(self, A, dist):\\n        return sum((b - a - 1) / dist for a, b in zip([0] + A, A))\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int addRungs(int[] A, int dist) {\\n        int pre = 0, res = 0;\\n        for (int a: A) {\\n            res += (a - pre - 1) / dist;\\n            pre = a;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int addRungs(vector<int>& A, int dist) {\\n        int pre = 0, res = 0;\\n        for (int a: A) {\\n            res += (a - pre - 1) / dist;\\n            pre = a;\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def addRungs(self, A, dist):\\n        pre = res = 0\\n        for a in A:\\n            res += (a - pre - 1) / dist\\n            pre = a\\n        return res\\n```\n```py\\n    def addRungs(self, A, dist):\\n        return sum((b - a - 1) / dist for a, b in zip([0] + A, A))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1344878,
                "title": "divide-gaps-by-dist",
                "content": "The only trick here is to use division, as the gap between two rungs could be large. We will get TLE if we add rungs one-by-one.\\n\\n**Java**\\n```java\\npublic int addRungs(int[] rungs, int dist) {\\n    int res = (rungs[0] - 1) / dist;\\n    for (int i = 1; i < rungs.length; ++i)\\n        res += (rungs[i] - rungs[i - 1] - 1) / dist;\\n    return res;\\n}\\n```\\n**C++**\\n```cpp\\nint addRungs(vector<int>& rungs, int dist) {\\n    int res = (rungs[0] - 1) / dist;\\n    for (int i = 1; i < rungs.size(); ++i)\\n        res += (rungs[i] - rungs[i - 1] - 1) / dist;\\n    return res;\\n}\\n```\\n**Python 3**\\n```python\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        return sum((a - b - 1) // dist for a, b in zip(rungs, [0] + rungs))\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```java\\npublic int addRungs(int[] rungs, int dist) {\\n    int res = (rungs[0] - 1) / dist;\\n    for (int i = 1; i < rungs.length; ++i)\\n        res += (rungs[i] - rungs[i - 1] - 1) / dist;\\n    return res;\\n}\\n```\n```cpp\\nint addRungs(vector<int>& rungs, int dist) {\\n    int res = (rungs[0] - 1) / dist;\\n    for (int i = 1; i < rungs.size(); ++i)\\n        res += (rungs[i] - rungs[i - 1] - 1) / dist;\\n    return res;\\n}\\n```\n```python\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        return sum((a - b - 1) // dist for a, b in zip(rungs, [0] + rungs))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344925,
                "title": "java-python-3-accumulate-the-division-of-gap-1-by-dist-w-brief-explanation",
                "content": "If any `gap` between nieghboring rungs is\\n1. no greater than `dist`, need `0` rung;\\n2. greater than `dist` by `1 ~ dist`, need `1` rung, by `dist + 1 ~ 2 * dist`, need `2` rungs...\\n\\nWe can conclude that **for any `gap`, we nned `(gap - 1) / dist` rungs.**\\n```java\\n    public int addRungs(int[] rungs, int dist) {\\n        int cnt = 0, prev = 0;\\n        for (int cur : rungs) {\\n            cnt += (cur - prev - 1) / dist;\\n            prev = cur;\\n        }\\n        return cnt;\\n    }\\n```\\n```python\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        cnt = prev = 0\\n        for cur in rungs:\\n            cnt += (cur - prev - 1) // dist\\n            prev = cur\\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int addRungs(int[] rungs, int dist) {\\n        int cnt = 0, prev = 0;\\n        for (int cur : rungs) {\\n            cnt += (cur - prev - 1) / dist;\\n            prev = cur;\\n        }\\n        return cnt;\\n    }\\n```\n```python\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        cnt = prev = 0\\n        for cur in rungs:\\n            cnt += (cur - prev - 1) // dist\\n            prev = cur\\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1344937,
                "title": "c-simple-math-solution-commented-explained",
                "content": "*  if you can\\'t reach the curr rung from the previoud one  using the given dist, then calculate the number of rungs you need .\\n*   number of rungs = (diff)/dist , where diff is the difference between current to the previous height\\n*   if the diff%dist ==0 then number of rungs decreases by one\\n*   for example if rungs=[4] number of rungs are 1 but not 2 (i.e., [2,4])\\n    \\n    \\n   - Time complexity -O(n)\\n  \\xA0space complexity O(1)\\n```\\nclass Solution {\\npublic:\\n    \\n    int addRungs(vector<int>& rungs, int dist) {\\n        int count=0;\\n        \\n        //represents the previous height\\n        int prevHeight=0;\\n        int diff;\\n        for(int i=0;i<rungs.size();i++)\\n        {\\n            diff=rungs[i]-prevHeight;\\n            if(diff>dist)\\n            {\\n                //the number of rungs needed to be inserted\\n                count+=(diff)/dist;\\n                //if the diference is divided by dist with 0 remainder then count may count-1 are needed\\n                //for example  [4] dist=2 here , (4-0)/2 =2 but (4-0)%2 == 0 so count decreases (count-1) the ans is [2,4]\\n                if((diff)%dist==0)\\n                    count--;\\n            }\\n            prevHeight=rungs[i];\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int addRungs(vector<int>& rungs, int dist) {\\n        int count=0;\\n        \\n        //represents the previous height\\n        int prevHeight=0;\\n        int diff;\\n        for(int i=0;i<rungs.size();i++)\\n        {\\n            diff=rungs[i]-prevHeight;\\n            if(diff>dist)\\n            {\\n                //the number of rungs needed to be inserted\\n                count+=(diff)/dist;\\n                //if the diference is divided by dist with 0 remainder then count may count-1 are needed\\n                //for example  [4] dist=2 here , (4-0)/2 =2 but (4-0)%2 == 0 so count decreases (count-1) the ans is [2,4]\\n                if((diff)%dist==0)\\n                    count--;\\n            }\\n            prevHeight=rungs[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345138,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist){\\n        int cnt=0;\\n        for(int i=rungs.size()-1;i>=0;i--){\\n           int j=(i!=0)?(rungs[i]-rungs[i-1]):rungs[i];\\n           if(j>dist){\\n               cnt+=((j-1)/dist);\\n\\t\\t\\t   //or\\n\\t\\t\\t   //cnt+=(j/dist)-1;\\n               //if(j%dist > 0) cnt++;\\n           }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist){\\n        int cnt=0;\\n        for(int i=rungs.size()-1;i>=0;i--){\\n           int j=(i!=0)?(rungs[i]-rungs[i-1]):rungs[i];\\n           if(j>dist){\\n               cnt+=((j-1)/dist);\\n\\t\\t\\t   //or\\n\\t\\t\\t   //cnt+=(j/dist)-1;\\n               //if(j%dist > 0) cnt++;\\n           }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1700794,
                "title": "easy-c-solution-by-dividing-with-gaps-each-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int pre=0,c=0;\\n        int n=rungs.size();\\n        for(int i=0;i<n;i++){\\n            c+=(rungs[i]-pre-1)/dist;\\n            pre=rungs[i];\\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int pre=0,c=0;\\n        int n=rungs.size();\\n        for(int i=0;i<n;i++){\\n            c+=(rungs[i]-pre-1)/dist;\\n            pre=rungs[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1346425,
                "title": "it-should-be-tagged-as-easy-instead-of-medium",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int n = rungs.size();\\n        vector<int>arr(n+1,0);\\n        for(int i=1;i<=n;i++) arr[i] = rungs[i-1];\\n        \\n        int count = 0;\\n        for(int i=1;i<=n;i++){\\n            if(arr[i] - arr[i-1] > dist){\\n                int diff = arr[i]-arr[i-1];\\n                count += diff/dist;\\n                if(diff%dist == 0) count--;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int n = rungs.size();\\n        vector<int>arr(n+1,0);\\n        for(int i=1;i<=n;i++) arr[i] = rungs[i-1];\\n        \\n        int count = 0;\\n        for(int i=1;i<=n;i++){\\n            if(arr[i] - arr[i-1] > dist){\\n                int diff = arr[i]-arr[i-1];\\n                count += diff/dist;\\n                if(diff%dist == 0) count--;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362810,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int addRungs(vector<int>& a, int d) \\n   {\\n        int n=a.size();\\n        int c=0;\\n        if(a[0]>d)\\n            c+=(a[0]-1)/d;       \\n        for(int i=1;i<n;i++)\\n        {\\n            if((a[i]-a[i-1])>d)\\n            {\\n                c+=(a[i]-a[i-1]-1)/d;\\n            }\\n        }\\n        return c;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int addRungs(vector<int>& a, int d) \\n   {\\n        int n=a.size();\\n        int c=0;\\n        if(a[0]>d)\\n            c+=(a[0]-1)/d;       \\n        for(int i=1;i<n;i++)\\n        {\\n            if((a[i]-a[i-1])>d)\\n            {\\n                c+=(a[i]-a[i-1]-1)/d;\\n            }\\n        }\\n        return c;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757807,
                "title": "c-solution-o-n-solution-beginner-friendly",
                "content": "``` Very easy solution . Beginner friendly```\\n``` Time complexity :- O(n)```\\n``` Space complexity :- O(1)```\\n```\\n int addRungs(vector<int>& a, int d) {\\n        int n=a.size();\\n        int c=0;\\n        if(a[0]>d)\\n            c+=(a[0]-1)/d;        // If the first element is greater than d(distance).\\n        for(int i=1;i<n;i++)\\n        {\\n            if((a[i]-a[i-1])>d)\\n            {\\n                c+=(a[i]-a[i-1]-1)/d;\\n            }\\n        }\\n        return c;          // Returned the count.\\n    }\\n```\\n``` If you like my approach then hit the like button.```",
                "solutionTags": [],
                "code": "``` Very easy solution . Beginner friendly```\n``` Time complexity :- O(n)```\n``` Space complexity :- O(1)```\n```\\n int addRungs(vector<int>& a, int d) {\\n        int n=a.size();\\n        int c=0;\\n        if(a[0]>d)\\n            c+=(a[0]-1)/d;        // If the first element is greater than d(distance).\\n        for(int i=1;i<n;i++)\\n        {\\n            if((a[i]-a[i-1])>d)\\n            {\\n                c+=(a[i]-a[i-1]-1)/d;\\n            }\\n        }\\n        return c;          // Returned the count.\\n    }\\n```\n``` If you like my approach then hit the like button.```",
                "codeTag": "Unknown"
            },
            {
                "id": 1365986,
                "title": "easy-cpp",
                "content": "class Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int count=0;\\n        for(int i=0; i<rungs.size(); i++){\\n            long long int temp;\\n            if(i==0)\\n                temp=rungs[i];\\n            else\\n                temp=rungs[i]-rungs[i-1];\\n            if(temp <= dist) continue;\\n            if(temp % dist==0) \\n            temp--;\\n            count+=(temp/dist);\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int count=0;\\n        for(int i=0; i<rungs.size(); i++){\\n            long long int temp;\\n            if(i==0)\\n                temp=rungs[i];\\n            else\\n                temp=rungs[i]-rungs[i-1];\\n            if(temp <= dist) continue;\\n            if(temp % dist==0) \\n            temp--;\\n            count+=(temp/dist);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1345151,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int cnt=0;\\n        int n=rungs.size();\\n        if(rungs[n-1]<dist)          \\n            return 0;\\n        if(rungs[0]>dist){            \\n            if(rungs[0]%dist==0)\\n             cnt+=(rungs[0]/dist)-1;\\n            else\\n             cnt+=rungs[0]/dist;\\n        }\\n        for(int i=0;i+1<n;i++){\\n            int x=rungs[i+1]-rungs[i];\\n            if(x >dist){\\n                if(x%dist==0)\\n                cnt+=(x/dist)-1;\\n                else\\n                    cnt+=x/dist;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\nDo upvote, if u find it helpful !!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int cnt=0;\\n        int n=rungs.size();\\n        if(rungs[n-1]<dist)          \\n            return 0;\\n        if(rungs[0]>dist){            \\n            if(rungs[0]%dist==0)\\n             cnt+=(rungs[0]/dist)-1;\\n            else\\n             cnt+=rungs[0]/dist;\\n        }\\n        for(int i=0;i+1<n;i++){\\n            int x=rungs[i+1]-rungs[i];\\n            if(x >dist){\\n                if(x%dist==0)\\n                cnt+=(x/dist)-1;\\n                else\\n                    cnt+=x/dist;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345016,
                "title": "o-n-python-solution-with-explanation-for-1",
                "content": "We simply iterate through rungs, keeping track of what the height of the previous rung was. If the difference in height between the current and previous rung is greater than the `dist` parameter, i.e. greater than the maximum distance we\\'re allowed to go up, we divide the height difference by `dist`. If `dist = 2` and height difference between the previous rung and current rung is `3`, we get `1.5` which we can simply truncate to `1`.\\n\\nThere are some cases this doesn\\'t cover, which comes up when the height difference is exactly divisible by `dist`, i.e. placing the minimum number of rungs puts us exactly *at* the next rung, from where we need to go a distance of `0` to get to the next rung. For example, when `dist = 2` and the difference between the previous and current rung is `4`, `4/2` would give us `2`, but we know that once we go up a distance of `2` from the previous rung, there already is a rung at a distance of `2` from there. For cases like this, we\\'d add one less rung than we usually do. \\n\\nIn the division `diff / dist`, this only happens when we get a whole number output (like `4/2 = 2` above); so we can simply check if the division result is a whole number or not, and take one out of the number of rungs to add if it is.\\n\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        newrungs = 0\\n        prev = 0\\n        \\n        for rung in rungs:\\n            diff = rung - prev\\n            \\n            if diff > dist:\\n                add = diff / dist # Number of rungs we need to add\\n                \\n                if add % 1 == 0:\\n                    add = int(add) - 1\\n                else:\\n                    add = int(add)\\n                newrungs += add\\n            prev = rung\\n        \\n\\t\\treturn newrungs\\n```\\n\\nAlternatively, if we subtract `1` from the difference between the previous and current rung, we do not need to check whether the division result is a whole number or not. For the first case above, `diff = 3` and `dist = 2`, we end up with `(3-1)/2 = 1` instead of `1.5`, removing the need to round down to get `1`. For the second case, `diff = 4` and `dist = 2`, we end up with `(4-1)/2 = 1.5`, which has to be truncated to `1`. Both cases require no additional checking, which helps simplify the code a fair bit.\\n\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        newrungs = 0\\n        prev = 0\\n        \\n        for rung in rungs:\\n            diff = rung - prev - 1\\n            newrungs += diff // dist\\n            prev = rung\\n        \\n        return newrungs\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        newrungs = 0\\n        prev = 0\\n        \\n        for rung in rungs:\\n            diff = rung - prev\\n            \\n            if diff > dist:\\n                add = diff / dist # Number of rungs we need to add\\n                \\n                if add % 1 == 0:\\n                    add = int(add) - 1\\n                else:\\n                    add = int(add)\\n                newrungs += add\\n            prev = rung\\n        \\n\\t\\treturn newrungs\\n```\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        newrungs = 0\\n        prev = 0\\n        \\n        for rung in rungs:\\n            diff = rung - prev - 1\\n            newrungs += diff // dist\\n            prev = rung\\n        \\n        return newrungs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344886,
                "title": "c-easy-to-understand-finding-gaps",
                "content": "The apporach is simple \\nhere we have to calculate the height difference between each rung.\\nthen we will check if that height difference is reachable or not.\\nif not reachable then, we will add (height diff - 1)/dist to find the no. of rungs needed to make it reachable.\\n\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n//         make a vector to store the differences\\n        vector<int> val(rungs.size());\\n        val[0]=rungs[0];\\n        for(int i=1;i<rungs.size();i++)\\n        {\\n            val[i]=rungs[i]-rungs[i-1];\\n        }\\n        int count=0;\\n//         iterate over the differences array\\n//         and count the numbers of rungs needed to make the climb possible\\n         for(int i=0;i<val.size();i++)\\n         {\\n             if(val[i]>dist)\\n             {\\n                 count+=((double)(val[i]-1)/dist);\\n             }\\n         }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n//         make a vector to store the differences\\n        vector<int> val(rungs.size());\\n        val[0]=rungs[0];\\n        for(int i=1;i<rungs.size();i++)\\n        {\\n            val[i]=rungs[i]-rungs[i-1];\\n        }\\n        int count=0;\\n//         iterate over the differences array\\n//         and count the numbers of rungs needed to make the climb possible\\n         for(int i=0;i<val.size();i++)\\n         {\\n             if(val[i]>dist)\\n             {\\n                 count+=((double)(val[i]-1)/dist);\\n             }\\n         }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633568,
                "title": "greedy-c-very-simple",
                "content": "# if it Helps You. Please Upvote Me..!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is Simple, just Calculate the difference between **current positions and Next Position**, if **Difference** is **Fully Divisible** by given **dist** then add **Difference/dist-1** to the **answer** otherwise add **difference/dist** to the **answer**.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& arr, int d) {\\n        int count = 0,pos = 0,n = arr.size();\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n          int dif = arr[i]-pos;\\n\\n          if(dif>d)\\n          {\\n            if(dif%d==0)\\n            count+=(dif/d-1);\\n            else\\n            count+=(dif/d);\\n          }\\n          pos = arr[i];\\n          \\n        }\\n\\n        return count;\\n        \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/f519ef05-8d79-42ea-baba-68d9a4d61b43_1686664921.6870508.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& arr, int d) {\\n        int count = 0,pos = 0,n = arr.size();\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n          int dif = arr[i]-pos;\\n\\n          if(dif>d)\\n          {\\n            if(dif%d==0)\\n            count+=(dif/d-1);\\n            else\\n            count+=(dif/d);\\n          }\\n          pos = arr[i];\\n          \\n        }\\n\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2553738,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Greedy***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& nums, int dist) {\\n        \\n        int n = nums.size();\\n        \\n        int count = 0;\\n        \\n        // prev will store the height at which i am standing\\n        \\n        int prev = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // if we can reach the rung\\n            \\n            if(prev + dist >= nums[i])\\n            {\\n                prev = nums[i];\\n            }\\n            \\n            // if we can\\'t reach the rung\\n            \\n            // count the no. of rungs we have to add in the ladder to reach next rung\\n            \\n            else\\n            {\\n                int req_rung = (nums[i] - prev) / dist;\\n                \\n                if((nums[i] - prev) % dist == 0)\\n                {\\n                    req_rung--;\\n                }\\n                \\n                // update count\\n                \\n                count += req_rung;\\n                \\n                prev = nums[i];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& nums, int dist) {\\n        \\n        int n = nums.size();\\n        \\n        int count = 0;\\n        \\n        // prev will store the height at which i am standing\\n        \\n        int prev = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // if we can reach the rung\\n            \\n            if(prev + dist >= nums[i])\\n            {\\n                prev = nums[i];\\n            }\\n            \\n            // if we can\\'t reach the rung\\n            \\n            // count the no. of rungs we have to add in the ladder to reach next rung\\n            \\n            else\\n            {\\n                int req_rung = (nums[i] - prev) / dist;\\n                \\n                if((nums[i] - prev) % dist == 0)\\n                {\\n                    req_rung--;\\n                }\\n                \\n                // update count\\n                \\n                count += req_rung;\\n                \\n                prev = nums[i];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680088,
                "title": "simple-straight-forward-javascript-solution",
                "content": "Solution based on [[Java/C++/Python] Straight Forward](https://leetcode.com/problems/add-minimum-number-of-rungs/discuss/1344941/JavaC%2B%2BPython-Straight-Forward) by [lee215](https://leetcode.com/lee215/)\\n\\n**Short Explanation**\\nCompare the previous height pre and the current height a,\\nwe need (a - pre - 1) / dist extra rungs.\\n\\n**Long Explanation** - by [kunqian](https://leetcode.com/kunqian/) \\nExplanation:\\nImagine we need at least k rungs between A[i - 1] ~ A[i], then we have the following relationships:\\n\\nA[i - 1] + (k + 1) * dist >= A[i]\\nA[i - 1] + k * dist < A[i] => [(A[i] - A[i - 1]) / dist] - 1 <= k < (A[i] - A[i - 1]) / dist\\nif D = (A[i] - A[i - 1]) / dist, D is a float and k is an integer\\nwe have D - 1 <= k < D, so k is biggest int that smaller than D, which is (A[i] - A[i - 1] - 1) // dist.\\n\\n**Complexity**\\n```\\nTime O(n)\\nSpace O(1)\\n```\\n\\n**JavaScript Code** \\n```\\nvar addRungs = function(rungs, dist) {\\n    let res = 0;\\n    let prev = 0;\\n    for ( let i = 0; i < rungs.length; i++ ){\\n        res += Math.floor(( rungs[i] - prev - 1 ) / dist ); \\n        prev = rungs[i];\\n    }\\n    return res;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nTime O(n)\\nSpace O(1)\\n```\n```\\nvar addRungs = function(rungs, dist) {\\n    let res = 0;\\n    let prev = 0;\\n    for ( let i = 0; i < rungs.length; i++ ){\\n        res += Math.floor(( rungs[i] - prev - 1 ) / dist ); \\n        prev = rungs[i];\\n    }\\n    return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1364199,
                "title": "python-easy-to-understand-faster-than-87-16",
                "content": "Runtime: 532 ms, faster than 87.16% of Python3 online submissions for Add Minimum Number of Rungs.\\nMemory Usage: 28.8 MB, less than 47.33% of Python3 online submissions for Add Minimum Number of Rungs.\\n\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        count = 0\\n        if rungs[0] > dist:\\n            m = rungs[0]\\n            m = (m - 1) // dist\\n            count += m\\n        for i in range (len(rungs) - 1):\\n            k = rungs[i+1] - rungs[i]\\n            if k > dist:\\n                \\n                n = (k-1) // dist\\n                count += n\\n        return count      \\n```\\n\\nFeel free to ask your doubts in comment section, Please do upvote.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        count = 0\\n        if rungs[0] > dist:\\n            m = rungs[0]\\n            m = (m - 1) // dist\\n            count += m\\n        for i in range (len(rungs) - 1):\\n            k = rungs[i+1] - rungs[i]\\n            if k > dist:\\n                \\n                n = (k-1) // dist\\n                count += n\\n        return count      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349799,
                "title": "c-just-math",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int spot = 0, count = 0;\\n        for (int i = 0; i < rungs.size(); i++) {\\n            if (spot + dist < rungs[i]) {\\n                count += (rungs[i] - 1 - spot) / dist;\\n            }\\n            spot = rungs[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int spot = 0, count = 0;\\n        for (int i = 0; i < rungs.size(); i++) {\\n            if (spot + dist < rungs[i]) {\\n                count += (rungs[i] - 1 - spot) / dist;\\n            }\\n            spot = rungs[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345278,
                "title": "c-explanation-efficient-solution-time-o-n-auxiliary-space-o-1",
                "content": "Explanation: \\n\\n**Input**\\n\\nrungs = [6,12,13,14,15], dist = 2\\n\\n**Output** = 4\\n\\n\\n**Ladder**\\n\\n**---15**\\n**---14**\\n**---13**\\n**---12**\\n---11\\n---10\\n---9\\n---8\\n---7\\n**---6**\\n---5\\n---4\\n---3\\n---2\\n---1\\n**---0**\\n\\n**Concept of count1=(rungs[i]-rungs[i-1]-1)/dist vs count2=(rungs[i]-rungs[i-1])/dist**\\n\\nFor example : If i=2, count1=(12-6)/2=3 & count2=(12-6-1)/2=2. From ladder diagram, if we add rungs at 8 & 10, it will enable us to climb from 6 to 12 in steps of 8-6=2=dist, 10-8=2=dist, 12-10=2=dist by adding minimum number of rungs. Hence, count2 is the correct equation.\\n\\n**Efficient Solution** \\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n\\t    // Efficient Solution Time O(N) & Auxiliary Space O(1)\\n        int len=rungs.size();\\n        int count=(rungs[0]-1)/dist; \\n        if(len==1)\\n            return count;\\n        for(int i=1;i<len;i++){\\n            count+=(rungs[i]-rungs[i-1]-1)/dist;\\n        }\\n      return count;\\n    }\\n};\\n```\\n**All suggestions are welcome. Please upvote if you like it. Thank you for reading the post.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n\\t    // Efficient Solution Time O(N) & Auxiliary Space O(1)\\n        int len=rungs.size();\\n        int count=(rungs[0]-1)/dist; \\n        if(len==1)\\n            return count;\\n        for(int i=1;i<len;i++){\\n            count+=(rungs[i]-rungs[i-1]-1)/dist;\\n        }\\n      return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344992,
                "title": "java-simple-division-self-written-ceiling-function",
                "content": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        //greedy\\n        int last=0;\\n        int res=0;\\n        for (int cur:rungs){\\n            if (cur-last>dist){\\n                //self written ceiling funtion\\n                int batch = (cur-last)/dist -1;\\n                if ((cur-last)%dist > 0){\\n                    batch+=1;\\n                }\\n                res+=batch;\\n            }\\n            last=cur;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        //greedy\\n        int last=0;\\n        int res=0;\\n        for (int cur:rungs){\\n            if (cur-last>dist){\\n                //self written ceiling funtion\\n                int batch = (cur-last)/dist -1;\\n                if ((cur-last)%dist > 0){\\n                    batch+=1;\\n                }\\n                res+=batch;\\n            }\\n            last=cur;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344963,
                "title": "java-straight-forward-5-lines",
                "content": "```java\\n public int addRungs(int[] rungs, int dist) {\\n        int s = 0, res = 0;\\n       for (int i = 0; i < rungs.length ; i++) {\\n           res += (rungs[i] - s - 1) / dist;\\n           s = rungs[i];\\n       }\\n       return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n public int addRungs(int[] rungs, int dist) {\\n        int s = 0, res = 0;\\n       for (int i = 0; i < rungs.length ; i++) {\\n           res += (rungs[i] - s - 1) / dist;\\n           s = rungs[i];\\n       }\\n       return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1344946,
                "title": "easy-java-o-n-solution",
                "content": "What we do here is that we traverse the array if our height is more that rungs[i], then we will keep it rungs[i].\\n\\nBut if not then we will get the difference between the rungs[i] and our height and add the ceil to the count and update the count this way.\\n\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int count = 0;\\n        int curHeight = 0;\\n        \\n        for(int i = 0; i < rungs.length; i++){\\n            curHeight += dist;\\n            if(curHeight >= rungs[i]){\\n                curHeight = rungs[i];\\n            }else{\\n                int diff = (rungs[i] - curHeight);\\n                count += (int)(Math.ceil((double)diff/dist));\\n                curHeight = rungs[i];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int count = 0;\\n        int curHeight = 0;\\n        \\n        for(int i = 0; i < rungs.length; i++){\\n            curHeight += dist;\\n            if(curHeight >= rungs[i]){\\n                curHeight = rungs[i];\\n            }else{\\n                int diff = (rungs[i] - curHeight);\\n                count += (int)(Math.ceil((double)diff/dist));\\n                curHeight = rungs[i];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839932,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) \\n    {\\n        int n=rungs.size();\\n        int count=0;\\n        int pre=0;\\n        for(int i =0;i<n;i++)\\n        {\\n            count+=(rungs[i]-pre-1)/dist;\\n            pre=rungs[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) \\n    {\\n        int n=rungs.size();\\n        int count=0;\\n        int pre=0;\\n        for(int i =0;i<n;i++)\\n        {\\n            count+=(rungs[i]-pre-1)/dist;\\n            pre=rungs[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565358,
                "title": "1-ms-just-move-rung-by-rung",
                "content": "## Java\\n```java\\npublic int addRungs(int[] rungs, int dist) {\\n    var answer = 0;\\n    for (int current = 0, i = 0; i < rungs.length; current = rungs[i++]) {\\n        int height;\\n        if ((height = rungs[i] - current) > dist) {\\n            answer += (height - 1) / dist;\\n        }\\n    }\\n    return answer;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic int addRungs(int[] rungs, int dist) {\\n    var answer = 0;\\n    for (int current = 0, i = 0; i < rungs.length; current = rungs[i++]) {\\n        int height;\\n        if ((height = rungs[i] - current) > dist) {\\n            answer += (height - 1) / dist;\\n        }\\n    }\\n    return answer;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3282999,
                "title": "greedy-easy-to-understand-eazy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) \\n    {\\n         //to keep the track of the number of extra rung to be added\\n         long long int count = 0;\\n       \\n         //our curr pos at the beggining\\n         long long int currpos = 0;\\n\\n         //to keep the track of the next pos to be climed\\n         long long int nextposidx = 0;\\n\\n         while(true)\\n         {\\n             if(currpos == rungs[rungs.size()-1])\\n             {\\n                 break;\\n             }\\n\\n             if((rungs[nextposidx] - currpos) <= dist)\\n             {\\n                 currpos = rungs[nextposidx];\\n                 nextposidx++;\\n             }\\n             else\\n             {\\n                 //cout<<\"hello\"<<endl;\\n                 long long int temp = (rungs[nextposidx] - currpos);\\n                 //cout<<\"temp = \"<<temp<<endl;\\n                 \\n                 if((temp%dist) == 0)\\n                 {\\n                     long long int val = temp/dist;\\n                     count = count + (val - 1);\\n                 }\\n                 else\\n                 {\\n                    long long int val = floor(((temp*1.00)/(dist*1.00)));\\n                    count = count + (val);\\n                 }\\n                 currpos = rungs[nextposidx];\\n             }\\n         }\\n         return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) \\n    {\\n         //to keep the track of the number of extra rung to be added\\n         long long int count = 0;\\n       \\n         //our curr pos at the beggining\\n         long long int currpos = 0;\\n\\n         //to keep the track of the next pos to be climed\\n         long long int nextposidx = 0;\\n\\n         while(true)\\n         {\\n             if(currpos == rungs[rungs.size()-1])\\n             {\\n                 break;\\n             }\\n\\n             if((rungs[nextposidx] - currpos) <= dist)\\n             {\\n                 currpos = rungs[nextposidx];\\n                 nextposidx++;\\n             }\\n             else\\n             {\\n                 //cout<<\"hello\"<<endl;\\n                 long long int temp = (rungs[nextposidx] - currpos);\\n                 //cout<<\"temp = \"<<temp<<endl;\\n                 \\n                 if((temp%dist) == 0)\\n                 {\\n                     long long int val = temp/dist;\\n                     count = count + (val - 1);\\n                 }\\n                 else\\n                 {\\n                    long long int val = floor(((temp*1.00)/(dist*1.00)));\\n                    count = count + (val);\\n                 }\\n                 currpos = rungs[nextposidx];\\n             }\\n         }\\n         return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2926135,
                "title": "100-0ms-easy-o-n-proof",
                "content": "# upvote pls\\n\\n# Complexity\\n- Time complexity: n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:1\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/09ef1aff-32f0-4e0c-bcdc-c0a3b2c2d773_1671384607.6674387.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] R, int D) {\\n        int st=0,c=0;\\n        for(int i:R){\\n            c+=(i-st-1)/D;\\n            st=i;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] R, int D) {\\n        int st=0,c=0;\\n        for(int i:R){\\n            c+=(i-st-1)/D;\\n            st=i;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496891,
                "title": "c-easiest-medium-i-ever-saw-on-leetcode",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans=0;\\n        for(int i=0; i<rungs.size()-1; i++) ans+=(rungs[i+1]-rungs[i]-1)/dist;\\n        ans+=(rungs[0]-1)/dist;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans=0;\\n        for(int i=0; i<rungs.size()-1; i++) ans+=(rungs[i+1]-rungs[i]-1)/dist;\\n        ans+=(rungs[0]-1)/dist;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447400,
                "title": "python-2-line-simple-solution",
                "content": "```\\ndef addRungs(self, nums: List[int], d: int) -> int:\\n\\tnums = [0]+nums\\n\\treturn sum(ceil((nums[i+1]-nums[i])/d)-1 for i in range(len(nums)-1))\\n```",
                "solutionTags": [],
                "code": "```\\ndef addRungs(self, nums: List[int], d: int) -> int:\\n\\tnums = [0]+nums\\n\\treturn sum(ceil((nums[i+1]-nums[i])/d)-1 for i in range(len(nums)-1))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2281037,
                "title": "c-easy-solution",
                "content": "```\\n  int n=r.size();\\n       \\n       int cnt=0;\\n        if(r[0]>d){\\n            cnt+=(r[0]-1)/d;\\n        }\\n        for(int i=1;i<n;i++){\\n           int val=r[i]-r[i-1];\\n            if(val>d){\\n                cnt+=(val-1)/d;\\n            }\\n            \\n        }\\n        return cnt;",
                "solutionTags": [],
                "code": "```\\n  int n=r.size();\\n       \\n       int cnt=0;\\n        if(r[0]>d){\\n            cnt+=(r[0]-1)/d;\\n        }\\n        for(int i=1;i<n;i++){\\n           int val=r[i]-r[i-1];\\n            if(val>d){\\n                cnt+=(val-1)/d;\\n            }\\n            \\n        }\\n        return cnt;",
                "codeTag": "Unknown"
            },
            {
                "id": 2266506,
                "title": "java-solution-o-n-time-o-1-space",
                "content": "```java \\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int c=(rungs[0]-0)/dist;\\n        if((rungs[0]-0)%dist==0)\\n        c--;\\n        for(int i=1;i<rungs.length;i++)\\n        {\\n            c+=(rungs[i]-rungs[i-1])/dist;\\n            if((rungs[i]-rungs[i-1])%dist==0)\\n            c--;\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int c=(rungs[0]-0)/dist;\\n        if((rungs[0]-0)%dist==0)\\n        c--;\\n        for(int i=1;i<rungs.length;i++)\\n        {\\n            c+=(rungs[i]-rungs[i-1])/dist;\\n            if((rungs[i]-rungs[i-1])%dist==0)\\n            c--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2243766,
                "title": "java-faster-than-100-o-n",
                "content": "```class Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        \\n        int rungsNeeded = 0;\\n        \\n        if(rungs[0] - 0 > dist)\\n            rungsNeeded += (rungs[0] - 1) / dist;\\n        \\n        for(int i = 1; i < rungs.length; i++) {\\n            \\n            if(rungs[i] - rungs[i-1] > dist) {\\n                rungsNeeded += (rungs[i] - rungs[i-1] - 1) / dist;\\n            }\\n        }\\n        \\n        return rungsNeeded;\\n    }\\n}```",
                "solutionTags": [],
                "code": "```class Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        \\n        int rungsNeeded = 0;\\n        \\n        if(rungs[0] - 0 > dist)\\n            rungsNeeded += (rungs[0] - 1) / dist;\\n        \\n        for(int i = 1; i < rungs.length; i++) {\\n            \\n            if(rungs[i] - rungs[i-1] > dist) {\\n                rungsNeeded += (rungs[i] - rungs[i-1] - 1) / dist;\\n            }\\n        }\\n        \\n        return rungsNeeded;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 2152380,
                "title": "c-divide-gaps-by-dist-explanation",
                "content": "Sharing my solution here :\\n+ greedy approach\\n+ optimised linear traversal\\n\\n**We need to take care of following:**\\n1.  take difference between consecutive jumps, and use division of difference by the at most distance (\\'dist\\') allowed. This way we can do better than 0(n) traversal\\n2.   if difference is a multiple of \\'dist\\', then we require those many rungs (see #3) else there will be a remainder left (less than \\'dist\\') so we would require extra rung for that\\n3.    at every step we can do a jump of atmost \\'dist\\', if we want to go higher than this we need extra rug, so in division we ned to subtract this as this jump at each step is allowed / 0 cost.\\n\\n \\n     int solution(vector<int> &rungs, int dist) {\\n\\t\\tconst int len = rungs.size();\\n        int count = 0, prev_rung = 0;\\n        \\n        // traverse and add any additional rung required\\n        for (int curr_rung : rungs) {\\n            if (curr_rung - prev_rung > dist) {\\n                int diff = curr_rung - prev_rung;\\n                // if the \\'diff\\' is not a multiple, add 1\\n                // -1 as a jump of atmost \\'dist\\' is allowed (0 cost)\\n                count += (diff / dist) + (diff % dist > 0 ? 1 : 0) - 1;\\n            }\\n            \\n            prev_rung = curr_rung;\\n        }\\n        \\n        return count;\\n    }",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "Sharing my solution here :\\n+ greedy approach\\n+ optimised linear traversal\\n\\n**We need to take care of following:**\\n1.  take difference between consecutive jumps, and use division of difference by the at most distance (\\'dist\\') allowed. This way we can do better than 0(n) traversal\\n2.   if difference is a multiple of \\'dist\\', then we require those many rungs (see #3) else there will be a remainder left (less than \\'dist\\') so we would require extra rung for that\\n3.    at every step we can do a jump of atmost \\'dist\\', if we want to go higher than this we need extra rug, so in division we ned to subtract this as this jump at each step is allowed / 0 cost.\\n\\n \\n     int solution(vector<int> &rungs, int dist) {\\n\\t\\tconst int len = rungs.size();\\n        int count = 0, prev_rung = 0;\\n        \\n        // traverse and add any additional rung required\\n        for (int curr_rung : rungs) {\\n            if (curr_rung - prev_rung > dist) {\\n                int diff = curr_rung - prev_rung;\\n                // if the \\'diff\\' is not a multiple, add 1\\n                // -1 as a jump of atmost \\'dist\\' is allowed (0 cost)\\n                count += (diff / dist) + (diff % dist > 0 ? 1 : 0) - 1;\\n            }\\n            \\n            prev_rung = curr_rung;\\n        }\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1849480,
                "title": "only-3-lines-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int s=(rungs[0]-1)/dist;\\n        for(int i=1;i<rungs.size();i++) s+=(rungs[i]-rungs[i-1]-1)/dist;\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int s=(rungs[0]-1)/dist;\\n        for(int i=1;i<rungs.size();i++) s+=(rungs[i]-rungs[i-1]-1)/dist;\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846169,
                "title": "java-two-solutions",
                "content": "This is not a Binary-search problem but the first thing that came into my mind was binary search and not greedy :( ........\\ni think i have done enough binary search problems, also this was recommended after a binary search problem.\\n\\n**BinarySearch :**\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        //  if we are given the amount of rungs that can be inserted\\n        //  check if it is possible to go from ground to the last stair\\n        int n = rungs.length;\\n        int l = 0;\\n        int r = rungs[n - 1] / dist;\\n        int ans = 0;\\n        while (l <= r) {\\n            //  allowed steps rungs = mid\\n            int mid = (l + r) / 2;\\n            if (isPossible(rungs, mid, dist)) {\\n                ans = mid;\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean isPossible(int[] a, int allowed, int step) {\\n        int curr_rungs = a[0] / step + (a[0] % step == 0 ? -1 : 0);\\n        if (curr_rungs > allowed) {\\n            return false;\\n        }\\n        for (int i = 1; i < a.length; i++) {\\n            int diff = a[i] - a[i - 1];\\n            if (diff > step) {\\n                curr_rungs += diff / step + (diff % step == 0 ? -1 : 0);\\n            }\\n            if (curr_rungs > allowed) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```\\n\\n**Greedy :**\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int n = rungs.length;\\n        int ans = 0;\\n        ans = rungs[0] / dist + (rungs[0] % dist == 0 ? -1 : 0);\\n        for (int i = 1; i < n; i++) {\\n            int diff = rungs[i] - rungs[i - 1];\\n            ans += diff / dist + (diff % dist == 0 ? -1 : 0);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        //  if we are given the amount of rungs that can be inserted\\n        //  check if it is possible to go from ground to the last stair\\n        int n = rungs.length;\\n        int l = 0;\\n        int r = rungs[n - 1] / dist;\\n        int ans = 0;\\n        while (l <= r) {\\n            //  allowed steps rungs = mid\\n            int mid = (l + r) / 2;\\n            if (isPossible(rungs, mid, dist)) {\\n                ans = mid;\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean isPossible(int[] a, int allowed, int step) {\\n        int curr_rungs = a[0] / step + (a[0] % step == 0 ? -1 : 0);\\n        if (curr_rungs > allowed) {\\n            return false;\\n        }\\n        for (int i = 1; i < a.length; i++) {\\n            int diff = a[i] - a[i - 1];\\n            if (diff > step) {\\n                curr_rungs += diff / step + (diff % step == 0 ? -1 : 0);\\n            }\\n            if (curr_rungs > allowed) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int n = rungs.length;\\n        int ans = 0;\\n        ans = rungs[0] / dist + (rungs[0] % dist == 0 ? -1 : 0);\\n        for (int i = 1; i < n; i++) {\\n            int diff = rungs[i] - rungs[i - 1];\\n            ans += diff / dist + (diff % dist == 0 ? -1 : 0);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577549,
                "title": "c-greedy-solution-easy-to-understand",
                "content": "## class Solution {\\n## public:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans=0;\\n        if(rungs[0]-0>dist){\\n            if(rungs[0]%dist==0)\\n                ans+=rungs[0]/dist -1;\\n            else\\n                ans+=rungs[0]/dist;\\n        }\\n        for(int i=1; i<rungs.size(); i++){\\n            if(rungs[i]-rungs[i-1]>dist){\\n                if((rungs[i]-rungs[i-1])%dist==0)\\n                    ans+=(rungs[i]-rungs[i-1])/dist -1;\\n                else\\n                    ans+=(rungs[i]-rungs[i-1])/dist;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n## public:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans=0;\\n        if(rungs[0]-0>dist){\\n            if(rungs[0]%dist==0)\\n                ans+=rungs[0]/dist -1;\\n            else\\n                ans+=rungs[0]/dist;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1512546,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int n=rungs.size();\\n        \\n        int ans=0;\\n        ans=(rungs[0]-1)/dist;\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            ans+=(rungs[i]-rungs[i-1]-1)/dist;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int n=rungs.size();\\n        \\n        int ans=0;\\n        ans=(rungs[0]-1)/dist;\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            ans+=(rungs[i]-rungs[i-1]-1)/dist;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1405676,
                "title": "7-lines-1ms-java-code-beats-99-97-codes",
                "content": "class Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int count=0;\\n        int min=0;\\n        for(int i=0;i<rungs.length;i++)\\n        {\\n            if((rungs[i]-min)>dist)\\n            {\\n                count=count+(rungs[i]-1-min)/dist;\\n            }\\n              min=rungs[i];\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int count=0;\\n        int min=0;\\n        for(int i=0;i<rungs.length;i++)\\n        {\\n            if((rungs[i]-min)>dist)\\n            {\\n                count=count+(rungs[i]-1-min)/dist;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1398182,
                "title": "c-o-1-space-o-n-speed",
                "content": "```\\npublic class Solution {\\n    public int AddRungs(int[] rungs, int dist) {\\n        if (rungs == null) {\\n            return -1;\\n        }\\n        \\n        int rungsToAdd = 0;\\n        for (int i = rungs.Length - 1; i >= 0; i--) {\\n            int nextHeight = i == 0 ? 0 : rungs[i - 1];\\n            int distance = rungs[i] - nextHeight;\\n            rungsToAdd += (distance / dist);\\n            if (distance % dist == 0) {\\n                rungsToAdd--;\\n            }\\n        }\\n        \\n        return rungsToAdd;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int AddRungs(int[] rungs, int dist) {\\n        if (rungs == null) {\\n            return -1;\\n        }\\n        \\n        int rungsToAdd = 0;\\n        for (int i = rungs.Length - 1; i >= 0; i--) {\\n            int nextHeight = i == 0 ? 0 : rungs[i - 1];\\n            int distance = rungs[i] - nextHeight;\\n            rungsToAdd += (distance / dist);\\n            if (distance % dist == 0) {\\n                rungsToAdd--;\\n            }\\n        }\\n        \\n        return rungsToAdd;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389428,
                "title": "greedy-c",
                "content": "\\n```\\nint addRungs(vector<int>& rungs, int dist) {\\n      int c=0;\\n     int p=0;\\n     for(int i=0;i<rungs.size();i++){\\n       c+=(rungs[i]-p-1)/dist;\\n       p=rungs[i];\\n         }\\n      return c;  \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint addRungs(vector<int>& rungs, int dist) {\\n      int c=0;\\n     int p=0;\\n     for(int i=0;i<rungs.size();i++){\\n       c+=(rungs[i]-p-1)/dist;\\n       p=rungs[i];\\n         }\\n      return c;  \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1369896,
                "title": "c-and-python",
                "content": "The solution is easy but hard to implement if you ignore the fact that dividing two integers is integer and not float, so we need to typecast it into double/float to solve this question. \\n\\nPython doesn\\'t have this issue, so we don\\'t need to bother about float division here. \\n\\nhere is my both the solutions.\\nC++ \\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        rungs.insert(rungs.begin(), 0);\\n        int count = 0;\\n        int size = rungs.size();\\n        for(int i=1; i< size; i++){\\n            double gap = rungs[i]-rungs[i-1];\\n            if(gap>dist){\\n                count = count + ceil((double)gap/(double)dist)-1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n```\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        count = 0\\n        rungs.insert(0,0)\\n        for i in range(len(rungs)-1):\\n            gap = rungs[i+1] - rungs[i]\\n            if gap > dist:\\n                count = count + math.ceil(gap/dist)-1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        rungs.insert(rungs.begin(), 0);\\n        int count = 0;\\n        int size = rungs.size();\\n        for(int i=1; i< size; i++){\\n            double gap = rungs[i]-rungs[i-1];\\n            if(gap>dist){\\n                count = count + ceil((double)gap/(double)dist)-1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n```\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        count = 0\\n        rungs.insert(0,0)\\n        for i in range(len(rungs)-1):\\n            gap = rungs[i+1] - rungs[i]\\n            if gap > dist:\\n                count = count + math.ceil(gap/dist)-1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368201,
                "title": "python-easy-explained-with-common-mistakes",
                "content": "Reason why you should divide gap by distance is TLE.\\nI initially did a while loop to increase counter by 1 but it failed a later test case.\\nThen I divided gap//dist but this creates a problem when dist = 1\\nHence we divide and take the ceil value and subtract 1 from it\\n\\n```def addRungs(self, rungs: List[int], dist: int) -> int:\\n        count = 0\\n        rungs.insert(0,0)    # add 0 because you start from the ground not the first rung.\\n        for i in range(len(rungs)-1):\\n            gap = rungs[i+1] - rungs[i]\\n            if gap > dist:\\n                gap = math.ceil(gap/dist) - 1\\n                count += gap\\n        return count\\'\\'\\'",
                "solutionTags": [],
                "code": "Reason why you should divide gap by distance is TLE.\\nI initially did a while loop to increase counter by 1 but it failed a later test case.\\nThen I divided gap//dist but this creates a problem when dist = 1\\nHence we divide and take the ceil value and subtract 1 from it\\n\\n```def addRungs(self, rungs: List[int], dist: int) -> int:\\n        count = 0\\n        rungs.insert(0,0)    # add 0 because you start from the ground not the first rung.\\n        for i in range(len(rungs)-1):\\n            gap = rungs[i+1] - rungs[i]\\n            if gap > dist:\\n                gap = math.ceil(gap/dist) - 1\\n                count += gap\\n        return count\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 1365762,
                "title": "easy-in-python",
                "content": "def addRungs(self, rungs: List[int], dist: int) -> int:\\n        rungs.insert(0,0)\\n        count=0\\n        for i in range(1,len(rungs)):\\n            if((rungs[i]-rungs[i-1])>dist):\\n                a=rungs[i]-rungs[i-1]\\n                if(a%dist==0):\\n                    count+=(a//dist)-1\\n                else:\\n                    count+=a//dist\\n        return count",
                "solutionTags": [],
                "code": "def addRungs(self, rungs: List[int], dist: int) -> int:\\n        rungs.insert(0,0)\\n        count=0\\n        for i in range(1,len(rungs)):\\n            if((rungs[i]-rungs[i-1])>dist):\\n                a=rungs[i]-rungs[i-1]\\n                if(a%dist==0):\\n                    count+=(a//dist)-1\\n                else:\\n                    count+=a//dist\\n        return count",
                "codeTag": "Python3"
            },
            {
                "id": 1361849,
                "title": "easy-to-understand-tc-o-n-sc-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int prev = 0;\\n        int ans = 0;\\n        for(auto r: rungs){\\n            int gap = r-prev;\\n            ans += (gap-1)/dist;\\n            prev = r;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int prev = 0;\\n        int ans = 0;\\n        for(auto r: rungs){\\n            int gap = r-prev;\\n            ans += (gap-1)/dist;\\n            prev = r;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361667,
                "title": "99-faster-easy-to-understand-divide-approach",
                "content": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n     \\n        int c = (rungs[0]-1)/dist;\\n        for(int i=1;i<rungs.length;i++) {\\n            if(rungs[i]-rungs[i-1]>dist) {\\n                c += (rungs[i]-rungs[i-1]-1)/dist;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\\n//please upvote if this is helpful for you.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n     \\n        int c = (rungs[0]-1)/dist;\\n        for(int i=1;i<rungs.length;i++) {\\n            if(rungs[i]-rungs[i-1]>dist) {\\n                c += (rungs[i]-rungs[i-1]-1)/dist;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361117,
                "title": "python3-easy-for-beginners",
                "content": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        h  = 0\\n        solution = 0\\n        for r in rungs:\\n            if (r-h)%dist==0:\\n                solution+=(r-h)//dist-1\\n            else:\\n                solution+=(r-h)//dist\\n            h=r\\n        return solution\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        h  = 0\\n        solution = 0\\n        for r in rungs:\\n            if (r-h)%dist==0:\\n                solution+=(r-h)//dist-1\\n            else:\\n                solution+=(r-h)//dist\\n            h=r\\n        return solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359318,
                "title": "java-easy-clean",
                "content": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        /* Compare the previous height and the current height */\\n         int min = 0;\\n         for(int i = 0;i < rungs.length ;i++){\\n             //current distance\\n             int cd = (i == 0) ? rungs[i] - 1 : rungs[i] - rungs[i - 1] - 1;\\n             int div = (cd / dist);\\n             min = min + div ;\\n         }\\n      return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        /* Compare the previous height and the current height */\\n         int min = 0;\\n         for(int i = 0;i < rungs.length ;i++){\\n             //current distance\\n             int cd = (i == 0) ? rungs[i] - 1 : rungs[i] - rungs[i - 1] - 1;\\n             int div = (cd / dist);\\n             min = min + div ;\\n         }\\n      return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352209,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int addRungs(int[] arr, int d) {\\n       int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            if(i==0){\\n                if(arr[i]>d){\\n                    if(arr[i]%d==0){\\n                ans+=(arr[i]/d)-1;\\n                    }\\n                    else{\\n                        ans+=(arr[i]/d);\\n                    }\\n                }\\n            }\\n            else{\\n                if(arr[i]>arr[i-1]+d){\\n                if((arr[i]-arr[i-1])%d==0){\\n                    ans+=((arr[i]-arr[i-1])/d)-1;\\n                }\\n                    else{\\n                    ans+=(arr[i]-arr[i-1])/d;\\n                }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] arr, int d) {\\n       int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            if(i==0){\\n                if(arr[i]>d){\\n                    if(arr[i]%d==0){\\n                ans+=(arr[i]/d)-1;\\n                    }\\n                    else{\\n                        ans+=(arr[i]/d);\\n                    }\\n                }\\n            }\\n            else{\\n                if(arr[i]>arr[i-1]+d){\\n                if((arr[i]-arr[i-1])%d==0){\\n                    ans+=((arr[i]-arr[i-1])/d)-1;\\n                }\\n                    else{\\n                    ans+=(arr[i]-arr[i-1])/d;\\n                }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349746,
                "title": "python-3-o-n-simple-solution",
                "content": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        L , count = 0\\n        for i in rungs:\\n            if (i - L) > dist:\\n                count += (i-L-1)//dist\\n            L = i\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        L , count = 0\\n        for i in rungs:\\n            if (i - L) > dist:\\n                count += (i-L-1)//dist\\n            L = i\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345954,
                "title": "c",
                "content": "class Solution {\\npublic:\\n        \\n    int addRungs(vector<int>& v, int dist) {\\n        \\n         int prev=0;\\n         int ans=0;  \\n            \\n         for(int i=0;i<v.size();i++){\\n             int x=(v[i]-prev)/dist;    \\n             ans+=x;\\n             if((v[i]-prev)%dist==0)ans--;    \\n             prev=v[i];    \\n         }   \\n            \\nreturn ans;     \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n        \\n    int addRungs(vector<int>& v, int dist) {\\n        \\n         int prev=0;\\n         int ans=0;  \\n            \\n         for(int i=0;i<v.size();i++){\\n             int x=(v[i]-prev)/dist;    \\n             ans+=x;\\n             if((v[i]-prev)%dist==0)ans--;    \\n             prev=v[i];    \\n         }",
                "codeTag": "Java"
            },
            {
                "id": 1345821,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int result = rungs[0] - 0 <= dist ? 0 : (rungs[0]-1)/dist;\\n        for(int i=1;i<rungs.length;i++)\\n            result += (rungs[i] - rungs[i-1] <= dist ? 0 : ((rungs[i] - rungs[i-1] - 1)/dist));\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int result = rungs[0] - 0 <= dist ? 0 : (rungs[0]-1)/dist;\\n        for(int i=1;i<rungs.length;i++)\\n            result += (rungs[i] - rungs[i-1] <= dist ? 0 : ((rungs[i] - rungs[i-1] - 1)/dist));\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345009,
                "title": "java-1ms-faster-than-100",
                "content": "class Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        \\n        int count=0;\\n        int hdiff=rungs[0]-0;\\n        count+=hdiff/dist;\\n        if(hdiff%dist==0){\\n            count--;\\n        }\\n        for(int i=0;i<rungs.length-1;i++){\\n            if(rungs[i]+dist>=rungs[i+1]){\\n                continue;\\n            }\\n            else{\\n                int diff=rungs[i+1]-rungs[i];\\n                count+=diff/dist;\\n                if(diff%dist==0){\\n                    count--;\\n                }                \\n            }\\n        }\\n        return count;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        \\n        int count=0;\\n        int hdiff=rungs[0]-0;\\n        count+=hdiff/dist;\\n        if(hdiff%dist==0){\\n            count--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1344976,
                "title": "java-solution-clean-code",
                "content": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i=0 ; i<rungs.length ; i++) {\\n\\t\\t\\tint d = (i==0) ? rungs[i] : rungs[i] - rungs[i-1];\\n\\t\\t\\tif ( d > dist ) {\\n\\t\\t\\t\\tans += d/dist;\\n\\t\\t\\t\\tans += ( d%dist == 0 ) ? -1 : 0; \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i=0 ; i<rungs.length ; i++) {\\n\\t\\t\\tint d = (i==0) ? rungs[i] : rungs[i] - rungs[i-1];\\n\\t\\t\\tif ( d > dist ) {\\n\\t\\t\\t\\tans += d/dist;\\n\\t\\t\\t\\tans += ( d%dist == 0 ) ? -1 : 0; \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344953,
                "title": "java-100-1ms",
                "content": "``\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        \\n        int i =0;\\n        int count = 0;\\n        \\n        if(rungs[0] > dist){\\n            \\n            count+= (int)((rungs[0])/dist);\\n            if((rungs[0])%dist == 0) count-=1;\\n        }\\n        for(i = 1; i< rungs.length;i++){\\n          \\n           if(rungs[i]-rungs[i-1] > dist){\\n                \\n                count+= (int) ((rungs[i]-rungs[i-1])/dist);\\n               if((rungs[i]-rungs[i-1])%dist == 0) count-=1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n``",
                "solutionTags": [],
                "code": "class Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        \\n        int i =0;\\n        int count = 0;\\n        \\n        if(rungs[0] > dist){\\n            \\n            count+= (int)((rungs[0])/dist);\\n            if((rungs[0])%dist == 0) count-=1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1344949,
                "title": "easy-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans=0;\\n        if(rungs[0]>dist)\\n        ans+=((rungs[0]-1)/dist);\\n        for(int i=1;i<rungs.size();i++)\\n        {\\n            if(rungs[i]-rungs[i-1]>dist)\\n            {\\n                ans+=(((rungs[i]-rungs[i-1])-1)/dist);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans=0;\\n        if(rungs[0]>dist)\\n        ans+=((rungs[0]-1)/dist);\\n        for(int i=1;i<rungs.size();i++)\\n        {\\n            if(rungs[i]-rungs[i-1]>dist)\\n            {\\n                ans+=(((rungs[i]-rungs[i-1])-1)/dist);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344915,
                "title": "best-simple-one-pass-solution-in-python",
                "content": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        height=0\\n        sol=0\\n        for r in rungs:\\n            if (r-height)%dist==0:\\n                sol+=(r-height)//dist-1\\n            else:\\n                sol+=(r-height)//dist\\n            height=r\\n        return sol\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        height=0\\n        sol=0\\n        for r in rungs:\\n            if (r-height)%dist==0:\\n                sol+=(r-height)//dist-1\\n            else:\\n                sol+=(r-height)//dist\\n            height=r\\n        return sol\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344912,
                "title": "c-very-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& r, int d) {\\n        int start = 0;\\n        int ans =0;\\n        for(int i=0;i<r.size();i++){\\n            int x = r[i];\\n            if(x-start>d){\\n                int p = (x-start)/d;\\n                if(start+(p*d)==x){\\n                    ans+=(p-1);\\n                }\\n                else{\\n                    ans+=p;\\n                }\\n            }\\n            start = x;\\n        }\\n        //cout<<ans;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& r, int d) {\\n        int start = 0;\\n        int ans =0;\\n        for(int i=0;i<r.size();i++){\\n            int x = r[i];\\n            if(x-start>d){\\n                int p = (x-start)/d;\\n                if(start+(p*d)==x){\\n                    ans+=(p-1);\\n                }\\n                else{\\n                    ans+=p;\\n                }\\n            }\\n            start = x;\\n        }\\n        //cout<<ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1344909,
                "title": "java-simple-sol",
                "content": "We have to handle edge cases explicitly here\\n```\\n public int addRungs(int[] arr, int dist) {\\n        int n=arr.length;\\n    \\n        int diff=0;\\n        int c=0;\\n        \\n        \\n        if(arr[0]>dist){   //if first element is itself greater than dist given\\n            \\n            if(arr[0]%dist==0) c+=arr[0]/dist-1;\\n            else c+=arr[0]/dist; \\n        }\\n        for(int i=1;i<n;i++){\\n            if(arr[i]-arr[i-1]>dist){\\n                diff=arr[i]-arr[i-1];\\n               if(diff%dist==0) \\n                  c+=diff/dist-1;\\n               else c+=diff/dist;\\n            }\\n            else continue;\\n            \\n        }\\n        return c;\\n       }",
                "solutionTags": [],
                "code": "We have to handle edge cases explicitly here\\n```\\n public int addRungs(int[] arr, int dist) {\\n        int n=arr.length;\\n    \\n        int diff=0;\\n        int c=0;\\n        \\n        \\n        if(arr[0]>dist){   //if first element is itself greater than dist given\\n            \\n            if(arr[0]%dist==0) c+=arr[0]/dist-1;\\n            else c+=arr[0]/dist; \\n        }\\n        for(int i=1;i<n;i++){\\n            if(arr[i]-arr[i-1]>dist){\\n                diff=arr[i]-arr[i-1];\\n               if(diff%dist==0) \\n                  c+=diff/dist-1;\\n               else c+=diff/dist;\\n            }\\n            else continue;\\n            \\n        }\\n        return c;\\n       }",
                "codeTag": "Unknown"
            },
            {
                "id": 1344882,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int previousNumber=0;\\n        int ans=0;\\n        for(auto n:rungs)\\n        {\\n            int gap=n-previousNumber;\\n            ans+=(gap-1)/dist;\\n            previousNumber=n;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int previousNumber=0;\\n        int ans=0;\\n        for(auto n:rungs)\\n        {\\n            int gap=n-previousNumber;\\n            ans+=(gap-1)/dist;\\n            previousNumber=n;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344876,
                "title": "a-few-solutions",
                "content": "Accumulate the count `cnt` of previous `pre` and current `cur` rung position differences `diff` divided by the distance threshold `T`, ie. this is the amount of rungs we need to add in between the previous and current rungs.\\n\\nNote: we subtract `1` from `diff`, since `cur` is non-inclusive for additional rungs (ie. there already exists a rung at `cur`, so we don\\'t need to add a rung at `cur` when `diff` exceeds the threshold `T`).\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun addRungs(A: IntArray, T: Int): Int {\\n        var cnt = 0\\n        var pre = 0\\n        for (cur in A) {\\n            var diff = cur - pre\\n            if (T < diff)\\n                cnt += (diff - 1) / T  // -1 since cur is non-inclusive\\n            pre = cur\\n        }\\n        return cnt\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet addRungs = (A, T, pre = 0, cnt = 0) => {\\n    for (let cur of A) {\\n        let diff = cur - pre;\\n        if (T < diff)\\n            cnt += Math.floor((diff - 1) / T);  // -1 since cur is non-inclusive\\n        pre = cur;\\n    }\\n    return cnt;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def addRungs(self, A: List[int], T: int, pre = 0, cnt = 0) -> int:\\n        for cur in A:\\n            diff = cur - pre\\n            if T < diff:\\n                cnt += (diff - 1) // T  # -1 since cur is non-inclusive\\n            pre = cur\\n        return cnt\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int addRungs(VI& A, int T, int pre = 0, int cnt = 0) {\\n        for (auto cur: A) {\\n            auto diff = cur - pre;\\n            if (T < diff) {\\n                cnt += (diff - 1) / T;  // -1 since cur is non-inclusive\\n            pre = cur;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun addRungs(A: IntArray, T: Int): Int {\\n        var cnt = 0\\n        var pre = 0\\n        for (cur in A) {\\n            var diff = cur - pre\\n            if (T < diff)\\n                cnt += (diff - 1) / T  // -1 since cur is non-inclusive\\n            pre = cur\\n        }\\n        return cnt\\n    }\\n}\\n```\n```\\nlet addRungs = (A, T, pre = 0, cnt = 0) => {\\n    for (let cur of A) {\\n        let diff = cur - pre;\\n        if (T < diff)\\n            cnt += Math.floor((diff - 1) / T);  // -1 since cur is non-inclusive\\n        pre = cur;\\n    }\\n    return cnt;\\n};\\n```\n```\\nclass Solution:\\n    def addRungs(self, A: List[int], T: int, pre = 0, cnt = 0) -> int:\\n        for cur in A:\\n            diff = cur - pre\\n            if T < diff:\\n                cnt += (diff - 1) // T  # -1 since cur is non-inclusive\\n            pre = cur\\n        return cnt\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int addRungs(VI& A, int T, int pre = 0, int cnt = 0) {\\n        for (auto cur: A) {\\n            auto diff = cur - pre;\\n            if (T < diff) {\\n                cnt += (diff - 1) / T;  // -1 since cur is non-inclusive\\n            pre = cur;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079318,
                "title": "simple-and-clear-python3-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` python3 []\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        result = 0\\n        prev = 0\\n        for elem in rungs:\\n            delta = elem - prev\\n            current = (delta - 1) // dist\\n            result += current\\n            prev = elem\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "``` python3 []\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        result = 0\\n        prev = 0\\n        for elem in rungs:\\n            delta = elem - prev\\n            current = (delta - 1) // dist\\n            result += current\\n            prev = elem\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075576,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def addRungs(self, rungs, dist):\\n        \"\"\"\\n        :type rungs: List[int]\\n        :type dist: int\\n        :rtype: int\\n        \"\"\"\\n        current_height = 0  # Start at the ground\\n        rungs_to_add = 0\\n\\n        for rung in rungs:\\n            gap = rung - current_height\\n            if gap > dist:\\n                rungs_to_add += (gap - 1) // dist\\n            current_height = rung\\n\\n        return rungs_to_add\\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def addRungs(self, rungs, dist):\\n        \"\"\"\\n        :type rungs: List[int]\\n        :type dist: int\\n        :rtype: int\\n        \"\"\"\\n        current_height = 0  # Start at the ground\\n        rungs_to_add = 0\\n\\n        for rung in rungs:\\n            gap = rung - current_height\\n            if gap > dist:\\n                rungs_to_add += (gap - 1) // dist\\n            current_height = rung\\n\\n        return rungs_to_add\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019664,
                "title": "simple-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int sum=0;\\n        rungs.insert(rungs.begin(),0);\\n        for(int i=0;i<rungs.size()-1;i++){\\n            int gap=rungs[i+1]-rungs[i];\\n            if(gap>dist){\\n            sum+=gap/dist + (gap%dist?0:-1);\\n            rungs[i+1] = max(rungs[i+1],rungs[i]+ (gap/dist + (gap%dist?0:-1))*dist);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int sum=0;\\n        rungs.insert(rungs.begin(),0);\\n        for(int i=0;i<rungs.size()-1;i++){\\n            int gap=rungs[i+1]-rungs[i];\\n            if(gap>dist){\\n            sum+=gap/dist + (gap%dist?0:-1);\\n            rungs[i+1] = max(rungs[i+1],rungs[i]+ (gap/dist + (gap%dist?0:-1))*dist);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017086,
                "title": "easy-approach-100-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int curr = 0;\\n        int cnt = 0; \\n        int n = rungs.size();\\n\\n        if(n==1){\\n            return (dist>rungs[0]) ? 0:((rungs[0]-1)/dist);\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int gap = rungs[i]-curr;\\n            if(gap>dist){\\n                cnt+= (gap-1)/dist;\\n            }\\n            curr = rungs[i];\\n        }\\n        return cnt;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int curr = 0;\\n        int cnt = 0; \\n        int n = rungs.size();\\n\\n        if(n==1){\\n            return (dist>rungs[0]) ? 0:((rungs[0]-1)/dist);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3999377,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int addRungs(vector<int>& rungs, int dist) {\\n    int ans = 0;\\n    int prev = 0;\\n\\n    for (const int rung : rungs) {\\n      ans += (rung - prev - 1) / dist;\\n      prev = rung;\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int addRungs(vector<int>& rungs, int dist) {\\n    int ans = 0;\\n    int prev = 0;\\n\\n    for (const int rung : rungs) {\\n      ans += (rung - prev - 1) / dist;\\n      prev = rung;\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947917,
                "title": "java-o-n-100-faster",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int count = 0, prev = 0;\\n        for (int i = 0; i < rungs.length; i++) {\\n            int diff = rungs[i] - prev;\\n            prev = rungs[i];\\n            if (diff > dist) count += diff % dist == 0 ? (diff / dist) - 1 : diff / dist;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int count = 0, prev = 0;\\n        for (int i = 0; i < rungs.length; i++) {\\n            int diff = rungs[i] - prev;\\n            prev = rungs[i];\\n            if (diff > dist) count += diff % dist == 0 ? (diff / dist) - 1 : diff / dist;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898885,
                "title": "easy-to-understand-c-solution",
                "content": "# Approach\\nDifference = (rungs at each i - previous rung) if this is divisible by dist they we required one less rung, if not add the difference / dist and move to the next rung of the ladder.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int cnt = 0;\\n        int intial = 0;\\n        int n = rungs.size();\\n        for(int i=0;i<n;i++){\\n            int diff = rungs[i] - intial;\\n            if(diff > dist){\\n                if(diff%dist == 0) cnt--;\\n                cnt += diff/ dist;\\n            }\\n            intial = rungs[i];\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n##### Kindly UpVote",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int cnt = 0;\\n        int intial = 0;\\n        int n = rungs.size();\\n        for(int i=0;i<n;i++){\\n            int diff = rungs[i] - intial;\\n            if(diff > dist){\\n                if(diff%dist == 0) cnt--;\\n                cnt += diff/ dist;\\n            }\\n            intial = rungs[i];\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896476,
                "title": "mathematical-java-solution-o-n-time-o-1-space-complexity",
                "content": "# Intuition\\nWhen solving this problem. It is paramount to understand that odd and even numbers behave differently. \\n\\n# Approach\\nWhat I did was I realized that, after putting together some data, that if the distance between two rungs that could not be reached, was even or odd. I realized that this mattered for odd and even distances because if the distance was even, then you needed to take into account if \\'dist\\' went into the rung evenly or not.\\n\\nIf it did, you needed to subtract one from the amount of rungs you needed to add, because the equation (rungs[i] - rung)/dist would account for how many steps it would take to get to your destination, including the step of your destination. \\n\\nIf (rungs[i] - rung) was odd, you didn\\'t need to take this into account, due to the nature that odd numbers behave in, you don\\'t need to take into account whether dist will go evenly into your destination rung.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nimport java.util.ArrayList;\\n\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int num = 0;\\n        int rung = 0;\\n\\n        for(int i=0; i<rungs.length; i++) {\\n            if(rungs[i] - rung > dist) {\\n                if(dist == 1) \\n                    num += ((rungs[i] - rung)/dist) - 1;\\n                else if((rungs[i]-rung)%2 == 1) \\n                    num += (rungs[i] - rung)/dist;\\n                else {\\n                    if((rungs[i]-rung) % dist != 0) \\n                        num += ((rungs[i] - rung)/dist);\\n                    else \\n                        num += (rungs[i] - rung)/dist-1;\\n                }\\n            } \\n            rung = rungs[i];\\n        }\\n\\n        return num;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.ArrayList;\\n\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int num = 0;\\n        int rung = 0;\\n\\n        for(int i=0; i<rungs.length; i++) {\\n            if(rungs[i] - rung > dist) {\\n                if(dist == 1) \\n                    num += ((rungs[i] - rung)/dist) - 1;\\n                else if((rungs[i]-rung)%2 == 1) \\n                    num += (rungs[i] - rung)/dist;\\n                else {\\n                    if((rungs[i]-rung) % dist != 0) \\n                        num += ((rungs[i] - rung)/dist);\\n                    else \\n                        num += (rungs[i] - rung)/dist-1;\\n                }\\n            } \\n            rung = rungs[i];\\n        }\\n\\n        return num;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874846,
                "title": "medium",
                "content": "# Intuition : \\nNothing checking we can jump to next positio or not \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int ans=0;\\n        int curr=0;\\n        for(int i=0;i<rungs.length;i++){\\n            int diff=rungs[i]-curr-1;\\n            if(diff>=dist)\\n            ans+=diff/dist;\\n            curr=rungs[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int ans=0;\\n        int curr=0;\\n        for(int i=0;i<rungs.length;i++){\\n            int diff=rungs[i]-curr-1;\\n            if(diff>=dist)\\n            ans+=diff/dist;\\n            curr=rungs[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854016,
                "title": "c-just-think",
                "content": "# Intuition\\nHow high from a particular index(i) can u go that is the question ? \\n\\n# Approach\\n\\nIf you\\'ll think carefully then you will see from arr[i] you can for to arr[i+1] always. SOOOO just count the steps require to move from i --> i + 1. which is ceil((arr[i] - arr[i - 1])/ k) steps (floot makes it complicated). \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& arr, int k) {\\n        int len = arr.size();\\n        int ans = 0;\\n\\n        ans = ans + ceil(arr[0] / (1.0* k)) - 1;\\n        for(int i = 1; i < len; i++){\\n            ans = ans + ceil((arr[i] - arr[i - 1])/ (1.0* k)) - 1;\\n        }\\n\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& arr, int k) {\\n        int len = arr.size();\\n        int ans = 0;\\n\\n        ans = ans + ceil(arr[0] / (1.0* k)) - 1;\\n        for(int i = 1; i < len; i++){\\n            ans = ans + ceil((arr[i] - arr[i - 1])/ (1.0* k)) - 1;\\n        }\\n\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842083,
                "title": "easy-c-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& v, int d) {\\n        int count=0;\\n        int n=v.size();\\n        for(int i=n-2;i>=0;i--){\\n            int k=(v[i+1]-v[i])/d;\\n            if((v[i+1]-v[i])%d>0) k++;\\n            if(k>0) count+=k-1;\\n        }\\n        int k=(v[0]-0)/d;\\n        if((v[0]-0)%d>0) k++;\\n        if(k>0) count+=k-1;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& v, int d) {\\n        int count=0;\\n        int n=v.size();\\n        for(int i=n-2;i>=0;i--){\\n            int k=(v[i+1]-v[i])/d;\\n            if((v[i+1]-v[i])%d>0) k++;\\n            if(k>0) count+=k-1;\\n        }\\n        int k=(v[0]-0)/d;\\n        if((v[0]-0)%d>0) k++;\\n        if(k>0) count+=k-1;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793003,
                "title": "java-100-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int result = 0;\\n\\n        int currentHeight = 0;\\n\\n        for (int i = 0; i < rungs.length; i++) {\\n            int dif = rungs[i] - currentHeight;\\n            if (dif > dist) {\\n                result += (dif - 1) / dist;\\n            }\\n            currentHeight = rungs[i];\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int result = 0;\\n\\n        int currentHeight = 0;\\n\\n        for (int i = 0; i < rungs.length; i++) {\\n            int dif = rungs[i] - currentHeight;\\n            if (dif > dist) {\\n                result += (dif - 1) / dist;\\n            }\\n            currentHeight = rungs[i];\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787361,
                "title": "83-faster-easy-c-solution-with-explanation-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int addRungs(vector<int> &rungs, int dist)\\n    {\\n        int n = rungs.size();\\n        int height = 0; // Initially on the floor\\n        int ans = 0;    // Total no. of rungs to be added\\n\\n        int i = 0; // tracks the rungs already present\\n\\n        if (dist < rungs[i])\\n            ans += ceil(double(rungs[i] - 0) / double(dist)) - 1; // No. of rungs required to climb the first rung\\n\\n        height = rungs[i]; // reached the first rung\\n\\n        i++;\\n        while (i < n)\\n        {\\n            if (height + dist < rungs[i])\\n            {\\n                int temp = ceil(double(rungs[i] - rungs[i - 1]) / double(dist)) - 1; // No. of rungs required to move from (i-1)th to ith\\n                ans += temp;\\n                height = rungs[i]; // reached the ith rung\\n            }\\n\\n            else\\n            {\\n                height = rungs[i];\\n                i++; // reached the ith rung\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int addRungs(vector<int> &rungs, int dist)\\n    {\\n        int n = rungs.size();\\n        int height = 0; // Initially on the floor\\n        int ans = 0;    // Total no. of rungs to be added\\n\\n        int i = 0; // tracks the rungs already present\\n\\n        if (dist < rungs[i])\\n            ans += ceil(double(rungs[i] - 0) / double(dist)) - 1; // No. of rungs required to climb the first rung\\n\\n        height = rungs[i]; // reached the first rung\\n\\n        i++;\\n        while (i < n)\\n        {\\n            if (height + dist < rungs[i])\\n            {\\n                int temp = ceil(double(rungs[i] - rungs[i - 1]) / double(dist)) - 1; // No. of rungs required to move from (i-1)th to ith\\n                ans += temp;\\n                height = rungs[i]; // reached the ith rung\\n            }\\n\\n            else\\n            {\\n                height = rungs[i];\\n                i++; // reached the ith rung\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778731,
                "title": "simple-solution-o-n",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} rungs\\n * @param {number} dist\\n * @return {number}\\n */\\nvar addRungs = function(rungs, dist) {\\n    let curr = 0\\n    let addition = 0\\n    for (const r of rungs){\\n        addition += Math.ceil((r - curr) / dist) - 1\\n        curr = r\\n    }\\n    return addition\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} rungs\\n * @param {number} dist\\n * @return {number}\\n */\\nvar addRungs = function(rungs, dist) {\\n    let curr = 0\\n    let addition = 0\\n    for (const r of rungs){\\n        addition += Math.ceil((r - curr) / dist) - 1\\n        curr = r\\n    }\\n    return addition\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3718862,
                "title": "python3-4-lines-only-yep-a-bit-tricky-ones",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        rung, result = 0, 0\\n        for r in rungs:\\n            rung, result = r, result if r - rung <= dist else result + ((r - rung) // dist + (-1 if (r - rung) % dist == 0 else 0))\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        rung, result = 0, 0\\n        for r in rungs:\\n            rung, result = r, result if r - rung <= dist else result + ((r - rung) // dist + (-1 if (r - rung) % dist == 0 else 0))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714719,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $rungs\\n     * @param Integer $dist\\n     * @return Integer\\n     */\\n    function addRungs($rungs, $dist) {\\n        ## returned value\\n        $count = 0;\\n\\n        #including 0 ( the floor ) in all cases. We start at 0 everytime.\\n        $rungs = [0, ...$rungs];\\n\\n        # iterate in array using two variables for N and N+1.\\n        for($i = 0, $j = 1; $j < count($rungs) ; $i++, $j++){\\n\\n            #get the diff of the values. ( N+1 - N)\\n            $diff = $rungs[$j] - $rungs[$i];\\n\\n            #if the diff > dist we need add a new rung\\n            if($diff > $dist){\\n\\n              #The amount of rungs is: the difference / dist - 1;\\n              # Example: N = 0\\n              # N + 1 = 9\\n              # Dist= 4\\n              # We cant reach 9. So, we add a rung in max height possible: N + 4;\\n              # Now we have [0, 4, 9]\\n              # We cant reach 9. So we add one more in max height: 4 + 4 = 8;\\n              # What we are doing is the same of divide the diff for the dist. In some cases, the number isn\\'t integer ( 9 / 2 ). So, we ceil.\\n              # We cant include the inital value, so we subtract 1.\\n              $count += ceil($diff/$dist) - 1;\\n            }\\n        }\\n        return $count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $rungs\\n     * @param Integer $dist\\n     * @return Integer\\n     */\\n    function addRungs($rungs, $dist) {\\n        ## returned value\\n        $count = 0;\\n\\n        #including 0 ( the floor ) in all cases. We start at 0 everytime.\\n        $rungs = [0, ...$rungs];\\n\\n        # iterate in array using two variables for N and N+1.\\n        for($i = 0, $j = 1; $j < count($rungs) ; $i++, $j++){\\n\\n            #get the diff of the values. ( N+1 - N)\\n            $diff = $rungs[$j] - $rungs[$i];\\n\\n            #if the diff > dist we need add a new rung\\n            if($diff > $dist){\\n\\n              #The amount of rungs is: the difference / dist - 1;\\n              # Example: N = 0\\n              # N + 1 = 9\\n              # Dist= 4\\n              # We cant reach 9. So, we add a rung in max height possible: N + 4;\\n              # Now we have [0, 4, 9]\\n              # We cant reach 9. So we add one more in max height: 4 + 4 = 8;\\n              # What we are doing is the same of divide the diff for the dist. In some cases, the number isn\\'t integer ( 9 / 2 ). So, we ceil.\\n              # We cant include the inital value, so we subtract 1.\\n              $count += ceil($diff/$dist) - 1;\\n            }\\n        }\\n        return $count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669335,
                "title": "simple-java-solution-1-ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int extraRungs = 0;\\n        int currentRung = 0;\\n        for (int i = 0; i < rungs.length; i++) {\\n            if (currentRung + dist < rungs[i]) {\\n                extraRungs += ((rungs[i] - currentRung - 1) / dist);\\n            }\\n            currentRung = rungs[i];\\n        }\\n        return extraRungs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int extraRungs = 0;\\n        int currentRung = 0;\\n        for (int i = 0; i < rungs.length; i++) {\\n            if (currentRung + dist < rungs[i]) {\\n                extraRungs += ((rungs[i] - currentRung - 1) / dist);\\n            }\\n            currentRung = rungs[i];\\n        }\\n        return extraRungs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638217,
                "title": "c-i-bet-you-will-understand-easy-and-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIterating over the array first finding the required number of rings.\\nAfter that from height 0 to the height of first ring we find the required number of rings.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ct=0;\\n        for(int i=0;i<rungs.size()-1;i++){\\n            int ans1=rungs[i+1]-rungs[i];\\n            int temp=ans1/dist;\\n            if(ans1%dist!=0){\\n                temp++;\\n            }\\n            ct+=(temp-1);\\n        }\\n        int rest_sum=rungs[0];\\n        int rest_temp=rest_sum/dist;\\n        if(rest_sum%dist!=0){\\n                rest_temp++;\\n        }\\n        ct+=(rest_temp-1);\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ct=0;\\n        for(int i=0;i<rungs.size()-1;i++){\\n            int ans1=rungs[i+1]-rungs[i];\\n            int temp=ans1/dist;\\n            if(ans1%dist!=0){\\n                temp++;\\n            }\\n            ct+=(temp-1);\\n        }\\n        int rest_sum=rungs[0];\\n        int rest_temp=rest_sum/dist;\\n        if(rest_sum%dist!=0){\\n                rest_temp++;\\n        }\\n        ct+=(rest_temp-1);\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580735,
                "title": "stack-solution-gave-tle-so-tried-one-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int k) {\\n        vector<int> lad;\\n        stack<int> st;\\n            st.push(0);        \\n        int i=0;\\n        int c = 0;\\n        // while(i<rungs.size()){\\n\\n        //     if(k+st.top()>=rungs[i]){\\n        //         st.push(rungs[i]);\\n        //         i++;\\n        //     }else{\\n        //         st.push(st.top()+k);\\n        //     }\\n\\n        // }\\n        if(0+k<rungs[0]){\\n              c+=(ceil)((rungs[0]-1)/k);\\n        }\\n        for(int i=0;i<rungs.size()-1;i++){\\n            if(rungs[i]+k>=rungs[i+1]){\\n\\n            }else{\\n                c+=(ceil)((rungs[i+1] - rungs[i]-1)/k);\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int k) {\\n        vector<int> lad;\\n        stack<int> st;\\n            st.push(0);        \\n        int i=0;\\n        int c = 0;\\n        // while(i<rungs.size()){\\n\\n        //     if(k+st.top()>=rungs[i]){\\n        //         st.push(rungs[i]);\\n        //         i++;\\n        //     }else{\\n        //         st.push(st.top()+k);\\n        //     }\\n\\n        // }\\n        if(0+k<rungs[0]){\\n              c+=(ceil)((rungs[0]-1)/k);\\n        }\\n        for(int i=0;i<rungs.size()-1;i++){\\n            if(rungs[i]+k>=rungs[i+1]){\\n\\n            }else{\\n                c+=(ceil)((rungs[i+1] - rungs[i]-1)/k);\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571208,
                "title": "python3-very-easy-7-lines-code-o-n-beginner-friendly-sece-cbe",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        c=0\\n        if(rungs[0]>dist):\\n            c+=((rungs[0]-1)//dist)\\n        for i in range(len(rungs)-1):\\n            if((rungs[i+1]-rungs[i]) > dist):\\n                if((rungs[i+1]-rungs[i])>dist):\\n                    c+= (rungs[i+1]-rungs[i])//dist if ((rungs[i+1]-rungs[i])%dist >= 1) else ((rungs[i+1]-rungs[i])//dist)-1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        c=0\\n        if(rungs[0]>dist):\\n            c+=((rungs[0]-1)//dist)\\n        for i in range(len(rungs)-1):\\n            if((rungs[i+1]-rungs[i]) > dist):\\n                if((rungs[i+1]-rungs[i])>dist):\\n                    c+= (rungs[i+1]-rungs[i])//dist if ((rungs[i+1]-rungs[i])%dist >= 1) else ((rungs[i+1]-rungs[i])//dist)-1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569426,
                "title": "simple-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    iterarte through each step and find diff\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        \\n        int n=rungs.size();\\n        int count=0;\\n        \\n            if(rungs[0]>dist)\\n                count+=(rungs[0]-1)/dist;\\n            \\n\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int diff=rungs[i+1]-rungs[i];\\n\\n            if(diff>dist)\\n            {\\n                count+=(diff-1)/dist;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        \\n        int n=rungs.size();\\n        int count=0;\\n        \\n            if(rungs[0]>dist)\\n                count+=(rungs[0]-1)/dist;\\n            \\n\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int diff=rungs[i+1]-rungs[i];\\n\\n            if(diff>dist)\\n            {\\n                count+=(diff-1)/dist;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530053,
                "title": "java-greedy-100-faster-intuition-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n```\\nintuition here is,\\n        initially we are standing at height = 0 ==> prevHeight = 0\\n        and from some prevHeight we need to cover a \\'dist\\' to reach the rungs[i],\\n        if there is prevHeight + dist >= rungs[i] then it is good we can reach our\\n        rungs[i] as we have covered plenty of range from [prevHeight, prevHeight + dist] \\n        as prevHeight < rungs[i] <= (prevHeight + dist)\\n        \\n        BUT \\n        \\n        if our prevHeight + dist < rungs[i] we don\\'t have much range to reach our\\n        rungs[i] so what we have to do is to add new rungs in between prevHeight\\n        and rungs[i] so to calculate that \\n        dest = rungs[i]\\n        src = prevHeight\\n        adjust = -1 \"adjust\", why? \\n        because, as we need to reach to dest from our src and we also know that\\n        we definitely have dest == rungs[i] available so we don\\'t need to count\\n        the dest rungs but those required in between thats why!!!\\n        \\n        so with this we need to cover a \\'total-length\\' of (dest - src - 1) between src & dest\\n        so how many rungs would be reuired to cover this \\'total-length\\' provided that we can\\n        move by dist \\'dist\\', then rungs required would be (\\'total-length\\' / \\'dist\\')\\n        \\n        hence, number of rungs required to add\\n        ==> addedRungs = ((dest - src - 1) / dist);\\n        ==> ((rungs[i] - prevHeight - 1) / dist)\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N), N is length of rungs[] arrays\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1), only few varibles are used\\n\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int n = rungs.length;\\n        int prevHeight = 0;\\n        int added = 0;\\n        for(int i = 0; i < n; i++){\\n            if(prevHeight + dist < rungs[i]) {\\n                added += ((rungs[i] - prevHeight - 1) / dist);\\n            }\\n            prevHeight = rungs[i];\\n        }\\n        return added;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nintuition here is,\\n        initially we are standing at height = 0 ==> prevHeight = 0\\n        and from some prevHeight we need to cover a \\'dist\\' to reach the rungs[i],\\n        if there is prevHeight + dist >= rungs[i] then it is good we can reach our\\n        rungs[i] as we have covered plenty of range from [prevHeight, prevHeight + dist] \\n        as prevHeight < rungs[i] <= (prevHeight + dist)\\n        \\n        BUT \\n        \\n        if our prevHeight + dist < rungs[i] we don\\'t have much range to reach our\\n        rungs[i] so what we have to do is to add new rungs in between prevHeight\\n        and rungs[i] so to calculate that \\n        dest = rungs[i]\\n        src = prevHeight\\n        adjust = -1 \"adjust\", why? \\n        because, as we need to reach to dest from our src and we also know that\\n        we definitely have dest == rungs[i] available so we don\\'t need to count\\n        the dest rungs but those required in between thats why!!!\\n        \\n        so with this we need to cover a \\'total-length\\' of (dest - src - 1) between src & dest\\n        so how many rungs would be reuired to cover this \\'total-length\\' provided that we can\\n        move by dist \\'dist\\', then rungs required would be (\\'total-length\\' / \\'dist\\')\\n        \\n        hence, number of rungs required to add\\n        ==> addedRungs = ((dest - src - 1) / dist);\\n        ==> ((rungs[i] - prevHeight - 1) / dist)\\n```\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int n = rungs.length;\\n        int prevHeight = 0;\\n        int added = 0;\\n        for(int i = 0; i < n; i++){\\n            if(prevHeight + dist < rungs[i]) {\\n                added += ((rungs[i] - prevHeight - 1) / dist);\\n            }\\n            prevHeight = rungs[i];\\n        }\\n        return added;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478681,
                "title": "c-solution-in-linear-time-without-extra-storage",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\npublic class Solution {\\n    public int AddRungs(int[] rungs, int dist) {\\n        int cur = 0, res = 0;\\n        for(int i = 0; i < rungs.Length;i++){\\n            res+= (rungs[i] - cur - 1) / dist;\\n            cur = rungs[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Greedy"
                ],
                "code": "```\\npublic class Solution {\\n    public int AddRungs(int[] rungs, int dist) {\\n        int cur = 0, res = 0;\\n        for(int i = 0; i < rungs.Length;i++){\\n            res+= (rungs[i] - cur - 1) / dist;\\n            cur = rungs[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477591,
                "title": "easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) \\n    {\\n        int prev=0, cnt=0;\\n        for(auto r: rungs)\\n        {\\n            int diff=r-prev;\\n            if(diff%dist==0) cnt+=diff/dist-1;\\n            else cnt+=diff/dist;\\n            prev=r;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) \\n    {\\n        int prev=0, cnt=0;\\n        for(auto r: rungs)\\n        {\\n            int diff=r-prev;\\n            if(diff%dist==0) cnt+=diff/dist-1;\\n            else cnt+=diff/dist;\\n            prev=r;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473601,
                "title": "java-simple-code-beats-100-92",
                "content": "```\\n    public int addRungs(int[] rungs, int dist) {\\n        int res=0, pos=0;\\n        for (int i=0;i<rungs.length;i++){\\n            var val = rungs[i];\\n            if (val-pos>dist){\\n                var diff = val-pos;\\n                res+= diff%dist==0?diff/dist-1:diff/dist;\\n            }\\n            pos=val;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int addRungs(int[] rungs, int dist) {\\n        int res=0, pos=0;\\n        for (int i=0;i<rungs.length;i++){\\n            var val = rungs[i];\\n            if (val-pos>dist){\\n                var diff = val-pos;\\n                res+= diff%dist==0?diff/dist-1:diff/dist;\\n            }\\n            pos=val;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3458818,
                "title": "c-golang-greedy",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans = (rungs[0] - 1) / dist;\\n        for(int i = 1; i < rungs.size(); i++) {\\n            ans += (rungs[i] - rungs[i - 1] - 1) / dist;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc addRungs(rungs []int, dist int) int {\\n    var ans int = (rungs[0] - 1) / dist\\n    for i := 1; i < len(rungs); i++ {\\n        ans += (rungs[i] - rungs[i - 1] - 1) / dist\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Greedy"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans = (rungs[0] - 1) / dist;\\n        for(int i = 1; i < rungs.size(); i++) {\\n            ans += (rungs[i] - rungs[i - 1] - 1) / dist;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc addRungs(rungs []int, dist int) int {\\n    var ans int = (rungs[0] - 1) / dist\\n    for i := 1; i < len(rungs); i++ {\\n        ans += (rungs[i] - rungs[i - 1] - 1) / dist\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446440,
                "title": "python3-clean-and-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        \\n        rungs=[0]+rungs\\n        ans=0\\n        \\n        for i in range(len(rungs)-1):\\n            diff=rungs[i+1]-rungs[i]\\n            if diff<=dist:\\n                continue\\n            \\n            ans+=(diff-1)//dist\\n        \\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        \\n        rungs=[0]+rungs\\n        ans=0\\n        \\n        for i in range(len(rungs)-1):\\n            diff=rungs[i+1]-rungs[i]\\n            if diff<=dist:\\n                continue\\n            \\n            ans+=(diff-1)//dist\\n        \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430578,
                "title": "c-best-solution-explained-in-easy-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs given array is increasing in nature, So we just need to see the difference between then and number count minumum number of rungs we can keep in between them.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor example : If we have to go from 3 to 6 and distance given is 1\\nWe just need 2 rungs no need to keep 3 rungs in between them\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        \\n        int ans=0,val=0,n=rungs.size();\\n        for(int i=0;i<n;i++){\\n            //This is difference between two rungs\\n            int diff=rungs[i]-val;\\n            if(diff > dist){\\n                int toBeAdded=diff/dist;\\n\\n                //if difference is exactly divisible by distance then you can remove one rungs in between them to minimix your answer\\n                /*\\n                    For example : If we have to go from 3 to 6 and distance given is 1\\n                    We just need 2 rungs no need to keep 3 rungs in between them\\n                */\\n                if(diff % dist==0) toBeAdded--;\\n                ans+=toBeAdded;\\n            }\\n            //val is temporary variable taking previous rungs value\\n            val=rungs[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        \\n        int ans=0,val=0,n=rungs.size();\\n        for(int i=0;i<n;i++){\\n            //This is difference between two rungs\\n            int diff=rungs[i]-val;\\n            if(diff > dist){\\n                int toBeAdded=diff/dist;\\n\\n                //if difference is exactly divisible by distance then you can remove one rungs in between them to minimix your answer\\n                /*\\n                    For example : If we have to go from 3 to 6 and distance given is 1\\n                    We just need 2 rungs no need to keep 3 rungs in between them\\n                */\\n                if(diff % dist==0) toBeAdded--;\\n                ans+=toBeAdded;\\n            }\\n            //val is temporary variable taking previous rungs value\\n            val=rungs[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396637,
                "title": "100-fast-easy-java-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n         \\n        int curr=0;       //created a pointer for the element at ground\\n        int i=0;\\n        int count=0;      //variable for taking count of rungs required\\n        while(i<rungs.length) //made a loop which will run to iterate the values\\n        {\\n            if(rungs[i]-curr<=dist) //if the value is satisfied then do nothing\\n            {\\n                curr=rungs[i];\\n                \\n                \\n            }\\n            else. //else we will see the difference between those two rungs where value is not satisified and if the difference is divisible by the dist then we will do -1 bcuz since it is a distance bwteen two numbers else we will take floor value.\\n            {\\n                int val=0;\\n                if((rungs[i]-curr)%dist==0)\\n                {\\n                        val=(rungs[i]-curr)/dist-1;\\n                }\\n                else\\n                {\\n                    val=(int)Math.floor((rungs[i]-curr)/dist);\\n                }\\n                 count=count+val;\\n                \\n                  curr=rungs[i];\\n               \\n\\n            }\\n          \\n            i++; //increment to proceed further\\n        }\\n        return count; //count of rungs required\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n         \\n        int curr=0;       //created a pointer for the element at ground\\n        int i=0;\\n        int count=0;      //variable for taking count of rungs required\\n        while(i<rungs.length) //made a loop which will run to iterate the values\\n        {\\n            if(rungs[i]-curr<=dist) //if the value is satisfied then do nothing\\n            {\\n                curr=rungs[i];\\n                \\n                \\n            }\\n            else. //else we will see the difference between those two rungs where value is not satisified and if the difference is divisible by the dist then we will do -1 bcuz since it is a distance bwteen two numbers else we will take floor value.\\n            {\\n                int val=0;\\n                if((rungs[i]-curr)%dist==0)\\n                {\\n                        val=(rungs[i]-curr)/dist-1;\\n                }\\n                else\\n                {\\n                    val=(int)Math.floor((rungs[i]-curr)/dist);\\n                }\\n                 count=count+val;\\n                \\n                  curr=rungs[i];\\n               \\n\\n            }\\n          \\n            i++; //increment to proceed further\\n        }\\n        return count; //count of rungs required\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359003,
                "title": "c",
                "content": "```\\nint addRungs(int* rungs, int rungsSize, int dist){\\n    int ret = 0 ;\\n    ret += (rungs[0]-1) / dist ;\\n    for(int i = 1; i < rungsSize; i++){\\n        int gap = rungs[i] - rungs[i-1] ;\\n        ret += (gap-1)/dist ;\\n    }\\n    return ret ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint addRungs(int* rungs, int rungsSize, int dist){\\n    int ret = 0 ;\\n    ret += (rungs[0]-1) / dist ;\\n    for(int i = 1; i < rungsSize; i++){\\n        int gap = rungs[i] - rungs[i-1] ;\\n        ret += (gap-1)/dist ;\\n    }\\n    return ret ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3337773,
                "title": "python-3-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        last = 0\\n        res = 0\\n        for x in rungs:\\n            res += (x - last-1)//dist\\n            last = x\\n        return res\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        last = 0\\n        res = 0\\n        for x in rungs:\\n            res += (x - last-1)//dist\\n            last = x\\n        return res\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320637,
                "title": "easy-to-understand-java-solution",
                "content": "![c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg](https://assets.leetcode.com/users/images/929d63af-ad34-4c9f-9657-b23a867a3f5b_1679327963.848759.jpeg)\\n\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int a=0;\\n        int c = 0;\\n        for(int i:rungs){\\n            a += ((i-c-1)/dist); \\n            c = i;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int a=0;\\n        int c = 0;\\n        for(int i:rungs){\\n            a += ((i-c-1)/dist); \\n            c = i;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248769,
                "title": "python3-easy-o-n",
                "content": "\\n# Explanation:\\nWe iterate through the rungs one by one and check if the distance between the current rung and the previous rung is greater than the given distance. If it is, we calculate the number of rungs that need to be added in between the two rungs to maintain the given distance. We add this count to our total count of rungs to be added. Finally, we update the start position to be the current rung and move on to the next rung. At the end, we return the total count of rungs to be added.\\n\\n# Time Complexity:\\nThe time complexity of this approach is O(n) as we iterate through the entire array once.\\n\\n# Space Complexity:\\nThe space complexity of this approach is O(1) as we only use a constant amount of extra space to keep track of the current position and the total count of rungs to be added.\\n\\n# Code\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        count = 0\\n        start = 0\\n        i = 0\\n        while i < len(rungs):\\n            cur_rung = rungs[i]\\n            if cur_rung - start > dist:\\n                count += (cur_rung - start - 1) // dist\\n            start = cur_rung\\n            i += 1\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        count = 0\\n        start = 0\\n        i = 0\\n        while i < len(rungs):\\n            cur_rung = rungs[i]\\n            if cur_rung - start > dist:\\n                count += (cur_rung - start - 1) // dist\\n            start = cur_rung\\n            i += 1\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3245711,
                "title": "beginner-friendly-solution-c-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nH:(-1 for one less step or plank.)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int n=rungs.size();\\n     int cnt=0;\\n      cnt+=(rungs[0]-1)/dist;\\n     for(int i=0;i<n-1;i++)\\n     {\\n        \\n            cnt+=(rungs[i+1]-rungs[i]-1)/dist;\\n        \\n     }\\n\\n     \\n    return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int n=rungs.size();\\n     int cnt=0;\\n      cnt+=(rungs[0]-1)/dist;\\n     for(int i=0;i<n-1;i++)\\n     {\\n        \\n            cnt+=(rungs[i+1]-rungs[i]-1)/dist;\\n        \\n     }\\n\\n     \\n    return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223152,
                "title": "python-ceil-distance-gaps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        rungs=[0]+rungs\\n        i,ans=1,0\\n        while i<len(rungs): \\n            if rungs[i]-rungs[i-1] > dist:\\n                ans+=ceil((rungs[i]-rungs[i-1])/dist)-1\\n            i+=1\\n        return ans\\n\\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        rungs=[0]+rungs\\n        i,ans=1,0\\n        while i<len(rungs): \\n            if rungs[i]-rungs[i-1] > dist:\\n                ans+=ceil((rungs[i]-rungs[i-1])/dist)-1\\n            i+=1\\n        return ans\\n\\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3191131,
                "title": "100-1ms-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int cur =0;\\n        int res =0;\\n        for(int n:rungs){\\n            if(n-cur>dist){\\n                int q = (n-cur-1)/dist;\\n            \\n                res += q;\\n            \\n            }\\n            cur = n;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int cur =0;\\n        int res =0;\\n        for(int n:rungs){\\n            if(n-cur>dist){\\n                int q = (n-cur-1)/dist;\\n            \\n                res += q;\\n            \\n            }\\n            cur = n;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188468,
                "title": "c-clean-short-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int c=0;\\n        if(rungs[0]>dist)\\n        {c+=rungs[0]/dist;\\n        if(rungs[0]%dist==0)\\n        c--;\\n        }\\n        for(int i=1;i<rungs.size();i++)\\n        {    int d=rungs[i]-rungs[i-1];\\n            if(d>dist)\\n            {\\n             c+=d/dist;\\n             if(d%dist==0)\\n             c--;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int c=0;\\n        if(rungs[0]>dist)\\n        {c+=rungs[0]/dist;\\n        if(rungs[0]%dist==0)\\n        c--;\\n        }\\n        for(int i=1;i<rungs.size();i++)\\n        {    int d=rungs[i]-rungs[i-1];\\n            if(d>dist)\\n            {\\n             c+=d/dist;\\n             if(d%dist==0)\\n             c--;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186165,
                "title": "java-simple-solution-greedy-approach",
                "content": "# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int ans = 0;\\n        int curr=0;\\n        int n = rungs.length;\\n        for(int i=0;i<n;i++){\\n            if((rungs[i]-curr-1)/dist>0) \\n                ans += (rungs[i]-curr-1)/dist;\\n            curr = rungs[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int ans = 0;\\n        int curr=0;\\n        int n = rungs.length;\\n        for(int i=0;i<n;i++){\\n            if((rungs[i]-curr-1)/dist>0) \\n                ans += (rungs[i]-curr-1)/dist;\\n            curr = rungs[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182461,
                "title": "i-feel-it-s-easy-level",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int res = 0, pos = 0;\\n        for(auto x: rungs){\\n            res += (x-pos-1) / dist;\\n            pos = x;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int res = 0, pos = 0;\\n        for(auto x: rungs){\\n            res += (x-pos-1) / dist;\\n            pos = x;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176621,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int cnt=0;int k=0;\\n        if(rungs[0]-0>dist){\\n            if(dist>1&&((rungs[0]-0)%dist!=0))\\n            cnt=((rungs[0]-0)/dist);\\n            else\\n             cnt=((rungs[0]-0)/dist)-1;\\n        }\\n        for(int i=0;i<rungs.length-1;i++){\\n            if(rungs[i+1]-rungs[i]>dist){\\n                k=rungs[i+1]-rungs[i];\\n                if(k%dist!=0){\\n                cnt+=k/dist;\\n                }\\n                else{\\n                cnt+=k/dist-1;}\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int cnt=0;int k=0;\\n        if(rungs[0]-0>dist){\\n            if(dist>1&&((rungs[0]-0)%dist!=0))\\n            cnt=((rungs[0]-0)/dist);\\n            else\\n             cnt=((rungs[0]-0)/dist)-1;\\n        }\\n        for(int i=0;i<rungs.length-1;i++){\\n            if(rungs[i+1]-rungs[i]>dist){\\n                k=rungs[i+1]-rungs[i];\\n                if(k%dist!=0){\\n                cnt+=k/dist;\\n                }\\n                else{\\n                cnt+=k/dist-1;}\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158297,
                "title": "simple-o-n-solution-rust-beats-100",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nuse std::cmp::max;\\n\\nimpl Solution {\\n    pub fn add_rungs(rungs: Vec<i32>, dist: i32) -> i32 {\\n        let (mut far, mut ans, n) = (0, 0, rungs.len());\\n\\n        for i in 0..n {\\n            if rungs[i] - far > dist {\\n                ans += (rungs[i] - far - 1) / dist;\\n                far += rungs[i] - far - 1;\\n            }\\n \\n            far = max(far, rungs[i]);\\n        }\\n\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::max;\\n\\nimpl Solution {\\n    pub fn add_rungs(rungs: Vec<i32>, dist: i32) -> i32 {\\n        let (mut far, mut ans, n) = (0, 0, rungs.len());\\n\\n        for i in 0..n {\\n            if rungs[i] - far > dist {\\n                ans += (rungs[i] - far - 1) / dist;\\n                far += rungs[i] - far - 1;\\n            }\\n \\n            far = max(far, rungs[i]);\\n        }\\n\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3156899,
                "title": "simple-java-o-n-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int res = 0, pre = 0;\\n        for (int i = 0; i < rungs.length; i++) {\\n            int d = rungs[i] - pre;\\n            if (d > dist) {\\n                res += d % dist == 0 ? d / dist - 1: d / dist;\\n            }\\n            pre = rungs[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int res = 0, pre = 0;\\n        for (int i = 0; i < rungs.length; i++) {\\n            int d = rungs[i] - pre;\\n            if (d > dist) {\\n                res += d % dist == 0 ? d / dist - 1: d / dist;\\n            }\\n            pre = rungs[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087031,
                "title": "python-clean-and-simple",
                "content": "```\\nfrom itertools import chain, pairwise\\nfrom math import ceil\\n\\n\\nclass Solution:\\n    def addRungs(self, rungs: list[int], dist: int) -> int:\\n        return sum(\\n            ceil((cur - prev) / dist) - 1\\n            for prev, cur in pairwise(chain([0], rungs))\\n        )\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import chain, pairwise\\nfrom math import ceil\\n\\n\\nclass Solution:\\n    def addRungs(self, rungs: list[int], dist: int) -> int:\\n        return sum(\\n            ceil((cur - prev) / dist) - 1\\n            for prev, cur in pairwise(chain([0], rungs))\\n        )\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045183,
                "title": "my-solution-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first I thought that if difference between two elements is greater than the allowed distance than i should subtract the distance from difference and increment the counter(no Of Rungs).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince my first approach takes alot time when input is large, therefore the approach used to solve the problem is that difference between two elemnts of array is divided by allowed/given distance. Then the answers is added to noOfRungs(an int variable).\\nThe process is done in loop by comparing two elements in sequence.\\n\\nFor example if array is [4,9,15] and allowed distance is 4. Then\\n\\nFirst iteration : diff = 9-4 = 5, dist = 4\\ndiff/dist = 5/4 = 1\\n\\nSecond iteration:diff = 15-9 = 6, dist = 4\\ndiff/dist = 6/4 = 1\\n\\nhence total rungs that should be added are 1+1 = 2.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n.\\n\\n# Code\\n```\\n#include<string.h>\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) \\n    {\\n        int length = rungs.size();\\n        int noOfRungs = 0;\\n\\n        //check if number of elements within the allowed limits\\n        if(length < 1 || length > 100000 )\\n            return -1;\\n\\n        //check if distance is within the allowed limits\\n        if(dist < 1 || dist > 1000000000)\\n            return -2;\\n  \\n        int firstHeightCheck = 0 + rungs[0] - 1;\\n        if(firstHeightCheck >= dist)\\n            noOfRungs += firstHeightCheck/dist;\\n        \\n        //first approach, correct but takes a lot of time\\n        /*while(firstHeightCheck > dist)\\n        {\\n            noOfRungs++;\\n            firstHeightCheck -=dist;\\n        }\\n        */\\n            \\n        for(int i = 1; i < length ; i++)\\n        {\\n            int diff = rungs[i] - rungs[i-1] - 1;\\n            \\n            //check if array is strictly increasing\\n            if(diff < 0)\\n                return -3;\\n\\n            if(diff >= dist)\\n            {\\n                //cout<<rungs[i] << \"-\" << rungs[i-1] << \"=\"<< diff <<\"\\\\n\";\\n                /*\\n                while(diff > dist)\\n                {\\n                    noOfRungs++;\\n                    diff -= dist;\\n                }\\n                */\\n\\n                noOfRungs += diff/dist;\\n            }\\n        }\\n        return noOfRungs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<string.h>\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) \\n    {\\n        int length = rungs.size();\\n        int noOfRungs = 0;\\n\\n        //check if number of elements within the allowed limits\\n        if(length < 1 || length > 100000 )\\n            return -1;\\n\\n        //check if distance is within the allowed limits\\n        if(dist < 1 || dist > 1000000000)\\n            return -2;\\n  \\n        int firstHeightCheck = 0 + rungs[0] - 1;\\n        if(firstHeightCheck >= dist)\\n            noOfRungs += firstHeightCheck/dist;\\n        \\n        //first approach, correct but takes a lot of time\\n        /*while(firstHeightCheck > dist)\\n        {\\n            noOfRungs++;\\n            firstHeightCheck -=dist;\\n        }\\n        */\\n            \\n        for(int i = 1; i < length ; i++)\\n        {\\n            int diff = rungs[i] - rungs[i-1] - 1;\\n            \\n            //check if array is strictly increasing\\n            if(diff < 0)\\n                return -3;\\n\\n            if(diff >= dist)\\n            {\\n                //cout<<rungs[i] << \"-\" << rungs[i-1] << \"=\"<< diff <<\"\\\\n\";\\n                /*\\n                while(diff > dist)\\n                {\\n                    noOfRungs++;\\n                    diff -= dist;\\n                }\\n                */\\n\\n                noOfRungs += diff/dist;\\n            }\\n        }\\n        return noOfRungs;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3013521,
                "title": "python-one-pass",
                "content": "# Code\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        cur = 0\\n        res = 0\\n        for r in rungs:\\n            res += (r - cur - 1)//dist\\n            cur = r\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        cur = 0\\n        res = 0\\n        for r in rungs:\\n            res += (r - cur - 1)//dist\\n            cur = r\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005467,
                "title": "java-beats-82",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int count = 0;\\n        if (rungs[0] > dist) {\\n            count += rungs[0]/dist;\\n            if (rungs[0] % dist == 0) count--;\\n        }\\n        for (int i = 0; i < rungs.length - 1; i++) {\\n            int distance = rungs[i+1] - rungs[i];\\n            if (distance > dist) {\\n                count += distance / dist;\\n                if (distance % dist == 0) count--;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int count = 0;\\n        if (rungs[0] > dist) {\\n            count += rungs[0]/dist;\\n            if (rungs[0] % dist == 0) count--;\\n        }\\n        for (int i = 0; i < rungs.length - 1; i++) {\\n            int distance = rungs[i+1] - rungs[i];\\n            if (distance > dist) {\\n                count += distance / dist;\\n                if (distance % dist == 0) count--;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963671,
                "title": "java-easy-solution-in-constant-space",
                "content": "**If you like my solution, Please Upvote!!**\\n\\n# Approach\\n1. If you have to add a new rung, add it as high up as possible.\\n2. Try using division to decrease the number of computations.\\n\\n# Complexity\\n- Time complexity:  O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int count = 0;\\n        int currRung = 0;\\n        \\n        for(int i=0;i<rungs.length;i++){\\n            if(rungs[i]-currRung<=dist){\\n                currRung = rungs[i];\\n            }else{\\n                count += (rungs[i]-currRung-1)/dist;\\n                currRung = rungs[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int count = 0;\\n        int currRung = 0;\\n        \\n        for(int i=0;i<rungs.length;i++){\\n            if(rungs[i]-currRung<=dist){\\n                currRung = rungs[i];\\n            }else{\\n                count += (rungs[i]-currRung-1)/dist;\\n                currRung = rungs[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954053,
                "title": "o-n-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int ans[]=new int[rungs.length];\\n        int c=0;\\n        for(int i=rungs.length-1;i>=1;i--){\\n            ans[i]=rungs[i]-rungs[i-1];\\n        }\\n        ans[0]=rungs[0]-0;\\n        for(int i=0;i<ans.length;i++){\\n            if(ans[i]>dist)\\n            {\\n                \\n            \\n                if(ans[i]%dist==0)\\n                c+=ans[i]/dist-1;\\n                else\\n                c+=ans[i]/dist;\\n            \\n               // c+=ans[i]/dist;\\n            }\\n        }\\n            \\n        return c;\\n            \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int ans[]=new int[rungs.length];\\n        int c=0;\\n        for(int i=rungs.length-1;i>=1;i--){\\n            ans[i]=rungs[i]-rungs[i-1];\\n        }\\n        ans[0]=rungs[0]-0;\\n        for(int i=0;i<ans.length;i++){\\n            if(ans[i]>dist)\\n            {\\n                \\n            \\n                if(ans[i]%dist==0)\\n                c+=ans[i]/dist-1;\\n                else\\n                c+=ans[i]/dist;\\n            \\n               // c+=ans[i]/dist;\\n            }\\n        }\\n            \\n        return c;\\n            \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952710,
                "title": "easy-solution-with-90-faster-c-beginner-friendly",
                "content": "# Intuition\\nWe just have to find number of times we need to insert rungs in between two adjacent element .\\n\\n# Approach\\nCreate two variable\\n answer: to store inerstion count;\\n floor: to store the floor till which we reached;\\n\\n\\nFor each element check if floor + dist>= element ,then we dont need to insert any rungs, so we move forward.\\nelse if floor+ dist < element, then we need to insert rungs.\\nIn inserting there are two cases:\\nFirst case if Element - floor is divisible by dist then we add required rungs-1.\\nelse we insert (element -floor)/dist rungs.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int n=rungs.size();\\n        int floor=0,ans=0,i=0;\\n        while(i<n)\\n        {\\n            if(floor+dist>=rungs[i])\\n            {  floor=rungs[i];\\n                i++;\\n            }\\n            else\\n            {     int count=rungs[i]-floor;\\n               \\n                  if(count%dist==0)\\n                  {  int val=count/dist-1;\\n                     ans+=val;\\n                     floor+=(dist*val);\\n                  }\\n                  else\\n                  {  int val=count/dist;\\n                     ans+=val;\\n                     floor+=dist*val;\\n                  }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int n=rungs.size();\\n        int floor=0,ans=0,i=0;\\n        while(i<n)\\n        {\\n            if(floor+dist>=rungs[i])\\n            {  floor=rungs[i];\\n                i++;\\n            }\\n            else\\n            {     int count=rungs[i]-floor;\\n               \\n                  if(count%dist==0)\\n                  {  int val=count/dist-1;\\n                     ans+=val;\\n                     floor+=(dist*val);\\n                  }\\n                  else\\n                  {  int val=count/dist;\\n                     ans+=val;\\n                     floor+=dist*val;\\n                  }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933481,
                "title": "c-simple-and-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n\\n- Space complexity:\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans{0}, prev{0};\\n\\n        for(int i{0}; i < rungs.size(); i++){\\n            int diff = (rungs[i] - prev);\\n\\n            if(diff > dist)\\n                ans += (diff - 1) / dist;\\n\\n            prev = rungs[i];\\n        }\\n\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans{0}, prev{0};\\n\\n        for(int i{0}; i < rungs.size(); i++){\\n            int diff = (rungs[i] - prev);\\n\\n            if(diff > dist)\\n                ans += (diff - 1) / dist;\\n\\n            prev = rungs[i];\\n        }\\n\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841684,
                "title": "c-simple-o-n-solution-using-for-loop",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n\\nint addRungs(int* rungs, int rungsSize, int dist){\\n\\n    int count = 0;\\n\\n    for (int i = 0; i < rungsSize; i++) {\\n\\n        count += (rungs[i] - (i > 0 ? rungs[i - 1] : 0) - 1) / dist; \\n\\n    }\\n\\n    return count;\\n\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nint addRungs(int* rungs, int rungsSize, int dist){\\n\\n    int count = 0;\\n\\n    for (int i = 0; i < rungsSize; i++) {\\n\\n        count += (rungs[i] - (i > 0 ? rungs[i - 1] : 0) - 1) / dist; \\n\\n    }\\n\\n    return count;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2824290,
                "title": "c-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int res = 0, pos = 0;\\n        for (int i = 0; i < rungs.size(); ++i) {\\n            if (pos + dist < rungs[i]) {\\n                res += ceil((rungs[i]-pos) / double(dist)) - 1;\\n            }\\n            pos = rungs[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int res = 0, pos = 0;\\n        for (int i = 0; i < rungs.size(); ++i) {\\n            if (pos + dist < rungs[i]) {\\n                res += ceil((rungs[i]-pos) / double(dist)) - 1;\\n            }\\n            pos = rungs[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783038,
                "title": "greedy",
                "content": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        rungs = [0] + rungs\\n        return sum(  (rungs[i]-rungs[i-1] - 1)//dist        for i in range(1,len(rungs)) )\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        rungs = [0] + rungs\\n        return sum(  (rungs[i]-rungs[i-1] - 1)//dist        for i in range(1,len(rungs)) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782614,
                "title": "simply-syntax-on-python-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        curr, preSum = 0, []\\n        for run in rungs:\\n            preSum.append(run - curr)\\n            curr = run\\n        \\n        result = sum([ (k-1 if dist == 1 else (k//dist if k%dist > 0 else (k//dist) - 1) )   for k in preSum if k > dist])    \\n        return result\\n    \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        curr, preSum = 0, []\\n        for run in rungs:\\n            preSum.append(run - curr)\\n            curr = run\\n        \\n        result = sum([ (k-1 if dist == 1 else (k//dist if k%dist > 0 else (k//dist) - 1) )   for k in preSum if k > dist])    \\n        return result\\n    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767867,
                "title": "divide-gaps-by-dist-details-explanation",
                "content": "**Why (gaps-1)/dist ?**\\nIf we only have two point (0 and 5 lets say) then how can we reach to 5 from 0. We need a intermediate step which is in distance D from 0. It may be tempting to find out by dividing the gap by distance D.\\nSo, (5-0)/2=2 which is correct.\\n```\\n0 1 2 3 4 5\\n    -   -\\n```\\nAs we can see, to react the desired point 5 we require two intermediate step (2 and 4).\\n\\nNow lets say, we have to reach from 0 to 6 this time. If we apply the same logic as we did earlier i.e. gap/dist = (6-0)/2 = 3. Lets see them in following figure:\\n```\\n0 1 2 3 4 5 6\\n    -   -\\n```\\nAs we can see , we still only require step 2 and step 4 to reach our goal.\\nThis is why we did -1 in the beginning. \\n\\nIf you understand this far, the rest of logic is straight forward. Here is the C++ code: \\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int count  = 0;\\n        int prev = 0;\\n        int sz = rungs.size();\\n        for(int i = 0; i<sz; i++){\\n            if(rungs[i]-prev>dist){\\n                count += (rungs[i]-prev-1)/dist;\\n            }\\n            prev = rungs[i];\\n        }      \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n0 1 2 3 4 5\\n    -   -\\n```\n```\\n0 1 2 3 4 5 6\\n    -   -\\n```\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int count  = 0;\\n        int prev = 0;\\n        int sz = rungs.size();\\n        for(int i = 0; i<sz; i++){\\n            if(rungs[i]-prev>dist){\\n                count += (rungs[i]-prev-1)/dist;\\n            }\\n            prev = rungs[i];\\n        }      \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754908,
                "title": "easiest-sol-maybe-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& a, int k) \\n    {\\n        int res=0;\\n        if(a.size()==1)return (a[0]-1)/k;\\n        for(int i=0;i<a.size()-1;i++)\\n        {\\n            res+=(a[i+1]-a[i]-1)/k;\\n            if(i==0)res+=(a[0]-1)/k;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& a, int k) \\n    {\\n        int res=0;\\n        if(a.size()==1)return (a[0]-1)/k;\\n        for(int i=0;i<a.size()-1;i++)\\n        {\\n            res+=(a[i+1]-a[i]-1)/k;\\n            if(i==0)res+=(a[0]-1)/k;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742659,
                "title": "easy-solution-in-java-10-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple maths\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmaths\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n          int count=dist;\\n          int sum=0; \\n          int arr[]=new int[rungs.length+1];\\n          arr[0]=0;\\n          int p=0;\\n          for(int i=1;i<rungs.length+1;i++)\\n          {\\n              arr[i]=rungs[p++];\\n          }\\n          for(int i=0;i<rungs.length;i++)\\n          {\\n              if((arr[i+1]-arr[i])>dist)\\n              {\\n                  int pp=(arr[i+1]-arr[i]);\\n                  int value=(arr[i+1]-arr[i])/dist;\\n                  if((pp%dist)==0)\\n                  {\\n                      value=value-1;\\n                  }\\n                  sum=sum+value;    \\n              }\\n              else\\n              {\\n                  \\n              }\\n          } \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n          int count=dist;\\n          int sum=0; \\n          int arr[]=new int[rungs.length+1];\\n          arr[0]=0;\\n          int p=0;\\n          for(int i=1;i<rungs.length+1;i++)\\n          {\\n              arr[i]=rungs[p++];\\n          }\\n          for(int i=0;i<rungs.length;i++)\\n          {\\n              if((arr[i+1]-arr[i])>dist)\\n              {\\n                  int pp=(arr[i+1]-arr[i]);\\n                  int value=(arr[i+1]-arr[i])/dist;\\n                  if((pp%dist)==0)\\n                  {\\n                      value=value-1;\\n                  }\\n                  sum=sum+value;    \\n              }\\n              else\\n              {\\n                  \\n              }\\n          } \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742658,
                "title": "easy-solution-in-java-10-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple maths\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmaths\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n          int count=dist;\\n          int sum=0; \\n          int arr[]=new int[rungs.length+1];\\n          arr[0]=0;\\n          int p=0;\\n          for(int i=1;i<rungs.length+1;i++)\\n          {\\n              arr[i]=rungs[p++];\\n          }\\n          for(int i=0;i<rungs.length;i++)\\n          {\\n              if((arr[i+1]-arr[i])>dist)\\n              {\\n                  int pp=(arr[i+1]-arr[i]);\\n                  int value=(arr[i+1]-arr[i])/dist;\\n                  if((pp%dist)==0)\\n                  {\\n                      value=value-1;\\n                  }\\n                  sum=sum+value;    \\n              }\\n              else\\n              {\\n                  \\n              }\\n          } \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n          int count=dist;\\n          int sum=0; \\n          int arr[]=new int[rungs.length+1];\\n          arr[0]=0;\\n          int p=0;\\n          for(int i=1;i<rungs.length+1;i++)\\n          {\\n              arr[i]=rungs[p++];\\n          }\\n          for(int i=0;i<rungs.length;i++)\\n          {\\n              if((arr[i+1]-arr[i])>dist)\\n              {\\n                  int pp=(arr[i+1]-arr[i]);\\n                  int value=(arr[i+1]-arr[i])/dist;\\n                  if((pp%dist)==0)\\n                  {\\n                      value=value-1;\\n                  }\\n                  sum=sum+value;    \\n              }\\n              else\\n              {\\n                  \\n              }\\n          } \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702256,
                "title": "c-o-n-easy-understanding",
                "content": "```\\nint addRungs(vector<int>& r, int d) {\\n        int n=r.size();\\n        int c=0;\\n        if(r[0]>d){\\n            c+=(r[0]-1)/d;\\n        }\\n        for(int i=0;i<n-1;i++){\\n            if(r[i+1]-r[i]>d){\\n                int p=r[i+1]-r[i]-1;\\n                c+=(p/d);\\n            }\\n        }\\n        return c;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint addRungs(vector<int>& r, int d) {\\n        int n=r.size();\\n        int c=0;\\n        if(r[0]>d){\\n            c+=(r[0]-1)/d;\\n        }\\n        for(int i=0;i<n-1;i++){\\n            if(r[i+1]-r[i]>d){\\n                int p=r[i+1]-r[i]-1;\\n                c+=(p/d);\\n            }\\n        }\\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2690098,
                "title": "easy-python-greedy-solution-94-faster",
                "content": "![image](https://assets.leetcode.com/users/images/0055bb0f-ca93-4fff-95eb-d00243b239ad_1665487325.3612945.png)\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        rungs = [0] + rungs\\n        n = len(rungs)\\n        res = 0\\n        for i in range(1,n):\\n            if rungs[i] - rungs[i-1] <= dist: continue\\n\\n            res += math.ceil((rungs[i] - rungs[i-1])/dist) - 1\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        rungs = [0] + rungs\\n        n = len(rungs)\\n        res = 0\\n        for i in range(1,n):\\n            if rungs[i] - rungs[i-1] <= dist: continue\\n\\n            res += math.ceil((rungs[i] - rungs[i-1])/dist) - 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670251,
                "title": "greedy-distance-python-tc-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. --> Greedy methodology\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        ans = 0\\n        if rungs[0] - 0 > dist:\\n            ans += (rungs[0]-1)//dist\\n        for i in range(len(rungs)):\\n            diff = rungs[i] - rungs[i-1]\\n            if diff > dist: \\n                ans += (diff-1)//dist\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        ans = 0\\n        if rungs[0] - 0 > dist:\\n            ans += (rungs[0]-1)//dist\\n        for i in range(len(rungs)):\\n            diff = rungs[i] - rungs[i-1]\\n            if diff > dist: \\n                ans += (diff-1)//dist\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657033,
                "title": "c-simple-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int pos=0,count=0;\\n        for(int i=0;i<rungs.size();i++){\\n            if((rungs[i]-pos)>dist){\\n                if((rungs[i]-pos)%dist){\\n                   count+=(rungs[i]-pos)/dist; \\n                }\\n                else{\\n                    count+=(rungs[i]-pos)/dist-1;\\n                }   \\n            }\\n            pos=rungs[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int pos=0,count=0;\\n        for(int i=0;i<rungs.size();i++){\\n            if((rungs[i]-pos)>dist){\\n                if((rungs[i]-pos)%dist){\\n                   count+=(rungs[i]-pos)/dist; \\n                }\\n                else{\\n                    count+=(rungs[i]-pos)/dist-1;\\n                }   \\n            }\\n            pos=rungs[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641513,
                "title": "maths",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans=0; \\n        if(rungs[0] > dist)  ans+=(rungs[0]-1)/dist;\\n        \\n        for(int i=0;i<rungs.size()-1;i++){\\n            int val = rungs[i+1]-rungs[i] ; \\n            if(val>dist) ans+=(val-1)/dist ;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans=0; \\n        if(rungs[0] > dist)  ans+=(rungs[0]-1)/dist;\\n        \\n        for(int i=0;i<rungs.size()-1;i++){\\n            int val = rungs[i+1]-rungs[i] ; \\n            if(val>dist) ans+=(val-1)/dist ;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2639785,
                "title": "javascript-o-n-w-reduce",
                "content": "```javascript\\n/**\\n * @param {number[]} rungs\\n * @param {number} dist\\n * @return {number}\\n */\\nvar addRungs = function (rungs, dist) {\\n  return rungs.reduce(\\n    (acc, cur) => {\\n      let [prev, res] = acc;\\n      return [cur, res + Math.floor((cur - prev - 1) / dist)];\\n    },\\n    [0, 0]\\n  )[1];\\n};\\n```\\n\\nTESTED\\n\\n```txt\\nAccepted\\n117/117 cases passed (158 ms)\\nYour runtime beats 11.11 % of javascript submissions\\nYour memory usage beats 5.56 % of javascript submissions (55.6 MB)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} rungs\\n * @param {number} dist\\n * @return {number}\\n */\\nvar addRungs = function (rungs, dist) {\\n  return rungs.reduce(\\n    (acc, cur) => {\\n      let [prev, res] = acc;\\n      return [cur, res + Math.floor((cur - prev - 1) / dist)];\\n    },\\n    [0, 0]\\n  )[1];\\n};\\n```\n```txt\\nAccepted\\n117/117 cases passed (158 ms)\\nYour runtime beats 11.11 % of javascript submissions\\nYour memory usage beats 5.56 % of javascript submissions (55.6 MB)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2638559,
                "title": "c-easy-solution-95-faster",
                "content": "\\nclass Solution {\\npublic:\\n\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int c=0;\\n        int ans=0;\\n        for(int i=0;i<rungs.size();i++){\\n\\t\\t\\n            if(rungs[i]-c>dist ){\\n                if((rungs[i]-c)%dist==0){\\n                    ans = ans + (rungs[i]-c)/dist -1;\\n                    c = rungs[i];\\n                }\\n                else if((rungs[i]-c)%dist!=0) {\\n                ans = ans + (rungs[i]-c)/dist;\\n                c = rungs[i];\\n                }\\n            }\\n            c =rungs[i];\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int c=0;\\n        int ans=0;\\n        for(int i=0;i<rungs.size();i++){\\n\\t\\t\\n            if(rungs[i]-c>dist ){\\n                if((rungs[i]-c)%dist==0){\\n                    ans = ans + (rungs[i]-c)/dist -1;\\n                    c = rungs[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2627308,
                "title": "simple-c-solutioon",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        \\n        int i, ans = 0, last, diff, k;\\n        \\n        last = 0;\\n        \\n        for(i=0; i < rungs.size(); i++){\\n            \\n            diff = rungs[i] - last;\\n            \\n            if(diff > dist){\\n                \\n                if(diff%dist==0){\\n                    \\n                    k = diff/dist-1;\\n                    \\n                }else\\n                    k = diff/dist;\\n                \\n                ans += k;\\n                \\n                last = max(k*dist, rungs[i]);\\n                \\n            }else{\\n                \\n                last = rungs[i];\\n                \\n            }\\n            \\n        }\\n         \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        \\n        int i, ans = 0, last, diff, k;\\n        \\n        last = 0;\\n        \\n        for(i=0; i < rungs.size(); i++){\\n            \\n            diff = rungs[i] - last;\\n            \\n            if(diff > dist){\\n                \\n                if(diff%dist==0){\\n                    \\n                    k = diff/dist-1;\\n                    \\n                }else\\n                    k = diff/dist;\\n                \\n                ans += k;\\n                \\n                last = max(k*dist, rungs[i]);\\n                \\n            }else{\\n                \\n                last = rungs[i];\\n                \\n            }\\n            \\n        }\\n         \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617822,
                "title": "unique-solution-and-clean-code-cpp",
                "content": "```\\nint addRungs(vector<int>& a, int dist) {\\n\\tint curDis = a[0], ans = 0, n = a.size();\\n\\n\\tif(curDis > dist) {\\n\\t\\tans += (curDis/dist) + ((curDis%dist) > 0);\\n\\t\\tans--;\\n\\t}\\n\\n\\tfor(int i = 0; i + 1 < n; i++) {\\n\\t\\tcurDis = (a[i+1] - a[i]);\\n\\t\\tif(curDis > dist) {\\n\\t\\t\\tans += (curDis/dist) + ((curDis%dist) > 0);\\n\\t\\t\\tans--;\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nint addRungs(vector<int>& a, int dist) {\\n\\tint curDis = a[0], ans = 0, n = a.size();\\n\\n\\tif(curDis > dist) {\\n\\t\\tans += (curDis/dist) + ((curDis%dist) > 0);\\n\\t\\tans--;\\n\\t}\\n\\n\\tfor(int i = 0; i + 1 < n; i++) {\\n\\t\\tcurDis = (a[i+1] - a[i]);\\n\\t\\tif(curDis > dist) {\\n\\t\\t\\tans += (curDis/dist) + ((curDis%dist) > 0);\\n\\t\\t\\tans--;\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2617640,
                "title": "simple-solution",
                "content": "class Solution {\\n    public int addRungs(int[] Rungs, int dist) {\\n        \\n        int ptr = 0;\\n        int res = 0;\\n        \\n        for (int i = 0; i < Rungs.length; i++) {\\n            \\n            res += (Rungs[i] - ptr - 1) / dist;\\n            ptr = Rungs[i];\\n            \\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int addRungs(int[] Rungs, int dist) {\\n        \\n        int ptr = 0;\\n        int res = 0;\\n        \\n        for (int i = 0; i < Rungs.length; i++) {\\n            \\n            res += (Rungs[i] - ptr - 1) / dist;\\n            ptr = Rungs[i];\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2560016,
                "title": "c-intuition-explained-greedy-o-n",
                "content": "```\\n  int addRungs(vector<int>& rungs, int dist) {\\n        \\n        int prev=0,count=0;\\n        for(int i=0;i<rungs.size();i++)\\n        {\\n            int diff=rungs[i]-prev;\\n            \\n//IMPORTANT ---> if diff/dist is totally divisible then in bw diff/dist -1 rings inserted if diff =13 and dist=3 4 rings inserted at 3,6,9,12, but if diff=9 and dist=k 2 rings inserted 3,6 .. (9 me to ring hai hi)\\n            count+=(diff%dist)?diff/dist:diff/dist-1;\\n            prev=rungs[i];\\n        }\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "```\\n  int addRungs(vector<int>& rungs, int dist) {\\n        \\n        int prev=0,count=0;\\n        for(int i=0;i<rungs.size();i++)\\n        {\\n            int diff=rungs[i]-prev;\\n            \\n//IMPORTANT ---> if diff/dist is totally divisible then in bw diff/dist -1 rings inserted if diff =13 and dist=3 4 rings inserted at 3,6,9,12, but if diff=9 and dist=k 2 rings inserted 3,6 .. (9 me to ring hai hi)\\n            count+=(diff%dist)?diff/dist:diff/dist-1;\\n            prev=rungs[i];\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2555940,
                "title": "java-c-python-straight-forward-greedy-sorting-solution",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int res = (rungs[0] - 1-0) / dist;\\n    for (int i = 1; i < rungs.size(); ++i)\\n        res += (rungs[i] - rungs[i - 1] - 1) / dist;\\n    return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2553182,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn add_rungs(rungs: Vec<i32>, dist: i32) -> i32 {\\n        let mut now = 0;\\n        let mut result = 0;\\n        for v in rungs {\\n            let diff = v - now;\\n            if diff > dist {\\n                let diff = diff - dist;\\n                let mut add = diff / dist;\\n                if diff % dist != 0 {\\n                    add += 1;\\n                }\\n                result += add;\\n            }\\n            \\n            now = v;\\n        }\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn add_rungs(rungs: Vec<i32>, dist: i32) -> i32 {\\n        let mut now = 0;\\n        let mut result = 0;\\n        for v in rungs {\\n            let diff = v - now;\\n            if diff > dist {\\n                let diff = diff - dist;\\n                let mut add = diff / dist;\\n                if diff % dist != 0 {\\n                    add += 1;\\n                }\\n                result += add;\\n            }\\n            \\n            now = v;\\n        }\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2549218,
                "title": "typescript-minimum-rungs-clean-solution-139-ms-faster-than-100-00-54-3-mb-less-than-100-00",
                "content": "Explanation:\\n1. Currently on floor 0, so create a storage for the minimum number of floors.\\n2. Check if first item is greater than `dist`, then add dist to the rungs.\\n3. Loop through the rungs starting from the second item.\\n4. Split Check if the difference between current item and the previous item is greater than `dist`.\\n5. Divide `diff` by `dist` and substract the result of the upper bound by 1.\\n```\\nfunction addRungs(rungs: number[], dist: number): number {\\n    let minimum = 0;\\n    \\n    const temp = rungs;\\n    if (temp[0] > dist) {\\n        minimum += 1;\\n        temp.unshift(dist);\\n    }\\n    \\n    for (let i = 1; i < temp.length; i++) {\\n        const diff = temp[i] - temp[i - 1];\\n        if (diff > dist) {\\n            minimum += Math.ceil(diff / dist) - 1;\\n        }\\n    }\\n    return minimum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction addRungs(rungs: number[], dist: number): number {\\n    let minimum = 0;\\n    \\n    const temp = rungs;\\n    if (temp[0] > dist) {\\n        minimum += 1;\\n        temp.unshift(dist);\\n    }\\n    \\n    for (let i = 1; i < temp.length; i++) {\\n        const diff = temp[i] - temp[i - 1];\\n        if (diff > dist) {\\n            minimum += Math.ceil(diff / dist) - 1;\\n        }\\n    }\\n    return minimum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2458114,
                "title": "add-minimum-rungs-c-explained-solution-100-faster-and-100-space-optimised",
                "content": "The question here is quite simple based on basic observations. Lets say we are currently at some **rungs[i]**. If I can jump to next rung without using any extra rung, then just move to the next rung. If not then we would have to add some rungs in between. This could be easily calculated by taking **difference of next rung and current rung and divide it by dist**. Now we would move to **current rung + (number of rungs needed) x dist**. We would apply the same process for all.\\nImplementation goes below :\\n\\nTime Complexity : O(N)\\nSpace Complexity : O(1)\\n\\nCode :\\n```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        ios_base::sync_with_stdio(0);\\n        long long ans = 0,cur_rung = 0,i = 0;\\n        while(i<rungs.size()){\\n            if(cur_rung+dist>=rungs[i]){\\n                cur_rung = rungs[i];\\n                i++;\\n            }\\n            else{\\n                long long diff = ceil((double)(rungs[i]-cur_rung)/dist);\\n                ans+=diff-1;\\n                cur_rung = cur_rung+diff*dist;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/14079515-c2d3-4795-ae46-45162b536314_1661071475.8651202.png)\\n\\n**Do Upvote If Found Helpful !**\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        ios_base::sync_with_stdio(0);\\n        long long ans = 0,cur_rung = 0,i = 0;\\n        while(i<rungs.size()){\\n            if(cur_rung+dist>=rungs[i]){\\n                cur_rung = rungs[i];\\n                i++;\\n            }\\n            else{\\n                long long diff = ceil((double)(rungs[i]-cur_rung)/dist);\\n                ans+=diff-1;\\n                cur_rung = cur_rung+diff*dist;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2432237,
                "title": "c-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int required=0;\\n        int n=rungs.size();\\n        for(int i=1;i<n;i++){\\n            int diff=rungs[i]-rungs[i-1];\\n            required+=(diff-1)/dist;\\n            \\n        }\\n      \\n        required+=(rungs[0]-1)/dist;\\n        return required;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int required=0;\\n        int n=rungs.size();\\n        for(int i=1;i<n;i++){\\n            int diff=rungs[i]-rungs[i-1];\\n            required+=(diff-1)/dist;\\n            \\n        }\\n      \\n        required+=(rungs[0]-1)/dist;\\n        return required;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400325,
                "title": "divide-gaps-by-dist-and-then-add-c",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n          int res = (rungs[0] - 1-0) / dist;\\n    for (int i = 1; i < rungs.size(); ++i)\\n        res += (rungs[i] - rungs[i - 1] - 1) / dist;\\n    return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2390413,
                "title": "loop-and-count-numbers-needed",
                "content": "```\\npublic class Solution {\\n    public int AddRungs(int[] rungs, int dist) {\\n        int pre=0,count=0;\\n        foreach(var rung in rungs){\\n            count+=(rung-pre-1)/dist;\\n            pre=rung;\\n        }\\n        return count;\\n    }\\n}\\n```\\nO(N)",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int AddRungs(int[] rungs, int dist) {\\n        int pre=0,count=0;\\n        foreach(var rung in rungs){\\n            count+=(rung-pre-1)/dist;\\n            pre=rung;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2304439,
                "title": "intuitive",
                "content": "```\\nclass Solution {\\n    \\n    bool climb(int cur, int next, int dist) {\\n        return next - cur <= dist;\\n    }\\n    \\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int cur = 0;\\n        int res = 0;\\n        for (int i = 0, len = rungs.size(); i < len;) {\\n            auto r = rungs[i];\\n            if (climb(cur, r, dist)) {\\n                cur = r;\\n                ++i;\\n            } else {\\n                int diff = (r - cur - 1) / dist;\\n                cur += diff * dist;\\n                res += diff;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\n    bool climb(int cur, int next, int dist) {\\n        return next - cur <= dist;\\n    }\\n    \\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int cur = 0;\\n        int res = 0;\\n        for (int i = 0, len = rungs.size(); i < len;) {\\n            auto r = rungs[i];\\n            if (climb(cur, r, dist)) {\\n                cur = r;\\n                ++i;\\n            } else {\\n                int diff = (r - cur - 1) / dist;\\n                cur += diff * dist;\\n                res += diff;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294645,
                "title": "python-one-liner-ugly",
                "content": "```\\nclass Solution:\\n    def addRungs(self, arr: List[int], dist: int) -> int:\\n        return sum([ceil((arr[i]-arr[i-1])/dist)-1 if i != 0 else ceil(arr[i]/dist)-1 for i in range(len(arr))])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addRungs(self, arr: List[int], dist: int) -> int:\\n        return sum([ceil((arr[i]-arr[i-1])/dist)-1 if i != 0 else ceil(arr[i]/dist)-1 for i in range(len(arr))])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2282467,
                "title": "c-solution-greedy",
                "content": "```\\n    int addRungs(vector<int>& nums, int dist) {\\n        int n=nums.size();\\n        int count=0;\\n        if(nums[0]>dist)\\n            count+=(nums[0]/dist)-1+((nums[0]%dist)!=0);\\n        for(int i=0; i<n-1; i++)\\n            if(nums[i+1]-nums[i]>dist)\\n                count+=((nums[i+1]-nums[i])/dist)-1+((nums[i+1]-nums[i])%dist!=0);\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int addRungs(vector<int>& nums, int dist) {\\n        int n=nums.size();\\n        int count=0;\\n        if(nums[0]>dist)\\n            count+=(nums[0]/dist)-1+((nums[0]%dist)!=0);\\n        for(int i=0; i<n-1; i++)\\n            if(nums[i+1]-nums[i]>dist)\\n                count+=((nums[i+1]-nums[i])/dist)-1+((nums[i+1]-nums[i])%dist!=0);\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2275602,
                "title": "swift-solution-100-efficient",
                "content": "```\\nclass Solution {\\n    func addRungs(_ A: [Int], _ dist: Int) -> Int {\\n        var pre = 0, res = 0\\n        for a in A {\\n            res += (a - pre - 1) / dist\\n            pre = a\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func addRungs(_ A: [Int], _ dist: Int) -> Int {\\n        var pre = 0, res = 0\\n        for a in A {\\n            res += (a - pre - 1) / dist\\n            pre = a\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241826,
                "title": "c-faster-than-97",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans = 0;\\n        rungs.insert(rungs.begin(), 0);\\n        for(int i=0; i<rungs.size()-1; ++i) {\\n            if(rungs[i+1] - rungs[i] > dist) {\\n                ans += (rungs[i+1] - rungs[i] - 1) / dist;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int ans = 0;\\n        rungs.insert(rungs.begin(), 0);\\n        for(int i=0; i<rungs.size()-1; ++i) {\\n            if(rungs[i+1] - rungs[i] > dist) {\\n                ans += (rungs[i+1] - rungs[i] - 1) / dist;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2211831,
                "title": "c-solution-only-integer-math",
                "content": "This doesn\\'t seem to be a medium problem.  I\\'d rate it lower.\\n\\n```\\n    public int AddRungs(int[] rungs, int dist) \\n    {\\n        int result = 0;\\n        int previous = 0;\\n        for(int i=0;i<rungs.Length;i++)\\n        {\\n            int delta = rungs[i]-previous;\\n            int x = delta / dist;\\n            if (x*dist!=delta) x++;\\n            //So if this is greater that 1 we need the extra rungs.\\n            result+=x-1;\\n            previous=rungs[i];\\n        }\\n        return result;\\n    }   \\n```",
                "solutionTags": [],
                "code": "```\\n    public int AddRungs(int[] rungs, int dist) \\n    {\\n        int result = 0;\\n        int previous = 0;\\n        for(int i=0;i<rungs.Length;i++)\\n        {\\n            int delta = rungs[i]-previous;\\n            int x = delta / dist;\\n            if (x*dist!=delta) x++;\\n            //So if this is greater that 1 we need the extra rungs.\\n            result+=x-1;\\n            previous=rungs[i];\\n        }\\n        return result;\\n    }   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2192323,
                "title": "python-greedy-5-liner",
                "content": "```\\nclass Solution:\\n    def addRungs(self, x: List[int], dist: int) -> int:\\n        q=ans=0\\n        for i in x:\\n            ans+=(i-q-1)//dist\\n            q=i\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addRungs(self, x: List[int], dist: int) -> int:\\n        q=ans=0\\n        for i in x:\\n            ans+=(i-q-1)//dist\\n            q=i\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2182195,
                "title": "c-5-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        \\n        int answer = 0, prev = 0;\\n        \\n        for(int i=0;i<rungs.size();i++){\\n            answer += ceil((rungs[i]-prev) / (double)dist) - 1;\\n            prev = rungs[i];\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        \\n        int answer = 0, prev = 0;\\n        \\n        for(int i=0;i<rungs.size();i++){\\n            answer += ceil((rungs[i]-prev) / (double)dist) - 1;\\n            prev = rungs[i];\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158457,
                "title": "o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int s=0,ans=0;\\n        for(int i=0;i<rungs.size();i++)\\n        {\\n            if(s+dist<rungs[i])\\n            {\\n                ans+=ceil((double)(rungs[i]-s)/dist)-1;\\n            }\\n            s=rungs[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int s=0,ans=0;\\n        for(int i=0;i<rungs.size();i++)\\n        {\\n            if(s+dist<rungs[i])\\n            {\\n                ans+=ceil((double)(rungs[i]-s)/dist)-1;\\n            }\\n            s=rungs[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156701,
                "title": "c-short-and-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int res = 0, i=0, curr=0;\\n        while(i<rungs.size()){\\n            res += (rungs[i] - curr-1)/dist;\\n            curr = rungs[i];\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int res = 0, i=0, curr=0;\\n        while(i<rungs.size()){\\n            res += (rungs[i] - curr-1)/dist;\\n            curr = rungs[i];\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139545,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int extras=0;\\n        int curr=0;\\n        int i=0;\\n        while(i<rungs.size())\\n        {\\n            if(curr + dist>= rungs[i])\\n            {\\n                curr=rungs[i];\\n                i++;\\n            }\\n            else\\n            {\\n                int multi=(rungs[i]-curr)/dist;\\n                if((rungs[i]-curr)%dist==0)\\n                {\\n                    curr=rungs[i];\\n                    i++;\\n                    extras+= multi-1;\\n                }\\n                else\\n                {\\n                    extras+= multi;\\n                    curr +=multi*dist;\\n                }\\n                \\n            }\\n        }\\n        return extras;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int extras=0;\\n        int curr=0;\\n        int i=0;\\n        while(i<rungs.size())\\n        {\\n            if(curr + dist>= rungs[i])\\n            {\\n                curr=rungs[i];\\n                i++;\\n            }\\n            else\\n            {\\n                int multi=(rungs[i]-curr)/dist;\\n                if((rungs[i]-curr)%dist==0)\\n                {\\n                    curr=rungs[i];\\n                    i++;\\n                    extras+= multi-1;\\n                }\\n                else\\n                {\\n                    extras+= multi;\\n                    curr +=multi*dist;\\n                }\\n                \\n            }\\n        }\\n        return extras;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120961,
                "title": "c-solution-linear-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int count = 0;\\n        for(int i = 1; i < rungs.size(); ++i){\\n            if(rungs[i] - rungs[i - 1] > dist)\\n                count += (rungs[i] - 1 - rungs[i - 1]) / dist;\\n        }\\n        if(rungs[0] > dist)\\n            count += (rungs[0] - 1) / dist;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int count = 0;\\n        for(int i = 1; i < rungs.size(); ++i){\\n            if(rungs[i] - rungs[i - 1] > dist)\\n                count += (rungs[i] - 1 - rungs[i - 1]) / dist;\\n        }\\n        if(rungs[0] > dist)\\n            count += (rungs[0] - 1) / dist;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2079747,
                "title": "greedy",
                "content": "```\\nint addRungs(vector<int> & r, int d)\\n{\\n\\tint out{(r[0]-1)/d};\\n\\tfor(int i{1}; i<size(r); out += (r[i]-r[i-1]-1)/d, ++i);\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint addRungs(vector<int> & r, int d)\\n{\\n\\tint out{(r[0]-1)/d};\\n\\tfor(int i{1}; i<size(r); out += (r[i]-r[i-1]-1)/d, ++i);\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2079134,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int c=0;int s=0;\\n        for(int i=0;i<rungs.size();i++)\\n        {\\n          if(rungs[i]-c>dist)\\n          {\\n              int d=rungs[i]-c-1;\\n              s+=d/dist;\\n              \\n          }\\n            c=rungs[i];\\n        }\\n        return s;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int c=0;int s=0;\\n        for(int i=0;i<rungs.size();i++)\\n        {\\n          if(rungs[i]-c>dist)\\n          {\\n              int d=rungs[i]-c-1;\\n              s+=d/dist;\\n              \\n          }",
                "codeTag": "Java"
            },
            {
                "id": 2016970,
                "title": "easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int count =0;\\n        int m =0;\\n        for(int i =0;i<rungs.size();i++){\\n            if(rungs[i]-m> dist){\\n                \\n                count += ((rungs[i]-m)/dist);\\n                if((rungs[i]-m)%dist==0){\\n                    count--;\\n                }\\n            }\\n                         m = rungs[i];\\n\\n        }\\n        return count ;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int addRungs(vector<int>& rungs, int dist) {\\n        int count =0;\\n        int m =0;\\n        for(int i =0;i<rungs.size();i++){\\n            if(rungs[i]-m> dist){\\n                \\n                count += ((rungs[i]-m)/dist);\\n                if((rungs[i]-m)%dist==0){\\n                    count--;\\n                }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1906337,
                "content": [
                    {
                        "username": "zalars",
                        "content": "This task is very easy even for me (I\\'m a beginner in algorithms) - why medium?"
                    }
                ]
            }
        ]
    }
]