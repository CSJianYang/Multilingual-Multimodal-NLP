[
    {
        "title": "Find the Maximum Number of Marked Indices",
        "question_content": "You are given a 0-indexed integer array nums.\nInitially, all of the indices are unmarked. You are allowed to make this operation any number of times:\n\n\tPick two different unmarked indices i and j such that 2 * nums[i] <= nums[j], then mark i and j.\n\nReturn the maximum possible number of marked indices in nums using the above operation any number of times.\n&nbsp;\nExample 1:\n\nInput: nums = [3,5,2,4]\nOutput: 2\nExplanation: In the first operation: pick i = 2 and j = 1, the operation is allowed because 2 * nums[2] <= nums[1]. Then mark index 2 and 1.\nIt can be shown that there's no other valid operation so the answer is 2.\n\nExample 2:\n\nInput: nums = [9,2,5,4]\nOutput: 4\nExplanation: In the first operation: pick i = 3 and j = 0, the operation is allowed because 2 * nums[3] <= nums[0]. Then mark index 3 and 0.\nIn the second operation: pick i = 1 and j = 2, the operation is allowed because 2 * nums[1] <= nums[2]. Then mark index 1 and 2.\nSince there is no other operation, the answer is 4.\n\nExample 3:\n\nInput: nums = [7,6,8]\nOutput: 0\nExplanation: There is no valid operation to do, so the answer is 0.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 109\n\n&nbsp;\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; \n}\n.spoiler {overflow:hidden;}\n.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}\n.spoilerbutton[value=\"Show Message\"] + .spoiler > div {margin-top:-500%;}\n.spoilerbutton[value=\"Hide Message\"] + .spoiler {padding:5px;}",
        "solutions": [
            {
                "id": 3231114,
                "title": "two-pointers",
                "content": "Intuition for this problem is tricky.\\n\\nIndices `i` and `j` form a pair (if `2 * nums[i] < nums[j]`). If we want to make `m` pairs, the best strategy is to pick `m` smallest numbers as `nums[i]`.\\n\\nAt the same time, we cannot make more than `n / 2` pairs. Therefore, we consider `n - n / 2` largest numbers for `nums[j]`.\\n\\nSo, we sort the array, and greedily match smallest numbers with numbers in the second half of the sorted array.\\n\\n**C++**\\n```cpp\\nint maxNumOfMarkedIndices(vector<int>& nums) {\\n    int i = 0, n = nums.size();\\n    sort(begin(nums), end(nums));\\n    for (int j = n - n / 2; j < n; ++j)\\n        i += 2 * nums[i] <= nums[j];\\n    return i * 2;\\n}\\n```\\n\\n**Java**\\n```java\\npublic int maxNumOfMarkedIndices(int[] nums) {\\n    int i = 0, n = nums.length;\\n    Arrays.sort(nums);\\n    for (int j = n - n / 2; j < n; ++j)\\n        i += 2 * nums[i] <= nums[j] ? 1 : 0;\\n    return i * 2;\\n}\\n```\\n**Python 3**\\n```python\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        i, n = 0, len(nums)\\n        nums.sort()\\n        for j in range(n - n // 2, n):\\n            i += 2 * nums[i] <= nums[j]\\n        return i * 2\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```cpp\\nint maxNumOfMarkedIndices(vector<int>& nums) {\\n    int i = 0, n = nums.size();\\n    sort(begin(nums), end(nums));\\n    for (int j = n - n / 2; j < n; ++j)\\n        i += 2 * nums[i] <= nums[j];\\n    return i * 2;\\n}\\n```\n```java\\npublic int maxNumOfMarkedIndices(int[] nums) {\\n    int i = 0, n = nums.length;\\n    Arrays.sort(nums);\\n    for (int j = n - n / 2; j < n; ++j)\\n        i += 2 * nums[i] <= nums[j] ? 1 : 0;\\n    return i * 2;\\n}\\n```\n```python\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        i, n = 0, len(nums)\\n        nums.sort()\\n        for j in range(n - n // 2, n):\\n            i += 2 * nums[i] <= nums[j]\\n        return i * 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230779,
                "title": "c-java-python-need-sorting-with-two-pointers",
                "content": "### SOLUTION\\n##### INTUTION \\n\\n---\\n\\n-  We only make `n / 2` pairs. So, we make pairs form element `i = 0` for first ptr & `j = n / 2` for second ptr if `nums[i] * 2 <= nums[j]` is valid pair then add `+2` in `ans` & increment `i` & also `j` bcz we used this two `idx`.\\n-  but it\\'s invalid then we know that next element of `jth` index is greater, so in that case we increament `jth` pointer.\\n---\\n\\n>**This intution by @votrubac** \\n\\n-  Intuition for this problem is tricky.\\n\\n-  Indices i and j form a pair (if 2 * nums[i] < nums[j]). If we want to make m pairs, the best strategy is to pick m smallest numbers as nums[i].\\n\\n-  At the same time, we cannot make more than n / 2 pairs. Therefore, we consider n - n / 2 largest numbers for nums[j].\\n\\n- So, we sort the array, and greedily match smallest numbers with numbers in the second half of the sorted array.\\n---\\n\\n\\n##### Time Complexity - `O(N*Log(N))`\\n##### Space Complexity - `O(1)`\\n\\n---\\n```cpp []\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), ans = 0, i = 0, j = n/2;\\n        while(i < n/2 && j < n) {\\n            if(nums[i] * 2 <= nums[j]) ans += 2, i++, j++;\\n            else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length, ans = 0, i = 0, j = n / 2; \\n        while(i < n / 2 && j < n) {\\n            if(nums[i] * 2 <= nums[j]) {ans += 2; i++; j++;}\\n            else j++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        n, i, ans = len(nums), 0, 0\\n        nums.sort()\\n        for j in range(n - n // 2, n):\\n            if nums[i] * 2 <= nums[j]:\\n                i += 1 \\n                ans += 2\\n        return ans\\n```\\n\\n\\n>##### If You Helpful, Please Upvote !!!\\n\\nHappy Coding ;) \\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), ans = 0, i = 0, j = n/2;\\n        while(i < n/2 && j < n) {\\n            if(nums[i] * 2 <= nums[j]) ans += 2, i++, j++;\\n            else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length, ans = 0, i = 0, j = n / 2; \\n        while(i < n / 2 && j < n) {\\n            if(nums[i] * 2 <= nums[j]) {ans += 2; i++; j++;}\\n            else j++;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        n, i, ans = len(nums), 0, 0\\n        nums.sort()\\n        for j in range(n - n // 2, n):\\n            if nums[i] * 2 <= nums[j]:\\n                i += 1 \\n                ans += 2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230855,
                "title": "python3-c-java-sort-and-two-pointers",
                "content": "# Please UPVOTE\\uD83D\\uDE0A\\n# Two pointers\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int l=0,r=nums.size()/2;\\n        while (r<nums.size() and l<nums.size()/2)\\n        {\\n            if(2*nums[l]<=nums[r]) l++;\\n            r++;\\n        }\\n        return l*2;\\n    }\\n};\\n```\\n# Python3\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        l,r=0,len(nums)//2\\n        while r<len(nums) and l<len(nums)//2:\\n            if 2*nums[l]<=nums[r]: l+=1\\n            r+=1\\n        return l*2\\n```\\n# Java\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int l=0,r=nums.length/2;\\n        while (r<nums.length && l<nums.length/2)\\n        {\\n            if(2*nums[l]<=nums[r])\\n            {\\n                l+=1;\\n            }\\n            r+=1;\\n        }\\n        return l*2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int l=0,r=nums.size()/2;\\n        while (r<nums.size() and l<nums.size()/2)\\n        {\\n            if(2*nums[l]<=nums[r]) l++;\\n            r++;\\n        }\\n        return l*2;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        l,r=0,len(nums)//2\\n        while r<len(nums) and l<len(nums)//2:\\n            if 2*nums[l]<=nums[r]: l+=1\\n            r+=1\\n        return l*2\\n```\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int l=0,r=nums.length/2;\\n        while (r<nums.length && l<nums.length/2)\\n        {\\n            if(2*nums[l]<=nums[r])\\n            {\\n                l+=1;\\n            }\\n            r+=1;\\n        }\\n        return l*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231353,
                "title": "explained-pointers-iteration-very-simple-easy-to-understand-solution",
                "content": "# Intuition\\nMax possible ans is nums.size() -> as we need to match each of the pairs \\nSo we can think to match the larger value with largest value first then keep on checking matching of smaller numbers.\\n\\n# Approach\\nSimpply sort the array \\nTake two pointers one at the mid (fptr )\\nand one at the last (ptr) -> refering to largest value.\\n\\nNow we iterate fptr to match it with the largest value at ptr.\\nKeep soing this and counting the matched pairs\\nReturn anser as no of matched pair x 2 to return no of marked elements\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n- Space complexity: O(1)\\n\\n#### Up vote if you like the solution \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int fptr = nums.size()/2-1, ptr = nums.size()-1, ans = 0;\\n        while(fptr >= 0 && ptr >= 0){\\n            //if(nums[ptr]) {\\n                if( 2*nums[fptr] <= nums[ptr] ) { ans++; ptr--; }\\n                fptr--;\\n            //}\\n            //else ptr--;\\n        }\\n        return 2*ans;\\n    }\\n};\\n```\\n\\nHere is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int fptr = nums.size()/2-1, ptr = nums.size()-1, ans = 0;\\n        while(fptr >= 0 && ptr >= 0){\\n            //if(nums[ptr]) {\\n                if( 2*nums[fptr] <= nums[ptr] ) { ans++; ptr--; }\\n                fptr--;\\n            //}\\n            //else ptr--;\\n        }\\n        return 2*ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230864,
                "title": "2576-find-the-maximum-number-of-marked-indices-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        int b=0;\\n        int g=(n+1)/2;\\n        while(g<n){\\n            if(nums[b]*2<=nums[g]) b++;\\n            g++;\\n        }\\n        return 2*b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        int b=0;\\n        int g=(n+1)/2;\\n        while(g<n){\\n            if(nums[b]*2<=nums[g]) b++;\\n            g++;\\n        }\\n        return 2*b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231270,
                "title": "explanation-with-no-code",
                "content": "# Intuition\\nMany people post simple code without explanation, here I will do the contrary, which I think is more helpful (hopefully you think so too, if yes, please **UPVOTE**). Correct logic to this problem is tricky, please comment if you have better explainations. \\n\\n0. Definitely need to sort first\\n\\n1. Let\\'s call all pairs [a, b], where a * 2 <= b, then first we need to realize the set of a and set of b won\\'t overlap, that is, it is always possible to find an optimal solution where all a are before all b. (this step is not very easy to figure out, since you may think each time we can just grab the max, then find the largest index such that nums[indx] <= max//2, I tried that but it is not the correct way to go)\\n\\nWhy? suppose after put into order, the max possible pairs we can make is a1, b1, a2, a3, b2, b3, (numbers are in increasing order)\\nwhere a1 matches to b1, a2 matches to b2, a3 matches to b3, then it can always change to a1\\', a2\\', a3\\', b1\\', b2\\', b3\\' (the same set of numbers in increasing order), since we know a1*2 <= b1, thus a1\\' * 2 <= b1\\', etc.. \\n\\n2. Now we know set of a must come before set of b, the question reduces to, where is the best cutoff point, so that a are chosen before the cutoff, and all b are chosen after the cutoff? \\n\\nTo do this, we can use binary search, to search the range *ans* in range [0, n//2]: there are two cases, case 1 is that first part has only *ans* count of elements from the beginning, the rest belongs to the 2nd part, we can use 2 pointers to match these 2 parts (In python, part1 is nums[:ans], part2 is nums[ans:]); case 2 is that, second part only has *ans* count of elements from the end, the rest belongs to the 1st part (In python, part1 is nums[:-ans], part2 is nums[-ans:]), again we can use 2 pointers to match these 2 parts. If either of the case is feasible, we know *ans* is feasbile to achieve.\\n\\nHowever, after some thought, this is not the most efficient approach. If we look again the above 2 cases, we realize that, for all possible cases, no matter where the cutoff point is,  we only need to compare [0, mid) to [mid, n). For example, for above case 1, we can always start searching the 2nd part from the mid (i.e., 2nd pointer starts at the mid due to the fact that we still have enough candidates in the 2nd part, and these candidates are better than those we can choose from if we start the 2nd pointer before mid), which won\\'t hurt the optimal count a bit (since for all those b we can match from the 2nd part, we can find their replacement after mid)\\n\\n\\n# Approach\\ntwo pointers, 1st starts at index 0, 2nd starts at index mid\\n",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "# Intuition\\nMany people post simple code without explanation, here I will do the contrary, which I think is more helpful (hopefully you think so too, if yes, please **UPVOTE**). Correct logic to this problem is tricky, please comment if you have better explainations. \\n\\n0. Definitely need to sort first\\n\\n1. Let\\'s call all pairs [a, b], where a * 2 <= b, then first we need to realize the set of a and set of b won\\'t overlap, that is, it is always possible to find an optimal solution where all a are before all b. (this step is not very easy to figure out, since you may think each time we can just grab the max, then find the largest index such that nums[indx] <= max//2, I tried that but it is not the correct way to go)\\n\\nWhy? suppose after put into order, the max possible pairs we can make is a1, b1, a2, a3, b2, b3, (numbers are in increasing order)\\nwhere a1 matches to b1, a2 matches to b2, a3 matches to b3, then it can always change to a1\\', a2\\', a3\\', b1\\', b2\\', b3\\' (the same set of numbers in increasing order), since we know a1*2 <= b1, thus a1\\' * 2 <= b1\\', etc.. \\n\\n2. Now we know set of a must come before set of b, the question reduces to, where is the best cutoff point, so that a are chosen before the cutoff, and all b are chosen after the cutoff? \\n\\nTo do this, we can use binary search, to search the range *ans* in range [0, n//2]: there are two cases, case 1 is that first part has only *ans* count of elements from the beginning, the rest belongs to the 2nd part, we can use 2 pointers to match these 2 parts (In python, part1 is nums[:ans], part2 is nums[ans:]); case 2 is that, second part only has *ans* count of elements from the end, the rest belongs to the 1st part (In python, part1 is nums[:-ans], part2 is nums[-ans:]), again we can use 2 pointers to match these 2 parts. If either of the case is feasible, we know *ans* is feasbile to achieve.\\n\\nHowever, after some thought, this is not the most efficient approach. If we look again the above 2 cases, we realize that, for all possible cases, no matter where the cutoff point is,  we only need to compare [0, mid) to [mid, n). For example, for above case 1, we can always start searching the 2nd part from the mid (i.e., 2nd pointer starts at the mid due to the fact that we still have enough candidates in the 2nd part, and these candidates are better than those we can choose from if we start the 2nd pointer before mid), which won\\'t hurt the optimal count a bit (since for all those b we can match from the 2nd part, we can find their replacement after mid)\\n\\n\\n# Approach\\ntwo pointers, 1st starts at index 0, 2nd starts at index mid\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3230920,
                "title": "python3-2-pointer",
                "content": "\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans = 0 \\n        j = len(nums)-1\\n        for i in range(len(nums)//2-1, -1, -1): \\n            if nums[i]*2 <= nums[j]: \\n                ans += 2\\n                j -= 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans = 0 \\n        j = len(nums)-1\\n        for i in range(len(nums)//2-1, -1, -1): \\n            if nums[i]*2 <= nums[j]: \\n                ans += 2\\n                j -= 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241900,
                "title": "100-solution-explained-code-explanation-video",
                "content": "# Intuition + Approach\\nhttps://youtu.be/Yi_-IZq40Cc\\n\\nIn this video, I have discussed two approaches, one that takes O(n) space and another optimized approach which takes O(1) space.\\n\\n# Complexity\\n- Time complexity: $$O(n log n)$$\\n- Space complexity: $$O(1)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n\\n        int n = nums.size();\\n        int i = 0;\\n        int j = n/2;\\n        int res = 0;\\n\\n        while(i<n/2 && j<n){\\n            if(2*nums[i]<=nums[j]){\\n                i++;\\n                j++;\\n                res += 2;\\n            }\\n            else\\n                j++;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n\\n        int n = nums.size();\\n        int i = 0;\\n        int j = n/2;\\n        int res = 0;\\n\\n        while(i<n/2 && j<n){\\n            if(2*nums[i]<=nums[j]){\\n                i++;\\n                j++;\\n                res += 2;\\n            }\\n            else\\n                j++;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230952,
                "title": "two-pointers-greedy-with-intuition-and-approach-with-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. We need to find the maximum possible number of marked indices in nums array by picking any 2 indices i and j such that 2* num[i] <= nums[j], then mark i and j (Initially all indices are unmarked).\\n2. We have to multiply nums[i] by 2 and then compare with nums[j] and then mark both indices if 2*nums[I]<=nums[j], in order to mark maximum indices we need to pick smallest value and then choose number which follows the above condition and mark them.\\n3. This can be done by sorting the nums array and comparing first element with the middle element as we need to find maximum marked indices. We also use two pointer approach two move the pointer from middle element(choosing mid element gives optimal solution) to next element if condition not matches and hence find the maximum indices see the approach and code to understand better.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the nums array.\\n2. Initialise two pointers i=0, j=nums.size()/2 and create a set to check indices are present or not.\\n3. First check if both the indices are present in set or not, if both indices are not present and matches the above condition then insert both indices into set and increment i and j pointers.\\n4. If above condition fails and j<n-1 then increment j pointer else increment i pointer.\\n5. Finally return size of set which stores the marked indices.\\n\\n\\n# Complexity\\n- Time complexity: N*Log(N) (sorting)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) (set)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        \\n        unordered_set<int> marked;\\n        int i = 0, j = n/2;\\n        while (i < n && j < n) {\\n            if (marked.find(i) == marked.end() && marked.find(j) == marked.end() && 2 * nums[i] <= nums[j]) {\\n                marked.insert(i);\\n                marked.insert(j);\\n                i++;\\n                j++;\\n            } \\n            else {\\n                if (j < n - 1) {\\n                    j++;\\n                } \\n                else {\\n                    i++;\\n                }\\n            }\\n        }\\n        return marked.size();\\n    }\\n};\\n```\\n\\n# Upvote if you like the solution :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        \\n        unordered_set<int> marked;\\n        int i = 0, j = n/2;\\n        while (i < n && j < n) {\\n            if (marked.find(i) == marked.end() && marked.find(j) == marked.end() && 2 * nums[i] <= nums[j]) {\\n                marked.insert(i);\\n                marked.insert(j);\\n                i++;\\n                j++;\\n            } \\n            else {\\n                if (j < n - 1) {\\n                    j++;\\n                } \\n                else {\\n                    i++;\\n                }\\n            }\\n        }\\n        return marked.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240358,
                "title": "leetcode-the-hard-way-binary-search",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [YouTube Channel](https://www.youtube.com/@leetcodethehardway) if you are interested.\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), l = 0, r = n / 2;\\n        while (l < r) {\\n            int m = l + (r - l + 1) / 2;\\n            int ok = 1;\\n            for (int i = 0; i < m; i++) {\\n                if (2 * nums[i] > nums[n - m + i]) {\\n                    ok = 0;\\n                    break;\\n                }\\n            }\\n            if (ok) l = m;\\n            else r = m - 1;\\n        }\\n        return 2 * l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), l = 0, r = n / 2;\\n        while (l < r) {\\n            int m = l + (r - l + 1) / 2;\\n            int ok = 1;\\n            for (int i = 0; i < m; i++) {\\n                if (2 * nums[i] > nums[n - m + i]) {\\n                    ok = 0;\\n                    break;\\n                }\\n            }\\n            if (ok) l = m;\\n            else r = m - 1;\\n        }\\n        return 2 * l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232381,
                "title": "easy-simple-priority-queue-approach",
                "content": "# Intuition\\nSimply try to group the smaller number with a greater number such that it is just enough to satisfy the equation \\n\\n**2 * small <= large**\\n\\n\\nIt means if we have 2 possiblities for an element then we will choose the one which is just sufficient to satisfy the above equation\\n\\nFor ex - > For [ 2 , 3 , 5 , 8] \\n\\nIn this array we can have 2 possible pairs for 2 which are **( 2 , 5 )** and **( 2 , 8 )** so we will choose **first pair** as the condition is sufficient enough to make the valid pair i.e **2*2<=5**  and further 8 can be selected with 3 making ( 3 , 8) as another valid pair **2*3<=8**\\n\\n# Approach\\nSo it is always profitable to make pair between the max possible smaller and max possible greater or vice-versa\\n\\nTo do so we will divide the array into two half \\n\\nSmaller half --> These elements are the candidates for pair in which they will act as small elements\\n\\nGreater half --> These elements are the candidates for pair in which they will act as greater elements\\n\\nWe will store the both half seperately in max-heaps namely small heap and large heap to retrieve the candidates quickly\\n\\nThese half can be created by dividing the array into two parts after sorting because this will create a perfect distribution of elements such that we can get maximum possible pairs of valid elements which is equal to number_of_element / 2 ( if possible).\\n\\nNow we will try to make pairs such that for every element of smaller half we will check if there is some element in greater half which satisfy the equation .\\n\\n// If element found -- > then increase the answer by 2 and remove the top element from both the small and large heap\\n\\n// If element not found --> then remove the top element of small heap because there is no possible element available in the large heap which can make pair with this element\\n\\n###### WHY IT WORKS ?? \\n\\nSuppose we have an element a as the top of small priority queue and b as the top of large prioity queue\\n\\nif **2 * a <= b** is not true then there can not be any value for a which can help it make pair because\\n\\nin smaller half all the elements are less than or  equal to a hence a cannot have any pair-element within small half elements\\n\\nin greater half or large half all the elements are less than or equal to b and the equation is not true for b so eventually it will not be true for less than or equal to b choice of candidates  hence a cannot have any pair-element with large half elements\\n\\n\\n// DRY RUN \\n\\nEX - [ 14 , 9 , 9 , 2 , 5 ,15 ]\\n\\nAfter sorting [ 2 , 5 , 9 , 9  ,14 , 15] \\n\\n\\nSmaller half -- 9 , 5 , 2 ( greater ele at top -- max heap)\\n\\nLarge or Greater half -- 15 , 14 , 9 ( greater ele at top -- max heap)\\n\\n\\n1) 2 * 9 <=  15 ( false ) . Hence we cannot make a valid pair for 9 thus remove it from small heap \\n\\n2) 2 * 5 <= 15 ( true ) . Valid pair can be made thus answer += 2 and remove both 5 and 15 from small heap and large heap respectively \\n\\n3) 2 * 2 <= 14 (true ) . Valid pair can be made thus answer += 2 and remove both 2 and 14 from small heap and large heap respectively \\n\\n\\nNow more candidates left in small heap hence the algorithm stops and we got our answer as 4 i.e 4 indexes are marked with pairs ( 5 , 15 ) and ( 2 , 14 ) .\\n\\n\\n# Complexity\\n- Time complexity:\\n\\nnlogn for sorting \\nnlogn for storing elements in the heap and executing operations\\n\\nHence overall time complexity is \\nO ( nlogn )\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nExtra Space required to store the elements in heap \\n\\nO ( n )\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        // sort the elements in non-decreasing order \\n        \\n        sort( nums.begin() , nums.end());\\n        \\n         // priority queue to store the smaller elements \\n\\n        priority_queue< int >small;\\n        \\n        // priority queue to store the greater elements\\n          \\n        priority_queue< int >large;\\n        \\n        int size = nums.size();\\n        \\n        // first half of sorted array in small priority_queue\\n\\n        for( int i = 0; i < size /2 ; i++)\\n        {\\n            small.push(nums[i]);\\n        }\\n        // second half of sorted array in large priority_queue        \\n\\n        for( int i = size /2 ; i < size ; i++)\\n        {\\n            large.push(nums[i]);\\n        }\\n        \\n\\n        int ans = 0;\\n        \\n        // check till the small heap become empty \\n         \\n        while(small.empty() == false)\\n        {   \\n\\n            // if large heap is not empty then check\\n            // if the current element of large heap is greater than small heap element or not \\n            \\n            // if yes -- > increase ans +=2 and remove the small\\n            // as well as large heap element as they have formed pair\\n            \\n           // if no -- > remove the small heap element as there is no possible element \\n           // available to satisfy the equation 2*small_ele <= large_ele             \\n\\n                if(large.top() >= 2*small.top())\\n                {\\n                    ans += 2;\\n\\n                    large.pop();\\n                }\\n\\n                small.pop();\\n        }\\n        \\n        return  ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        // sort the elements in non-decreasing order \\n        \\n        sort( nums.begin() , nums.end());\\n        \\n         // priority queue to store the smaller elements \\n\\n        priority_queue< int >small;\\n        \\n        // priority queue to store the greater elements\\n          \\n        priority_queue< int >large;\\n        \\n        int size = nums.size();\\n        \\n        // first half of sorted array in small priority_queue\\n\\n        for( int i = 0; i < size /2 ; i++)\\n        {\\n            small.push(nums[i]);\\n        }\\n        // second half of sorted array in large priority_queue        \\n\\n        for( int i = size /2 ; i < size ; i++)\\n        {\\n            large.push(nums[i]);\\n        }\\n        \\n\\n        int ans = 0;\\n        \\n        // check till the small heap become empty \\n         \\n        while(small.empty() == false)\\n        {   \\n\\n            // if large heap is not empty then check\\n            // if the current element of large heap is greater than small heap element or not \\n            \\n            // if yes -- > increase ans +=2 and remove the small\\n            // as well as large heap element as they have formed pair\\n            \\n           // if no -- > remove the small heap element as there is no possible element \\n           // available to satisfy the equation 2*small_ele <= large_ele             \\n\\n                if(large.top() >= 2*small.top())\\n                {\\n                    ans += 2;\\n\\n                    large.pop();\\n                }\\n\\n                small.pop();\\n        }\\n        \\n        return  ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231018,
                "title": "beats-100-solutions-sorting-easy-and-understandable-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>&v) {\\n        sort(v.begin(),v.end());\\n        int i=0,n=v.size(),j=n/2,cnt=0;\\n        while(i<n/2 && j<n){\\n            if(v[i]*2<=v[j]){\\n                i++;\\n                j++;\\n                cnt+=2;\\n            }\\n            else j++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>&v) {\\n        sort(v.begin(),v.end());\\n        int i=0,n=v.size(),j=n/2,cnt=0;\\n        while(i<n/2 && j<n){\\n            if(v[i]*2<=v[j]){\\n                i++;\\n                j++;\\n                cnt+=2;\\n            }\\n            else j++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230939,
                "title": "c-solution-tc-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint maxNumOfMarkedIndices(vector<int> &arr)\\n{\\n    int n = arr.size();\\n    sort(arr.begin(), arr.end());\\n    int ans = 0;\\n    int h = n +1;\\n    h/=2;\\n    int pre = n;\\n    int l=0;\\n\\n    while (h<n)\\n    {\\n        if (arr[l]*2<=arr[h])\\n        {\\n            l++;\\n            h++;\\n        }\\n        else\\n        {\\n            h++;\\n        }\\n        \\n        \\n    }\\n    \\n    return l*2;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint maxNumOfMarkedIndices(vector<int> &arr)\\n{\\n    int n = arr.size();\\n    sort(arr.begin(), arr.end());\\n    int ans = 0;\\n    int h = n +1;\\n    h/=2;\\n    int pre = n;\\n    int l=0;\\n\\n    while (h<n)\\n    {\\n        if (arr[l]*2<=arr[h])\\n        {\\n            l++;\\n            h++;\\n        }\\n        else\\n        {\\n            h++;\\n        }\\n        \\n        \\n    }\\n    \\n    return l*2;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230841,
                "title": "easy-c-using-multiset",
                "content": "# Intuition\\nSort nums and then We need to find lowerbond of nums[i]*2 if found then delete else break\\n\\n# Approach\\nusing multiset will reduce time-complexity\\ntake 2 multiset and insert first n/2 smallest element in one and other in 2nd\\n\\nnow if lower bound of smallest element * 2 is found in 2nd multiset we will delete that element and increase ans by 2 else break the loop\\n\\n# Time Complexity\\nO(n log(n))\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        \\n        multiset<long long>le,ri;\\n        for(int i=0;i<n/2;++i){\\n            le.insert(nums[i]);\\n        }\\n        for(int i=n/2;i<n;++i){\\n            ri.insert(nums[i]);\\n        }\\n        int ans=0;\\n        \\n        for(auto it=le.begin();it!=le.end();++it){\\n            long long val=*it;\\n            val*=2;\\n            auto it1=ri.lower_bound(val);\\n            if(it1==ri.end()){\\n                break;\\n            }else{\\n                ans+=2;\\n                ri.erase(it1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPLEASE UPVOTE",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        \\n        multiset<long long>le,ri;\\n        for(int i=0;i<n/2;++i){\\n            le.insert(nums[i]);\\n        }\\n        for(int i=n/2;i<n;++i){\\n            ri.insert(nums[i]);\\n        }\\n        int ans=0;\\n        \\n        for(auto it=le.begin();it!=le.end();++it){\\n            long long val=*it;\\n            val*=2;\\n            auto it1=ri.lower_bound(val);\\n            if(it1==ri.end()){\\n                break;\\n            }else{\\n                ans+=2;\\n                ri.erase(it1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230960,
                "title": "codeforces-2-pointers-easy-and-elegant",
                "content": "# Intuition\\nWe can have at max N / 2 pairs. We have to greedily assign in groups of 2. How to do that ? Consider different problem of dividing array in 2 parts after sorting both having size N / 2. Did you get an idea?\\n\\n# Approach\\nSo we can split array in two set, such that first set contains the elements whose size is in smaller half and second set contains the elements whose size is in larger half, and use easy greedy algorithm. \\n\\n# Complexity\\n- Time complexity:\\n$$O(nlog(n))$$ \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```c++ []\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int n = A.size(), i = 0, j = n / 2;\\n        \\n        while(i < n / 2 && j < n) {\\n            while(j < n && 2 * A[i] > A[j]) {\\n                j += 1;\\n            }\\n            if(j == n) {\\n                break;\\n            }\\n            i += 1;\\n            j += 1;\\n        }\\n        \\n        return i * 2;\\n    }\\n};\\n```\\n\\n# Codeforces\\nhttps://codeforces.com/contest/372/problem/A\\n\\nThanks, you can upvote :\\')",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy",
                    "Sort"
                ],
                "code": "```c++ []\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int n = A.size(), i = 0, j = n / 2;\\n        \\n        while(i < n / 2 && j < n) {\\n            while(j < n && 2 * A[i] > A[j]) {\\n                j += 1;\\n            }\\n            if(j == n) {\\n                break;\\n            }\\n            i += 1;\\n            j += 1;\\n        }\\n        \\n        return i * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233352,
                "title": "greedy-solution",
                "content": "# Intuition\\nWe can sort an array and make a gridy solution here. \\n\\n# Approach\\nSort the array. We can have up to N/2 index pairs. Check first N/2 smallest elements and try find min element from the second half so that condition will be valid.\\n\\n# Complexity\\n- Time complexity:\\nO(N*Log(N))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxNumOfMarkedIndices = function(nums) {\\n   nums.sort((a,b) => a-b)\\n   let i = 0\\n   let end = Math.floor(nums.length / 2)\\n   let j = end\\n   let res = 0;\\n   while(i < end && j < nums.length){\\n       if(2*nums[i] <= nums[j]){\\n           res+=2\\n           i++\\n       }\\n       j++\\n   }\\n\\n   return res\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxNumOfMarkedIndices = function(nums) {\\n   nums.sort((a,b) => a-b)\\n   let i = 0\\n   let end = Math.floor(nums.length / 2)\\n   let j = end\\n   let res = 0;\\n   while(i < end && j < nums.length){\\n       if(2*nums[i] <= nums[j]){\\n           res+=2\\n           i++\\n       }\\n       j++\\n   }\\n\\n   return res\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3232369,
                "title": "c-easy-two-pointers",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& v) {\\n        int n=v.size();\\n        map<int,int>m;\\n        sort(v.begin(),v.end());\\n        int left = 0, right = n/2;\\n        int count = 0;\\n        while (left <n && right <n) {\\n            if(m[left]){\\n                left++;\\n                continue;\\n            }\\n            if(m[right]){\\n                right++;\\n                continue;\\n            }\\n            if(left==right){\\n                right++;\\n                continue;\\n            }\\n            if (2 * v[left] <= v[right]) {\\n                count++;\\n                m[left]++;\\n                m[right]++;\\n                left++;\\n                right++;  \\n            }\\n            else\\n            right++;\\n        } \\n        return count*2; \\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/360356ec-be49-4e11-bce3-4abce0c78e4e_1677407533.801757.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& v) {\\n        int n=v.size();\\n        map<int,int>m;\\n        sort(v.begin(),v.end());\\n        int left = 0, right = n/2;\\n        int count = 0;\\n        while (left <n && right <n) {\\n            if(m[left]){\\n                left++;\\n                continue;\\n            }\\n            if(m[right]){\\n                right++;\\n                continue;\\n            }\\n            if(left==right){\\n                right++;\\n                continue;\\n            }\\n            if (2 * v[left] <= v[right]) {\\n                count++;\\n                m[left]++;\\n                m[right]++;\\n                left++;\\n                right++;  \\n            }\\n            else\\n            right++;\\n        } \\n        return count*2; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231476,
                "title": "c-2-pointers-intuitive",
                "content": "\\n# Approach\\n- Sort the array.\\n- Find out the mid and start iterating till mid is lesser than j.\\n- IF our condition matches (2*nums[mid] <= nums[j]) : inrease the counter + move backward.\\n- IF not then call back mid by 1 step.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        sort( nums.begin(), nums.end() );\\n\\n        int mid = (n/2)-1;\\n        int j = n-1;\\n\\n        int cnt = 0;\\n\\n        while( mid>=0 && mid<j ){\\n\\n            if( 2*nums[mid] <= nums[j] ) {\\n                cnt += 2;\\n                mid--; j--;\\n            }\\n\\n            else mid--;\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```\\n**\\uD83D\\uDC4DPlase Upvote IF u Like the Solution :D**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        sort( nums.begin(), nums.end() );\\n\\n        int mid = (n/2)-1;\\n        int j = n-1;\\n\\n        int cnt = 0;\\n\\n        while( mid>=0 && mid<j ){\\n\\n            if( 2*nums[mid] <= nums[j] ) {\\n                cnt += 2;\\n                mid--; j--;\\n            }\\n\\n            else mid--;\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231187,
                "title": "c-explanation-beats-100",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n-   The given problem asks to find the maximum number of marked indices in the given array \"nums\" using a specific operation any number of times.\\n- The given operation involves selecting two different unmarked indices i and j such that 2 * nums[i] <= nums[j], and then marking them.\\n- The solution approach is to sort the given array and maintain two pointers, f and s. Initially, f is set to 0 and s is set to the middle index of the array (or the next integer if the array has an odd length).\\n- We then iterate over the array with the condition s < n, where n is the length of the array. Within the loop, we check if the current condition for the operation is satisfied, i.e., if nums[f] * 2 is less than or equal to nums[s]. If the condition is satisfied, we move the f pointer forward to the next unmarked index.\\n- In the end, we return the number of marked indices, which is equal to the value of f multiplied by 2. This is because we marked two indices (i and j) in each successful operation.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n    - The time complexity of this solution is O(nlogn) due to the sorting operation.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n    - The space complexity is O(1) as we are not using any extra space to solve this problem.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n=nums.size();\\n       \\n        sort(nums.begin(),nums.end());\\n       \\n        int f=0,s=(nums.size()+1)/2;\\n        while(s<n)\\n        {\\n            if(nums[f]*2<=nums[s]) \\n                f++;\\n            \\n            s++;\\n        }\\n        return f*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n=nums.size();\\n       \\n        sort(nums.begin(),nums.end());\\n       \\n        int f=0,s=(nums.size()+1)/2;\\n        while(s<n)\\n        {\\n            if(nums[f]*2<=nums[s]) \\n                f++;\\n            \\n            s++;\\n        }\\n        return f*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231183,
                "title": "clean-short-java",
                "content": "\\n# Code\\n```java []\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int count = 0, j = nums.length-1;\\n        Arrays.sort(nums);\\n        for(int i=nums.length/2-1; i>=0; i--){\\n            if(nums[i] <= nums[j]/2){\\n                count += 2;\\n                j--;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int count = 0, j = nums.length-1;\\n        Arrays.sort(nums);\\n        for(int i=nums.length/2-1; i>=0; i--){\\n            if(nums[i] <= nums[j]/2){\\n                count += 2;\\n                j--;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230797,
                "title": "python-sort-o-nlogn-o-n-greedy",
                "content": "# Intuition\\nMax count of pairs are N/2 pairs.\\nAfter sort nums,\\nif nums[mid] >= nums[0] * 2 then all indices after mid works, greedily select nums[mid]\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        m = len(nums)//2\\n        i, j = 0, m\\n        res = 0\\n        nums.sort()\\n        while i < m and j < len(nums):\\n            if nums[j] >= nums[i]*2:\\n                res += 2\\n                i += 1\\n            j += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        m = len(nums)//2\\n        i, j = 0, m\\n        res = 0\\n        nums.sort()\\n        while i < m and j < len(nums):\\n            if nums[j] >= nums[i]*2:\\n                res += 2\\n                i += 1\\n            j += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234136,
                "title": "python-3-7-lines-w-explanation-and-example-t-m-644-ms-27-7-mb",
                "content": "Here\\'s the plan:\\n- We sort`nums`.\\n- We use the ptr`r`to iterate left-to-right through the second half of`nums`. For each value of`r`, we increment another ptr`l` to identify the least available value to pair with`nums[r`].\\n- Because each increment of`l`indicates a successful pairng, and each successful pairiing increases the number of markings by two, we return`2*l`\\n\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n\\n                                    # Example: nums = [9,2,5,4,5,7,7]\\n        nums.sort()                 # <\\u2013\\u2013      nums = [2,4,5,5,7,7,9]\\n        n = len(nums)\\n        l, r = 0, n//2              #   (l,r)   nums[l]   nums[r]\\n                                    #   \\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n        while l < n//2 and r < n:   #   (0,3)      2         5   <\\u2013\\u2013 (2*2<=5) = True\\n                                    #   (1,4)      4         6   <\\u2013\\u2013 (2*4<=6) = False \\n            l+= 2*nums[l]<=nums[r]  #   (1,5)      4         7   <\\u2013\\u2013 (2*4<=7) = False \\n                                    #   (1,6)      5         9   <\\u2013\\u2013 (2*4<=9) = True\\n            r+= 1                   #   (2,7)      r >= n\\n                                    #\\n        return 2*l                  #    return 2*2 = 4\\n```\\n[https://leetcode.com/problems/find-the-maximum-number-of-marked-indices/submissions/905498629/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*NlogN*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n\\n                                    # Example: nums = [9,2,5,4,5,7,7]\\n        nums.sort()                 # <\\u2013\\u2013      nums = [2,4,5,5,7,7,9]\\n        n = len(nums)\\n        l, r = 0, n//2              #   (l,r)   nums[l]   nums[r]\\n                                    #   \\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n        while l < n//2 and r < n:   #   (0,3)      2         5   <\\u2013\\u2013 (2*2<=5) = True\\n                                    #   (1,4)      4         6   <\\u2013\\u2013 (2*4<=6) = False \\n            l+= 2*nums[l]<=nums[r]  #   (1,5)      4         7   <\\u2013\\u2013 (2*4<=7) = False \\n                                    #   (1,6)      5         9   <\\u2013\\u2013 (2*4<=9) = True\\n            r+= 1                   #   (2,7)      r >= n\\n                                    #\\n        return 2*l                  #    return 2*2 = 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233285,
                "title": "c-solutions-beats-100-based-on-the-basic-approach",
                "content": "\\n\\n# Approach\\nBASIC APPROACH & EASY TO UNDERSTAND\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        int p=0;\\n        int q=(n+1)/2;\\n        sort(nums.begin(),nums.end());\\n\\n        if(n==1)\\n            return 0;\\n        while(p<n && q<n)\\n        {\\n            if(2 * nums[p] <= nums[q])\\n            {\\n                p++;\\n            }\\n            q++;\\n        }\\n        return p*2;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        int p=0;\\n        int q=(n+1)/2;\\n        sort(nums.begin(),nums.end());\\n\\n        if(n==1)\\n            return 0;\\n        while(p<n && q<n)\\n        {\\n            if(2 * nums[p] <= nums[q])\\n            {\\n                p++;\\n            }\\n            q++;\\n        }\\n        return p*2;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231524,
                "title": "c-using-two-pointer",
                "content": "# Approach\\nsort the array\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxNumOfMarkedIndices(vector<int>& nums) \\n    {\\n        vector<int> sorted=v;\\n        sort(sorted.begin(),sorted.end());\\n        nums=sorted;        \\n        int s=0,e=(nums.size()+1)/2,count=0;\\n        while(e<nums.size())\\n        {\\n            if(2*nums[s]<=nums[e])\\n            {\\n                s++;\\n                count++;\\n            }\\n            e++;\\n        }\\n        cout<<\"ankit\"<<e<<\" \";\\n       return 2*count;\\n    }\\n};\\n// [1,78,27,48,14,86,79,68,77,20,57,21,18,67,5,51,70,85,47,56,22,79,41,8,39,81,59,74,14,45,49,15,10,28,16,77,22,65,8,36,79,94,44,80,72,8,96,78,39,92,69,55,9,44,26,76,40,77,16,69,40,64,12,48,66,7,59,10]\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxNumOfMarkedIndices(vector<int>& nums) \\n    {\\n        vector<int> sorted=v;\\n        sort(sorted.begin(),sorted.end());\\n        nums=sorted;        \\n        int s=0,e=(nums.size()+1)/2,count=0;\\n        while(e<nums.size())\\n        {\\n            if(2*nums[s]<=nums[e])\\n            {\\n                s++;\\n                count++;\\n            }\\n            e++;\\n        }\\n        cout<<\"ankit\"<<e<<\" \";\\n       return 2*count;\\n    }\\n};\\n// [1,78,27,48,14,86,79,68,77,20,57,21,18,67,5,51,70,85,47,56,22,79,41,8,39,81,59,74,14,45,49,15,10,28,16,77,22,65,8,36,79,94,44,80,72,8,96,78,39,92,69,55,9,44,26,76,40,77,16,69,40,64,12,48,66,7,59,10]\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3231144,
                "title": "video-explanation-how-to-reach-at-2-pointers-solution",
                "content": "# Video Explanation\\n\\nhttps://youtu.be/lk9H3FYvqQw\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort (nums.begin(), nums.end());\\n        int n = nums.size();\\n        \\n        vector<bool> marked(n, false);\\n        int l = 0, r = (n + 1)/2;\\n        \\n        while (l <= (n-1)/2) {\\n            while (r < n && nums[l]*2 > nums[r]) r ++;\\n            \\n            if (r < n) {\\n                marked[l] = marked[r] = true;\\n                l ++, r ++;\\n            }\\n            else break;\\n        }\\n        \\n        int result = 0;\\n        for (auto i : marked) if (i) result ++;\\n        return result;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort (nums.begin(), nums.end());\\n        int n = nums.size();\\n        \\n        vector<bool> marked(n, false);\\n        int l = 0, r = (n + 1)/2;\\n        \\n        while (l <= (n-1)/2) {\\n            while (r < n && nums[l]*2 > nums[r]) r ++;\\n            \\n            if (r < n) {\\n                marked[l] = marked[r] = true;\\n                l ++, r ++;\\n            }\\n            else break;\\n        }\\n        \\n        int result = 0;\\n        for (auto i : marked) if (i) result ++;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231055,
                "title": "2-solutions-two-pointers-binary-search-c",
                "content": "# Binary Search\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        vector<int> v(n), idx, cnt(n);\\n        \\n        for(int i=0; i<n; i++) {\\n            int pos = lower_bound(nums.begin(), nums.end(), nums[i] * 2) - nums.begin();\\n            v[i] = pos < n ? pos : -1;\\n        }\\n        for(int i : v) {\\n            if(i != -1) idx.push_back(i);\\n        }\\n        sort(idx.begin(), idx.end(), greater<int>());\\n        \\n        int j = n - 1, ans = 0;\\n        for(int i : idx) {\\n            if(j >= i) cnt[j] = 1, j--;\\n        }\\n        for(int i : cnt) ans += i * 2;\\n        if(n % 2) n--;\\n        return min(ans, n);\\n    }\\n};\\n```\\n\\n# Two Pointers\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size() - 1, i = n / 2, j = n, ans = 0;\\n        while(i >= 0 && j > n / 2) {\\n            if(nums[i] * 2 <= nums[j]) ans += 2, i--, j--;\\n            else i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        vector<int> v(n), idx, cnt(n);\\n        \\n        for(int i=0; i<n; i++) {\\n            int pos = lower_bound(nums.begin(), nums.end(), nums[i] * 2) - nums.begin();\\n            v[i] = pos < n ? pos : -1;\\n        }\\n        for(int i : v) {\\n            if(i != -1) idx.push_back(i);\\n        }\\n        sort(idx.begin(), idx.end(), greater<int>());\\n        \\n        int j = n - 1, ans = 0;\\n        for(int i : idx) {\\n            if(j >= i) cnt[j] = 1, j--;\\n        }\\n        for(int i : cnt) ans += i * 2;\\n        if(n % 2) n--;\\n        return min(ans, n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size() - 1, i = n / 2, j = n, ans = 0;\\n        while(i >= 0 && j > n / 2) {\\n            if(nums[i] * 2 <= nums[j]) ans += 2, i--, j--;\\n            else i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230991,
                "title": "c-sorting-sliding-widow",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans = 0, i = 0, j, n = nums.size();\\n        j = n-1;\\n        for(i = n/2-1; i>=0;i--){\\n            if(nums[j]>=nums[i]*2){\\n                ans += 2;\\n                j--;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans = 0, i = 0, j, n = nums.size();\\n        j = n-1;\\n        for(i = n/2-1; i>=0;i--){\\n            if(nums[j]>=nums[i]*2){\\n                ans += 2;\\n                j--;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230970,
                "title": "sorting-two-pointers-approach",
                "content": "# Complexity\\n- Time `O(N logN)`\\n- Space `O(N) #for sorting`\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxNumOfMarkedIndices(self, nums):\\n        nums.sort()\\n        n, res = len(nums), 0\\n        ptr1, ptr2 = 0, n // 2\\n        while ptr2 < n:\\n            if nums[ptr1] * 2 <= nums[ptr2]:\\n                if nums[ptr1] == -1: break #this condition will help when n is odd.\\n                else:\\n                    nums[ptr1], nums[ptr2] = -1, -1 #Mark index as taken.\\n                    res += 2\\n                    ptr1 += 1\\n            ptr2 += 1\\n        return res\\n```\\n**UpVote**, if you like it **:)**",
                "solutionTags": [
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxNumOfMarkedIndices(self, nums):\\n        nums.sort()\\n        n, res = len(nums), 0\\n        ptr1, ptr2 = 0, n // 2\\n        while ptr2 < n:\\n            if nums[ptr1] * 2 <= nums[ptr2]:\\n                if nums[ptr1] == -1: break #this condition will help when n is odd.\\n                else:\\n                    nums[ptr1], nums[ptr2] = -1, -1 #Mark index as taken.\\n                    res += 2\\n                    ptr1 += 1\\n            ptr2 += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232456,
                "title": "sorting-set-intuition-behind-the-solution",
                "content": "1- As we need to find the number of pairs such that 2*nums[i]<=nums[j], so atfirst we will think of for each number finding the smallest number that will satisfy the given condition.\\n\\t\\t\\tError in this way - For each number if we find the smallest number that satisfy the given condition then it may lie in the same half which will decrease the number of other pairs that can be formed.\\n\\t\\t\\texample - A=[4,8,15,17]\\n\\t\\t\\tif we pair 4 with 8 then we cannot form pair of 15 and 17.\\nCorrect approach - We will think of the given array as two halves and the for the each number in the first half we will find the element satisfying the given condition in the second half as we can form maximum of n/2 pairs.\\n\\tExample - A=[4,8,15,17]\\n\\tNow we will consider 4,8 as the first hlaf and 15,17 as second half \\n\\tand for 4 we will form pair with 15 and for 8 we will form pair with 17.\\nFor finding such an element in the second half we can either use Two pointer, Binary search or Set\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& v) {\\n        sort(v.begin(), v.end());\\n        int ans=0, n=v.size();\\n        int i=(n-1)/2;\\n        multiset<int> s(v.begin(), v.end());\\n        while(s.size()>1 && i>=0){\\n            auto str=s.find(v[i]);\\n            auto ptr=s.lower_bound((*str)*2);\\n            if(ptr!=s.end()){\\n                ans+=2;\\n                s.erase(str);\\n                s.erase(ptr);\\n            }\\n            i--;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& v) {\\n        sort(v.begin(), v.end());\\n        int ans=0, n=v.size();\\n        int i=(n-1)/2;\\n        multiset<int> s(v.begin(), v.end());\\n        while(s.size()>1 && i>=0){\\n            auto str=s.find(v[i]);\\n            auto ptr=s.lower_bound((*str)*2);\\n            if(ptr!=s.end()){\\n                ans+=2;\\n                s.erase(str);\\n                s.erase(ptr);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3230953,
                "title": "javascript-code-with-approach",
                "content": "**The problem can be solved using a greedy approach. We need to mark pairs of indices in the array such that 2 * nums[i] <= nums[j], where i and j are unmarked indices. We want to mark as many pairs as possible, so we should try to mark the pairs that allow for the most remaining pairs to be marked.**\\n\\n**To achieve this, we can first sort the array in non-decreasing order. We can then use two pointers, one starting from the beginning of the array and the other starting from the middle of the array (rounded up). We can then iterate over the array from the middle pointer to the end pointer. For each pair of indices (i, j) where i is the index pointed to by the beginning pointer and j is the index pointed to by the middle pointer, we check if 2 * nums[i] <= nums[j]. If this condition is true, we can mark the indices i and j, and move the beginning pointer to the next unmarked index. Otherwise, we move the middle pointer to the next index.**\\n\\n**We continue this process until the middle pointer reaches the end of the array. The maximum number of marked indices is twice the value of the beginning pointer, since we mark pairs of indices.**\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxNumOfMarkedIndices = function(nums) {\\n     const n = nums.length;\\n  nums.sort((a, b) => a - b); // sort the array in non-decreasing order\\n  let st = 0;\\n  let mid = Math.floor((n + 1) / 2);\\n  while (mid < n) {\\n    if (nums[st] * 2 <= nums[mid]) {\\n      st++;\\n    }\\n    mid++;\\n  }\\n  return st * 2; \\n};\\n```\\n# UpVoting is Much Appreciated",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxNumOfMarkedIndices = function(nums) {\\n     const n = nums.length;\\n  nums.sort((a, b) => a - b); // sort the array in non-decreasing order\\n  let st = 0;\\n  let mid = Math.floor((n + 1) / 2);\\n  while (mid < n) {\\n    if (nums[st] * 2 <= nums[mid]) {\\n      st++;\\n    }\\n    mid++;\\n  }\\n  return st * 2; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3231743,
                "title": "binary-search-easy-solution",
                "content": "# Approach\\nBinary Search\\n\\nif we think brout force :\\nfor example given a sorted array : 2, 3, 5, 6, 7, 9\\ntake first 1 and last 1 numbers : 2x2 <= 9. It satisfy the condition\\nthen take first 2 and last 2 numbers : 2x2 <= 7, 3x2 <= 9. It satisfy the condition.\\nthen take first 3 and last 3 number : 2x2 <= 6, 3x2 <= 7, but 5x3 > 9 It does not satisfy the condition.\\nSo the ans is 2.\\n```\\nclass Solution {\\npublic:\\n    int max_count(vector<int>&a)\\n    {\\n        sort(a.begin(),a.end());\\n        int ans = 0, n = a.size();\\n        int l = 0, r = n/2;\\n        while(l <= r)\\n        {\\n            int mid = (l+r)/2, flag = 0, c1 = 0;\\n            vector <int> v, v1;\\n\\n            for (int i = 0; i < mid; i++) v.push_back(a[i]);\\n            // store from first in v\\n            for (int i = n-1; i >= 0; i--) {\\n                if (c1 == mid) break;\\n                v1.push_back(a[i]);\\n                c1++;\\n            }\\n            // store from last in v1 and then reverse\\n            reverse(v1.begin(), v1.end());\\n            for (int i = 0; i < mid; i++) \\n            {\\n                if (v[i]*2 > v1[i]) flag = 1;\\n            }\\n            if (flag == 0) { // if all element v[i]*2 <= v1[i]\\n                ans = mid;\\n                l = mid+1;\\n            }\\n            else {\\n                r = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int maxNumOfMarkedIndices(vector<int>& a) \\n    {\\n        int x = max_count(a);\\n        return x*2;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    int max_count(vector<int>&a)\\n    {\\n        sort(a.begin(),a.end());\\n        int ans = 0, n = a.size();\\n        int l = 0, r = n/2;\\n        while(l <= r)\\n        {\\n            int mid = (l+r)/2, flag = 0, c1 = 0;\\n            vector <int> v, v1;\\n\\n            for (int i = 0; i < mid; i++) v.push_back(a[i]);\\n            // store from first in v\\n            for (int i = n-1; i >= 0; i--) {\\n                if (c1 == mid) break;\\n                v1.push_back(a[i]);\\n                c1++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3231390,
                "title": "binary-search-easy-lower-bound",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        sort(begin(nums), end(nums));\\n        \\n        int i = 0,j = 0, n = size(nums), cnt = 0;\\n        auto it = nums.begin();\\n        \\n        for(int i = 0; i < n/2; i++) {\\n            \\n            it++;\\n            it = lower_bound(it, end(nums), nums[i]*2);\\n            if(it == end(nums))break;\\n            cnt++;\\n        }\\n        return cnt*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        sort(begin(nums), end(nums));\\n        \\n        int i = 0,j = 0, n = size(nums), cnt = 0;\\n        auto it = nums.begin();\\n        \\n        for(int i = 0; i < n/2; i++) {\\n            \\n            it++;\\n            it = lower_bound(it, end(nums), nums[i]*2);\\n            if(it == end(nums))break;\\n            cnt++;\\n        }\\n        return cnt*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231064,
                "title": "very-simple-solution",
                "content": "**connect with me on linkedin https://www.linkedin.com/in/raghav-upadhyay-80336b229/**\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& n) {\\n        int myans=0;\\n        sort(n.begin(),n.end());\\n        int i=0,j=(n.size()+1)/2;\\n        while(j<n.size()){\\n            if(n[i]*2<=n[j]){\\n                myans++;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return myans*2;\\n    }\\n};\\n```\\n# **Don\\'t forgot to upvote \\u2B06\\uFE0F**\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& n) {\\n        int myans=0;\\n        sort(n.begin(),n.end());\\n        int i=0,j=(n.size()+1)/2;\\n        while(j<n.size()){\\n            if(n[i]*2<=n[j]){\\n                myans++;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return myans*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230996,
                "title": "c-binary-search-greedy-similar-to-painters-partition",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool pos(int x,vector<int>&nums){\\n        int n=nums.size();\\n        int i=0;\\n        int j=x;\\n        while(i<x&&j<n){\\n            if(nums[i]*2<=nums[j])\\n                i++;\\n            j++;\\n        }\\n        return i==x;\\n    }\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int lo=0;\\n        int hi=nums.size()/2;\\n        int ans=0;\\n        while(lo<=hi){\\n            int mid=lo+(hi-lo)/2;\\n            if(pos(mid,nums)){\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n            else{\\n                hi=mid-1;\\n            }\\n        }\\n        return ans*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool pos(int x,vector<int>&nums){\\n        int n=nums.size();\\n        int i=0;\\n        int j=x;\\n        while(i<x&&j<n){\\n            if(nums[i]*2<=nums[j])\\n                i++;\\n            j++;\\n        }\\n        return i==x;\\n    }\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int lo=0;\\n        int hi=nums.size()/2;\\n        int ans=0;\\n        while(lo<=hi){\\n            int mid=lo+(hi-lo)/2;\\n            if(pos(mid,nums)){\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n            else{\\n                hi=mid-1;\\n            }\\n        }\\n        return ans*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603312,
                "title": "understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n   \\n   the main problem of this question was , that  we want to increase the count of maximum marked index\\n   , now since 10^5 length h array ki , oth ye toh pakka h ki hum sorting karenge ; \\n\\n   // now , hum starting se iterate kar re hain , ab kaun se index wale ko uske saath pair kare , ye dikkat \\n   hai ( because marked humesha pair mein honge , becauae each time we have to take two unmarked index)\\n   and we have to marked them , and \\n\\n   ONE IMPORANT POINT IS THAT ANSWER WILL BE EVEN , MEANS COUNT OF MARKED INDEX WILL BE EVEN ( obviously \\n   because we are marking indexes in pairs ) , and THE MAXIMUM ANSWER CAN BE (N/2) BECAUSE USKE BAAD\\n   ELEMENT BACHENGE HI NAHI \\n\\n\\n   NOW THE Optimised way OF DOING QUESITNO IS \\n\\n   1. SORT THE ARRAY ; \\n\\n   2. DIVIDE THE ARRAY INTO TWO PARTS , AND DONO KE STARTING MEIN TWO POINTERS RAKEHNGE AND THEN\\n      COUNT GINNA SHURU KARENGE ; \\n\\n      ( JAB BHI PAIR MEIN INDEXES MEIN MARKED KARNA HO , KISI BHI REASON KE WAJAH SE ,TOH PHLE\\n      SORT KARENEGE , FIRST USKE BAAD MATCHING \\n      HUMESHA AISE HI HOGI , ARRAY KKO 2 PART MEIN DIVIDE KARENGE , FIR DO POINTER DONO KE STARTING\\n      MEIN RAKH DENGE , AUR FIR DEKHENGE )\\n*/\\n\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        \\n        \\n        Arrays.sort(nums) ;\\n\\n         int i = 0 ; \\n         int j = nums.length/2 ; \\n\\n          long count = 0 ;\\n\\n         while( i < nums.length/2 && j < nums.length)\\n         {\\n             if( nums[i] *2  <= nums[j])\\n             {\\n                 i++ ; \\n                 j++ ;\\n\\n                 count = count+ 2 ; // kyonki pair mein indexes marked ho rahe hain , isliye count humesha \\n                 // 2 se badh rahi hai ;  \\n             }\\n             else\\n             {\\n                 j++ ; \\n             }\\n         }\\n\\n         return (int)count ; \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n   \\n   the main problem of this question was , that  we want to increase the count of maximum marked index\\n   , now since 10^5 length h array ki , oth ye toh pakka h ki hum sorting karenge ; \\n\\n   // now , hum starting se iterate kar re hain , ab kaun se index wale ko uske saath pair kare , ye dikkat \\n   hai ( because marked humesha pair mein honge , becauae each time we have to take two unmarked index)\\n   and we have to marked them , and \\n\\n   ONE IMPORANT POINT IS THAT ANSWER WILL BE EVEN , MEANS COUNT OF MARKED INDEX WILL BE EVEN ( obviously \\n   because we are marking indexes in pairs ) , and THE MAXIMUM ANSWER CAN BE (N/2) BECAUSE USKE BAAD\\n   ELEMENT BACHENGE HI NAHI \\n\\n\\n   NOW THE Optimised way OF DOING QUESITNO IS \\n\\n   1. SORT THE ARRAY ; \\n\\n   2. DIVIDE THE ARRAY INTO TWO PARTS , AND DONO KE STARTING MEIN TWO POINTERS RAKEHNGE AND THEN\\n      COUNT GINNA SHURU KARENGE ; \\n\\n      ( JAB BHI PAIR MEIN INDEXES MEIN MARKED KARNA HO , KISI BHI REASON KE WAJAH SE ,TOH PHLE\\n      SORT KARENEGE , FIRST USKE BAAD MATCHING \\n      HUMESHA AISE HI HOGI , ARRAY KKO 2 PART MEIN DIVIDE KARENGE , FIR DO POINTER DONO KE STARTING\\n      MEIN RAKH DENGE , AUR FIR DEKHENGE )\\n*/\\n\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        \\n        \\n        Arrays.sort(nums) ;\\n\\n         int i = 0 ; \\n         int j = nums.length/2 ; \\n\\n          long count = 0 ;\\n\\n         while( i < nums.length/2 && j < nums.length)\\n         {\\n             if( nums[i] *2  <= nums[j])\\n             {\\n                 i++ ; \\n                 j++ ;\\n\\n                 count = count+ 2 ; // kyonki pair mein indexes marked ho rahe hain , isliye count humesha \\n                 // 2 se badh rahi hai ;  \\n             }\\n             else\\n             {\\n                 j++ ; \\n             }\\n         }\\n\\n         return (int)count ; \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547370,
                "title": "simplest-python-solution-linear-tc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n=len(nums)\\n        ct=0\\n        rct=[i for i in range((n//2),n)]\\n        for i in range((n//2)-1,-1,-1):\\n            if rct:\\n                if nums[rct[-1]]>=2*nums[i]:\\n                    rct.pop()\\n                    ct+=2\\n                else:\\n                    rct.insert(0,i)\\n            else:\\n                rct.insert(0,i)\\n        return ct\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n=len(nums)\\n        ct=0\\n        rct=[i for i in range((n//2),n)]\\n        for i in range((n//2)-1,-1,-1):\\n            if rct:\\n                if nums[rct[-1]]>=2*nums[i]:\\n                    rct.pop()\\n                    ct+=2\\n                else:\\n                    rct.insert(0,i)\\n            else:\\n                rct.insert(0,i)\\n        return ct\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494167,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nsliding window and sorting\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: nlog(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) \\n    {\\n       sort(nums.begin(),nums.end());\\n       int n= nums.size();\\n       int i =n/2-1;    //one pointer at middle of sorted array\\n       int j=n-1;       // another pointer at the end\\n       int ans=0;\\n       while(i>=0)\\n       {\\n           if(nums[j]>=nums[i]*2)\\n         {  \\n             ans+=2;\\n              --j;\\n         }\\n              i--;\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) \\n    {\\n       sort(nums.begin(),nums.end());\\n       int n= nums.size();\\n       int i =n/2-1;    //one pointer at middle of sorted array\\n       int j=n-1;       // another pointer at the end\\n       int ans=0;\\n       while(i>=0)\\n       {\\n           if(nums[j]>=nums[i]*2)\\n         {  \\n             ans+=2;\\n              --j;\\n         }\\n              i--;\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335079,
                "title": "c-sorting-two-pointers-faster-easy-to-understand",
                "content": "* ***Using Sorting && Two Pointers***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // sort the nums\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        // use two pointers\\n        \\n        int i = 0, j = n / 2;\\n        \\n        int count = 0;\\n        \\n        while(i < n / 2 && j < n)\\n        {\\n            if(2 * nums[i] <= nums[j])\\n            {\\n                count++;\\n                \\n                i++;\\n                \\n                j++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        \\n        return 2 * count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // sort the nums\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        // use two pointers\\n        \\n        int i = 0, j = n / 2;\\n        \\n        int count = 0;\\n        \\n        while(i < n / 2 && j < n)\\n        {\\n            if(2 * nums[i] <= nums[j])\\n            {\\n                count++;\\n                \\n                i++;\\n                \\n                j++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        \\n        return 2 * count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3245332,
                "title": "scala-binary-search-recursion",
                "content": "# Code\\n```\\nobject Solution {\\n  def maxNumOfMarkedIndices(nums: Array[Int]): Int = {\\n    lazy val nsize = nums.size\\n    lazy val sorted = nums.sorted\\n    def check(k: Int): Boolean = (0 until k).forall{i => (2*sorted(i)) <= sorted(nsize-k+i)}\\n    def bs(lo: Int, hi: Int): Int = {\\n      lazy val mid = (hi+lo)/2\\n      if(lo+1>=hi) lo else if(check(mid)) bs(mid,hi) else bs(lo,mid)\\n    }\\n    if(check(nsize/2)) (nsize/2)*2 else bs(0,nsize/2)*2\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Binary Search",
                    "Recursion"
                ],
                "code": "```\\nobject Solution {\\n  def maxNumOfMarkedIndices(nums: Array[Int]): Int = {\\n    lazy val nsize = nums.size\\n    lazy val sorted = nums.sorted\\n    def check(k: Int): Boolean = (0 until k).forall{i => (2*sorted(i)) <= sorted(nsize-k+i)}\\n    def bs(lo: Int, hi: Int): Int = {\\n      lazy val mid = (hi+lo)/2\\n      if(lo+1>=hi) lo else if(check(mid)) bs(mid,hi) else bs(lo,mid)\\n    }\\n    if(check(nsize/2)) (nsize/2)*2 else bs(0,nsize/2)*2\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3240140,
                "title": "c-easy-to-understand-two-pointers",
                "content": "# Complexity\\n- Time complexity:  O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count = 0;\\n        int i = 0;\\n        int j = (nums.size())/2;\\n        while(i < nums.size()/2 and j < nums.size()) \\n        {\\n            if((2*nums[i]) <= nums[j])\\n            {\\n                count += 2;\\n                j++;\\n                i++;\\n            }\\n            else j++;\\n        }   \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count = 0;\\n        int i = 0;\\n        int j = (nums.size())/2;\\n        while(i < nums.size()/2 and j < nums.size()) \\n        {\\n            if((2*nums[i]) <= nums[j])\\n            {\\n                count += 2;\\n                j++;\\n                i++;\\n            }\\n            else j++;\\n        }   \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236042,
                "title": "using-two-pointers-easy-to-understand-with-explanation",
                "content": "# Intuition\\nTake two pointers one on 0th index and another on n/2th index where n = length of the array.\\nIterator till last index and check if the 2*(value of ith index) <= (value of jth index) then mark nums[j] as visited and increment both pointers by 1.\\nIf nums[i] is visited then increment i by 1\\n\\n\\n# Complexity\\n- Time complexity:\\n- O(N) where n = size of array\\n\\n- Space complexity:\\n- constant\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans = 0,i=0,j=nums.size()/2;\\n        while(j<nums.size()) {\\n            if(nums[i]==-1) {i+=1; continue;}\\n            if(nums[i]*2 <= nums[j]) {\\n                ans+=2;\\n                nums[j]=-1;\\n                i+=1; j+=1;\\n            }\\n            else {\\n                j+=1;\\n            }\\n        } return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans = 0,i=0,j=nums.size()/2;\\n        while(j<nums.size()) {\\n            if(nums[i]==-1) {i+=1; continue;}\\n            if(nums[i]*2 <= nums[j]) {\\n                ans+=2;\\n                nums[j]=-1;\\n                i+=1; j+=1;\\n            }\\n            else {\\n                j+=1;\\n            }\\n        } return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235431,
                "title": "java-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        \\n        int res = 0;\\n        Arrays.sort(nums);\\n\\n        // visited array to mark the indices we visited , so not to take the \\n        // same indices again\\n        boolean[] visited = new boolean[nums.length];\\n        for(int i = 0;i<nums.length/2;i++)\\n        {\\n            int target = 2 * nums[i];\\n            if(binarySearch(nums, target , i/2 , nums.length-1, visited))\\n                res+=2;\\n        }\\n\\n        return res;\\n    }\\n  \\n    boolean binarySearch(int [] nums , int target , int start , int end, boolean [] visited)\\n    {\\n\\n        boolean found = false;\\n        int index = -1;\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n\\n            if (target <= nums[mid] && !visited[mid]) {\\n                found = true;\\n                index = mid;\\n                end = mid - 1;\\n\\n            } else {\\n                start = mid + 1;\\n            }\\n\\n        }\\n\\n\\n        if (found)\\n            visited[index] = true;\\n\\n        return found;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        \\n        int res = 0;\\n        Arrays.sort(nums);\\n\\n        // visited array to mark the indices we visited , so not to take the \\n        // same indices again\\n        boolean[] visited = new boolean[nums.length];\\n        for(int i = 0;i<nums.length/2;i++)\\n        {\\n            int target = 2 * nums[i];\\n            if(binarySearch(nums, target , i/2 , nums.length-1, visited))\\n                res+=2;\\n        }\\n\\n        return res;\\n    }\\n  \\n    boolean binarySearch(int [] nums , int target , int start , int end, boolean [] visited)\\n    {\\n\\n        boolean found = false;\\n        int index = -1;\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n\\n            if (target <= nums[mid] && !visited[mid]) {\\n                found = true;\\n                index = mid;\\n                end = mid - 1;\\n\\n            } else {\\n                start = mid + 1;\\n            }\\n\\n        }\\n\\n\\n        if (found)\\n            visited[index] = true;\\n\\n        return found;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233411,
                "title": "c-and-python-beats-100-most-efficient-solution-sorting-two-pointers",
                "content": "\\n\\n# Code\\n**C++ Solution:-**\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        int n = nums.size();\\n        int i = 0;\\n        int j = n / 2;\\n        int ans = 0;\\n        while (i < n/2 && j < n) {\\n            if (2 * nums[i] <= nums[j]) {\\n                ans += 2;\\n                i++;\\n                j++;\\n            }\\n            else {\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Python Solution:-**\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        i = 0\\n        j = n // 2\\n        ans = 0\\n        while i < n//2 and j < n:\\n            if 2*nums[i] <= nums[j]:\\n                ans += 2\\n                i += 1\\n                j += 1\\n            else:\\n                j += 1\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        int n = nums.size();\\n        int i = 0;\\n        int j = n / 2;\\n        int ans = 0;\\n        while (i < n/2 && j < n) {\\n            if (2 * nums[i] <= nums[j]) {\\n                ans += 2;\\n                i++;\\n                j++;\\n            }\\n            else {\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        i = 0\\n        j = n // 2\\n        ans = 0\\n        while i < n//2 and j < n:\\n            if 2*nums[i] <= nums[j]:\\n                ans += 2\\n                i += 1\\n                j += 1\\n            else:\\n                j += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233039,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def maxNumOfMarkedIndices(nums: Array[Int]): Int = {\\n        def help(leftSorted: Array[Int], rigthSorted: Array[Int], res: Int): Int = (leftSorted, rigthSorted) match {\\n            case (l, r) if(l.isEmpty || r.isEmpty) => res\\n            case (l, r) if(l(0) * 2 <= r(0)) => help(l.tail, r.tail, res + 2)\\n            case (l, r) => help(l, r.tail, res)\\n        }\\n\\n        val (leftSorted, rigthSorted) = nums.sorted.splitAt(nums.length / 2)\\n        help(leftSorted, rigthSorted, 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def maxNumOfMarkedIndices(nums: Array[Int]): Int = {\\n        def help(leftSorted: Array[Int], rigthSorted: Array[Int], res: Int): Int = (leftSorted, rigthSorted) match {\\n            case (l, r) if(l.isEmpty || r.isEmpty) => res\\n            case (l, r) if(l(0) * 2 <= r(0)) => help(l.tail, r.tail, res + 2)\\n            case (l, r) => help(l, r.tail, res)\\n        }\\n\\n        val (leftSorted, rigthSorted) = nums.sorted.splitAt(nums.length / 2)\\n        help(leftSorted, rigthSorted, 0)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3232764,
                "title": "two-pointers",
                "content": "## Why include the middle element in the 1st half\\nFor the people confused why mid is in the first part:\\nWe know that the condition: nums[firstElement]<=2*nums[secondElement] will hold true for all elements to the right of second element:\\nfor example:\\n[1,2,3] => if 12<=2 (indices 0,1), which is true\\nit will also be true for 12<=3, (indices 0,2)\\n\\nThus we can say if we choose to include in the middle we cancel the possibility that:\\nnums[mid]<=nums[lastElement]\\n\\nNow consider this possibility existed, we will never mark it as the middle element is a part of our second half.\\nBut if we kept it as a part of our 1st half we will be able to make a pair of this with the last element:(mid,lastIndex)\\nNow what happened to the index for which mid satisfied the condition: i.e. nums[smallerIndex]*2<=nums[mid]; it can still be marked with indexes greater than mid;\\nsay nums[smallerIndex]>*2<=nums[mid+1] (mid+1 is just for demonstration here, any index with a value greater than mid could be paired with the smaller index as they all are greater than the smaller index).\\n\\nHope I was properly able to explain the reason why we take 1st half as [0, mid] and 2nd half as (mid,lastIndex]\\n\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        i=0\\n        nums.sort()\\n        for j in range(n//2,n):\\n            i+= nums[j]>=nums[i]*2\\n        return i*2\\n```\\nSolution credits: @votrubac\\n\\n**Example**:\\n```\\nIf n= 5\\nN//2 or n-n//2\\n2 or 5-2=3\\n\\n----v\\n0 1 2 3 4. [indexes of an array of length 5]\\n------^\\nseparate as :\\n{0,1,2} and {3,4}\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        i=0\\n        nums.sort()\\n        for j in range(n//2,n):\\n            i+= nums[j]>=nums[i]*2\\n        return i*2\\n```\n```\\nIf n= 5\\nN//2 or n-n//2\\n2 or 5-2=3\\n\\n----v\\n0 1 2 3 4. [indexes of an array of length 5]\\n------^\\nseparate as :\\n{0,1,2} and {3,4}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232686,
                "title": "kotlin-sorting-two-pointers-100",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    fun maxNumOfMarkedIndices(nums: IntArray): Int {    \\n        nums.sort()    \\n        var count = 0\\n        var i = 0\\n        var j = nums.size / 2\\n\\n        while(j < nums.size && i < nums.size / 2) {\\n            if(nums[i] * 2 <= nums[j]) {\\n                count+=2\\n                i++\\n                j++\\n            } else {\\n                j++\\n            }\\n        }\\n\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    fun maxNumOfMarkedIndices(nums: IntArray): Int {    \\n        nums.sort()    \\n        var count = 0\\n        var i = 0\\n        var j = nums.size / 2\\n\\n        while(j < nums.size && i < nums.size / 2) {\\n            if(nums[i] * 2 <= nums[j]) {\\n                count+=2\\n                i++\\n                j++\\n            } else {\\n                j++\\n            }\\n        }\\n\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232532,
                "title": "go-python-o-n-time-o-1-space",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```golang []\\nfunc maxNumOfMarkedIndices(nums []int) int {\\n    n := len(nums)\\n    sort.Ints(nums)\\n    answer := 0\\n    i := n / 2 - 1\\n    j := n - 1\\n    for i >= 0{\\n        if nums[i] * 2 <= nums[j]{\\n            answer+=2\\n            j--\\n        }\\n        i--\\n    }\\n    return answer\\n}\\n```\\n```python []\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        answer = 0\\n        i = n // 2 - 1\\n        j = n - 1\\n        while i >= 0:\\n            if nums[i] * 2 <= nums[j]:\\n                answer+=2\\n                j-=1\\n            i-=1\\n        return answer\\n```",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Two Pointers",
                    "Greedy",
                    "Sort"
                ],
                "code": "```golang []\\nfunc maxNumOfMarkedIndices(nums []int) int {\\n    n := len(nums)\\n    sort.Ints(nums)\\n    answer := 0\\n    i := n / 2 - 1\\n    j := n - 1\\n    for i >= 0{\\n        if nums[i] * 2 <= nums[j]{\\n            answer+=2\\n            j--\\n        }\\n        i--\\n    }\\n    return answer\\n}\\n```\n```python []\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        answer = 0\\n        i = n // 2 - 1\\n        j = n - 1\\n        while i >= 0:\\n            if nums[i] * 2 <= nums[j]:\\n                answer+=2\\n                j-=1\\n            i-=1\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232472,
                "title": "two-pointers-o-nlogn-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor an array of size n there will be exactly n/2 pairs, so we\\'ve divided the array into two halves and compared the left half with right half.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the array and take 2 pointers i and j and place it at index 0 and n/2 respectively.\\nNow we\\'ll check for the condition i.e 2*nums[i] <= nums[j] and if satisfied, we\\'ll move forward and check for other numbers. If not then we keep on finding the pair for the current element nums[i].\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int i = 0;\\n        int j = n/2;\\n        int cnt = 0;\\n        while(i < n/2 and j < n){\\n            if(2*nums[i] <= nums[j]){\\n                i++;\\n                j++;\\n                cnt+=2;\\n            } else{\\n                j++;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int i = 0;\\n        int j = n/2;\\n        int cnt = 0;\\n        while(i < n/2 and j < n){\\n            if(2*nums[i] <= nums[j]){\\n                i++;\\n                j++;\\n                cnt+=2;\\n            } else{\\n                j++;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232366,
                "title": "java-easy-solution-beats-100",
                "content": "# Intuition\\nSorting and TWo Pointers,constant space\\n\\n# Approach\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int counter = 0;\\n        int i =0, j =nums.length/2;\\n\\n        while(i < nums.length/2  &&  j < nums.length){\\n            if(nums[i] * 2 <= nums[j]){\\n                counter += 2;\\n                i++;j++;\\n                continue;\\n            }\\n           j++;\\n        } \\n\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int counter = 0;\\n        int i =0, j =nums.length/2;\\n\\n        while(i < nums.length/2  &&  j < nums.length){\\n            if(nums[i] * 2 <= nums[j]){\\n                counter += 2;\\n                i++;j++;\\n                continue;\\n            }\\n           j++;\\n        } \\n\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231193,
                "title": "simply-sort-the-array-and-divide-it-into-two-halves",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int j=nums.size()-1;\\n        int c=0;\\n        int i=0;\\n        for(int i=nums.size()/2-1;i>=0;i--)\\n        {\\n            if(nums[i]*2<=nums[j])\\n            {\\n                c+=2;\\n                j--;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int j=nums.size()-1;\\n        int c=0;\\n        int i=0;\\n        for(int i=nums.size()/2-1;i>=0;i--)\\n        {\\n            if(nums[i]*2<=nums[j])\\n            {\\n                c+=2;\\n                j--;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231134,
                "title": "two-pointer-sorting-tc-o-nlogn-sc-o-1",
                "content": "# Approach\\nThe given problem requires us to find the maximum number of indices we can mark in the input array nums. To mark an index, we need to select two different unmarked indices i and j such that 2*nums[i] <= nums[j].\\n\\nThe given solution uses two pointers to solve this problem. First, we sort the input array in ascending order. We then initialize two pointers i and j. The pointer i starts at the beginning of the array, and the pointer j starts at the middle of the array.\\n\\nThe condition for finding a suitable index pair (i,j) is nums[i]*2 <= nums[j]. When we find such a pair, we increment the counter cnt by 2, as we can mark both i and j. Finally, we increment the pointer j and move to the next index.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end()); // sort the input array\\n        int j = n/2; // initialize pointer j to middle of the array\\n        int cnt = 0; // initialize counter to 0\\n        for(int i=0; i<n/2 && j<n; i++) { // loop over the array using pointer i until the middle index\\n            while(j<n && nums[i]*2 > nums[j]) { // try to find a suitable index j using a nested loop\\n                j++; // increment j until a suitable index is found\\n            }\\n            if(j<n) cnt += 2; // increment the counter by 2 as we can mark both i and j\\n            j++; // move to the next index\\n        }\\n        return cnt; // return the maximum number of marked indices\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end()); // sort the input array\\n        int j = n/2; // initialize pointer j to middle of the array\\n        int cnt = 0; // initialize counter to 0\\n        for(int i=0; i<n/2 && j<n; i++) { // loop over the array using pointer i until the middle index\\n            while(j<n && nums[i]*2 > nums[j]) { // try to find a suitable index j using a nested loop\\n                j++; // increment j until a suitable index is found\\n            }\\n            if(j<n) cnt += 2; // increment the counter by 2 as we can mark both i and j\\n            j++; // move to the next index\\n        }\\n        return cnt; // return the maximum number of marked indices\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231056,
                "title": "how-to-think-for-initialization-of-pointers-intuition-of-2-pointers-explained-o-nlogn-n",
                "content": "# Idea\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- See looking at prob, if they suppose mentioned that we can use marked multiple times then all we need to do is to take max ele and compare how many nums[i]*2 <= max ele\\n- But here we cannnot reuse\\n- so technically speaking we need to keep i at 0 and j at half of array\\n- Why ? See at max we can mark All elements ANS is N\\n- For that we need to pair 0 with half, 1 with half+1, .... half-1 with N-1\\n- So we keep pointers that way like i=0 and j= (N+1)/2\\n- So at max we can get N/2 pairs, so we always do j++, doesnt matter used or not.\\n- Whereas i is like the border for CONDITION VALID. As ARR is sorted, if Arr[i] is marked then Arr[0...i-1] should ofcourse have a pair, without which it cant exist.\\n-  At last i*2 is the tot nos of elements\\n- because every i has a unique j at that end\\n\\n# Complexity\\n- Time complexity:$$O(NLogN + N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end()); // sort the array in non-decreasing order\\n        int n = nums.size();\\n        int i = 0, j = (n+1)/2;\\n        int ctr = 0;\\n        while (j < n) {\\n            if (2*nums[i] <= nums[j]) { \\n                i++; \\n            }\\n            j++; \\n        }\\n        return i*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end()); // sort the array in non-decreasing order\\n        int n = nums.size();\\n        int i = 0, j = (n+1)/2;\\n        int ctr = 0;\\n        while (j < n) {\\n            if (2*nums[i] <= nums[j]) { \\n                i++; \\n            }\\n            j++; \\n        }\\n        return i*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231040,
                "title": "o-nlogn-java",
                "content": "# Complexity\\n- Time complexity: $$O(nlog(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n\\n        int end = n - 1;\\n        int ans = 0;\\n\\n        for (int i = (n / 2) - 1; i >= 0; i--) {\\n            if (nums[i] * 2 <= nums[end]) {\\n                ans += 2;\\n                nums[i] = -1;\\n                nums[end] = -1;\\n            }\\n\\n            while (end >= 0 && nums[end] == -1) end--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n\\n        int end = n - 1;\\n        int ans = 0;\\n\\n        for (int i = (n / 2) - 1; i >= 0; i--) {\\n            if (nums[i] * 2 <= nums[end]) {\\n                ans += 2;\\n                nums[i] = -1;\\n                nums[end] = -1;\\n            }\\n\\n            while (end >= 0 && nums[end] == -1) end--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231028,
                "title": "easy-to-understand-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n        int j=nums.size()-1;\\n        int ans=0;\\n        for(int i=(nums.size()/2)-1;i>=0;i--){\\n            if(nums[i]*2<=nums[j]){\\n                ans+=2;\\n                j--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n        int j=nums.size()-1;\\n        int ans=0;\\n        for(int i=(nums.size()/2)-1;i>=0;i--){\\n            if(nums[i]*2<=nums[j]){\\n                ans+=2;\\n                j--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230962,
                "title": "easiest-way",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary Search\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int s = 0;\\n        int e = (n+1)/2;\\n        \\n        while(e<n){\\n            if(2 * nums[s] <= nums[e])\\n                s++;\\n            e++;\\n        }\\n        return s*2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int s = 0;\\n        int e = (n+1)/2;\\n        \\n        while(e<n){\\n            if(2 * nums[s] <= nums[e])\\n                s++;\\n            e++;\\n        }\\n        return s*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230911,
                "title": "multiset-easy-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int maxNumOfMarkedIndices(vector<int>& v) {\\n        int n=v.size();\\n        int ans=0;\\n        sort(v.begin(),v.end());\\n        multiset<int>s;\\n        for(int i=n/2; i<n; i++) s.insert(v[i]);\\n        for(int i=v.size()/2-1; i>=0; i--) {\\n            auto up=s.lower_bound(v[i]*2);\\n            if(up!=s.end()){\\n                ans+=2;\\n                s.erase(up);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int maxNumOfMarkedIndices(vector<int>& v) {\\n        int n=v.size();\\n        int ans=0;\\n        sort(v.begin(),v.end());\\n        multiset<int>s;\\n        for(int i=n/2; i<n; i++) s.insert(v[i]);\\n        for(int i=v.size()/2-1; i>=0; i--) {\\n            auto up=s.lower_bound(v[i]*2);\\n            if(up!=s.end()){\\n                ans+=2;\\n                s.erase(up);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230895,
                "title": "greedy-two-pointers-pair-smaller-half-to-larger-half",
                "content": "Sort the numbers, use two pointers, left at the n // 2 - 1, right at n - 1. Greedily pair left pointed to the right pointed. If a left pointed unmatchable, skip it and try matching [left - 1] to [right].\\n\\n# Code\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        # ans = 0\\n        \\n        # print(n, nums)\\n        # print(nums[:n//2])\\n        \\n        marked = [0] * n\\n        \\n        j = n - 1\\n        for i in range(n // 2 - 1, -1, -1):\\n            if marked[i]:\\n                continue\\n            found = 1\\n            while marked[j]:\\n                j -= 1\\n                if j == i:\\n                    found = 0\\n                    break\\n            if not found:\\n                continue\\n            if nums[i] * 2 <= nums[j]:\\n                marked[i] = marked[j] = 1\\n                j -= 1\\n        \\n        return sum(marked)\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        # ans = 0\\n        \\n        # print(n, nums)\\n        # print(nums[:n//2])\\n        \\n        marked = [0] * n\\n        \\n        j = n - 1\\n        for i in range(n // 2 - 1, -1, -1):\\n            if marked[i]:\\n                continue\\n            found = 1\\n            while marked[j]:\\n                j -= 1\\n                if j == i:\\n                    found = 0\\n                    break\\n            if not found:\\n                continue\\n            if nums[i] * 2 <= nums[j]:\\n                marked[i] = marked[j] = 1\\n                j -= 1\\n        \\n        return sum(marked)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230851,
                "title": "easy-clean-c",
                "content": "# Intuition\\nTwo Pointer\\n\\n# Approach\\nWe can sort the array and count the number of good pairs using two pointers in linear time.\\n\\n1. We keep the first pointer at the beginning of the sorted array (as we have to start taking first element of pairs from minimum).\\n\\n2. We keep the second pointer after half of the sorted array, as the maximum good pairs we can get will be half of the array.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(c)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        int n = nums.size(), result = 0;\\n        \\n        sort(nums.begin(), nums.end());\\n        if(n == 1)return 0;\\n        \\n        \\n        int first = 0, last = (n + 1) / 2; // we only need to start taking second element of pairs after half of \\n                                           // the array, as maximum number of good pairs will be n / 2\\n        \\n        while(last < n)\\n        {\\n            if(2 * nums[first] <= nums[last])\\n            {\\n                result++; // counting number of good pairs\\n                first++;\\n            }\\n            \\n            last++;\\n        }\\n        \\n        return result * 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        int n = nums.size(), result = 0;\\n        \\n        sort(nums.begin(), nums.end());\\n        if(n == 1)return 0;\\n        \\n        \\n        int first = 0, last = (n + 1) / 2; // we only need to start taking second element of pairs after half of \\n                                           // the array, as maximum number of good pairs will be n / 2\\n        \\n        while(last < n)\\n        {\\n            if(2 * nums[first] <= nums[last])\\n            {\\n                result++; // counting number of good pairs\\n                first++;\\n            }\\n            \\n            last++;\\n        }\\n        \\n        return result * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230849,
                "title": "easy-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int end = n-1;\\n        int start = 0;\\n        \\n        int mid = start+(end-start)/2;\\n        int i = 0, j = mid+1;\\n        int cnt = 0;\\n        sort(nums.begin(), nums.end());\\n        \\n        \\n        while(i <= mid && j < n){\\n            if((i != j) && (2*nums[i] <= nums[j])){\\n                cnt++;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        int ans = cnt*2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int end = n-1;\\n        int start = 0;\\n        \\n        int mid = start+(end-start)/2;\\n        int i = 0, j = mid+1;\\n        int cnt = 0;\\n        sort(nums.begin(), nums.end());\\n        \\n        \\n        while(i <= mid && j < n){\\n            if((i != j) && (2*nums[i] <= nums[j])){\\n                cnt++;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        int ans = cnt*2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230843,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int mid=(nums.length+1)>>1;\\n        int low=0;\\n        int cnt=0;\\n        while(mid<nums.length){\\n            if(nums[mid]>=((nums[low])<<1)){\\n                low++;\\n                cnt+=2;\\n            }\\n            mid++;\\n        }\\n        return cnt;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/af01dab1-431d-4e1d-9173-0adfb3c8cfed_1677384132.5504675.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int mid=(nums.length+1)>>1;\\n        int low=0;\\n        int cnt=0;\\n        while(mid<nums.length){\\n            if(nums[mid]>=((nums[low])<<1)){\\n                low++;\\n                cnt+=2;\\n            }\\n            mid++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230804,
                "title": "c-two-pointer-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0;\\n        int mid = (nums.size())/2;\\n        int j = mid;\\n        int count = 0;\\n        while(i<mid and j<nums.size())\\n        {\\n            if((2*nums[i])<=nums[j])\\n            {\\n                i++;\\n                j++;\\n                count+=2;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0;\\n        int mid = (nums.size())/2;\\n        int j = mid;\\n        int count = 0;\\n        while(i<mid and j<nums.size())\\n        {\\n            if((2*nums[i])<=nums[j])\\n            {\\n                i++;\\n                j++;\\n                count+=2;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230776,
                "title": "easiest-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        int st=0;\\n        int mid=(n+1)/2;\\n        while(mid<n){\\n            if(nums[st]*2<=nums[mid]) st++;\\n            mid++;\\n        }\\n        return st*2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        int st=0;\\n        int mid=(n+1)/2;\\n        while(mid<n){\\n            if(nums[st]*2<=nums[mid]) st++;\\n            mid++;\\n        }\\n        return st*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072720,
                "title": "simplest-java-solution-100-efficient-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n\\n        // int count = 0 ;\\n\\n        // for ( int i = 0 ; i < nums.length ; i ++){\\n            \\n        // for ( int j=i ; j < nums.length ; j ++){\\n\\n        //     if(2 * nums[i] <= nums[j]){\\n        //         count += 2 ;\\n        //     }\\n            \\n        // }\\n        // }\\n        \\n        // return count ;\\n\\n\\n       int n = nums.length ;\\n\\n       Arrays.sort(nums);\\n       int ans = 0 ;\\n       int strt = 0 ; \\n       int mid = (n+1)/2;\\n\\n       while(mid<n){\\n           if(2 * nums[strt] <= nums[mid]){\\n               strt++;\\n               ans += 2;\\n           }\\n\\n           mid++;\\n       }\\n\\n\\n     return ans;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n\\n        // int count = 0 ;\\n\\n        // for ( int i = 0 ; i < nums.length ; i ++){\\n            \\n        // for ( int j=i ; j < nums.length ; j ++){\\n\\n        //     if(2 * nums[i] <= nums[j]){\\n        //         count += 2 ;\\n        //     }\\n            \\n        // }\\n        // }\\n        \\n        // return count ;\\n\\n\\n       int n = nums.length ;\\n\\n       Arrays.sort(nums);\\n       int ans = 0 ;\\n       int strt = 0 ; \\n       int mid = (n+1)/2;\\n\\n       while(mid<n){\\n           if(2 * nums[strt] <= nums[mid]){\\n               strt++;\\n               ans += 2;\\n           }\\n\\n           mid++;\\n       }\\n\\n\\n     return ans;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060325,
                "title": "java-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int n = nums.length; \\n        Arrays.sort(nums);\\n\\n        int i = (n/2)-1;\\n        int j = n-1;\\n        int count = 0;\\n\\n        while(i >= 0) {\\n\\n           if(nums[i]*2 <= nums[j]) {\\n               count += 2;\\n               j--;\\n               i--;\\n\\n           } else if(nums[i]*2 > nums[j]){\\n               i--;\\n           } else {\\n               i--;\\n               j--;\\n           }\\n\\n        }\\n\\n\\n       return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int n = nums.length; \\n        Arrays.sort(nums);\\n\\n        int i = (n/2)-1;\\n        int j = n-1;\\n        int count = 0;\\n\\n        while(i >= 0) {\\n\\n           if(nums[i]*2 <= nums[j]) {\\n               count += 2;\\n               j--;\\n               i--;\\n\\n           } else if(nums[i]*2 > nums[j]){\\n               i--;\\n           } else {\\n               i--;\\n               j--;\\n           }\\n\\n        }\\n\\n\\n       return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997351,
                "title": "easy-two-pointer-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst sort the array and then use Two pointer method \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        if(nums.size()%2==0)\\n        {\\n            i=(nums.size()/2)-1;\\n        }\\n        else{\\n            i=nums.size()/2;\\n        }\\n        int t=i;\\n        int j=nums.size()-1;\\n        int cnt=0;\\n        while(i>=0 && j>t)\\n        {\\n            if(2*nums[i]<=nums[j])\\n            {\\n                i--;\\n                j--;\\n                cnt=cnt+2;\\n            }\\n            else if(2*nums[i]>nums[j]){\\n                i--;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        if(nums.size()%2==0)\\n        {\\n            i=(nums.size()/2)-1;\\n        }\\n        else{\\n            i=nums.size()/2;\\n        }\\n        int t=i;\\n        int j=nums.size()-1;\\n        int cnt=0;\\n        while(i>=0 && j>t)\\n        {\\n            if(2*nums[i]<=nums[j])\\n            {\\n                i--;\\n                j--;\\n                cnt=cnt+2;\\n            }\\n            else if(2*nums[i]>nums[j]){\\n                i--;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987006,
                "title": "java-simple-solution-using-two-pointers",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int len = nums.length;\\n        Arrays.sort(nums);\\n        int i = 0, j = len - len / 2;\\n\\n        while(j < len){\\n            if(2 * nums[i] <= nums[j]){\\n                i++;\\n            }\\n            j++;\\n        }\\n        return 2 * i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int len = nums.length;\\n        Arrays.sort(nums);\\n        int i = 0, j = len - len / 2;\\n\\n        while(j < len){\\n            if(2 * nums[i] <= nums[j]){\\n                i++;\\n            }\\n            j++;\\n        }\\n        return 2 * i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969139,
                "title": "java-strategic-pointer-manipulation-beats-97",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int count = 0;\\n        int i = 0, j = nums.length/2;\\n        while(i < nums.length/2 && j < nums.length){\\n            if(2*nums[i] <= nums[j]){\\n                count+=2;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n# Please upvote if you liked the solution \\u263A\\uFE0F",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int count = 0;\\n        int i = 0, j = nums.length/2;\\n        while(i < nums.length/2 && j < nums.length){\\n            if(2*nums[i] <= nums[j]){\\n                count+=2;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968018,
                "title": "simple-java-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int c =0, j = nums.length-1;\\n        for(int i=nums.length/2 -1; i>=0;i--){\\n            if(nums[i] <= nums[j]/2 ) {\\n                c += 2;\\n                j--;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int c =0, j = nums.length-1;\\n        for(int i=nums.length/2 -1; i>=0;i--){\\n            if(nums[i] <= nums[j]/2 ) {\\n                c += 2;\\n                j--;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944119,
                "title": "simple-4-steps-javascript-beginner-approach-using-greedy-fully-explained",
                "content": "# Approach\\nStep 1: Sort the Array in ascending order(Non decreasing order)\\n\\nStep 2: Find the index of the mid of the array and add +1 so we are going to traverse from the second half of the array....\\n\\nStep3: if the first element of the first half of the array is less than the second element of the first half of the array then increment the count...\\n\\nStep 4: After traversing, Multiply count with 2 to mark the second half of the array and return the count.\\n\\n# UPVOTE IS APPRECIATED!!\\n# Complexity\\n- Time complexity: O(logn)\\n- Space complexity:O(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxNumOfMarkedIndices = function(nums) {\\n    var count=0;\\n    nums.sort((a,b)=>a-b);\\n    var len=nums.length;\\n    var mid=Math.floor((nums.length+1)/2);\\n    while(mid<len){\\n        if((nums[count]*2)<=nums[mid]){\\n            count++;\\n        }\\n        mid++;\\n    }\\n    return count*2;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxNumOfMarkedIndices = function(nums) {\\n    var count=0;\\n    nums.sort((a,b)=>a-b);\\n    var len=nums.length;\\n    var mid=Math.floor((nums.length+1)/2);\\n    while(mid<len){\\n        if((nums[count]*2)<=nums[mid]){\\n            count++;\\n        }\\n        mid++;\\n    }\\n    return count*2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3931170,
                "title": "solution-using-sorting-and-two-pointers-rust-tm",
                "content": "# Code\\n```\\n// use std::collections::HashSet;\\nimpl Solution {\\n    pub fn max_num_of_marked_indices(nums: Vec<i32>) -> i32 {\\n        // Pick two different unmarked indices i and j such that 2 * nums[i] <= nums[j], then mark i and j\\n        let mut temp_nums: Vec<i32> = nums.to_vec();\\n        let mut count: i32 = 0; \\n        temp_nums.sort_by(|a,b| a.cmp(b));\\n        let mut l: usize = 0;\\n        let mut r: usize = temp_nums.len()/2;\\n        // let mut idx_set: HashSet<usize> = HashSet::new();\\n        // println!(\"l:{},r:{}\\\\n{:?}\", l, r, temp_nums);\\n        while l < (temp_nums.len()/2) && r < temp_nums.len() {\\n            // if idx_set.contains(&l) {\\n            //     break;\\n            // }\\n            // println!(\"{:?}\", idx_set);\\n            let first_val: i32 = temp_nums[l] * 2;\\n            let second_val: i32 = temp_nums[r];\\n            // println!(\"l:{},r:{},1:{},2:{}\", l, r, first_val, second_val);\\n            if first_val <= second_val {\\n                count += 2;\\n                // idx_set.insert(r);\\n                l += 1;\\n                r += 1;\\n                continue;\\n            }\\n            r += 1;\\n        }\\n        // println!(\"{:?}\", idx_set);\\n\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n// use std::collections::HashSet;\\nimpl Solution {\\n    pub fn max_num_of_marked_indices(nums: Vec<i32>) -> i32 {\\n        // Pick two different unmarked indices i and j such that 2 * nums[i] <= nums[j], then mark i and j\\n        let mut temp_nums: Vec<i32> = nums.to_vec();\\n        let mut count: i32 = 0; \\n        temp_nums.sort_by(|a,b| a.cmp(b));\\n        let mut l: usize = 0;\\n        let mut r: usize = temp_nums.len()/2;\\n        // let mut idx_set: HashSet<usize> = HashSet::new();\\n        // println!(\"l:{},r:{}\\\\n{:?}\", l, r, temp_nums);\\n        while l < (temp_nums.len()/2) && r < temp_nums.len() {\\n            // if idx_set.contains(&l) {\\n            //     break;\\n            // }\\n            // println!(\"{:?}\", idx_set);\\n            let first_val: i32 = temp_nums[l] * 2;\\n            let second_val: i32 = temp_nums[r];\\n            // println!(\"l:{},r:{},1:{},2:{}\", l, r, first_val, second_val);\\n            if first_val <= second_val {\\n                count += 2;\\n                // idx_set.insert(r);\\n                l += 1;\\n                r += 1;\\n                continue;\\n            }\\n            r += 1;\\n        }\\n        // println!(\"{:?}\", idx_set);\\n\\n        count\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3876028,
                "title": "the-optimal-solution-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int i=0, j= (n+1)/2;\\n        int ans = 0;\\n        while (j < n) {\\n            if (2*nums[i] <= nums[j]) {\\n                i++;\\n                ans += 2;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int i=0, j= (n+1)/2;\\n        int ans = 0;\\n        while (j < n) {\\n            if (2*nums[i] <= nums[j]) {\\n                i++;\\n                ans += 2;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821460,
                "title": "c-sort",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN) -> N= number of elements in nums\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int left=0,sz = nums.size(),right=(sz+1)/2,ans=0;\\n        while (left < sz/2 && right<sz){\\n            if (2*nums[left] <= nums[right]) {\\n                left++;\\n                right++;\\n                ans+=2;\\n            }\\n            else right++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int left=0,sz = nums.size(),right=(sz+1)/2,ans=0;\\n        while (left < sz/2 && right<sz){\\n            if (2*nums[left] <= nums[right]) {\\n                left++;\\n                right++;\\n                ans+=2;\\n            }\\n            else right++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782143,
                "title": "simple-c-solution-2-pointer",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int left=0,right;\\n        int n=nums.size()/2;\\n        right=n;\\n        int count=0;\\n        while(right<nums.size() and left<n){\\n            if(2*nums[left]>nums[right])right++;\\n            else{\\n                left++;\\n                right++;\\n                count+=2;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int left=0,right;\\n        int n=nums.size()/2;\\n        right=n;\\n        int count=0;\\n        while(right<nums.size() and left<n){\\n            if(2*nums[left]>nums[right])right++;\\n            else{\\n                left++;\\n                right++;\\n                count+=2;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758702,
                "title": "easy-to-get-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int counter = 0;\\n        int i =0, j =nums.length/2;\\n\\n        while(i < nums.length/2  &&  j < nums.length){\\n            if(nums[i] * 2 <= nums[j]){\\n                counter += 2;\\n                i++;j++;\\n                continue;\\n            }\\n           j++;\\n        } \\n\\n        return counter;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int counter = 0;\\n        int i =0, j =nums.length/2;\\n\\n        while(i < nums.length/2  &&  j < nums.length){\\n            if(nums[i] * 2 <= nums[j]){\\n                counter += 2;\\n                i++;j++;\\n                continue;\\n            }\\n           j++;\\n        } \\n\\n        return counter;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723402,
                "title": "sorting-two-pointer-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        int count=0;\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=(n+1)/2;\\n        while(j<n)\\n        {\\n            if(2*nums[i]<=nums[j])\\n            {\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else j++;\\n        }\\n        return 2*count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        int count=0;\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=(n+1)/2;\\n        while(j<n)\\n        {\\n            if(2*nums[i]<=nums[j])\\n            {\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else j++;\\n        }\\n        return 2*count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718377,
                "title": "two-pointer-with-sorting-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxNumOfMarkedIndices = function(nums) {\\n    nums.sort((a,b) => a-b);\\n    let l = 0, r = nums.length - 1;\\n    let mid = Math.floor((l + r)/2);\\n    let ans = 0;\\n    const curMid = mid;\\n    while (mid >= 0 && curMid < r) {\\n        if (nums[mid] * 2 <= nums[r]) {\\n            ans+=2;\\n            r--;\\n        }\\n        mid--;\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxNumOfMarkedIndices = function(nums) {\\n    nums.sort((a,b) => a-b);\\n    let l = 0, r = nums.length - 1;\\n    let mid = Math.floor((l + r)/2);\\n    let ans = 0;\\n    const curMid = mid;\\n    while (mid >= 0 && curMid < r) {\\n        if (nums[mid] * 2 <= nums[r]) {\\n            ans+=2;\\n            r--;\\n        }\\n        mid--;\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3639231,
                "title": "simple-python-with-sorting",
                "content": "\\n\\n# Code\\n```\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        m = n // 2\\n        i = 0\\n        j = m\\n        c = 0\\n        while i < m and j < n:\\n            if 2 * nums[i] <= nums[j]:\\n                c += 2\\n                i += 1\\n                j += 1\\n            else:\\n                j += 1\\n\\n        return c\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        m = n // 2\\n        i = 0\\n        j = m\\n        c = 0\\n        while i < m and j < n:\\n            if 2 * nums[i] <= nums[j]:\\n                c += 2\\n                i += 1\\n                j += 1\\n            else:\\n                j += 1\\n\\n        return c\\n\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3572776,
                "title": "c-simple-solution-must-check-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nnlog(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n\\n        int i = 0; int j = n/2;\\n        int jj = j;\\n        int cnt = 0;\\n        while(i<jj && j<n)\\n        {\\n            if(2 * nums[i] <= nums[j])\\n            {\\n                cnt += 2;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n\\n        int i = 0; int j = n/2;\\n        int jj = j;\\n        int cnt = 0;\\n        while(i<jj && j<n)\\n        {\\n            if(2 * nums[i] <= nums[j])\\n            {\\n                cnt += 2;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526851,
                "title": "c-python-greedy-solution-with-explanation",
                "content": "we can use the first k smallest numbers to match the first k largest numbers, and count how many pairs are matched.\\n\\ntc is O(nlogn), sc is O(1)\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int i = 0;\\n        for (int j = (nums.size() + 1) / 2; j < nums.size(); j+=1) {\\n            if (2 * nums[i] <= nums[j]) i += 1;\\n        }\\n        return 2 * i;\\n    }\\n};\\n```\\n\\n### python\\n```python\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        i = 0\\n        for j in range((len(nums) + 1)// 2, len(nums)):\\n            if nums[i] * 2 <= nums[j]: i+=1\\n        return 2 * i\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int i = 0;\\n        for (int j = (nums.size() + 1) / 2; j < nums.size(); j+=1) {\\n            if (2 * nums[i] <= nums[j]) i += 1;\\n        }\\n        return 2 * i;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        i = 0\\n        for j in range((len(nums) + 1)// 2, len(nums)):\\n            if nums[i] * 2 <= nums[j]: i+=1\\n        return 2 * i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492253,
                "title": "two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- sort the array\\n- if nums[i]*2<=nums[j] then nums[i]*2<=nums[k] when k<=j\\n- therefore we just need to count the valid number of i\\n- break when either i==nums.size()/2 or j==nums.size()/2\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int cnt=0;\\n        for(int i=0,j=1; i<nums.size()/2;i++){\\n            while(j<nums.size() and nums[j]<nums[i]*2) j++;\\n            if(j<nums.size()){\\n                cnt+=2;\\n                j++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int cnt=0;\\n        for(int i=0,j=1; i<nums.size()/2;i++){\\n            while(j<nums.size() and nums[j]<nums[i]*2) j++;\\n            if(j<nums.size()){\\n                cnt+=2;\\n                j++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477856,
                "title": "c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUSING SORTING ALGORITHM \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n..\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int i=0;\\n        int j=(nums.size()+1)/2;\\n        int mx=0;\\n        sort(nums.begin(),nums.end());\\n       while(j<nums.size()){\\n            if(2*nums[i]<=nums[j]){\\n               mx++;\\n               i++;\\n              \\n            \\n            }\\n            j++;\\n        }\\n        return mx*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int i=0;\\n        int j=(nums.size()+1)/2;\\n        int mx=0;\\n        sort(nums.begin(),nums.end());\\n       while(j<nums.size()){\\n            if(2*nums[i]<=nums[j]){\\n               mx++;\\n               i++;\\n              \\n            \\n            }\\n            j++;\\n        }\\n        return mx*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473205,
                "title": "divide-the-arr-in-half-part-and-calculate-easy-and-simple-way-in-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int len = nums.size();\\n        int mid =(len+1)/2;\\n        int res=0;\\n        int i=0, j=mid; \\n        while(j<len){\\n            if(nums[j] >= 2*nums[i]) {\\n                res++;\\n                i++;\\n            }\\n            \\n            j++;\\n        }\\n\\n        return 2*res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int len = nums.size();\\n        int mid =(len+1)/2;\\n        int res=0;\\n        int i=0, j=mid; \\n        while(j<len){\\n            if(nums[j] >= 2*nums[i]) {\\n                res++;\\n                i++;\\n            }\\n            \\n            j++;\\n        }\\n\\n        return 2*res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404775,
                "title": "java-easy-approach-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nDivide array into half and take smallest of both array and check for condition. if condition satisfies increment both index else increment only greater value index \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int mid=(nums.length+1)/2;\\n        int l=0;\\n        int count=0;\\n        int r=mid;\\n        while(r<=nums.length-1){\\n            if((nums[l]*2)<=nums[r]){\\n                count=count+2;\\n                l=l+1;\\n                r=r+1;\\n            }\\n            else{\\n\\n                r=r+1;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int mid=(nums.length+1)/2;\\n        int l=0;\\n        int count=0;\\n        int r=mid;\\n        while(r<=nums.length-1){\\n            if((nums[l]*2)<=nums[r]){\\n                count=count+2;\\n                l=l+1;\\n                r=r+1;\\n            }\\n            else{\\n\\n                r=r+1;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402127,
                "title": "sort-and-greedily-simply-matching-python",
                "content": "```\\n\"\"\"\\nTreatment: queue ADT\\n\\nIdea: we try to pair smaller numbers in the list with large ones (larger means 2 * small <= large)\\nObs: if the n = len(nums), then there are at most n // 2 matching pairs.\\n\\nWith the above Idea and Obs, we can use the following steps:\\n\\nAlgorithm/Steps:\\n\\nstep-0 sort the list nums from small to large and retrieve its length n\\nstep-1 use the first n//2 elements to check matching larger elements\\n       Let q1 = nums[:n//2]; q2 = nums[n//2:]\\n       for each element y in q1 (note these elements are from small to larger),\\n       we pop from q2 the elements that are not large enough, i.e., < 2 * y.\\n       If q2 is empty, it means no match, we just return the counting of pairs\\n       Else: q2[0] >= 2 * y, so we pop it to match y, increment the counting by 2 (= 1 pair)\\nstep-2 return the counting\\n       \\nEx-2. nums = [9,2,5,4] => sort => nums=[2, 4, 5, 9] => q1=[2, 4]; q2=[5, 9].\\n=> use 4 to match 2, and 9 to match 4, so the final result is 4.\\n\\nNote: we donot use 9 to match 2 though it can, b/c 5 can not match 4. This note\\njustified the soundness of the above algorithm.\\n\\nFollow up at Youtube channel \"Code-Yao\".\\n\"\"\"\\n\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        q1, q2 = collections.deque(nums[:n//2]), collections.deque(nums[n//2:])\\n        res = 0\\n        for y in q1:\\n            while q2 and q2[0] < 2 * y:\\n                q2.popleft()\\n            if not q2:\\n                break\\n            else:\\n                q2.popleft()\\n                res += 2\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\nTreatment: queue ADT\\n\\nIdea: we try to pair smaller numbers in the list with large ones (larger means 2 * small <= large)\\nObs: if the n = len(nums), then there are at most n // 2 matching pairs.\\n\\nWith the above Idea and Obs, we can use the following steps:\\n\\nAlgorithm/Steps:\\n\\nstep-0 sort the list nums from small to large and retrieve its length n\\nstep-1 use the first n//2 elements to check matching larger elements\\n       Let q1 = nums[:n//2]; q2 = nums[n//2:]\\n       for each element y in q1 (note these elements are from small to larger),\\n       we pop from q2 the elements that are not large enough, i.e., < 2 * y.\\n       If q2 is empty, it means no match, we just return the counting of pairs\\n       Else: q2[0] >= 2 * y, so we pop it to match y, increment the counting by 2 (= 1 pair)\\nstep-2 return the counting\\n       \\nEx-2. nums = [9,2,5,4] => sort => nums=[2, 4, 5, 9] => q1=[2, 4]; q2=[5, 9].\\n=> use 4 to match 2, and 9 to match 4, so the final result is 4.\\n\\nNote: we donot use 9 to match 2 though it can, b/c 5 can not match 4. This note\\njustified the soundness of the above algorithm.\\n\\nFollow up at Youtube channel \"Code-Yao\".\\n\"\"\"\\n\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        q1, q2 = collections.deque(nums[:n//2]), collections.deque(nums[n//2:])\\n        res = 0\\n        for y in q1:\\n            while q2 and q2[0] < 2 * y:\\n                q2.popleft()\\n            if not q2:\\n                break\\n            else:\\n                q2.popleft()\\n                res += 2\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389623,
                "title": "even-a-kid-can-understand-c",
                "content": "# Intuition\\nso max pair can be made is n/2  if array size is n .\\nwe have to maximize the indices \\nwe will sort the array \\nlets start matching n/2 smallest element to n/2 largest element\\noptimally we should find the smallest element from second half \\n**ex :- 2 4 5 9 \\nfor two 5 and 9  both are suitable \\nif we pick 9 then for 4 we will be left with no option\\nso we choose min from second half\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) \\n    {\\n        int count = 0; \\n        sort(nums.begin(),nums.end());\\n        int n  = nums.size();\\n\\n        int i = 0 , j = n - n/2;\\n\\n        while(i<n/2+1 && j<n)\\n        {\\n          if(nums[i]*2<=nums[j])\\n          {\\n              i++;\\n              j++;\\n              count +=2;\\n          }\\n          else j++;\\n        } \\n\\n        return count ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) \\n    {\\n        int count = 0; \\n        sort(nums.begin(),nums.end());\\n        int n  = nums.size();\\n\\n        int i = 0 , j = n - n/2;\\n\\n        while(i<n/2+1 && j<n)\\n        {\\n          if(nums[i]*2<=nums[j])\\n          {\\n              i++;\\n              j++;\\n              count +=2;\\n          }\\n          else j++;\\n        } \\n\\n        return count ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349239,
                "title": "c-solution-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSorting the Array\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmax pair can be formed is n \\nand pair can be formed by n/2 * 2 which means\\nseparte sorted array in two equal parts \\nand check condition accordingly \\nsee the code for more ....\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int ans = 0;\\n        sort(nums.begin(),nums.end());\\n        int mid = nums.size()/2;\\n        for(int i = 0; i<nums.size()/2 ; i++){\\n            while(mid < nums.size()){\\n                if(nums[i]*2 <= nums[mid]){\\n                    ans++;\\n                    mid++;\\n                    break;\\n                }\\n                else\\n                    mid++;\\n            }\\n        }\\n        return ans*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int ans = 0;\\n        sort(nums.begin(),nums.end());\\n        int mid = nums.size()/2;\\n        for(int i = 0; i<nums.size()/2 ; i++){\\n            while(mid < nums.size()){\\n                if(nums[i]*2 <= nums[mid]){\\n                    ans++;\\n                    mid++;\\n                    break;\\n                }\\n                else\\n                    mid++;\\n            }\\n        }\\n        return ans*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335759,
                "title": "tricky-approach-and-harder-than-it-looks",
                "content": "I got the idea from another pro coder but it is really good. \\nYou just need the count and thats why you can sort the array and you\\'ll get the condition true (2*nums[i] <=nums[j)* if and only if the nums[i] is smaller so we divide array into two parts *smaller and larger* and we compare first index of smaller to first index of larger as we need top maximize the count.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n      int n = nums.size();\\n      int i=0;\\n      sort(nums.begin(),nums.end());\\n\\n\\n      for(int j=n-n/2 ; j<n ; j++){\\n          i+=(2*nums[i]<=nums[j]);\\n      }\\n      return i*2;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n      int n = nums.size();\\n      int i=0;\\n      sort(nums.begin(),nums.end());\\n\\n\\n      for(int j=n-n/2 ; j<n ; j++){\\n          i+=(2*nums[i]<=nums[j]);\\n      }\\n      return i*2;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287345,
                "title": "short-simple-easy-c-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA greedy approach is well suited here. In best case, we want to pair up every i and j. The ideal situation would be - in a sorted array item at index 0 paired up with item at nums.size()/2; 1 -> nums.size()/2 +1 and so on.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTaking a two pointer approach works well here with i ranging from [0,nums.size()/2) and j belonging to [nums.size()/2, nums.size())\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn) as we sort the array\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=0, j = nums.size()/2;i<nums.size()/2;i++){\\n            while(j<nums.size() && nums[j]<2*nums[i])j++;\\n            if(j>=nums.size())break;\\n            else {\\n                j++;\\n                ans+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=0, j = nums.size()/2;i<nums.size()/2;i++){\\n            while(j<nums.size() && nums[j]<2*nums[i])j++;\\n            if(j>=nums.size())break;\\n            else {\\n                j++;\\n                ans+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285095,
                "title": "two-pointers-thoughts-and-prove",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTBH, I didn\\'t get to this until a few hours of try-and-WA and I feel like this is very delicate so I would like to organize my thoughs and share them.\\n\\nThe idea is you can also find the optimal pairs by spliting the sorted `nums` into two halves. One number from the lower half and the other from the upper half.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the input `nums` in ascending order.\\n2. Split the sorted input into two halves from the middle.\\n    - `i = 0 ` is the head of lower half, `j=(n+1)/2` is the head of upper half. \\n    - you may wonder about what if the number of input is odd, where to put the middle one: the lower or the upper. The answer is the upper one. For example, you have 13 numbers from the input. If you can paired the lower 6 numbers with the upper 6, then it is optimal. Therefore no need to put an extra number to the lower half. \\n3. Start matching the lower half and the upper half.\\n    - if `nums[j]` does not meet `nums[j] >= 2*nums[i]`,`i` stays and `j` moves to the next one.\\n    - if it does, then `i` and `j` moves to the next\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int i=0, j= (n+1)/2;\\n        int ans = 0;\\n        while (j < n) {\\n            if (2*nums[i] <= nums[j]) {\\n                i++;\\n                ans += 2;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int i=0, j= (n+1)/2;\\n        int ans = 0;\\n        while (j < n) {\\n            if (2*nums[i] <= nums[j]) {\\n                i++;\\n                ans += 2;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284335,
                "title": "2576-find-the-maximum-number-of-marked-indices-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMaximum answer can be the total size of the array. To happen that, half of the number should be higher or equal to the other half of the arry.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf we sort the arry in non-decreasing order, then we can easily check if the second half of the array is greater or equal to the first half of the array. If not so, then we should check which maximum position we we get so that the other corresponding element is greater or equal to that element.\\n1. Sort the array in non-decreasing order.\\n2. Define a vector v and push the value in it which is twice as the first half of the sorted array.\\n3. Then simply check how many element of the sorted array of the second half is greater or equal to the previously defined vector v.\\n4. Each time the condition is satisfied our ans(answer)(initially defind 0(zero)) is incremented by 2.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIt will be O(nlong(n)). To sort the array it will take O(nlog(n)). Then a loop of the size of the given vector. So the overall time complexity will be O(nlogn).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIt will O(n). Because we have used a vector of the half of the size of the given vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        if(nums.size()==1){\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end());\\n        vector<int> v;\\n        int i;\\n        for(i=0;i<(nums.size()/2);i++){\\n            v.push_back(2*nums[i]);\\n        }\\n        int ans=0;\\n        int k=0;\\n        for(i=(nums.size()/2);i<nums.size();i++){\\n            //cout<<\"nums[i]: \"<<nums[i]<<\" \"<<\"v[k]: \"<<v[k]<<endl;\\n            if(nums[i]>=v[k]){\\n                ans+=2;\\n                k++;\\n            }\\n            if(k==v.size()){\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        if(nums.size()==1){\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end());\\n        vector<int> v;\\n        int i;\\n        for(i=0;i<(nums.size()/2);i++){\\n            v.push_back(2*nums[i]);\\n        }\\n        int ans=0;\\n        int k=0;\\n        for(i=(nums.size()/2);i<nums.size();i++){\\n            //cout<<\"nums[i]: \"<<nums[i]<<\" \"<<\"v[k]: \"<<v[k]<<endl;\\n            if(nums[i]>=v[k]){\\n                ans+=2;\\n                k++;\\n            }\\n            if(k==v.size()){\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3278460,
                "title": "short-easiest-2-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& v) {\\n    int p=0; sort(v.begin(),v.end());\\n    for(int i=v.size()-v.size()/2;i<v.size();i++)p+=2*v[p]<=v[i];return p*2;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& v) {\\n    int p=0; sort(v.begin(),v.end());\\n    for(int i=v.size()-v.size()/2;i<v.size();i++)p+=2*v[p]<=v[i];return p*2;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274271,
                "title": "c-binary-search",
                "content": "\\n```\\nclass Solution \\n{\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) \\n    {\\n        sort(nums.begin(), nums.end());\\n\\n        int n = nums.size();\\n        int lo = 0, hi = n / 2;\\n\\n        while (lo < hi)\\n        {\\n            int md = (lo + hi + 1) / 2; // make `md` stick with hi to avoid infinite loop\\n\\n            int i = 0;\\n            for (; i < md; ++i)\\n            {\\n                if (nums[i] * 2 > nums[n - md + i])\\n                {\\n                    break;\\n                }\\n            }\\n\\n            if (i < md)\\n            {\\n                hi = md - 1;\\n            }\\n            else\\n            {\\n                lo = md;\\n            }\\n        }\\n\\n        return lo * 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) \\n    {\\n        sort(nums.begin(), nums.end());\\n\\n        int n = nums.size();\\n        int lo = 0, hi = n / 2;\\n\\n        while (lo < hi)\\n        {\\n            int md = (lo + hi + 1) / 2; // make `md` stick with hi to avoid infinite loop\\n\\n            int i = 0;\\n            for (; i < md; ++i)\\n            {\\n                if (nums[i] * 2 > nums[n - md + i])\\n                {\\n                    break;\\n                }\\n            }\\n\\n            if (i < md)\\n            {\\n                hi = md - 1;\\n            }\\n            else\\n            {\\n                lo = md;\\n            }\\n        }\\n\\n        return lo * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270720,
                "title": "binary-search-two-pointer-approach-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem first I sort the array and then find the minimum index for which i can get the minimum index for which i can get my answer.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy code just a simple predicate function which return true if for the mid i can have enough values.\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool predi(vector<int>&num,int mid){\\n        int n = num.size();\\n        int i = 0;\\n        int j = mid+1;\\n        while(i<=mid && j<n){\\n            if(2*num[i]<=num[j]){\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        if(i==mid+1){\\n            return true;\\n        }\\n        else return false;\\n    }\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int index = -1;\\n        int i=0;\\n        int j = nums.size()-1;\\n        while(j>=i){\\n            int mid = (i+j)/2;\\n            if(predi(nums,mid)){\\n                index = mid;\\n                i = mid+1;\\n            }\\n            else{\\n                j = mid-1;\\n            }\\n            \\n        }\\n        cout<<index<<endl;\\n        if(index==-1)return 0;\\n        return 2*(index+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool predi(vector<int>&num,int mid){\\n        int n = num.size();\\n        int i = 0;\\n        int j = mid+1;\\n        while(i<=mid && j<n){\\n            if(2*num[i]<=num[j]){\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        if(i==mid+1){\\n            return true;\\n        }\\n        else return false;\\n    }\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int index = -1;\\n        int i=0;\\n        int j = nums.size()-1;\\n        while(j>=i){\\n            int mid = (i+j)/2;\\n            if(predi(nums,mid)){\\n                index = mid;\\n                i = mid+1;\\n            }\\n            else{\\n                j = mid-1;\\n            }\\n            \\n        }\\n        cout<<index<<endl;\\n        if(index==-1)return 0;\\n        return 2*(index+1);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3265714,
                "title": "1-liner",
                "content": "```ruby\\ndef max_num_of_marked_indices(a) =\\n    ((z = a.sort!.size) - z / 2...z).reduce(0) do\\n        _1 + (a[_1] * 2 <= a[_2] ? 1 : 0)\\n    end * 2\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef max_num_of_marked_indices(a) =\\n    ((z = a.sort!.size) - z / 2...z).reduce(0) do\\n        _1 + (a[_1] * 2 <= a[_2] ? 1 : 0)\\n    end * 2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3254611,
                "title": "c-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter we sort the input, we can greedly check if an answer is possible in linear time, so we can use binary search in the solution space for this quesstion. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe sort the array so we can check if the potencial answer \"max\" is possible in linear time. We check greedyly, smallest number that\\'s in lower group match with smallest number that\\'s in upper group.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSorting cost O(nLog(n))\\nBinary Search cost O(Log(n))\\nThe final algorithem cost O(nLog(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\nIn my code, I clone the input to a new array then sorted it, but you can just sort the input array.\\n# Code\\n```\\npublic class Solution {\\n\\n    int[] ascendArray;\\n    int n;\\n\\n    public int MaxNumOfMarkedIndices(int[] nums) {\\n        \\n        n = nums.Length;\\n        ascendArray = (int[])nums.Clone();\\n\\n        Array.Sort(ascendArray);\\n\\n\\n        int left = 0;\\n        int right = n/2;\\n\\n        while(left <= right)\\n        {\\n            int mid = left + (right - left) / 2;\\n            if(Check(mid))\\n            {\\n                left = mid + 1;\\n            }\\n            else\\n            {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return right * 2;\\n\\n    }\\n\\n    bool Check(int max)\\n    {\\n        if(max > n) {\\n            return false;\\n        }\\n\\n        for(int i = 0; i < max; i++)\\n        {\\n            int small = ascendArray[i];\\n            int large = ascendArray[n - (max - i)];\\n            if(small * 2 > large)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\n    int[] ascendArray;\\n    int n;\\n\\n    public int MaxNumOfMarkedIndices(int[] nums) {\\n        \\n        n = nums.Length;\\n        ascendArray = (int[])nums.Clone();\\n\\n        Array.Sort(ascendArray);\\n\\n\\n        int left = 0;\\n        int right = n/2;\\n\\n        while(left <= right)\\n        {\\n            int mid = left + (right - left) / 2;\\n            if(Check(mid))\\n            {\\n                left = mid + 1;\\n            }\\n            else\\n            {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return right * 2;\\n\\n    }\\n\\n    bool Check(int max)\\n    {\\n        if(max > n) {\\n            return false;\\n        }\\n\\n        for(int i = 0; i < max; i++)\\n        {\\n            int small = ascendArray[i];\\n            int large = ascendArray[n - (max - i)];\\n            if(small * 2 > large)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252926,
                "title": "python-two-pointers",
                "content": "```\\ndef maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        lth,div,re = len(nums),len(nums)//2,0\\n        left = nums[:div]\\n        right = nums[div:]\\n        j=len(left)-1\\n        for i in range(len(right)-1, -1, -1):\\n            while j >= 0:\\n                if right[i] >= left[j]*2:\\n                    re+=2\\n                    j-=1\\n                    break\\n                else:\\n                    j-=1\\n        return re\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\ndef maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        lth,div,re = len(nums),len(nums)//2,0\\n        left = nums[:div]\\n        right = nums[div:]\\n        j=len(left)-1\\n        for i in range(len(right)-1, -1, -1):\\n            while j >= 0:\\n                if right[i] >= left[j]*2:\\n                    re+=2\\n                    j-=1\\n                    break\\n                else:\\n                    j-=1\\n        return re\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3252026,
                "title": "pair",
                "content": "# * 1. class Solution(object):``\\n    def maxNumOfMarkedIndices(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        i=0\\n        count=0\\n        nums.sort()\\n        n=len(nums)\\n        for j in range((n+1)//2,len(nums)):\\n            if 2 * nums[i] <= nums[j]:\\n                i+=1\\n                count+=2\\n        return count\\n",
                "solutionTags": [
                    "Array",
                    "Two Pointers"
                ],
                "code": "# * 1. class Solution(object):``\\n    def maxNumOfMarkedIndices(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        i=0\\n        count=0\\n        nums.sort()\\n        n=len(nums)\\n        for j in range((n+1)//2,len(nums)):\\n            if 2 * nums[i] <= nums[j]:\\n                i+=1\\n                count+=2\\n        return count\\n",
                "codeTag": "Java"
            },
            {
                "id": 3251666,
                "title": "java-2-pointer-solution",
                "content": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int mid=nums.length/2-1;\\n        int l=mid;\\n        int count=0;\\n        int r=nums.length-1;\\n        while(l>=0){\\n            if((nums[l]*2)<=nums[r]){\\n                count=count+1;\\n                l=l-1;\\n                r=r-1;\\n            }\\n            else{\\n                l=l-1;\\n            }\\n        }\\n        return count*2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int mid=nums.length/2-1;\\n        int l=mid;\\n        int count=0;\\n        int r=nums.length-1;\\n        while(l>=0){\\n            if((nums[l]*2)<=nums[r]){\\n                count=count+1;\\n                l=l-1;\\n                r=r-1;\\n            }\\n            else{\\n                l=l-1;\\n            }\\n        }\\n        return count*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251102,
                "title": "c-easy-solution-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        vector<char>v(nums.size(),\\'u\\');\\n        sort(nums.begin(),nums.end());\\n        int largest = nums[nums.size()-1];\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            int l=0 , h= i-1;\\n            int k = nums[i]/2;\\n            int a = -1;\\n            while(l<=h){\\n                int mid= ((h-l)/2)+l;\\n                if(i==3){\\n                    cout<<nums[i]<<\\' \\';\\n                }\\n                if(nums[mid]<=k && v[mid]==\\'u\\'){\\n                    a=mid;\\n                    l=mid+1;\\n                }\\n                else{\\n                    h=mid-1;\\n                }\\n                \\n            }\\n            if(a==-1){\\n                continue;\\n            }\\n            else{\\n                v[a]=\\'m\\';\\n                v[i]=\\'m\\';\\n                \\n            }\\n        }\\n        for(int i=0;i<v.size();i++){\\n            cout<<v[i]<<\\' \\';\\n        }\\n        int c = count(v.begin(),v.end(),\\'m\\');\\n        if(c%2!=0){\\n            for(int i=0;i<nums.size();i++){\\n                if(v[i]==\\'u\\' && nums[i]<=largest/2)\\n                {\\n                    return c+1;\\n                }\\n            }\\n            return c-1;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        vector<char>v(nums.size(),\\'u\\');\\n        sort(nums.begin(),nums.end());\\n        int largest = nums[nums.size()-1];\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            int l=0 , h= i-1;\\n            int k = nums[i]/2;\\n            int a = -1;\\n            while(l<=h){\\n                int mid= ((h-l)/2)+l;\\n                if(i==3){\\n                    cout<<nums[i]<<\\' \\';\\n                }\\n                if(nums[mid]<=k && v[mid]==\\'u\\'){\\n                    a=mid;\\n                    l=mid+1;\\n                }\\n                else{\\n                    h=mid-1;\\n                }\\n                \\n            }\\n            if(a==-1){\\n                continue;\\n            }\\n            else{\\n                v[a]=\\'m\\';\\n                v[i]=\\'m\\';\\n                \\n            }\\n        }\\n        for(int i=0;i<v.size();i++){\\n            cout<<v[i]<<\\' \\';\\n        }\\n        int c = count(v.begin(),v.end(),\\'m\\');\\n        if(c%2!=0){\\n            for(int i=0;i<nums.size();i++){\\n                if(v[i]==\\'u\\' && nums[i]<=largest/2)\\n                {\\n                    return c+1;\\n                }\\n            }\\n            return c-1;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3250452,
                "title": "antarnab-100-faster-java-solution-full-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    //public int maxNumOfMarkedIndices(int[] nums) {\\n        public int maxNumOfMarkedIndices(int[] nums) {\\n    int i = 0, n = nums.length;\\n    Arrays.sort(nums);\\n    for (int j = n - n / 2; j < n; ++j)\\n        i += 2 * nums[i] <= nums[j] ? 1 : 0;\\n    return i * 2;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //public int maxNumOfMarkedIndices(int[] nums) {\\n        public int maxNumOfMarkedIndices(int[] nums) {\\n    int i = 0, n = nums.length;\\n    Arrays.sort(nums);\\n    for (int j = n - n / 2; j < n; ++j)\\n        i += 2 * nums[i] <= nums[j] ? 1 : 0;\\n    return i * 2;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244986,
                "title": "easy-to-understand-solution-in-c",
                "content": "\\n# Complexity\\n- Time complexity:162 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:60.2 mb\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int ans=0,i=0,j=nums.size()/2;\\n        sort(nums.begin(),nums.end());\\n        while(i<nums.size()/2 && j<nums.size()){\\n            if(2*nums[i]<=nums[j]) ans++,i++;\\n            j++;\\n        }\\n        return 2*ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int ans=0,i=0,j=nums.size()/2;\\n        sort(nums.begin(),nums.end());\\n        while(i<nums.size()/2 && j<nums.size()){\\n            if(2*nums[i]<=nums[j]) ans++,i++;\\n            j++;\\n        }\\n        return 2*ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244909,
                "title": "c-golang-two-pointers-greedy",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int ans = 0;\\n        for(int i = 0, j = n / 2; i < n / 2 && j < n; i++, j++) {\\n            while(j < n && 2 * nums[i] > nums[j]) j++;\\n            if(j < n) ans += 2;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc maxNumOfMarkedIndices(nums []int) int {\\n    sort.Ints(nums)\\n    var n, ans int = len(nums), 0\\n    for i, j := 0, n / 2; i < n / 2 && j < n; i, j = i + 1, j + 1 {\\n        for j < n && 2 * nums[i] > nums[j] {j++}\\n        if j < n {ans += 2}\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int ans = 0;\\n        for(int i = 0, j = n / 2; i < n / 2 && j < n; i++, j++) {\\n            while(j < n && 2 * nums[i] > nums[j]) j++;\\n            if(j < n) ans += 2;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc maxNumOfMarkedIndices(nums []int) int {\\n    sort.Ints(nums)\\n    var n, ans int = len(nums), 0\\n    for i, j := 0, n / 2; i < n / 2 && j < n; i, j = i + 1, j + 1 {\\n        for j < n && 2 * nums[i] > nums[j] {j++}\\n        if j < n {ans += 2}\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244598,
                "title": "20230301-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int nn=n;\\n        for (int i = n/2; i>0; i--)\\n            if (nums[i-1]*2 <= nums[n-1]) n--;\\n        return (nn-n)*2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int nn=n;\\n        for (int i = n/2; i>0; i--)\\n            if (nums[i-1]*2 <= nums[n-1]) n--;\\n        return (nn-n)*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243696,
                "title": "treemap-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        TreeMap<Integer,Integer> set = new TreeMap<>();\\n        TreeMap<Integer,Integer> set2 = new TreeMap<>();\\n        int ans = 0, l = nums.length;\\n        Arrays.sort(nums);\\n        for(int i = 0;i<l/2;i++){\\n            int a = nums[i];\\n            if(set.containsKey(a))set.put(a,set.get(a) + 1);\\n            else set.put(a,1);\\n        }\\n\\n        for(int i = l/2;i<l;i++){\\n            int a = nums[i];\\n            if(set2.containsKey(a))set2.put(a,set2.get(a) + 1);\\n            else set2.put(a,1);\\n        }\\n\\n        for(int i = 0;i<l/2;i++){\\n            int a = nums[i];\\n            if(set2.ceilingKey(2*a)!=null){\\n                int b = set2.ceilingKey(2*a);\\n                set2.put(b,set2.get(b)-1);\\n                if(set2.get(b)==0)set2.remove(b);\\n                set.put(a,set.get(a)-1);\\n                if(set.get(a)==0)set.remove(a);\\n                ans+=2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n\\n// 2 \\n// 2 3 4 5\\n// 2,4\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        TreeMap<Integer,Integer> set = new TreeMap<>();\\n        TreeMap<Integer,Integer> set2 = new TreeMap<>();\\n        int ans = 0, l = nums.length;\\n        Arrays.sort(nums);\\n        for(int i = 0;i<l/2;i++){\\n            int a = nums[i];\\n            if(set.containsKey(a))set.put(a,set.get(a) + 1);\\n            else set.put(a,1);\\n        }\\n\\n        for(int i = l/2;i<l;i++){\\n            int a = nums[i];\\n            if(set2.containsKey(a))set2.put(a,set2.get(a) + 1);\\n            else set2.put(a,1);\\n        }\\n\\n        for(int i = 0;i<l/2;i++){\\n            int a = nums[i];\\n            if(set2.ceilingKey(2*a)!=null){\\n                int b = set2.ceilingKey(2*a);\\n                set2.put(b,set2.get(b)-1);\\n                if(set2.get(b)==0)set2.remove(b);\\n                set.put(a,set.get(a)-1);\\n                if(set.get(a)==0)set.remove(a);\\n                ans+=2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n\\n// 2 \\n// 2 3 4 5\\n// 2,4\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242935,
                "title": "easy-to-understand-c-solution-two-pointers",
                "content": "# Complexity\\n- Time complexity: O(n*logn)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int cnt = 0, n = nums.size(), j = n/2;\\n        for(int i=0;i<n/2 && j<n;) {\\n            if(2* nums[i] <= nums[j]) {\\n                cnt+=2;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int cnt = 0, n = nums.size(), j = n/2;\\n        for(int i=0;i<n/2 && j<n;) {\\n            if(2* nums[i] <= nums[j]) {\\n                cnt+=2;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242914,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        const auto size = nums.size();\\n        int skips = size % 2, result = 0;\\n        for (auto i = 0; i + size / 2 + skips < size;) {\\n            if (2 * nums[i] <= nums[i + size / 2 + skips]) {\\n                ++result; ++i;\\n            } else ++skips;\\n        }\\n        return 2 * result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        const auto size = nums.size();\\n        int skips = size % 2, result = 0;\\n        for (auto i = 0; i + size / 2 + skips < size;) {\\n            if (2 * nums[i] <= nums[i + size / 2 + skips]) {\\n                ++result; ++i;\\n            } else ++skips;\\n        }\\n        return 2 * result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242197,
                "title": "this-question-was-so-easy-and-i-have-wasted-time-thinking-about-binary-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n      int n = nums.length ;\\n        int count = 0 ;\\n      int i = 0;\\n        int j = (n%2==0)?n/2:(n/2)+1;\\n        while(i<=j){\\n            if(i==n||j==n)\\n                break;\\n            if(  2*nums[i]<=nums[j] ){\\n                i++;\\n            j++;\\n                count+=2;\\n                \\n            }\\n            else \\n            {\\n                j++;\\n            }\\n        }\\n                \\nreturn count ;\\n}\\n       \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n      int n = nums.length ;\\n        int count = 0 ;\\n      int i = 0;\\n        int j = (n%2==0)?n/2:(n/2)+1;\\n        while(i<=j){\\n            if(i==n||j==n)\\n                break;\\n            if(  2*nums[i]<=nums[j] ){\\n                i++;\\n            j++;\\n                count+=2;\\n                \\n            }\\n            else \\n            {\\n                j++;\\n            }\\n        }\\n                \\nreturn count ;\\n}\\n       \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242093,
                "title": "the-worst-solution",
                "content": "# Intuition\\ngreed and badly written code\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n), thanks Tim!\\n# Code\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        i, j = 0, (len(nums) + 1) // 2\\n\\n        while j < len(nums):\\n            if (nums[i] * 2) <= nums[j]: #success\\n                i += 1\\n                j += 1\\n            else: #failure\\n                j += 1 #note that j+= 1 happens both times but has DISTINCTION here\\n\\n        #num of pairs == how much we can move i to the right and pair it with j_elements\\n        #total == (that mess) * 2\\n        return (i) * 2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        i, j = 0, (len(nums) + 1) // 2\\n\\n        while j < len(nums):\\n            if (nums[i] * 2) <= nums[j]: #success\\n                i += 1\\n                j += 1\\n            else: #failure\\n                j += 1 #note that j+= 1 happens both times but has DISTINCTION here\\n\\n        #num of pairs == how much we can move i to the right and pair it with j_elements\\n        #total == (that mess) * 2\\n        return (i) * 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241087,
                "title": "c-sorting-two-pointer",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size(),cnt=0;\\n        int i=0,j=n/2;\\n        while(i<n/2 && j<n){\\n            if(2*nums[i]<=nums[j]){\\n                cnt++;\\n                i++;\\n                j++;\\n            }else {\\n                j++;\\n            }\\n        }\\n        return 2*cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size(),cnt=0;\\n        int i=0,j=n/2;\\n        while(i<n/2 && j<n){\\n            if(2*nums[i]<=nums[j]){\\n                cnt++;\\n                i++;\\n                j++;\\n            }else {\\n                j++;\\n            }\\n        }\\n        return 2*cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240625,
                "title": "c-sorting-two-pointers-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums)\\n    {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=n/2,ans=0;\\n        while(j<n&&i<n/2)\\n        {\\n            if(nums[i]*2<=nums[j])\\n            {\\n                ans++;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans*2;\\n        \\n        \\n    }\\n};\\n```\\nIf you like the solution plz upvote.\\n=",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums)\\n    {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=n/2,ans=0;\\n        while(j<n&&i<n/2)\\n        {\\n            if(nums[i]*2<=nums[j])\\n            {\\n                ans++;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans*2;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239918,
                "title": "1sentence-faster-than-98-matching-lower-half-with-upper-half-of-nums-with-2-pointers",
                "content": "# Upvote if you like the solution\\n\\n# Code\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        j = n//2\\n        ret = 0\\n        for i in range(n//2):\\n            while j<n and nums[j] < 2 * nums[i]:\\n                j += 1\\n            if j<n:\\n                ret += 2\\n                j += 1\\n            elif j==n:\\n                break\\n        return ret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        j = n//2\\n        ret = 0\\n        for i in range(n//2):\\n            while j<n and nums[j] < 2 * nums[i]:\\n                j += 1\\n            if j<n:\\n                ret += 2\\n                j += 1\\n            elif j==n:\\n                break\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239756,
                "title": "easy-java-solution",
                "content": "# Intuition\\nWe require pairs to be maximum so we have pair them in such a way that we can find pair for all nums[i]. \\n\\n# Approach\\nWe can do it by sorting the array and two pointers algorithm \\n\\n# Complexity\\n- Time complexity:\\nO(logn) (Sorting)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int n = nums.length;\\n        int i=0, j=n/2, ans = 0;\\n        Arrays.sort(nums);\\n        while(i<n/2 && j<n){\\n            if(2*nums[i] <= nums[j]){\\n                i++;\\n                j++;\\n                ans=ans+2;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nPls give an upvote :)\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int n = nums.length;\\n        int i=0, j=n/2, ans = 0;\\n        Arrays.sort(nums);\\n        while(i<n/2 && j<n){\\n            if(2*nums[i] <= nums[j]){\\n                i++;\\n                j++;\\n                ans=ans+2;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238885,
                "title": "easy-simple-solution-c-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        int ft=0;\\n        int sec=n/2;\\n        int cnt=0;\\n        while(ft<n/2 && sec<n){\\n            if(2*nums[ft]<=nums[sec]){\\n                cnt+=2;\\n                ft++;\\n                sec++;\\n            }\\n            else\\n            sec++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        int ft=0;\\n        int sec=n/2;\\n        int cnt=0;\\n        while(ft<n/2 && sec<n){\\n            if(2*nums[ft]<=nums[sec]){\\n                cnt+=2;\\n                ft++;\\n                sec++;\\n            }\\n            else\\n            sec++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238823,
                "title": "fundamental-approach-two-pointers-c-sorting",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int i = 0;\\n        int n = nums.size();\\n        int j = n/2;\\n        int out = 0;\\n        while(i < (n/2) and j < n) {\\n            if(nums[i]*2 <= nums[j]) {\\n                out += 2;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return out;\\n    }\\n};\\n// Please consider upvoting if the solution helped! Thank you :)\\n// Credits: (Whose-so-ever concerned)\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int i = 0;\\n        int n = nums.size();\\n        int j = n/2;\\n        int out = 0;\\n        while(i < (n/2) and j < n) {\\n            if(nums[i]*2 <= nums[j]) {\\n                out += 2;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return out;\\n    }\\n};\\n// Please consider upvoting if the solution helped! Thank you :)\\n// Credits: (Whose-so-ever concerned)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238660,
                "title": "two-pointer-rust",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn max_num_of_marked_indices(mut nums: Vec<i32>) -> i32 {\\n        let n = nums.len();\\n        nums.sort_unstable();\\n\\n        let mut left: usize = 0;\\n        let mut right: usize = n / 2;    \\n        while left < n/2 && right < n {\\n            if nums[left] * 2 <= nums[right] {\\n                left += 1;\\n            }\\n            right += 1;\\n        }\\n        return (left * 2) as i32;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_num_of_marked_indices(mut nums: Vec<i32>) -> i32 {\\n        let n = nums.len();\\n        nums.sort_unstable();\\n\\n        let mut left: usize = 0;\\n        let mut right: usize = n / 2;    \\n        while left < n/2 && right < n {\\n            if nums[left] * 2 <= nums[right] {\\n                left += 1;\\n            }\\n            right += 1;\\n        }\\n        return (left * 2) as i32;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3238659,
                "title": "two-pointer-rust",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn max_num_of_marked_indices(mut nums: Vec<i32>) -> i32 {\\n        let n = nums.len();\\n        nums.sort_unstable();\\n\\n        let mut left: usize = 0;\\n        let mut right: usize = n / 2;    \\n        while left < n/2 && right < n {\\n            if nums[left] * 2 <= nums[right] {\\n                left += 1;\\n            }\\n            right += 1;\\n        }\\n        return (left * 2) as i32;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_num_of_marked_indices(mut nums: Vec<i32>) -> i32 {\\n        let n = nums.len();\\n        nums.sort_unstable();\\n\\n        let mut left: usize = 0;\\n        let mut right: usize = n / 2;    \\n        while left < n/2 && right < n {\\n            if nums[left] * 2 <= nums[right] {\\n                left += 1;\\n            }\\n            right += 1;\\n        }\\n        return (left * 2) as i32;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3238454,
                "title": "java-beginner-friendly-solution",
                "content": "# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans = 0;\\n        int n = nums.length;\\n        int j = n-1;\\n    \\n        for(int i=n/2-1;i>=0;i--){\\n            if (nums[i] * 2 <= nums[j]) {\\n                ans += 2; \\n                j -= 1;\\n            }\\n        }\\n\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans = 0;\\n        int n = nums.length;\\n        int j = n-1;\\n    \\n        for(int i=n/2-1;i>=0;i--){\\n            if (nums[i] * 2 <= nums[j]) {\\n                ans += 2; \\n                j -= 1;\\n            }\\n        }\\n\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237853,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n    sort(nums.begin(), nums.end());\\n    int n = nums.size();\\n    int i = 0, j = n/2, cnt = 0;\\n    while(j<n and i < n/2){\\n        if(2 * nums[i] <= nums[j]){\\n            cnt += 2;\\n            i++;\\n        }\\n        j++;\\n    }\\n    return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n    sort(nums.begin(), nums.end());\\n    int n = nums.size();\\n    int i = 0, j = n/2, cnt = 0;\\n    while(j<n and i < n/2){\\n        if(2 * nums[i] <= nums[j]){\\n            cnt += 2;\\n            i++;\\n        }\\n        j++;\\n    }\\n    return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237459,
                "title": "c-sorting-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        int n=nums.size()/2;\\n        int j=n;\\n        for(int i=0;i<n && j<nums.size();){\\n            if(nums[i]*2<=nums[j]){\\n                    i++;\\n                    j++;\\n                    ans+=2;\\n                }\\n                else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n//Please upvote if you like the code",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        int n=nums.size()/2;\\n        int j=n;\\n        for(int i=0;i<n && j<nums.size();){\\n            if(nums[i]*2<=nums[j]){\\n                    i++;\\n                    j++;\\n                    ans+=2;\\n                }\\n                else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237233,
                "title": "beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        // vector<int>vis(n,0);\\n        int i=0;\\n        int j=n/2;\\n        while(i<n/2 && j<n){\\n            if( 2*nums[i]<=nums[j]){\\n                ans+=2;\\n                \\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        // vector<int>vis(n,0);\\n        int i=0;\\n        int j=n/2;\\n        while(i<n/2 && j<n){\\n            if( 2*nums[i]<=nums[j]){\\n                ans+=2;\\n                \\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237032,
                "title": "easy-understanding-c-solution-binary-search",
                "content": "```\\nclass Solution {\\n    bool utilfunc(vector<int> &nums,int k)\\n    {\\n        int count = 0;\\n        int n = nums.size();\\n        for(int i=0;i<k;i++)\\n        {\\n            if(2*nums[i]<=nums[n-k+i])\\n            {\\n                count++;\\n            }\\n        }\\n        return count == k;\\n    }\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int l = 0;\\n        int h = nums.size()/2;\\n        int ans  = l;\\n        while(l<=h)\\n        {\\n            int mid = (l+(h-l)/2);\\n            \\n            if(utilfunc(nums,mid))\\n            {\\n                ans = max(ans,mid);\\n                l = mid+1;\\n            }else{\\n                h = mid-1;\\n            }\\n        }\\n        return ans*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    bool utilfunc(vector<int> &nums,int k)\\n    {\\n        int count = 0;\\n        int n = nums.size();\\n        for(int i=0;i<k;i++)\\n        {\\n            if(2*nums[i]<=nums[n-k+i])\\n            {\\n                count++;\\n            }\\n        }\\n        return count == k;\\n    }\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int l = 0;\\n        int h = nums.size()/2;\\n        int ans  = l;\\n        while(l<=h)\\n        {\\n            int mid = (l+(h-l)/2);\\n            \\n            if(utilfunc(nums,mid))\\n            {\\n                ans = max(ans,mid);\\n                l = mid+1;\\n            }else{\\n                h = mid-1;\\n            }\\n        }\\n        return ans*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236736,
                "title": "binarysearch-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        left, right = 0, n // 2\\n        while left <= right:\\n            k = (left + right) // 2\\n            if all(nums[i] * 2 <= nums[i - k] for i in range(k)):\\n                left = k + 1\\n            else:\\n                right = k - 1\\n\\n        return (left - 1) * 2\\n                    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        left, right = 0, n // 2\\n        while left <= right:\\n            k = (left + right) // 2\\n            if all(nums[i] * 2 <= nums[i - k] for i in range(k)):\\n                left = k + 1\\n            else:\\n                right = k - 1\\n\\n        return (left - 1) * 2\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236578,
                "title": "a-few-solutions",
                "content": "Initialize `i` and `j` to the index of the last element of the first and second half of the *sorted* input array `A` correspondingly.\\n\\nFrom right-to-left, greedily consume pairs of index `i`,`j` if-and-only-if `A[i] * 2 <= A[j]`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun maxNumOfMarkedIndices(A: IntArray): Int {\\n        var N = A.size\\n        if (N == 1)\\n            return 0\\n        var cnt = 0\\n        A.sort()\\n        var (i, j) = Pair(N / 2 - 1, N - 1)\\n        while (0 <= i) {\\n            if (A[i] * 2 <= A[j]) {\\n                --j; cnt += 2;\\n            }\\n            --i\\n        }\\n        return cnt\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet maxNumOfMarkedIndices = (A, cnt = 0) => {\\n    let N = A.length;\\n    if (N == 1)\\n        return 0;\\n    A.sort((a, b) => a - b);\\n    let [i, j] = [Math.floor(N / 2) - 1, N - 1];\\n    while (0 <= i) {\\n        if (A[i] * 2 <= A[j])\\n            --j, cnt += 2;\\n        --i;\\n    }\\n    return cnt;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, A: List[int], cnt = 0) -> int:\\n        N = len(A)\\n        if N == 1:\\n            return 0\\n        A.sort()\\n        i, j = N // 2 - 1, N - 1\\n        while 0 <= i:\\n            if A[i] * 2 <= A[j]:\\n                j -= 1; cnt += 2\\n            i -= 1\\n        return cnt\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn max_num_of_marked_indices(mut A: VI) -> i32 {\\n        let N = A.len();\\n        if N == 1 {\\n            return 0;\\n        }\\n        let mut cnt = 0;\\n        A.sort();\\n        let (mut i, mut j) = (N / 2 - 1, N - 1);\\n        loop {\\n            if A[i] * 2 <= A[j] {\\n                j -= 1; cnt += 2;\\n            }\\n            if i == 0 { break; } else { i -= 1; }\\n        }\\n        cnt\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maxNumOfMarkedIndices(VI& A, int cnt = 0) {\\n        int N = A.size();\\n        if (N == 1)\\n            return 0;\\n        sort(A.begin(), A.end());\\n        auto [i, j] = make_pair(N / 2 - 1, N - 1);\\n        while (0 <= i) {\\n            if (A[i] * 2 <= A[j])\\n                --j, cnt += 2;\\n            --i;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maxNumOfMarkedIndices(A: IntArray): Int {\\n        var N = A.size\\n        if (N == 1)\\n            return 0\\n        var cnt = 0\\n        A.sort()\\n        var (i, j) = Pair(N / 2 - 1, N - 1)\\n        while (0 <= i) {\\n            if (A[i] * 2 <= A[j]) {\\n                --j; cnt += 2;\\n            }\\n            --i\\n        }\\n        return cnt\\n    }\\n}\\n```\n```\\nlet maxNumOfMarkedIndices = (A, cnt = 0) => {\\n    let N = A.length;\\n    if (N == 1)\\n        return 0;\\n    A.sort((a, b) => a - b);\\n    let [i, j] = [Math.floor(N / 2) - 1, N - 1];\\n    while (0 <= i) {\\n        if (A[i] * 2 <= A[j])\\n            --j, cnt += 2;\\n        --i;\\n    }\\n    return cnt;\\n};\\n```\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, A: List[int], cnt = 0) -> int:\\n        N = len(A)\\n        if N == 1:\\n            return 0\\n        A.sort()\\n        i, j = N // 2 - 1, N - 1\\n        while 0 <= i:\\n            if A[i] * 2 <= A[j]:\\n                j -= 1; cnt += 2\\n            i -= 1\\n        return cnt\\n```\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn max_num_of_marked_indices(mut A: VI) -> i32 {\\n        let N = A.len();\\n        if N == 1 {\\n            return 0;\\n        }\\n        let mut cnt = 0;\\n        A.sort();\\n        let (mut i, mut j) = (N / 2 - 1, N - 1);\\n        loop {\\n            if A[i] * 2 <= A[j] {\\n                j -= 1; cnt += 2;\\n            }\\n            if i == 0 { break; } else { i -= 1; }\\n        }\\n        cnt\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maxNumOfMarkedIndices(VI& A, int cnt = 0) {\\n        int N = A.size();\\n        if (N == 1)\\n            return 0;\\n        sort(A.begin(), A.end());\\n        auto [i, j] = make_pair(N / 2 - 1, N - 1);\\n        while (0 <= i) {\\n            if (A[i] * 2 <= A[j])\\n                --j, cnt += 2;\\n            --i;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236378,
                "title": "c-solution-with-sort-and-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe first need to sort the array to maximise the result. Then we canseperate the first half and second half oof array and greedly try to make as much pair as we can.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int i = 0;\\n        for (int j=(n+1)/2; j<n; ++j) {\\n            if (2 * nums[i] <= nums[j]) i++;\\n        }\\n        return i * 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int i = 0;\\n        for (int j=(n+1)/2; j<n; ++j) {\\n            if (2 * nums[i] <= nums[j]) i++;\\n        }\\n        return i * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236363,
                "title": "java-easy-5-lines-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int maxNumOfMarkedIndices(int[] nums) {\\n    Arrays.sort(nums);\\n    int l = 0;\\n\\n    for(int r = (nums.length+1)>>1; r != nums.length; r++)\\n      if((nums[l]<<1) <= nums[r]) l++;\\n    \\n    return l<<1;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int maxNumOfMarkedIndices(int[] nums) {\\n    Arrays.sort(nums);\\n    int l = 0;\\n\\n    for(int r = (nums.length+1)>>1; r != nums.length; r++)\\n      if((nums[l]<<1) <= nums[r]) l++;\\n    \\n    return l<<1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236273,
                "title": "two-pointer-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe know that the order of i,j does not matter in this question.\\nSo we can sort it and look for the required pairs.\\n\\nWe know that there can only be n/2 pairs maximum in the given array\\nSo while trying to find maximum number of pairs we can go from the. midpoint of the sorted array with the idea of matching the elements in the first half of the array with elements of second half of arrray.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse 2 ptr approach and greedily search the first possible pair for the element in the first half of array to the available elements in the second half of the array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxNumOfMarkedIndices(int[] nums) {\\n        Array.Sort(nums);\\n        \\n        int n = nums.Length;\\n        \\n        int p1 = 0, midPoint = (n%2==0)?n/2:n/2+1;\\n        \\n        int p2 = midPoint;\\n        \\n        int ans = 0;\\n        \\n        while(p1<midPoint && p2<n){\\n            if(2*nums[p1]<=nums[p2]){\\n                ans += 2;\\n                p1++;\\n                p2++;\\n            }\\n            else{\\n                p2++;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxNumOfMarkedIndices(int[] nums) {\\n        Array.Sort(nums);\\n        \\n        int n = nums.Length;\\n        \\n        int p1 = 0, midPoint = (n%2==0)?n/2:n/2+1;\\n        \\n        int p2 = midPoint;\\n        \\n        int ans = 0;\\n        \\n        while(p1<midPoint && p2<n){\\n            if(2*nums[p1]<=nums[p2]){\\n                ans += 2;\\n                p1++;\\n                p2++;\\n            }\\n            else{\\n                p2++;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236051,
                "title": "simple-and-fast-approach-c",
                "content": "#\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int i=0,count=0,j=nums.size()/2;\\n        while(j<nums.size())\\n        {\\n            if(nums[i]==-1)\\n            {\\n                i+=1;\\n                continue;\\n            }\\n            if(2*nums[i]<=nums[j])\\n            {\\n                i+=1;\\n                nums[j]=-1;\\n                j+=1;\\n                count+=2;\\n            }\\n            else\\n            {\\n                j+=1;\\n            }\\n        }\\n        return count;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int i=0,count=0,j=nums.size()/2;\\n        while(j<nums.size())\\n        {\\n            if(nums[i]==-1)\\n            {\\n                i+=1;\\n                continue;\\n            }\\n            if(2*nums[i]<=nums[j])\\n            {\\n                i+=1;\\n                nums[j]=-1;\\n                j+=1;\\n                count+=2;\\n            }\\n            else\\n            {\\n                j+=1;\\n            }\\n        }\\n        return count;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235980,
                "title": "very-easy-c-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n         int n=nums.size();\\n        int k=nums.size()/2;\\n        if(n==1){\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end());\\n        int i=k-1;\\n        int j=n-1;\\n        int ans=0;\\n        while(i>=0 && j>=k){\\n            if(2*nums[i]<=nums[j]){\\n                ans+=2;\\n                i--;\\n                j--;\\n            }\\n            else{\\n                i--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n         int n=nums.size();\\n        int k=nums.size()/2;\\n        if(n==1){\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end());\\n        int i=k-1;\\n        int j=n-1;\\n        int ans=0;\\n        while(i>=0 && j>=k){\\n            if(2*nums[i]<=nums[j]){\\n                ans+=2;\\n                i--;\\n                j--;\\n            }\\n            else{\\n                i--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235710,
                "title": "dart-both-two-pointer-and-binary-search-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(LogN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Two Pointer\\n```\\n  int maxNumOfMarkedIndices(List<int> nums) {\\n    nums.sort();\\n    int n = nums.length;\\n    int res = 0;\\n    for (var i = 0, j = (n + 1) ~/ 2; j < n; j++) {\\n      if (nums[j] >= nums[i] * 2) {\\n        i++;\\n        res += 2;\\n      }\\n    }\\n\\n    return res;\\n  }\\n```\\n\\n# Binary Search Answer\\n```\\nclass Solution {\\n  int maxNumOfMarkedIndices(List<int> nums) {\\n    nums.sort();\\n    int n = nums.length;\\n    int res = 0;\\n    int mid = (n + 1) ~/ 2;\\n    for (var i = 0; i < n / 2; i++) {\\n      mid = lowerBound(nums, 2 * nums[i], start: mid);\\n      if (mid == n) {\\n          break;\\n      }\\n      mid++;\\n      res += 2;\\n    }\\n\\n    return res;\\n  }\\n\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\n  int maxNumOfMarkedIndices(List<int> nums) {\\n    nums.sort();\\n    int n = nums.length;\\n    int res = 0;\\n    for (var i = 0, j = (n + 1) ~/ 2; j < n; j++) {\\n      if (nums[j] >= nums[i] * 2) {\\n        i++;\\n        res += 2;\\n      }\\n    }\\n\\n    return res;\\n  }\\n```\n```\\nclass Solution {\\n  int maxNumOfMarkedIndices(List<int> nums) {\\n    nums.sort();\\n    int n = nums.length;\\n    int res = 0;\\n    int mid = (n + 1) ~/ 2;\\n    for (var i = 0; i < n / 2; i++) {\\n      mid = lowerBound(nums, 2 * nums[i], start: mid);\\n      if (mid == n) {\\n          break;\\n      }\\n      mid++;\\n      res += 2;\\n    }\\n\\n    return res;\\n  }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235374,
                "title": "c-solution-beats-100-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        int n=nums.size();\\n        int i=0;\\n        int j=n/2;\\n        while(j<n&&i<n/2){\\n            if(nums[i]*2<=nums[j]){\\n                ans+=2;\\n                i++;   \\n            }\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        int n=nums.size();\\n        int i=0;\\n        int j=n/2;\\n        while(j<n&&i<n/2){\\n            if(nums[i]*2<=nums[j]){\\n                ans+=2;\\n                i++;   \\n            }\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235198,
                "title": "swift-one-liner",
                "content": "**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n    func maxNumOfMarkedIndices(_ n: [Int]) -> Int {\\n        ((n.count+1)/2..<n.count).reduce(into: (0, n.sorted())) {$0.0 += $0.1[$0.0]*2<=$0.1[$1] ? 1:0}.0*2\\n    }\\n}\\n```\\n\\n----\\n\\n**One-Liner, expanded and annnotated (accepted answer)**\\n```\\nclass Solution {\\n    func maxNumOfMarkedIndices(_ nums: [Int]) -> Int {\\n        ((nums.count+1)/2..<nums.count).reduce(into: (\\n            result: 0, \\n            nums: nums.sorted()\\n        )) { data, num in \\n            data.result += data.nums[data.result]*2 <= data.nums[num] ? 1:0\\n        }.result * 2\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxNumOfMarkedIndices(_ n: [Int]) -> Int {\\n        ((n.count+1)/2..<n.count).reduce(into: (0, n.sorted())) {$0.0 += $0.1[$0.0]*2<=$0.1[$1] ? 1:0}.0*2\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func maxNumOfMarkedIndices(_ nums: [Int]) -> Int {\\n        ((nums.count+1)/2..<nums.count).reduce(into: (\\n            result: 0, \\n            nums: nums.sorted()\\n        )) { data, num in \\n            data.result += data.nums[data.result]*2 <= data.nums[num] ? 1:0\\n        }.result * 2\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235184,
                "title": "javascript-greedy-201ms",
                "content": "```\\nconst maxNumOfMarkedIndices = (a) => {\\n    a.sort((x, y) => x - y);\\n    let n = a.length, j = n - 1, res = 0;\\n    for (let i = (n >> 1) - 1; i >= 0; i--) {\\n        if (a[i] * 2 <= a[j]) {\\n            res += 2;\\n            j--;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nconst maxNumOfMarkedIndices = (a) => {\\n    a.sort((x, y) => x - y);\\n    let n = a.length, j = n - 1, res = 0;\\n    for (let i = (n >> 1) - 1; i >= 0; i--) {\\n        if (a[i] * 2 <= a[j]) {\\n            res += 2;\\n            j--;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3235182,
                "title": "100-fast-4-lines-sol-c",
                "content": "***Code is poetry of the binary***\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());int i=0;int j=nums.size()/2;int count=0;\\n        while(i<nums.size()/2&&j<nums.size()){\\n            if(nums[i]*2<=nums[j]){i++;j++;count++;}else j++;\\n        }return count*2;\\n    }\\n};\\n```\\n**logik**\\n1.sort \\n2.make i go from 0 to n/2 and j from n/2 to n \\n3.whenever nums[i]*2<=nums[j] then increment count (as it is a pair) and j++,i++;\\n4.else keep doing j++;\\n5.return 2*count as count is number of pairs and 2*count is number of numbers \\n![image](https://assets.leetcode.com/users/images/268ef4e7-46dd-4e2f-8c3f-cfe1dbee2293_1677476936.8152895.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());int i=0;int j=nums.size()/2;int count=0;\\n        while(i<nums.size()/2&&j<nums.size()){\\n            if(nums[i]*2<=nums[j]){i++;j++;count++;}else j++;\\n        }return count*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235032,
                "title": "easy-cpp-code-binary-search-lower-bound",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. sort the array.\\n2. Traverse from middle index to the zeroth index.\\n3. At each index i search for an index j that follows the condition(2*nums[i]<=nums[j]).\\n4. After each search if the element is found decrease the end iterator by one for the subseqence search. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int start=(n/2)-1;\\n        int count=0;\\n        for(int i=start;i>=0;i--){\\n            auto it2=nums.end()-count;\\n            auto it1=nums.begin()+start+1;\\n            auto it = lower_bound(it1, it2, 2*nums[i]);\\n            if(it!=it2) count++;\\n        }\\n        return 2*count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int start=(n/2)-1;\\n        int count=0;\\n        for(int i=start;i>=0;i--){\\n            auto it2=nums.end()-count;\\n            auto it1=nums.begin()+start+1;\\n            auto it = lower_bound(it1, it2, 2*nums[i]);\\n            if(it!=it2) count++;\\n        }\\n        return 2*count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234916,
                "title": "reverse-sort-and-two-pointers",
                "content": "# Original solution (easiest to understand):\\n```python\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        h = n // 2\\n        l = nums[:h]\\n        r = nums[h:]\\n        c = 0\\n        while l and r:\\n            if 2 * l[0] <= r[0]:\\n                l.pop(0)\\n                r.pop(0)\\n                c += 2\\n            else:\\n                r.pop(0)\\n        return c\\n```\\n\\n# Reversed (because popping from right is faster)\\n```python\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        n = len(nums)\\n        h = n // 2\\n        r = nums[:h]\\n        l = nums[h:]\\n        c = 0\\n        while l and r:\\n            if 2 * l[-1] <= r[-1]:\\n                l.pop()\\n                r.pop()\\n                c += 2\\n            else:\\n                r.pop()\\n        return c\\n```\\n# Converted to two pointers\\n```python\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        n = len(nums)\\n        h = n // 2\\n        c = 0\\n        i = h - 1\\n        j = n - 1\\n        while i >= 0 and j >= h:\\n            if 2 * nums[j] <= nums[i]:\\n                i -= 1\\n                j -= 1\\n                c += 2\\n            else:\\n                i -= 1\\n        return c\\n```\\n\\nProbably should have converted the original solution to two pointers instead, but ayeeee.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        h = n // 2\\n        l = nums[:h]\\n        r = nums[h:]\\n        c = 0\\n        while l and r:\\n            if 2 * l[0] <= r[0]:\\n                l.pop(0)\\n                r.pop(0)\\n                c += 2\\n            else:\\n                r.pop(0)\\n        return c\\n```\n```python\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        n = len(nums)\\n        h = n // 2\\n        r = nums[:h]\\n        l = nums[h:]\\n        c = 0\\n        while l and r:\\n            if 2 * l[-1] <= r[-1]:\\n                l.pop()\\n                r.pop()\\n                c += 2\\n            else:\\n                r.pop()\\n        return c\\n```\n```python\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        n = len(nums)\\n        h = n // 2\\n        c = 0\\n        i = h - 1\\n        j = n - 1\\n        while i >= 0 and j >= h:\\n            if 2 * nums[j] <= nums[i]:\\n                i -= 1\\n                j -= 1\\n                c += 2\\n            else:\\n                i -= 1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234900,
                "title": "two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans=0,n = nums.size(), lp =0, rp =n/2;\\n        while( lp < n/2 and rp <= n-1){\\n            if( 2*nums[lp]<= nums[rp]){\\n                ans+=2;\\n                lp++;\\n                \\n            }\\n         rp++;\\n\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans=0,n = nums.size(), lp =0, rp =n/2;\\n        while( lp < n/2 and rp <= n-1){\\n            if( 2*nums[lp]<= nums[rp]){\\n                ans+=2;\\n                lp++;\\n                \\n            }\\n         rp++;\\n\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234646,
                "title": "python-2-pointers-most-readable-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        start = 0\\n        end = n//2\\n        ans = 0\\n\\n        while(end<n and start<n//2):\\n            if(nums[end]>=2*nums[start]):\\n                ans+=2\\n                start += 1\\n                end += 1\\n            else:\\n                end += 1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        start = 0\\n        end = n//2\\n        ans = 0\\n\\n        while(end<n and start<n//2):\\n            if(nums[end]>=2*nums[start]):\\n                ans+=2\\n                start += 1\\n                end += 1\\n            else:\\n                end += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234543,
                "title": "javascript-sorting-two-pointers",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxNumOfMarkedIndices = function (nums) {\\n  nums.sort((a, b) => a - b);\\n  const half = Math.floor(nums.length / 2);\\n\\n  let ans = 0;\\n  let i = 0;\\n  let j = half;\\n  while (i < half && j < nums.length) {\\n    if (nums[i] * 2 <= nums[j]) {\\n      ans += 2;\\n      i++;\\n      j++;\\n    } else {\\n      j++;\\n    }\\n  }\\n\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Sort"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxNumOfMarkedIndices = function (nums) {\\n  nums.sort((a, b) => a - b);\\n  const half = Math.floor(nums.length / 2);\\n\\n  let ans = 0;\\n  let i = 0;\\n  let j = half;\\n  while (i < half && j < nums.length) {\\n    if (nums[i] * 2 <= nums[j]) {\\n      ans += 2;\\n      i++;\\n      j++;\\n    } else {\\n      j++;\\n    }\\n  }\\n\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3234476,
                "title": "c-5-line",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        int res = 0;\\n        for(int i=0, n = nums.size(), j = n/2; i<n/2 && j<n;)\\n            nums[i] * 2  <= nums[j] ? i++, j++, res++ : j++;\\n        return res*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        int res = 0;\\n        for(int i=0, n = nums.size(), j = n/2; i<n/2 && j<n;)\\n            nums[i] * 2  <= nums[j] ? i++, j++, res++ : j++;\\n        return res*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234187,
                "title": "c-greedy-two-pointers",
                "content": "# Intuition\\nBacktracking is TLE, there is no good key to use for memoization\\n\\nGreedy:\\n- we can sort nums, the indices don\\'t matter\\n- there are at max n/2 i\\'s and n/2 j\\'s\\n- the best approach is point i to 0 point j to (n + 1) / 2\\n- if nums[i] * 2 >= nums[j]\\n    mark them\\n- else \\n    increment j\\n\\n\\nO(nlgn) time\\nO(n) space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // 2,3,4,5\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        int i = 0;\\n        int j = (nums.size() + 1) >> 1;\\n\\n        while (j < nums.size()) {\\n            if ((nums[i] << 1) <= nums[j]) {\\n                ans += 2;\\n                i++;\\n                j++;\\n            } else {\\n                j++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // 2,3,4,5\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        int i = 0;\\n        int j = (nums.size() + 1) >> 1;\\n\\n        while (j < nums.size()) {\\n            if ((nums[i] << 1) <= nums[j]) {\\n                ans += 2;\\n                i++;\\n                j++;\\n            } else {\\n                j++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234148,
                "title": "python-solution-with-video-explanation",
                "content": "**Detailed Video Explanation**\\nhttps://youtu.be/H3YIq2lea7Y\\n\\n# Approach\\n- sort the array \\n- We can make at most n//2 pairs, its always better for i to pick the smallest available number and pair it with the smallest valid number at j (valid means 2 * nums[i] <= nums[j])\\n\\n# Complexity\\n- Time complexity: O(n log n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        count = 0\\n        i = 0\\n\\n        for j in range((n + 1)//2, n):\\n            if nums[j] >= 2*nums[i]: # (i, j) is a valid pair\\n                i += 1\\n                count += 2\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        count = 0\\n        i = 0\\n\\n        for j in range((n + 1)//2, n):\\n            if nums[j] >= 2*nums[i]: # (i, j) is a valid pair\\n                i += 1\\n                count += 2\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234070,
                "title": "c-solution-sort-two-pointerss",
                "content": "# Intuition\\nSort the array first, then cut the array into lower half and upper half, then use two pointers.\\n\\n# Complexity\\n- Time complexity:\\nO(N * log(N)) + O(N / 2) = O(N * log(N))\\n\\n- Space complexity:\\nO(1), there is no extra space used\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int size = nums.size();\\n        if(size == 1) return 0;\\n        sort(nums.begin(), nums.end());\\n        int pos1 = 0, pos2 = size / 2, res = 0;\\n        while(pos1 < size / 2 && pos2 < size){\\n            if(2 * nums[pos1] <= nums[pos2]){\\n                res += 2;\\n                pos1++;\\n            }\\n            pos2++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int size = nums.size();\\n        if(size == 1) return 0;\\n        sort(nums.begin(), nums.end());\\n        int pos1 = 0, pos2 = size / 2, res = 0;\\n        while(pos1 < size / 2 && pos2 < size){\\n            if(2 * nums[pos1] <= nums[pos2]){\\n                res += 2;\\n                pos1++;\\n            }\\n            pos2++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234045,
                "title": "two-pointers-sliding-window-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n* Order doesn\\'t matter, so sorting the array certainly helps. It\\'s size is not too large, so we have time to do so.\\n* After sorting, sliding window with 2 pointers seems like a good solution. Meaning we go through the array with 2 pointers, left and right, and mark pairs as we go.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n* Sort the array first\\n* Initialize the pointers: one at the beginning of the array, the other one at the middle. Why at the middle? Because we don\\'t want to pair indices at the beginning, and then end up with similar sized items at the end of the array.\\n* For each left index, increase the right index until it\\'s 2 times the size of the left one. When it is, mark them\\n* Don\\'t forget to skip the left index if it\\'s already marked as a right one.\\n* Finish when the right index reaches end of the array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n * log(n)), for sorting the array. Later part of the algorithm has O(n) complexity\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) because we add indices to the marked arrays.\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        if (nums.length < 2) {\\n            return 0;\\n        }\\n        Arrays.sort(nums);\\n        Set<Integer> marked = new HashSet<>();\\n        // get the pointer to the middle of the array\\n        int right = nums.length / 2;\\n        for (int left = 0; left < nums.length; left++) {\\n            // if we have already marked left index, as right\\n            if (!marked.contains(left)) {\\n                // increase right until it\\'s double the size of left, or until the end\\n                while (right < nums.length - 1 && nums[right] < nums[left] * 2) {\\n                    right++;\\n                }\\n                // check again if right is twice as big as left. It may not be so, if we stopped \\n                // increasing it because we reahed the end of the array.\\n                if (nums[right] >= nums[left] * 2) {\\n                    marked.add(left);\\n                    marked.add(right);\\n                    right++;\\n                }\\n                // if we reached the end of the array, that\\'s it, no more pairs to be found\\n                if (right == nums.length) {\\n                    break;\\n                }\\n            }\\n        }\\n        return marked.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        if (nums.length < 2) {\\n            return 0;\\n        }\\n        Arrays.sort(nums);\\n        Set<Integer> marked = new HashSet<>();\\n        // get the pointer to the middle of the array\\n        int right = nums.length / 2;\\n        for (int left = 0; left < nums.length; left++) {\\n            // if we have already marked left index, as right\\n            if (!marked.contains(left)) {\\n                // increase right until it\\'s double the size of left, or until the end\\n                while (right < nums.length - 1 && nums[right] < nums[left] * 2) {\\n                    right++;\\n                }\\n                // check again if right is twice as big as left. It may not be so, if we stopped \\n                // increasing it because we reahed the end of the array.\\n                if (nums[right] >= nums[left] * 2) {\\n                    marked.add(left);\\n                    marked.add(right);\\n                    right++;\\n                }\\n                // if we reached the end of the array, that\\'s it, no more pairs to be found\\n                if (right == nums.length) {\\n                    break;\\n                }\\n            }\\n        }\\n        return marked.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233949,
                "title": "javascript-solution-based-on-kreakemp-s-great-idea",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Based on the idea from leetcode solution\\n *\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxNumOfMarkedIndices = function (nums) {\\n  const LEN = nums.length;\\n  const HALFLEN = Math.floor(nums.length / 2 - 1);\\n  nums.sort((a, b) => a - b);\\n\\n  let ans = 0;\\n  let lo = HALFLEN;\\n  let hi = LEN - 1;\\n  while (lo >= 0 && hi > HALFLEN) {\\n    if (nums[hi] >= 2 * nums[lo]) {\\n      ans++;\\n      hi--;\\n    }\\n\\n    lo--;\\n  }\\n\\n  return ans * 2;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Based on the idea from leetcode solution\\n *\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxNumOfMarkedIndices = function (nums) {\\n  const LEN = nums.length;\\n  const HALFLEN = Math.floor(nums.length / 2 - 1);\\n  nums.sort((a, b) => a - b);\\n\\n  let ans = 0;\\n  let lo = HALFLEN;\\n  let hi = LEN - 1;\\n  while (lo >= 0 && hi > HALFLEN) {\\n    if (nums[hi] >= 2 * nums[lo]) {\\n      ans++;\\n      hi--;\\n    }\\n\\n    lo--;\\n  }\\n\\n  return ans * 2;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3233851,
                "title": "java-weekly-contest-334-two-pointers-beat-100-tc-o-n",
                "content": "# Approach\\n1. Try to use Two pointers to solve the issue. In order to use it, I need to have the array sorted. The sort part takes O(nlogn).\\n2. Two pointers, one points(j) to the largest number started from the end of the sorted array; another one(i) points to the most suitable solution that satisfies ```2 * nums[i] <= nums[j] ```\\n3. The best start index of i might be the middle of the array. However, if this number doesn\\'t satisfy ```2 * nums[i] <= nums[j] ```, we need to move it to the right until it finds the first index that works. \\n4. Once find the first i that works, try to go through the whole array and find all marked indices. \\n\\nPlease upvote if it makes sense. Thank you!\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) + O(n) = O(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int total = 0;\\n        int endIndex = nums.length - 1;\\n        int startIndex = endIndex;\\n        int midIndex = nums.length / 2 - 1 ;\\n        if (midIndex < 0)\\n            return 0;\\n        if (nums[midIndex] * 2 <= nums[endIndex])\\n            startIndex = midIndex;\\n        else {\\n            startIndex = midIndex;\\n            // FIND FIRST POSSIBLE INDEX\\n            while (startIndex >= 0 && nums[startIndex] * 2 > nums[endIndex]) {\\n                startIndex --;\\n            }\\n        }\\n\\n        if (startIndex == -1)\\n            return 0;\\n        int[] marked = new int[nums.length];\\n        while (startIndex >= 0) {\\n            if (marked[endIndex] == 1) {\\n                endIndex --;\\n            }\\n            else {\\n                // CASE 1 - MATCH\\n                if (nums[startIndex] * 2 <= nums[endIndex]) {\\n                    total += 2;\\n                    marked[startIndex] = 1;\\n                    marked[endIndex] = 1;\\n                    startIndex --;\\n                    endIndex --;\\n                }   \\n                // CASE 2 - BIGGER \\n                else {\\n                    startIndex --;\\n                }\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```2 * nums[i] <= nums[j] ```\n```2 * nums[i] <= nums[j] ```\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int total = 0;\\n        int endIndex = nums.length - 1;\\n        int startIndex = endIndex;\\n        int midIndex = nums.length / 2 - 1 ;\\n        if (midIndex < 0)\\n            return 0;\\n        if (nums[midIndex] * 2 <= nums[endIndex])\\n            startIndex = midIndex;\\n        else {\\n            startIndex = midIndex;\\n            // FIND FIRST POSSIBLE INDEX\\n            while (startIndex >= 0 && nums[startIndex] * 2 > nums[endIndex]) {\\n                startIndex --;\\n            }\\n        }\\n\\n        if (startIndex == -1)\\n            return 0;\\n        int[] marked = new int[nums.length];\\n        while (startIndex >= 0) {\\n            if (marked[endIndex] == 1) {\\n                endIndex --;\\n            }\\n            else {\\n                // CASE 1 - MATCH\\n                if (nums[startIndex] * 2 <= nums[endIndex]) {\\n                    total += 2;\\n                    marked[startIndex] = 1;\\n                    marked[endIndex] = 1;\\n                    startIndex --;\\n                    endIndex --;\\n                }   \\n                // CASE 2 - BIGGER \\n                else {\\n                    startIndex --;\\n                }\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233823,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int l=0,r=nums.size()/2;\\n        while(l<nums.size()/2&&r<nums.size()){\\n            if(2*nums[l]<=nums[r++])\\n            l++;\\n        }\\n        return 2*l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int l=0,r=nums.size()/2;\\n        while(l<nums.size()/2&&r<nums.size()){\\n            if(2*nums[l]<=nums[r++])\\n            l++;\\n        }\\n        return 2*l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233762,
                "title": "easy-to-understand-two-deques-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nLet\\'s take [2, 4, 5, 9] for example, we have two deques \\'small\\' and \\'large\\', let\\'s say we put 2 into small and 4 into large, now the two deques are:\\n\\nsmall [2]\\nlarge [4]\\n\\n2 in small and 4 in large are matched with each other, now let\\'s work on the next element which is 5, initially we place the 5 into small, since 2 and 4 are matched (used).\\n\\nsmall [2, 5]\\nlarge [4]\\n\\nThe greedy manipulation we can do here is to swap 5 with 4 which is the front of deque \\'large\\', and now we have \\n\\nsmall [2, 4]\\nlarge [5]\\n\\nsince 4 is smaller than 5, it has a better chance to get matched in the future.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nSort and process array elements one by one, if we can find a match in \\'small\\' for the current element, add it into \\'large\\', otherwise, we place the current element at the back of \\'large\\', and take out the front of \\'large\\' then append it to \\'small\\' (greedy intuition mentioned above). \\n\\nNotice that if \\'large\\' is empty, we can not use the greedy intuition, we have to append the current element to \\'small\\'. (an example would be arr = [5, 6, 7, 8, 9] in which max = 9 is smaller than 2 * min = 2 * 5 = 10)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n log n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        deque<int> small, large;\\n        int n = nums.size(), ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (small.empty() || nums[i] < 2 * nums[small.front()]) {\\n                if (large.empty()) small.push_back(i);\\n                else {\\n                    small.push_back(large.front());\\n                    large.pop_front();\\n                    large.push_back(i);\\n                }\\n            } else {\\n                small.pop_front();\\n                large.push_back(i);\\n                ans += 2;\\n            }\\n        }\\n        return ans;\\n        // or equivalently, return (int)(2 * large.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        deque<int> small, large;\\n        int n = nums.size(), ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (small.empty() || nums[i] < 2 * nums[small.front()]) {\\n                if (large.empty()) small.push_back(i);\\n                else {\\n                    small.push_back(large.front());\\n                    large.pop_front();\\n                    large.push_back(i);\\n                }\\n            } else {\\n                small.pop_front();\\n                large.push_back(i);\\n                ans += 2;\\n            }\\n        }\\n        return ans;\\n        // or equivalently, return (int)(2 * large.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233729,
                "title": "easy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n     //Step01 Sort Array for easy Answer\\n     Arrays.sort(nums);\\n     int n=0;\\n     int m = (nums.length+1)/2;\\n     int res=0;\\n     while(m<nums.length) {\\n         if(nums[n]*2 <= nums[m]){\\n            n++;\\n            res+=2;\\n         }\\n        m++;\\n     }    \\n     return res;\\n     //return n*2;\\n   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n     //Step01 Sort Array for easy Answer\\n     Arrays.sort(nums);\\n     int n=0;\\n     int m = (nums.length+1)/2;\\n     int res=0;\\n     while(m<nums.length) {\\n         if(nums[n]*2 <= nums[m]){\\n            n++;\\n            res+=2;\\n         }\\n        m++;\\n     }    \\n     return res;\\n     //return n*2;\\n   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233658,
                "title": "c-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe try to search minimum possible number that satisfy given condition.\\nTo output maximum marked index\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor this we use binary search to find the minimum possible number in the 2nd half of the sorted array. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int bs(int ind ,int v, vector<int>&vp,vector<int>&anss){\\n        \\n        int low = vp.size()/2, high = vp.size()-1 , ans = -1;\\n        \\n        while(low<=high){\\n            \\n            int mid = (low+high)/2;\\n            \\n            if(vp[mid]>=2*vp[ind]){\\n                if(anss[mid] == 0){\\n                 ans = mid;\\n                 high  = mid-1; \\n                }\\n                 else{\\n                low = mid+1;\\n            }\\n            \\n            }\\n            else{\\n                low = mid+1;\\n            }\\n            \\n        }\\n       \\n        return ans;\\n    }\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& v) {\\n        \\n        int n = v.size();\\n        int cnt = 0;\\n        \\n        sort(v.begin(),v.end());\\n        vector<int>ans(n,0);\\n        \\n        for(int i =0; i<n/2;i++){\\n            cout<<bs(i,v[i],v,ans)<<\"\\\\n\";\\n              if(bs(i,v[i],v,ans)!=-1){\\n                    ans[bs(i,v[i],v,ans)] = 1;\\n                    ans[i] = 1;\\n                  \\n              }\\n        }\\n        \\n        for(int i = 0; i<n; i++){\\n            cout<<ans[i]<<\" \";\\n            if(ans[i]==1){\\n                cnt++;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int bs(int ind ,int v, vector<int>&vp,vector<int>&anss){\\n        \\n        int low = vp.size()/2, high = vp.size()-1 , ans = -1;\\n        \\n        while(low<=high){\\n            \\n            int mid = (low+high)/2;\\n            \\n            if(vp[mid]>=2*vp[ind]){\\n                if(anss[mid] == 0){\\n                 ans = mid;\\n                 high  = mid-1; \\n                }\\n                 else{\\n                low = mid+1;\\n            }\\n            \\n            }\\n            else{\\n                low = mid+1;\\n            }\\n            \\n        }\\n       \\n        return ans;\\n    }\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& v) {\\n        \\n        int n = v.size();\\n        int cnt = 0;\\n        \\n        sort(v.begin(),v.end());\\n        vector<int>ans(n,0);\\n        \\n        for(int i =0; i<n/2;i++){\\n            cout<<bs(i,v[i],v,ans)<<\"\\\\n\";\\n              if(bs(i,v[i],v,ans)!=-1){\\n                    ans[bs(i,v[i],v,ans)] = 1;\\n                    ans[i] = 1;\\n                  \\n              }\\n        }\\n        \\n        for(int i = 0; i<n; i++){\\n            cout<<ans[i]<<\" \";\\n            if(ans[i]==1){\\n                cnt++;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3233588,
                "title": "easy-java-solution-two-pointer-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n       int i=0;\\n       int j=nums.length/2;\\n       while( i<=nums.length-1 && j<nums.length){\\n           if(nums[i]==-1){\\n               i++;\\n               continue;\\n           }\\n           if(nums[j]==-1){\\n               j++;\\n               continue;\\n           }\\n           int ch=2*nums[i];\\n           if(ch<=nums[j]){\\n               nums[i]=-1;\\n               nums[j]=-1;\\n               i++;\\n               j++;\\n           }else if(ch>nums[j]){\\n               j++;\\n           }\\n       }\\n       int count=0;\\n       for(int k=0; k<nums.length;k++){\\n           if(nums[k]==-1){\\n               count++;\\n           }\\n       }\\n       return count; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n       int i=0;\\n       int j=nums.length/2;\\n       while( i<=nums.length-1 && j<nums.length){\\n           if(nums[i]==-1){\\n               i++;\\n               continue;\\n           }\\n           if(nums[j]==-1){\\n               j++;\\n               continue;\\n           }\\n           int ch=2*nums[i];\\n           if(ch<=nums[j]){\\n               nums[i]=-1;\\n               nums[j]=-1;\\n               i++;\\n               j++;\\n           }else if(ch>nums[j]){\\n               j++;\\n           }\\n       }\\n       int count=0;\\n       for(int k=0; k<nums.length;k++){\\n           if(nums[k]==-1){\\n               count++;\\n           }\\n       }\\n       return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1814758,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The problem can be solved using a greedy approach. We need to mark pairs of indices in the array such that 2 * nums[i] <= nums[j], where i and j are unmarked indices. We want to mark as many pairs as possible, so we should try to mark the pairs that allow for the most remaining pairs to be marked.\\n\\nTo achieve this, we can first sort the array in non-decreasing order. We can then use two pointers, one starting from the beginning of the array and the other starting from the middle of the array (rounded up). We can then iterate over the array from the middle pointer to the end pointer. For each pair of indices (i, j) where i is the index pointed to by the beginning pointer and j is the index pointed to by the middle pointer, we check if 2 * nums[i] <= nums[j]. If this condition is true, we can mark the indices i and j, and move the beginning pointer to the next unmarked index. Otherwise, we move the middle pointer to the next index.\\n\\nWe continue this process until the middle pointer reaches the end of the array. The maximum number of marked indices is twice the value of the beginning pointer, since we mark pairs of indices."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Took me a while to get there as I was using binary search. I kept TLE as I was reslicing two arrays rather than using pointers. Once I realized that I could use pointers (and Pythons bisect method takes a start and stop pointer as optional args to its built in binary search method) I got it. Keep searching until the insert index for \"curr_largest//2\" is -1, indicating there is no existing number small enough. "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Help:-\\nhttps://leetcode.com/problems/find-the-maximum-number-of-marked-indices/solutions/3230953/javascript-code-with-approach/"
                    },
                    {
                        "username": "halfengineer",
                        "content": "testcase 50/68\\uD83D\\uDE29"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The hints point to a more complicated solution (i.e. bisection) than the greedy approach.\\nThey should be changed."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I mean, you can definitely do it with bisect. I did. "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Sorting with two pointers work well.\\nI expected more no of people to do this correct."
                    },
                    {
                        "username": "rohitjingar",
                        "content": "Firstly sort the array, and then you have to think about your maximum possible answer. I think this will help you to do this problem. "
                    },
                    {
                        "username": "surajsingh907668",
                        "content": "TC: O(nlogn)\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int index, sum = 0;\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            nums[i] *= 2;\\n        }\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            index = lower_bound(nums.begin()+nums.size()/2, nums.end(), nums[i]) - nums.begin();\\n            if(index != nums.size()) {\\n                sum += 2;\\n                nums[index] = -1;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Naga_Subramanian",
                        "content": "Don\\'t share solution in the discuss"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I have doubt regarding where to start loop in this problem.\\nI ran the code without starting the loop from `n-n/2` many times but I didn\\'t understand why this is happening. \\nWhy we should start loop from `n-n/2` instead of  `n/2`?\\nIf anybody know then please tell me"
                    },
                    {
                        "username": "subhash_27",
                        "content": "for max we have to pair the first (n/2) elements to pair that we have to check last (n/2) elements not the elements from (n/2)\\n"
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "Can anybody help why this approach is failing\n  \n\n     `int maxNumOfMarkedIndices(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int ans=0;\n        vector<bool> vis(nums.size(),0);\n        for(int i=0;i<nums.size();i++){\n            if(vis[i]) continue;\n            int z=lower_bound(nums.begin()+i+1,nums.end(),2*nums[i])-nums.begin();\n            while(z< nums.size() and vis[z]) z++;\n            if(z<nums.size() and  vis[z]==0) {\n                ans++;\n                vis[i]=1;\n                vis[z]=1;\n            }\n            \n        }\n        return ans*2;\n    } `"
                    },
                    {
                        "username": "Steinz",
                        "content": "Your Code doesn\\'t work for sample case 2, reason being:\\nwhile iterating at index i=0, the value of z is equal to 1 as 4>=2, and it is marked as visited, now for {5, 9}, no index can be found to satisfy the condition. The answer of your code is hence 2 as the only valid pair according to it is {2, 4}.\\nBut as mentioned in the explanation, the answer should be 4, with valid pairs being, {2, 5} and {4, 9} as both satisfy the condition."
                    },
                    {
                        "username": "coder42032",
                        "content": "same thing with my code i also write this type of code but it is not working on testcase 10."
                    }
                ]
            },
            {
                "id": 1821469,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The problem can be solved using a greedy approach. We need to mark pairs of indices in the array such that 2 * nums[i] <= nums[j], where i and j are unmarked indices. We want to mark as many pairs as possible, so we should try to mark the pairs that allow for the most remaining pairs to be marked.\\n\\nTo achieve this, we can first sort the array in non-decreasing order. We can then use two pointers, one starting from the beginning of the array and the other starting from the middle of the array (rounded up). We can then iterate over the array from the middle pointer to the end pointer. For each pair of indices (i, j) where i is the index pointed to by the beginning pointer and j is the index pointed to by the middle pointer, we check if 2 * nums[i] <= nums[j]. If this condition is true, we can mark the indices i and j, and move the beginning pointer to the next unmarked index. Otherwise, we move the middle pointer to the next index.\\n\\nWe continue this process until the middle pointer reaches the end of the array. The maximum number of marked indices is twice the value of the beginning pointer, since we mark pairs of indices."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Took me a while to get there as I was using binary search. I kept TLE as I was reslicing two arrays rather than using pointers. Once I realized that I could use pointers (and Pythons bisect method takes a start and stop pointer as optional args to its built in binary search method) I got it. Keep searching until the insert index for \"curr_largest//2\" is -1, indicating there is no existing number small enough. "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Help:-\\nhttps://leetcode.com/problems/find-the-maximum-number-of-marked-indices/solutions/3230953/javascript-code-with-approach/"
                    },
                    {
                        "username": "halfengineer",
                        "content": "testcase 50/68\\uD83D\\uDE29"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The hints point to a more complicated solution (i.e. bisection) than the greedy approach.\\nThey should be changed."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I mean, you can definitely do it with bisect. I did. "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Sorting with two pointers work well.\\nI expected more no of people to do this correct."
                    },
                    {
                        "username": "rohitjingar",
                        "content": "Firstly sort the array, and then you have to think about your maximum possible answer. I think this will help you to do this problem. "
                    },
                    {
                        "username": "surajsingh907668",
                        "content": "TC: O(nlogn)\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int index, sum = 0;\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            nums[i] *= 2;\\n        }\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            index = lower_bound(nums.begin()+nums.size()/2, nums.end(), nums[i]) - nums.begin();\\n            if(index != nums.size()) {\\n                sum += 2;\\n                nums[index] = -1;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Naga_Subramanian",
                        "content": "Don\\'t share solution in the discuss"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I have doubt regarding where to start loop in this problem.\\nI ran the code without starting the loop from `n-n/2` many times but I didn\\'t understand why this is happening. \\nWhy we should start loop from `n-n/2` instead of  `n/2`?\\nIf anybody know then please tell me"
                    },
                    {
                        "username": "subhash_27",
                        "content": "for max we have to pair the first (n/2) elements to pair that we have to check last (n/2) elements not the elements from (n/2)\\n"
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "Can anybody help why this approach is failing\n  \n\n     `int maxNumOfMarkedIndices(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int ans=0;\n        vector<bool> vis(nums.size(),0);\n        for(int i=0;i<nums.size();i++){\n            if(vis[i]) continue;\n            int z=lower_bound(nums.begin()+i+1,nums.end(),2*nums[i])-nums.begin();\n            while(z< nums.size() and vis[z]) z++;\n            if(z<nums.size() and  vis[z]==0) {\n                ans++;\n                vis[i]=1;\n                vis[z]=1;\n            }\n            \n        }\n        return ans*2;\n    } `"
                    },
                    {
                        "username": "Steinz",
                        "content": "Your Code doesn\\'t work for sample case 2, reason being:\\nwhile iterating at index i=0, the value of z is equal to 1 as 4>=2, and it is marked as visited, now for {5, 9}, no index can be found to satisfy the condition. The answer of your code is hence 2 as the only valid pair according to it is {2, 4}.\\nBut as mentioned in the explanation, the answer should be 4, with valid pairs being, {2, 5} and {4, 9} as both satisfy the condition."
                    },
                    {
                        "username": "coder42032",
                        "content": "same thing with my code i also write this type of code but it is not working on testcase 10."
                    }
                ]
            },
            {
                "id": 1817331,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The problem can be solved using a greedy approach. We need to mark pairs of indices in the array such that 2 * nums[i] <= nums[j], where i and j are unmarked indices. We want to mark as many pairs as possible, so we should try to mark the pairs that allow for the most remaining pairs to be marked.\\n\\nTo achieve this, we can first sort the array in non-decreasing order. We can then use two pointers, one starting from the beginning of the array and the other starting from the middle of the array (rounded up). We can then iterate over the array from the middle pointer to the end pointer. For each pair of indices (i, j) where i is the index pointed to by the beginning pointer and j is the index pointed to by the middle pointer, we check if 2 * nums[i] <= nums[j]. If this condition is true, we can mark the indices i and j, and move the beginning pointer to the next unmarked index. Otherwise, we move the middle pointer to the next index.\\n\\nWe continue this process until the middle pointer reaches the end of the array. The maximum number of marked indices is twice the value of the beginning pointer, since we mark pairs of indices."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Took me a while to get there as I was using binary search. I kept TLE as I was reslicing two arrays rather than using pointers. Once I realized that I could use pointers (and Pythons bisect method takes a start and stop pointer as optional args to its built in binary search method) I got it. Keep searching until the insert index for \"curr_largest//2\" is -1, indicating there is no existing number small enough. "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Help:-\\nhttps://leetcode.com/problems/find-the-maximum-number-of-marked-indices/solutions/3230953/javascript-code-with-approach/"
                    },
                    {
                        "username": "halfengineer",
                        "content": "testcase 50/68\\uD83D\\uDE29"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The hints point to a more complicated solution (i.e. bisection) than the greedy approach.\\nThey should be changed."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I mean, you can definitely do it with bisect. I did. "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Sorting with two pointers work well.\\nI expected more no of people to do this correct."
                    },
                    {
                        "username": "rohitjingar",
                        "content": "Firstly sort the array, and then you have to think about your maximum possible answer. I think this will help you to do this problem. "
                    },
                    {
                        "username": "surajsingh907668",
                        "content": "TC: O(nlogn)\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int index, sum = 0;\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            nums[i] *= 2;\\n        }\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            index = lower_bound(nums.begin()+nums.size()/2, nums.end(), nums[i]) - nums.begin();\\n            if(index != nums.size()) {\\n                sum += 2;\\n                nums[index] = -1;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Naga_Subramanian",
                        "content": "Don\\'t share solution in the discuss"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I have doubt regarding where to start loop in this problem.\\nI ran the code without starting the loop from `n-n/2` many times but I didn\\'t understand why this is happening. \\nWhy we should start loop from `n-n/2` instead of  `n/2`?\\nIf anybody know then please tell me"
                    },
                    {
                        "username": "subhash_27",
                        "content": "for max we have to pair the first (n/2) elements to pair that we have to check last (n/2) elements not the elements from (n/2)\\n"
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "Can anybody help why this approach is failing\n  \n\n     `int maxNumOfMarkedIndices(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int ans=0;\n        vector<bool> vis(nums.size(),0);\n        for(int i=0;i<nums.size();i++){\n            if(vis[i]) continue;\n            int z=lower_bound(nums.begin()+i+1,nums.end(),2*nums[i])-nums.begin();\n            while(z< nums.size() and vis[z]) z++;\n            if(z<nums.size() and  vis[z]==0) {\n                ans++;\n                vis[i]=1;\n                vis[z]=1;\n            }\n            \n        }\n        return ans*2;\n    } `"
                    },
                    {
                        "username": "Steinz",
                        "content": "Your Code doesn\\'t work for sample case 2, reason being:\\nwhile iterating at index i=0, the value of z is equal to 1 as 4>=2, and it is marked as visited, now for {5, 9}, no index can be found to satisfy the condition. The answer of your code is hence 2 as the only valid pair according to it is {2, 4}.\\nBut as mentioned in the explanation, the answer should be 4, with valid pairs being, {2, 5} and {4, 9} as both satisfy the condition."
                    },
                    {
                        "username": "coder42032",
                        "content": "same thing with my code i also write this type of code but it is not working on testcase 10."
                    }
                ]
            },
            {
                "id": 1814725,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The problem can be solved using a greedy approach. We need to mark pairs of indices in the array such that 2 * nums[i] <= nums[j], where i and j are unmarked indices. We want to mark as many pairs as possible, so we should try to mark the pairs that allow for the most remaining pairs to be marked.\\n\\nTo achieve this, we can first sort the array in non-decreasing order. We can then use two pointers, one starting from the beginning of the array and the other starting from the middle of the array (rounded up). We can then iterate over the array from the middle pointer to the end pointer. For each pair of indices (i, j) where i is the index pointed to by the beginning pointer and j is the index pointed to by the middle pointer, we check if 2 * nums[i] <= nums[j]. If this condition is true, we can mark the indices i and j, and move the beginning pointer to the next unmarked index. Otherwise, we move the middle pointer to the next index.\\n\\nWe continue this process until the middle pointer reaches the end of the array. The maximum number of marked indices is twice the value of the beginning pointer, since we mark pairs of indices."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Took me a while to get there as I was using binary search. I kept TLE as I was reslicing two arrays rather than using pointers. Once I realized that I could use pointers (and Pythons bisect method takes a start and stop pointer as optional args to its built in binary search method) I got it. Keep searching until the insert index for \"curr_largest//2\" is -1, indicating there is no existing number small enough. "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Help:-\\nhttps://leetcode.com/problems/find-the-maximum-number-of-marked-indices/solutions/3230953/javascript-code-with-approach/"
                    },
                    {
                        "username": "halfengineer",
                        "content": "testcase 50/68\\uD83D\\uDE29"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The hints point to a more complicated solution (i.e. bisection) than the greedy approach.\\nThey should be changed."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I mean, you can definitely do it with bisect. I did. "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Sorting with two pointers work well.\\nI expected more no of people to do this correct."
                    },
                    {
                        "username": "rohitjingar",
                        "content": "Firstly sort the array, and then you have to think about your maximum possible answer. I think this will help you to do this problem. "
                    },
                    {
                        "username": "surajsingh907668",
                        "content": "TC: O(nlogn)\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int index, sum = 0;\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            nums[i] *= 2;\\n        }\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            index = lower_bound(nums.begin()+nums.size()/2, nums.end(), nums[i]) - nums.begin();\\n            if(index != nums.size()) {\\n                sum += 2;\\n                nums[index] = -1;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Naga_Subramanian",
                        "content": "Don\\'t share solution in the discuss"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I have doubt regarding where to start loop in this problem.\\nI ran the code without starting the loop from `n-n/2` many times but I didn\\'t understand why this is happening. \\nWhy we should start loop from `n-n/2` instead of  `n/2`?\\nIf anybody know then please tell me"
                    },
                    {
                        "username": "subhash_27",
                        "content": "for max we have to pair the first (n/2) elements to pair that we have to check last (n/2) elements not the elements from (n/2)\\n"
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "Can anybody help why this approach is failing\n  \n\n     `int maxNumOfMarkedIndices(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int ans=0;\n        vector<bool> vis(nums.size(),0);\n        for(int i=0;i<nums.size();i++){\n            if(vis[i]) continue;\n            int z=lower_bound(nums.begin()+i+1,nums.end(),2*nums[i])-nums.begin();\n            while(z< nums.size() and vis[z]) z++;\n            if(z<nums.size() and  vis[z]==0) {\n                ans++;\n                vis[i]=1;\n                vis[z]=1;\n            }\n            \n        }\n        return ans*2;\n    } `"
                    },
                    {
                        "username": "Steinz",
                        "content": "Your Code doesn\\'t work for sample case 2, reason being:\\nwhile iterating at index i=0, the value of z is equal to 1 as 4>=2, and it is marked as visited, now for {5, 9}, no index can be found to satisfy the condition. The answer of your code is hence 2 as the only valid pair according to it is {2, 4}.\\nBut as mentioned in the explanation, the answer should be 4, with valid pairs being, {2, 5} and {4, 9} as both satisfy the condition."
                    },
                    {
                        "username": "coder42032",
                        "content": "same thing with my code i also write this type of code but it is not working on testcase 10."
                    }
                ]
            },
            {
                "id": 1846460,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The problem can be solved using a greedy approach. We need to mark pairs of indices in the array such that 2 * nums[i] <= nums[j], where i and j are unmarked indices. We want to mark as many pairs as possible, so we should try to mark the pairs that allow for the most remaining pairs to be marked.\\n\\nTo achieve this, we can first sort the array in non-decreasing order. We can then use two pointers, one starting from the beginning of the array and the other starting from the middle of the array (rounded up). We can then iterate over the array from the middle pointer to the end pointer. For each pair of indices (i, j) where i is the index pointed to by the beginning pointer and j is the index pointed to by the middle pointer, we check if 2 * nums[i] <= nums[j]. If this condition is true, we can mark the indices i and j, and move the beginning pointer to the next unmarked index. Otherwise, we move the middle pointer to the next index.\\n\\nWe continue this process until the middle pointer reaches the end of the array. The maximum number of marked indices is twice the value of the beginning pointer, since we mark pairs of indices."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Took me a while to get there as I was using binary search. I kept TLE as I was reslicing two arrays rather than using pointers. Once I realized that I could use pointers (and Pythons bisect method takes a start and stop pointer as optional args to its built in binary search method) I got it. Keep searching until the insert index for \"curr_largest//2\" is -1, indicating there is no existing number small enough. "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Help:-\\nhttps://leetcode.com/problems/find-the-maximum-number-of-marked-indices/solutions/3230953/javascript-code-with-approach/"
                    },
                    {
                        "username": "halfengineer",
                        "content": "testcase 50/68\\uD83D\\uDE29"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The hints point to a more complicated solution (i.e. bisection) than the greedy approach.\\nThey should be changed."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I mean, you can definitely do it with bisect. I did. "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Sorting with two pointers work well.\\nI expected more no of people to do this correct."
                    },
                    {
                        "username": "rohitjingar",
                        "content": "Firstly sort the array, and then you have to think about your maximum possible answer. I think this will help you to do this problem. "
                    },
                    {
                        "username": "surajsingh907668",
                        "content": "TC: O(nlogn)\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int index, sum = 0;\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            nums[i] *= 2;\\n        }\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            index = lower_bound(nums.begin()+nums.size()/2, nums.end(), nums[i]) - nums.begin();\\n            if(index != nums.size()) {\\n                sum += 2;\\n                nums[index] = -1;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Naga_Subramanian",
                        "content": "Don\\'t share solution in the discuss"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I have doubt regarding where to start loop in this problem.\\nI ran the code without starting the loop from `n-n/2` many times but I didn\\'t understand why this is happening. \\nWhy we should start loop from `n-n/2` instead of  `n/2`?\\nIf anybody know then please tell me"
                    },
                    {
                        "username": "subhash_27",
                        "content": "for max we have to pair the first (n/2) elements to pair that we have to check last (n/2) elements not the elements from (n/2)\\n"
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "Can anybody help why this approach is failing\n  \n\n     `int maxNumOfMarkedIndices(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int ans=0;\n        vector<bool> vis(nums.size(),0);\n        for(int i=0;i<nums.size();i++){\n            if(vis[i]) continue;\n            int z=lower_bound(nums.begin()+i+1,nums.end(),2*nums[i])-nums.begin();\n            while(z< nums.size() and vis[z]) z++;\n            if(z<nums.size() and  vis[z]==0) {\n                ans++;\n                vis[i]=1;\n                vis[z]=1;\n            }\n            \n        }\n        return ans*2;\n    } `"
                    },
                    {
                        "username": "Steinz",
                        "content": "Your Code doesn\\'t work for sample case 2, reason being:\\nwhile iterating at index i=0, the value of z is equal to 1 as 4>=2, and it is marked as visited, now for {5, 9}, no index can be found to satisfy the condition. The answer of your code is hence 2 as the only valid pair according to it is {2, 4}.\\nBut as mentioned in the explanation, the answer should be 4, with valid pairs being, {2, 5} and {4, 9} as both satisfy the condition."
                    },
                    {
                        "username": "coder42032",
                        "content": "same thing with my code i also write this type of code but it is not working on testcase 10."
                    }
                ]
            },
            {
                "id": 1839253,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The problem can be solved using a greedy approach. We need to mark pairs of indices in the array such that 2 * nums[i] <= nums[j], where i and j are unmarked indices. We want to mark as many pairs as possible, so we should try to mark the pairs that allow for the most remaining pairs to be marked.\\n\\nTo achieve this, we can first sort the array in non-decreasing order. We can then use two pointers, one starting from the beginning of the array and the other starting from the middle of the array (rounded up). We can then iterate over the array from the middle pointer to the end pointer. For each pair of indices (i, j) where i is the index pointed to by the beginning pointer and j is the index pointed to by the middle pointer, we check if 2 * nums[i] <= nums[j]. If this condition is true, we can mark the indices i and j, and move the beginning pointer to the next unmarked index. Otherwise, we move the middle pointer to the next index.\\n\\nWe continue this process until the middle pointer reaches the end of the array. The maximum number of marked indices is twice the value of the beginning pointer, since we mark pairs of indices."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Took me a while to get there as I was using binary search. I kept TLE as I was reslicing two arrays rather than using pointers. Once I realized that I could use pointers (and Pythons bisect method takes a start and stop pointer as optional args to its built in binary search method) I got it. Keep searching until the insert index for \"curr_largest//2\" is -1, indicating there is no existing number small enough. "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Help:-\\nhttps://leetcode.com/problems/find-the-maximum-number-of-marked-indices/solutions/3230953/javascript-code-with-approach/"
                    },
                    {
                        "username": "halfengineer",
                        "content": "testcase 50/68\\uD83D\\uDE29"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The hints point to a more complicated solution (i.e. bisection) than the greedy approach.\\nThey should be changed."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I mean, you can definitely do it with bisect. I did. "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Sorting with two pointers work well.\\nI expected more no of people to do this correct."
                    },
                    {
                        "username": "rohitjingar",
                        "content": "Firstly sort the array, and then you have to think about your maximum possible answer. I think this will help you to do this problem. "
                    },
                    {
                        "username": "surajsingh907668",
                        "content": "TC: O(nlogn)\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int index, sum = 0;\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            nums[i] *= 2;\\n        }\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            index = lower_bound(nums.begin()+nums.size()/2, nums.end(), nums[i]) - nums.begin();\\n            if(index != nums.size()) {\\n                sum += 2;\\n                nums[index] = -1;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Naga_Subramanian",
                        "content": "Don\\'t share solution in the discuss"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I have doubt regarding where to start loop in this problem.\\nI ran the code without starting the loop from `n-n/2` many times but I didn\\'t understand why this is happening. \\nWhy we should start loop from `n-n/2` instead of  `n/2`?\\nIf anybody know then please tell me"
                    },
                    {
                        "username": "subhash_27",
                        "content": "for max we have to pair the first (n/2) elements to pair that we have to check last (n/2) elements not the elements from (n/2)\\n"
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "Can anybody help why this approach is failing\n  \n\n     `int maxNumOfMarkedIndices(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int ans=0;\n        vector<bool> vis(nums.size(),0);\n        for(int i=0;i<nums.size();i++){\n            if(vis[i]) continue;\n            int z=lower_bound(nums.begin()+i+1,nums.end(),2*nums[i])-nums.begin();\n            while(z< nums.size() and vis[z]) z++;\n            if(z<nums.size() and  vis[z]==0) {\n                ans++;\n                vis[i]=1;\n                vis[z]=1;\n            }\n            \n        }\n        return ans*2;\n    } `"
                    },
                    {
                        "username": "Steinz",
                        "content": "Your Code doesn\\'t work for sample case 2, reason being:\\nwhile iterating at index i=0, the value of z is equal to 1 as 4>=2, and it is marked as visited, now for {5, 9}, no index can be found to satisfy the condition. The answer of your code is hence 2 as the only valid pair according to it is {2, 4}.\\nBut as mentioned in the explanation, the answer should be 4, with valid pairs being, {2, 5} and {4, 9} as both satisfy the condition."
                    },
                    {
                        "username": "coder42032",
                        "content": "same thing with my code i also write this type of code but it is not working on testcase 10."
                    }
                ]
            },
            {
                "id": 1816049,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The problem can be solved using a greedy approach. We need to mark pairs of indices in the array such that 2 * nums[i] <= nums[j], where i and j are unmarked indices. We want to mark as many pairs as possible, so we should try to mark the pairs that allow for the most remaining pairs to be marked.\\n\\nTo achieve this, we can first sort the array in non-decreasing order. We can then use two pointers, one starting from the beginning of the array and the other starting from the middle of the array (rounded up). We can then iterate over the array from the middle pointer to the end pointer. For each pair of indices (i, j) where i is the index pointed to by the beginning pointer and j is the index pointed to by the middle pointer, we check if 2 * nums[i] <= nums[j]. If this condition is true, we can mark the indices i and j, and move the beginning pointer to the next unmarked index. Otherwise, we move the middle pointer to the next index.\\n\\nWe continue this process until the middle pointer reaches the end of the array. The maximum number of marked indices is twice the value of the beginning pointer, since we mark pairs of indices."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Took me a while to get there as I was using binary search. I kept TLE as I was reslicing two arrays rather than using pointers. Once I realized that I could use pointers (and Pythons bisect method takes a start and stop pointer as optional args to its built in binary search method) I got it. Keep searching until the insert index for \"curr_largest//2\" is -1, indicating there is no existing number small enough. "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Help:-\\nhttps://leetcode.com/problems/find-the-maximum-number-of-marked-indices/solutions/3230953/javascript-code-with-approach/"
                    },
                    {
                        "username": "halfengineer",
                        "content": "testcase 50/68\\uD83D\\uDE29"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The hints point to a more complicated solution (i.e. bisection) than the greedy approach.\\nThey should be changed."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I mean, you can definitely do it with bisect. I did. "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Sorting with two pointers work well.\\nI expected more no of people to do this correct."
                    },
                    {
                        "username": "rohitjingar",
                        "content": "Firstly sort the array, and then you have to think about your maximum possible answer. I think this will help you to do this problem. "
                    },
                    {
                        "username": "surajsingh907668",
                        "content": "TC: O(nlogn)\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int index, sum = 0;\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            nums[i] *= 2;\\n        }\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            index = lower_bound(nums.begin()+nums.size()/2, nums.end(), nums[i]) - nums.begin();\\n            if(index != nums.size()) {\\n                sum += 2;\\n                nums[index] = -1;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Naga_Subramanian",
                        "content": "Don\\'t share solution in the discuss"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I have doubt regarding where to start loop in this problem.\\nI ran the code without starting the loop from `n-n/2` many times but I didn\\'t understand why this is happening. \\nWhy we should start loop from `n-n/2` instead of  `n/2`?\\nIf anybody know then please tell me"
                    },
                    {
                        "username": "subhash_27",
                        "content": "for max we have to pair the first (n/2) elements to pair that we have to check last (n/2) elements not the elements from (n/2)\\n"
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "Can anybody help why this approach is failing\n  \n\n     `int maxNumOfMarkedIndices(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int ans=0;\n        vector<bool> vis(nums.size(),0);\n        for(int i=0;i<nums.size();i++){\n            if(vis[i]) continue;\n            int z=lower_bound(nums.begin()+i+1,nums.end(),2*nums[i])-nums.begin();\n            while(z< nums.size() and vis[z]) z++;\n            if(z<nums.size() and  vis[z]==0) {\n                ans++;\n                vis[i]=1;\n                vis[z]=1;\n            }\n            \n        }\n        return ans*2;\n    } `"
                    },
                    {
                        "username": "Steinz",
                        "content": "Your Code doesn\\'t work for sample case 2, reason being:\\nwhile iterating at index i=0, the value of z is equal to 1 as 4>=2, and it is marked as visited, now for {5, 9}, no index can be found to satisfy the condition. The answer of your code is hence 2 as the only valid pair according to it is {2, 4}.\\nBut as mentioned in the explanation, the answer should be 4, with valid pairs being, {2, 5} and {4, 9} as both satisfy the condition."
                    },
                    {
                        "username": "coder42032",
                        "content": "same thing with my code i also write this type of code but it is not working on testcase 10."
                    }
                ]
            },
            {
                "id": 1815293,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The problem can be solved using a greedy approach. We need to mark pairs of indices in the array such that 2 * nums[i] <= nums[j], where i and j are unmarked indices. We want to mark as many pairs as possible, so we should try to mark the pairs that allow for the most remaining pairs to be marked.\\n\\nTo achieve this, we can first sort the array in non-decreasing order. We can then use two pointers, one starting from the beginning of the array and the other starting from the middle of the array (rounded up). We can then iterate over the array from the middle pointer to the end pointer. For each pair of indices (i, j) where i is the index pointed to by the beginning pointer and j is the index pointed to by the middle pointer, we check if 2 * nums[i] <= nums[j]. If this condition is true, we can mark the indices i and j, and move the beginning pointer to the next unmarked index. Otherwise, we move the middle pointer to the next index.\\n\\nWe continue this process until the middle pointer reaches the end of the array. The maximum number of marked indices is twice the value of the beginning pointer, since we mark pairs of indices."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Took me a while to get there as I was using binary search. I kept TLE as I was reslicing two arrays rather than using pointers. Once I realized that I could use pointers (and Pythons bisect method takes a start and stop pointer as optional args to its built in binary search method) I got it. Keep searching until the insert index for \"curr_largest//2\" is -1, indicating there is no existing number small enough. "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Help:-\\nhttps://leetcode.com/problems/find-the-maximum-number-of-marked-indices/solutions/3230953/javascript-code-with-approach/"
                    },
                    {
                        "username": "halfengineer",
                        "content": "testcase 50/68\\uD83D\\uDE29"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The hints point to a more complicated solution (i.e. bisection) than the greedy approach.\\nThey should be changed."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I mean, you can definitely do it with bisect. I did. "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Sorting with two pointers work well.\\nI expected more no of people to do this correct."
                    },
                    {
                        "username": "rohitjingar",
                        "content": "Firstly sort the array, and then you have to think about your maximum possible answer. I think this will help you to do this problem. "
                    },
                    {
                        "username": "surajsingh907668",
                        "content": "TC: O(nlogn)\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int index, sum = 0;\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            nums[i] *= 2;\\n        }\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            index = lower_bound(nums.begin()+nums.size()/2, nums.end(), nums[i]) - nums.begin();\\n            if(index != nums.size()) {\\n                sum += 2;\\n                nums[index] = -1;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Naga_Subramanian",
                        "content": "Don\\'t share solution in the discuss"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I have doubt regarding where to start loop in this problem.\\nI ran the code without starting the loop from `n-n/2` many times but I didn\\'t understand why this is happening. \\nWhy we should start loop from `n-n/2` instead of  `n/2`?\\nIf anybody know then please tell me"
                    },
                    {
                        "username": "subhash_27",
                        "content": "for max we have to pair the first (n/2) elements to pair that we have to check last (n/2) elements not the elements from (n/2)\\n"
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "Can anybody help why this approach is failing\n  \n\n     `int maxNumOfMarkedIndices(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int ans=0;\n        vector<bool> vis(nums.size(),0);\n        for(int i=0;i<nums.size();i++){\n            if(vis[i]) continue;\n            int z=lower_bound(nums.begin()+i+1,nums.end(),2*nums[i])-nums.begin();\n            while(z< nums.size() and vis[z]) z++;\n            if(z<nums.size() and  vis[z]==0) {\n                ans++;\n                vis[i]=1;\n                vis[z]=1;\n            }\n            \n        }\n        return ans*2;\n    } `"
                    },
                    {
                        "username": "Steinz",
                        "content": "Your Code doesn\\'t work for sample case 2, reason being:\\nwhile iterating at index i=0, the value of z is equal to 1 as 4>=2, and it is marked as visited, now for {5, 9}, no index can be found to satisfy the condition. The answer of your code is hence 2 as the only valid pair according to it is {2, 4}.\\nBut as mentioned in the explanation, the answer should be 4, with valid pairs being, {2, 5} and {4, 9} as both satisfy the condition."
                    },
                    {
                        "username": "coder42032",
                        "content": "same thing with my code i also write this type of code but it is not working on testcase 10."
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Time to Visit a Cell In a Grid",
        "question_content": "<p>You are given a <code>m x n</code> matrix <code>grid</code> consisting of <b>non-negative</b> integers where <code>grid[row][col]</code> represents the <strong>minimum</strong> time required to be able to visit the cell <code>(row, col)</code>, which means you can visit the cell <code>(row, col)</code> only when the time you visit it is greater than or equal to <code>grid[row][col]</code>.</p>\n\n<p>You are standing in the <strong>top-left</strong> cell of the matrix in the <code>0<sup>th</sup></code> second, and you must move to <strong>any</strong> adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.</p>\n\n<p>Return <em>the <strong>minimum</strong> time required in which you can visit the bottom-right cell of the matrix</em>. If you cannot visit the bottom-right cell, then return <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-8.png\" /></p>\n\n<pre>\n<strong>Input:</strong> grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> One of the paths that we can take is the following:\n- at t = 0, we are on the cell (0,0).\n- at t = 1, we move to the cell (0,1). It is possible because grid[0][1] &lt;= 1.\n- at t = 2, we move to the cell (1,1). It is possible because grid[1][1] &lt;= 2.\n- at t = 3, we move to the cell (1,2). It is possible because grid[1][2] &lt;= 3.\n- at t = 4, we move to the cell (1,1). It is possible because grid[1][1] &lt;= 4.\n- at t = 5, we move to the cell (1,2). It is possible because grid[1][2] &lt;= 5.\n- at t = 6, we move to the cell (1,3). It is possible because grid[1][3] &lt;= 6.\n- at t = 7, we move to the cell (2,3). It is possible because grid[2][3] &lt;= 7.\nThe final time is 7. It can be shown that it is the minimum time possible.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-9.png\" style=\"width: 151px; height: 151px;\" /></p>\n\n<pre>\n<strong>Input:</strong> grid = [[0,2,4],[3,2,1],[1,0,4]]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> There is no path from the top left to the bottom-right cell.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>2 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>grid[0][0] == 0</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<style type=\"text/css\">.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; \n}\n.spoiler {overflow:hidden;}\n.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}\n.spoilerbutton[value=\"Show Message\"] + .spoiler > div {margin-top:-500%;}\n.spoilerbutton[value=\"Hide Message\"] + .spoiler {padding:5px;}\n</style>\n",
        "solutions": [
            {
                "id": 3230800,
                "title": "c-java-python-ping-pong-dijkstra",
                "content": "\\n# Intuition\\nWe want to find minimum time to reach bottom right cell. We\\'ll have to traverse the matrix as the time in each cell allows. We can use a priority queue to keep track of time.\\nSome things to keep in mind:\\n1. If we can not move to the neighboring cells from starting position we can not move anywhere in the matrix hence answer is -1. \\n2. But if we can move to the neighboring cells from starting position, we can move anywhere in the matrix. We can wait by playing \"ping pong\" between previous cell and current cell till a neighboring cell opens up.\\n\\n\\n# Approach\\n* If `grid[0][1] > 1 and grid[1][0] > 1` we can not move anywhere from cell `grid[0][0]` hence answer is `-1`\\n* Use priority queue to find next cell with minimum time to move to it\\n* If time for a neighbor (target) cell is > 1 + time for current cell. We can not directly move to target cell. We will have to \"ping pong\" between previous cell and current cell. When playing ping pong between previous and current cell there can be two cases. \\n    * Let\\'s say time for target cell is 4 and current time is 2, difference = 2 (even).\\n        * Move to prev cell, time = 3\\n        * Move to curr cell, time = 4\\n        * Move to target cell, time = 5. \\n        * Hence we reach target cell with time: **target cell time + 1** when difference between target cell time and curr cell time is even.\\n    * Let\\'s say time for target cell is 5 and current time is 2, difference = 3 (odd).\\n        * Move to prev cell, time = 3\\n        * Move to curr cell, time = 4\\n        * Move to target cell, time = 5. \\n        * Hence we reach target cell with time: target cell time when difference between target cell time and curr cell time is odd.\\n    * This \"ping pong\" is captured in the `wait` variable in the code\\n\\n\\n# Complexity\\n- Time complexity: `O(mnlog(mn))`\\n\\n- Space complexity: `O(mn)`\\n\\n# Code\\n**Python3**:\\n```\\ndef minimumTime(self, grid: List[List[int]]) -> int:\\n    if grid[0][1] > 1 and grid[1][0] > 1: return -1\\n    m, n = len(grid), len(grid[0])\\n    visited = set()\\n    pq = [(grid[0][0], 0, 0)]\\n    \\n    while pq:\\n        time, row, col = heappop(pq)\\n        if row == m-1 and col == n-1: return time\\n        if (row, col) in visited: continue\\n        visited.add((row, col))\\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n            r, c = row + dr, col + dc\\n            if 0 <= r < m and 0 <= c < n and (r, c) not in visited:\\n                wait = 1 if ((grid[r][c] - time) % 2 == 0) else 0\\n                heappush(pq, (max(time + 1, grid[r][c] + wait), r, c))\\n```\\n\\n**C++**\\n```\\nint minimumTime(vector<vector<int>>& grid) {\\n    // Check if the starting points are blocked\\n    if (grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n    \\n    int m = grid.size(), n = grid[0].size();\\n    vector<vector<int>> dirs{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    vector<vector<bool>> visited(m, vector<bool>(n, false));\\n    priority_queue<vector<int>, vector<vector<int>>, greater<>> pq;\\n    \\n    pq.push({grid[0][0], 0, 0}); // Start at top-left corner\\n    while (!pq.empty()) {\\n        // Get the current time, row, and column\\n        int time = pq.top()[0], row = pq.top()[1], col = pq.top()[2];\\n        pq.pop();\\n        \\n        // Check if we\\'ve reached the bottom-right corner\\n        if (row == m - 1 && col == n - 1) return time;\\n        \\n        // Mark the current cell as visited\\n        if (visited[row][col]) continue;\\n        visited[row][col] = true;\\n        \\n        // Explore the neighboring cells\\n        for (auto dr: dirs) {\\n            int r = row + dr[0], c = col + dr[1];\\n            if (r < 0 || r >= m || c < 0 || c >= n || visited[r][c]) continue;\\n            \\n            // Calculate the time required to reach the neighboring cell\\n            int wait = (grid[r][c] - time) % 2 == 0;\\n            pq.push({max(grid[r][c] + wait, time + 1), r, c});\\n        }\\n    }\\n    return -1; // We couldn\\'t reach the bottom-right corner. \\n               // We will never actually encounter this in practice.\\n}\\n```\\n\\n**Java**:\\n```\\npublic int minimumTime(int[][] grid) {\\n    if (grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n    \\n    int m = grid.length, n = grid[0].length;\\n    int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    boolean[][] visited = new boolean[m][n];\\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));\\n    pq.offer(new int[]{grid[0][0], 0, 0});\\n    \\n    while (!pq.isEmpty()) {\\n        int[] curr = pq.poll();\\n        int time = curr[0], row = curr[1], col = curr[2];\\n        \\n        if (row == m - 1 && col == n - 1) return time;\\n        if (visited[row][col]) continue;\\n        visited[row][col] = true;\\n        \\n        for (int[] dir : dirs) {\\n            int r = row + dir[0], c = col + dir[1];\\n            if (r < 0 || r >= m || c < 0 || c >= n || visited[r][c]) continue;\\n            int wait = ((grid[r][c] - time) % 2 == 0) ? 1 : 0;\\n            pq.offer(new int[]{Math.max(grid[r][c] + wait, time + 1), r, c});\\n        }\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\ndef minimumTime(self, grid: List[List[int]]) -> int:\\n    if grid[0][1] > 1 and grid[1][0] > 1: return -1\\n    m, n = len(grid), len(grid[0])\\n    visited = set()\\n    pq = [(grid[0][0], 0, 0)]\\n    \\n    while pq:\\n        time, row, col = heappop(pq)\\n        if row == m-1 and col == n-1: return time\\n        if (row, col) in visited: continue\\n        visited.add((row, col))\\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n            r, c = row + dr, col + dc\\n            if 0 <= r < m and 0 <= c < n and (r, c) not in visited:\\n                wait = 1 if ((grid[r][c] - time) % 2 == 0) else 0\\n                heappush(pq, (max(time + 1, grid[r][c] + wait), r, c))\\n```\n```\\nint minimumTime(vector<vector<int>>& grid) {\\n    // Check if the starting points are blocked\\n    if (grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n    \\n    int m = grid.size(), n = grid[0].size();\\n    vector<vector<int>> dirs{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    vector<vector<bool>> visited(m, vector<bool>(n, false));\\n    priority_queue<vector<int>, vector<vector<int>>, greater<>> pq;\\n    \\n    pq.push({grid[0][0], 0, 0}); // Start at top-left corner\\n    while (!pq.empty()) {\\n        // Get the current time, row, and column\\n        int time = pq.top()[0], row = pq.top()[1], col = pq.top()[2];\\n        pq.pop();\\n        \\n        // Check if we\\'ve reached the bottom-right corner\\n        if (row == m - 1 && col == n - 1) return time;\\n        \\n        // Mark the current cell as visited\\n        if (visited[row][col]) continue;\\n        visited[row][col] = true;\\n        \\n        // Explore the neighboring cells\\n        for (auto dr: dirs) {\\n            int r = row + dr[0], c = col + dr[1];\\n            if (r < 0 || r >= m || c < 0 || c >= n || visited[r][c]) continue;\\n            \\n            // Calculate the time required to reach the neighboring cell\\n            int wait = (grid[r][c] - time) % 2 == 0;\\n            pq.push({max(grid[r][c] + wait, time + 1), r, c});\\n        }\\n    }\\n    return -1; // We couldn\\'t reach the bottom-right corner. \\n               // We will never actually encounter this in practice.\\n}\\n```\n```\\npublic int minimumTime(int[][] grid) {\\n    if (grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n    \\n    int m = grid.length, n = grid[0].length;\\n    int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    boolean[][] visited = new boolean[m][n];\\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));\\n    pq.offer(new int[]{grid[0][0], 0, 0});\\n    \\n    while (!pq.isEmpty()) {\\n        int[] curr = pq.poll();\\n        int time = curr[0], row = curr[1], col = curr[2];\\n        \\n        if (row == m - 1 && col == n - 1) return time;\\n        if (visited[row][col]) continue;\\n        visited[row][col] = true;\\n        \\n        for (int[] dir : dirs) {\\n            int r = row + dir[0], c = col + dir[1];\\n            if (r < 0 || r >= m || c < 0 || c >= n || visited[r][c]) continue;\\n            int wait = ((grid[r][c] - time) % 2 == 0) ? 1 : 0;\\n            pq.offer(new int[]{Math.max(grid[r][c] + wait, time + 1), r, c});\\n        }\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3230787,
                "title": "python-c-clean-dijkstra-s-algorithm-solution-with-explanation",
                "content": "**Explaination**\\n\\nThis problem can be solved using the Dijkstra\\'s algorithm with a small variation.\\n\\nFirstly, note that we can always reach the bottom-right cell of the matrix if we can move to at least one adjacent cell (i.e. `grid[0][1]` or `grid[1][0]`). After that, we can simply move back and forth to spend time as needed.\\n\\nIt\\'s also worth noting that we may not always be able to move to an adjacent cell immediately. For example, in Example 1, we have to step back to cell (1,1) before moving to cell (1,3) because we must move every second.\\n\\nSince it takes an even number of seconds to \"stand still\" when moving back and forth, we need to wait for an extra second if we want to move after an odd number of seconds\\n\\nAfter accounting for these factors, we can use the standard Dijkstra\\'s algorithm to find the answer.\\n\\n<br/>\\n\\n**Complexity**\\n\\nTime complexity: `O(MNlog(MN))`\\nSpace complexity: `O(MN)`\\n\\n<br/>\\n\\n**Python**\\n```Python\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        if grid[0][1] > 1 and grid[1][0] > 1:\\n            return -1\\n        visited = [[False] * n for _ in range(m)]\\n        heap = [(0, 0, 0)] # (t, r, c)\\n        while heap:\\n            t, r, c = heapq.heappop(heap)\\n            if r == m - 1 and c == n - 1:\\n                return t\\n            if visited[r][c]:\\n                continue\\n            visited[r][c] = True\\n            for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):\\n                nr, nc = r + dr, c + dc\\n                if nr < 0 or nr >= m or nc < 0 or nc >= n or visited[nr][nc]:\\n                    continue\\n                wait = (grid[nr][nc] - t) % 2 == 0\\n                nt = max(grid[nr][nc] + wait, t + 1)\\n                heapq.heappush(heap, (nt, nr, nc))\\n        return -1\\n```\\n\\n<br/>\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\\n            return -1;\\n        }\\n        vector<vector<int>> directions{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        priority_queue<vector<int>, vector<vector<int>>, greater<>> pq;\\n        pq.push({0, 0, 0}); // (t, r, c)\\n        while (!pq.empty()) {\\n            auto cur = pq.top();\\n            int t = cur[0], r = cur[1], c = cur[2];\\n            pq.pop();\\n            if (r == m - 1 && c == n - 1) {\\n                return t;\\n            }\\n            if (visited[r][c]) {\\n                continue;\\n            }\\n            visited[r][c] = true;\\n            for (const auto& dir : directions) {\\n                int nr = r + dir[0], nc = c + dir[1];\\n                if (nr < 0 || nr >= m || nc < 0 || nc >= n || visited[nr][nc]) {\\n                    continue;\\n                }\\n                bool wait = (grid[nr][nc] - t) % 2 == 0;\\n                int nt = max(grid[nr][nc] + wait, t + 1);\\n                pq.push({nt, nr, nc});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```Python\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        if grid[0][1] > 1 and grid[1][0] > 1:\\n            return -1\\n        visited = [[False] * n for _ in range(m)]\\n        heap = [(0, 0, 0)] # (t, r, c)\\n        while heap:\\n            t, r, c = heapq.heappop(heap)\\n            if r == m - 1 and c == n - 1:\\n                return t\\n            if visited[r][c]:\\n                continue\\n            visited[r][c] = True\\n            for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):\\n                nr, nc = r + dr, c + dc\\n                if nr < 0 or nr >= m or nc < 0 or nc >= n or visited[nr][nc]:\\n                    continue\\n                wait = (grid[nr][nc] - t) % 2 == 0\\n                nt = max(grid[nr][nc] + wait, t + 1)\\n                heapq.heappush(heap, (nt, nr, nc))\\n        return -1\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\\n            return -1;\\n        }\\n        vector<vector<int>> directions{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        priority_queue<vector<int>, vector<vector<int>>, greater<>> pq;\\n        pq.push({0, 0, 0}); // (t, r, c)\\n        while (!pq.empty()) {\\n            auto cur = pq.top();\\n            int t = cur[0], r = cur[1], c = cur[2];\\n            pq.pop();\\n            if (r == m - 1 && c == n - 1) {\\n                return t;\\n            }\\n            if (visited[r][c]) {\\n                continue;\\n            }\\n            visited[r][c] = true;\\n            for (const auto& dir : directions) {\\n                int nr = r + dir[0], nc = c + dir[1];\\n                if (nr < 0 || nr >= m || nc < 0 || nc >= n || visited[nr][nc]) {\\n                    continue;\\n                }\\n                bool wait = (grid[nr][nc] - t) % 2 == 0;\\n                int nt = max(grid[nr][nc] + wait, t + 1);\\n                pq.push({nt, nr, nc});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231581,
                "title": "easy-dijkstra-video-solution-intuition-explained",
                "content": "# Intuition\\nDoes the solution always exist? \\n\\n# Approach\\nQ. Is there any case where we can not reach the end? \\nans: Yes!\\n\\nQ. That\\'s the example test case that has already been provided to us. The exact specifics are that if I can not go to (1,0) and even (0,1) from (0,0) then my answer doesn\\'t exist! \\nNow in what case it isn\\'t possible for me to go to these 2 indices? \\nans: Since grid[0][0]=0 hence when the value at (1,0) or (0,1) is greater than 1 itself then I would be blocked. \\n\\nQ. Is it possible for me to always reach the end otherwise? \\nans: yes, let me prove this. Say we are at some node X it\\'s parent node is P (all nodes except for (0,0) have a parent node). and from X we want to go to Y. Now 2 cases would arise \\ncase1. currentTime(at which I am on X)+1>=VAL[Y], in this case the time I can simply go to Y. \\ncase2. I\\'ll go back and forth between X and P. 1 unit of time would be spent going from X to P and another to go from P to X. so a round trip would cost us 2 time units. Since we can perform any roundtrips this way hence we add 2*N time where N is the number of roundtrips! \\nafter performing some number of roundtrips our time+1 would become greater than VAL[Y] and now I can go to Y! The only point to be noted is that when you peform these roundtrips then it\\'s possible that you reach a valud of time t which is 1 more than the optimum value. let\\'s say currTime=6, Val[Y]=8 so now you go from X to P and P to X and your time increases by 2 units. so you are at X now with currTime =6+2=8, you need 1 more unit of time to go to Y so you reach there at time 8+1=9 whereas the optimum time would\\'ve been 8 units.\\n\\nVideo solution: https://youtu.be/FEl1u9FvHLE\\n\\n\\n\\nPS- code is not mine, I modified the code of some other contributer. \\n# Complexity\\n- Time complexity:\\n- O(m*n*log(mn))\\n- Space complexity:\\n- O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint minimumTime(vector<vector<int>>& grid) {\\n    // Check if the starting points are blocked\\n    if (grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n    \\n    int n = grid.size(), m = grid[0].size();\\n    int dirs[]={1,0,-1,0,1};\\n    int visited[n][m];\\n    memset(visited,0,sizeof visited);\\n    priority_queue<vector<int>, vector<vector<int>>, greater<>> pq;\\n    \\n    pq.push({grid[0][0], 0, 0}); // Start at top-left corner\\n    while (!pq.empty()) {\\n        // Get the current time, row, and column\\n        int time = pq.top()[0], row = pq.top()[1], col = pq.top()[2];\\n        pq.pop();\\n        \\n        if (row == n - 1 && col == m - 1) return time;\\n        \\n        if (visited[row][col]) continue;\\n        visited[row][col] = true;\\n        for (int i=0;i<4;i++) {\\n            int r = row + dirs[i], c = col + dirs[i+1];\\n            if (r < 0 || r >= n || c < 0 || c >= m || visited[r][c]) continue;\\n            int wait = (grid[r][c] - time) % 2 == 0?1:0; // we would have to wait 1 more extra unit of time if the difference was already odd. \\n            pq.push({max(grid[r][c] + wait, time + 1), r, c});\\n        }\\n    }\\n    return -1; \\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint minimumTime(vector<vector<int>>& grid) {\\n    // Check if the starting points are blocked\\n    if (grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n    \\n    int n = grid.size(), m = grid[0].size();\\n    int dirs[]={1,0,-1,0,1};\\n    int visited[n][m];\\n    memset(visited,0,sizeof visited);\\n    priority_queue<vector<int>, vector<vector<int>>, greater<>> pq;\\n    \\n    pq.push({grid[0][0], 0, 0}); // Start at top-left corner\\n    while (!pq.empty()) {\\n        // Get the current time, row, and column\\n        int time = pq.top()[0], row = pq.top()[1], col = pq.top()[2];\\n        pq.pop();\\n        \\n        if (row == n - 1 && col == m - 1) return time;\\n        \\n        if (visited[row][col]) continue;\\n        visited[row][col] = true;\\n        for (int i=0;i<4;i++) {\\n            int r = row + dirs[i], c = col + dirs[i+1];\\n            if (r < 0 || r >= n || c < 0 || c >= m || visited[r][c]) continue;\\n            int wait = (grid[r][c] - time) % 2 == 0?1:0; // we would have to wait 1 more extra unit of time if the difference was already odd. \\n            pq.push({max(grid[r][c] + wait, time + 1), r, c});\\n        }\\n    }\\n    return -1; \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230876,
                "title": "djackstra-solution-visualisation-commented-solution",
                "content": "\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n**If you find this useful please give it an upvote!**\\nSince we have to find the minimum time and we have to search it. This boils down to **BFS**. However, we have to approach it greedily so we should use **djackstra\\'s algorithm which uses minimum Priority_queue\\ninstead of queue in bfs**.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe start from `{0,0}`;\\nThere are 4 cases that are possible:\\n![image.png](https://assets.leetcode.com/users/images/afe87c19-723a-4246-bfcf-49f8f5edb767_1677385952.6621647.png)\\n* If we are at red block at `time=3 sec`, we can move to yellow block at `time=4 sec`. \\n \\n![image.png](https://assets.leetcode.com/users/images/66c04bcf-2794-4130-96e0-c43379766157_1677385852.6977856.png)\\n* If we are at red block at t=1 sec and want to move to block 5\\nwe can keep on moving `1->0->1->0->1->1` until we move back to 1 at 5 sec and in that case we move to block 5 at t=7 sec.grid[X][Y]+1\\n(if difference is **even**, we reach at `grid[X][Y]+1`)\\n\\n![image.png](https://assets.leetcode.com/users/images/d9cb0ca4-6212-458c-b903-eeb92e6af6bf_1677385796.133826.png)\\n* To reach from 0 to 4 we keep on moving `0->1->0->1` until at red block and reach it at t=4sec.  \\n(if difference is **odd**, we reach at `grid[X][Y]`)\\n\\n![image.png](https://assets.leetcode.com/users/images/bc80be8a-7186-4eaa-a745-f01cb3b38a21_1677385927.8410172.png)\\n* If we are at `{0,0}`  and we have these two cases above we cannot move to any and in this case we will `return -1`;(edge case).\\n\\n\\n* **Visited array** keeps into account **minimum time instant at which we reach that position X,Y**. If it is smaller than current instant `par[0]+1>=visited[X][Y]` we dont add it in our priority_queue.\\n# Complexity\\n- Time complexity: O(m*n log(m*n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int dir[5]={1,0,-1,0,1};\\n    int visited[1001][1001];  //keeps the minimum instant we reached a point X,Y.\\n    int minimumTime(vector<vector<int>>& grid) \\n    {\\n        \\n        int m=grid.size(),n=grid[0].size();      \\n        if(grid[0][1]>1 and grid[1][0]>1) //edgecase: \\n            return -1;  \\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                visited[i][j]=INT_MAX;#initialise visted to INT_MAX.           \\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;  \\n#initialise min priority queue for djackstra traversal\\n        pq.push({0,{0,0}});\\n        visited[0][0]=0; #starting position\\n        while(!pq.empty())\\n        {\\n            auto temp=pq.top();\\n            int par[3]={temp.first,temp.second.first,temp.second.second};     // par[0]->time,par[1]->  i, par[2]-> j\\n            if(par[1]==m-1 and par[2]==n-1)\\n                return par[0];\\n            pq.pop();\\n            for(int k=0;k<4;k++)\\n            {\\n                int X=par[1]+dir[k];\\n                int Y=par[2]+dir[k+1];\\n                if(X<0||Y<0||X==m||Y==n||par[0]+1>=visited[X][Y])\\n                    continue;  //do not visit is we go out of boundary, or reach node if we have only reached there at smaller time\\n                int time=0;\\n                if(par[0]+1>grid[X][Y]) time=par[0]+1; //if we reach at time instant greater\\n#than grid[X][Y] time will be par[0]+1; \\n                else if((grid[X][Y]-par[0])%2) time=grid[X][Y]; //if diff between the two times is odd we will reach that node in time =grid[X][Y];\\n                else time=grid[X][Y]+1; //if diff between the two times is even we will reach that node in time =grid[X][Y]+1;\\n                pq.push({time,{X,Y}});\\n                visited[X][Y]=time; #update time\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Shortest Path"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int dir[5]={1,0,-1,0,1};\\n    int visited[1001][1001];  //keeps the minimum instant we reached a point X,Y.\\n    int minimumTime(vector<vector<int>>& grid) \\n    {\\n        \\n        int m=grid.size(),n=grid[0].size();      \\n        if(grid[0][1]>1 and grid[1][0]>1) //edgecase: \\n            return -1;  \\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                visited[i][j]=INT_MAX;#initialise visted to INT_MAX.           \\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;  \\n#initialise min priority queue for djackstra traversal\\n        pq.push({0,{0,0}});\\n        visited[0][0]=0; #starting position\\n        while(!pq.empty())\\n        {\\n            auto temp=pq.top();\\n            int par[3]={temp.first,temp.second.first,temp.second.second};     // par[0]->time,par[1]->  i, par[2]-> j\\n            if(par[1]==m-1 and par[2]==n-1)\\n                return par[0];\\n            pq.pop();\\n            for(int k=0;k<4;k++)\\n            {\\n                int X=par[1]+dir[k];\\n                int Y=par[2]+dir[k+1];\\n                if(X<0||Y<0||X==m||Y==n||par[0]+1>=visited[X][Y])\\n                    continue;  //do not visit is we go out of boundary, or reach node if we have only reached there at smaller time\\n                int time=0;\\n                if(par[0]+1>grid[X][Y]) time=par[0]+1; //if we reach at time instant greater\\n#than grid[X][Y] time will be par[0]+1; \\n                else if((grid[X][Y]-par[0])%2) time=grid[X][Y]; //if diff between the two times is odd we will reach that node in time =grid[X][Y];\\n                else time=grid[X][Y]+1; //if diff between the two times is even we will reach that node in time =grid[X][Y]+1;\\n                pq.push({time,{X,Y}});\\n                visited[X][Y]=time; #update time\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230782,
                "title": "java-priorityqueue-with-comments",
                "content": "```\\nclass Solution {\\n    private static final int[][] DIRS = new int[][] { { 1, 0 }, { -1, 0}, { 0, 1 }, { 0, -1 } };\\n    public int minimumTime(int[][] grid) {\\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\\n            return -1;\\n        }\\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        heap.offer(new int[] { 0, 0, 0 }); // row, col, time\\n        \\n        boolean[][] visited = new boolean[m][n];\\n        \\n        while (!heap.isEmpty()) {\\n            int[] entry = heap.poll();\\n            int row = entry[0];\\n            int col = entry[1];\\n            int time = entry[2];\\n            if (row == m - 1 && col == n - 1) {\\n                return time;\\n            }\\n            if (visited[row][col]) {\\n                continue;\\n            }\\n            visited[row][col] = true;\\n                \\n            for (int[] dir : DIRS) {\\n                int r = row + dir[0];\\n                int c = col + dir[1];\\n                if (r < 0 || r == m || c < 0 || c == n || visited[r][c]) {\\n                    continue;\\n                }\\n                \\n                if (grid[r][c] <= time + 1) {\\n                    // if it is possible to move to neighbor, do it\\n                    heap.offer(new int[] { r, c, time + 1 });\\n                } else {\\n                    // If we cant move to neighbor yet, we can hop to the previous cell\\n                    // and back to current cell as many times as we need to until\\n                    // sufficient time has passed.\\n                    // The trick here is that if the difference between the current time\\n                    // and the time we need is even, we will arrive back at the current cell\\n                    // 1 second \"late\" and so we will move to the neighbor 1 second after\\n                    // the minimum neighbor time.\\n                    int diff = grid[r][c] - time;\\n                    if (diff % 2 == 1) {\\n                        heap.offer(new int[] { r, c, grid[r][c] });\\n                    } else {\\n                        heap.offer(new int[] { r, c, grid[r][c] + 1 });\\n                    }\\n                }\\n            }\\n        }\\n        return -1; // will never reach here\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    private static final int[][] DIRS = new int[][] { { 1, 0 }, { -1, 0}, { 0, 1 }, { 0, -1 } };\\n    public int minimumTime(int[][] grid) {\\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\\n            return -1;\\n        }\\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        heap.offer(new int[] { 0, 0, 0 }); // row, col, time\\n        \\n        boolean[][] visited = new boolean[m][n];\\n        \\n        while (!heap.isEmpty()) {\\n            int[] entry = heap.poll();\\n            int row = entry[0];\\n            int col = entry[1];\\n            int time = entry[2];\\n            if (row == m - 1 && col == n - 1) {\\n                return time;\\n            }\\n            if (visited[row][col]) {\\n                continue;\\n            }\\n            visited[row][col] = true;\\n                \\n            for (int[] dir : DIRS) {\\n                int r = row + dir[0];\\n                int c = col + dir[1];\\n                if (r < 0 || r == m || c < 0 || c == n || visited[r][c]) {\\n                    continue;\\n                }\\n                \\n                if (grid[r][c] <= time + 1) {\\n                    // if it is possible to move to neighbor, do it\\n                    heap.offer(new int[] { r, c, time + 1 });\\n                } else {\\n                    // If we cant move to neighbor yet, we can hop to the previous cell\\n                    // and back to current cell as many times as we need to until\\n                    // sufficient time has passed.\\n                    // The trick here is that if the difference between the current time\\n                    // and the time we need is even, we will arrive back at the current cell\\n                    // 1 second \"late\" and so we will move to the neighbor 1 second after\\n                    // the minimum neighbor time.\\n                    int diff = grid[r][c] - time;\\n                    if (diff % 2 == 1) {\\n                        heap.offer(new int[] { r, c, grid[r][c] });\\n                    } else {\\n                        heap.offer(new int[] { r, c, grid[r][c] + 1 });\\n                    }\\n                }\\n            }\\n        }\\n        return -1; // will never reach here\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231527,
                "title": "back-n-forth-dijkstra",
                "content": "Good ol\\' Dijkstra once you work out the details.\\n\\nFirst of all, if the required time for both `g[0][1]` and `g[1][0]` is greater than one, we cannot move (return `-1`).\\n\\nOtherwise, we can always reach the bottom-right cell. If the current time (plus 1) is less than required, we can \"wait\" till the required time.\\n\\n> We do not wait, of course - instead, we put the required time into the priority queue. \\n\\nNote that we may need to add `1` to the required time, as we advance the current time in the increments of `2` seconds (by going back and forth). \\n\\n> For example, if the current time is `3`, and the required time is 9, we can get back to the current cell at `5`, `7`, and `9` seconds, so arrive at the adjacent cell at tenth second.\\n\\nFinally, we need to use \"visited\" matrix (`vis`) to track the shortest time to arrive at each cell.\\n\\n**C++**\\n```cpp\\nint dir[5] = {0, 1, 0, -1, 0};\\nint minimumTime(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size();\\n    if (min(g[0][1], g[1][0]) > 1)\\n        return -1;\\n    vector<vector<int>> vis(m, vector<int>(n, INT_MAX));\\n    priority_queue<array<int, 3>> pq;\\n    pq.push({0, 0, 0});\\n    while(!pq.empty()) {\\n        auto [neg_sec, i, j] = pq.top(); pq.pop();\\n        if (i == m - 1 && j == n - 1)\\n            break;\\n        for (int d = 0; d < 4; ++d) {\\n            int x = i + dir[d], y = j + dir[d + 1];\\n            if (min(x, y) >= 0 && x < m && y < n) {\\n                int sec = -neg_sec + 1;\\n                if (sec < g[x][y])\\n                    sec = g[x][y] + (g[x][y] - sec) % 2;\\n                if (sec < vis[x][y]) {\\n                    vis[x][y] = sec;\\n                    pq.push({-sec, x, y});\\n                }\\n            }\\n        }\\n    }\\n    return vis.back().back();\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint dir[5] = {0, 1, 0, -1, 0};\\nint minimumTime(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size();\\n    if (min(g[0][1], g[1][0]) > 1)\\n        return -1;\\n    vector<vector<int>> vis(m, vector<int>(n, INT_MAX));\\n    priority_queue<array<int, 3>> pq;\\n    pq.push({0, 0, 0});\\n    while(!pq.empty()) {\\n        auto [neg_sec, i, j] = pq.top(); pq.pop();\\n        if (i == m - 1 && j == n - 1)\\n            break;\\n        for (int d = 0; d < 4; ++d) {\\n            int x = i + dir[d], y = j + dir[d + 1];\\n            if (min(x, y) >= 0 && x < m && y < n) {\\n                int sec = -neg_sec + 1;\\n                if (sec < g[x][y])\\n                    sec = g[x][y] + (g[x][y] - sec) % 2;\\n                if (sec < vis[x][y]) {\\n                    vis[x][y] = sec;\\n                    pq.push({-sec, x, y});\\n                }\\n            }\\n        }\\n    }\\n    return vis.back().back();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3231001,
                "title": "python3-modified-dijkstra-detailed-solution",
                "content": "# Intuition\\nDijkstra algorithm should always be considered first in shortest time/path questions.\\n\\n# Approach\\nFirst observation:\\nIf ```grid[0][1] <= 1``` or ```grid[1][0] <= 1```, then you can always reach the bottom right position because you can jump back and forth between the starting point ```(0, 0)``` and its neighbour.\\n\\nSecond observation:\\nFor each position ```(r, c)```, you can visit it either at odd time or at even time, you won\\'t be able to visit ```(r, c)``` at both an odd time and an even time. This is because if you jump out and jump in, it will take `2` seconds, so the time you can visit a cell should be `t`, `t + 2`, `t + 4`, ..., where all of them are all even or all odd, depends on whether `t` is even or not.\\n\\nFinally:\\nIt\\'s just the standard Dijkstra\\'s algorithm, when you are about to visit a new cell `(r + dr, c + dc)`, assume the current time is `t`\\n- if `t + 1` and `grid[r + dr][c + dc]` are of the same parity (e.g. both odd or both even), then earliest time you can visit `(r + dr, c + dc)` is either `t + 1` or `grid[r][c]`. \\n- if `t + 1` and `grid[r + dr][c + dc]` are of different parity, then earliest time you can visit `(r + dr, c + dc)` is either `t + 1` or `grid[r][c] + 1`. Notice that we have `+1` here so that after that, `t + 1` and `grid[r][c] + 1` will have the same parity. \\n\\n# Complexity\\n- Time complexity:\\n$$O(mn log(mn))$$. Recall that for a standard Dijkstra algorithm, the time complexity is $$O((|V| + |E|) log V)$$, in our case, both $|V|$ and $|E|$ are $$O(mn)$$.\\n\\n- Space complexity:\\n$$O(mn)$$. Recall that for a standard Dijkstra algorithm, the space complexity is $$O(|V| + |E|)$$, in our case, both $|V|$ and $|E|$ are $$O(mn)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        if grid[0][1] > 1 and grid[1][0] > 1:\\n            return -1\\n\\n        m, n = len(grid), len(grid[0])\\n        heap = [(0, 0, 0)]\\n        min_time = [[inf] * n for _ in range(m)]\\n        min_time[0][0] = 0\\n        \\n        while heap:\\n            curr_time, r, c = heappop(heap)\\n            for dr, dc in [[-1, 0], [1, 0], [0, -1], [0, 1]]:\\n                if 0 <= r + dr < m and 0 <= c + dc < n:\\n                    if curr_time + 1 >= min_time[r + dr][c + dc]:\\n                        continue\\n                    else:\\n                        if (curr_time + 1 - grid[r + dr][c + dc]) % 2 == 0:\\n                            min_time[r + dr][c + dc] = max(curr_time + 1, grid[r + dr][c + dc])\\n                        else:\\n                            min_time[r + dr][c + dc] = max(curr_time + 1, grid[r + dr][c + dc] + 1)\\n                        heappush(heap, (min_time[r + dr][c + dc], r + dr, c + dc))\\n        return min_time[-1][-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```grid[0][1] <= 1```\n```grid[1][0] <= 1```\n```(0, 0)```\n```(r, c)```\n```(r, c)```\n```\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        if grid[0][1] > 1 and grid[1][0] > 1:\\n            return -1\\n\\n        m, n = len(grid), len(grid[0])\\n        heap = [(0, 0, 0)]\\n        min_time = [[inf] * n for _ in range(m)]\\n        min_time[0][0] = 0\\n        \\n        while heap:\\n            curr_time, r, c = heappop(heap)\\n            for dr, dc in [[-1, 0], [1, 0], [0, -1], [0, 1]]:\\n                if 0 <= r + dr < m and 0 <= c + dc < n:\\n                    if curr_time + 1 >= min_time[r + dr][c + dc]:\\n                        continue\\n                    else:\\n                        if (curr_time + 1 - grid[r + dr][c + dc]) % 2 == 0:\\n                            min_time[r + dr][c + dc] = max(curr_time + 1, grid[r + dr][c + dc])\\n                        else:\\n                            min_time[r + dr][c + dc] = max(curr_time + 1, grid[r + dr][c + dc] + 1)\\n                        heappush(heap, (min_time[r + dr][c + dc], r + dr, c + dc))\\n        return min_time[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234470,
                "title": "c-modified-dijkstra-s-algorithm-explained-approach-commented-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSome sort of modified dijkstra\\'s algorth will be used.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMODIFICATION of DIJKSTRA\\'S ALGO :-\\n\\nWe will mainatain a time visited 2d array for keeping the track of minimum time to reach the node.\\nDifferent cases will occur :\\n1. the grid node is not yet visited && current time >= grid node time    :   simply upgarde the time array and push values in minheap.\\n2. the grid node is not yet visited && current time < grid node time    :   check the difference btw current time and grid node time ; it its even -> use grid node time in time array and push values in minheap , and if odd -> use grid node time + 1 in time array and push values in minheap.\\n3. the grid node is visited before && current time < time matrix value : here arise two subcases :-\\n3.a. if grid node value <= current time : simply upgarde the time array and push values in minheap.\\n3.b. if grid node value > current time : arise two sub-subcases :  check the difference btw current time and grid node time :-\\n3.b.1. if it its even -> use grid node time in time array and push values in minheap .\\n3.b.2. if its odd -> use grid node time + 1 in time array and push values in minheap. \\n\\n\\n![download (2).jfif](https://assets.leetcode.com/users/images/74b13bd5-b9e2-40cc-9843-1503daedf32c_1677453378.4892983.jpeg)\\n\\n\\n \\n# Complexity\\n- Time complexity   :   O(mn * (mn)log(mn))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity  :   O(n*m) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef pair<int,pair<int,int>> p;\\n    \\n    int minimumTime(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        //case when no moves can be made [can\\'t reach the destination]\\n        if(grid[0][1]>1 && grid[1][0]>1)   return -1;\\n        \\n        //helping matrices\\n        vector<vector<int>> time(n, vector<int> (m,INT_MAX));\\n        vector<int> drow {0,-1,0,1};\\n        vector<int> dcol {-1,0,1,0};\\n        \\n        //minHeap for dijkstra\\'s\\n        priority_queue<p,vector<p>,greater<p>> q;\\n        //pushing initial values of source\\n        q.push({0,{0,0}});\\n        time[0][0] = 0;\\n        int res = INT_MAX;\\n        \\n        while(!q.empty())   {\\n            auto it = q.top();\\n            q.pop();\\n            int r = it.second.first;\\n            int c = it.second.second;\\n            int t = it.first;\\n            \\n            //case when destination is reached (possible answer)\\n            if(r==n-1 && c==m-1)    \\n                res = min(res,t);\\n            \\n            //incrementing time for the next new moves\\n            t++;\\n            \\n            //checking all four directions\\n            for(int i=0; i<4; i++)  {\\n                int dr = r+drow[i];\\n                int dc = c+dcol[i];\\n                \\n                if(dr>=0&&dr<n&&dc>=0&&dc<m) {\\n                    if(time[dr][dc]==INT_MAX)   {\\n                        //case 1\\n                        if(grid[dr][dc]<=t) {\\n                            time[dr][dc] = t;\\n                            q.push({t,{dr,dc}});\\n                        }\\n                        //case 2\\n                        else {\\n                            int dif = grid[dr][dc]-t;\\n                            if(dif%2==0)    {\\n                                time[dr][dc] = grid[dr][dc];\\n                                q.push({grid[dr][dc],{dr,dc}});\\n                            }\\n                            else {\\n                                time[dr][dc] = grid[dr][dc]+1;\\n                                q.push({grid[dr][dc]+1,{dr,dc}});\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        if(time[dr][dc]>t)  {\\n                            //case 3.a\\n                            if(grid[dr][dc]<=t)  {\\n                                time[dr][dc] = t;\\n                                q.push({t,{dr,dc}});                                \\n                            }\\n                            //case 3.b\\n                            else {\\n                                int dif = grid[dr][dc]-t;\\n                                if(dif%2==0)    {\\n                                    time[dr][dc] = grid[dr][dc];\\n                                    q.push({grid[dr][dc],{dr,dc}});\\n                                }\\n                                else {\\n                                    time[dr][dc] = grid[dr][dc]+1;\\n                                    q.push({grid[dr][dc]+1,{dr,dc}});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(res==INT_MAX)\\n            return -1;\\n        return res;\\n    }\\n};\\n```\\n\\n![sad-thumbs-up-cat.3.meme.webp](https://assets.leetcode.com/users/images/ac9176bf-ce84-48a7-ac3e-74b0ba735101_1677453394.161722.webp)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Matrix",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef pair<int,pair<int,int>> p;\\n    \\n    int minimumTime(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        //case when no moves can be made [can\\'t reach the destination]\\n        if(grid[0][1]>1 && grid[1][0]>1)   return -1;\\n        \\n        //helping matrices\\n        vector<vector<int>> time(n, vector<int> (m,INT_MAX));\\n        vector<int> drow {0,-1,0,1};\\n        vector<int> dcol {-1,0,1,0};\\n        \\n        //minHeap for dijkstra\\'s\\n        priority_queue<p,vector<p>,greater<p>> q;\\n        //pushing initial values of source\\n        q.push({0,{0,0}});\\n        time[0][0] = 0;\\n        int res = INT_MAX;\\n        \\n        while(!q.empty())   {\\n            auto it = q.top();\\n            q.pop();\\n            int r = it.second.first;\\n            int c = it.second.second;\\n            int t = it.first;\\n            \\n            //case when destination is reached (possible answer)\\n            if(r==n-1 && c==m-1)    \\n                res = min(res,t);\\n            \\n            //incrementing time for the next new moves\\n            t++;\\n            \\n            //checking all four directions\\n            for(int i=0; i<4; i++)  {\\n                int dr = r+drow[i];\\n                int dc = c+dcol[i];\\n                \\n                if(dr>=0&&dr<n&&dc>=0&&dc<m) {\\n                    if(time[dr][dc]==INT_MAX)   {\\n                        //case 1\\n                        if(grid[dr][dc]<=t) {\\n                            time[dr][dc] = t;\\n                            q.push({t,{dr,dc}});\\n                        }\\n                        //case 2\\n                        else {\\n                            int dif = grid[dr][dc]-t;\\n                            if(dif%2==0)    {\\n                                time[dr][dc] = grid[dr][dc];\\n                                q.push({grid[dr][dc],{dr,dc}});\\n                            }\\n                            else {\\n                                time[dr][dc] = grid[dr][dc]+1;\\n                                q.push({grid[dr][dc]+1,{dr,dc}});\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        if(time[dr][dc]>t)  {\\n                            //case 3.a\\n                            if(grid[dr][dc]<=t)  {\\n                                time[dr][dc] = t;\\n                                q.push({t,{dr,dc}});                                \\n                            }\\n                            //case 3.b\\n                            else {\\n                                int dif = grid[dr][dc]-t;\\n                                if(dif%2==0)    {\\n                                    time[dr][dc] = grid[dr][dc];\\n                                    q.push({grid[dr][dc],{dr,dc}});\\n                                }\\n                                else {\\n                                    time[dr][dc] = grid[dr][dc]+1;\\n                                    q.push({grid[dr][dc]+1,{dr,dc}});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(res==INT_MAX)\\n            return -1;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233743,
                "title": "bfs-priorityqueue",
                "content": "# Intuition\\nOn every step we will go to cell we can visit at minimum time.\\n\\n# Approach\\nWe will use BFS + priority queue. Among all possible cells we select one we can reach at minimum time. How can we calculate minimum time we can reach particular cell. Let consider following example:\\n![Screenshot 2023-02-26 at 17.22.43.png](https://assets.leetcode.com/users/images/c3f3d24c-7cfc-4733-b08f-1b8df2719f17_1677432207.830003.png)\\nFrom [0,0] we can move to [0,1] at minute 1. At minute 2 we can move to [1,1] at minute 2. At minute 3 we can move to [1,2]. Let calculate at what minute we can move to cell [1,3]. We can not move to it instantly but we can move back and forward untill we can. So we move back to [1,1] at minute 4, move to [1,2] at minute 5 and move to [1,3] at minute 6. We seond 2 seconds to do step back/forward. So if at time N we considering move to grid[i][j] = M we can calculate minimum time to reach it as following:\\n```javascript\\nif N + 1 >= M\\n  time = N + 1\\nelse\\n  diff = M - N -1 // seconds we need to wait untill we can move to this cell\\n  time = diff MOD 2 == 0 ? M : M + 1 // We spend 2 seconds to do step back/forward so if difference is even we can move at M if not at M + 1\\n```\\n**No Path**\\nThere is only one case when there is now path when both first possible steps [0,1] and [1,0] greater than 1. In this case we can not move. In all other cases we can do step back/forward in any particular cell untill next cell is avalalbe to move in.\\n\\n# Complexity\\n- Time complexity:\\nO(N*Log(N))\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nlet visited = new Set()\\nconst moves = [[0, -1], [0, 1], [1, 0], [-1, 0]]\\nvar minimumTime = function(grid) {\\n    visited = new Set();\\n    // Check if there is no path\\n    if(grid[0][1] > 1 && grid[1][0] > 1){\\n        return -1\\n    }\\n    \\n    return solve(grid)\\n};\\n\\nfunction solve(grid){\\n    const heap = new MinPriorityQueue()\\n    heap.enqueue([0, 0, 0], 0)\\n    while(heap.size() > 0){\\n        let c = heap.dequeue().element\\n        let i = c[0]\\n        let j = c[1]\\n        let key = `${i}_${j}`\\n        visited.add(key)\\n        let time = c[2]\\n        if(i == grid.length -1 && j == grid[0].length-1) {\\n            return time\\n        }\\n        const nm = moves.map(m => [i + m[0], j + m[1]]).filter(m => m[0] >= 0 && m[1] >= 0 && m[0] < grid.length && m[1] < grid[0].length).filter(m => !visited.has(`${m[0]}_${m[1]}`))\\n        \\n        for(let m of nm) {\\n            let nt = time+1\\n            if(time + 1 < grid[m[0]][m[1]]) {\\n                let diff = grid[m[0]][m[1]] - time-1\\n                nt = diff % 2 == 0 ? \\n                    grid[m[0]][m[1]] : grid[m[0]][m[1]] + 1\\n                \\n            }\\n            visited.add(`${m[0]}_${m[1]}`)\\n            heap.enqueue([...m, nt], nt)\\n        }\\n    }\\n    return -1;\\n}\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nif N + 1 >= M\\n  time = N + 1\\nelse\\n  diff = M - N -1 // seconds we need to wait untill we can move to this cell\\n  time = diff MOD 2 == 0 ? M : M + 1 // We spend 2 seconds to do step back/forward so if difference is even we can move at M if not at M + 1\\n```\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nlet visited = new Set()\\nconst moves = [[0, -1], [0, 1], [1, 0], [-1, 0]]\\nvar minimumTime = function(grid) {\\n    visited = new Set();\\n    // Check if there is no path\\n    if(grid[0][1] > 1 && grid[1][0] > 1){\\n        return -1\\n    }\\n    \\n    return solve(grid)\\n};\\n\\nfunction solve(grid){\\n    const heap = new MinPriorityQueue()\\n    heap.enqueue([0, 0, 0], 0)\\n    while(heap.size() > 0){\\n        let c = heap.dequeue().element\\n        let i = c[0]\\n        let j = c[1]\\n        let key = `${i}_${j}`\\n        visited.add(key)\\n        let time = c[2]\\n        if(i == grid.length -1 && j == grid[0].length-1) {\\n            return time\\n        }\\n        const nm = moves.map(m => [i + m[0], j + m[1]]).filter(m => m[0] >= 0 && m[1] >= 0 && m[0] < grid.length && m[1] < grid[0].length).filter(m => !visited.has(`${m[0]}_${m[1]}`))\\n        \\n        for(let m of nm) {\\n            let nt = time+1\\n            if(time + 1 < grid[m[0]][m[1]]) {\\n                let diff = grid[m[0]][m[1]] - time-1\\n                nt = diff % 2 == 0 ? \\n                    grid[m[0]][m[1]] : grid[m[0]][m[1]] + 1\\n                \\n            }\\n            visited.add(`${m[0]}_${m[1]}`)\\n            heap.enqueue([...m, nt], nt)\\n        }\\n    }\\n    return -1;\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3231554,
                "title": "video-explanation-with-intuition",
                "content": "# Explanation\\n\\nhttps://youtu.be/GAj_Q78lYP4\\n\\n[Click here if the preview above doesn\\'t works](https://youtu.be/GAj_Q78lYP4)\\n\\nNote - Video will be public at 12:15PM IST.\\n\\n# Code\\n```\\n#define F first\\n#define S second\\n\\nconst vector<vector<int>> neighbours = {\\n    {0, 1},\\n    {1, 0},\\n    {0, -1},\\n    {-1, 0}\\n};\\n\\nstruct Node {\\n    int time;\\n    int row, col;\\n    \\n    Node (int _time, int _row, int _col) : time(_time), row(_row), col(_col) {}\\n    \\n    bool operator < (const Node& rhs) const {\\n        if (time != rhs.time) return time < rhs.time;\\n        if (row != rhs.row) return row < rhs.row;\\n        return col < rhs.col;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size(); \\n        \\n        if (grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n        \\n        vector<vector<int>> time_to_reach(rows, vector<int>(cols, 1e9));\\n        time_to_reach[0][0] = 0;\\n        \\n        set<Node> q;\\n        for (int r = 0; r < rows; r ++) {\\n            for (int c = 0; c < cols; c ++) {\\n                q.insert(Node(time_to_reach[r][c], r, c));\\n            }\\n        }\\n        \\n        while (!q.empty()) {\\n            Node cur = *q.begin();\\n            q.erase (q.begin());\\n            \\n            for (auto i : neighbours) {\\n                int r = cur.row + i[0], c = cur.col + i[1];\\n                if (r < 0 || r >= rows || c < 0 || c >= cols) continue;\\n                \\n                int wait_time = max(0, grid[r][c] - cur.time - 1);\\n                if (wait_time % 2 != 0) wait_time ++;\\n            \\n                int new_time  = cur.time + wait_time + 1;\\n                if (time_to_reach[r][c] > new_time) {\\n                    q.erase (Node(time_to_reach[r][c], r, c));\\n                    time_to_reach[r][c] = new_time;\\n                    q.insert (Node(time_to_reach[r][c], r, c));\\n                }\\n            }\\n        }\\n        \\n        return time_to_reach[rows-1][cols-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define F first\\n#define S second\\n\\nconst vector<vector<int>> neighbours = {\\n    {0, 1},\\n    {1, 0},\\n    {0, -1},\\n    {-1, 0}\\n};\\n\\nstruct Node {\\n    int time;\\n    int row, col;\\n    \\n    Node (int _time, int _row, int _col) : time(_time), row(_row), col(_col) {}\\n    \\n    bool operator < (const Node& rhs) const {\\n        if (time != rhs.time) return time < rhs.time;\\n        if (row != rhs.row) return row < rhs.row;\\n        return col < rhs.col;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size(); \\n        \\n        if (grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n        \\n        vector<vector<int>> time_to_reach(rows, vector<int>(cols, 1e9));\\n        time_to_reach[0][0] = 0;\\n        \\n        set<Node> q;\\n        for (int r = 0; r < rows; r ++) {\\n            for (int c = 0; c < cols; c ++) {\\n                q.insert(Node(time_to_reach[r][c], r, c));\\n            }\\n        }\\n        \\n        while (!q.empty()) {\\n            Node cur = *q.begin();\\n            q.erase (q.begin());\\n            \\n            for (auto i : neighbours) {\\n                int r = cur.row + i[0], c = cur.col + i[1];\\n                if (r < 0 || r >= rows || c < 0 || c >= cols) continue;\\n                \\n                int wait_time = max(0, grid[r][c] - cur.time - 1);\\n                if (wait_time % 2 != 0) wait_time ++;\\n            \\n                int new_time  = cur.time + wait_time + 1;\\n                if (time_to_reach[r][c] > new_time) {\\n                    q.erase (Node(time_to_reach[r][c], r, c));\\n                    time_to_reach[r][c] = new_time;\\n                    q.insert (Node(time_to_reach[r][c], r, c));\\n                }\\n            }\\n        }\\n        \\n        return time_to_reach[rows-1][cols-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233232,
                "title": "pure-bfs-no-heap-max-grid-i-j-mn",
                "content": "# Approach\\n1) as regular BFS, move 1 level at a time and record adjacent cells as new level\\n2) the difference is, if `adjacent cell\\'s required time > current time + 1`, meaning we need to move back-and-forth to reach this cell, so put them in future level to be processed\\n3) for 2), one caveat is that when steps between adjacent cell\\'s time and current time is odd, it can move back-and-forth till exact adjacent cell time to reach it,\\nbut when it is even, it need 1 extra move to reach the adjacent cell\\n\\ne.g. \\n```\\nt=0             t[5] = (1,0)\\n  0  1  2  3\\n0[0*,1a,3 ,2 ]\\n1[5f,1 ,2 ,5 ]\\n2[4 ,3 ,8 ,6 ]\\n\\nt=1             t[4] = (2,2)\\n  0  1  2  3    t[5] = (1,0)\\n0[0-,1*,3f,2 ]\\n1[5f,1a,2 ,5 ]\\n2[4 ,3 ,8 ,6 ]\\n\\nt=2             t[4] = (2,2)\\n  0  1  2  3    t[5] = (1,0)\\n0[0-,1-,3f,2 ]\\n1[5f,1*,2a,5 ]\\n2[4 ,3a,8 ,6 ]\\n\\nt=3             t[4] = (2,2)\\n  0  1  2  3    t[5] = (1,0)\\n0[0-,1-,3f,2 ]  t[6] = (1,3)\\n1[5f,1-,2*,5f]  t[8] = (2,2)\\n2[4a,3*,8f,6 ]\\n\\nt=4             t[5] = (1,0)\\n  0  1  2  3    t[6] = (1,3)\\n0[0-,1-,3*,2a]  t[8] = (2,2)\\n1[5f,1-,2-,5f]\\n2[4*,3-,8f,6 ]\\n\\nt=5             \\n  0  1  2  3    t[6] = (1,3)\\n0[0-,1-,3-,2*]  t[8] = (2,2)\\n1[5*,1-,2-,5f]\\n2[4-,3-,8f,6 ]\\n\\nt=6             \\n  0  1  2  3    \\n0[0-,1-,3-,2-]  t[8] = (2,2)\\n1[5-,1-,2-,5*]\\n2[4-,3-,8f,6a]\\n\\nt=7             \\n  0  1  2  3    \\n0[0-,1-,3-,2-]  t[8] = (2,2)\\n1[5-,1-,2-,5-]\\n2[4-,3-,8f,6*]\\n```\\n\\n# Complexity\\n- Time complexity: O(max(grid[i][j])+mn)\\n- Space complexity: O(m*n)\\n\\n\\n# Code\\n```python\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        R, C = 0, 1\\n        nr, nc = len(grid), len(grid[0])\\n\\n        def get_nx(r, c):\\n            for r_nx, c_nx in ((r+1,c),(r-1,c),(r,c+1),(r,c-1)):\\n                if 0 <= r_nx <= nr-1 and 0 <= c_nx <= nc-1:\\n                    yield r_nx, c_nx\\n\\n        # main\\n        if grid[0][1] > 1 and grid[1][0] > 1:\\n            return -1\\n        start, end = (0, 0), (nr-1, nc-1)\\n        t_to_cells = defaultdict(set)\\n        t = 0\\n        t_to_cells[t].add(start)\\n        visited = {start}\\n        while True:\\n            for r, c in t_to_cells[t]:\\n                for r_nx, c_nx in get_nx(r, c):\\n                    if (r_nx, c_nx) in visited:\\n                        continue\\n                    if grid[r_nx][c_nx] > t+1:\\n                        t_diff = grid[r_nx][c_nx] - t\\n                        t_nx = t + t_diff if t_diff % 2 == 1 else t + t_diff + 1\\n                    else:\\n                        t_nx = t+1\\n                    if (r_nx, c_nx) == end:\\n                        return t_nx\\n                    t_to_cells[t_nx].add((r_nx, c_nx))\\n                    visited.add((r_nx, c_nx))\\n            t += 1\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nt=0             t[5] = (1,0)\\n  0  1  2  3\\n0[0*,1a,3 ,2 ]\\n1[5f,1 ,2 ,5 ]\\n2[4 ,3 ,8 ,6 ]\\n\\nt=1             t[4] = (2,2)\\n  0  1  2  3    t[5] = (1,0)\\n0[0-,1*,3f,2 ]\\n1[5f,1a,2 ,5 ]\\n2[4 ,3 ,8 ,6 ]\\n\\nt=2             t[4] = (2,2)\\n  0  1  2  3    t[5] = (1,0)\\n0[0-,1-,3f,2 ]\\n1[5f,1*,2a,5 ]\\n2[4 ,3a,8 ,6 ]\\n\\nt=3             t[4] = (2,2)\\n  0  1  2  3    t[5] = (1,0)\\n0[0-,1-,3f,2 ]  t[6] = (1,3)\\n1[5f,1-,2*,5f]  t[8] = (2,2)\\n2[4a,3*,8f,6 ]\\n\\nt=4             t[5] = (1,0)\\n  0  1  2  3    t[6] = (1,3)\\n0[0-,1-,3*,2a]  t[8] = (2,2)\\n1[5f,1-,2-,5f]\\n2[4*,3-,8f,6 ]\\n\\nt=5             \\n  0  1  2  3    t[6] = (1,3)\\n0[0-,1-,3-,2*]  t[8] = (2,2)\\n1[5*,1-,2-,5f]\\n2[4-,3-,8f,6 ]\\n\\nt=6             \\n  0  1  2  3    \\n0[0-,1-,3-,2-]  t[8] = (2,2)\\n1[5-,1-,2-,5*]\\n2[4-,3-,8f,6a]\\n\\nt=7             \\n  0  1  2  3    \\n0[0-,1-,3-,2-]  t[8] = (2,2)\\n1[5-,1-,2-,5-]\\n2[4-,3-,8f,6*]\\n```\n```python\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        R, C = 0, 1\\n        nr, nc = len(grid), len(grid[0])\\n\\n        def get_nx(r, c):\\n            for r_nx, c_nx in ((r+1,c),(r-1,c),(r,c+1),(r,c-1)):\\n                if 0 <= r_nx <= nr-1 and 0 <= c_nx <= nc-1:\\n                    yield r_nx, c_nx\\n\\n        # main\\n        if grid[0][1] > 1 and grid[1][0] > 1:\\n            return -1\\n        start, end = (0, 0), (nr-1, nc-1)\\n        t_to_cells = defaultdict(set)\\n        t = 0\\n        t_to_cells[t].add(start)\\n        visited = {start}\\n        while True:\\n            for r, c in t_to_cells[t]:\\n                for r_nx, c_nx in get_nx(r, c):\\n                    if (r_nx, c_nx) in visited:\\n                        continue\\n                    if grid[r_nx][c_nx] > t+1:\\n                        t_diff = grid[r_nx][c_nx] - t\\n                        t_nx = t + t_diff if t_diff % 2 == 1 else t + t_diff + 1\\n                    else:\\n                        t_nx = t+1\\n                    if (r_nx, c_nx) == end:\\n                        return t_nx\\n                    t_to_cells[t_nx].add((r_nx, c_nx))\\n                    visited.add((r_nx, c_nx))\\n            t += 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230831,
                "title": "python-dijkstra-simple-solution",
                "content": "# Code\\n```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        if grid[0][1] > 1 and grid[1][0] > 1: \\n            return -1\\n        heap = [(0,0,0)]\\n        visited = set()\\n        while heap:\\n            d, i, j = heappop(heap)\\n            if (i, j) in visited: continue\\n            visited.add((i,j))\\n            if (i, j) == (m-1, n-1): return d\\n            for di, dj in [[-1,0], [1,0], [0,-1], [0,1]]:\\n                if 0 <= i + di < m and 0 <= j + dj < n and (i + di, j + dj) not in visited:\\n                    t = grid[i+di][j+dj]\\n                    gap = max(t-(d+1), 0)\\n                    heappush(heap, (d + 1 + gap + (gap%2), i + di, j + dj))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        if grid[0][1] > 1 and grid[1][0] > 1: \\n            return -1\\n        heap = [(0,0,0)]\\n        visited = set()\\n        while heap:\\n            d, i, j = heappop(heap)\\n            if (i, j) in visited: continue\\n            visited.add((i,j))\\n            if (i, j) == (m-1, n-1): return d\\n            for di, dj in [[-1,0], [1,0], [0,-1], [0,1]]:\\n                if 0 <= i + di < m and 0 <= j + dj < n and (i + di, j + dj) not in visited:\\n                    t = grid[i+di][j+dj]\\n                    gap = max(t-(d+1), 0)\\n                    heappush(heap, (d + 1 + gap + (gap%2), i + di, j + dj))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230919,
                "title": "easy-c-dijkstra-with-conditions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt seemed like a straightforward shortest path problem with some modification due to the given condition: \\n\\n>  You can visit the cell `(row, col)` only when the time you visit it is **greater than or equal** to `grid[row][col]`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nA simple dijkstra where the following conditions are kept in mind:\\n\\n> If the `value` of adjacent element is less than the distance required to reach it, then the distance will be exactly `distance[x][y] + 1`\\n\\n> Otherwise two cases:\\n1. **The parity is same:** the distance will be exactly `grid[x][y] + 1` because you can visit the previous cell and come back but then the distance would be \\n`(dis[x][y] + 1) + 1`\\n\\n2. **The parity is different:** the distance will be exactly `grid[x][y]` because you can just visit the previous cell and come back and then the distance would be \\n`(dis[x][y] + 1)`\\n\\n# Complexity\\n- Time complexity: $$O((M * N) * log(M * N) + (M * N))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M*N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// please upvote if you find it useful :)\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        // -1 condition\\n        \\n        if(grid[0][1] > 1 and grid[1][0] > 1){\\n            return -1;\\n        }\\n        \\n        // main code\\n        vector<vector<int>> dis(n + 1, vector<int> (m + 1, 1e6));\\n        \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<>> q;\\n        \\n        q.push({0,{0,0}}); // dist, src_x, src_y\\n        \\n        dis[0][0] = 0;\\n        \\n        while(!q.empty()){\\n            int d = q.top().first;\\n            int x = q.top().second.first;\\n            int y = q.top().second.second;\\n            q.pop();\\n            if (d > dis[x][y]) continue; // Skip if `d` is not updated to latest version!\\n            \\n            // move down\\n            if(x + 1 < n){\\n                if(dis[x + 1][y] > d + 1){\\n                    \\n                    if(grid[x + 1][y] <= d + 1){\\n                        dis[x + 1][y] = d + 1;\\n                    }\\n                    else{\\n                        dis[x + 1][y] = ((grid[x + 1][y] % 2) == (d % 2) ? (grid[x + 1][y] + 1) : grid[x + 1][y]);\\n                    }\\n                    q.push({dis[x + 1][y],{x + 1, y}});\\n                    \\n                }\\n                \\n            }\\n            \\n            // move up\\n            if(x - 1 >= 0){\\n                if(dis[x - 1][y] > d + 1){\\n                    \\n                    if(grid[x - 1][y] <= d + 1){\\n                        dis[x - 1][y] = d + 1;\\n                    }\\n                    else dis[x - 1][y] = ((grid[x - 1][y] % 2) == (d % 2) ? (grid[x - 1][y] + 1) : grid[x - 1][y]);\\n                    q.push({dis[x - 1][y], {x - 1, y}});\\n                }\\n                \\n            }\\n            \\n            // move right\\n            if(y + 1 < m){\\n                if(dis[x][y + 1] > d + 1){\\n                    \\n                    if(grid[x][y + 1] <= d + 1){\\n                        dis[x][y + 1] = d + 1;\\n                    }\\n                    else dis[x][y + 1] = (dis[x][y + 1], (grid[x][y + 1] % 2) == (d % 2) ? (grid[x][y + 1] + 1) : grid[x][y + 1]);\\n                    q.push({dis[x][y + 1], {x, y + 1}});\\n                }\\n                \\n            }\\n            \\n            // move left\\n            if(y - 1 >= 0){\\n                if(dis[x][y - 1] > d + 1){\\n                    \\n                    if(grid[x][y - 1] <= d + 1){\\n                        dis[x][y - 1] = d + 1;\\n                    }\\n                    else dis[x][y - 1] = ((grid[x][y - 1] % 2) == (d % 2) ? (grid[x][y - 1] + 1) : grid[x][y - 1]);\\n                    q.push({dis[x][y - 1],{x, y - 1}});\\n                }\\n                \\n            }\\n            \\n            \\n        }\\n        \\n        return dis[n - 1][m - 1];\\n    }\\n};\\n```\\n# Questions Asked:\\n1. How does this work `if (d > dis[x][y]) continue;`?\\n- Firstly it wasn\\'t necessary here because any cell can be visited at most 4 times so the current cell `{x, y}` would have been pushed to the minHeap that many times. In the worst case, the cell will pop and process for its adjacent cells that can be atmost 4, each time it takes time to visit adjacent cells, there is up to 4 cells like current cell.\\n\\n- What if it was a graph question where a node may be connected to V other nodes, so in that case this line can be useful in avoiding visiting all V nodes as explained above.",
                "solutionTags": [
                    "C++",
                    "Shortest Path"
                ],
                "code": "```\\n// please upvote if you find it useful :)\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        // -1 condition\\n        \\n        if(grid[0][1] > 1 and grid[1][0] > 1){\\n            return -1;\\n        }\\n        \\n        // main code\\n        vector<vector<int>> dis(n + 1, vector<int> (m + 1, 1e6));\\n        \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<>> q;\\n        \\n        q.push({0,{0,0}}); // dist, src_x, src_y\\n        \\n        dis[0][0] = 0;\\n        \\n        while(!q.empty()){\\n            int d = q.top().first;\\n            int x = q.top().second.first;\\n            int y = q.top().second.second;\\n            q.pop();\\n            if (d > dis[x][y]) continue; // Skip if `d` is not updated to latest version!\\n            \\n            // move down\\n            if(x + 1 < n){\\n                if(dis[x + 1][y] > d + 1){\\n                    \\n                    if(grid[x + 1][y] <= d + 1){\\n                        dis[x + 1][y] = d + 1;\\n                    }\\n                    else{\\n                        dis[x + 1][y] = ((grid[x + 1][y] % 2) == (d % 2) ? (grid[x + 1][y] + 1) : grid[x + 1][y]);\\n                    }\\n                    q.push({dis[x + 1][y],{x + 1, y}});\\n                    \\n                }\\n                \\n            }\\n            \\n            // move up\\n            if(x - 1 >= 0){\\n                if(dis[x - 1][y] > d + 1){\\n                    \\n                    if(grid[x - 1][y] <= d + 1){\\n                        dis[x - 1][y] = d + 1;\\n                    }\\n                    else dis[x - 1][y] = ((grid[x - 1][y] % 2) == (d % 2) ? (grid[x - 1][y] + 1) : grid[x - 1][y]);\\n                    q.push({dis[x - 1][y], {x - 1, y}});\\n                }\\n                \\n            }\\n            \\n            // move right\\n            if(y + 1 < m){\\n                if(dis[x][y + 1] > d + 1){\\n                    \\n                    if(grid[x][y + 1] <= d + 1){\\n                        dis[x][y + 1] = d + 1;\\n                    }\\n                    else dis[x][y + 1] = (dis[x][y + 1], (grid[x][y + 1] % 2) == (d % 2) ? (grid[x][y + 1] + 1) : grid[x][y + 1]);\\n                    q.push({dis[x][y + 1], {x, y + 1}});\\n                }\\n                \\n            }\\n            \\n            // move left\\n            if(y - 1 >= 0){\\n                if(dis[x][y - 1] > d + 1){\\n                    \\n                    if(grid[x][y - 1] <= d + 1){\\n                        dis[x][y - 1] = d + 1;\\n                    }\\n                    else dis[x][y - 1] = ((grid[x][y - 1] % 2) == (d % 2) ? (grid[x][y - 1] + 1) : grid[x][y - 1]);\\n                    q.push({dis[x][y - 1],{x, y - 1}});\\n                }\\n                \\n            }\\n            \\n            \\n        }\\n        \\n        return dis[n - 1][m - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3429689,
                "title": "python-dijkstra-variant-explained",
                "content": "There is only one case where we can\\'t reach last cell , i.e. when all cells adjacent to (0,0) are greater than 1.\\nOtherwise we can always keep switching between current cell and the last visited cell to pass the time.\\nNow when we are moving from one cell to its adjacent cell -\\n1) if the difference between grid value of new cell and current cost is odd and grid value is greater than cost then we can move to new cell with it\\'s required grid value.\\n2) otherwise if difference is even and new cell grid value is greater than cost then we can only reach it by grid value+1 (since we will need 1 extra move while swtiching between current and previously visited cell).\\n3) If grid value of new cell is less than or equal to current cost then we can always move to new cell with new_cost=cost+1 (This is normal bfs move) .\\n\\nTime Complexity - O(m* n * log (m* n))\\n\\nCode : \\n```\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        directions=((0,1),(1,0),(-1,0),(0,-1))\\n        i,j,flag=0,0,0\\n        for di,dj in directions:\\n            ni,nj=i+di,j+dj\\n            if 0<=ni<m and 0<=nj<n and grid[ni][nj]<=1: flag=1;break;\\n        if not flag: return -1\\n        heap=[]\\n        heappush(heap,(0,0,0))\\n        dist=[[sys.maxsize]*n for _ in range(m)]\\n        while heap:\\n            cost,i,j=heappop(heap)\\n            if i==m-1 and j==n-1: return cost\\n            for di,dj in directions:\\n                ni,nj=i+di,j+dj\\n                if 0<=ni<m and 0<=nj<n:\\n                    new_cost=cost+1\\n                    if grid[ni][nj]>cost:\\n                        if abs(cost-grid[ni][nj])%2==0:\\n                            new_cost=grid[ni][nj]+1\\n                        else:\\n                            new_cost=grid[ni][nj]\\n                    if new_cost<dist[ni][nj]:\\n                        dist[ni][nj]=new_cost\\n                        heappush(heap,(new_cost,ni,nj))\\n        \\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        directions=((0,1),(1,0),(-1,0),(0,-1))\\n        i,j,flag=0,0,0\\n        for di,dj in directions:\\n            ni,nj=i+di,j+dj\\n            if 0<=ni<m and 0<=nj<n and grid[ni][nj]<=1: flag=1;break;\\n        if not flag: return -1\\n        heap=[]\\n        heappush(heap,(0,0,0))\\n        dist=[[sys.maxsize]*n for _ in range(m)]\\n        while heap:\\n            cost,i,j=heappop(heap)\\n            if i==m-1 and j==n-1: return cost\\n            for di,dj in directions:\\n                ni,nj=i+di,j+dj\\n                if 0<=ni<m and 0<=nj<n:\\n                    new_cost=cost+1\\n                    if grid[ni][nj]>cost:\\n                        if abs(cost-grid[ni][nj])%2==0:\\n                            new_cost=grid[ni][nj]+1\\n                        else:\\n                            new_cost=grid[ni][nj]\\n                    if new_cost<dist[ni][nj]:\\n                        dist[ni][nj]=new_cost\\n                        heappush(heap,(new_cost,ni,nj))\\n        \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3245273,
                "title": "c-dijkstra-flip-flopping-simple-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    // To check whether the node is in range or not...\\n    bool isValid(int row, int col, vector<vector<int>>& grid){\\n        return row >= 0 && col >= 0 && row < grid.size() && col < grid[0].size();\\n    }\\n    \\n    int minimumTime(vector<vector<int>>& grid) {\\n        \\n        // min heap...\\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;\\n        \\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        // Base cases...\\n        if(n > 1 && m > 1){\\n            if(grid[0][1] > grid[0][0] + 1 && grid[1][0] > grid[0][0] + 1){\\n                return -1;\\n            }\\n        }\\n        \\n        if(n > 1 && m == 0){\\n            if(grid[1][0] > grid[0][0] + 1){\\n                return -1;\\n            }\\n        }\\n        \\n        if(n == 0 && m > 1){\\n            if(grid[0][1] > grid[0][0] + 1){\\n                return -1;\\n            }\\n        }\\n        \\n        // Initializing distance array...\\n        vector<vector<int>> dists(n,vector<int>(m,INT_MAX));\\n        \\n        \\n        int dr[] = {0,1,0,-1};\\n        int dc[] = {-1,0,1,0};\\n        \\n        pq.push({0,{0,0}});\\n        \\n        dists[0][0] = 0;\\n        \\n        // Dijkstra\\n        \\n        while(!pq.empty()){\\n            auto tops = pq.top();\\n            pq.pop();\\n            \\n            int dist = tops.first;\\n            \\n            int row = tops.second.first;\\n            int col = tops.second.second;\\n            \\n            if(row == grid.size() - 1 && col == grid[0].size() - 1){\\n                return dist;\\n                \\n            }\\n            \\n            for(int i = 0 ; i < 4; i++){\\n                \\n                int newrow = row + dr[i];\\n                int newcol = col + dc[i];\\n                \\n                // Simple as explained in the question conditions are applied...\\n                \\n                if(isValid(newrow,newcol,grid) && grid[newrow][newcol] <= dist + 1){\\n                    \\n                    if(dists[newrow][newcol] > dist + 1){\\n                        pq.push({dist + 1, {newrow,newcol}});\\n                        dists[newrow][newcol] = dist + 1;\\n                        \\n                    }\\n                    \\n                }\\n                \\n                // If the conditions are not matched then there must be a cell smaller than grid[row][col] that is the cell from which iterator reached on  grid[row][col]. It can go back and forth in those two cells increasing the time and making the iterator able to reach new cell... \\n                \\n                // Number of times the back and forth process occured will be grid[newrow][newcol] - (dist) - 1...\\n                \\n                // If this number is odd then to make the iterator reach again at grid[row][col] we add 1 in it...\\n                \\n                else if(isValid(newrow,newcol,grid) && grid[newrow][newcol] > dist + 1){\\n                    \\n                    int diff = grid[newrow][newcol] - (dist);\\n                    diff--;\\n                    \\n                    if((diff&1)){\\n                        diff++;\\n                    }\\n                    \\n                    if(dists[newrow][newcol] > dist + diff + 1){\\n                        pq.push({dist + diff + 1, {newrow,newcol}});\\n                        dists[newrow][newcol] = dist + diff + 1;\\n                    }\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Math",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\npublic:\\n    // To check whether the node is in range or not...\\n    bool isValid(int row, int col, vector<vector<int>>& grid){\\n        return row >= 0 && col >= 0 && row < grid.size() && col < grid[0].size();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3235344,
                "title": "python-bfs-with-priority-queue-explained",
                "content": "The BFS can be used to solve the minimum time or minimum length problem.\\n\\n(1) In this problem, we must move to a different cell every second. Thus, the only case that we cannot reach the bottom right cell is that all the cells next to (0, 0) has required visit time larger than 1. If we have more than 2 visited cells, we can move back and forth so that the required visit time can meet.\\n\\n(2) Since we are moving back and forth, the minimum increment of time is 2. If the difference between the required visit time of next cell and the current time is multiple of 2, we need add one more second before we can reach the next cell.\\n\\n(3) Sort all the cells in a priority queue based on the next visit time, so that we can always visit the cell using the minimum time.\\n\\nWhenever, we reach the bottom right cell, we can return the visiting time.\\n\\n```\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        nrow = len(grid)\\n        ncol = len(grid[0])\\n        \\n        visited = set()\\n        visit_queue = [(0, 0, 0)]\\n        visited.add((0, 0))\\n        \\n        ans = -1\\n        while visit_queue:\\n            visit_time, r, c = heapq.heappop(visit_queue)\\n            if r == nrow - 1 and c == ncol - 1:\\n                ans = visit_time\\n                break\\n            \\n            for ncell in {(0, 1), (1, 0), (0, -1), (-1, 0)}:\\n                nr = r + ncell[0]\\n                nc = c + ncell[1]\\n                if nr >= 0 and nr < nrow and nc >= 0 and nc < ncol and (nr, nc) not in visited:\\n                    if grid[nr][nc] <= visit_time + 1:\\n                        heapq.heappush(visit_queue, (visit_time + 1, nr, nc))\\n                        visited.add((nr, nc))\\n                    elif len(visited) >= 2:\\n                        if (grid[nr][nc] - visit_time - 1) % 2:\\n                            heapq.heappush(visit_queue, (grid[nr][nc] + 1, nr, nc))\\n                        else:\\n                            heapq.heappush(visit_queue, (grid[nr][nc], nr, nc))\\n                        visited.add((nr, nc))\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        nrow = len(grid)\\n        ncol = len(grid[0])\\n        \\n        visited = set()\\n        visit_queue = [(0, 0, 0)]\\n        visited.add((0, 0))\\n        \\n        ans = -1\\n        while visit_queue:\\n            visit_time, r, c = heapq.heappop(visit_queue)\\n            if r == nrow - 1 and c == ncol - 1:\\n                ans = visit_time\\n                break\\n            \\n            for ncell in {(0, 1), (1, 0), (0, -1), (-1, 0)}:\\n                nr = r + ncell[0]\\n                nc = c + ncell[1]\\n                if nr >= 0 and nr < nrow and nc >= 0 and nc < ncol and (nr, nc) not in visited:\\n                    if grid[nr][nc] <= visit_time + 1:\\n                        heapq.heappush(visit_queue, (visit_time + 1, nr, nc))\\n                        visited.add((nr, nc))\\n                    elif len(visited) >= 2:\\n                        if (grid[nr][nc] - visit_time - 1) % 2:\\n                            heapq.heappush(visit_queue, (grid[nr][nc] + 1, nr, nc))\\n                        else:\\n                            heapq.heappush(visit_queue, (grid[nr][nc], nr, nc))\\n                        visited.add((nr, nc))\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230926,
                "title": "python3-dijkstra-s-algo",
                "content": "\\n```\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        if grid[0][1] <= 1 or grid[1][0] <= 1: \\n            m, n = len(grid), len(grid[0])\\n            pq = [(0, 0, 0)]\\n            dist = defaultdict(lambda : inf, {(0, 0) : 0})\\n            while pq: \\n                x, i, j = heappop(pq)\\n                if (i, j) == (m-1, n-1): return x \\n                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                    if 0 <= ii < m and 0 <= jj < n: \\n                        xx = x + 1 + max(0, (grid[ii][jj] - x)//2*2) \\n                        if dist[ii, jj] > xx: \\n                            heappush(pq, (xx, ii, jj))\\n                            dist[ii, jj] = xx \\n        return -1 \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        if grid[0][1] <= 1 or grid[1][0] <= 1: \\n            m, n = len(grid), len(grid[0])\\n            pq = [(0, 0, 0)]\\n            dist = defaultdict(lambda : inf, {(0, 0) : 0})\\n            while pq: \\n                x, i, j = heappop(pq)\\n                if (i, j) == (m-1, n-1): return x \\n                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                    if 0 <= ii < m and 0 <= jj < n: \\n                        xx = x + 1 + max(0, (grid[ii][jj] - x)//2*2) \\n                        if dist[ii, jj] > xx: \\n                            heappush(pq, (xx, ii, jj))\\n                            dist[ii, jj] = xx \\n        return -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231189,
                "title": "dfs-approach-stuck-c",
                "content": "Not able to clear all test cases, what am i doing wrong?\\n```\\nvector<int> row = {-1, 0, 1, 0};\\nvector<int> col = {0, 1, 0, -1};\\n\\nbool isVisited(int r, int c, vector<vector<int>> &visited) {\\n  if (visited[r][c] == 1)\\n    return true;\\n  return false;\\n}\\nint tm = 0 ;\\nvoid help(vector<vector<int>> &grid, int i, int j, vector<vector<int>> &visited,\\n          bool &flag, int &time) {\\n\\n // cout<<i<<\" \"<<j<<endl;\\n  visited[i][j] = 1;\\n  if(time < grid[i][j]){\\n    return;\\n  }\\n\\n  // cout << grid[i][j] << endl;\\n  int n = grid.size();\\n  int m = grid[0].size();\\n\\n  if (i == n - 1 && j == m - 1) {\\n    // cout<< \" base case\"<<endl;\\n    flag = true;\\n    tm =  max(tm,time);\\n    return;\\n  }\\n\\n\\n  for (int k = 0; k < 4; k++) {\\n    int r = i + row[k];\\n    int c = j + col[k];\\n  \\n    if (r >= 0 && r < n && c >= 0 && c < m ) {\\n        \\n      if (!isVisited(r, c, visited)) {\\n          time ++;\\n        // cout<<\"Time : \"<<time<<endl;\\n        help(grid,r,c,visited,flag,time);\\n        visited[r][c] = 0;\\n        time--;\\n      }\\n    }  \\n  }\\n}\\n```\\n\\nThank you!",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvector<int> row = {-1, 0, 1, 0};\\nvector<int> col = {0, 1, 0, -1};\\n\\nbool isVisited(int r, int c, vector<vector<int>> &visited) {\\n  if (visited[r][c] == 1)\\n    return true;\\n  return false;\\n}\\nint tm = 0 ;\\nvoid help(vector<vector<int>> &grid, int i, int j, vector<vector<int>> &visited,\\n          bool &flag, int &time) {\\n\\n // cout<<i<<\" \"<<j<<endl;\\n  visited[i][j] = 1;\\n  if(time < grid[i][j]){\\n    return;\\n  }\\n\\n  // cout << grid[i][j] << endl;\\n  int n = grid.size();\\n  int m = grid[0].size();\\n\\n  if (i == n - 1 && j == m - 1) {\\n    // cout<< \" base case\"<<endl;\\n    flag = true;\\n    tm =  max(tm,time);\\n    return;\\n  }\\n\\n\\n  for (int k = 0; k < 4; k++) {\\n    int r = i + row[k];\\n    int c = j + col[k];\\n  \\n    if (r >= 0 && r < n && c >= 0 && c < m ) {\\n        \\n      if (!isVisited(r, c, visited)) {\\n          time ++;\\n        // cout<<\"Time : \"<<time<<endl;\\n        help(grid,r,c,visited,flag,time);\\n        visited[r][c] = 0;\\n        time--;\\n      }\\n    }  \\n  }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3230947,
                "title": "java-solution-priorityqueue",
                "content": "\\n\\nclass Solution {\\n    \\n\\tpublic int minimumTime(int[][] grid) {\\n        \\n        \\n        int n = grid.length, m = grid[0].length;\\n        if(grid[0][0] > t) return -1;\\n        if(grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n        \\n        int[][] dir = {{-1,0}, {1,0}, {0,-1}, {0,1}};\\n        \\n        PriorityQueue<int[]> q = new PriorityQueue<>( (a, b)->(a[2]-b[2]) );\\n        boolean[][] vis = new boolean[n][m];\\n        q.offer(new int[]{0, 0, 0});\\n        \\n        while(!q.isEmpty()){\\n            int[] e = q.remove();\\n            \\n            vis[e[0]][e[1]] = true;\\n            \\n            if(e[0]  == n-1 && e[1] == m-1) return e[2];\\n            \\n            for(int[] d: dir){\\n                int new_x = e[0]+d[0], new_y = e[1]+d[1];\\n                \\n                if(new_x < 0 || new_y < 0 || new_x >= n || new_y >= m || vis[new_x][new_y]) continue;\\n                vis[new_x][new_y] = true;\\n                int diff = grid[new_x][new_y]-e[2];\\n                \\n                if(diff <= 1){\\n                    q.offer(new int[]{new_x, new_y, e[2]+1});\\n                }else{\\n                    if(diff%2 == 0){\\n                        q.offer(new int[]{new_x, new_y, e[2]+diff+1});\\n                    }else{\\n                        q.offer(new int[]{new_x, new_y, e[2]+diff});\\n                    }\\n                }\\n                \\n            }\\n            \\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n\\tpublic int minimumTime(int[][] grid) {\\n        \\n        \\n        int n = grid.length, m = grid[0].length;\\n        if(grid[0][0] > t) return -1;\\n        if(grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n        \\n        int[][] dir = {{-1,0}",
                "codeTag": "Java"
            },
            {
                "id": 3927690,
                "title": "c-modified-dijkstra-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are asked to move in adjacent cell every second.\\nBut what if the unvisited cell\\'s time is much more greater than current time passed?\\nHere, we will need to iterate on the peviously visited cells so that the time is passed. But doing this will lead to TLE.\\nSo, we need to keep a track of at what minimum time the cell can be visited after re-iterating on the visited cells.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- If`grid[0][1]`and`grid[1][0]`are greater than 1, then we cannot move anywhere from the first cell. So answer will be`-1`.\\n- If`time passed + 1 sec`is greater than or equal to`grid[i][j]`, then the cell will unlock at the same instance.\\n- Else, we will need to waste some time visiting the already visited cells so that the time is passed and the cell will unlock.\\nIf we are standing at a cell and no matter whichever path is chosed to visit the already visited cells, it will always take`even`amount of time to go and come back to the current cell.\\nSo, if the time passed is even,\\n    - If`grid[i][j]`is odd, then cell`{i, j}`will unlock at`grid[i][j]`time because revisiting the visited cells and coming back will take even amount of time no matter whichever path is traversed and then +1 second to go to locked cell.\\n    - If`grid[i][j]`is even, then cell`{i, j}`will unlock at`grid[i][j] + 1`time.\\n- If time passed is odd,\\n    - If`grid[i][j]`is even, then cell`{i, j}`will unlock at`grid[i][j]`time because revisiting the visited cells and coming back will take even amount of time no matter whichever path is traversed and then +1 second to go to locked cell.  \\n    - If`grid[i][j]`is odd, then cell`{i, j}`will unlock at`grid[i][j] + 1`time.\\n\\n# Complexity\\n- Time complexity: O(n * m * log(n * m)).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n * m).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<int> dr = {0, +1, 0, -1};\\n    vector<int> dc = {+1, 0, -1, 0};\\n\\npublic:\\n    bool isValid(int row, int col, int n, int m) {\\n        return (row >= 0 && row < n && col >= 0 && col < m);\\n    }\\n\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n\\n        // We can\\'t iterate anywhere except the first cell.\\n        if(grid[0][1] > 1 && grid[1][0] > 1) {\\n            return -1;\\n        }\\n\\n        vector<vector<int>> vis(n, vector<int>(m, -1));\\n        set<pair<int, pair<int, int>>> st;\\n        // {time, {row, col}}.\\n        st.insert({0, {0, 0}});\\n        vis[0][0] = 0;\\n\\n        while(st.size() != 0) {\\n            auto it = *(st.begin());\\n            int time = it.first;\\n            int x = it.second.first;\\n            int y = it.second.second;\\n            st.erase(it);\\n\\n            for(int i = 0; i < 4; ++i) {\\n                int newX = x + dr[i];\\n                int newY = y + dc[i];\\n                if(isValid(newX, newY, n, m) && vis[newX][newY] == -1) {\\n                    // No need to waste time as cell is already unlocked.\\n                    if(time + 1 >= grid[newX][newY]) {\\n                        vis[newX][newY] = time + 1;\\n                        st.insert({time + 1, {newX, newY}});\\n                    }\\n                    // Need to waste time.\\n                    else {\\n                        if(time % 2 == 0) {\\n                            if(grid[newX][newY] % 2 == 1) {\\n                                vis[newX][newY] = grid[newX][newY];\\n                                st.insert({grid[newX][newY], {newX, newY}});\\n                            }   \\n                            else {\\n                                vis[newX][newY] = grid[newX][newY] + 1;\\n                                st.insert({grid[newX][newY] + 1, {newX, newY}});\\n                            }\\n                        }\\n                        else {\\n                            if(grid[newX][newY] % 2 == 0) {\\n                                vis[newX][newY] = grid[newX][newY];\\n                                st.insert({grid[newX][newY], {newX, newY}});\\n                            }   \\n                            else {\\n                                vis[newX][newY] = grid[newX][newY] + 1;\\n                                st.insert({grid[newX][newY] + 1, {newX, newY}});\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return vis[n - 1][m - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Graph",
                    "Matrix",
                    "Ordered Set",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> dr = {0, +1, 0, -1};\\n    vector<int> dc = {+1, 0, -1, 0};\\n\\npublic:\\n    bool isValid(int row, int col, int n, int m) {\\n        return (row >= 0 && row < n && col >= 0 && col < m);\\n    }\\n\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n\\n        // We can\\'t iterate anywhere except the first cell.\\n        if(grid[0][1] > 1 && grid[1][0] > 1) {\\n            return -1;\\n        }\\n\\n        vector<vector<int>> vis(n, vector<int>(m, -1));\\n        set<pair<int, pair<int, int>>> st;\\n        // {time, {row, col}}.\\n        st.insert({0, {0, 0}});\\n        vis[0][0] = 0;\\n\\n        while(st.size() != 0) {\\n            auto it = *(st.begin());\\n            int time = it.first;\\n            int x = it.second.first;\\n            int y = it.second.second;\\n            st.erase(it);\\n\\n            for(int i = 0; i < 4; ++i) {\\n                int newX = x + dr[i];\\n                int newY = y + dc[i];\\n                if(isValid(newX, newY, n, m) && vis[newX][newY] == -1) {\\n                    // No need to waste time as cell is already unlocked.\\n                    if(time + 1 >= grid[newX][newY]) {\\n                        vis[newX][newY] = time + 1;\\n                        st.insert({time + 1, {newX, newY}});\\n                    }\\n                    // Need to waste time.\\n                    else {\\n                        if(time % 2 == 0) {\\n                            if(grid[newX][newY] % 2 == 1) {\\n                                vis[newX][newY] = grid[newX][newY];\\n                                st.insert({grid[newX][newY], {newX, newY}});\\n                            }   \\n                            else {\\n                                vis[newX][newY] = grid[newX][newY] + 1;\\n                                st.insert({grid[newX][newY] + 1, {newX, newY}});\\n                            }\\n                        }\\n                        else {\\n                            if(grid[newX][newY] % 2 == 0) {\\n                                vis[newX][newY] = grid[newX][newY];\\n                                st.insert({grid[newX][newY], {newX, newY}});\\n                            }   \\n                            else {\\n                                vis[newX][newY] = grid[newX][newY] + 1;\\n                                st.insert({grid[newX][newY] + 1, {newX, newY}});\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return vis[n - 1][m - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476724,
                "title": "easy-c-solution",
                "content": "# Intuition\\nwe will not reach the destination only when grid[0][1]and grid[1][0] both of them are greater than one otherwise we can go to the grid which is reachable and can increse time by oscillating between the places .For even we will see in howmany minimum time it is possible and we will do the same for odd. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n    int n =grid.size();\\n    int m =grid[0].size();\\n    vector<pair<int,int>>direc={{0,1},{0,-1},{1,0},{-1,0}};\\n    vector<vector<long long>>mov(n,vector<long long>(m,1e10));\\n    set<pair<long long,pair<int,int>>>st;\\n    mov[0][0]=0;\\n    st.insert({0,{0,0}});\\n    if(grid[0][1]>1&&grid[1][0]>1){\\n        return -1;\\n    }\\n      while(!st.empty()){\\n          auto it =*st.begin();\\n          long long  dis =it.first;\\n          int row = it.second.first;\\n          int col = it.second.second;\\n          st.erase(st.begin());\\n          if(dis>mov[row][col])continue;\\n          for(auto p:direc){\\n              int nr =row+p.first;\\n              int nc= col+p.second;\\n              if(nr>=0&&nr<n&&nc>=0&&nc<m){\\n                  long long add=1;\\n                  if(dis+1>=grid[nr][nc]){\\n                    add=1;\\n                  }\\n                  else{\\n                      if((grid[nr][nc]-dis)%2==0){\\n                        add=grid[nr][nc]-dis+1;\\n                      }\\n                      else{\\n                        add=grid[nr][nc]-dis;\\n                      }\\n                  }\\n                  if(mov[row][col]+add<mov[nr][nc]){\\n                      mov[nr][nc]=dis+add;\\n                      st.insert({mov[nr][nc],{nr,nc}});\\n                  }\\n                  \\n              }\\n          }\\n      }\\n    return mov[n-1][m-1];\\n    \\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n    int n =grid.size();\\n    int m =grid[0].size();\\n    vector<pair<int,int>>direc={{0,1},{0,-1},{1,0},{-1,0}};\\n    vector<vector<long long>>mov(n,vector<long long>(m,1e10));\\n    set<pair<long long,pair<int,int>>>st;\\n    mov[0][0]=0;\\n    st.insert({0,{0,0}});\\n    if(grid[0][1]>1&&grid[1][0]>1){\\n        return -1;\\n    }\\n      while(!st.empty()){\\n          auto it =*st.begin();\\n          long long  dis =it.first;\\n          int row = it.second.first;\\n          int col = it.second.second;\\n          st.erase(st.begin());\\n          if(dis>mov[row][col])continue;\\n          for(auto p:direc){\\n              int nr =row+p.first;\\n              int nc= col+p.second;\\n              if(nr>=0&&nr<n&&nc>=0&&nc<m){\\n                  long long add=1;\\n                  if(dis+1>=grid[nr][nc]){\\n                    add=1;\\n                  }\\n                  else{\\n                      if((grid[nr][nc]-dis)%2==0){\\n                        add=grid[nr][nc]-dis+1;\\n                      }\\n                      else{\\n                        add=grid[nr][nc]-dis;\\n                      }\\n                  }\\n                  if(mov[row][col]+add<mov[nr][nc]){\\n                      mov[nr][nc]=dis+add;\\n                      st.insert({mov[nr][nc],{nr,nc}});\\n                  }\\n                  \\n              }\\n          }\\n      }\\n    return mov[n-1][m-1];\\n    \\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284991,
                "title": "c-dijkstra-one-of-the-most-understable-simple-solution",
                "content": "```\\nclass Solution {\\n    vector<pair<int,int>> moves={{1,0},{0,1},{-1,0},{0,-1}};\\n    vector<vector<int>> dp;\\n    bool check(int x,int y,int n,int m){\\n        if(x>=0 && x<n && y>=0 && y<m)return true;\\n        return false;\\n    }\\n \\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n      int n=grid.size();\\n        int m=grid[0].size();\\n        dp.assign(n+1,vector<int>(m+1,INT_MAX));\\n      \\n        set<pair<int,pair<int,int>>> st;\\n        st.insert({0,{0,0}});\\n       \\n        if(grid[1][0]>1 && grid[0][1]>1)return -1;\\n        while(!st.empty()){\\n            auto it=*st.begin();\\n            int px=it.second.first;\\n            int py=it.second.second;\\n            int d=it.first;\\n            st.erase(it);\\n            for(int i=0;i<4;i++){\\n                int x=px+moves[i].first;\\n                int y=py+moves[i].second;\\n                if(!check(x,y,n,m))continue;\\n                 if(d+1>=grid[x][y]){\\n                   if(dp[x][y]>d+1){  st.insert({d+1,{x,y}}); dp[x][y]=d+1; }\\n                 }\\n                else{\\n                    if(d%2==(grid[x][y])%2){\\n                      if(dp[x][y]>grid[x][y]+1){  st.insert({grid[x][y]+1,{x,y}}); dp[x][y]=grid[x][y]+1;}\\n                            \\n                    }\\n                    else if(d%2!=(grid[x][y])%2){\\n                      if(dp[x][y]>grid[x][y]){   st.insert({grid[x][y],{x,y}});dp[x][y]=grid[x][y]; }\\n                    }\\n                }\\n                }\\n            }\\n        \\n        if(dp[n-1][m-1]==INT_MAX){\\n            return -1;\\n        }\\n        else return dp[n-1][m-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    vector<pair<int,int>> moves={{1,0},{0,1},{-1,0},{0,-1}};\\n    vector<vector<int>> dp;\\n    bool check(int x,int y,int n,int m){\\n        if(x>=0 && x<n && y>=0 && y<m)return true;\\n        return false;\\n    }\\n \\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n      int n=grid.size();\\n        int m=grid[0].size();\\n        dp.assign(n+1,vector<int>(m+1,INT_MAX));\\n      \\n        set<pair<int,pair<int,int>>> st;\\n        st.insert({0,{0,0}});\\n       \\n        if(grid[1][0]>1 && grid[0][1]>1)return -1;\\n        while(!st.empty()){\\n            auto it=*st.begin();\\n            int px=it.second.first;\\n            int py=it.second.second;\\n            int d=it.first;\\n            st.erase(it);\\n            for(int i=0;i<4;i++){\\n                int x=px+moves[i].first;\\n                int y=py+moves[i].second;\\n                if(!check(x,y,n,m))continue;\\n                 if(d+1>=grid[x][y]){\\n                   if(dp[x][y]>d+1){  st.insert({d+1,{x,y}}); dp[x][y]=d+1; }\\n                 }\\n                else{\\n                    if(d%2==(grid[x][y])%2){\\n                      if(dp[x][y]>grid[x][y]+1){  st.insert({grid[x][y]+1,{x,y}}); dp[x][y]=grid[x][y]+1;}\\n                            \\n                    }\\n                    else if(d%2!=(grid[x][y])%2){\\n                      if(dp[x][y]>grid[x][y]){   st.insert({grid[x][y],{x,y}});dp[x][y]=grid[x][y]; }\\n                    }\\n                }\\n                }\\n            }\\n        \\n        if(dp[n-1][m-1]==INT_MAX){\\n            return -1;\\n        }\\n        else return dp[n-1][m-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232633,
                "title": "video-explanation-hindi-dijkstra-algorithm-edge-case-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhttps://youtu.be/lZM00M5oljY\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first check cell(0,1) and (1,0) if they both have value>1 we cannot find solution as we will not be able to move forwards.\\n\\nWe will use dijkstra algorithms to get smallest cost cell first while doing bfs to reduce time cost.\\n\\nThere is one edge case , if we want to move from cell(i,j) to neighbour cell and we need additional \\'x\\' time and \\'x\\' is **even** then we need \\'x+1\\' time .\\n\\nLike we are at (1,1) with time  = 2, and want to go to (1,2) with time 4 we need additional 2 sec time but we will have to give (3) sec time to get there. As 2 sec will be exhausted going to cell(1,0)and coming back to (1,1) , and we need additonal \\'1\\' to reach (1,2)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n log (m *n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    \\n   \\n    \\n    int minimumTime(vector<vector<int>>& grid) {\\n\\n        //if cell 0,1 and cell 1,0 have >1 values then we cannot move ahed \\n        //from 0,0 so no sollution\\n        if(grid[0][1]>1 && grid[1][0]>1)return -1;\\n\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        //visited array we will process each cell atmax once\\n        vector<vector<int>>vis(n,vector<int>(m));\\n         \\n        //using priroirty queue to give us minimum cost cell first\\n        priority_queue<pair<int,pair<int,int>>>bfs;\\n        bfs.push({0,{0,0}});\\n         \\n        \\n        while(!bfs.empty()){\\n            pair<int,pair<int,int>>temp = bfs.top();\\n            bfs.pop();\\n\\n            //here x,y are coordinates of current cell\\n            //tm is the total time to reach till this cell\\n            int x = temp.second.first;\\n            int y = temp.second.second;\\n            int tm = abs(temp.first);\\n            \\n            //the first time we get to the last cell we return the time taken\\n            //we are using Dijkstra algorithm so it will most optimal answer\\n            //in first go\\n            if(x == n-1 && y == m-1)return tm;\\n            \\n            //we dont process already visited/processed cell\\n            if(vis[x][y])continue;\\n\\n            //marking the cell visited/processed\\n            vis[x][y] = 1;\\n            \\n            //now we will try to go to all valid neighbours \\n\\n            //move up\\n            if((x-1)>=0){\\n                int req = grid[x-1][y] - tm;\\n                //finding the required time\\n\\n                if(req<=1)req = max(req,1);\\n                else {\\n                    //if time is even we need one extra time \\n                    if(req%2==0)req ++;\\n                }\\n                //if condition is satisfied to move to the grid cell\\n                if((tm+req)>= grid[x-1][y] && vis[x-1][y] == 0){\\n                   \\n                    bfs.push({-(tm+req),{x-1,y}});\\n                }\\n                 \\n            }\\n            \\n            //move down\\n            if((x+1)<n){\\n                int req = grid[x+1][y] - tm;\\n                \\n\\n                if(req<=1)req = max(req,1);\\n                else {\\n                    if(req%2==0)req ++;\\n                }\\n                \\n                if((tm+req)>= grid[x+1][y] && vis[x+1][y] == 0){\\n                  \\n                    bfs.push({-(tm+req),{x+1,y}});\\n                } \\n            }\\n            \\n            //move up\\n            if((y-1)>=0){\\n                 int req = grid[x][y-1] - tm;\\n                 \\n                if(req<=1)req = max(req,1);\\n                else {\\n                    if(req%2==0)req ++;\\n                }\\n                \\n                if((tm+req)>= grid[x][y-1] && vis[x][y-1] == 0){\\n                    \\n                    bfs.push({-(tm+req),{x,y-1}});\\n                }\\n            }\\n            \\n            //move down\\n            if((y+1)<m){\\n                int req = grid[x][y+1] - tm;\\n                \\n                if(req<=1)req = max(req,1);\\n                else {\\n                    if(req%2==0)req ++;\\n                }\\n                \\n                if((tm+req)>= grid[x][y+1] && vis[x][y+1] == 0){\\n                    \\n                    bfs.push({-(tm+req),{x,y+1}});\\n                }\\n            }\\n       \\n            \\n        }\\n        \\n       return -1;\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n   \\n    \\n    int minimumTime(vector<vector<int>>& grid) {\\n\\n        //if cell 0,1 and cell 1,0 have >1 values then we cannot move ahed \\n        //from 0,0 so no sollution\\n        if(grid[0][1]>1 && grid[1][0]>1)return -1;\\n\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        //visited array we will process each cell atmax once\\n        vector<vector<int>>vis(n,vector<int>(m));\\n         \\n        //using priroirty queue to give us minimum cost cell first\\n        priority_queue<pair<int,pair<int,int>>>bfs;\\n        bfs.push({0,{0,0}});\\n         \\n        \\n        while(!bfs.empty()){\\n            pair<int,pair<int,int>>temp = bfs.top();\\n            bfs.pop();\\n\\n            //here x,y are coordinates of current cell\\n            //tm is the total time to reach till this cell\\n            int x = temp.second.first;\\n            int y = temp.second.second;\\n            int tm = abs(temp.first);\\n            \\n            //the first time we get to the last cell we return the time taken\\n            //we are using Dijkstra algorithm so it will most optimal answer\\n            //in first go\\n            if(x == n-1 && y == m-1)return tm;\\n            \\n            //we dont process already visited/processed cell\\n            if(vis[x][y])continue;\\n\\n            //marking the cell visited/processed\\n            vis[x][y] = 1;\\n            \\n            //now we will try to go to all valid neighbours \\n\\n            //move up\\n            if((x-1)>=0){\\n                int req = grid[x-1][y] - tm;\\n                //finding the required time\\n\\n                if(req<=1)req = max(req,1);\\n                else {\\n                    //if time is even we need one extra time \\n                    if(req%2==0)req ++;\\n                }\\n                //if condition is satisfied to move to the grid cell\\n                if((tm+req)>= grid[x-1][y] && vis[x-1][y] == 0){\\n                   \\n                    bfs.push({-(tm+req),{x-1,y}});\\n                }\\n                 \\n            }\\n            \\n            //move down\\n            if((x+1)<n){\\n                int req = grid[x+1][y] - tm;\\n                \\n\\n                if(req<=1)req = max(req,1);\\n                else {\\n                    if(req%2==0)req ++;\\n                }\\n                \\n                if((tm+req)>= grid[x+1][y] && vis[x+1][y] == 0){\\n                  \\n                    bfs.push({-(tm+req),{x+1,y}});\\n                } \\n            }\\n            \\n            //move up\\n            if((y-1)>=0){\\n                 int req = grid[x][y-1] - tm;\\n                 \\n                if(req<=1)req = max(req,1);\\n                else {\\n                    if(req%2==0)req ++;\\n                }\\n                \\n                if((tm+req)>= grid[x][y-1] && vis[x][y-1] == 0){\\n                    \\n                    bfs.push({-(tm+req),{x,y-1}});\\n                }\\n            }\\n            \\n            //move down\\n            if((y+1)<m){\\n                int req = grid[x][y+1] - tm;\\n                \\n                if(req<=1)req = max(req,1);\\n                else {\\n                    if(req%2==0)req ++;\\n                }\\n                \\n                if((tm+req)>= grid[x][y+1] && vis[x][y+1] == 0){\\n                    \\n                    bfs.push({-(tm+req),{x,y+1}});\\n                }\\n            }\\n       \\n            \\n        }\\n        \\n       return -1;\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232503,
                "title": "c-clean-code-dijkstra-s-algorithm-self-explanatory",
                "content": "# Intuition\\nJust Simple Dijkstra\\u2019s implementation we try to go to all nodes possible from current code and if we can\\'t reach there at given time than we assume that travel back and forth and increase time, and if value of new time for that node is less than the current value in resultant vector than update and add that in priority queue.\\n\\n# Complexity\\n- Time complexity:\\nO( E log(V) ) { for Dijkstra\\u2019s Algorithm }\\n\\n- Space complexity:\\nO( |E| + |V| ) { for priority queue and dist array } + O( |V| ) { for storing the final path }\\n\\nWhere E = Number of edges and V = Number of Nodes.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) \\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> res(n,vector<int>(m,1e9));\\n        \\n        if(grid[0][1]>grid[0][0]+1 && grid[1][0]>grid[0][0]+1)\\n        {\\n            return -1;\\n        }\\n        \\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;\\n        \\n        pq.push({0,{0,0}});\\n        \\n        int nr[] = {-1,0,1,0};\\n        int nc[] = {0,1,0,-1};\\n        \\n        while(!pq.empty())\\n        {\\n            auto it = pq.top();\\n            pq.pop();\\n            int time = it.first;\\n            int r = it.second.first;\\n            int c = it.second.second;\\n            \\n            for(int i=0;i<4;i++)\\n            {\\n                int x = r + nr[i];\\n                int y = c + nc[i];\\n                \\n                if(x>=0 && x<n && y>=0 && y<m)\\n                {\\n                    int ntime;\\n                    \\n                    if(time + 1 < grid[x][y])\\n                    {\\n                        ntime = grid[x][y];\\n                        \\n                        if(((time+1)+ntime)%2)\\n                        {\\n                            ntime++;\\n                        }\\n                    }\\n                    \\n                    else\\n                    {\\n                        ntime = time+1;\\n                    }\\n                    \\n                    // We will go back and forth with prev. node till time will be \\n                    // greater or equal\\n                    if(ntime < res[x][y])\\n                    {\\n                        res[x][y]=ntime;\\n                        pq.push({ntime,{x,y}});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(res[n-1][m-1]==INT_MAX)\\n        {\\n            res[n-1][m-1]=-1;\\n        }\\n        return res[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) \\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> res(n,vector<int>(m,1e9));\\n        \\n        if(grid[0][1]>grid[0][0]+1 && grid[1][0]>grid[0][0]+1)\\n        {\\n            return -1;\\n        }\\n        \\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;\\n        \\n        pq.push({0,{0,0}});\\n        \\n        int nr[] = {-1,0,1,0};\\n        int nc[] = {0,1,0,-1};\\n        \\n        while(!pq.empty())\\n        {\\n            auto it = pq.top();\\n            pq.pop();\\n            int time = it.first;\\n            int r = it.second.first;\\n            int c = it.second.second;\\n            \\n            for(int i=0;i<4;i++)\\n            {\\n                int x = r + nr[i];\\n                int y = c + nc[i];\\n                \\n                if(x>=0 && x<n && y>=0 && y<m)\\n                {\\n                    int ntime;\\n                    \\n                    if(time + 1 < grid[x][y])\\n                    {\\n                        ntime = grid[x][y];\\n                        \\n                        if(((time+1)+ntime)%2)\\n                        {\\n                            ntime++;\\n                        }\\n                    }\\n                    \\n                    else\\n                    {\\n                        ntime = time+1;\\n                    }\\n                    \\n                    // We will go back and forth with prev. node till time will be \\n                    // greater or equal\\n                    if(ntime < res[x][y])\\n                    {\\n                        res[x][y]=ntime;\\n                        pq.push({ntime,{x,y}});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(res[n-1][m-1]==INT_MAX)\\n        {\\n            res[n-1][m-1]=-1;\\n        }\\n        return res[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232394,
                "title": "shortest-path-bfs",
                "content": "Approach - We will use a priority queue to store the cells visited and also the minimum time required to get to the cell and mark the cell visited and from each cell we will try to move in all the four directions whenever possible.\\nPoints to note - \\n\\t1- We will use min priority queue with time as the criteria to keep our cells in increasing order.\\n\\t2-At any cell if we cannot make move due to the higher value of time required to get to that cell then there will be a cell from where we reach to current cell with which we can make some to and fro motions to satisfy the given condition.\\n```\\nclass Solution {\\npublic:\\n    \\n    int minimumTime(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        if(grid[0][1]!=1 && grid[1][0]!=1 && grid[0][1]!=0 && grid[1][0]!=0) return -1;\\n        vector<vector<int>> vis(1002,vector<int>(1001,0));\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        vector<int> dx={1,0,-1,0};\\n        vector<int> dy={0,1,0,-1};\\n        \\n        pq.push({0,0,0});\\n        while(pq.size()>0){\\n            \\n            auto curr=pq.top();\\n            pq.pop();\\n            int x=curr[1], y=curr[2], cost=curr[0];\\n            cout<<cost<<\" \";\\n            if(x==m-1 && y==n-1) return cost;\\n            for(int i=0;i<4;i++){\\n                if(x+dx[i]<m && y+dy[i]<n  && x+dx[i]>=0 && y+dy[i]>=0  && (vis[x+dx[i]][y+dy[i]]==0)){\\n                    vis[x+dx[i]][y+dy[i]]=1;\\n                     int val=0;\\n                    if(grid[x+dx[i]][y+dy[i]]<=cost){\\n                        val=cost;\\n                    }\\n                    else{\\n                        int z=(grid[x+dx[i]][y+dy[i]]-cost)/2;\\n                        val=cost+2*abs(z);\\n                    }\\n                   pq.push({val+1, x+dx[i], y+dy[i]});\\n                }\\n            }\\n        }\\n        return -2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumTime(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        if(grid[0][1]!=1 && grid[1][0]!=1 && grid[0][1]!=0 && grid[1][0]!=0) return -1;\\n        vector<vector<int>> vis(1002,vector<int>(1001,0));\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        vector<int> dx={1,0,-1,0};\\n        vector<int> dy={0,1,0,-1};\\n        \\n        pq.push({0,0,0});\\n        while(pq.size()>0){\\n            \\n            auto curr=pq.top();\\n            pq.pop();\\n            int x=curr[1], y=curr[2], cost=curr[0];\\n            cout<<cost<<\" \";\\n            if(x==m-1 && y==n-1) return cost;\\n            for(int i=0;i<4;i++){\\n                if(x+dx[i]<m && y+dy[i]<n  && x+dx[i]>=0 && y+dy[i]>=0  && (vis[x+dx[i]][y+dy[i]]==0)){\\n                    vis[x+dx[i]][y+dy[i]]=1;\\n                     int val=0;\\n                    if(grid[x+dx[i]][y+dy[i]]<=cost){\\n                        val=cost;\\n                    }\\n                    else{\\n                        int z=(grid[x+dx[i]][y+dy[i]]-cost)/2;\\n                        val=cost+2*abs(z);\\n                    }\\n                   pq.push({val+1, x+dx[i], y+dy[i]});\\n                }\\n            }\\n        }\\n        return -2;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3231161,
                "title": "modified-dijkstra-solution-c",
                "content": "We will be using dijkstra algorithm to find minimum time to reach bottom right from top left.\\n\\n![image](https://assets.leetcode.com/users/images/5dffba17-04e2-4c7f-a2d0-3b5beb3ca38f_1677385772.468185.png)\\n![image](https://assets.leetcode.com/users/images/d7d2ae94-ca07-46f0-9e4c-733abfc89b5f_1677385887.5832057.png)\\n\\n\\n\\n```\\ntypedef pair<int,int> pi;\\nclass Solution {\\npublic:\\n    \\n    int isSafe(int x, int y, int m, int n){\\n        \\n\\t\\t//returns whether a point lies within the grid or not\\n        if(x<0 or y<0 or x==m or y==n)\\n            return 0;\\n        \\n        return 1;\\n        \\n    }\\n    int minimumTime(vector<vector<int>>& grid) {\\n\\t\\t\\t\\n\\t\\t// If the neighbouring cells of grid[0][0] is not 1, we will be not able to travel forward so just return -1\\t\\n        if(grid[1][0]>1 and grid[0][1]>1)\\n            return -1;\\n        \\n\\t\\t// priority queue\\n\\t\\t// 1st value in pair - Time required to reach that point\\n\\t\\t// 2nd pair - Coordinates (x,y)\\n\\n        priority_queue<pair<int,pi>,vector<pair<int,pi>>,greater<pair<int,pi>>> pq;\\n        pq.push({0,{0,0}});\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n\\t\\t// Dist vector of vector to store min time required to reach a point\\n        vector<vector<int>> dist(m,vector<int> (n,INT_MAX));\\n\\t\\t\\n\\t\\t// Defining available moves\\n        vector<vector<int>> moves = {{1,0},{-1,0},{0,1},{0,-1}};\\n        \\n        while(!pq.empty()){\\n            \\n            auto tmp = pq.top();\\n            pq.pop();\\n            \\n            int val = tmp.first;\\n            int x = tmp.second.first;\\n            int y = tmp.second.second;\\n            \\n\\t\\t\\t//If we have reached the right bottom return the min time\\n            if(x == m-1 and y == n-1)\\n                return val;\\n            \\n            for(int i=0;i<4;i++){\\n                \\n                int nx = x+moves[i][0];\\n                int ny = y+moves[i][1];\\n                \\n                if(!isSafe(nx,ny,m,n))\\n                    continue;\\n                \\n\\t\\t\\t\\t// Finding the difference between time of the cells\\n                int currDist = grid[nx][ny] - val;\\n                \\n                currDist = max(currDist,0);\\n                \\n\\t\\t\\t\\t//If the distance between the times of 2 cell is even then we have to increment required time\\n                if(currDist%2 == 0)\\n                    currDist++;\\n                \\n                if(dist[nx][ny]>val+currDist)\\n                {\\n                    dist[nx][ny] = val+currDist;\\n                    pq.push({dist[nx][ny],{nx,ny}});\\n                }\\n                \\n            }\\n            \\n        }\\n        return -1;\\n        \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntypedef pair<int,int> pi;\\nclass Solution {\\npublic:\\n    \\n    int isSafe(int x, int y, int m, int n){\\n        \\n\\t\\t//returns whether a point lies within the grid or not\\n        if(x<0 or y<0 or x==m or y==n)\\n            return 0;\\n        \\n        return 1;\\n        \\n    }\\n    int minimumTime(vector<vector<int>>& grid) {\\n\\t\\t\\t\\n\\t\\t// If the neighbouring cells of grid[0][0] is not 1, we will be not able to travel forward so just return -1\\t\\n        if(grid[1][0]>1 and grid[0][1]>1)\\n            return -1;\\n        \\n\\t\\t// priority queue\\n\\t\\t// 1st value in pair - Time required to reach that point\\n\\t\\t// 2nd pair - Coordinates (x,y)\\n\\n        priority_queue<pair<int,pi>,vector<pair<int,pi>>,greater<pair<int,pi>>> pq;\\n        pq.push({0,{0,0}});\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n\\t\\t// Dist vector of vector to store min time required to reach a point\\n        vector<vector<int>> dist(m,vector<int> (n,INT_MAX));\\n\\t\\t\\n\\t\\t// Defining available moves\\n        vector<vector<int>> moves = {{1,0},{-1,0},{0,1},{0,-1}};\\n        \\n        while(!pq.empty()){\\n            \\n            auto tmp = pq.top();\\n            pq.pop();\\n            \\n            int val = tmp.first;\\n            int x = tmp.second.first;\\n            int y = tmp.second.second;\\n            \\n\\t\\t\\t//If we have reached the right bottom return the min time\\n            if(x == m-1 and y == n-1)\\n                return val;\\n            \\n            for(int i=0;i<4;i++){\\n                \\n                int nx = x+moves[i][0];\\n                int ny = y+moves[i][1];\\n                \\n                if(!isSafe(nx,ny,m,n))\\n                    continue;\\n                \\n\\t\\t\\t\\t// Finding the difference between time of the cells\\n                int currDist = grid[nx][ny] - val;\\n                \\n                currDist = max(currDist,0);\\n                \\n\\t\\t\\t\\t//If the distance between the times of 2 cell is even then we have to increment required time\\n                if(currDist%2 == 0)\\n                    currDist++;\\n                \\n                if(dist[nx][ny]>val+currDist)\\n                {\\n                    dist[nx][ny] = val+currDist;\\n                    pq.push({dist[nx][ny],{nx,ny}});\\n                }\\n                \\n            }\\n            \\n        }\\n        return -1;\\n        \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230835,
                "title": "c-bfs-pq-code-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : bfs with priority queue\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: (m*n)log(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int row=grid.size(), col=grid[0].size(), ans=INT_MAX;\\n        vector<vector<int>> direction{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        vector<vector<bool>> visited(row, vector<bool>(col, false));\\n        \\n        priority_queue<vector<int>, vector<vector<int>>, greater<>> pq;\\n    \\n        visited[0][0]=true;\\n        \\n        pq.push({0, 0, 0});\\n        // do initial explore\\n        if(grid[1][0]<=1){\\n            pq.push({1, 1, 0});\\n            visited[1][0]=true;\\n        }\\n        if(grid[0][1]<=1){\\n            pq.push({1, 0, 1});\\n            visited[0][1]=true;\\n        }\\n        \\n        // if no initial round return 0\\n        if(pq.size()==1){\\n            return -1;\\n        }\\n        \\n        while(pq.size()){\\n            auto curr = pq.top();\\n            pq.pop();\\n            int time=curr[0];\\n            int r=curr[1], c=curr[2];\\n            \\n            if(r==row-1 && c==col-1){\\n                ans=min(ans, time);\\n            }\\n            \\n            for(auto& i:direction){\\n                int newR=r+i[0];\\n                int newC=c+i[1];\\n                if(newR>=0 && newR<row && newC>=0 && newC<col && visited[newR][newC]==false){\\n                    if(time+1>=grid[newR][newC]){\\n                        pq.push({time+1, newR, newC});\\n                    // if difference between two cell is more than 1\\n                    }else{\\n                        int diff=grid[newR][newC]-time;\\n                        // steps to get two next cell\\n                        if(diff%2==0){\\n                            pq.push({grid[newR][newC]+1, newR, newC});\\n                        }else{\\n                            pq.push({grid[newR][newC], newR, newC});\\n                        }\\n                    }\\n                    visited[newR][newC]=true;\\n                }\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int row=grid.size(), col=grid[0].size(), ans=INT_MAX;\\n        vector<vector<int>> direction{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        vector<vector<bool>> visited(row, vector<bool>(col, false));\\n        \\n        priority_queue<vector<int>, vector<vector<int>>, greater<>> pq;\\n    \\n        visited[0][0]=true;\\n        \\n        pq.push({0, 0, 0});\\n        // do initial explore\\n        if(grid[1][0]<=1){\\n            pq.push({1, 1, 0});\\n            visited[1][0]=true;\\n        }\\n        if(grid[0][1]<=1){\\n            pq.push({1, 0, 1});\\n            visited[0][1]=true;\\n        }\\n        \\n        // if no initial round return 0\\n        if(pq.size()==1){\\n            return -1;\\n        }\\n        \\n        while(pq.size()){\\n            auto curr = pq.top();\\n            pq.pop();\\n            int time=curr[0];\\n            int r=curr[1], c=curr[2];\\n            \\n            if(r==row-1 && c==col-1){\\n                ans=min(ans, time);\\n            }\\n            \\n            for(auto& i:direction){\\n                int newR=r+i[0];\\n                int newC=c+i[1];\\n                if(newR>=0 && newR<row && newC>=0 && newC<col && visited[newR][newC]==false){\\n                    if(time+1>=grid[newR][newC]){\\n                        pq.push({time+1, newR, newC});\\n                    // if difference between two cell is more than 1\\n                    }else{\\n                        int diff=grid[newR][newC]-time;\\n                        // steps to get two next cell\\n                        if(diff%2==0){\\n                            pq.push({grid[newR][newC]+1, newR, newC});\\n                        }else{\\n                            pq.push({grid[newR][newC], newR, newC});\\n                        }\\n                    }\\n                    visited[newR][newC]=true;\\n                }\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230807,
                "title": "java-simple-priority-queue-speed-98-31",
                "content": "![image.png](https://assets.leetcode.com/users/images/f388b6ed-e166-430f-a365-d4e8442e5dda_1678416705.2699091.png)\\n\\n# Code\\n```\\n    public int minimumTime(int[][] grid) {\\n        if(grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n        int m = grid.length, n = grid[0].length;\\n        int[][] directions = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[0] - b[0]); \\n        pq.add(new int[]{0, 0, 0});//int[step, i, j]\\n        boolean[][] visited = new boolean[m][n];\\n        visited[0][0] = true;\\n        while(!pq.isEmpty()){\\n            int[] cur = pq.poll(); //current smallest step\\n            for(int[] direction : directions){\\n                int i = cur[1] + direction[0];\\n                int j = cur[2] + direction[1];\\n                if(i < 0 || i == m || j < 0 || j == n || visited[i][j]) continue;\\n                visited[i][j] = true;\\n                int step = cur[0] + 1;\\n                if(grid[i][j] > step) step = (grid[i][j] - step) % 2 + grid[i][j];\\n                if(i == m - 1 && j == n - 1) return step;\\n                pq.add(new int[]{step , i, j});\\n            }     \\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int minimumTime(int[][] grid) {\\n        if(grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n        int m = grid.length, n = grid[0].length;\\n        int[][] directions = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[0] - b[0]); \\n        pq.add(new int[]{0, 0, 0});//int[step, i, j]\\n        boolean[][] visited = new boolean[m][n];\\n        visited[0][0] = true;\\n        while(!pq.isEmpty()){\\n            int[] cur = pq.poll(); //current smallest step\\n            for(int[] direction : directions){\\n                int i = cur[1] + direction[0];\\n                int j = cur[2] + direction[1];\\n                if(i < 0 || i == m || j < 0 || j == n || visited[i][j]) continue;\\n                visited[i][j] = true;\\n                int step = cur[0] + 1;\\n                if(grid[i][j] > step) step = (grid[i][j] - step) % 2 + grid[i][j];\\n                if(i == m - 1 && j == n - 1) return step;\\n                pq.add(new int[]{step , i, j});\\n            }     \\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4064115,
                "title": "easy-priority-queue",
                "content": "# Intuition\\nthe problem is talking about minimum time for reaching from one node to another, so it is pointing towards ****some where around shortest path algo i.e dijkstra algorithm**** . we have to some how think of how to calculate the distance in terms of time to reach that node.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nhere the case where we can\\'t achieve the goal state is when the adjacent nodes of {0,0} have timing>1. for any other node we can pass the time by alternately switching between parent node and current node. for calculating the distance we jsut need to apply some maths.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> dist(m,vector<int>(n,INT_MAX));\\n        if(grid[0][1]>1 && grid[1][0]>1)\\n        {\\n            return -1;\\n        }\\n       priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> q;\\n       vector<int> temp{0,0,0};\\n       dist[0][0]=0;\\n       q.emplace(temp); \\n       int dx[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\\n       while(!q.empty())\\n       {\\n         auto top=q.top();\\n         q.pop();\\n         int cost=top[0];\\n         int x=top[1];\\n         int y=top[2];\\n         if(x==m-1 && y==n-1){\\n             return cost;\\n         }\\n         if(cost>dist[x][y]) continue;\\n         for(int i=0;i<4;i++)\\n         {   \\n             int nx=x+dx[i][0];\\n             int ny=y+dx[i][1];\\n             if(nx>=0 && nx<m && ny>=0 && ny<n)\\n             {  // here we calculate the distance of the adjacent \\n                //node from the current node\\n                int newdist;\\n                if(grid[nx][ny]>cost+1)\\n                {\\n                    if((grid[nx][ny]-cost)%2==0)\\n                    {\\n                        newdist=grid[nx][ny]+1;\\n                    }\\n                    else{\\n                        newdist=grid[nx][ny];\\n                    }\\n                }\\n                else{\\n                    newdist=cost+1;\\n                }\\n\\n                if(newdist<dist[nx][ny])\\n                {\\n                    dist[nx][ny]=newdist;\\n                    vector<int> t{newdist,nx,ny};\\n                    q.emplace(t); \\n                }\\n             } \\n         }\\n       }\\n\\n       return dist[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> dist(m,vector<int>(n,INT_MAX));\\n        if(grid[0][1]>1 && grid[1][0]>1)\\n        {\\n            return -1;\\n        }\\n       priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> q;\\n       vector<int> temp{0,0,0};\\n       dist[0][0]=0;\\n       q.emplace(temp); \\n       int dx[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\\n       while(!q.empty())\\n       {\\n         auto top=q.top();\\n         q.pop();\\n         int cost=top[0];\\n         int x=top[1];\\n         int y=top[2];\\n         if(x==m-1 && y==n-1){\\n             return cost;\\n         }\\n         if(cost>dist[x][y]) continue;\\n         for(int i=0;i<4;i++)\\n         {   \\n             int nx=x+dx[i][0];\\n             int ny=y+dx[i][1];\\n             if(nx>=0 && nx<m && ny>=0 && ny<n)\\n             {  // here we calculate the distance of the adjacent \\n                //node from the current node\\n                int newdist;\\n                if(grid[nx][ny]>cost+1)\\n                {\\n                    if((grid[nx][ny]-cost)%2==0)\\n                    {\\n                        newdist=grid[nx][ny]+1;\\n                    }\\n                    else{\\n                        newdist=grid[nx][ny];\\n                    }\\n                }\\n                else{\\n                    newdist=cost+1;\\n                }\\n\\n                if(newdist<dist[nx][ny])\\n                {\\n                    dist[nx][ny]=newdist;\\n                    vector<int> t{newdist,nx,ny};\\n                    q.emplace(t); \\n                }\\n             } \\n         }\\n       }\\n\\n       return dist[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974862,
                "title": "java-with-bfs-and-heavy-comments-and-description",
                "content": "Absolutely, let\\'s highlight the key points for better clarity:\\n\\n1. **Problem Description:** The code addresses a problem where you\\'re given a 2D grid representing time requirements to visit each cell. The task is to find the minimum time to reach the bottom-right cell from the top-left cell while obeying certain rules.\\n\\n2. **Goal:** Calculate and return the minimum time needed to reach the bottom-right cell in the grid. If reaching the destination is impossible due to constraints, return -1.\\n\\n3. **Constraints Check:** Initially, the code checks if the top-right and bottom-left cells are unreachable, indicated by values greater than 1. If both are inaccessible, the function returns -1 immediately.\\n\\n4. **PriorityQueue Usage:** A `PriorityQueue` named `qu` is used to store instances of a class called `pair`. This queue manages cells to explore based on their associated times.\\n\\n5. **Visited Cells Tracking:** A boolean array named `vis` is used to keep track of visited cells.\\n\\n6. **Queue Initialization:** The queue starts with a `pair` representing the top-left cell and time 0.\\n\\n7. **Exploration Loop:** The code enters a loop to explore cells in the queue.\\n\\n8. **Dequeueing a Cell:** Inside the loop, a `pair` instance is removed from the queue for exploration.\\n\\n9. **Visited Cell Check:** If the current cell has already been visited, the loop skips to the next iteration.\\n\\n10. **Destination Check:** If the current cell is the bottom-right cell, the function returns the time taken to reach it (`p.time`).\\n\\n11. **Possible Movements:** An array named `dir` holds the possible movement directions: right, down, up, and left.\\n\\n12. **Direction Loop:** A loop iterates through each direction in the `dir` array.\\n\\n13. **New Cell Calculation:** For each direction, coordinates of the new cell `(ii, jj)` are calculated by adding direction components to the current cell\\'s position `(p.i, p.j)`.\\n\\n14. **Bounds Check:** If the new cell is out of bounds, it\\'s ignored.\\n\\n15. **Time Calculation:** Time required to move to the new cell is computed as the difference between the cell\\'s value (`grid[ii][jj]`) and the current time (`p.time`).\\n\\n16. **Immediate Accessibility:** If the calculated time is less than or equal to 1, a new `pair` is added to the queue with an incremented time.\\n\\n17. **Time Parity Check:** If the time is greater than 1, it checks whether it\\'s even or odd:\\n    - Even time: A new `pair` is added with an adjusted time (`p.time + t + 1`).\\n    - Odd time: A new `pair` is added with the new time (`p.time + t`).\\n\\n18. **Loop Conclusion:** The loop continues until all movement directions are considered for the current cell.\\n\\n19. **Destination Unreachable:** If the loop finishes without reaching the destination, the function returns -1, indicating that the bottom-right cell cannot be reached within the given constraints.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // Define a class to store cell information\\n    class pair implements Comparable<pair> {\\n        int i;\\n        int j;\\n        int time;\\n\\n        // Constructor to initialize cell info\\n        pair(int i, int j, int time) {\\n            this.i = i;\\n            this.j = j;\\n            this.time = time;\\n        }\\n\\n        // Comparison method for PriorityQueue\\n        public int compareTo(pair p) {\\n            return this.time - p.time;\\n        }\\n\\n        // For debugging and clarity\\n        public String toString(){\\n            return this.i+\" \"+this.j+\" \"+this.time;\\n        }\\n    }\\n\\n    // Main method to find minimum time\\n    public int minimumTime(int[][] grid) {\\n\\n        // Check if initial cells are unreachable\\n        if (grid[0][1] > 1 && grid[1][0] > 1)\\n            return -1;\\n\\n        // Create a PriorityQueue for cell exploration\\n        PriorityQueue<pair> qu = new PriorityQueue<>();\\n\\n        // Create a 2D boolean array to track visited cells\\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n\\n        // Initialize the queue with the top-left cell\\n        qu.add(new pair(0, 0, 0));\\n\\n        // Exploration loop\\n        while (qu.size() > 0) {\\n\\n            // Dequeue a cell for exploration\\n            pair p = qu.remove();\\n\\n            // Skip if cell is already visited\\n            if (vis[p.i][p.j]) continue;\\n            vis[p.i][p.j] = true;\\n\\n            // Check if destination is reached\\n            if (p.i == grid.length-1 && p.j == grid[0].length-1) {\\n                return p.time; // Return minimum time\\n            }\\n\\n            // Define possible movement directions\\n            int[][] dir = { { 0, 1 }, { 1, 0 }, {-1, 0}, {0, -1} };\\n\\n            // Loop through possible directions\\n            for (int i = 0; i < dir.length; i++) {\\n                int ii = p.i + dir[i][0]; // Calculate new row coordinate\\n                int jj = p.j + dir[i][1]; // Calculate new column coordinate\\n\\n                // Skip if new cell is out of bounds\\n                if (ii >= grid.length || jj >= grid[0].length || ii < 0 || jj < 0)\\n                    continue;\\n\\n                int t = grid[ii][jj] - p.time; // Calculate time required\\n\\n                // Check if cell is immediately accessible\\n                if (t <= 1){\\n                    qu.add(new pair(ii, jj, p.time+1)); // Add with adjusted time\\n                } else {\\n                    // Adjust time based on parity\\n                    if (t % 2 == 0) {\\n                        qu.add(new pair(ii, jj, p.time + t + 1));\\n                    } else {\\n                        qu.add(new pair(ii, jj, p.time + t));\\n                    }\\n                }\\n            }\\n\\n        }\\n        return -1; // Destination is unreachable\\n    }\\n}\\n****Bold****\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // Define a class to store cell information\\n    class pair implements Comparable<pair> {\\n        int i;\\n        int j;\\n        int time;\\n\\n        // Constructor to initialize cell info\\n        pair(int i, int j, int time) {\\n            this.i = i;\\n            this.j = j;\\n            this.time = time;\\n        }\\n\\n        // Comparison method for PriorityQueue\\n        public int compareTo(pair p) {\\n            return this.time - p.time;\\n        }\\n\\n        // For debugging and clarity\\n        public String toString(){\\n            return this.i+\" \"+this.j+\" \"+this.time;\\n        }\\n    }\\n\\n    // Main method to find minimum time\\n    public int minimumTime(int[][] grid) {\\n\\n        // Check if initial cells are unreachable\\n        if (grid[0][1] > 1 && grid[1][0] > 1)\\n            return -1;\\n\\n        // Create a PriorityQueue for cell exploration\\n        PriorityQueue<pair> qu = new PriorityQueue<>();\\n\\n        // Create a 2D boolean array to track visited cells\\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n\\n        // Initialize the queue with the top-left cell\\n        qu.add(new pair(0, 0, 0));\\n\\n        // Exploration loop\\n        while (qu.size() > 0) {\\n\\n            // Dequeue a cell for exploration\\n            pair p = qu.remove();\\n\\n            // Skip if cell is already visited\\n            if (vis[p.i][p.j]) continue;\\n            vis[p.i][p.j] = true;\\n\\n            // Check if destination is reached\\n            if (p.i == grid.length-1 && p.j == grid[0].length-1) {\\n                return p.time; // Return minimum time\\n            }\\n\\n            // Define possible movement directions\\n            int[][] dir = { { 0, 1 }, { 1, 0 }, {-1, 0}, {0, -1} };\\n\\n            // Loop through possible directions\\n            for (int i = 0; i < dir.length; i++) {\\n                int ii = p.i + dir[i][0]; // Calculate new row coordinate\\n                int jj = p.j + dir[i][1]; // Calculate new column coordinate\\n\\n                // Skip if new cell is out of bounds\\n                if (ii >= grid.length || jj >= grid[0].length || ii < 0 || jj < 0)\\n                    continue;\\n\\n                int t = grid[ii][jj] - p.time; // Calculate time required\\n\\n                // Check if cell is immediately accessible\\n                if (t <= 1){\\n                    qu.add(new pair(ii, jj, p.time+1)); // Add with adjusted time\\n                } else {\\n                    // Adjust time based on parity\\n                    if (t % 2 == 0) {\\n                        qu.add(new pair(ii, jj, p.time + t + 1));\\n                    } else {\\n                        qu.add(new pair(ii, jj, p.time + t));\\n                    }\\n                }\\n            }\\n\\n        }\\n        return -1; // Destination is unreachable\\n    }\\n}\\n****Bold****\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966352,
                "title": "c-easy-code-djiktra-algo",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dr={1,-1,0,0};\\n    vector<int> dc={0,0,1,-1};\\n    int n,m;\\n    bool isvalid(int i,int j){\\n        return i>=0 and j>=0 and i<n and j<m;\\n    }\\n    int minimumTime(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        vector<vector<int>>dis(n,vector<int>(m,INT_MAX));\\n       \\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>q;\\n        if(grid[0][0]==0){\\n            dis[0][0]=0;\\n            q.push({0,0,0});//time x y\\n        }\\n        while(!q.empty()){\\n            vector<int>v=q.top();\\n            q.pop();\\n            int disi=v[0];\\n            int x=v[1];\\n            int y=v[2];\\n            if(grid[0][1]>1 and grid[1][0]>1)return -1;\\n            for(int k=0;k<4;k++){\\n                int tx=x+dr[k];\\n                int ty=y+dc[k];                \\n                if(isvalid(tx,ty)){\\n                    int diff=grid[tx][ty]-dis[x][y];\\n                    int jumps=max((int)ceil(1.0*(diff-1)/2)*2+1,1);\\n                    if(isvalid(tx,ty) and dis[tx][ty]>dis[x][y]+jumps and   dis[x][y]+jumps>=grid[tx][ty]){\\n                        dis[tx][ty]=dis[x][y]+jumps;\\n                        q.push({dis[tx][ty],tx,ty});\\n                    }\\n                }\\n            }\\n         }\\n        return  dis[n-1][m-1]>=INT_MAX?-1:dis[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dr={1,-1,0,0};\\n    vector<int> dc={0,0,1,-1};\\n    int n,m;\\n    bool isvalid(int i,int j){\\n        return i>=0 and j>=0 and i<n and j<m;\\n    }\\n    int minimumTime(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        vector<vector<int>>dis(n,vector<int>(m,INT_MAX));\\n       \\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>q;\\n        if(grid[0][0]==0){\\n            dis[0][0]=0;\\n            q.push({0,0,0});//time x y\\n        }\\n        while(!q.empty()){\\n            vector<int>v=q.top();\\n            q.pop();\\n            int disi=v[0];\\n            int x=v[1];\\n            int y=v[2];\\n            if(grid[0][1]>1 and grid[1][0]>1)return -1;\\n            for(int k=0;k<4;k++){\\n                int tx=x+dr[k];\\n                int ty=y+dc[k];                \\n                if(isvalid(tx,ty)){\\n                    int diff=grid[tx][ty]-dis[x][y];\\n                    int jumps=max((int)ceil(1.0*(diff-1)/2)*2+1,1);\\n                    if(isvalid(tx,ty) and dis[tx][ty]>dis[x][y]+jumps and   dis[x][y]+jumps>=grid[tx][ty]){\\n                        dis[tx][ty]=dis[x][y]+jumps;\\n                        q.push({dis[tx][ty],tx,ty});\\n                    }\\n                }\\n            }\\n         }\\n        return  dis[n-1][m-1]>=INT_MAX?-1:dis[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943755,
                "title": "djikstra-heavily-commented",
                "content": "Djikstra || Heavily commented\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        // Get the dimensions of the grid\\n        int m = grid.size(), n = grid[0].size();\\n\\n        // Check if starting positions are blocked\\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\\n            return -1; // No path is possible\\n        }\\n\\n        // Define possible movement directions: down, up, right, left\\n        vector<vector<int>> directions{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n\\n        // Create a 2D vector to mark visited cells\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n\\n        // Priority queue for Dijkstra\\'s algorithm with time, row, column\\n        priority_queue<vector<int>, vector<vector<int>>, greater<>> pq;\\n        pq.push({0, 0, 0}); // (time, row, column)\\n\\n        while (!pq.empty()) {\\n            auto cur = pq.top();\\n            int t = cur[0], r = cur[1], c = cur[2];\\n            pq.pop();\\n\\n            // Check if reached the destination\\n            if (r == m - 1 && c == n - 1) {\\n                return t; // Return the time taken\\n            }\\n\\n            // Skip already visited cells\\n            if (visited[r][c]) {\\n                continue;\\n            }\\n            visited[r][c] = true;\\n\\n            // Explore possible directions\\n            for (const auto& dir : directions) {\\n                int nr = r + dir[0], nc = c + dir[1];\\n\\n                // Skip if out of bounds or already visited\\n                if (nr < 0 || nr >= m || nc < 0 || nc >= n || visited[nr][nc]) {\\n                    continue;\\n                }\\n\\n                /* It\\'s similar to this idea, and it\\'s also implicitly not valid case like t+1==3 and g+1==4 :\\nif (grid[i][j]<=t+1)\\npq.push({t+1, i, j});\\nelse if ((grid[i][j]-t)%2==0)\\npq.push({grid[i][j]+1, i, j});\\nelse\\npq.push({grid[i][j], i, j});*/\\n\\n               // Calculate whether waiting is necessary\\nbool wait = (grid[nr][nc] - t) % 2 == 0;\\n// Here, we calculate whether waiting is necessary to synchronize with the time on the next cell (grid[nr][nc]).\\n// The condition checks if the difference between the time on the next cell and the current time (t) is even.\\n\\n// Calculate new time for the next cell\\nint nt = max(grid[nr][nc] + wait, t + 1);\\n// Here, we calculate the new time (nt) it takes to reach the next cell.\\n// If waiting is necessary (wait is true), then nt is set to the maximum value between the time on the next cell and (t + 1).\\n// This is done to ensure that we don\\'t move to the next cell before it\\'s safe to do so.\\n// If waiting is not necessary (wait is false), then nt is set to (grid[nr][nc] + 1) to indicate the next available time for movement.\\n\\n\\n                // Push the updated time, row, and column to the priority queue\\n                pq.push({nt, nr, nc});\\n            }\\n        }\\n        \\n        // If destination is not reachable\\n        return -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        // Get the dimensions of the grid\\n        int m = grid.size(), n = grid[0].size();\\n\\n        // Check if starting positions are blocked\\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\\n            return -1; // No path is possible\\n        }\\n\\n        // Define possible movement directions: down, up, right, left\\n        vector<vector<int>> directions{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n\\n        // Create a 2D vector to mark visited cells\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n\\n        // Priority queue for Dijkstra\\'s algorithm with time, row, column\\n        priority_queue<vector<int>, vector<vector<int>>, greater<>> pq;\\n        pq.push({0, 0, 0}); // (time, row, column)\\n\\n        while (!pq.empty()) {\\n            auto cur = pq.top();\\n            int t = cur[0], r = cur[1], c = cur[2];\\n            pq.pop();\\n\\n            // Check if reached the destination\\n            if (r == m - 1 && c == n - 1) {\\n                return t; // Return the time taken\\n            }\\n\\n            // Skip already visited cells\\n            if (visited[r][c]) {\\n                continue;\\n            }\\n            visited[r][c] = true;\\n\\n            // Explore possible directions\\n            for (const auto& dir : directions) {\\n                int nr = r + dir[0], nc = c + dir[1];\\n\\n                // Skip if out of bounds or already visited\\n                if (nr < 0 || nr >= m || nc < 0 || nc >= n || visited[nr][nc]) {\\n                    continue;\\n                }\\n\\n                /* It\\'s similar to this idea, and it\\'s also implicitly not valid case like t+1==3 and g+1==4 :\\nif (grid[i][j]<=t+1)\\npq.push({t+1, i, j});\\nelse if ((grid[i][j]-t)%2==0)\\npq.push({grid[i][j]+1, i, j});\\nelse\\npq.push({grid[i][j], i, j});*/\\n\\n               // Calculate whether waiting is necessary\\nbool wait = (grid[nr][nc] - t) % 2 == 0;\\n// Here, we calculate whether waiting is necessary to synchronize with the time on the next cell (grid[nr][nc]).\\n// The condition checks if the difference between the time on the next cell and the current time (t) is even.\\n\\n// Calculate new time for the next cell\\nint nt = max(grid[nr][nc] + wait, t + 1);\\n// Here, we calculate the new time (nt) it takes to reach the next cell.\\n// If waiting is necessary (wait is true), then nt is set to the maximum value between the time on the next cell and (t + 1).\\n// This is done to ensure that we don\\'t move to the next cell before it\\'s safe to do so.\\n// If waiting is not necessary (wait is false), then nt is set to (grid[nr][nc] + 1) to indicate the next available time for movement.\\n\\n\\n                // Push the updated time, row, and column to the priority queue\\n                pq.push({nt, nr, nc});\\n            }\\n        }\\n        \\n        // If destination is not reachable\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921393,
                "title": "easy-c-dijkstra-min-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    #define vi vector<int>\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int n = grid.size() , m = grid[0].size() ;\\n        priority_queue<vi , vector<vi> , greater<vi>>pq ;\\n        pq.push({0 , 0 , 0}) ;\\n        \\n        int dx[4] = {-1 ,1 ,0,0} ;\\n        int dy[4] = {0 , 0, -1 , 1} ;\\n        vector<vector<int>>time(n , vector<int>(m , -1)) ;\\n        time[0][0] = 0 ;\\n        while(pq.size()){\\n            int curr = pq.top()[0] ;\\n            int x = pq.top()[1] ;\\n            int y = pq.top()[2] ;\\n            pq.pop() ;\\n            if(x == n-1 && y == m-1){\\n                return curr ;\\n            }\\n            int cntL = 0 ;\\n            // we can only shift to grid value > 1 + curr iff there is atleast one neighbour of curr cell whose value is <= 1 + curr so that we can alternate b/w that node and curr node\\n            for(int k= 0 ; k<4 ; k++){\\n                int nx = x + dx[k] ;\\n                int ny = y + dy[k] ;\\n                if(nx >=0  && ny >= 0 && nx < n && ny < m && 1 + curr >= grid[nx][ny]){\\n                    cntL++ ;\\n                }\\n            }\\n            for(int k= 0 ; k<4 ; k++){\\n                int nx = x + dx[k] ;\\n                int ny = y + dy[k] ;\\n                if(nx >=0  && ny >= 0 && nx < n && ny < m){\\n                    if(time[nx][ny] != -1){\\n                        continue ;\\n                    }\\n                    if(grid[nx][ny] > 1 + curr){\\n                        if(cntL >= 1){\\n                            time[nx][ny] = grid[nx][ny] + ((grid[nx][ny] - curr)%2 ? 0 : 1) ;\\n                            pq.push({time[nx][ny] , nx , ny}) ;\\n                        }\\n                    }else{\\n                        time[nx][ny] = 1 + curr ;\\n                        pq.push({time[nx][ny] , nx , ny}) ;\\n                    }\\n                }\\n            }\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define vi vector<int>\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int n = grid.size() , m = grid[0].size() ;\\n        priority_queue<vi , vector<vi> , greater<vi>>pq ;\\n        pq.push({0 , 0 , 0}) ;\\n        \\n        int dx[4] = {-1 ,1 ,0,0} ;\\n        int dy[4] = {0 , 0, -1 , 1} ;\\n        vector<vector<int>>time(n , vector<int>(m , -1)) ;\\n        time[0][0] = 0 ;\\n        while(pq.size()){\\n            int curr = pq.top()[0] ;\\n            int x = pq.top()[1] ;\\n            int y = pq.top()[2] ;\\n            pq.pop() ;\\n            if(x == n-1 && y == m-1){\\n                return curr ;\\n            }\\n            int cntL = 0 ;\\n            // we can only shift to grid value > 1 + curr iff there is atleast one neighbour of curr cell whose value is <= 1 + curr so that we can alternate b/w that node and curr node\\n            for(int k= 0 ; k<4 ; k++){\\n                int nx = x + dx[k] ;\\n                int ny = y + dy[k] ;\\n                if(nx >=0  && ny >= 0 && nx < n && ny < m && 1 + curr >= grid[nx][ny]){\\n                    cntL++ ;\\n                }\\n            }\\n            for(int k= 0 ; k<4 ; k++){\\n                int nx = x + dx[k] ;\\n                int ny = y + dy[k] ;\\n                if(nx >=0  && ny >= 0 && nx < n && ny < m){\\n                    if(time[nx][ny] != -1){\\n                        continue ;\\n                    }\\n                    if(grid[nx][ny] > 1 + curr){\\n                        if(cntL >= 1){\\n                            time[nx][ny] = grid[nx][ny] + ((grid[nx][ny] - curr)%2 ? 0 : 1) ;\\n                            pq.push({time[nx][ny] , nx , ny}) ;\\n                        }\\n                    }else{\\n                        time[nx][ny] = 1 + curr ;\\n                        pq.push({time[nx][ny] , nx , ny}) ;\\n                    }\\n                }\\n            }\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818859,
                "title": "simplest-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Node{\\n\\n    int x;\\n    int y;\\n    int time;\\n    Node(int xx, int yy, int tt){\\n        x = xx;\\n        y = yy;\\n        time = tt;\\n    }\\n\\n}\\n\\nclass Solution {\\n    public int minimumTime(int[][] grid) {\\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        if(grid[0][1] > 1  && grid[1][0] > 1) return -1;\\n\\n        PriorityQueue<Node> pq = new PriorityQueue<>((a, b) -> a.time - b.time);\\n\\n        pq.add(new Node(0, 0, 0));\\n\\n        int[] xdir = { 0, 0, 1, -1};\\n        int[] ydir = { 1, -1, 0, 0};\\n\\n        int[][] vis = new int[m][n];\\n        for(int[] temp: vis) Arrays.fill(temp, -1);\\n\\n        while(!pq.isEmpty()){\\n\\n            Node curr = pq.remove();\\n\\n            if(curr.x == m-1 && curr.y == n-1) return curr.time;\\n\\n            vis[curr.x][curr.y] = 1;\\n\\n            int curr_time = curr.time + 1;\\n            \\n            for(int i =0; i<4; i++){\\n                int newx = curr.x + xdir[i];\\n                int newy = curr.y + ydir[i];\\n\\n                if(newx >= 0 && newy >= 0 && newx <m && newy < n && vis[newx][newy] == -1)\\n                {\\n\\n                    vis[newx][newy] =1;\\n\\n                    if(grid[newx][newy] <= curr_time){\\n                        pq.add(new Node(newx, newy, curr_time));\\n                    }\\n                    else{\\n                        if(( grid[newx][newy] - curr.time) % 2 == 0){\\n                            pq.add(new Node(newx, newy, grid[newx][newy] +1 ));\\n                        } else{\\n                            pq.add(new Node(newx, newy, grid[newx][newy] ));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n        return -1;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Node{\\n\\n    int x;\\n    int y;\\n    int time;\\n    Node(int xx, int yy, int tt){\\n        x = xx;\\n        y = yy;\\n        time = tt;\\n    }\\n\\n}\\n\\nclass Solution {\\n    public int minimumTime(int[][] grid) {\\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        if(grid[0][1] > 1  && grid[1][0] > 1) return -1;\\n\\n        PriorityQueue<Node> pq = new PriorityQueue<>((a, b) -> a.time - b.time);\\n\\n        pq.add(new Node(0, 0, 0));\\n\\n        int[] xdir = { 0, 0, 1, -1};\\n        int[] ydir = { 1, -1, 0, 0};\\n\\n        int[][] vis = new int[m][n];\\n        for(int[] temp: vis) Arrays.fill(temp, -1);\\n\\n        while(!pq.isEmpty()){\\n\\n            Node curr = pq.remove();\\n\\n            if(curr.x == m-1 && curr.y == n-1) return curr.time;\\n\\n            vis[curr.x][curr.y] = 1;\\n\\n            int curr_time = curr.time + 1;\\n            \\n            for(int i =0; i<4; i++){\\n                int newx = curr.x + xdir[i];\\n                int newy = curr.y + ydir[i];\\n\\n                if(newx >= 0 && newy >= 0 && newx <m && newy < n && vis[newx][newy] == -1)\\n                {\\n\\n                    vis[newx][newy] =1;\\n\\n                    if(grid[newx][newy] <= curr_time){\\n                        pq.add(new Node(newx, newy, curr_time));\\n                    }\\n                    else{\\n                        if(( grid[newx][newy] - curr.time) % 2 == 0){\\n                            pq.add(new Node(newx, newy, grid[newx][newy] +1 ));\\n                        } else{\\n                            pq.add(new Node(newx, newy, grid[newx][newy] ));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n        return -1;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759018,
                "title": "easy-dijkstra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int r, int c, vector<vector<int>>& grid) {\\n        int n = grid.size(); int m = grid[0].size();\\n        if(r<0 || c<0 || r>=n || c>=m )return 0 ;\\n        return 1; \\n    }\\n    int dx[4]= {0,1,0,-1};\\n    int dy[4]= {-1,0,1,0};\\n\\n    int minimumTime(vector<vector<int>>& grid) {\\n    \\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>q;\\n        q.push(make_pair(0,make_pair(0,0)));\\n\\n        int n = grid.size(); int m = grid[0].size(); int dist[n][m];\\n        \\n        if(grid[0][1]>=2 && grid[1][0]>=2)return -1 ;\\n\\n        for(int i =0 ; i<n ; i++){\\n            for(int j =0 ; j<m ; j++){\\n                dist[i][j]= 1e9 ;\\n            }\\n        }\\n         dist[0][0]=0;\\n\\n        while(!q.empty()){\\n\\n            pair<int,pair<int,int>>curr = q.top();\\n            int x = curr.second.first;\\n            int y = curr.second.second;\\n            // int time = curr.first;\\n            int currdist = dist[x][y];\\n            q.pop();\\n\\n            for(int dir = 0 ; dir<4 ; dir ++){\\n                int xx = x+dx[dir];\\n                int yy = y+dy[dir];\\n                if(check(xx,yy,grid)){\\n\\n                    if( (currdist+1 >= grid[xx][yy])){\\n                        if(dist[xx][yy] > currdist+1 ){\\n                            dist[xx][yy] = currdist+1;\\n                            q.push({dist[xx][yy],{xx,yy}});\\n                        }\\n                    }\\n                    else{\\n                        // if(x == 0 && y == 0 ){\\n                            \\n                        // }\\n                        // else{\\n                            int l = grid[xx][yy]-currdist;\\n                        \\n                                if( l%2 == 0){\\n                                    if(dist[xx][yy] > grid[xx][yy]+1 ){\\n                                        dist[xx][yy] = grid[xx][yy]+1;\\n                                        q.push({dist[xx][yy],{xx,yy}});\\n                                    }\\n                                }\\n                                else{\\n                                    if(dist[xx][yy] > grid[xx][yy]){\\n                                        dist[xx][yy] = grid[xx][yy];\\n                                        q.push({ grid[xx][yy],{xx,yy}});\\n                                    }\\n                                }\\n                        // }             \\n                    }\\n               }\\n            }\\n            \\n        }\\n        for(int i =0 ; i<n ; i++){\\n            for(int j =0 ; j<m ; j++){\\n                cout<<dist[i][j]<<\" \";\\n            }\\n            cout<<\\'\\\\n\\';\\n        }\\n        \\n        if(dist[n-1][m-1] == 1e9)return -1 ;\\n        else return dist[n-1][m-1];\\n     }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int r, int c, vector<vector<int>>& grid) {\\n        int n = grid.size(); int m = grid[0].size();\\n        if(r<0 || c<0 || r>=n || c>=m )return 0 ;\\n        return 1; \\n    }\\n    int dx[4]= {0,1,0,-1};\\n    int dy[4]= {-1,0,1,0};\\n\\n    int minimumTime(vector<vector<int>>& grid) {\\n    \\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>q;\\n        q.push(make_pair(0,make_pair(0,0)));\\n\\n        int n = grid.size(); int m = grid[0].size(); int dist[n][m];\\n        \\n        if(grid[0][1]>=2 && grid[1][0]>=2)return -1 ;\\n\\n        for(int i =0 ; i<n ; i++){\\n            for(int j =0 ; j<m ; j++){\\n                dist[i][j]= 1e9 ;\\n            }\\n        }\\n         dist[0][0]=0;\\n\\n        while(!q.empty()){\\n\\n            pair<int,pair<int,int>>curr = q.top();\\n            int x = curr.second.first;\\n            int y = curr.second.second;\\n            // int time = curr.first;\\n            int currdist = dist[x][y];\\n            q.pop();\\n\\n            for(int dir = 0 ; dir<4 ; dir ++){\\n                int xx = x+dx[dir];\\n                int yy = y+dy[dir];\\n                if(check(xx,yy,grid)){\\n\\n                    if( (currdist+1 >= grid[xx][yy])){\\n                        if(dist[xx][yy] > currdist+1 ){\\n                            dist[xx][yy] = currdist+1;\\n                            q.push({dist[xx][yy],{xx,yy}});\\n                        }\\n                    }\\n                    else{\\n                        // if(x == 0 && y == 0 ){\\n                            \\n                        // }\\n                        // else{\\n                            int l = grid[xx][yy]-currdist;\\n                        \\n                                if( l%2 == 0){\\n                                    if(dist[xx][yy] > grid[xx][yy]+1 ){\\n                                        dist[xx][yy] = grid[xx][yy]+1;\\n                                        q.push({dist[xx][yy],{xx,yy}});\\n                                    }\\n                                }\\n                                else{\\n                                    if(dist[xx][yy] > grid[xx][yy]){\\n                                        dist[xx][yy] = grid[xx][yy];\\n                                        q.push({ grid[xx][yy],{xx,yy}});\\n                                    }\\n                                }\\n                        // }             \\n                    }\\n               }\\n            }\\n            \\n        }\\n        for(int i =0 ; i<n ; i++){\\n            for(int j =0 ; j<m ; j++){\\n                cout<<dist[i][j]<<\" \";\\n            }\\n            cout<<\\'\\\\n\\';\\n        }\\n        \\n        if(dist[n-1][m-1] == 1e9)return -1 ;\\n        else return dist[n-1][m-1];\\n     }\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3753090,
                "title": "c-dijkstras-solution-clean-code",
                "content": "# Code\\n```\\ntypedef struct p_s {\\n    p_s(int _x, int _y, int _cost): x(_x), y(_y), cost(_cost) {}\\n    int x;\\n    int y;\\n    int cost;\\n} p_t;\\n\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int R = grid.size(), C = grid[0].size();\\n        auto cmp = [](const p_t& a, const p_t& b) {return a.cost > b.cost;};\\n        std::priority_queue<p_t, std::vector<p_t>, decltype(cmp)> pq(cmp);\\n\\n        if (C > 1 && grid[0][1] <= 1) pq.emplace(0, 1, 1);\\n        if (R > 1 && grid[1][0] <= 1) pq.emplace(1, 0, 1);\\n        std::vector<std::vector<bool>> visited(R, std::vector<bool>(C, false));\\n\\n        while(!pq.empty()) {\\n            auto [i, j, time] = pq.top(); pq.pop();\\n            if (i == R-1 && j == C-1) return time;\\n            if (visited[i][j]) continue;\\n            visited[i][j] = true;\\n\\n            if (i > 0) pq.emplace(i-1, j, time+(std::max(0, grid[i-1][j] - time)|1));\\n            if (i < R-1) pq.emplace(i+1, j, time+(std::max(0, grid[i+1][j] - time)|1));\\n            if (j > 0) pq.emplace(i, j-1, time+(std::max(0, grid[i][j-1] - time)|1));\\n            if (j < C-1) pq.emplace(i, j+1, time+(std::max(0, grid[i][j+1] - time)|1));\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef struct p_s {\\n    p_s(int _x, int _y, int _cost): x(_x), y(_y), cost(_cost) {}\\n    int x;\\n    int y;\\n    int cost;\\n} p_t;\\n\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int R = grid.size(), C = grid[0].size();\\n        auto cmp = [](const p_t& a, const p_t& b) {return a.cost > b.cost;};\\n        std::priority_queue<p_t, std::vector<p_t>, decltype(cmp)> pq(cmp);\\n\\n        if (C > 1 && grid[0][1] <= 1) pq.emplace(0, 1, 1);\\n        if (R > 1 && grid[1][0] <= 1) pq.emplace(1, 0, 1);\\n        std::vector<std::vector<bool>> visited(R, std::vector<bool>(C, false));\\n\\n        while(!pq.empty()) {\\n            auto [i, j, time] = pq.top(); pq.pop();\\n            if (i == R-1 && j == C-1) return time;\\n            if (visited[i][j]) continue;\\n            visited[i][j] = true;\\n\\n            if (i > 0) pq.emplace(i-1, j, time+(std::max(0, grid[i-1][j] - time)|1));\\n            if (i < R-1) pq.emplace(i+1, j, time+(std::max(0, grid[i+1][j] - time)|1));\\n            if (j > 0) pq.emplace(i, j-1, time+(std::max(0, grid[i][j-1] - time)|1));\\n            if (j < C-1) pq.emplace(i, j+1, time+(std::max(0, grid[i][j+1] - time)|1));\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691997,
                "title": "dijkstra-s-algo-java-solution-28-line-of-code-7ms-100-working",
                "content": "# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int minimumTime(int[][] grid) {\\n        if (grid[0][1] <= 1 || grid[1][0] <= 1) {\\n            int m = grid.length;\\n            int n = grid[0].length;\\n            PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n            Map<String, Integer> dist = new HashMap<>();\\n            pq.offer(new int[]{0, 0, 0});\\n            dist.put(\"0,0\", 0);\\n            \\n            while (!pq.isEmpty()) {\\n                int[] curr = pq.poll();\\n                int x = curr[0];\\n                int i = curr[1];\\n                int j = curr[2];\\n                \\n                if (i == m - 1 && j == n - 1) {\\n                    return x;\\n                }\\n                \\n                int[][] directions = {{i - 1, j}, {i, j - 1}, {i, j + 1}, {i + 1, j}};\\n                for (int[] dir : directions) {\\n                    int ii = dir[0];\\n                    int jj = dir[1];\\n                    \\n                    if (ii >= 0 && ii < m && jj >= 0 && jj < n) {\\n                        int xx = x + 1 + Math.max(0, (grid[ii][jj] - x) / 2 * 2);\\n                        String key = ii + \",\" + jj;\\n                        \\n                        if (!dist.containsKey(key) || dist.get(key) > xx) {\\n                            pq.offer(new int[]{xx, ii, jj});\\n                            dist.put(key, xx);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int minimumTime(int[][] grid) {\\n        if (grid[0][1] <= 1 || grid[1][0] <= 1) {\\n            int m = grid.length;\\n            int n = grid[0].length;\\n            PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n            Map<String, Integer> dist = new HashMap<>();\\n            pq.offer(new int[]{0, 0, 0});\\n            dist.put(\"0,0\", 0);\\n            \\n            while (!pq.isEmpty()) {\\n                int[] curr = pq.poll();\\n                int x = curr[0];\\n                int i = curr[1];\\n                int j = curr[2];\\n                \\n                if (i == m - 1 && j == n - 1) {\\n                    return x;\\n                }\\n                \\n                int[][] directions = {{i - 1, j}, {i, j - 1}, {i, j + 1}, {i + 1, j}};\\n                for (int[] dir : directions) {\\n                    int ii = dir[0];\\n                    int jj = dir[1];\\n                    \\n                    if (ii >= 0 && ii < m && jj >= 0 && jj < n) {\\n                        int xx = x + 1 + Math.max(0, (grid[ii][jj] - x) / 2 * 2);\\n                        String key = ii + \",\" + jj;\\n                        \\n                        if (!dist.containsKey(key) || dist.get(key) > xx) {\\n                            pq.offer(new int[]{xx, ii, jj});\\n                            dist.put(key, xx);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600486,
                "title": "dijkstra",
                "content": "> Dijkstra is to assemble Coder\\'s, Keep it in mind and go below.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    bool valid(int x, int y){\\n        if(x >= 0 and y >= 0 and x < n and y < m){\\n            return true;\\n        }\\n        return false;\\n    }\\n    vector<vector<int>>dp;\\n    void dijkstra(vector<vector<int>>&grid){\\n        multiset<pair<int, pair<int,int>>>s;\\n        s.insert({0,{0,0}});\\n        vector<vector<bool>>visited(n, vector<bool>(m));\\n        while(s.size()){\\n            auto it = s.begin();\\n            pair<int, pair<int,int>> P = *it;\\n            s.erase(it);\\n            int X = P.second.first; int Y = P.second.second;\\n            if(visited[X][Y]) continue;\\n            visited[X][Y] = true;\\n            if(valid(X-1, Y)){\\n                int cnt = 0;\\n                if((grid[X-1][Y]%2) == (dp[X][Y]%2)) cnt++;\\n                int weigh = max(1, grid[X-1][Y] - dp[X][Y] + cnt);\\n                if(dp[X-1][Y] > dp[X][Y] + weigh){\\n                    dp[X-1][Y] = dp[X][Y] + weigh;\\n                    s.insert({dp[X-1][Y], {X-1, Y}});\\n                }\\n            }\\n            if(valid(X+1, Y)){\\n                int cnt = 0;\\n                if((grid[X+1][Y]%2) == (dp[X][Y]%2)) cnt++;\\n                int weigh = max(1, grid[X+1][Y] - dp[X][Y] + cnt);\\n                if(dp[X+1][Y] > dp[X][Y] + weigh){\\n                    dp[X+1][Y] = dp[X][Y] + weigh;\\n                    s.insert({dp[X+1][Y], {X+1, Y}});\\n                }\\n            }\\n            if(valid(X, Y-1)){\\n                int cnt = 0;\\n                if((grid[X][Y-1]%2) == (dp[X][Y]%2)) cnt++;\\n                int weigh = max(1, grid[X][Y-1] - dp[X][Y] + cnt);\\n                if(dp[X][Y-1] > dp[X][Y] + weigh){\\n                    dp[X][Y-1] = dp[X][Y] + weigh;\\n                    s.insert({dp[X][Y-1], {X, Y-1}});\\n                }\\n            }\\n            if(valid(X, Y+1)){\\n                int cnt = 0;\\n                if((grid[X][Y+1]%2) == (dp[X][Y]%2)) cnt++;\\n                int weigh = max(1, grid[X][Y+1] - dp[X][Y] + cnt);\\n                if(dp[X][Y+1] > dp[X][Y] + weigh){\\n                    dp[X][Y+1] = dp[X][Y] + weigh;\\n                    s.insert({dp[X][Y+1], {X, Y+1}});\\n                }\\n            }\\n        }\\n    }\\n    int minimumTime(vector<vector<int>>& grid) {\\n        n = grid.size(); m = grid[0].size();\\n        if(grid[0][1] > 1 and grid[1][0] > 1){\\n            return -1;\\n        }\\n        dp = vector<vector<int>>(n, vector<int>(m, INT_MAX));\\n        dp[0][0] = 0;\\n        dijkstra(grid);\\n\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, m;\\n    bool valid(int x, int y){\\n        if(x >= 0 and y >= 0 and x < n and y < m){\\n            return true;\\n        }\\n        return false;\\n    }\\n    vector<vector<int>>dp;\\n    void dijkstra(vector<vector<int>>&grid){\\n        multiset<pair<int, pair<int,int>>>s;\\n        s.insert({0,{0,0}});\\n        vector<vector<bool>>visited(n, vector<bool>(m));\\n        while(s.size()){\\n            auto it = s.begin();\\n            pair<int, pair<int,int>> P = *it;\\n            s.erase(it);\\n            int X = P.second.first; int Y = P.second.second;\\n            if(visited[X][Y]) continue;\\n            visited[X][Y] = true;\\n            if(valid(X-1, Y)){\\n                int cnt = 0;\\n                if((grid[X-1][Y]%2) == (dp[X][Y]%2)) cnt++;\\n                int weigh = max(1, grid[X-1][Y] - dp[X][Y] + cnt);\\n                if(dp[X-1][Y] > dp[X][Y] + weigh){\\n                    dp[X-1][Y] = dp[X][Y] + weigh;\\n                    s.insert({dp[X-1][Y], {X-1, Y}});\\n                }\\n            }\\n            if(valid(X+1, Y)){\\n                int cnt = 0;\\n                if((grid[X+1][Y]%2) == (dp[X][Y]%2)) cnt++;\\n                int weigh = max(1, grid[X+1][Y] - dp[X][Y] + cnt);\\n                if(dp[X+1][Y] > dp[X][Y] + weigh){\\n                    dp[X+1][Y] = dp[X][Y] + weigh;\\n                    s.insert({dp[X+1][Y], {X+1, Y}});\\n                }\\n            }\\n            if(valid(X, Y-1)){\\n                int cnt = 0;\\n                if((grid[X][Y-1]%2) == (dp[X][Y]%2)) cnt++;\\n                int weigh = max(1, grid[X][Y-1] - dp[X][Y] + cnt);\\n                if(dp[X][Y-1] > dp[X][Y] + weigh){\\n                    dp[X][Y-1] = dp[X][Y] + weigh;\\n                    s.insert({dp[X][Y-1], {X, Y-1}});\\n                }\\n            }\\n            if(valid(X, Y+1)){\\n                int cnt = 0;\\n                if((grid[X][Y+1]%2) == (dp[X][Y]%2)) cnt++;\\n                int weigh = max(1, grid[X][Y+1] - dp[X][Y] + cnt);\\n                if(dp[X][Y+1] > dp[X][Y] + weigh){\\n                    dp[X][Y+1] = dp[X][Y] + weigh;\\n                    s.insert({dp[X][Y+1], {X, Y+1}});\\n                }\\n            }\\n        }\\n    }\\n    int minimumTime(vector<vector<int>>& grid) {\\n        n = grid.size(); m = grid[0].size();\\n        if(grid[0][1] > 1 and grid[1][0] > 1){\\n            return -1;\\n        }\\n        dp = vector<vector<int>>(n, vector<int>(m, INT_MAX));\\n        dp[0][0] = 0;\\n        dijkstra(grid);\\n\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598638,
                "title": "c-round-to-the-next-odd-number",
                "content": "# Code\\n```\\nusing pi = tuple<int, int, int>;\\nint dir[5] = { 0, 1, 0, -1, 0 };\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        priority_queue<pi, vector<pi>, greater<>> q;\\n        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));\\n        q.push({ 0, 0, 0 });\\n        while (!q.empty()) {\\n            auto [d, i, j] = q.top();\\n            q.pop();\\n            if (i == n - 1 && j == m - 1) return d;\\n            for (int di = 0; di < 4; di++) {\\n                int ii = i + dir[di];\\n                int jj = j + dir[di+1];\\n                if (ii < 0 || ii == n || jj < 0 || jj == m) continue;\\n                int newCost = INT_MAX;\\n                if (d + 1 >= grid[ii][jj]) {\\n                    newCost = d + 1;\\n                } else {\\n                    int diff = grid[ii][jj] - d;\\n                    if (d > 0) {\\n                        newCost = d + (diff | 1);\\n                    } \\n                }\\n                if (dist[ii][jj] > newCost) {\\n                    dist[ii][jj] = newCost;\\n                    q.push({ newCost, ii, jj });\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nusing pi = tuple<int, int, int>;\\nint dir[5] = { 0, 1, 0, -1, 0 };\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        priority_queue<pi, vector<pi>, greater<>> q;\\n        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));\\n        q.push({ 0, 0, 0 });\\n        while (!q.empty()) {\\n            auto [d, i, j] = q.top();\\n            q.pop();\\n            if (i == n - 1 && j == m - 1) return d;\\n            for (int di = 0; di < 4; di++) {\\n                int ii = i + dir[di];\\n                int jj = j + dir[di+1];\\n                if (ii < 0 || ii == n || jj < 0 || jj == m) continue;\\n                int newCost = INT_MAX;\\n                if (d + 1 >= grid[ii][jj]) {\\n                    newCost = d + 1;\\n                } else {\\n                    int diff = grid[ii][jj] - d;\\n                    if (d > 0) {\\n                        newCost = d + (diff | 1);\\n                    } \\n                }\\n                if (dist[ii][jj] > newCost) {\\n                    dist[ii][jj] = newCost;\\n                    q.push({ newCost, ii, jj });\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457851,
                "title": "c-dijkstras-algorithm-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        set<vector<int>> s;\\n        vector<vector<int>> dis(n,vector<int>(m,INT_MAX));\\n        dis[0][0] = 0;\\n        if(grid[0][1]>1 && grid[1][0]>1)\\n        return -1;\\n        s.insert({0,0,0});\\n        int time = 0;\\n        int up[4] = {-1,1,0,0};\\n        int dw[4] = {0,0,-1,1};\\n\\n        while(!s.empty())\\n        {\\n            vector<int> v = *s.begin(); s.erase(s.begin());\\n            int currtime = v[0];\\n            int x = v[1];\\n            int y = v[2];\\n\\n            for(int i=0;i<4;i++)\\n            {\\n                int x2 = x+up[i];\\n                int y2 = y+dw[i];\\n                \\n                    if(x2<n && y2<m && x2>=0 && y2>=0)\\n                    {\\n                        int d = 1;\\n                        if(currtime<grid[x2][y2]-1)\\n                        {\\n                             d = grid[x2][y2]- currtime;\\n                            if(d%2==0)\\n                            d++;\\n                            \\n                        }\\n                         if(currtime+d<dis[x2][y2]){\\n                            s.insert({currtime+d,x2,y2});\\n                            dis[x2][y2] = currtime+d;\\n                           }\\n                       \\n                    }\\n                \\n            }\\n        }\\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     for(int j=0;j<m;j++)\\n        //     cout<<dis[i][j]<<\" \";\\n        //     cout<<endl;\\n        // }\\n        return dis[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        set<vector<int>> s;\\n        vector<vector<int>> dis(n,vector<int>(m,INT_MAX));\\n        dis[0][0] = 0;\\n        if(grid[0][1]>1 && grid[1][0]>1)\\n        return -1;\\n        s.insert({0,0,0});\\n        int time = 0;\\n        int up[4] = {-1,1,0,0};\\n        int dw[4] = {0,0,-1,1};\\n\\n        while(!s.empty())\\n        {\\n            vector<int> v = *s.begin(); s.erase(s.begin());\\n            int currtime = v[0];\\n            int x = v[1];\\n            int y = v[2];\\n\\n            for(int i=0;i<4;i++)\\n            {\\n                int x2 = x+up[i];\\n                int y2 = y+dw[i];\\n                \\n                    if(x2<n && y2<m && x2>=0 && y2>=0)\\n                    {\\n                        int d = 1;\\n                        if(currtime<grid[x2][y2]-1)\\n                        {\\n                             d = grid[x2][y2]- currtime;\\n                            if(d%2==0)\\n                            d++;\\n                            \\n                        }\\n                         if(currtime+d<dis[x2][y2]){\\n                            s.insert({currtime+d,x2,y2});\\n                            dis[x2][y2] = currtime+d;\\n                           }\\n                       \\n                    }\\n                \\n            }\\n        }\\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     for(int j=0;j<m;j++)\\n        //     cout<<dis[i][j]<<\" \";\\n        //     cout<<endl;\\n        // }\\n        return dis[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3440730,
                "title": "dijkstra-variation",
                "content": "Dijkstra algorithm is possible because if you chance to move from a cell to another in ith time then you can move at ith + even number of time(unless you are at 0, 0). This essentialy mean you can assume some even number of time as a wait time at that cell without worrying to move somewhere else which was already visited. So, if you are not updating those already visited cells, you won\\'t be ruining possibly already computed shortest time to those cells, and Dijkstra can work smoothly.\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        if(grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n        priority_queue<vector<int>, vector<vector<int> >, greater<vector<int> > > pq;\\n        vector<vector<int> >fixed(grid.size(), vector<int>(grid[0].size(), 0));\\n        vector<vector<int> >dist(grid.size(), vector<int>(grid[0].size(), INT_MAX));\\n        dist[0][0] = 0;\\n        pq.push({0, 0, 0});\\n        int i, j, t, d;\\n        while(!pq.empty()){\\n            i = pq.top()[1];\\n            j = pq.top()[2];\\n            t = pq.top()[0];\\n            pq.pop();\\n            if(fixed[i][j]) continue;\\n            fixed[i][j] = 1;\\n            t++;\\n            if(i > 0){\\n                d = t;\\n                if(d < grid[i - 1][j]) d = grid[i - 1][j] + ((grid[i - 1][j] - d)&1);\\n                if(dist[i - 1][j] > d){\\n                    pq.push({d, i - 1, j});\\n                    dist[i - 1][j] = d;\\n                }\\n            }\\n            if(j > 0){\\n                d = t;\\n                if(d < grid[i][j - 1]) d = grid[i][j - 1] + ((grid[i][j - 1] - d)&1);\\n                if(dist[i][j - 1] > d){\\n                    pq.push({d, i, j - 1});\\n                    dist[i][j - 1] = d;\\n                }\\n            }\\n            if(i < grid.size() - 1){\\n                d = t;\\n                if(d < grid[i + 1][j]) d = grid[i + 1][j] + ((grid[i + 1][j] - d)&1);\\n                if(dist[i + 1][j] > d){\\n                    pq.push({d, i + 1, j});\\n                    dist[i + 1][j] = d;\\n                }\\n            }\\n            if(j < grid[0].size() - 1){\\n                d = t;\\n                if(d < grid[i][j + 1]) d = grid[i][j + 1] + ((grid[i][j + 1] - d)&1);\\n                if(dist[i][j + 1] > d){\\n                    pq.push({d, i, j + 1});\\n                    dist[i][j + 1] = d;\\n                }\\n            }\\n        }\\n        return dist[grid.size() - 1][grid[0].size() - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        if(grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n        priority_queue<vector<int>, vector<vector<int> >, greater<vector<int> > > pq;\\n        vector<vector<int> >fixed(grid.size(), vector<int>(grid[0].size(), 0));\\n        vector<vector<int> >dist(grid.size(), vector<int>(grid[0].size(), INT_MAX));\\n        dist[0][0] = 0;\\n        pq.push({0, 0, 0});\\n        int i, j, t, d;\\n        while(!pq.empty()){\\n            i = pq.top()[1];\\n            j = pq.top()[2];\\n            t = pq.top()[0];\\n            pq.pop();\\n            if(fixed[i][j]) continue;\\n            fixed[i][j] = 1;\\n            t++;\\n            if(i > 0){\\n                d = t;\\n                if(d < grid[i - 1][j]) d = grid[i - 1][j] + ((grid[i - 1][j] - d)&1);\\n                if(dist[i - 1][j] > d){\\n                    pq.push({d, i - 1, j});\\n                    dist[i - 1][j] = d;\\n                }\\n            }\\n            if(j > 0){\\n                d = t;\\n                if(d < grid[i][j - 1]) d = grid[i][j - 1] + ((grid[i][j - 1] - d)&1);\\n                if(dist[i][j - 1] > d){\\n                    pq.push({d, i, j - 1});\\n                    dist[i][j - 1] = d;\\n                }\\n            }\\n            if(i < grid.size() - 1){\\n                d = t;\\n                if(d < grid[i + 1][j]) d = grid[i + 1][j] + ((grid[i + 1][j] - d)&1);\\n                if(dist[i + 1][j] > d){\\n                    pq.push({d, i + 1, j});\\n                    dist[i + 1][j] = d;\\n                }\\n            }\\n            if(j < grid[0].size() - 1){\\n                d = t;\\n                if(d < grid[i][j + 1]) d = grid[i][j + 1] + ((grid[i][j + 1] - d)&1);\\n                if(dist[i][j + 1] > d){\\n                    pq.push({d, i, j + 1});\\n                    dist[i][j + 1] = d;\\n                }\\n            }\\n        }\\n        return dist[grid.size() - 1][grid[0].size() - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415366,
                "title": "c-easy-solution-with-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(MN(log(MN)))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(MN)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> r={1,-1,0,0};\\n    vector<int> c={0,0,1,-1};\\n\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n\\n        if(grid[0][1]>1 && grid[1][0]>1) return -1;\\n\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n\\n        pq.push({0,{0,0}});\\n        vis[0][0]=1;\\n\\n        while(!pq.empty()){\\n            int row=pq.top().second.first;\\n            int col=pq.top().second.second;\\n            int dis=pq.top().first;\\n\\n            pq.pop();\\n\\n            if(row==n-1 && col==m-1){\\n                return dis;\\n            }\\n\\n            for(int i=0;i<4;i++){\\n                int ro = row + r[i];\\n                int co = col + c[i];\\n\\n                if(ro>=0 && ro<n && co>=0 && co<m && !vis[ro][co]){\\n                    if(grid[ro][co]<=dis+1){\\n                        pq.push({dis+1,{ro,co}});\\n                        vis[ro][co]=1;\\n                    }\\n                    else {\\n                        /// Important Note:\\n                        /// We are calculating the difference to find the number of steps to visit a cell \\n                        /// whose value is greater than current time \\n                        /// As we are using priority queue ,so it will take care of minimum steps to \\n                        /// the destination.\\n\\n\\n                        /// For Example \\n                        /// [[0,1,4]\\n                        ///  [3,4,9]\\n                        ///  [1,0,4]]\\n\\n                        /// If we want to visit 9 from 4 , diff is 9-4=5 (odd) ,then we need to take steps\\n                        /// (4->3),(3->4),(4->3),(3->4),(4->9) to reach to 9\\n                        ///  5      6      7      8      9-------> Finally reached 9 in 5 steps i.e \\n                        ///  grid[i][j] of time it will take to reach destination grid[i][j] which is 9 \\n                        ///  when diff is odd.\\n\\n                        /// For Example \\n                        /// [[0,1,4]\\n                        ///  [3,5,9]\\n                        ///  [1,0,4]]\\n\\n                        /// If we want to visit 9 from 5 , diff is 9-5=4 (even) ,then we need to take\\n                        /// steps (5->3),(3->5),(5->3),(3->5),(5->9) to reach to 9.\\n                        ///        6      7      8      9      10-------> Finally reached 9 in 5 steps i.e\\n                        /// grid[i][j]+1 of time it required to reach destination grid[i][j] which is 9 in\\n                        /// this case when diff is even.\\n\\n                        int diff=grid[ro][co]-dis;\\n\\n                        if(diff%2==1){\\n                            pq.push({grid[ro][co],{ro,co}});\\n                            vis[ro][co]=1;\\n                        }\\n                        else {\\n                            pq.push({grid[ro][co]+1,{ro,co}});\\n                            vis[ro][co]=1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> r={1,-1,0,0};\\n    vector<int> c={0,0,1,-1};\\n\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n\\n        if(grid[0][1]>1 && grid[1][0]>1) return -1;\\n\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n\\n        pq.push({0,{0,0}});\\n        vis[0][0]=1;\\n\\n        while(!pq.empty()){\\n            int row=pq.top().second.first;\\n            int col=pq.top().second.second;\\n            int dis=pq.top().first;\\n\\n            pq.pop();\\n\\n            if(row==n-1 && col==m-1){\\n                return dis;\\n            }\\n\\n            for(int i=0;i<4;i++){\\n                int ro = row + r[i];\\n                int co = col + c[i];\\n\\n                if(ro>=0 && ro<n && co>=0 && co<m && !vis[ro][co]){\\n                    if(grid[ro][co]<=dis+1){\\n                        pq.push({dis+1,{ro,co}});\\n                        vis[ro][co]=1;\\n                    }\\n                    else {\\n                        /// Important Note:\\n                        /// We are calculating the difference to find the number of steps to visit a cell \\n                        /// whose value is greater than current time \\n                        /// As we are using priority queue ,so it will take care of minimum steps to \\n                        /// the destination.\\n\\n\\n                        /// For Example \\n                        /// [[0,1,4]\\n                        ///  [3,4,9]\\n                        ///  [1,0,4]]\\n\\n                        /// If we want to visit 9 from 4 , diff is 9-4=5 (odd) ,then we need to take steps\\n                        /// (4->3),(3->4),(4->3),(3->4),(4->9) to reach to 9\\n                        ///  5      6      7      8      9-------> Finally reached 9 in 5 steps i.e \\n                        ///  grid[i][j] of time it will take to reach destination grid[i][j] which is 9 \\n                        ///  when diff is odd.\\n\\n                        /// For Example \\n                        /// [[0,1,4]\\n                        ///  [3,5,9]\\n                        ///  [1,0,4]]\\n\\n                        /// If we want to visit 9 from 5 , diff is 9-5=4 (even) ,then we need to take\\n                        /// steps (5->3),(3->5),(5->3),(3->5),(5->9) to reach to 9.\\n                        ///        6      7      8      9      10-------> Finally reached 9 in 5 steps i.e\\n                        /// grid[i][j]+1 of time it required to reach destination grid[i][j] which is 9 in\\n                        /// this case when diff is even.\\n\\n                        int diff=grid[ro][co]-dis;\\n\\n                        if(diff%2==1){\\n                            pq.push({grid[ro][co],{ro,co}});\\n                            vis[ro][co]=1;\\n                        }\\n                        else {\\n                            pq.push({grid[ro][co]+1,{ro,co}});\\n                            vis[ro][co]=1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414312,
                "title": "bfs-with-priorityqueue",
                "content": "# Approach\\n## Breadth first search with PriorityQueue\\nThe gerenal approach presented herein is rather simple: a cell can be visited after a neighboring cell has been visited, and at least its value in time has passed. A PriorityQueue is used to conduct the BFS in the order of temporal reachability.\\n\\nWe start at time 0 on (0, 0) and continue according to the following algorithm:\\n - Dequeue the next (in time) element that can be reached\\n - Check if we reached the target cell\\n - Find coordinates of four neighboring grid cells\\n - For each of them:\\n    - Check that they are within the grid and have not yet been visited\\n    - calculate the earliest time they can be reached: $$\\\\min(currentTime~+~1,~gridEntry)$$\\n    - Enqueue them using the calculated time as priority\\n\\n## Parity of grid entries\\nEvery second, exactly one move must be made. Noving one step back and one forward will take two seconds, there is no possibility to walk a closed loop while spending an uneven number of seconds. Therefore, grid cells in even distance from the origin can only be reached in an even number of seconds, grid cells in uneven distance can only be reached in an uneven number of seconds.\\nWe can account for this by incrementing the grid values of cells by one if:\\n - They have even distance from the origin, but uneven value\\n - They have uneven distance from the origin, but even value\\n\\n## Unreachability\\nThe only way to grt stuck is if it is not possible to make any move to wait. That can only happen when stuck on the origin. We are stuck on the origin if both adjacent fields have a value greater than one. In all other cases, it is possible to wait by repeatedly moving between two adjacent fields.\\n\\n# Complexity\\n- Time complexity:\\n$$O(mn)$$\\n\\n- Space complexity:\\n$$O(mn)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimumTime(int[][] grid) {\\n        int m = grid.Length, n = grid[0].Length;\\n\\n        //make sure only odd/even of grid entries is correct, so that no cell is entered at wrong parity\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(grid[i][j] % 2 != (i + j) % 2)\\n                    grid[i][j]++;\\n        \\n        //only case where no path can be found\\n        if(grid[1][0] >= 2 && grid[0][1] >= 2)\\n            return -1;\\n\\n        // DFS with priorityQueue\\n        var queue = new PriorityQueue<(int x, int y), int>();\\n        queue.Enqueue((0, 0), 0);           //start at (0, 0) at time 0\\n        bool[,] visited = new bool[m, n];   //remember visited fields to not visit them again    \\n        int time = 0;                       //current time\\n        (int x, int y) curr;                //current cell\\n        while(queue.TryDequeue(out curr, out time))\\n        {\\n            if(curr == (m - 1, n - 1))\\n                return time;\\n            var neighbors = new (int x, int y)[] {(curr.x + 1, curr.y),\\n                                            (curr.x - 1, curr.y),\\n                                            (curr.x, curr.y + 1),\\n                                            (curr.x, curr.y - 1)};\\n            foreach(var next in neighbors)\\n            {\\n                if(next.x < 0 || next.y < 0 || next.x >= m || next.y >= n || visited[next.x, next.y])\\n                    continue;\\n                visited[next.x, next.y] = true;\\n                queue.Enqueue(next, Math.Max(time + 1, grid[next.x][next.y]));                                \\n            }\\n        }\\n        return -1;  //should never be reached\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimumTime(int[][] grid) {\\n        int m = grid.Length, n = grid[0].Length;\\n\\n        //make sure only odd/even of grid entries is correct, so that no cell is entered at wrong parity\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(grid[i][j] % 2 != (i + j) % 2)\\n                    grid[i][j]++;\\n        \\n        //only case where no path can be found\\n        if(grid[1][0] >= 2 && grid[0][1] >= 2)\\n            return -1;\\n\\n        // DFS with priorityQueue\\n        var queue = new PriorityQueue<(int x, int y), int>();\\n        queue.Enqueue((0, 0), 0);           //start at (0, 0) at time 0\\n        bool[,] visited = new bool[m, n];   //remember visited fields to not visit them again    \\n        int time = 0;                       //current time\\n        (int x, int y) curr;                //current cell\\n        while(queue.TryDequeue(out curr, out time))\\n        {\\n            if(curr == (m - 1, n - 1))\\n                return time;\\n            var neighbors = new (int x, int y)[] {(curr.x + 1, curr.y),\\n                                            (curr.x - 1, curr.y),\\n                                            (curr.x, curr.y + 1),\\n                                            (curr.x, curr.y - 1)};\\n            foreach(var next in neighbors)\\n            {\\n                if(next.x < 0 || next.y < 0 || next.x >= m || next.y >= n || visited[next.x, next.y])\\n                    continue;\\n                visited[next.x, next.y] = true;\\n                queue.Enqueue(next, Math.Max(time + 1, grid[next.x][next.y]));                                \\n            }\\n        }\\n        return -1;  //should never be reached\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407127,
                "title": "why-my-dijkstra-time-out",
                "content": "# Intuition\\nWhy my Dijkstra time out? Did I miss anything? I tried early exit but not helping.\\n\\n# Complexity\\n- Time complexity:\\nShould also be O(nlogn)\\n\\n# Code\\n```\\nclass Solution {\\n  \\n    int[][] directions = new int[][] {\\n      {0, 1},\\n      {1, 0},\\n      {-1, 0},\\n      {0, -1},\\n    };\\n  \\n    public int minimumTime(int[][] grid) {\\n      int m = grid.length;\\n      int n = grid[0].length;\\n      boolean[][] visited = new boolean[m][n];\\n      int[][] res = new int[m][n];\\n      if (grid[0][1] != 1 && grid[1][0] != 1) {\\n        return -1;\\n      }\\n      PriorityQueue<int[]> pq = new PriorityQueue<>(m * n, (a, b) -> a[0] - b[0]);\\n      pq.add(new int[] {0, 0, 0});\\n      while (!pq.isEmpty()) {\\n        int x = pq.peek()[1];\\n        int y = pq.peek()[2];\\n        int reachTime = pq.peek()[0];\\n        pq.poll();\\n        res[x][y] = reachTime;\\n        visited[x][y] = true;\\n        \\n        for (int[] d : directions) {\\n          int nextX = x + d[0];\\n          int nextY = y + d[1];\\n          int nextReachTime = 0;\\n          if (inScope(m, n, nextX, nextY) && !visited[nextX][nextY]) {\\n            if (grid[nextX][nextY] <= reachTime) {\\n              nextReachTime = reachTime + 1;\\n            } else if ((grid[nextX][nextY] - reachTime) % 2 == 1) {\\n              nextReachTime = grid[nextX][nextY];\\n            } else if ((grid[nextX][nextY] - reachTime) % 2 == 0) {\\n              nextReachTime = grid[nextX][nextY] + 1;\\n            }\\n            \\n            pq.add(new int[] {nextReachTime, nextX, nextY});\\n          }\\n        }\\n      }\\n      if (!visited[m - 1][n - 1]) {\\n        return -1;\\n      }  \\n      return res[m - 1][n - 1];\\n    }\\n      \\n    boolean inScope(int m, int n, int x, int y) {\\n      return 0 <= x && x < m && 0 <= y && y < n;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  \\n    int[][] directions = new int[][] {\\n      {0, 1},\\n      {1, 0},\\n      {-1, 0},\\n      {0, -1},\\n    };\\n  \\n    public int minimumTime(int[][] grid) {\\n      int m = grid.length;\\n      int n = grid[0].length;\\n      boolean[][] visited = new boolean[m][n];\\n      int[][] res = new int[m][n];\\n      if (grid[0][1] != 1 && grid[1][0] != 1) {\\n        return -1;\\n      }\\n      PriorityQueue<int[]> pq = new PriorityQueue<>(m * n, (a, b) -> a[0] - b[0]);\\n      pq.add(new int[] {0, 0, 0});\\n      while (!pq.isEmpty()) {\\n        int x = pq.peek()[1];\\n        int y = pq.peek()[2];\\n        int reachTime = pq.peek()[0];\\n        pq.poll();\\n        res[x][y] = reachTime;\\n        visited[x][y] = true;\\n        \\n        for (int[] d : directions) {\\n          int nextX = x + d[0];\\n          int nextY = y + d[1];\\n          int nextReachTime = 0;\\n          if (inScope(m, n, nextX, nextY) && !visited[nextX][nextY]) {\\n            if (grid[nextX][nextY] <= reachTime) {\\n              nextReachTime = reachTime + 1;\\n            } else if ((grid[nextX][nextY] - reachTime) % 2 == 1) {\\n              nextReachTime = grid[nextX][nextY];\\n            } else if ((grid[nextX][nextY] - reachTime) % 2 == 0) {\\n              nextReachTime = grid[nextX][nextY] + 1;\\n            }\\n            \\n            pq.add(new int[] {nextReachTime, nextX, nextY});\\n          }\\n        }\\n      }\\n      if (!visited[m - 1][n - 1]) {\\n        return -1;\\n      }  \\n      return res[m - 1][n - 1];\\n    }\\n      \\n    boolean inScope(int m, int n, int x, int y) {\\n      return 0 <= x && x < m && 0 <= y && y < n;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400273,
                "title": "c-solution-using-bfs-with-priority-queue-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int m = grid.size(),n= grid[0].size();\\n        priority_queue<pair<pair<int,int>,int>,vector<pair<pair<int,int>,int>>,greater<pair<pair<int,int>,int>>> pq;\\n        pq.push({{0,0},0}); //{time,x,y}\\n        \\n        if(grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n        int dx[4] = {1,0,-1,0};\\n        int dy[4] = {0,1,0,-1};\\n        \\n        vector<vector<bool>> vis(m,vector<bool>(n,false));\\n        vis[0][0] = true;\\n\\n        while(!pq.empty()){\\n            int t = pq.top().first.first, i=pq.top().first.second, j=pq.top().second;\\n            pq.pop();\\n\\n            if(i==m-1 && j==n-1) return t;\\n            for(int k=0;k<4;k++){\\n                int x = i + dx[k], y = j + dy[k];\\n\\n                if(x < 0 || y < 0 || x >= m || y >= n || vis[x][y]) continue;\\n\\n                bool isWaitEven = ((grid[x][y] - t) % 2 == 0);\\n                int newTime = max(grid[x][y] + isWaitEven,t+1);\\n       \\n                pq.push({{newTime,x},y});\\n                vis[x][y] = true;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int m = grid.size(),n= grid[0].size();\\n        priority_queue<pair<pair<int,int>,int>,vector<pair<pair<int,int>,int>>,greater<pair<pair<int,int>,int>>> pq;\\n        pq.push({{0,0},0}); //{time,x,y}\\n        \\n        if(grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n        int dx[4] = {1,0,-1,0};\\n        int dy[4] = {0,1,0,-1};\\n        \\n        vector<vector<bool>> vis(m,vector<bool>(n,false));\\n        vis[0][0] = true;\\n\\n        while(!pq.empty()){\\n            int t = pq.top().first.first, i=pq.top().first.second, j=pq.top().second;\\n            pq.pop();\\n\\n            if(i==m-1 && j==n-1) return t;\\n            for(int k=0;k<4;k++){\\n                int x = i + dx[k], y = j + dy[k];\\n\\n                if(x < 0 || y < 0 || x >= m || y >= n || vis[x][y]) continue;\\n\\n                bool isWaitEven = ((grid[x][y] - t) % 2 == 0);\\n                int newTime = max(grid[x][y] + isWaitEven,t+1);\\n       \\n                pq.push({{newTime,x},y});\\n                vis[x][y] = true;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362121,
                "title": "c-easy-solution-dijkastra-algorithm-optimal-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int r,int c,int n,int m){\\n        if(r>=0 && r<n && c>=0 && c<m){\\n            return true;\\n        }\\n        return false;\\n    }\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> q;\\n        vector<int> dir{-1,0,1,0,-1};\\n        vector<vector<int>> dist(n,vector<int>(m,INT_MAX));\\n        bool flag=false;\\n        if(n>=2){\\n            if(grid[1][0]-grid[0][0]<=1){\\n                flag=true;\\n            }\\n        }\\n        if(m>=2){\\n            if(grid[0][1]-grid[0][0]<=1){\\n                flag=true;\\n            }\\n        }\\n        if(!flag){\\n            return -1;\\n        }\\n        dist[0][0]=0;\\n        q.push({0,{0,0}});\\n        while(!q.empty()){\\n            int d=q.top().first;\\n            int r=q.top().second.first;\\n            int c=q.top().second.second;\\n            q.pop();\\n            for(int k=0;k<dir.size()-1;k++){\\n                int c_r=r+dir[k];\\n                int c_c=c+dir[k+1];\\n                if(isValid(c_r,c_c,n,m)){\\n                    if(d+1<grid[c_r][c_c]){\\n                        int di=grid[c_r][c_c]-d;\\n                        if(di%2==0){\\n                            dist[c_r][c_c]=grid[c_r][c_c]+1;\\n                        }else{\\n                            dist[c_r][c_c]=grid[c_r][c_c];\\n                        }\\n                        q.push({dist[c_r][c_c],{c_r,c_c}});\\n                    }else if(d+1<dist[c_r][c_c]){\\n                        dist[c_r][c_c]=d+1;\\n                        q.push({dist[c_r][c_c],{c_r,c_c}});\\n                    }\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1];\\n    }\\n};\\n```\\n# AUTHOR: JAYESH BADGUJAR\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int r,int c,int n,int m){\\n        if(r>=0 && r<n && c>=0 && c<m){\\n            return true;\\n        }\\n        return false;\\n    }\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> q;\\n        vector<int> dir{-1,0,1,0,-1};\\n        vector<vector<int>> dist(n,vector<int>(m,INT_MAX));\\n        bool flag=false;\\n        if(n>=2){\\n            if(grid[1][0]-grid[0][0]<=1){\\n                flag=true;\\n            }\\n        }\\n        if(m>=2){\\n            if(grid[0][1]-grid[0][0]<=1){\\n                flag=true;\\n            }\\n        }\\n        if(!flag){\\n            return -1;\\n        }\\n        dist[0][0]=0;\\n        q.push({0,{0,0}});\\n        while(!q.empty()){\\n            int d=q.top().first;\\n            int r=q.top().second.first;\\n            int c=q.top().second.second;\\n            q.pop();\\n            for(int k=0;k<dir.size()-1;k++){\\n                int c_r=r+dir[k];\\n                int c_c=c+dir[k+1];\\n                if(isValid(c_r,c_c,n,m)){\\n                    if(d+1<grid[c_r][c_c]){\\n                        int di=grid[c_r][c_c]-d;\\n                        if(di%2==0){\\n                            dist[c_r][c_c]=grid[c_r][c_c]+1;\\n                        }else{\\n                            dist[c_r][c_c]=grid[c_r][c_c];\\n                        }\\n                        q.push({dist[c_r][c_c],{c_r,c_c}});\\n                    }else if(d+1<dist[c_r][c_c]){\\n                        dist[c_r][c_c]=d+1;\\n                        q.push({dist[c_r][c_c],{c_r,c_c}});\\n                    }\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326366,
                "title": "java-comparator-priorityqueue-dyjtra-s-solution",
                "content": "```\\nclass Solution {\\n    class Node implements Comparable<Node> {\\n        int i;\\n        int j;\\n        int dis;\\n        public Node(int i , int j , int dis){\\n            this.i = i;\\n            this.j = j;\\n            this.dis = dis;\\n        }\\n        public int compareTo(Node node){\\n            return this.dis - node.dis;\\n        }\\n    }\\n    public int minimumTime(int[][] arr) {\\n        int[][] dir = {{-1,0},{1,0},{0,-1},{0,1}};\\n        int curTime = 0;\\n        int rows = arr.length;\\n        int ans = Integer.MAX_VALUE;\\n        int cols = arr[0].length;\\n        int[][] dis = new int[rows][cols];\\n        for(int i = 0 ; i < rows ; i++){\\n            for(int j = 0 ; j < cols ; j++){\\n                dis[i][j] = 1000000;\\n            }\\n        }\\n        dis[0][0] = 0;\\n        if(!check(arr)) return -1;\\n        PriorityQueue<Node> pq = new PriorityQueue<>();\\n        pq.add(new Node(0,0,0));\\n        while(!pq.isEmpty()){\\n            Node node = pq.poll();\\n            int i = node.i;\\n            int j = node.j;\\n            int time = node.dis;\\n            if(i == rows - 1 && j == cols - 1){\\n                ans = Math.min(ans , time);\\n            }\\n            for(int ptr = 0 ; ptr < 4 ; ptr++){\\n                int I = i + dir[ptr][0];\\n                int J = j + dir[ptr][1];\\n                if(I < rows && I >= 0 && J < cols && J >= 0){\\n                    if(time + 1 >= arr[I][J]){\\n                        if(dis[I][J] > time + 1){\\n                            dis[I][J] = time + 1;\\n                            pq.add(new Node(I , J , dis[I][J]));\\n                        }\\n                    }else{\\n                        int diff = arr[I][J] - time;\\n                        if(diff % 2 != 0){\\n                            if(dis[I][J] > arr[I][J]){\\n                                dis[I][J] = arr[I][J];\\n                                pq.add(new Node(I , J , arr[I][J]));\\n                            }\\n                        }else{\\n                            if(dis[I][J] > arr[I][J] + 1){\\n                                dis[I][J] = arr[I][J] + 1;\\n                                pq.add(new Node(I , J , arr[I][J] + 1));\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans == 1000000 ? -1 : ans;\\n    }\\n    private boolean check(int[][] arr){\\n        int rows = arr.length;\\n        int cols = arr[0].length;\\n        boolean ans = false;\\n        if(arr[0][0] != 0) return false;\\n        int[][] dir = {{-1,0},{1,0},{0,-1},{0,1}};\\n        int i = 0;\\n        int j = 0;\\n        for(int ptr = 0 ; ptr < 4 ; ptr++){\\n            int I = i + dir[ptr][0];\\n            int J = j + dir[ptr][1];\\n            if(I < rows && I >= 0 && J >= 0 && J < cols){\\n                if(arr[I][J] <= 1) ans = ans | true;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**Please UpVote, If found useful :)**",
                "solutionTags": [
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\n    class Node implements Comparable<Node> {\\n        int i;\\n        int j;\\n        int dis;\\n        public Node(int i , int j , int dis){\\n            this.i = i;\\n            this.j = j;\\n            this.dis = dis;\\n        }\\n        public int compareTo(Node node){\\n            return this.dis - node.dis;\\n        }\\n    }\\n    public int minimumTime(int[][] arr) {\\n        int[][] dir = {{-1,0},{1,0},{0,-1},{0,1}};\\n        int curTime = 0;\\n        int rows = arr.length;\\n        int ans = Integer.MAX_VALUE;\\n        int cols = arr[0].length;\\n        int[][] dis = new int[rows][cols];\\n        for(int i = 0 ; i < rows ; i++){\\n            for(int j = 0 ; j < cols ; j++){\\n                dis[i][j] = 1000000;\\n            }\\n        }\\n        dis[0][0] = 0;\\n        if(!check(arr)) return -1;\\n        PriorityQueue<Node> pq = new PriorityQueue<>();\\n        pq.add(new Node(0,0,0));\\n        while(!pq.isEmpty()){\\n            Node node = pq.poll();\\n            int i = node.i;\\n            int j = node.j;\\n            int time = node.dis;\\n            if(i == rows - 1 && j == cols - 1){\\n                ans = Math.min(ans , time);\\n            }\\n            for(int ptr = 0 ; ptr < 4 ; ptr++){\\n                int I = i + dir[ptr][0];\\n                int J = j + dir[ptr][1];\\n                if(I < rows && I >= 0 && J < cols && J >= 0){\\n                    if(time + 1 >= arr[I][J]){\\n                        if(dis[I][J] > time + 1){\\n                            dis[I][J] = time + 1;\\n                            pq.add(new Node(I , J , dis[I][J]));\\n                        }\\n                    }else{\\n                        int diff = arr[I][J] - time;\\n                        if(diff % 2 != 0){\\n                            if(dis[I][J] > arr[I][J]){\\n                                dis[I][J] = arr[I][J];\\n                                pq.add(new Node(I , J , arr[I][J]));\\n                            }\\n                        }else{\\n                            if(dis[I][J] > arr[I][J] + 1){\\n                                dis[I][J] = arr[I][J] + 1;\\n                                pq.add(new Node(I , J , arr[I][J] + 1));\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans == 1000000 ? -1 : ans;\\n    }\\n    private boolean check(int[][] arr){\\n        int rows = arr.length;\\n        int cols = arr[0].length;\\n        boolean ans = false;\\n        if(arr[0][0] != 0) return false;\\n        int[][] dir = {{-1,0},{1,0},{0,-1},{0,1}};\\n        int i = 0;\\n        int j = 0;\\n        for(int ptr = 0 ; ptr < 4 ; ptr++){\\n            int I = i + dir[ptr][0];\\n            int J = j + dir[ptr][1];\\n            if(I < rows && I >= 0 && J >= 0 && J < cols){\\n                if(arr[I][J] <= 1) ans = ans | true;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326034,
                "title": "c-dijkstra-s-algorithm-simple-easy-to-understand-code",
                "content": "# Intuition\\nWe need to find the shortest path to reach the bottom-right cell of the matrix. This indicates that we need to use Dijkstra.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nApply dijkstra\\'s algoritm on a grid and check with the neighbouring nodes the possible paths that can be taken. Each step we take will increase the `curr_time = curr_time + 1`. Using this approach the problem can be solved easily. We need to store `current time`, `current x and y indices` in the priority queue.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NM * log(NM))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(NM)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define tp tuple<int,int,int>\\nclass Solution {\\npublic:\\n    vector<int> dx = {0,0,1,-1};\\n    vector<int> dy = {1,-1,0,0};\\n\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        if(grid[1][0]>1 && grid[0][1]>1)\\n            return -1;\\n        \\n        vector<vector<int>> time(n,vector<int>(m,INT_MAX));\\n        \\n        priority_queue<tp, vector<tp>, greater<tp>> pq;\\n        pq.push({0,0,0});\\n        time[0][0] = 0;\\n\\n        while(!pq.empty())\\n        {\\n            auto [curr,i,j] = pq.top();\\n            pq.pop();\\n\\n            if(curr > time[i][j])\\n                continue;\\n\\n            if(i==n-1 && j==m-1)\\n                return curr;\\n            \\n            for(int k=0; k<4; k++)\\n            {\\n                int x = i + dx[k];\\n                int y = j + dy[k];\\n                int t = curr + 1;\\n\\n                if(x<0 || x>=n || y<0 || y>=m)\\n                    continue;\\n                \\n                if(grid[x][y] > t)\\n                {\\n                    int diff = grid[x][y] - t;\\n                    if(diff & 1)\\n                        diff++;\\n                    \\n                    t += diff;\\n                }\\n\\n                if(t < time[x][y])\\n                {\\n                    time[x][y] = t;\\n                    pq.push({t,x,y});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define tp tuple<int,int,int>\\nclass Solution {\\npublic:\\n    vector<int> dx = {0,0,1,-1};\\n    vector<int> dy = {1,-1,0,0};\\n\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        if(grid[1][0]>1 && grid[0][1]>1)\\n            return -1;\\n        \\n        vector<vector<int>> time(n,vector<int>(m,INT_MAX));\\n        \\n        priority_queue<tp, vector<tp>, greater<tp>> pq;\\n        pq.push({0,0,0});\\n        time[0][0] = 0;\\n\\n        while(!pq.empty())\\n        {\\n            auto [curr,i,j] = pq.top();\\n            pq.pop();\\n\\n            if(curr > time[i][j])\\n                continue;\\n\\n            if(i==n-1 && j==m-1)\\n                return curr;\\n            \\n            for(int k=0; k<4; k++)\\n            {\\n                int x = i + dx[k];\\n                int y = j + dy[k];\\n                int t = curr + 1;\\n\\n                if(x<0 || x>=n || y<0 || y>=m)\\n                    continue;\\n                \\n                if(grid[x][y] > t)\\n                {\\n                    int diff = grid[x][y] - t;\\n                    if(diff & 1)\\n                        diff++;\\n                    \\n                    t += diff;\\n                }\\n\\n                if(t < time[x][y])\\n                {\\n                    time[x][y] = t;\\n                    pq.push({t,x,y});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322470,
                "title": "rust-bfs-with-btreemap",
                "content": "Logic is basically the same as BinaryHeap solutions.\\n\\nKey of BTreeMap is the number of steps, and value is a Vec of cell coordinates.\\n\\nAdditional check for the 1st step is needed for the \"return -1\" special case.\\n\\n\"Visited\" status is marked by flipping all the bits of a `grid[i][j]` value by `!` operator.\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n- Space complexity: O(n)\\n\\nWhere n is total number of cells in the grid.\\n# Code\\n```\\nuse std::collections::BTreeMap;\\n\\nimpl Solution {\\n    pub fn minimum_time(mut grid: Vec<Vec<i32>>) -> i32 {\\n        let mut tree: BTreeMap<i32, Vec<(usize, usize)>> = BTreeMap::new();\\n        tree.insert(0, vec![(0, 0)]);\\n        grid[0][0] = -1;\\n        let dir = [0, 1, 0, usize::MAX, 0];\\n        while let Some(&step) = tree.keys().next() {\\n            let v = tree.remove(&step).unwrap();\\n            for &(i, j) in v.iter() {\\n                for w in dir.windows(2) {\\n                    let i2 = i.wrapping_add(w[0]);\\n                    let j2 = j.wrapping_add(w[1]);\\n                    if i2 < grid.len() && j2 < grid[0].len() {\\n                        if grid[i2][j2] >= 0 {\\n                            let step2 = if grid[i2][j2] > step + 1 {\\n                                grid[i2][j2] + 1 - ((grid[i2][j2] + step) & 1)\\n                            }\\n                            else {\\n                                step + 1\\n                            };\\n                            if i2 == grid.len() - 1 && j2 == grid[0].len() - 1 {\\n                                return step2;\\n                            }\\n                            tree.entry(step2).or_default().push((i2, j2));\\n                            grid[i2][j2] = !grid[i2][j2];\\n                        }\\n                    }\\n                }\\n            }\\n            if step == 0 && tree.get(&1).is_none() {\\n                return -1;\\n            }\\n        }\\n        unreachable!()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nuse std::collections::BTreeMap;\\n\\nimpl Solution {\\n    pub fn minimum_time(mut grid: Vec<Vec<i32>>) -> i32 {\\n        let mut tree: BTreeMap<i32, Vec<(usize, usize)>> = BTreeMap::new();\\n        tree.insert(0, vec![(0, 0)]);\\n        grid[0][0] = -1;\\n        let dir = [0, 1, 0, usize::MAX, 0];\\n        while let Some(&step) = tree.keys().next() {\\n            let v = tree.remove(&step).unwrap();\\n            for &(i, j) in v.iter() {\\n                for w in dir.windows(2) {\\n                    let i2 = i.wrapping_add(w[0]);\\n                    let j2 = j.wrapping_add(w[1]);\\n                    if i2 < grid.len() && j2 < grid[0].len() {\\n                        if grid[i2][j2] >= 0 {\\n                            let step2 = if grid[i2][j2] > step + 1 {\\n                                grid[i2][j2] + 1 - ((grid[i2][j2] + step) & 1)\\n                            }\\n                            else {\\n                                step + 1\\n                            };\\n                            if i2 == grid.len() - 1 && j2 == grid[0].len() - 1 {\\n                                return step2;\\n                            }\\n                            tree.entry(step2).or_default().push((i2, j2));\\n                            grid[i2][j2] = !grid[i2][j2];\\n                        }\\n                    }\\n                }\\n            }\\n            if step == 0 && tree.get(&1).is_none() {\\n                return -1;\\n            }\\n        }\\n        unreachable!()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3289919,
                "title": "c-clever-solution-top-95-5-clean-code",
                "content": "This Github repository have solution to every problem I looked for https://github.com/AnasImloul/Leetcode-solutions\\nIt is extremely beneficial to find your solutions in one place, I hope it is useful to you as well.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int n = (int)grid.size();\\n        int m = (int)grid[0].size();\\n\\n        if (grid[1][0] > 1 && grid[0][1] > 1) {\\n            return -1;  \\n        }\\n\\n        int dx[] = {0, 0, 1, -1};\\n        int dy[] = {1, -1, 0, 0};\\n\\n        priority_queue<pair<int, pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq; // time : x : y\\n\\n        int time[n][m];\\n        for(int i = 0; i < n; ++i){\\n            for(int j =0; j < m; ++j){\\n                time[i][j] = (int)1e9;\\n            }\\n        }        \\n\\n        pq.push({0,{0,0}});\\n        time[0][0] = 0;\\n        while(!pq.empty()){\\n            int curtime = pq.top().first;\\n            int curx = pq.top().second.first;\\n            int cury = pq.top().second.second;\\n            pq.pop();\\n            if(curtime > time[curx][cury]){\\n                continue;  \\n            }\\n            if(curx == n - 1 && cury == m - 1){\\n                return curtime;\\n            }\\n            for(int i = 0; i < 4 ; ++i){\\n                int newtime = curtime + 1;\\n                int nx = curx + dx[i];\\n                int ny = cury + dy[i];\\n                if(nx < 0 || nx >= n || ny < 0 || ny >=m){\\n                    continue;\\n                }\\n                if (grid[nx][ny] > newtime) {\\n                    int diff = grid[nx][ny] - newtime;\\n                    if (diff & 1) {\\n                        ++diff;\\n                    }\\n                    newtime = newtime + diff;\\n                }\\n                if(newtime < time[nx][ny]){\\n                    time[nx][ny] = newtime;\\n                    pq.push({newtime, {nx, ny}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int n = (int)grid.size();\\n        int m = (int)grid[0].size();\\n\\n        if (grid[1][0] > 1 && grid[0][1] > 1) {\\n            return -1;  \\n        }\\n\\n        int dx[] = {0, 0, 1, -1};\\n        int dy[] = {1, -1, 0, 0};\\n\\n        priority_queue<pair<int, pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq; // time : x : y\\n\\n        int time[n][m];\\n        for(int i = 0; i < n; ++i){\\n            for(int j =0; j < m; ++j){\\n                time[i][j] = (int)1e9;\\n            }\\n        }        \\n\\n        pq.push({0,{0,0}});\\n        time[0][0] = 0;\\n        while(!pq.empty()){\\n            int curtime = pq.top().first;\\n            int curx = pq.top().second.first;\\n            int cury = pq.top().second.second;\\n            pq.pop();\\n            if(curtime > time[curx][cury]){\\n                continue;  \\n            }\\n            if(curx == n - 1 && cury == m - 1){\\n                return curtime;\\n            }\\n            for(int i = 0; i < 4 ; ++i){\\n                int newtime = curtime + 1;\\n                int nx = curx + dx[i];\\n                int ny = cury + dy[i];\\n                if(nx < 0 || nx >= n || ny < 0 || ny >=m){\\n                    continue;\\n                }\\n                if (grid[nx][ny] > newtime) {\\n                    int diff = grid[nx][ny] - newtime;\\n                    if (diff & 1) {\\n                        ++diff;\\n                    }\\n                    newtime = newtime + diff;\\n                }\\n                if(newtime < time[nx][ny]){\\n                    time[nx][ny] = newtime;\\n                    pq.push({newtime, {nx, ny}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277827,
                "title": "dijstras-algorithm-based-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(M* N* Log(M*N)) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(M* N) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define PPI pair<int,pair<int,int>>\\n\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        priority_queue<PPI, vector<PPI>, greater<PPI>> pq; // time, row, col\\n        pq.push({0,{0,0}});\\n        vector<vector<int>> vis(n, vector<int>(m,0));\\n        vis[0][0] = 1;\\n\\n        if(grid[1][0] > 1 && grid[0][1] > 1)\\n            return -1; // as back forth not possible at all here\\n\\n        //Dijstras\\n        while(!pq.empty()){\\n            auto it = pq.top();\\n            pq.pop();\\n            int time = it.first;\\n            int r = it.second.first;\\n            int c = it.second.second;\\n            //vis[r][c] = 1;\\n\\n            //if we reach end, the first time we reach is the best\\n            //greedy - pq gives min most guy\\n            if(r == n-1 && c == m-1){\\n                return time;\\n            }\\n\\n            //4 directions\\n            int dr[] = {-1,0,1,0};\\n            int dc[] = {0,1,0,-1};\\n            for(int i=0;i<4; i++){\\n                int nr = r + dr[i];\\n                int nc = c + dc[i]; // new row and col\\n                if(nr>=0 && nr<n && nc>=0 && nc<m \\n                && vis[nr][nc] == 0){\\n                    //when we are able to visit the cell\\n                    if(grid[nr][nc] <= time+1){//+1 as it take to move 1 cell\\n                        pq.push({time+1, {nr,nc}});\\n                    }\\n                    else{\\n                        int diff = grid[nr][nc] - (time+1);\\n                        if(diff%2 ==0 ){\\n                            //evem leads to same guy\\n                            pq.push({grid[nr][nc], {nr, nc}});\\n                        }\\n                        else{\\n                            //odd diff, leads +1 to grid time\\n                            pq.push({grid[nr][nc] +1 , {nr, nc}});\\n                        }\\n                    }\\n                    vis[nr][nc] = 1;\\n                }\\n            }\\n            \\n        //we pick the smaller smaller guy to reach end node\\n        }\\n        \\n        return -1; // we cant reach end node at all\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define PPI pair<int,pair<int,int>>\\n\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        priority_queue<PPI, vector<PPI>, greater<PPI>> pq; // time, row, col\\n        pq.push({0,{0,0}});\\n        vector<vector<int>> vis(n, vector<int>(m,0));\\n        vis[0][0] = 1;\\n\\n        if(grid[1][0] > 1 && grid[0][1] > 1)\\n            return -1; // as back forth not possible at all here\\n\\n        //Dijstras\\n        while(!pq.empty()){\\n            auto it = pq.top();\\n            pq.pop();\\n            int time = it.first;\\n            int r = it.second.first;\\n            int c = it.second.second;\\n            //vis[r][c] = 1;\\n\\n            //if we reach end, the first time we reach is the best\\n            //greedy - pq gives min most guy\\n            if(r == n-1 && c == m-1){\\n                return time;\\n            }\\n\\n            //4 directions\\n            int dr[] = {-1,0,1,0};\\n            int dc[] = {0,1,0,-1};\\n            for(int i=0;i<4; i++){\\n                int nr = r + dr[i];\\n                int nc = c + dc[i]; // new row and col\\n                if(nr>=0 && nr<n && nc>=0 && nc<m \\n                && vis[nr][nc] == 0){\\n                    //when we are able to visit the cell\\n                    if(grid[nr][nc] <= time+1){//+1 as it take to move 1 cell\\n                        pq.push({time+1, {nr,nc}});\\n                    }\\n                    else{\\n                        int diff = grid[nr][nc] - (time+1);\\n                        if(diff%2 ==0 ){\\n                            //evem leads to same guy\\n                            pq.push({grid[nr][nc], {nr, nc}});\\n                        }\\n                        else{\\n                            //odd diff, leads +1 to grid time\\n                            pq.push({grid[nr][nc] +1 , {nr, nc}});\\n                        }\\n                    }\\n                    vis[nr][nc] = 1;\\n                }\\n            }\\n            \\n        //we pick the smaller smaller guy to reach end node\\n        }\\n        \\n        return -1; // we cant reach end node at all\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277393,
                "title": "a-few-solutions",
                "content": "Use Dijkstra\\'s algorithm to find the single-source-shortest-path from top-left source cell (0,0) to bottom-right destination cell (M-1, N-1).\\n\\n---\\n\\nWe return `-1` immediately if the source cell\\'s adjacent cells (0,1) and (1,0) exceed `1`, ie. we *cannot* move from the source cell.  Otherwise we can *always* hop back & forth to an arbitrary adjacent auxillary cell until we accumulate sufficient `time` to visit all cells, and there are 2 cases to consider for visiting adjacent cells:\\n  * **Case 1:** if the time difference `diff` is **even**, then we hop back & forth an **even** amount of steps\\n  * **Case 2:** if the time difference `diff` is **odd**, then we **still** hop back & forth an **even** amount of steps\\n\\nNote: we *cannot* hop back & forth an odd amount of steps since that\\'s impossible (ie. each hop back & forth counts as 2 steps).  Thus, we pay **+1** time cost when the difference `diff` is **odd**.\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/16ad90e7-6972-480a-9746-be43125aa1dd_1678384208.7306507.png)\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minimumTime(A: Array<IntArray>): Int {\\n        if (1 < A[0][1] && 1 < A[1][0])\\n            return -1\\n        var key = { i: Int, j: Int -> \"$i,$j\" }\\n        var (M, N) = Pair(A.size, A[0].size)\\n        var q = PriorityQueue<Triple<Int, Int, Int>>({ a, b -> a.first.compareTo(b.first) })\\n        q.add(Triple(0, 0, 0))\\n        var seen = mutableSetOf<String>(key(0, 0))\\n        while (true) {\\n            var (time, i, j) = q.poll()\\n            if (i == M - 1 && j == N - 1)\\n                return time\\n            ++time\\n            for ((u, v) in listOf(Pair(i - 1, j), Pair(i, j + 1), Pair(i + 1, j), Pair(i, j - 1))) {\\n                if (0 <= u && u < M && 0 <= v && v < N && !seen.contains(key(u, v))) {\\n                    var diff = Math.max(0, A[u][v] - time)\\n                    q.add(Triple(time + diff + (diff % 2), u, v)); seen.add(key(u, v))\\n                }\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet key = x => Array.isArray(x) ? x[0] : x;\\nlet heappush = (A, x, f = Math.min) => {\\n    let P = i => Math.floor((i - 1) / 2);  // parent\\n    A.push(x);\\n    let N = A.length,\\n        i = N - 1;\\n    while (0 < i && key(A[i]) == f(key(A[i]), key(A[P(i)]))) {\\n        [A[i], A[P(i)]] = [A[P(i)], A[i]];\\n        i = P(i);\\n    }\\n};\\nlet heappop = (A, f = Math.min) => {\\n    let L = i => 2 * i + 1,  // children\\n        R = i => 2 * i + 2;\\n    let N = A.length,\\n        i = 0;\\n    let top = A[0];\\n    [A[0], A[N - 1]] = [A[N - 1], A[0]], A.pop(), --N;\\n    let ok;\\n    do {\\n        ok = true;\\n        let left = f == Math.min ? Infinity : -Infinity,\\n            right = left;\\n        if (L(i) < N && key(A[i]) != f(key(A[i]), key(A[L(i)]))) ok = false, left  = key(A[L(i)]);\\n        if (R(i) < N && key(A[i]) != f(key(A[i]), key(A[R(i)]))) ok = false, right = key(A[R(i)]);\\n        if (!ok) {\\n            let j = left == f(left, right) ? L(i) : R(i);\\n            [A[i], A[j]] = [A[j], A[i]];\\n            i = j;\\n        }\\n    } while (!ok);\\n    return top;\\n};\\nlet minimumTime = A => {\\n    if (1 < A[0][1] && 1 < A[1][0])\\n        return -1;\\n    let key = (i, j) => `${i},${j}`;\\n    let [M, N] = [A.length, A[0].length];\\n    let [q, seen] = [[[0, 0, 0]], new Set([key(0, 0)])];\\n    for (;;) {\\n        let [time, i, j] = heappop(q);\\n        if (i == M - 1 && j == N - 1)\\n            return time;\\n        ++time;\\n        for (let [u, v] of [[i - 1, j], [i, j + 1], [i + 1, j], [i, j - 1]]) {\\n            if (0 <= u && u < M && 0 <= v && v < N && !seen.has(key(u, v))) {\\n                let diff = Math.max(0, A[u][v] - time);\\n                heappush(q, [time + diff + Number(diff & 1), u, v]), seen.add(key(u, v));\\n            }\\n        }\\n    }\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minimumTime(self, A: List[List[int]], T = 1e5) -> int:\\n        if 1 < A[0][1] and 1 < A[1][0]:\\n            return -1\\n        M, N = len(A), len(A[0])\\n        q, seen = [(0, 0, 0)], set([(0, 0)])\\n        while True:\\n            time, i, j = heappop(q)\\n            if i == M - 1 and j == N - 1:\\n                return time\\n            time += 1\\n            for u, v in [(i - 1, j), (i, j + 1), (i + 1, j), (i, j - 1)]:\\n                if 0 <= u < M and 0 <= v < N and (u, v) not in seen:\\n                    diff = max(0, A[u][v] - time)\\n                    heappush(q, (time + diff + int(diff & 1), u, v)); seen.add((u, v))\\n```\\n\\n*Rust (using negative `time` for a min-heap)*\\n```\\nuse std::cmp::{max, Reverse};\\nuse std::collections::{BinaryHeap, HashSet};\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nimpl Solution {\\n    pub fn minimum_time(A: VVI) -> i32 {\\n        if 1 < A[0][1] && 1 < A[1][0] {\\n            return -1;\\n        }\\n        let (M, N) = (A.len(), A[0].len());\\n        let key = (|i, j| format!(\"{},{}\", i, j));\\n        let (mut q, mut seen) = (BinaryHeap::new(), HashSet::new());\\n        q.push((0, 0, 0)); seen.insert(key(0, 0));\\n        loop {\\n            let (mut time, i, j) = q.pop().unwrap();\\n            if i == M - 1 && j == N - 1 {\\n                return -time;\\n            }\\n            time -= 1;\\n            for (u, v) in vec![(i - 1, j), (i, j + 1), (i + 1, j), (i, j - 1)] {\\n                if 0 <= u && u < M && 0 <= v && v < N && !seen.contains(&key(u, v)) {\\n                    let diff = max(0, A[u][v] + time);\\n                    q.push((time - (diff + (diff % 2)), u, v)); seen.insert(key(u, v));\\n                }\\n            }\\n        }\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Pair = pair<int, int>;\\n    using Pairs = vector<Pair>;\\n    using Triple = tuple<int, int, int>;\\n    using Queue = priority_queue<Triple, vector<Triple>, ::greater<Triple>>;\\n    using Seen = unordered_map<int, unordered_map<int, bool>>;\\n    int minimumTime(VVI& A, Queue q = {}, Seen seen = {}) {\\n        if (1 < A[0][1] && 1 < A[1][0])\\n            return -1;\\n        auto [M, N] = make_pair(A.size(), A[0].size());\\n        q.push({ 0, 0, 0 }); seen[0][0] = true;\\n        for (;;) {\\n            auto [time, i, j] = q.top(); q.pop();\\n            if (i == M - 1 && j == N - 1)\\n                return time;\\n            ++time;\\n            for (auto [u, v]: Pairs{{i - 1, j}, {i, j + 1}, {i + 1, j}, {i, j - 1}}) {\\n                if (0 <= u && u < M && 0 <= v && v < N && !seen[u][v]) {\\n                    auto diff = max(0, A[u][v] - time);\\n                    q.push({ time + diff + int(diff & 1), u, v }), seen[u][v] = true;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minimumTime(A: Array<IntArray>): Int {\\n        if (1 < A[0][1] && 1 < A[1][0])\\n            return -1\\n        var key = { i: Int, j: Int -> \"$i,$j\" }\\n        var (M, N) = Pair(A.size, A[0].size)\\n        var q = PriorityQueue<Triple<Int, Int, Int>>({ a, b -> a.first.compareTo(b.first) })\\n        q.add(Triple(0, 0, 0))\\n        var seen = mutableSetOf<String>(key(0, 0))\\n        while (true) {\\n            var (time, i, j) = q.poll()\\n            if (i == M - 1 && j == N - 1)\\n                return time\\n            ++time\\n            for ((u, v) in listOf(Pair(i - 1, j), Pair(i, j + 1), Pair(i + 1, j), Pair(i, j - 1))) {\\n                if (0 <= u && u < M && 0 <= v && v < N && !seen.contains(key(u, v))) {\\n                    var diff = Math.max(0, A[u][v] - time)\\n                    q.add(Triple(time + diff + (diff % 2), u, v)); seen.add(key(u, v))\\n                }\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```\n```\\nlet key = x => Array.isArray(x) ? x[0] : x;\\nlet heappush = (A, x, f = Math.min) => {\\n    let P = i => Math.floor((i - 1) / 2);  // parent\\n    A.push(x);\\n    let N = A.length,\\n        i = N - 1;\\n    while (0 < i && key(A[i]) == f(key(A[i]), key(A[P(i)]))) {\\n        [A[i], A[P(i)]] = [A[P(i)], A[i]];\\n        i = P(i);\\n    }\\n};\\nlet heappop = (A, f = Math.min) => {\\n    let L = i => 2 * i + 1,  // children\\n        R = i => 2 * i + 2;\\n    let N = A.length,\\n        i = 0;\\n    let top = A[0];\\n    [A[0], A[N - 1]] = [A[N - 1], A[0]], A.pop(), --N;\\n    let ok;\\n    do {\\n        ok = true;\\n        let left = f == Math.min ? Infinity : -Infinity,\\n            right = left;\\n        if (L(i) < N && key(A[i]) != f(key(A[i]), key(A[L(i)]))) ok = false, left  = key(A[L(i)]);\\n        if (R(i) < N && key(A[i]) != f(key(A[i]), key(A[R(i)]))) ok = false, right = key(A[R(i)]);\\n        if (!ok) {\\n            let j = left == f(left, right) ? L(i) : R(i);\\n            [A[i], A[j]] = [A[j], A[i]];\\n            i = j;\\n        }\\n    } while (!ok);\\n    return top;\\n};\\nlet minimumTime = A => {\\n    if (1 < A[0][1] && 1 < A[1][0])\\n        return -1;\\n    let key = (i, j) => `${i},${j}`;\\n    let [M, N] = [A.length, A[0].length];\\n    let [q, seen] = [[[0, 0, 0]], new Set([key(0, 0)])];\\n    for (;;) {\\n        let [time, i, j] = heappop(q);\\n        if (i == M - 1 && j == N - 1)\\n            return time;\\n        ++time;\\n        for (let [u, v] of [[i - 1, j], [i, j + 1], [i + 1, j], [i, j - 1]]) {\\n            if (0 <= u && u < M && 0 <= v && v < N && !seen.has(key(u, v))) {\\n                let diff = Math.max(0, A[u][v] - time);\\n                heappush(q, [time + diff + Number(diff & 1), u, v]), seen.add(key(u, v));\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minimumTime(self, A: List[List[int]], T = 1e5) -> int:\\n        if 1 < A[0][1] and 1 < A[1][0]:\\n            return -1\\n        M, N = len(A), len(A[0])\\n        q, seen = [(0, 0, 0)], set([(0, 0)])\\n        while True:\\n            time, i, j = heappop(q)\\n            if i == M - 1 and j == N - 1:\\n                return time\\n            time += 1\\n            for u, v in [(i - 1, j), (i, j + 1), (i + 1, j), (i, j - 1)]:\\n                if 0 <= u < M and 0 <= v < N and (u, v) not in seen:\\n                    diff = max(0, A[u][v] - time)\\n                    heappush(q, (time + diff + int(diff & 1), u, v)); seen.add((u, v))\\n```\n```\\nuse std::cmp::{max, Reverse};\\nuse std::collections::{BinaryHeap, HashSet};\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nimpl Solution {\\n    pub fn minimum_time(A: VVI) -> i32 {\\n        if 1 < A[0][1] && 1 < A[1][0] {\\n            return -1;\\n        }\\n        let (M, N) = (A.len(), A[0].len());\\n        let key = (|i, j| format!(\"{},{}\", i, j));\\n        let (mut q, mut seen) = (BinaryHeap::new(), HashSet::new());\\n        q.push((0, 0, 0)); seen.insert(key(0, 0));\\n        loop {\\n            let (mut time, i, j) = q.pop().unwrap();\\n            if i == M - 1 && j == N - 1 {\\n                return -time;\\n            }\\n            time -= 1;\\n            for (u, v) in vec![(i - 1, j), (i, j + 1), (i + 1, j), (i, j - 1)] {\\n                if 0 <= u && u < M && 0 <= v && v < N && !seen.contains(&key(u, v)) {\\n                    let diff = max(0, A[u][v] + time);\\n                    q.push((time - (diff + (diff % 2)), u, v)); seen.insert(key(u, v));\\n                }\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Pair = pair<int, int>;\\n    using Pairs = vector<Pair>;\\n    using Triple = tuple<int, int, int>;\\n    using Queue = priority_queue<Triple, vector<Triple>, ::greater<Triple>>;\\n    using Seen = unordered_map<int, unordered_map<int, bool>>;\\n    int minimumTime(VVI& A, Queue q = {}, Seen seen = {}) {\\n        if (1 < A[0][1] && 1 < A[1][0])\\n            return -1;\\n        auto [M, N] = make_pair(A.size(), A[0].size());\\n        q.push({ 0, 0, 0 }); seen[0][0] = true;\\n        for (;;) {\\n            auto [time, i, j] = q.top(); q.pop();\\n            if (i == M - 1 && j == N - 1)\\n                return time;\\n            ++time;\\n            for (auto [u, v]: Pairs{{i - 1, j}, {i, j + 1}, {i + 1, j}, {i, j - 1}}) {\\n                if (0 <= u && u < M && 0 <= v && v < N && !seen[u][v]) {\\n                    auto diff = max(0, A[u][v] - time);\\n                    q.push({ time + diff + int(diff & 1), u, v }), seen[u][v] = true;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276583,
                "title": "fundamental-approach-c-greedy-best-first-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        priority_queue<array<int,3>,vector<array<int,3>>,greater<array<int,3>>> pq;\\n        if(grid[0][1] > 1 and grid[1][0] > 1) return -1;\\n        int R = grid.size();\\n        int C = grid[0].size();\\n        int dx[] = {0, 0, -1, 1};\\n        int dy[] = {1, -1, 0, 0};\\n        vector<vector<bool>> seen(R, vector<bool>(C, false));\\n        pq.push({0, 0, 0});\\n        while(!pq.empty()) {\\n            auto curr = pq.top();\\n            pq.pop();\\n            int time = curr[0];\\n            int r = curr[1];\\n            int c = curr[2];\\n            if(seen[r][c]) continue;\\n            seen[r][c] = true;\\n            if(r == R-1 and c == C-1)\\n                return time;\\n            for(int t=0;t<4;t++) {\\n                int nr = dx[t]+r;\\n                int nc = dy[t]+c;\\n                if(nc < 0 or nr < 0 or nc == C or nr == R or seen[nr][nc]) continue;\\n                if(grid[nr][nc] <= time+1) {\\n                    pq.push({time+1, nr, nc});\\n                }\\n                else {\\n                    int diff = grid[nr][nc]-time;\\n                    if(diff%2 == 1) {\\n                        pq.push({grid[nr][nc], nr, nc});\\n                    }\\n                    else {\\n                        pq.push({grid[nr][nc]+1, nr, nc});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n// Please consider upvoting if the solution helped! Thank you :)\\n// Credits: Prakhar (Youtuber)\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        priority_queue<array<int,3>,vector<array<int,3>>,greater<array<int,3>>> pq;\\n        if(grid[0][1] > 1 and grid[1][0] > 1) return -1;\\n        int R = grid.size();\\n        int C = grid[0].size();\\n        int dx[] = {0, 0, -1, 1};\\n        int dy[] = {1, -1, 0, 0};\\n        vector<vector<bool>> seen(R, vector<bool>(C, false));\\n        pq.push({0, 0, 0});\\n        while(!pq.empty()) {\\n            auto curr = pq.top();\\n            pq.pop();\\n            int time = curr[0];\\n            int r = curr[1];\\n            int c = curr[2];\\n            if(seen[r][c]) continue;\\n            seen[r][c] = true;\\n            if(r == R-1 and c == C-1)\\n                return time;\\n            for(int t=0;t<4;t++) {\\n                int nr = dx[t]+r;\\n                int nc = dy[t]+c;\\n                if(nc < 0 or nr < 0 or nc == C or nr == R or seen[nr][nc]) continue;\\n                if(grid[nr][nc] <= time+1) {\\n                    pq.push({time+1, nr, nc});\\n                }\\n                else {\\n                    int diff = grid[nr][nc]-time;\\n                    if(diff%2 == 1) {\\n                        pq.push({grid[nr][nc], nr, nc});\\n                    }\\n                    else {\\n                        pq.push({grid[nr][nc]+1, nr, nc});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n// Please consider upvoting if the solution helped! Thank you :)\\n// Credits: Prakhar (Youtuber)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272874,
                "title": "easy-to-understand-intuitive-djisktra-s-algorithm",
                "content": "# Intuition\\nto find the minimum time we should take out the minimum path to reach the end index i.e we will find the shortest distace(here time) in the graph with some modification.\\n\\n# Approach\\nthe only case when we cannot reach the end is if there is no valid move from start itself otherwise we can move back and forth and make time sufficient to move to next box. so incase the the box is not reachable in time+1 then the time to reach it will be atleast the time in that box, and if the difference of the value in that box and time is divisible by 2 we need additional 1 unit time to reach to that box because there is no valid way to move to and fro and then move to the box when it becomes available, we will always reach 1 second later. keeping these in mind apply djisktra\\'s algo.   \\n\\n# Complexity\\n- Time complexity:\\nO(m*n log(m*n))\\n\\n- Space complexity:\\n O(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int row,int col ,int m ,int n){\\n        return row>=0 && col>=0 && row<m && col<n;\\n    }\\n    int minimumTime(vector<vector<int>>& grid) {\\n    int m = grid.size(); \\n    int n = grid[0].size();\\n    if(grid[0][1]>1 && grid[1][0]>1) return -1;\\n    vector<int> dist(m*n+1,1e9);    \\n    set<pair<int,int>> st;\\n    st.insert({0,0});\\n    vector<int> a = {-1,0,1,0};\\n    vector<int> b = {0,1,0,-1};\\n    dist[0] = 0;\\n    while(st.size()){\\n    auto p = *(st.begin());\\n    st.erase(st.begin());\\n    int time = p.first;\\n    int ind = p.second;\\n    int row = ind/n;\\n    int col = ind%n;\\n    for(int i = 0;i<4;i++){\\n        int newr = row + a[i];\\n        int newc = col + b[i];\\n        if(isValid(newr,newc,m,n)){\\n            if(time + 1 < dist[newr*n + newc]){\\n                int newtime;\\n                int newind = newr*n + newc; \\n                if(time+1 >= grid[newr][newc]) newtime = time+1;\\n                else{\\n                    int diff = grid[newr][newc] - time;\\n                    if(diff%2==0) newtime = diff + time + 1;\\n                    else newtime = diff + time;\\n                }\\n                if(dist[newind] > newtime){\\n                    if(dist[newind] < 1e9){\\n                        auto it = st.find({dist[newind],newind});\\n                        if(it!=st.end()) st.erase(it);\\n                    }\\n                    dist[newind] = newtime;\\n                    st.insert({newtime,newind});\\n               // cout<<newtime<<\" \"<<newind<<endl;\\n                }\\n            }\\n        }\\n    }\\n    }\\n    return dist[m*n-1]>=1e9?-1 : dist[m*n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int row,int col ,int m ,int n){\\n        return row>=0 && col>=0 && row<m && col<n;\\n    }\\n    int minimumTime(vector<vector<int>>& grid) {\\n    int m = grid.size(); \\n    int n = grid[0].size();\\n    if(grid[0][1]>1 && grid[1][0]>1) return -1;\\n    vector<int> dist(m*n+1,1e9);    \\n    set<pair<int,int>> st;\\n    st.insert({0,0});\\n    vector<int> a = {-1,0,1,0};\\n    vector<int> b = {0,1,0,-1};\\n    dist[0] = 0;\\n    while(st.size()){\\n    auto p = *(st.begin());\\n    st.erase(st.begin());\\n    int time = p.first;\\n    int ind = p.second;\\n    int row = ind/n;\\n    int col = ind%n;\\n    for(int i = 0;i<4;i++){\\n        int newr = row + a[i];\\n        int newc = col + b[i];\\n        if(isValid(newr,newc,m,n)){\\n            if(time + 1 < dist[newr*n + newc]){\\n                int newtime;\\n                int newind = newr*n + newc; \\n                if(time+1 >= grid[newr][newc]) newtime = time+1;\\n                else{\\n                    int diff = grid[newr][newc] - time;\\n                    if(diff%2==0) newtime = diff + time + 1;\\n                    else newtime = diff + time;\\n                }\\n                if(dist[newind] > newtime){\\n                    if(dist[newind] < 1e9){\\n                        auto it = st.find({dist[newind],newind});\\n                        if(it!=st.end()) st.erase(it);\\n                    }\\n                    dist[newind] = newtime;\\n                    st.insert({newtime,newind});\\n               // cout<<newtime<<\" \"<<newind<<endl;\\n                }\\n            }\\n        }\\n    }\\n    }\\n    return dist[m*n-1]>=1e9?-1 : dist[m*n-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3267930,
                "title": "c-solution-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) \\n    {\\n        int dr[4]={0,0,-1,1};\\n        int dc[4]={1,-1,0,0};\\n        int m=grid.size(),n=grid[0].size();\\n        if(grid[0][1]>1&&grid[1][0]>1)return -1;\\n        priority_queue<array<int,3>,vector<array<int,3>>,greater<array<int,3>>>pq;\\n        unordered_set<int>visited;\\n        pq.push({0,0,0});\\n        while(pq.size())\\n        {\\n            array<int,3>cur=pq.top();\\n            pq.pop();\\n            int step=cur[0],x=cur[1],y=cur[2];\\n            if(x==m-1&&y==n-1)return step;\\n            if(visited.count(x*n+y))continue;\\n            visited.insert(x*n+y);\\n            for(int i=0;i<4;i++)\\n            {\\n                int nx=x+dr[i],ny=y+dc[i];\\n                if(nx<0||ny<0||nx==m||ny==n)continue;\\n                if(visited.count(nx*n+ny))continue;\\n                if(grid[nx][ny]>step)\\n                {\\n                    int dif=grid[nx][ny]-step+1;\\n                    pq.push({grid[nx][ny]+(dif%2),nx,ny});\\n                }else pq.push({step+1,nx,ny});\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) \\n    {\\n        int dr[4]={0,0,-1,1};\\n        int dc[4]={1,-1,0,0};\\n        int m=grid.size(),n=grid[0].size();\\n        if(grid[0][1]>1&&grid[1][0]>1)return -1;\\n        priority_queue<array<int,3>,vector<array<int,3>>,greater<array<int,3>>>pq;\\n        unordered_set<int>visited;\\n        pq.push({0,0,0});\\n        while(pq.size())\\n        {\\n            array<int,3>cur=pq.top();\\n            pq.pop();\\n            int step=cur[0],x=cur[1],y=cur[2];\\n            if(x==m-1&&y==n-1)return step;\\n            if(visited.count(x*n+y))continue;\\n            visited.insert(x*n+y);\\n            for(int i=0;i<4;i++)\\n            {\\n                int nx=x+dr[i],ny=y+dc[i];\\n                if(nx<0||ny<0||nx==m||ny==n)continue;\\n                if(visited.count(nx*n+ny))continue;\\n                if(grid[nx][ny]>step)\\n                {\\n                    int dif=grid[nx][ny]-step+1;\\n                    pq.push({grid[nx][ny]+(dif%2),nx,ny});\\n                }else pq.push({step+1,nx,ny});\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247412,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& mat) \\n    {\\n        if(mat[0][1]>1&&mat[1][0]>1)\\n        {\\n            return -1;\\n        }\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<pair<int,int>>d={{-1,0},{1,0},{0,-1},{0,1}};\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        pq.push({0,0});\\n        int vis[n][m];\\n        memset(vis,0,sizeof(vis));\\n        while(pq.size())\\n        {\\n            auto [time,xy]=pq.top();\\n            pq.pop();\\n            int x=xy/m;\\n            int y=xy%m;\\n            if(x==n-1&&y==m-1)\\n            {\\n                return time;\\n            }\\n            if(vis[x][y])\\n            {\\n                continue;\\n            }\\n            vis[x][y]=1;\\n            for(auto &it:d)\\n            {\\n                int nx=x+it.first;\\n                int ny=y+it.second;\\n                if(nx>=0&&ny>=0&&nx<n&&ny<m)\\n                {\\n                    if(mat[nx][ny]<=time+1)\\n                    {\\n                        pq.push({time+1,nx*m+ny});\\n                    }\\n                    else\\n                    {\\n                        int diff=(mat[nx][ny]-time);\\n                        if(diff%2==0)\\n                        {\\n                            pq.push({mat[nx][ny]+1,nx*m+ny});\\n                        }\\n                        else\\n                        {\\n                            pq.push({mat[nx][ny],nx*m+ny});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& mat) \\n    {\\n        if(mat[0][1]>1&&mat[1][0]>1)\\n        {\\n            return -1;\\n        }\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<pair<int,int>>d={{-1,0},{1,0},{0,-1},{0,1}};\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        pq.push({0,0});\\n        int vis[n][m];\\n        memset(vis,0,sizeof(vis));\\n        while(pq.size())\\n        {\\n            auto [time,xy]=pq.top();\\n            pq.pop();\\n            int x=xy/m;\\n            int y=xy%m;\\n            if(x==n-1&&y==m-1)\\n            {\\n                return time;\\n            }\\n            if(vis[x][y])\\n            {\\n                continue;\\n            }\\n            vis[x][y]=1;\\n            for(auto &it:d)\\n            {\\n                int nx=x+it.first;\\n                int ny=y+it.second;\\n                if(nx>=0&&ny>=0&&nx<n&&ny<m)\\n                {\\n                    if(mat[nx][ny]<=time+1)\\n                    {\\n                        pq.push({time+1,nx*m+ny});\\n                    }\\n                    else\\n                    {\\n                        int diff=(mat[nx][ny]-time);\\n                        if(diff%2==0)\\n                        {\\n                            pq.push({mat[nx][ny]+1,nx*m+ny});\\n                        }\\n                        else\\n                        {\\n                            pq.push({mat[nx][ny],nx*m+ny});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247060,
                "title": "very-readable-c-solution",
                "content": "Very readable C++ solution\\n\\n# Code\\n```\\nclass Solution {\\n    vector<pair<int, int>> dirs {\\n        {0, -1}, {1, 0}, {0, 1}, {-1, 0}\\n    };\\n    \\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        if (grid[0][1] > 1 && grid[1][0] > 1) return -1; // only edge case where we can\\'t stall for time\\n\\n        int height = grid.size();\\n        int width = grid[0].size();\\n        \\n        vector<vector<int>> visited(height, vector<int>(width, -1));\\n        \\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int,pair<int,int>>>> pq;\\n        \\n        pq.push({grid[0][0], {0, 0}});\\n        visited[0][0] = 0;\\n        \\n        while (!pq.empty()){\\n            auto currCell = pq.top();\\n            pq.pop();\\n            \\n            int currX = currCell.second.first;\\n            int currY = currCell.second.second;\\n            \\n            for (auto dir : dirs){\\n                int newX = currX + dir.first;\\n                int newY = currY + dir.second;\\n\\n                if (newX >= 0 && newX < width && newY >= 0 && newY < height && // this neighbor is within the grid\\n                    visited[newY][newX] == -1) { // and this neighbor is not visited yet \\n                    int newTime = 1 + visited[currY][currX];\\n\\n                    if (grid[newY][newX] > newTime)\\n                        visited[newY][newX] = ((grid[newY][newX] - newTime) % 2 == 1) + grid[newY][newX]; // the time we will reach this neighbor after going back and forth, stalling for time\\n                    else\\n                        visited[newY][newX] = newTime;\\n\\n                    pq.push({visited[newY][newX], {newX, newY}});\\n                }\\n            }\\n        }\\n\\n        return visited[height-1][width-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<pair<int, int>> dirs {\\n        {0, -1}, {1, 0}, {0, 1}, {-1, 0}\\n    };\\n    \\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        if (grid[0][1] > 1 && grid[1][0] > 1) return -1; // only edge case where we can\\'t stall for time\\n\\n        int height = grid.size();\\n        int width = grid[0].size();\\n        \\n        vector<vector<int>> visited(height, vector<int>(width, -1));\\n        \\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int,pair<int,int>>>> pq;\\n        \\n        pq.push({grid[0][0], {0, 0}});\\n        visited[0][0] = 0;\\n        \\n        while (!pq.empty()){\\n            auto currCell = pq.top();\\n            pq.pop();\\n            \\n            int currX = currCell.second.first;\\n            int currY = currCell.second.second;\\n            \\n            for (auto dir : dirs){\\n                int newX = currX + dir.first;\\n                int newY = currY + dir.second;\\n\\n                if (newX >= 0 && newX < width && newY >= 0 && newY < height && // this neighbor is within the grid\\n                    visited[newY][newX] == -1) { // and this neighbor is not visited yet \\n                    int newTime = 1 + visited[currY][currX];\\n\\n                    if (grid[newY][newX] > newTime)\\n                        visited[newY][newX] = ((grid[newY][newX] - newTime) % 2 == 1) + grid[newY][newX]; // the time we will reach this neighbor after going back and forth, stalling for time\\n                    else\\n                        visited[newY][newX] = newTime;\\n\\n                    pq.push({visited[newY][newX], {newX, newY}});\\n                }\\n            }\\n        }\\n\\n        return visited[height-1][width-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246499,
                "title": "simple-java-solution-using-pair-class-and-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair{\\n    int row;\\n    int col;\\n    int min;\\n    Pair(int row,int col,int min){\\n        this.row = row;\\n        this.col = col;\\n        this.min = min;\\n    }\\n}\\n\\nclass Solution {\\n    public int minimumTime(int[][] grid) {\\n        int N = grid.length;\\n        int M = grid[0].length;\\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\\n            return -1;\\n        }\\n        boolean[][] visited = new boolean[N][M];\\n        visited[0][0] = true;\\n        PriorityQueue<Pair> q = new PriorityQueue<>((a,b)->a.min-b.min);\\n        q.add(new Pair(0,0,0));\\n        \\n        int[] drow = {-1, 0, 1, 0};\\n        int[] dcol = {0, 1, 0, -1};\\n        \\n        while(!q.isEmpty()){\\n            Pair p = q.poll();\\n            int row = p.row;\\n            int col = p.col;\\n            int min = p.min;\\n            \\n            if(row == N-1 && col == M-1) return min;\\n\\n            for(int i=0;i<4;i++){\\n                int nrow = row+drow[i];\\n                int ncol = col+dcol[i];\\n                if (nrow >= 0 && nrow < N && ncol >= 0 && ncol < M && !visited[nrow][ncol]) {\\n                    if(min + 1 >= grid[nrow][ncol]){\\n                        visited[nrow][ncol] = true;\\n                        q.add(new Pair(nrow,ncol,min+1));\\n                    }else{\\n                        int diff = grid[nrow][ncol] - min;\\n                        if (diff % 2 == 1) {\\n                            q.add(new Pair(nrow,ncol,grid[nrow][ncol]));\\n                        } else {\\n                            q.add(new Pair(nrow,ncol,grid[nrow][ncol]+1));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Pair{\\n    int row;\\n    int col;\\n    int min;\\n    Pair(int row,int col,int min){\\n        this.row = row;\\n        this.col = col;\\n        this.min = min;\\n    }\\n}\\n\\nclass Solution {\\n    public int minimumTime(int[][] grid) {\\n        int N = grid.length;\\n        int M = grid[0].length;\\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\\n            return -1;\\n        }\\n        boolean[][] visited = new boolean[N][M];\\n        visited[0][0] = true;\\n        PriorityQueue<Pair> q = new PriorityQueue<>((a,b)->a.min-b.min);\\n        q.add(new Pair(0,0,0));\\n        \\n        int[] drow = {-1, 0, 1, 0};\\n        int[] dcol = {0, 1, 0, -1};\\n        \\n        while(!q.isEmpty()){\\n            Pair p = q.poll();\\n            int row = p.row;\\n            int col = p.col;\\n            int min = p.min;\\n            \\n            if(row == N-1 && col == M-1) return min;\\n\\n            for(int i=0;i<4;i++){\\n                int nrow = row+drow[i];\\n                int ncol = col+dcol[i];\\n                if (nrow >= 0 && nrow < N && ncol >= 0 && ncol < M && !visited[nrow][ncol]) {\\n                    if(min + 1 >= grid[nrow][ncol]){\\n                        visited[nrow][ncol] = true;\\n                        q.add(new Pair(nrow,ncol,min+1));\\n                    }else{\\n                        int diff = grid[nrow][ncol] - min;\\n                        if (diff % 2 == 1) {\\n                            q.add(new Pair(nrow,ncol,grid[nrow][ncol]));\\n                        } else {\\n                            q.add(new Pair(nrow,ncol,grid[nrow][ncol]+1));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243401,
                "title": "accepted-c-dijkstra-with-a-little-bit-of-smartness-required",
                "content": "READ AND YOU WILL UNDERSTAND STILL NOT THEN FOLLOW THE LINKS\\n\\n![image](https://assets.leetcode.com/users/images/dcf97160-1bab-406c-8c81-c237e16606ba_1677667002.293557.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        \\n        \\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        vector<int> direct={0,1,0,-1,0};\\n        \\n        if(grid[0][1]>1 && grid[1][0]>1)\\n            return -1;\\n        \\n        priority_queue<vector<long int>,vector<vector<long int>>,greater<vector<long int>>> pq;\\n        \\n        pq.push({0,0,0});//{cost to reach (x,y),x,y}\\n        \\n        vector<vector<bool>> vis(n,vector<bool>(m));\\n        \\n        int x,y,t,nx,ny;\\n        \\n        while(!pq.empty())\\n        {\\n            t=pq.top()[0];\\n            x=pq.top()[1];\\n            y=pq.top()[2];\\n            \\n            pq.pop();\\n            \\n            if(x==n-1 && y==m-1)\\n                return t;\\n            \\n            if(vis[x][y])\\n                continue;\\n            \\n            vis[x][y]=true;\\n            \\n            for(int i=0;i<4;i++)\\n            {\\n                nx=x+direct[i];\\n                ny=y+direct[i+1];\\n                \\n                if(nx>=0 && ny>=0 && nx<n && ny<m && !vis[nx][ny])//we wil not move backwards to visited index (nx,ny) instead we will apply maths and calculated how much back and forth movement required to move to the required index\\n                {\\n                        int wait=((grid[nx][ny]-t)&1)?0:1;\\n                    \\n                        pq.push({max(grid[nx][ny]+wait,t+1),nx,ny}); /*the thing happening over here is clariffied in detail below*/\\n                  \\n                    \\n                    /*if( grid[nx][ny] <= t + 1) \\n                    {\\n                        pq.push({ t + 1,nx,ny});\\n                    }\\n                    //grid[nr][nc]>time+1 meaning to say reaching to that box is not possible in single leap we need to increase our capability and that going back and coming back to current index and addint more time so that we are having capability to reach new cell is done by calculation\\n                        //if diffrence >1 and odd means we will reach box with the landing time same as written on the new trying to reach index (nx,ny)\\n                     //   else if difference>1 and  is even we will reach box with time + 1 the landing time in the new position (nx,ny)\\n                     else\\n                    {\\n                        int diff = grid[nx][ny] - t;\\n                        \\n                        if (diff % 2 == 1) {\\n                            pq.push({grid[nx][ny],nx,ny});\\n                        } else {\\n                            pq.push({grid[nx][ny] + 1,nx,ny});\\n                        }\\n                    }*/\\n                    \\n                    \\n                    /*\\n                    now considering the top statement max(grid[nx][ny]+wait,t+1)\\n                    two cases for wait 0 or 1\\n                    \\n                    grid[nx][ny]\\n                    grid[nx][ny]+1\\n                    \\n                    and for \\n                    \\n                    pq.push({ t + 1,nx,ny}); statement t+1 is equal to grid[nx][ny] so on taking max it will land on index (nx,ny) with time grid[nx][ny]\\n                    otherwise if difference is even then max function will give maximum to grid[nx][ny]+1 as it will land with one extra time compared to required even difference of time\\n                    */\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};```\\n\\n /*\\n        \\n        https://www.youtube.com/watch?v=w9oMct1YeAg\\n        \\n        https://leetcode.com/problems/minimum-time-to-visit-a-cell-in-a-grid/discuss/3230800/C%2B%2B-Java-Python-Ping-Pong-Dijkstra\\n        \\n        https://www.youtube.com/watch?v=0HN_d2WEKgQ*/\\n",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        \\n        \\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        vector<int> direct={0,1,0,-1,0};\\n        \\n        if(grid[0][1]>1 && grid[1][0]>1)\\n            return -1;\\n        \\n        priority_queue<vector<long int>,vector<vector<long int>>,greater<vector<long int>>> pq;\\n        \\n        pq.push({0,0,0});//{cost to reach (x,y),x,y}\\n        \\n        vector<vector<bool>> vis(n,vector<bool>(m));\\n        \\n        int x,y,t,nx,ny;\\n        \\n        while(!pq.empty())\\n        {\\n            t=pq.top()[0];\\n            x=pq.top()[1];\\n            y=pq.top()[2];\\n            \\n            pq.pop();\\n            \\n            if(x==n-1 && y==m-1)\\n                return t;\\n            \\n            if(vis[x][y])\\n                continue;\\n            \\n            vis[x][y]=true;\\n            \\n            for(int i=0;i<4;i++)\\n            {\\n                nx=x+direct[i];\\n                ny=y+direct[i+1];\\n                \\n                if(nx>=0 && ny>=0 && nx<n && ny<m && !vis[nx][ny])//we wil not move backwards to visited index (nx,ny) instead we will apply maths and calculated how much back and forth movement required to move to the required index\\n                {\\n                        int wait=((grid[nx][ny]-t)&1)?0:1;\\n                    \\n                        pq.push({max(grid[nx][ny]+wait,t+1),nx,ny}); /*the thing happening over here is clariffied in detail below*/\\n                  \\n                    \\n                    /*if( grid[nx][ny] <= t + 1) \\n                    {\\n                        pq.push({ t + 1,nx,ny});\\n                    }\\n                    //grid[nr][nc]>time+1 meaning to say reaching to that box is not possible in single leap we need to increase our capability and that going back and coming back to current index and addint more time so that we are having capability to reach new cell is done by calculation\\n                        //if diffrence >1 and odd means we will reach box with the landing time same as written on the new trying to reach index (nx,ny)\\n                     //   else if difference>1 and  is even we will reach box with time + 1 the landing time in the new position (nx,ny)\\n                     else\\n                    {\\n                        int diff = grid[nx][ny] - t;\\n                        \\n                        if (diff % 2 == 1) {\\n                            pq.push({grid[nx][ny],nx,ny});\\n                        } else {\\n                            pq.push({grid[nx][ny] + 1,nx,ny});\\n                        }\\n                    }*/\\n                    \\n                    \\n                    /*\\n                    now considering the top statement max(grid[nx][ny]+wait,t+1)\\n                    two cases for wait 0 or 1\\n                    \\n                    grid[nx][ny]\\n                    grid[nx][ny]+1\\n                    \\n                    and for \\n                    \\n                    pq.push({ t + 1,nx,ny}); statement t+1 is equal to grid[nx][ny] so on taking max it will land on index (nx,ny) with time grid[nx][ny]\\n                    otherwise if difference is even then max function will give maximum to grid[nx][ny]+1 as it will land with one extra time compared to required even difference of time\\n                    */\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 3243109,
                "title": "c-solution-dijkstra-s-algorithm",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\\n            return -1;\\n        }\\n        priority_queue<\\n            pair<int, pair<int,int>>,\\n            vector<pair<int, pair<int,int>>>,\\n            greater<pair<int, pair<int,int>>>\\n            > pq;\\n        vector<vector<int>> vis(m, vector<int>(n,0));\\n        pq.push({0,{0,0}});\\n        int row[] = {-1, 0, 1, 0};\\n        int col[] = {0, -1, 0, 1};\\n        while(!pq.empty()) {\\n            pair<int, pair<int,int>> p = pq.top();\\n            pq.pop();\\n            int time = p.first;\\n            int r = p.second.first;\\n            int c = p.second.second;\\n            if(r == m-1 && c == n-1)\\n                return time;\\n            if(vis[r][c]) continue;\\n            vis[r][c] = 1;\\n            for(int k = 0;k<4;k++) {\\n                int i = r + row[k];\\n                int j = c + col[k];\\n                if(i < 0 || i >= m || j < 0 || j >= n || vis[i][j])\\n                    continue;\\n                int timeToVistNeighbor = (grid[i][j] - time)%2 == 0;\\n                pq.push({max(time+1, grid[i][j] + timeToVistNeighbor), {i, j}});\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\\n            return -1;\\n        }\\n        priority_queue<\\n            pair<int, pair<int,int>>,\\n            vector<pair<int, pair<int,int>>>,\\n            greater<pair<int, pair<int,int>>>\\n            > pq;\\n        vector<vector<int>> vis(m, vector<int>(n,0));\\n        pq.push({0,{0,0}});\\n        int row[] = {-1, 0, 1, 0};\\n        int col[] = {0, -1, 0, 1};\\n        while(!pq.empty()) {\\n            pair<int, pair<int,int>> p = pq.top();\\n            pq.pop();\\n            int time = p.first;\\n            int r = p.second.first;\\n            int c = p.second.second;\\n            if(r == m-1 && c == n-1)\\n                return time;\\n            if(vis[r][c]) continue;\\n            vis[r][c] = 1;\\n            for(int k = 0;k<4;k++) {\\n                int i = r + row[k];\\n                int j = c + col[k];\\n                if(i < 0 || i >= m || j < 0 || j >= n || vis[i][j])\\n                    continue;\\n                int timeToVistNeighbor = (grid[i][j] - time)%2 == 0;\\n                pq.push({max(time+1, grid[i][j] + timeToVistNeighbor), {i, j}});\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243022,
                "title": "c-dijkstras-modification",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));\\n        dist[0][0] = 0;\\n        vector<vector<int>> dirs = {{0, 1},{1, 0},{-1, 0},{0, -1}};\\n        if(grid[0][1] > 1 && grid[1][0] > 1)\\n            return -1;\\n        pq.push({0, 0, 0});\\n        int ans = INT_MAX;\\n        int a, b, k;\\n        vector<int> temp;\\n        while(!pq.empty()){\\n           temp = pq.top();\\n            pq.pop();\\n            if(dist[temp[1]][temp[2]] < temp[0])\\n                continue;\\n            if(temp[1] == n-1 && temp[2] == m-1)\\n                return temp[0];\\n            for(int i = 0;i < 4;i++){\\n                 a = temp[1] + dirs[i][0];\\n                 b = temp[2] + dirs[i][1];\\n                if(a >= 0 && a < n && b >= 0 && b < m){\\n                     k = 0;\\n                    if((grid[a][b] - temp[0]) > 1){\\n                        k += (grid[a][b] - temp[0]);\\n                        if((grid[a][b] - temp[0]) % 2 == 0)\\n                            k++;\\n                    }\\n                    else\\n                        k = 1;\\n                    if(dist[a][b] > temp[0] + k){\\n                        dist[a][b] = temp[0] + k;\\n                        pq.push({dist[a][b], a, b});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));\\n        dist[0][0] = 0;\\n        vector<vector<int>> dirs = {{0, 1},{1, 0},{-1, 0},{0, -1}};\\n        if(grid[0][1] > 1 && grid[1][0] > 1)\\n            return -1;\\n        pq.push({0, 0, 0});\\n        int ans = INT_MAX;\\n        int a, b, k;\\n        vector<int> temp;\\n        while(!pq.empty()){\\n           temp = pq.top();\\n            pq.pop();\\n            if(dist[temp[1]][temp[2]] < temp[0])\\n                continue;\\n            if(temp[1] == n-1 && temp[2] == m-1)\\n                return temp[0];\\n            for(int i = 0;i < 4;i++){\\n                 a = temp[1] + dirs[i][0];\\n                 b = temp[2] + dirs[i][1];\\n                if(a >= 0 && a < n && b >= 0 && b < m){\\n                     k = 0;\\n                    if((grid[a][b] - temp[0]) > 1){\\n                        k += (grid[a][b] - temp[0]);\\n                        if((grid[a][b] - temp[0]) % 2 == 0)\\n                            k++;\\n                    }\\n                    else\\n                        k = 1;\\n                    if(dist[a][b] > temp[0] + k){\\n                        dist[a][b] = temp[0] + k;\\n                        pq.push({dist[a][b], a, b});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242827,
                "title": "simple-sortest-path-dijkstra-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfirst chechk for when it is not possible to reach end ,\\nit is possible if we cant move from position (0,0);\\nother wise we reach in every situation to the bottom end.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nafter check base cases and for -1 ,we go for find the minimum path \\napproach;-\\n* check every possible path with the count of time at each cell if we we reach the bottom end simple retun time\\n* use priority queue for sortest time \\n* we use BFS to find the solution \\n* keep update vector of of ech cell with minimum time ,if there is any way to reach the cell with less time than previous we update it\\n* one more thing keep in mind like in situation come where cell defference is high we directly calculate difference of both cell insted of going for one by one increase \\nlike;-[ 1,45689]\\nin this siuation if be go one by one time if increase time complexity so instead of that direclty check its diff.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\ntypedef  pair<int,pair<int,int>>pi;\\nvector<int>t={0,-1,0,1,0};\\n\\n    int minimumTime(vector<vector<int>>& grid) {\\n       \\n        int n=grid.size();\\n        int m=grid[0].size();\\n         vector<vector<int>>v(n,vector<int>(m,INT_MAX));\\n        if(n==1 &&m==1){\\n            return 0;\\n        }\\n       if(n==1){\\nif(grid[0][1]>grid[0][0]+1){\\n    return -1;\\n}\\n       }\\n        if(m==1){\\nif(grid[1][0]>grid[0][0]+1){\\n    return -1;\\n}\\n       }\\n      if(grid[1][0]>grid[0][0]+1 && grid[0][1]>grid[0][0]+1){\\n          return -1;\\n      } \\npriority_queue<pi, vector<pi>, greater<pi> > q;\\nq.push({0,{0,0}});\\nwhile(!q.empty()){\\n    auto it=q.top();\\n    q.pop();\\n    if(it.second.first==n-1 && it.second.second==m-1){\\n        return it.first;\\n    }\\n    for(int i=1;i<t.size();i++){\\n        int h=it.second.first+t[i-1];\\n        int k=it.second.second+t[i];\\n        if(h>=0 &&h<=n-1 && k>=0 && k<=m-1 ){\\n            if(it.first+1>=grid[h][k]){\\n                if(v[h][k]>it.first+1){\\n            q.push({it.first+1,{h,k}});\\n            v[h][k]=it.first+1;\\n                }\\n            }else{\\n               int l=grid[h][k]-it.first;\\n               if(l%2==0){\\n                   if(v[h][k]>grid[h][k]+1){\\n                   q.push({grid[h][k]+1,{h,k}});\\n                   v[h][k]=grid[h][k]+1;\\n                   }\\n               }else{\\n                     if(v[h][k]>grid[h][k]){\\n                   q.push({grid[h][k],{h,k}});\\n                   v[h][k]=grid[h][k];\\n                   }\\n               }\\n            }\\n            \\n        }\\n         \\n    }\\n}\\nreturn -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\ntypedef  pair<int,pair<int,int>>pi;\\nvector<int>t={0,-1,0,1,0};\\n\\n    int minimumTime(vector<vector<int>>& grid) {\\n       \\n        int n=grid.size();\\n        int m=grid[0].size();\\n         vector<vector<int>>v(n,vector<int>(m,INT_MAX));\\n        if(n==1 &&m==1){\\n            return 0;\\n        }\\n       if(n==1){\\nif(grid[0][1]>grid[0][0]+1){\\n    return -1;\\n}\\n       }\\n        if(m==1){\\nif(grid[1][0]>grid[0][0]+1){\\n    return -1;\\n}\\n       }\\n      if(grid[1][0]>grid[0][0]+1 && grid[0][1]>grid[0][0]+1){\\n          return -1;\\n      } \\npriority_queue<pi, vector<pi>, greater<pi> > q;\\nq.push({0,{0,0}});\\nwhile(!q.empty()){\\n    auto it=q.top();\\n    q.pop();\\n    if(it.second.first==n-1 && it.second.second==m-1){\\n        return it.first;\\n    }\\n    for(int i=1;i<t.size();i++){\\n        int h=it.second.first+t[i-1];\\n        int k=it.second.second+t[i];\\n        if(h>=0 &&h<=n-1 && k>=0 && k<=m-1 ){\\n            if(it.first+1>=grid[h][k]){\\n                if(v[h][k]>it.first+1){\\n            q.push({it.first+1,{h,k}});\\n            v[h][k]=it.first+1;\\n                }\\n            }else{\\n               int l=grid[h][k]-it.first;\\n               if(l%2==0){\\n                   if(v[h][k]>grid[h][k]+1){\\n                   q.push({grid[h][k]+1,{h,k}});\\n                   v[h][k]=grid[h][k]+1;\\n                   }\\n               }else{\\n                     if(v[h][k]>grid[h][k]){\\n                   q.push({grid[h][k],{h,k}});\\n                   v[h][k]=grid[h][k];\\n                   }\\n               }\\n            }\\n            \\n        }\\n         \\n    }\\n}\\nreturn -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242020,
                "title": "pog-c-solution-99-runtime-98-memory",
                "content": "# Code\\n```\\nint mp[103002];\\nint speedup = []{ios::sync_with_stdio(0); cin.tie(0); return 0;}();\\n\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        if (grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n        int step = grid[0].size() + 1, tgt = (grid.size() + 1) * step - 2;\\n        {\\n            int *p = mp + step, ss = 0;\\n            fill(mp, p, -1);\\n            for (const auto &r : grid) {\\n                int s = ss = 1 - ss;\\n                for (int x : r) *p++ = (s = 1 - s) ? x | 1 : (x + 1) & ~1;\\n                *p++ = -1;\\n            }\\n            fill(p, p + step, -1);\\n        }\\n\\n        using tq = tuple<int,int>;\\n        priority_queue<tq, vector<tq>, greater<tq>> q;\\n        q.push({0,step}); mp[step] = -1;\\n        while (1) {\\n            auto [d, n] = q.top(); q.pop(); ++d;\\n            for (int nb : {n - step, n - 1, n + 1, n + step}) {\\n                if (mp[nb] == -1) continue;\\n                int dd = max(d, mp[nb]);\\n                if (nb == tgt) return dd;\\n                mp[nb] = -1; q.push({dd, nb});\\n            }\\n        }\\n    }\\n};\\n```\\nPlease give an upvote on this solution! Thanks!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint mp[103002];\\nint speedup = []{ios::sync_with_stdio(0); cin.tie(0); return 0;}();\\n\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        if (grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n        int step = grid[0].size() + 1, tgt = (grid.size() + 1) * step - 2;\\n        {\\n            int *p = mp + step, ss = 0;\\n            fill(mp, p, -1);\\n            for (const auto &r : grid) {\\n                int s = ss = 1 - ss;\\n                for (int x : r) *p++ = (s = 1 - s) ? x | 1 : (x + 1) & ~1;\\n                *p++ = -1;\\n            }\\n            fill(p, p + step, -1);\\n        }\\n\\n        using tq = tuple<int,int>;\\n        priority_queue<tq, vector<tq>, greater<tq>> q;\\n        q.push({0,step}); mp[step] = -1;\\n        while (1) {\\n            auto [d, n] = q.top(); q.pop(); ++d;\\n            for (int nb : {n - step, n - 1, n + 1, n + step}) {\\n                if (mp[nb] == -1) continue;\\n                int dd = max(d, mp[nb]);\\n                if (nb == tgt) return dd;\\n                mp[nb] = -1; q.push({dd, nb});\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240630,
                "title": "c-priority-queue-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int dir[5]={-1,0,1,0,-1};\\n    int minimumTime(vector<vector<int>>& grid) \\n    {\\n        int m=grid.size(),n=grid[0].size();\\n        if(grid[0][1]>1&&grid[1][0]>1)\\n            return -1;\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> pq;  //val,i,j\\n        pq.push({0,0,0});\\n        vector<vector<bool>> vis(m,vector<bool>(n,0));\\n        while(!pq.empty())\\n        {\\n            auto v=pq.top();\\n             pq.pop();\\n            int t=v[0];\\n            int x=v[1],y=v[2];\\n            if(x==m-1&&y==n-1)\\n                 return t;\\n            if(vis[x][y])\\n                continue;\\n            vis[x][y]=true;\\n            for(int i=0;i<4;i++)\\n            {\\n                int nx=x+dir[i],ny=y+dir[i+1];\\n                if(nx<0||ny<0||nx>=m||ny>=n||vis[nx][ny])\\n                    continue;\\n                int wait=(grid[nx][ny]-t)%2==0;\\n                pq.push({max(grid[nx][ny]+wait,t+1),nx,ny});\\n            }\\n            \\n            \\n        }\\n        return -1;\\n    }\\n};\\n```\\nIf you like the solution plz upvote.\\n=",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dir[5]={-1,0,1,0,-1};\\n    int minimumTime(vector<vector<int>>& grid) \\n    {\\n        int m=grid.size(),n=grid[0].size();\\n        if(grid[0][1]>1&&grid[1][0]>1)\\n            return -1;\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> pq;  //val,i,j\\n        pq.push({0,0,0});\\n        vector<vector<bool>> vis(m,vector<bool>(n,0));\\n        while(!pq.empty())\\n        {\\n            auto v=pq.top();\\n             pq.pop();\\n            int t=v[0];\\n            int x=v[1],y=v[2];\\n            if(x==m-1&&y==n-1)\\n                 return t;\\n            if(vis[x][y])\\n                continue;\\n            vis[x][y]=true;\\n            for(int i=0;i<4;i++)\\n            {\\n                int nx=x+dir[i],ny=y+dir[i+1];\\n                if(nx<0||ny<0||nx>=m||ny>=n||vis[nx][ny])\\n                    continue;\\n                int wait=(grid[nx][ny]-t)%2==0;\\n                pq.push({max(grid[nx][ny]+wait,t+1),nx,ny});\\n            }\\n            \\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240210,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n     int minimumTime(vector<vector<int>>& g) {\\n        int n = g.size();\\n        int m = g[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        priority_queue< pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater< pair<int,pair<int,int>> > >pq;\\n        pq.push({0,{0,0}});\\n        vis[0][0] = 1;\\n        int dx[4]={1,-1,0,0};\\n        int dy[4]={0,0,-1,1};\\n         int ans = 1e7;\\n          bool entry = false;\\n        while(pq.size()){\\n            int t = pq.top().first;\\n            int x = pq.top().second.first;\\n            int y = pq.top().second.second;\\n            pq.pop();\\n            if(x == n-1 && y == m-1)\\n                ans=min(ans,t);\\n           \\n            for(int k=0;k<4;k++){\\n                int nx = dx[k]+x;\\n                int ny=dy[k]+y;\\n                if(nx<0||ny<0||nx>=n||ny>=m ||vis[nx][ny]==1)continue;\\n                if(t+1 >= g[nx][ny]){\\n                    pq.push({t+1,{nx,ny}});\\n                    vis[nx][ny]=1;\\n                    entry = true;\\n                }\\n                else {\\n                    int diff = g[nx][ny]-t;\\n                    if(diff%2==0){\\n                        pq.push({g[nx][ny]+1,{nx,ny}});\\n                    }\\n                    else \\n                        pq.push({g[nx][ny],{nx,ny}});\\n                    vis[nx][ny]=1;\\n                }\\n            }\\n            if(entry == false)\\n                return -1;\\n           \\n        }\\n         return ans;\\n     }\\n        \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n     int minimumTime(vector<vector<int>>& g) {\\n        int n = g.size();\\n        int m = g[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        priority_queue< pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater< pair<int,pair<int,int>> > >pq;\\n        pq.push({0,{0,0}",
                "codeTag": "Java"
            },
            {
                "id": 3240007,
                "title": "one-queue-and-one-priority-queue-432ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size(), n = grid[0].size(), time = 0;\\n        if(grid[0][1] >= 2 && grid[1][0] >= 2)\\n        {\\n            return -1;\\n        }\\n        vector<vector<bool>> visited(m, vector<bool>(n));\\n        visited[0][0] = true;\\n        queue<pair<int, int>> q;\\n        auto cmp = [](const vector<int>& v1, const vector<int>& v2)\\n        {\\n            return v1[0] > v2[0];\\n        };\\n        priority_queue<vector<int>, vector<vector<int>>, decltype(cmp)> pq(cmp);\\n        q.push({0, 0});\\n        vector<vector<int>> dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        while(true)\\n        {\\n            int cnt = q.size();\\n            while(cnt--)\\n            {\\n                auto [r, c] = q.front();\\n                if(r == m - 1 && c == n - 1)\\n                {\\n                    return time;\\n                }\\n                q.pop();\\n                for(int j = 0; j < 4; j++)\\n                {\\n                    int nr = r + dir[j][0], nc = c + dir[j][1];\\n                    if(nr >= 0 && nr < m && nc >= 0 && nc < n && !visited[nr][nc])\\n                    {\\n                        visited[nr][nc] = true;\\n                        if(time + 1 >= grid[nr][nc])\\n                        {    \\n                            q.push({nr, nc});\\n                        }\\n                        else\\n                        {\\n                            grid[nr][nc] += !((time & 1) ^ (grid[nr][nc] & 1));\\n                            pq.push({grid[nr][nc], nr, nc});\\n                        }\\n                    }\\n                }\\n            }\\n            time = (!pq.empty() && q.empty()) ? pq.top()[0] - 1 : time;\\n            while(!pq.empty() && time + 1 >= pq.top()[0])\\n            {\\n                q.push({pq.top()[1], pq.top()[2]});\\n                pq.pop();\\n            }\\n            time++;\\n        }\\n        return -1;      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size(), n = grid[0].size(), time = 0;\\n        if(grid[0][1] >= 2 && grid[1][0] >= 2)\\n        {\\n            return -1;\\n        }\\n        vector<vector<bool>> visited(m, vector<bool>(n));\\n        visited[0][0] = true;\\n        queue<pair<int, int>> q;\\n        auto cmp = [](const vector<int>& v1, const vector<int>& v2)\\n        {\\n            return v1[0] > v2[0];\\n        };\\n        priority_queue<vector<int>, vector<vector<int>>, decltype(cmp)> pq(cmp);\\n        q.push({0, 0});\\n        vector<vector<int>> dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        while(true)\\n        {\\n            int cnt = q.size();\\n            while(cnt--)\\n            {\\n                auto [r, c] = q.front();\\n                if(r == m - 1 && c == n - 1)\\n                {\\n                    return time;\\n                }\\n                q.pop();\\n                for(int j = 0; j < 4; j++)\\n                {\\n                    int nr = r + dir[j][0], nc = c + dir[j][1];\\n                    if(nr >= 0 && nr < m && nc >= 0 && nc < n && !visited[nr][nc])\\n                    {\\n                        visited[nr][nc] = true;\\n                        if(time + 1 >= grid[nr][nc])\\n                        {    \\n                            q.push({nr, nc});\\n                        }\\n                        else\\n                        {\\n                            grid[nr][nc] += !((time & 1) ^ (grid[nr][nc] & 1));\\n                            pq.push({grid[nr][nc], nr, nc});\\n                        }\\n                    }\\n                }\\n            }\\n            time = (!pq.empty() && q.empty()) ? pq.top()[0] - 1 : time;\\n            while(!pq.empty() && time + 1 >= pq.top()[0])\\n            {\\n                q.push({pq.top()[1], pq.top()[2]});\\n                pq.pop();\\n            }\\n            time++;\\n        }\\n        return -1;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239201,
                "title": "java-modification-of-dijecstra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int minimumTime(int[][] grid) {\\n    if(grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n\\n    int y = grid.length, x = grid[0].length;\\n\\n    int t[][] = new int[y][];\\n    for(int i = 0; i != y; i++){\\n      t[i] = new int[x];\\n      Arrays.fill(t[i], Integer.MAX_VALUE);\\n    }\\n    PriorityQueue<int[]> q = new PriorityQueue<>(y*x, (int[] a, int[] b) -> a[0] - b[0]);   //step, row, column\\n    q.add(new int[]{0, 0, 0});\\n    t[0][0] = 0;\\n  \\n    while(!q.isEmpty()){\\n      int cell[] = q.poll();\\n      int step = cell[0], r = cell[1], c = cell[2]; \\n\\n      int coor[] = new int[]{-1, 0, 1, 0 , -1};\\n      for(int i = 1; i != 5; i++){\\n        int R = r + coor[i-1], C = c + coor[i], next_step;\\n        if(R == -1 || C == -1 || R == y || C == x) continue;\\n\\n        if(grid[R][C] - 1 <= step) next_step = step + 1;\\n        else next_step = grid[R][C] + ((grid[R][C] - step + 1) & 1);\\n\\n        if(t[R][C] > next_step){\\n          q.add(new int[]{next_step, R, C});\\n          t[R][C] = next_step;\\n        }\\n      } \\n    }\\n\\n    return t[y-1][x-1];    \\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int minimumTime(int[][] grid) {\\n    if(grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n\\n    int y = grid.length, x = grid[0].length;\\n\\n    int t[][] = new int[y][];\\n    for(int i = 0; i != y; i++){\\n      t[i] = new int[x];\\n      Arrays.fill(t[i], Integer.MAX_VALUE);\\n    }\\n    PriorityQueue<int[]> q = new PriorityQueue<>(y*x, (int[] a, int[] b) -> a[0] - b[0]);   //step, row, column\\n    q.add(new int[]{0, 0, 0});\\n    t[0][0] = 0;\\n  \\n    while(!q.isEmpty()){\\n      int cell[] = q.poll();\\n      int step = cell[0], r = cell[1], c = cell[2]; \\n\\n      int coor[] = new int[]{-1, 0, 1, 0 , -1};\\n      for(int i = 1; i != 5; i++){\\n        int R = r + coor[i-1], C = c + coor[i], next_step;\\n        if(R == -1 || C == -1 || R == y || C == x) continue;\\n\\n        if(grid[R][C] - 1 <= step) next_step = step + 1;\\n        else next_step = grid[R][C] + ((grid[R][C] - step + 1) & 1);\\n\\n        if(t[R][C] > next_step){\\n          q.add(new int[]{next_step, R, C});\\n          t[R][C] = next_step;\\n        }\\n      } \\n    }\\n\\n    return t[y-1][x-1];    \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237468,
                "title": "javascript-dijkstra-with-priority-queue",
                "content": "# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n var minimumTime = function(grid) {\\n    if (grid[0][1] > 1 && grid[1][0] > 1) {\\n        return -1;\\n    }  \\n    const dp = new Array(grid.length).fill().map(_ => new Array(grid[0].length).fill());\\n    const dir = [1, 0, -1, 0, 1];\\n    const pq = new MinPriorityQueue({\\n        compare: (a, b) => a[0]-b[0]\\n    })\\n    pq.enqueue([0, 0, 0]);\\n    while (pq.size() > 0) {\\n        // Pick the node with the min potential value of time to visit\\n        const [val, i, j] = pq.dequeue();\\n        if (dp[i][j] != null) {\\n            continue;\\n        }\\n        dp[i][j] = val;\\n        if (i === grid.length-1 && j === grid[0].length-1) {\\n            break;\\n        }\\n        for (let k = 0; k < 4; ++k) {\\n            const [ni, nj] = [i+dir[k], j+dir[k+1]];\\n            if (ni >= 0 && nj >= 0 && ni < grid.length && nj < grid[0].length && dp[ni][nj] == null) {\\n                // 1 + dp[i][j]: Move 1 step from [i, j] to [ni, nj];\\n                // grid[ni][nj] + (grid[ni][nj] & 1 ^ (ni+nj) & 1): After some back and forth in [i, j], finally reach the time\\n                // of grid[ni][nj], depending on its value and position, we may need to add 1 to it.\\n                const pVal = Math.max(1 + dp[i][j], grid[ni][nj] + (grid[ni][nj] & 1 ^ (ni+nj) & 1));\\n                pq.enqueue([pVal, ni, nj]);\\n            }\\n        }\\n    }\\n    return dp[grid.length-1][grid[0].length-1];\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n var minimumTime = function(grid) {\\n    if (grid[0][1] > 1 && grid[1][0] > 1) {\\n        return -1;\\n    }  \\n    const dp = new Array(grid.length).fill().map(_ => new Array(grid[0].length).fill());\\n    const dir = [1, 0, -1, 0, 1];\\n    const pq = new MinPriorityQueue({\\n        compare: (a, b) => a[0]-b[0]\\n    })\\n    pq.enqueue([0, 0, 0]);\\n    while (pq.size() > 0) {\\n        // Pick the node with the min potential value of time to visit\\n        const [val, i, j] = pq.dequeue();\\n        if (dp[i][j] != null) {\\n            continue;\\n        }\\n        dp[i][j] = val;\\n        if (i === grid.length-1 && j === grid[0].length-1) {\\n            break;\\n        }\\n        for (let k = 0; k < 4; ++k) {\\n            const [ni, nj] = [i+dir[k], j+dir[k+1]];\\n            if (ni >= 0 && nj >= 0 && ni < grid.length && nj < grid[0].length && dp[ni][nj] == null) {\\n                // 1 + dp[i][j]: Move 1 step from [i, j] to [ni, nj];\\n                // grid[ni][nj] + (grid[ni][nj] & 1 ^ (ni+nj) & 1): After some back and forth in [i, j], finally reach the time\\n                // of grid[ni][nj], depending on its value and position, we may need to add 1 to it.\\n                const pVal = Math.max(1 + dp[i][j], grid[ni][nj] + (grid[ni][nj] & 1 ^ (ni+nj) & 1));\\n                pq.enqueue([pVal, ni, nj]);\\n            }\\n        }\\n    }\\n    return dp[grid.length-1][grid[0].length-1];\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3236725,
                "title": "matrix-dikstra-time",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        if grid[1][0] > 1 and grid[0][1] > 1: return -1\\n        dis = [[inf for _ in range(n)] for _ in range(m)]\\n        dis[0][0] = 0\\n        h = [(0, 0, 0)]\\n        while h:\\n            d, i, j = heapq.heappop(h)\\n            if i == m - 1 and j == n - 1:\\n                return d\\n            for x, y in (i+1, j), (i, j+1), (i-1, j), (i, j-1):\\n                if 0 <= x < m and 0 <= y < n:\\n                    nd = max(d + 1, grid[x][y])\\n                    nd += (nd - x - y) % 2\\n                    if nd < dis[x][y]:\\n                        dis[x][y] = nd\\n                        heappush(h, (nd, x, y))\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        if grid[1][0] > 1 and grid[0][1] > 1: return -1\\n        dis = [[inf for _ in range(n)] for _ in range(m)]\\n        dis[0][0] = 0\\n        h = [(0, 0, 0)]\\n        while h:\\n            d, i, j = heapq.heappop(h)\\n            if i == m - 1 and j == n - 1:\\n                return d\\n            for x, y in (i+1, j), (i, j+1), (i-1, j), (i, j-1):\\n                if 0 <= x < m and 0 <= y < n:\\n                    nd = max(d + 1, grid[x][y])\\n                    nd += (nd - x - y) % 2\\n                    if nd < dis[x][y]:\\n                        dis[x][y] = nd\\n                        heappush(h, (nd, x, y))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236613,
                "title": "c-clean-dijkstra-with-explanation",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef pair<int, int> p;\\n    typedef pair<int, p> ip;//pair<time, pair<row,col>> -- push to min heap\\n    priority_queue<ip, vector<ip>, greater<ip> > pq;//min heap of pair<time, pair<row,col>> \\n    int minimumTime(vector<vector<int>>& grid) {\\n        //if we can either jump downwards or rightwards from [0,0] we can jump to the destination since we can jump repeatly between [0,0] and our next step to earn the time we need\\n        if (grid[0][1] >1 && grid[1][0]>1){\\n            return -1;\\n        }\\n        //from each cell, we can jump to any adjacent cell if it\\'s in bound, in order to reach the destination faster,we should be greedy and choose the adjacent cell with the minimum distance from [0,0] (Dijkstra\\'s Algorithm)\\n        //here we have one constraint. if t+1 < adjacent cell\\'s value, we need to take adjacent cell\\'s value or adjacent cell\\'s value+1 since we have to jump backwards to kill some time\\n        vector<int> v(grid[0].size(), 10000000);//initialize as max. value\\n        vector<vector<int>> time(grid.size(), v);//record min time for each point in the grid\\n        vector<vector<int>> visited(grid.size(), v);\\n        //mark the effort of starting point as 0\\n        time[0][0] = 0;\\n        p p1 = { 0,0 };\\n        ip p0 = make_pair(0, p1);\\n        pq.push(p0); //put starting point to the minheap and start our Algorithm\\n        while (!pq.empty()){\\n            int row = pq.top().second.first;\\n            int col = pq.top().second.second;\\n            int t = pq.top().first;\\n            if (row == grid.size() - 1 && col == grid[0].size() - 1) {//reached\\n                return t;\\n            }\\n            //add it to visited set and pop it\\n            visited[row][col] = 1;\\n            pq.pop();\\n            //examine its unvisited neighbours         \\n            p right = { row,col + 1 };\\n            p left = { row, col - 1 };\\n            p up = { row - 1,col };\\n            p down = { row + 1,col };\\n            vector<p> neighbours = { right,left,up,down };\\n            for (int i = 0; i < neighbours.size(); i++) {\\n                int r = neighbours[i].first;\\n                int c = neighbours[i].second;\\n                if (r >= 0 && r < grid.size() && c >= 0 && c < grid[0].size() && visited[r][c] != 1) {//unvisited neighbour\\n                    int timeToReach = t +1;\\n                    if (timeToReach < grid[r][c]){//we have to jump around until grid[r][c]\\n                        if ((grid[r][c] - t)%2 ==0){\\n                            timeToReach = grid[r][c]+1;//we have to jump even number of times\\n                        } else{\\n                            timeToReach = grid[r][c];\\n                        }\\n                    }\\n                    if (timeToReach < time[r][c]) {\\n                        time[r][c] = timeToReach;\\n                        //put this node into min heap\\n                        p p1 = { r,c };\\n                        ip p0 = make_pair(timeToReach, p1);\\n                        pq.push(p0);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef pair<int, int> p;\\n    typedef pair<int, p> ip;//pair<time, pair<row,col>> -- push to min heap\\n    priority_queue<ip, vector<ip>, greater<ip> > pq;//min heap of pair<time, pair<row,col>> \\n    int minimumTime(vector<vector<int>>& grid) {\\n        //if we can either jump downwards or rightwards from [0,0] we can jump to the destination since we can jump repeatly between [0,0] and our next step to earn the time we need\\n        if (grid[0][1] >1 && grid[1][0]>1){\\n            return -1;\\n        }\\n        //from each cell, we can jump to any adjacent cell if it\\'s in bound, in order to reach the destination faster,we should be greedy and choose the adjacent cell with the minimum distance from [0,0] (Dijkstra\\'s Algorithm)\\n        //here we have one constraint. if t+1 < adjacent cell\\'s value, we need to take adjacent cell\\'s value or adjacent cell\\'s value+1 since we have to jump backwards to kill some time\\n        vector<int> v(grid[0].size(), 10000000);//initialize as max. value\\n        vector<vector<int>> time(grid.size(), v);//record min time for each point in the grid\\n        vector<vector<int>> visited(grid.size(), v);\\n        //mark the effort of starting point as 0\\n        time[0][0] = 0;\\n        p p1 = { 0,0 };\\n        ip p0 = make_pair(0, p1);\\n        pq.push(p0); //put starting point to the minheap and start our Algorithm\\n        while (!pq.empty()){\\n            int row = pq.top().second.first;\\n            int col = pq.top().second.second;\\n            int t = pq.top().first;\\n            if (row == grid.size() - 1 && col == grid[0].size() - 1) {//reached\\n                return t;\\n            }\\n            //add it to visited set and pop it\\n            visited[row][col] = 1;\\n            pq.pop();\\n            //examine its unvisited neighbours         \\n            p right = { row,col + 1 };\\n            p left = { row, col - 1 };\\n            p up = { row - 1,col };\\n            p down = { row + 1,col };\\n            vector<p> neighbours = { right,left,up,down };\\n            for (int i = 0; i < neighbours.size(); i++) {\\n                int r = neighbours[i].first;\\n                int c = neighbours[i].second;\\n                if (r >= 0 && r < grid.size() && c >= 0 && c < grid[0].size() && visited[r][c] != 1) {//unvisited neighbour\\n                    int timeToReach = t +1;\\n                    if (timeToReach < grid[r][c]){//we have to jump around until grid[r][c]\\n                        if ((grid[r][c] - t)%2 ==0){\\n                            timeToReach = grid[r][c]+1;//we have to jump even number of times\\n                        } else{\\n                            timeToReach = grid[r][c];\\n                        }\\n                    }\\n                    if (timeToReach < time[r][c]) {\\n                        time[r][c] = timeToReach;\\n                        //put this node into min heap\\n                        p p1 = { r,c };\\n                        ip p0 = make_pair(timeToReach, p1);\\n                        pq.push(p0);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235209,
                "title": "dijkstra-s",
                "content": "# Intuition\\nWe want to find minimum time to reach bottom right cell. We\\'ll have to traverse the matrix as the time in each cell allows. We can use a priority queue to keep track of time.\\nSome things to keep in mind:\\n\\nIf we can not move to the neighboring cells from starting position we can not move anywhere in the matrix hence answer is -1.\\nBut if we can move to the neighboring cells from starting position, we can move anywhere in the matrix. We can wait by playing \"ping pong\" between previous cell and current cell till a neighboring cell opens up.\\n\\nby @tojuna\\n\\n# Approach\\n1) if grid[0][1] > 1 and grid[1][0] > 1 we can not move anywhere from cell grid[0][0] hence answer is -1\\n\\n2) Use priority queue to find next cell with minimum time to move to it\\n3) If time for a neighbor (target) cell is > 1 + time for current cell. We can not directly move to target cell. We will have to \"ping pong\" between previous cell and current cell. When playing ping pong between previous and current cell there can be two cases.\\n\\nThere are 4 cases in this problem\\n1) if new_time is even and our time is even then time required is new_time+1\\n2) if new_time is even and our time is odd then time required is new_time+0\\n3) if new_time is odd and our time is odd then time required is new_time+1\\n4) if new_time is odd and our time is even then time required is new_time.\\n\\nin short ->\\nif new_time-time is even (case 1,case 3) then push new_time+1\\nelse push new_time\\n\\n\\n# Complexity\\n- Time complexity:\\no(m*n log(m*n)) as total elements are m*n and time comp to push k elements in pq is klogk.\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int minimumTime(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        if(grid[0][0]!=0) return -1;\\n        if(n>1 && m>1 && grid[0][1]>1 && grid[1][0]>1) return -1;\\n        vector<int>delRow={0,0,1,-1};\\n        vector<int>delCol={1,-1,0,0};\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({0,{0,0}});\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n      \\n   while(!pq.empty())\\n    {\\n        auto node=pq.top();\\n        pq.pop();\\n        int time=node.first;\\n        int i=node.second.first;\\n        int j=node.second.second;\\n        if(i==n-1 && j==m-1) return time;\\n        if (vis[i][j]) continue;\\n        vis[i][j]=1;\\n\\n        for(int indx=0;indx<4;indx++)\\n        {\\n            int newRow=i+delRow[indx];\\n            int newCol=j+delCol[indx];\\n            \\n            if(newRow>=0 && newRow<n && newCol>=0 && newCol<m && vis[newRow][newCol]==0)  // if we don\\'t require to ping pong\\n            {\\n                int new_time=grid[newRow][newCol];\\n                if(new_time<=(time+1)) pq.push({time+1,{newRow,newCol}});\\n\\n                else if((new_time-time)%2==0)\\n                pq.push({new_time+1,{newRow,newCol}});\\n                else\\n                pq.push({new_time,{newRow,newCol}});\\n                \\n\\n\\n            }\\n        }\\n    }\\n\\n    return -1;\\n       \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minimumTime(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        if(grid[0][0]!=0) return -1;\\n        if(n>1 && m>1 && grid[0][1]>1 && grid[1][0]>1) return -1;\\n        vector<int>delRow={0,0,1,-1};\\n        vector<int>delCol={1,-1,0,0};\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({0,{0,0}});\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n      \\n   while(!pq.empty())\\n    {\\n        auto node=pq.top();\\n        pq.pop();\\n        int time=node.first;\\n        int i=node.second.first;\\n        int j=node.second.second;\\n        if(i==n-1 && j==m-1) return time;\\n        if (vis[i][j]) continue;\\n        vis[i][j]=1;\\n\\n        for(int indx=0;indx<4;indx++)\\n        {\\n            int newRow=i+delRow[indx];\\n            int newCol=j+delCol[indx];\\n            \\n            if(newRow>=0 && newRow<n && newCol>=0 && newCol<m && vis[newRow][newCol]==0)  // if we don\\'t require to ping pong\\n            {\\n                int new_time=grid[newRow][newCol];\\n                if(new_time<=(time+1)) pq.push({time+1,{newRow,newCol}});\\n\\n                else if((new_time-time)%2==0)\\n                pq.push({new_time+1,{newRow,newCol}});\\n                else\\n                pq.push({new_time,{newRow,newCol}});\\n                \\n\\n\\n            }\\n        }\\n    }\\n\\n    return -1;\\n       \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235167,
                "title": "javascript-bfs-min-heap-pq-443ms",
                "content": "```\\nconst initialize2DArray = (n, m) => [...Array(n)].map(() => Array(m).fill(Number.MAX_SAFE_INTEGER));\\nconst dx = [-1, 1, 0, 0], dy = [0, 0, -1, 1];\\n\\nconst minimumTime = (g) => {\\n    if (g[0][1] > 1 && g[1][0] > 1) return -1;\\n    let pq = new MinPriorityQueue({\\n        compare: (x, y) => {\\n            if (x[0] != y[0]) return x[0] - y[0];\\n            if (x[1] != y[1]) return x[1] - y[1];\\n            return x[2] - y[2];\\n        }\\n    }), n = g.length, m = g[0].length, dis = initialize2DArray(n, m);\\n    pq.enqueue([0, 0, 0]);\\n    dis[0][0] = 0;\\n    while (pq.size()) {\\n        let [v, x, y] = pq.dequeue()\\n        if (x == n - 1 && y == m - 1) return v;\\n        for (let k = 0; k < 4; k++) {\\n            let nx = x + dx[k], ny = y + dy[k];\\n            if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;\\n            let diff = g[nx][ny] - v;\\n            if (diff < 0) {\\n                diff = 0;\\n            } else if (diff & 1) {\\n                diff--;\\n            }\\n            let nv = v + 1 + diff;\\n            if (dis[nx][ny] > nv) {\\n                dis[nx][ny] = nv;\\n                pq.enqueue([nv, nx, ny]);\\n            }\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Heap (Priority Queue)",
                    "Matrix"
                ],
                "code": "```\\nconst initialize2DArray = (n, m) => [...Array(n)].map(() => Array(m).fill(Number.MAX_SAFE_INTEGER));\\nconst dx = [-1, 1, 0, 0], dy = [0, 0, -1, 1];\\n\\nconst minimumTime = (g) => {\\n    if (g[0][1] > 1 && g[1][0] > 1) return -1;\\n    let pq = new MinPriorityQueue({\\n        compare: (x, y) => {\\n            if (x[0] != y[0]) return x[0] - y[0];\\n            if (x[1] != y[1]) return x[1] - y[1];\\n            return x[2] - y[2];\\n        }\\n    }), n = g.length, m = g[0].length, dis = initialize2DArray(n, m);\\n    pq.enqueue([0, 0, 0]);\\n    dis[0][0] = 0;\\n    while (pq.size()) {\\n        let [v, x, y] = pq.dequeue()\\n        if (x == n - 1 && y == m - 1) return v;\\n        for (let k = 0; k < 4; k++) {\\n            let nx = x + dx[k], ny = y + dy[k];\\n            if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;\\n            let diff = g[nx][ny] - v;\\n            if (diff < 0) {\\n                diff = 0;\\n            } else if (diff & 1) {\\n                diff--;\\n            }\\n            let nv = v + 1 + diff;\\n            if (dis[nx][ny] > nv) {\\n                dis[nx][ny] = nv;\\n                pq.enqueue([nv, nx, ny]);\\n            }\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3235046,
                "title": "antarnab-date-27-02-2023-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   // public int minimumTime(int[][] grid) {\\n        public int minimumTime(int[][] grid) {\\n    if (grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n    \\n    int m = grid.length, n = grid[0].length;\\n    int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    boolean[][] visited = new boolean[m][n];\\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));\\n    pq.offer(new int[]{grid[0][0], 0, 0});\\n    \\n    while (!pq.isEmpty()) {\\n        int[] curr = pq.poll();\\n        int time = curr[0], row = curr[1], col = curr[2];\\n        \\n        if (row == m - 1 && col == n - 1) return time;\\n        if (visited[row][col]) continue;\\n        visited[row][col] = true;\\n        \\n        for (int[] dir : dirs) {\\n            int r = row + dir[0], c = col + dir[1];\\n            if (r < 0 || r >= m || c < 0 || c >= n || visited[r][c]) continue;\\n            int wait = ((grid[r][c] - time) % 2 == 0) ? 1 : 0;\\n            pq.offer(new int[]{Math.max(grid[r][c] + wait, time + 1), r, c});\\n        }\\n    }\\n    return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   // public int minimumTime(int[][] grid) {\\n        public int minimumTime(int[][] grid) {\\n    if (grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n    \\n    int m = grid.length, n = grid[0].length;\\n    int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    boolean[][] visited = new boolean[m][n];\\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));\\n    pq.offer(new int[]{grid[0][0], 0, 0});\\n    \\n    while (!pq.isEmpty()) {\\n        int[] curr = pq.poll();\\n        int time = curr[0], row = curr[1], col = curr[2];\\n        \\n        if (row == m - 1 && col == n - 1) return time;\\n        if (visited[row][col]) continue;\\n        visited[row][col] = true;\\n        \\n        for (int[] dir : dirs) {\\n            int r = row + dir[0], c = col + dir[1];\\n            if (r < 0 || r >= m || c < 0 || c >= n || visited[r][c]) continue;\\n            int wait = ((grid[r][c] - time) % 2 == 0) ? 1 : 0;\\n            pq.offer(new int[]{Math.max(grid[r][c] + wait, time + 1), r, c});\\n        }\\n    }\\n    return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235012,
                "title": "simple-easy-to-understand-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    using pi = pair<int,int>;\\n    bool canGoBack(vector<vector<int>> &grid, vector<vector<int>> &dir, int time, int x, int y) {\\n        int m = grid.size(); int n = grid[0].size();\\n        for (auto &d : dir) {\\n            int nx = x + d[0]; int ny = y + d[1];\\n            if (nx >= m || nx < 0 || ny < 0 || ny >= n)\\n                continue;\\n            if (grid[nx][ny] <= time)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int minimumTime(vector<vector<int>>& grid) {\\n        vector<vector<int>> dir = {{0,1}, {0,-1}, {1,0}, {-1,0}};\\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\\n        pq.push({0,0});\\n        int m = grid.size(); int n = grid[0].size();\\n        vector<vector<bool>> visited(m,vector<bool>(n,false));\\n        while (!pq.empty()) {\\n            auto [time,idx] = pq.top();\\n            pq.pop();\\n            int x = idx/n; int y = idx%n;\\n            if ((x == m-1) && (y == n-1))\\n                return time;\\n            \\n            for (auto &d : dir) {\\n                int nx = x + d[0]; int ny = y + d[1];\\n                if (nx >= m || nx < 0 || ny < 0 || ny >= n || visited[nx][ny])\\n                    continue;\\n                int nidx = nx*n + ny;\\n                int nxt = time + 1;\\n                if (nxt < grid[nx][ny]) {\\n                    if (!canGoBack(grid,dir,nxt,x,y)) {\\n                        continue;\\n                    }\\n                    int gap = grid[nx][ny]-time;\\n                    nxt = time + ((gap%2 == 0) ? gap+1 : gap);\\n                }\\n                visited[nx][ny] = true;\\n                pq.push({nxt,nidx});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    using pi = pair<int,int>;\\n    bool canGoBack(vector<vector<int>> &grid, vector<vector<int>> &dir, int time, int x, int y) {\\n        int m = grid.size(); int n = grid[0].size();\\n        for (auto &d : dir) {\\n            int nx = x + d[0]; int ny = y + d[1];\\n            if (nx >= m || nx < 0 || ny < 0 || ny >= n)\\n                continue;\\n            if (grid[nx][ny] <= time)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int minimumTime(vector<vector<int>>& grid) {\\n        vector<vector<int>> dir = {{0,1}, {0,-1}, {1,0}, {-1,0}};\\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\\n        pq.push({0,0});\\n        int m = grid.size(); int n = grid[0].size();\\n        vector<vector<bool>> visited(m,vector<bool>(n,false));\\n        while (!pq.empty()) {\\n            auto [time,idx] = pq.top();\\n            pq.pop();\\n            int x = idx/n; int y = idx%n;\\n            if ((x == m-1) && (y == n-1))\\n                return time;\\n            \\n            for (auto &d : dir) {\\n                int nx = x + d[0]; int ny = y + d[1];\\n                if (nx >= m || nx < 0 || ny < 0 || ny >= n || visited[nx][ny])\\n                    continue;\\n                int nidx = nx*n + ny;\\n                int nxt = time + 1;\\n                if (nxt < grid[nx][ny]) {\\n                    if (!canGoBack(grid,dir,nxt,x,y)) {\\n                        continue;\\n                    }\\n                    int gap = grid[nx][ny]-time;\\n                    nxt = time + ((gap%2 == 0) ? gap+1 : gap);\\n                }\\n                visited[nx][ny] = true;\\n                pq.push({nxt,nidx});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235010,
                "title": "easy-python",
                "content": "<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\njust do dijkstra with modifications\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        q=[(0,(0,0))]\\n        dp=[[float(\"inf\")]*len(grid[0]) for i in range(len(grid))]\\n        dp[0][0]=0\\n        while q:\\n            t,pt=heapq.heappop(q)\\n            t+=1\\n            for (dx,dy) in [(0,1),(0,-1),(1,0),(-1,0)]:\\n                x=pt[0]+dx\\n                y= pt[1]+dy\\n                if x<len(grid) and y<len(grid[0]) and x>=0 and y>=0:\\n                    if t>=grid[x][y]:\\n                        if t<dp[x][y]:\\n                            dp[x][y]=t\\n                            heapq.heappush(q,(t,(x,y)))\\n                    else:\\n                        if pt!=(0,0):\\n                            req=ceil((grid[x][y]-t)/2)*2\\n                            req+=t\\n                            if req<dp[x][y]:\\n                                dp[x][y]=req\\n                                heapq.heappush(q,(req,(x,y)))\\n        ans=dp[-1][-1]\\n        if ans==float(\"inf\"):\\n            return -1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        q=[(0,(0,0))]\\n        dp=[[float(\"inf\")]*len(grid[0]) for i in range(len(grid))]\\n        dp[0][0]=0\\n        while q:\\n            t,pt=heapq.heappop(q)\\n            t+=1\\n            for (dx,dy) in [(0,1),(0,-1),(1,0),(-1,0)]:\\n                x=pt[0]+dx\\n                y= pt[1]+dy\\n                if x<len(grid) and y<len(grid[0]) and x>=0 and y>=0:\\n                    if t>=grid[x][y]:\\n                        if t<dp[x][y]:\\n                            dp[x][y]=t\\n                            heapq.heappush(q,(t,(x,y)))\\n                    else:\\n                        if pt!=(0,0):\\n                            req=ceil((grid[x][y]-t)/2)*2\\n                            req+=t\\n                            if req<dp[x][y]:\\n                                dp[x][y]=req\\n                                heapq.heappush(q,(req,(x,y)))\\n        ans=dp[-1][-1]\\n        if ans==float(\"inf\"):\\n            return -1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234986,
                "title": "clean-code-dijikstra-c",
                "content": "\\n```\\nint dir[4][2]={{-1,0},{1,0},{0,-1},{0,1}};\\n\\nbool valid(int r,int c,int n,int m)\\n{\\n    return r>=0 && c>=0 && r<n && c<m;\\n}\\nint dijikstra(vector<vector<int>>& grid)\\n{\\n    int n=grid.size();\\n    int m=grid[0].size();\\n  \\n    priority_queue<vector<int>>q;\\n    q.push({0,0,0});\\n    vector<vector<bool>>vis(n,vector<bool>(m,false));\\n    vector<vector<int>>dist(n,vector<int>(m,INT_MAX));\\n    dist[0][0]=0;\\n    while(q.size()>0)\\n    {\\n        vector<int>curr=q.top();\\n        q.pop();\\n        int curr_r=curr[1];\\n        int curr_c=curr[2];\\n        if(vis[curr_r][curr_c])continue;\\n        vis[curr_r][curr_c]=true;\\n        for(int i=0;i<4;i++)\\n        {\\n            int child_r=curr_r+dir[i][0];\\n            int child_c=curr_c+dir[i][1];\\n            if(!valid(child_r,child_c,n,m))continue;\\n            int wt=0;\\n            if(dist[curr_r][curr_c]+1>=grid[child_r][child_c])wt=1;\\n            else\\n            {\\n                int diff=(grid[child_r][child_c]-dist[curr_r][curr_c]);\\n                wt=diff;\\n                if(diff%2==0)wt++;\\n            }\\n            if(dist[child_r][child_c]>wt+dist[curr_r][curr_c])\\n            {\\n                dist[child_r][child_c]=wt+dist[curr_r][curr_c];\\n                q.push({-1*dist[child_r][child_c],child_r,child_c});\\n            }\\n        }\\n    }\\n    \\n    if(dist[n-1][m-1]==INT_MAX)return -1;\\n    return dist[n-1][m-1];\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        if(grid[0][1]>1 && grid[1][0]>1)return -1;\\n        return dijikstra(grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint dir[4][2]={{-1,0},{1,0},{0,-1},{0,1}};\\n\\nbool valid(int r,int c,int n,int m)\\n{\\n    return r>=0 && c>=0 && r<n && c<m;\\n}\\nint dijikstra(vector<vector<int>>& grid)\\n{\\n    int n=grid.size();\\n    int m=grid[0].size();\\n  \\n    priority_queue<vector<int>>q;\\n    q.push({0,0,0});\\n    vector<vector<bool>>vis(n,vector<bool>(m,false));\\n    vector<vector<int>>dist(n,vector<int>(m,INT_MAX));\\n    dist[0][0]=0;\\n    while(q.size()>0)\\n    {\\n        vector<int>curr=q.top();\\n        q.pop();\\n        int curr_r=curr[1];\\n        int curr_c=curr[2];\\n        if(vis[curr_r][curr_c])continue;\\n        vis[curr_r][curr_c]=true;\\n        for(int i=0;i<4;i++)\\n        {\\n            int child_r=curr_r+dir[i][0];\\n            int child_c=curr_c+dir[i][1];\\n            if(!valid(child_r,child_c,n,m))continue;\\n            int wt=0;\\n            if(dist[curr_r][curr_c]+1>=grid[child_r][child_c])wt=1;\\n            else\\n            {\\n                int diff=(grid[child_r][child_c]-dist[curr_r][curr_c]);\\n                wt=diff;\\n                if(diff%2==0)wt++;\\n            }\\n            if(dist[child_r][child_c]>wt+dist[curr_r][curr_c])\\n            {\\n                dist[child_r][child_c]=wt+dist[curr_r][curr_c];\\n                q.push({-1*dist[child_r][child_c],child_r,child_c});\\n            }\\n        }\\n    }\\n    \\n    if(dist[n-1][m-1]==INT_MAX)return -1;\\n    return dist[n-1][m-1];\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        if(grid[0][1]>1 && grid[1][0]>1)return -1;\\n        return dijikstra(grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234807,
                "title": "rust-heap",
                "content": "```rust\\nuse std::collections::{BinaryHeap, HashSet};\\nuse std::cmp::Ordering;\\n\\n#[derive(Eq, PartialEq)]\\nstruct TupleWithIndex {\\n    t: i32,\\n    i: usize,\\n    j: usize,\\n}\\n\\nimpl Ord for TupleWithIndex {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        other.t.cmp(&self.t)\\n    }\\n}\\n\\nimpl PartialOrd for TupleWithIndex {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        Some(self.cmp(other))\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn minimum_time(grid: Vec<Vec<i32>>) -> i32 {\\n        let m = grid.len();\\n        let n = grid[0].len();\\n        let mut seen = HashSet::new();\\n        let mut h = BinaryHeap::new();\\n        h.push(TupleWithIndex { t: 0, i: 0, j: 0 });\\n        while let Some(TupleWithIndex { t, i, j }) = h.pop() {\\n            if i == m - 1 && j == n - 1 {\\n                return t;\\n            }\\n            for (di, dj) in [(0, 1), (1, 0), (0, -1), (-1, 0)].iter() {\\n                let mut t2 = t + 1;\\n                let i2 = i as i32 + di;\\n                let j2 = j as i32 + dj;\\n                if i2 >= 0 && i2 < m as i32 && j2 >= 0 && j2 < n as i32 {\\n                    let key = (i2, j2);\\n                    if seen.contains(&key) {\\n                        continue;\\n                    }\\n                    seen.insert(key);\\n                    let i2 = i2 as usize;\\n                    let j2 = j2 as usize;\\n                    if t2 < grid[i2][j2] {\\n                        if t2 == 1 {\\n                            continue;\\n                        }\\n                        let dt = grid[i2][j2] - t2;\\n                        t2 += dt + dt % 2;\\n                    }\\n\\n                    h.push(TupleWithIndex { t: t2, i: i2, j: j2 });\\n                }\\n            }\\n        }\\n        -1\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse std::collections::{BinaryHeap, HashSet};\\nuse std::cmp::Ordering;\\n\\n#[derive(Eq, PartialEq)]\\nstruct TupleWithIndex {\\n    t: i32,\\n    i: usize,\\n    j: usize,\\n}\\n\\nimpl Ord for TupleWithIndex {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        other.t.cmp(&self.t)\\n    }\\n}\\n\\nimpl PartialOrd for TupleWithIndex {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        Some(self.cmp(other))\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn minimum_time(grid: Vec<Vec<i32>>) -> i32 {\\n        let m = grid.len();\\n        let n = grid[0].len();\\n        let mut seen = HashSet::new();\\n        let mut h = BinaryHeap::new();\\n        h.push(TupleWithIndex { t: 0, i: 0, j: 0 });\\n        while let Some(TupleWithIndex { t, i, j }) = h.pop() {\\n            if i == m - 1 && j == n - 1 {\\n                return t;\\n            }\\n            for (di, dj) in [(0, 1), (1, 0), (0, -1), (-1, 0)].iter() {\\n                let mut t2 = t + 1;\\n                let i2 = i as i32 + di;\\n                let j2 = j as i32 + dj;\\n                if i2 >= 0 && i2 < m as i32 && j2 >= 0 && j2 < n as i32 {\\n                    let key = (i2, j2);\\n                    if seen.contains(&key) {\\n                        continue;\\n                    }\\n                    seen.insert(key);\\n                    let i2 = i2 as usize;\\n                    let j2 = j2 as usize;\\n                    if t2 < grid[i2][j2] {\\n                        if t2 == 1 {\\n                            continue;\\n                        }\\n                        let dt = grid[i2][j2] - t2;\\n                        t2 += dt + dt % 2;\\n                    }\\n\\n                    h.push(TupleWithIndex { t: t2, i: i2, j: j2 });\\n                }\\n            }\\n        }\\n        -1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3234781,
                "title": "graph-search-with-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* The only way that we can\\'t reach the end is if we are stuck at the start cell. Otherwise, we can always shuffle back and forth.\\n* Obviously a graph search. Since this is weighted graph solution, priority queue seems appropriate to always take the shortest path. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* To start, check if we are stuck at the starting cell\\n* Initialize the heap and the visited variable\\n* Put starting cell in the queue\\n* Get the cell from the queue. \\n* Find it\\'s neighbours.\\n* Check if they are already visited, or out of bounds.\\n* THen check if it\\'s at the end.\\n* Now the key step is figuring out when we\\'ll reach the enxt cell. If we can do it immediately, it\\'s easy. Otherwise, we need to go back and forth until we can enter. So we are adding even number of units to the time elapsed.\\n \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m * n), where m and n are grid dimensions\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m * n)\\n# Code\\n```\\nclass Solution {\\n    int[][] directions = new int[][] {\\n        new int[] {-1, 0},\\n        new int[] {1, 0},\\n        new int[] {0, -1},\\n        new int[] {0, 1},\\n    };\\n\\n    public int minimumTime(int[][] grid) {\\n        // we can only be stuck on the starting grid, otherwise we can go back and forth\\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\\n            return -1;\\n        }\\n        // heap containing coordinates and when  the algorithm would reach there\\n        // 0: x axis\\n        // 1: y axis\\n        // 2: time\\n        PriorityQueue<int[]> heap = new PriorityQueue<int[]>((a, b) -> a[2] - b[2]); \\n        // start at the beginning\\n        heap.offer(new int[]{0, 0, 0});\\n        // variable keeping score of where we\\'ve been, so we don\\'t go in circles\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        visited[0][0] = true;\\n        while(heap.peek() != null){\\n            int[] current = heap.poll();\\n            // check the time\\n            int time = current[2] + 1;\\n            // check all neighbours\\n            for(int[] direction : directions){\\n                int x = current[0] + direction[0];\\n                int y = current[1] + direction[1];\\n                // stop if we are out of the grid, or if we already visited this neighbour  \\n                if(x < 0 || x == grid.length || y < 0 || y == grid[0].length || visited[x][y]) {\\n                    continue;\\n                }\\n                visited[x][y] = true;\\n                int gridTime = grid[x][y];\\n                // if the field is available, then go to it. Otherwise, go back and forth until we can \\n                // enter. If the diff is odd, add one more because we need to go back and forth so we are \\n                // late by 1\\n                int nextTime = time > gridTime ? time : gridTime + (gridTime - time) % 2;\\n                if (x == grid.length - 1 && y == grid[0].length - 1) {\\n                    return nextTime;\\n                }\\n                heap.offer(new int[]{ x, y, nextTime });\\n            }     \\n        }\\n        return grid[grid.length - 1][grid[0].length - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] directions = new int[][] {\\n        new int[] {-1, 0},\\n        new int[] {1, 0},\\n        new int[] {0, -1},\\n        new int[] {0, 1},\\n    };\\n\\n    public int minimumTime(int[][] grid) {\\n        // we can only be stuck on the starting grid, otherwise we can go back and forth\\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\\n            return -1;\\n        }\\n        // heap containing coordinates and when  the algorithm would reach there\\n        // 0: x axis\\n        // 1: y axis\\n        // 2: time\\n        PriorityQueue<int[]> heap = new PriorityQueue<int[]>((a, b) -> a[2] - b[2]); \\n        // start at the beginning\\n        heap.offer(new int[]{0, 0, 0});\\n        // variable keeping score of where we\\'ve been, so we don\\'t go in circles\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        visited[0][0] = true;\\n        while(heap.peek() != null){\\n            int[] current = heap.poll();\\n            // check the time\\n            int time = current[2] + 1;\\n            // check all neighbours\\n            for(int[] direction : directions){\\n                int x = current[0] + direction[0];\\n                int y = current[1] + direction[1];\\n                // stop if we are out of the grid, or if we already visited this neighbour  \\n                if(x < 0 || x == grid.length || y < 0 || y == grid[0].length || visited[x][y]) {\\n                    continue;\\n                }\\n                visited[x][y] = true;\\n                int gridTime = grid[x][y];\\n                // if the field is available, then go to it. Otherwise, go back and forth until we can \\n                // enter. If the diff is odd, add one more because we need to go back and forth so we are \\n                // late by 1\\n                int nextTime = time > gridTime ? time : gridTime + (gridTime - time) % 2;\\n                if (x == grid.length - 1 && y == grid[0].length - 1) {\\n                    return nextTime;\\n                }\\n                heap.offer(new int[]{ x, y, nextTime });\\n            }     \\n        }\\n        return grid[grid.length - 1][grid[0].length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234645,
                "title": "python3-my-heap-solution",
                "content": "## Short and sweet\\n```python\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        h = [(0, 0, 0)]\\n        seen = set()\\n        while h:\\n            t, i, j = heappop(h)\\n            if i == m - 1 and j == n - 1:\\n                return t\\n            for di, dj in ((0, 1), (1, 0), (0, -1), (-1, 0)):\\n                i2 = i + di\\n                j2 = j + dj\\n                if i2 in range(m) and j2 in range(n) and (i2, j2) not in seen:\\n                    t2 = t + 1\\n                    if t2 < grid[i2][j2]:\\n                        if t2 == 1:\\n                            continue\\n                        dt = grid[i2][j2] - t2\\n                        t2 += dt + dt % 2\\n                    seen.add((i2, j2))\\n                    heappush(h, (t2, i2, j2))\\n        return -1\\n```\\n\\n## Original, with comments\\n```python\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        h = []\\n        \\n        def pop():\\n            return heappop(h)\\n        \\n        seen = set()\\n        def push(t, i, j):\\n            key = (i, j)\\n            if key in seen:\\n                return\\n            \\n            if t < grid[i][j]:\\n                if t == 1:\\n                    # We are attempting to move off of the starting tile\\n                    # and have no where to go back to\\n                    return\\n                dt = grid[i][j] - t\\n                if dt % 2 == 0:\\n                    # We can go back and forth that many times to get there exactly\\n                    t += dt\\n                else:\\n                    # We have to do one more round trip to be allowed to visit\\n                    t += dt + 1\\n                    \\n            seen.add(key)\\n            heappush(h, (t, i, j))\\n            \\n        push(0, 0, 0)\\n        \\n        while h:\\n            t, i, j = pop()\\n            if i == m - 1 and j == n - 1:\\n                return t\\n            t2 = t + 1\\n            for di, dj in ((0, 1), (1, 0), (0, -1), (-1, 0)):\\n                i2 = i + di\\n                j2 = j + dj\\n                if i2 in range(m) and j2 in range(n):\\n                    push(t2, i2, j2)\\n            \\n        return -1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        h = [(0, 0, 0)]\\n        seen = set()\\n        while h:\\n            t, i, j = heappop(h)\\n            if i == m - 1 and j == n - 1:\\n                return t\\n            for di, dj in ((0, 1), (1, 0), (0, -1), (-1, 0)):\\n                i2 = i + di\\n                j2 = j + dj\\n                if i2 in range(m) and j2 in range(n) and (i2, j2) not in seen:\\n                    t2 = t + 1\\n                    if t2 < grid[i2][j2]:\\n                        if t2 == 1:\\n                            continue\\n                        dt = grid[i2][j2] - t2\\n                        t2 += dt + dt % 2\\n                    seen.add((i2, j2))\\n                    heappush(h, (t2, i2, j2))\\n        return -1\\n```\n```python\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        h = []\\n        \\n        def pop():\\n            return heappop(h)\\n        \\n        seen = set()\\n        def push(t, i, j):\\n            key = (i, j)\\n            if key in seen:\\n                return\\n            \\n            if t < grid[i][j]:\\n                if t == 1:\\n                    # We are attempting to move off of the starting tile\\n                    # and have no where to go back to\\n                    return\\n                dt = grid[i][j] - t\\n                if dt % 2 == 0:\\n                    # We can go back and forth that many times to get there exactly\\n                    t += dt\\n                else:\\n                    # We have to do one more round trip to be allowed to visit\\n                    t += dt + 1\\n                    \\n            seen.add(key)\\n            heappush(h, (t, i, j))\\n            \\n        push(0, 0, 0)\\n        \\n        while h:\\n            t, i, j = pop()\\n            if i == m - 1 and j == n - 1:\\n                return t\\n            t2 = t + 1\\n            for di, dj in ((0, 1), (1, 0), (0, -1), (-1, 0)):\\n                i2 = i + di\\n                j2 = j + dj\\n                if i2 in range(m) and j2 in range(n):\\n                    push(t2, i2, j2)\\n            \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234433,
                "title": "faster-than-100-modified-bfs-with-a-heap-keeping-first-possible-visiting-time-12-lines",
                "content": "# Intuition\\nAt start you must be able to make a move:\\n`if grid[0][1] > 1 and grid[1][0] > 1: return -1`\\n\\nAfter start we have at least 2 squares and we can go back and forth between them until we can go somewhere else.\\n\\n# Approach\\nKeep a heap with key being time of the first possible visit. Do the BFS movements. Every neighbouring cell will is visitable at the time `t+1` or at the time `grid[i][j]`, possibly plus one, since we can only visit cells at even or odd time depending where they are.\\n\\n# Upvote if you like the simplicity!\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        if grid[0][1] > 1 and grid[1][0] > 1: return -1\\n        q = [(0, 0, 0)]\\n        while True:\\n            t, r, c = heappop(q)\\n            t += 1\\n            for i, j in ((r-1,c), (r+1,c), (r, c-1), (r, c+1)):\\n                if i<0 or i>=m or j<0 or j>=n or grid[i][j] == -1: continue\\n                when = max(t, grid[i][j] + (1 if (t+grid[i][j])%2 else 0 ) )\\n                if i == m-1 and j == n-1: return when\\n                heappush(q, (when, i, j))\\n                grid[i][j] = -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        if grid[0][1] > 1 and grid[1][0] > 1: return -1\\n        q = [(0, 0, 0)]\\n        while True:\\n            t, r, c = heappop(q)\\n            t += 1\\n            for i, j in ((r-1,c), (r+1,c), (r, c-1), (r, c+1)):\\n                if i<0 or i>=m or j<0 or j>=n or grid[i][j] == -1: continue\\n                when = max(t, grid[i][j] + (1 if (t+grid[i][j])%2 else 0 ) )\\n                if i == m-1 and j == n-1: return when\\n                heappush(q, (when, i, j))\\n                grid[i][j] = -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234412,
                "title": "c-concise-dijkstra",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        if(grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n        const int n = grid.size(), m = grid[0].size();\\n        const vector<pair<int,int>> dirs = {{0,1},{0,-1},{-1,0},{1,0}};\\n        auto vv = vector(n, vector(m, -1));\\n        vv[0][0] = 0;\\n        priority_queue<tuple<int,int,int>> q; //-time, i, j\\n        q.emplace(0,0,0);\\n        while(1){\\n            auto [t, i, j] = q.top(); q.pop();\\n            for(auto [di, dj] : dirs){\\n                int x = i+di, y = j+dj;\\n                if(x<0 || x>=n || y<0 || y>=m || vv[x][y] > -1) continue;\\n                vv[x][y] = nextT(-t, grid[x][y]);\\n                if(x == n-1 && y== m-1) return vv[x][y] ;\\n                q.emplace(-vv[x][y], x, y);\\n            }\\n        }\\n    }\\n\\n    int nextT(int t, int minT){\\n        t++;\\n        if(t >= minT) return t;\\n        else return minT + (minT-t) % 2; //walk back and forth until t >= minT;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        if(grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n        const int n = grid.size(), m = grid[0].size();\\n        const vector<pair<int,int>> dirs = {{0,1},{0,-1},{-1,0},{1,0}};\\n        auto vv = vector(n, vector(m, -1));\\n        vv[0][0] = 0;\\n        priority_queue<tuple<int,int,int>> q; //-time, i, j\\n        q.emplace(0,0,0);\\n        while(1){\\n            auto [t, i, j] = q.top(); q.pop();\\n            for(auto [di, dj] : dirs){\\n                int x = i+di, y = j+dj;\\n                if(x<0 || x>=n || y<0 || y>=m || vv[x][y] > -1) continue;\\n                vv[x][y] = nextT(-t, grid[x][y]);\\n                if(x == n-1 && y== m-1) return vv[x][y] ;\\n                q.emplace(-vv[x][y], x, y);\\n            }\\n        }\\n    }\\n\\n    int nextT(int t, int minT){\\n        t++;\\n        if(t >= minT) return t;\\n        else return minT + (minT-t) % 2; //walk back and forth until t >= minT;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234237,
                "title": "python-dijkistra",
                "content": "```\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        \\n        q = [(0, 0, 0, 0)] # ts, steps, row, col\\n        R, C = len(grid), len(grid[0])\\n        seen = set()\\n    \\n        \\n        def find_correct_ts(_from, to, steps):\\n            # we have taken steps number of steps till now\\n            # example : _from = 3, to=5, steps=3\\n            # we are currently at 3th second and reached here in 3 steps\\n            # reach the destination of 5\\n            if steps == 0:\\n                return -1\\n            \\n            remains = to - _from # we need to pass these many more steps\\n            \\n            if remains % 2 == 0:\\n                return remains \\n            else:\\n                return remains + 1\\n            \\n    \\n        while q:\\n            ts, steps, row, col = heappop(q)\\n            \\n            if (row, col) == (R - 1, C - 1):\\n                return ts\\n            \\n            if (row, col) in seen:\\n                # we have reached this col with lesser ts, so no need\\n                continue\\n            \\n            seen.add((row, col))\\n            \\n            for dx, dy in [(0 ,1), (1, 0), (0, -1), (-1, 0)]:\\n                nx , ny = row + dx , col + dy\\n                \\n                if 0 <= nx < R and 0 <= ny < C and (nx, ny) not in seen:\\n                    ts_new = ts + 1\\n                    if grid[nx][ny] > ts_new:\\n                        ts_new = ts + find_correct_ts(ts, grid[nx][ny] - 1, steps) + 1\\n                    \\n                    if ts_new > 0: # returns -1 of not possible\\n                        heappush(q, (ts_new, steps + 1, nx, ny))\\n            \\n        return -1\\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        \\n        q = [(0, 0, 0, 0)] # ts, steps, row, col\\n        R, C = len(grid), len(grid[0])\\n        seen = set()\\n    \\n        \\n        def find_correct_ts(_from, to, steps):\\n            # we have taken steps number of steps till now\\n            # example : _from = 3, to=5, steps=3\\n            # we are currently at 3th second and reached here in 3 steps\\n            # reach the destination of 5\\n            if steps == 0:\\n                return -1\\n            \\n            remains = to - _from # we need to pass these many more steps\\n            \\n            if remains % 2 == 0:\\n                return remains \\n            else:\\n                return remains + 1\\n            \\n    \\n        while q:\\n            ts, steps, row, col = heappop(q)\\n            \\n            if (row, col) == (R - 1, C - 1):\\n                return ts\\n            \\n            if (row, col) in seen:\\n                # we have reached this col with lesser ts, so no need\\n                continue\\n            \\n            seen.add((row, col))\\n            \\n            for dx, dy in [(0 ,1), (1, 0), (0, -1), (-1, 0)]:\\n                nx , ny = row + dx , col + dy\\n                \\n                if 0 <= nx < R and 0 <= ny < C and (nx, ny) not in seen:\\n                    ts_new = ts + 1\\n                    if grid[nx][ny] > ts_new:\\n                        ts_new = ts + find_correct_ts(ts, grid[nx][ny] - 1, steps) + 1\\n                    \\n                    if ts_new > 0: # returns -1 of not possible\\n                        heappush(q, (ts_new, steps + 1, nx, ny))\\n            \\n        return -1\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233927,
                "title": "dijkstra-bfs-priorityqueue",
                "content": "# Code\\n```\\nconst moves = [[0, -1], [0, 1], [1, 0], [-1, 0]]\\n\\nfunction minimumTime(grid: number[][]): number {\\n    const N = grid.length;\\n    const M = grid[0].length;\\n\\n    const check = (x: number, y: number) => x >= 0 && y >= 0 && x < N && y < M;\\n\\n    let visited: boolean[][] = [...new Array(N)].map(_ => new Array(M).fill(false));\\n\\n    if(grid[0][1] > 1 && grid[1][0] > 1){\\n        return -1\\n    }\\n    \\n    const heap = new MinPriorityQueue()\\n    heap.enqueue([0, 0, 0], 0);\\n\\n    while (heap.size()) {\\n        let [i, j, time] = heap.dequeue().element;\\n \\n        visited[i][j] = true;\\n\\n        if (i == N -1 && j == M - 1) {\\n            return time\\n        }\\n\\n        for (const [diffX, diffY] of moves) {\\n            const newX = i + diffX, newY = j + diffY;\\n            if (!check(newX, newY)) {\\n                continue;\\n            }\\n\\n            if (visited[newX][newY]) {\\n                continue;\\n            }\\n\\n            let newTime = time + 1\\n            if (time + 1 < grid[newX][newY]) {\\n                let diff = grid[newX][newY] - time-1\\n                newTime = diff % 2 == 0 ? \\n                    grid[newX][newY] : grid[newX][newY] + 1\\n                \\n            }\\n\\n            visited[newX][newY] = true;\\n            heap.enqueue([newX, newY, newTime], newTime)\\n        }\\n    }\\n\\n    return -1;\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nconst moves = [[0, -1], [0, 1], [1, 0], [-1, 0]]\\n\\nfunction minimumTime(grid: number[][]): number {\\n    const N = grid.length;\\n    const M = grid[0].length;\\n\\n    const check = (x: number, y: number) => x >= 0 && y >= 0 && x < N && y < M;\\n\\n    let visited: boolean[][] = [...new Array(N)].map(_ => new Array(M).fill(false));\\n\\n    if(grid[0][1] > 1 && grid[1][0] > 1){\\n        return -1\\n    }\\n    \\n    const heap = new MinPriorityQueue()\\n    heap.enqueue([0, 0, 0], 0);\\n\\n    while (heap.size()) {\\n        let [i, j, time] = heap.dequeue().element;\\n \\n        visited[i][j] = true;\\n\\n        if (i == N -1 && j == M - 1) {\\n            return time\\n        }\\n\\n        for (const [diffX, diffY] of moves) {\\n            const newX = i + diffX, newY = j + diffY;\\n            if (!check(newX, newY)) {\\n                continue;\\n            }\\n\\n            if (visited[newX][newY]) {\\n                continue;\\n            }\\n\\n            let newTime = time + 1\\n            if (time + 1 < grid[newX][newY]) {\\n                let diff = grid[newX][newY] - time-1\\n                newTime = diff % 2 == 0 ? \\n                    grid[newX][newY] : grid[newX][newY] + 1\\n                \\n            }\\n\\n            visited[newX][newY] = true;\\n            heap.enqueue([newX, newY, newTime], newTime)\\n        }\\n    }\\n\\n    return -1;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3233825,
                "title": "o-m-n-bfs-schedule-the-visits-in-the-future",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf grid[0][1] > 1 && grid[1][0] > 1, you have nowhere to go and because grid is not a 1x1 matrix, so you return -1 for this case.\\n\\nOtherwise, you can always reach the bottom, because you can increase the time by back and forth, it\\'s easy to prove that if you can get to a cell at time = t, you can revisit it in the future at time = t + 2 * k (k = 1, 2, ....) that is the parity won\\'t change (odd stays odd, even stays even).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nWith the intuition we can use standard BFS to explore the matrix, just keep all the cells to be visited at a given time in a data structure (hash map from integer to hash set) and try to visit them after one layer of standard BFS iteration.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(m * n + V)$$ where V is the maximum value in grid\\nSince each cell appears in to_visit at most 4 times (fron its 4 neighbours)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(m * n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        if (grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n        int m = grid.size(), n = grid[0].size();\\n        unordered_map<int, unordered_set<int>> to_visit;\\n        int cur = 0;\\n        queue<pair<int, int>> q;\\n        bool visit[m][n];\\n        memset(visit, 0, sizeof(visit));\\n        q.push(make_pair(0, 0));\\n        visit[0][0] = true;\\n        vector<pair<int, int>> moves{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        while (!q.empty() || !to_visit.empty()) {\\n            ++cur;\\n            int sz = q.size();\\n            while (sz-- > 0) {\\n                auto [i, j] = q.front();\\n                q.pop();\\n                for (const auto& [di, dj] : moves) {\\n                    int r = i + di, c = j + dj;\\n                    if (r >= 0 && r < m && c >= 0 && c < n && !visit[r][c]) {\\n                        if (grid[r][c] <= cur) {\\n                            q.push(make_pair(r, c));\\n                            visit[r][c] = true;\\n                        } else {\\n                            to_visit[grid[r][c] + ((grid[r][c] - cur) % 2)].insert(r * n + c);\\n                        }\\n                    }\\n                }\\n            }\\n            auto it = to_visit.find(cur);\\n            if (it != to_visit.end()) {\\n                for (const auto& pos : it->second) {\\n                    int r = pos / n, c = pos % n;\\n                    if (!visit[r][c]) {\\n                        q.push(make_pair(r, c));\\n                        visit[r][c] = true;\\n                    }\\n                }\\n                to_visit.erase(it);  // not required but save some memory\\n            }\\n            if (visit[m - 1][n - 1]) break;\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        if (grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n        int m = grid.size(), n = grid[0].size();\\n        unordered_map<int, unordered_set<int>> to_visit;\\n        int cur = 0;\\n        queue<pair<int, int>> q;\\n        bool visit[m][n];\\n        memset(visit, 0, sizeof(visit));\\n        q.push(make_pair(0, 0));\\n        visit[0][0] = true;\\n        vector<pair<int, int>> moves{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        while (!q.empty() || !to_visit.empty()) {\\n            ++cur;\\n            int sz = q.size();\\n            while (sz-- > 0) {\\n                auto [i, j] = q.front();\\n                q.pop();\\n                for (const auto& [di, dj] : moves) {\\n                    int r = i + di, c = j + dj;\\n                    if (r >= 0 && r < m && c >= 0 && c < n && !visit[r][c]) {\\n                        if (grid[r][c] <= cur) {\\n                            q.push(make_pair(r, c));\\n                            visit[r][c] = true;\\n                        } else {\\n                            to_visit[grid[r][c] + ((grid[r][c] - cur) % 2)].insert(r * n + c);\\n                        }\\n                    }\\n                }\\n            }\\n            auto it = to_visit.find(cur);\\n            if (it != to_visit.end()) {\\n                for (const auto& pos : it->second) {\\n                    int r = pos / n, c = pos % n;\\n                    if (!visit[r][c]) {\\n                        q.push(make_pair(r, c));\\n                        visit[r][c] = true;\\n                    }\\n                }\\n                to_visit.erase(it);  // not required but save some memory\\n            }\\n            if (visit[m - 1][n - 1]) break;\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233750,
                "title": "c-observation-and-dijkstra-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRealise that we can \"waste\" time by stepping on previously stepped on tiles. This means that we can go between the origin and an adjacent tile as long as the adjacent tile has value 1 or 0.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst verify that the end is reachable, that is we are able to \"waste time\".\\n\\nThen we can do a Dijkstra to find the shortest path, where the weight of each edge is:\\n- 1 for the time taken for the step\\n- `(max(0,grid[i+di][j+dj]-du)/2)*2`\\n  - `grid[i+di][j+dj]-du` represents the time that we have to waste\\n  - We take the `max(0,grid[i+di][j+dj]-du)` since if it is negative, that means that the current time is already greater, and we can step on the next position\\n  - Finally, we do integer division by 2 and multiply by 2 to represent stepping back and forward to \"waste time\", which means that we can only reach this tile again in time increments of 2 units.\\n\\nEverything else in the Dijkstra is standard.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nLet `V ~ m*n`, and `E ~ 4m*n`\\nO((V+E)log(V)) = O(VlogV)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<pair<int,int>> d4 = {{-1,0},{1,0},{0,-1},{0,1}};\\n\\n    int minimumTime(vector<vector<int>>& grid) {\\n        if(grid[0][1]>1 && grid[1][0]>1) return -1;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> d(m, vector<int>(n,1e9));\\n        d[0][0] = 0;\\n        set<tuple<int,int,int>> pq;\\n        if(grid[0][1]<=1){\\n            d[0][1]=1;\\n            pq.insert({1,0,1});\\n        }\\n        if(grid[1][0]<=1){\\n            d[1][0]=1;\\n            pq.insert({1,1,0});\\n        }\\n        while(pq.size()){\\n            auto [du,i,j] = *pq.begin();\\n            pq.erase(pq.begin());\\n            for(auto&[di,dj]:d4){\\n                if(0<=i+di && i+di<m && 0<=j+dj && j+dj<n){\\n                    // time taken for 1 step + time \"wasted\" until enough time has passed for us to step on {i+di,j+dj}\\n                    int w = 1+(max(0,grid[i+di][j+dj]-du)/2)*2;\\n                    if(du+w<d[i+di][j+dj]){\\n                        d[i+di][j+dj]=du+w;\\n                        pq.insert({du+w,i+di,j+dj});\\n                    }\\n                }\\n            }\\n        }\\n        return d[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<pair<int,int>> d4 = {{-1,0},{1,0},{0,-1},{0,1}};\\n\\n    int minimumTime(vector<vector<int>>& grid) {\\n        if(grid[0][1]>1 && grid[1][0]>1) return -1;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> d(m, vector<int>(n,1e9));\\n        d[0][0] = 0;\\n        set<tuple<int,int,int>> pq;\\n        if(grid[0][1]<=1){\\n            d[0][1]=1;\\n            pq.insert({1,0,1});\\n        }\\n        if(grid[1][0]<=1){\\n            d[1][0]=1;\\n            pq.insert({1,1,0});\\n        }\\n        while(pq.size()){\\n            auto [du,i,j] = *pq.begin();\\n            pq.erase(pq.begin());\\n            for(auto&[di,dj]:d4){\\n                if(0<=i+di && i+di<m && 0<=j+dj && j+dj<n){\\n                    // time taken for 1 step + time \"wasted\" until enough time has passed for us to step on {i+di,j+dj}\\n                    int w = 1+(max(0,grid[i+di][j+dj]-du)/2)*2;\\n                    if(du+w<d[i+di][j+dj]){\\n                        d[i+di][j+dj]=du+w;\\n                        pq.insert({du+w,i+di,j+dj});\\n                    }\\n                }\\n            }\\n        }\\n        return d[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233510,
                "title": "easy-and-clean-solution-using-dijkstra-s-with-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int [][] dir = new int[][]{{-1,0},{0,1},{1,0},{0,-1}};\\n    public int minimumTime(int[][] grid) {\\n        //Since we are using priority queue the first time we reach \\n        //last cell will cost minium\\n        //so we can directly return from there\\n        if(grid[0][1] > 1 && grid[1][0] > 1)\\n        return -1;\\n\\n        PriorityQueue<int[]> q = new PriorityQueue<>((a,b) -> a[2] - b[2]);\\n        boolean [][] visited = new boolean[grid.length][grid[0].length];\\n        q.add(new int[]{0,0,0});\\n        visited[0][0] = true;\\n        while(q.size() > 0)\\n        {\\n            int [] triplet = q.poll();\\n            if(triplet[0] == grid.length - 1 && triplet[1] == grid[0].length - 1)\\n            {\\n                return triplet[2];\\n            }\\n            for(int i = 0; i < dir.length; i++)\\n            {\\n                int newRow = triplet[0] + dir[i][0];\\n                int newCol = triplet[1] + dir[i][1];\\n                if(IsValid(newRow, newCol, grid, visited))\\n                {\\n                    if(grid[newRow][newCol] <= triplet[2])\\n                    q.add(new int[]{newRow, newCol, triplet[2] + 1});\\n                    else\\n                    {\\n                        int costRequired = grid[newRow][newCol] - triplet[2] - 1;\\n                        // if(triplet[0] == 0 && triplet[1] == 0 && costRequired >= 1)\\n                        //     continue;\\n                        if(costRequired % 2 != 0)\\n                            costRequired++;\\n                        q.add(new int[]{newRow, newCol, triplet[2] + costRequired + 1});\\n                    }\\n                    visited[newRow][newCol] = true;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    public boolean IsValid(int r, int c, int [][] grid, boolean [][] visited)\\n    {\\n        return r >= 0 && r < grid.length && c >= 0 && c < grid[0].length && !visited[r][c]; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    int [][] dir = new int[][]{{-1,0},{0,1},{1,0},{0,-1}};\\n    public int minimumTime(int[][] grid) {\\n        //Since we are using priority queue the first time we reach \\n        //last cell will cost minium\\n        //so we can directly return from there\\n        if(grid[0][1] > 1 && grid[1][0] > 1)\\n        return -1;\\n\\n        PriorityQueue<int[]> q = new PriorityQueue<>((a,b) -> a[2] - b[2]);\\n        boolean [][] visited = new boolean[grid.length][grid[0].length];\\n        q.add(new int[]{0,0,0});\\n        visited[0][0] = true;\\n        while(q.size() > 0)\\n        {\\n            int [] triplet = q.poll();\\n            if(triplet[0] == grid.length - 1 && triplet[1] == grid[0].length - 1)\\n            {\\n                return triplet[2];\\n            }\\n            for(int i = 0; i < dir.length; i++)\\n            {\\n                int newRow = triplet[0] + dir[i][0];\\n                int newCol = triplet[1] + dir[i][1];\\n                if(IsValid(newRow, newCol, grid, visited))\\n                {\\n                    if(grid[newRow][newCol] <= triplet[2])\\n                    q.add(new int[]{newRow, newCol, triplet[2] + 1});\\n                    else\\n                    {\\n                        int costRequired = grid[newRow][newCol] - triplet[2] - 1;\\n                        // if(triplet[0] == 0 && triplet[1] == 0 && costRequired >= 1)\\n                        //     continue;\\n                        if(costRequired % 2 != 0)\\n                            costRequired++;\\n                        q.add(new int[]{newRow, newCol, triplet[2] + costRequired + 1});\\n                    }\\n                    visited[newRow][newCol] = true;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    public boolean IsValid(int r, int c, int [][] grid, boolean [][] visited)\\n    {\\n        return r >= 0 && r < grid.length && c >= 0 && c < grid[0].length && !visited[r][c]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233401,
                "title": "easy-solution-c-dijkstra-algorithm-faster-than-75",
                "content": "\\n# Approach\\nDijkstra Algorithm using Priority Queue\\n# Complexity\\n- Time complexity: **O(*$$m * n * log(m * n)$$*)**\\n\\n- Space complexity: O(*$$m * n$$*)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int n = (int)grid.size();\\n        int m = (int)grid[0].size();\\n\\n        if (grid[1][0] > 1 && grid[0][1] > 1) {\\n            return -1;  \\n        }\\n\\n        int dx[] = {0, 0, 1, -1};\\n        int dy[] = {1, -1, 0, 0};\\n\\n        priority_queue<pair<int, pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq; // time : x : y\\n\\n        int time[n][m];\\n        for(int i = 0; i < n; ++i){\\n            for(int j =0; j < m; ++j){\\n                time[i][j] = (int)1e9;\\n            }\\n        }        \\n\\n        pq.push({0,{0,0}});\\n        time[0][0] = 0;\\n        while(!pq.empty()){\\n            int curtime = pq.top().first;\\n            int curx = pq.top().second.first;\\n            int cury = pq.top().second.second;\\n            pq.pop();\\n            if(curtime > time[curx][cury]){\\n                continue;  \\n            }\\n            if(curx == n - 1 && cury == m - 1){\\n                return curtime;\\n            }\\n            for(int i = 0; i < 4 ; ++i){\\n                int newtime = curtime + 1;\\n                int nx = curx + dx[i];\\n                int ny = cury + dy[i];\\n                if(nx < 0 || nx >= n || ny < 0 || ny >=m){\\n                    continue;\\n                }\\n                if (grid[nx][ny] > newtime) {\\n                    int diff = grid[nx][ny] - newtime;\\n                    if (diff & 1) {\\n                        ++diff;\\n                    }\\n                    newtime = newtime + diff;\\n                }\\n                if(newtime < time[nx][ny]){\\n                    time[nx][ny] = newtime;\\n                    pq.push({newtime, {nx, ny}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int n = (int)grid.size();\\n        int m = (int)grid[0].size();\\n\\n        if (grid[1][0] > 1 && grid[0][1] > 1) {\\n            return -1;  \\n        }\\n\\n        int dx[] = {0, 0, 1, -1};\\n        int dy[] = {1, -1, 0, 0};\\n\\n        priority_queue<pair<int, pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq; // time : x : y\\n\\n        int time[n][m];\\n        for(int i = 0; i < n; ++i){\\n            for(int j =0; j < m; ++j){\\n                time[i][j] = (int)1e9;\\n            }\\n        }        \\n\\n        pq.push({0,{0,0}});\\n        time[0][0] = 0;\\n        while(!pq.empty()){\\n            int curtime = pq.top().first;\\n            int curx = pq.top().second.first;\\n            int cury = pq.top().second.second;\\n            pq.pop();\\n            if(curtime > time[curx][cury]){\\n                continue;  \\n            }\\n            if(curx == n - 1 && cury == m - 1){\\n                return curtime;\\n            }\\n            for(int i = 0; i < 4 ; ++i){\\n                int newtime = curtime + 1;\\n                int nx = curx + dx[i];\\n                int ny = cury + dy[i];\\n                if(nx < 0 || nx >= n || ny < 0 || ny >=m){\\n                    continue;\\n                }\\n                if (grid[nx][ny] > newtime) {\\n                    int diff = grid[nx][ny] - newtime;\\n                    if (diff & 1) {\\n                        ++diff;\\n                    }\\n                    newtime = newtime + diff;\\n                }\\n                if(newtime < time[nx][ny]){\\n                    time[nx][ny] = newtime;\\n                    pq.push({newtime, {nx, ny}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233182,
                "title": "clean-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dx[4] = {-1 , 1 , 0 , 0};\\n    int dy[4] = {0 , 0 , 1 , -1};\\n\\n    int minimumTime(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size() , m = grid[0].size();\\n\\n        vector<vector<int>>vis(n , vector<int>(m , INT_MAX));\\n\\n        // we can\\'t able to start our journey\\n        if(grid[0][1] > 1 && grid[1][0] > 1)\\n            return -1;\\n\\n        priority_queue<pair<int,pair<int,int>> , vector<pair<int,pair<int,int>>> , greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({0 , {0 , 0}});\\n        vis[0][0] = 0;\\n\\n        while(!pq.empty())\\n        {\\n            int curr_time = pq.top().first;\\n            int row = pq.top().second.first;\\n            int col = pq.top().second.second;\\n\\n            pq.pop();\\n\\n            if(row == n-1 && col == m-1)\\n                return curr_time;\\n\\n            for(int i = 0 ; i < 4 ; i++)\\n            {\\n                int x = row + dx[i];\\n                int y = col + dy[i];\\n\\n                if(x < 0 || x >= n || y < 0 || y >= m || curr_time+1 >= vis[x][y])\\n                    continue;\\n\\n                int time = 0;    \\n\\n                if(curr_time+1 > grid[x][y])\\n                       time = curr_time+1;\\n                else if((grid[x][y] - curr_time) % 2 == 0)\\n                    time = grid[x][y] + 1 ;\\n                else\\n                    time = grid[x][y];    \\n                        \\n                pq.push({time , {x, y}});\\n                vis[x][y] = time;        \\n            }\\n        }    \\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dx[4] = {-1 , 1 , 0 , 0};\\n    int dy[4] = {0 , 0 , 1 , -1};\\n\\n    int minimumTime(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size() , m = grid[0].size();\\n\\n        vector<vector<int>>vis(n , vector<int>(m , INT_MAX));\\n\\n        // we can\\'t able to start our journey\\n        if(grid[0][1] > 1 && grid[1][0] > 1)\\n            return -1;\\n\\n        priority_queue<pair<int,pair<int,int>> , vector<pair<int,pair<int,int>>> , greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({0 , {0 , 0}});\\n        vis[0][0] = 0;\\n\\n        while(!pq.empty())\\n        {\\n            int curr_time = pq.top().first;\\n            int row = pq.top().second.first;\\n            int col = pq.top().second.second;\\n\\n            pq.pop();\\n\\n            if(row == n-1 && col == m-1)\\n                return curr_time;\\n\\n            for(int i = 0 ; i < 4 ; i++)\\n            {\\n                int x = row + dx[i];\\n                int y = col + dy[i];\\n\\n                if(x < 0 || x >= n || y < 0 || y >= m || curr_time+1 >= vis[x][y])\\n                    continue;\\n\\n                int time = 0;    \\n\\n                if(curr_time+1 > grid[x][y])\\n                       time = curr_time+1;\\n                else if((grid[x][y] - curr_time) % 2 == 0)\\n                    time = grid[x][y] + 1 ;\\n                else\\n                    time = grid[x][y];    \\n                        \\n                pq.push({time , {x, y}});\\n                vis[x][y] = time;        \\n            }\\n        }    \\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233171,
                "title": "dart-good-question-bfs-step-by-step-explained",
                "content": "# Intuition\\n- The first return we can move a position from start we can always reach to last. So checked, first right and bottom is greater than 1 cause of grid[0][0] is always 0.\\n- Simple BFS but use PriorityQueue because time is not always increase by 1. As if we can\\'t jump, we need to hop previous to current. So PriorityQueue will help us to get the lowest time every time. Otherwise we might reach with no minimum time.\\n- Last step, if we can move, we will move with time + 1. Else we need to check how many times we need to hop back to back to jump the next position. So, if the NextTime - CurTime is even, as calculation we must jump back to back till NextTime + 1, else we can jump with NextTime.\\n\\n# Code\\n```\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int minimumTime(List<List<int>> grid) {\\n    if (grid[0][1] > 1 && grid[1][0] > 1) {\\n      return -1;\\n    }\\n    int n = grid.length;\\n    int m = grid[0].length;\\n    final q = PriorityQueue<Tuple>((a, b) => a.time.compareTo(b.time));\\n    q.add(Tuple(0, 0, 0));\\n    List<List<bool>> visited = List.generate(\\n      n,\\n      (index) => List.filled(m, false),\\n    );\\n\\n    List<List<int>> dir = [\\n      [1, 0],\\n      [-1, 0],\\n      [0, 1],\\n      [0, -1]\\n    ];\\n    while (q.isNotEmpty) {\\n      int k = q.length;\\n\\n      for (var i = 0; i < k; i++) {\\n        Tuple t = q.removeFirst();\\n        int i = t.i, j = t.j, time = t.time;\\n        if (i == n - 1 && j == m - 1) {\\n          return time;\\n        }\\n\\n        if (visited[i][j]) {\\n          continue;\\n        }\\n        visited[i][j] = true;\\n\\n        var plusTime = time + 1;\\n\\n        for (var pos in dir) {\\n          int newX = i + pos[0];\\n          int newY = j + pos[1];\\n\\n          if (newX >= 0 &&\\n              newX < n &&\\n              newY >= 0 &&\\n              newY < m) {\\n            if (plusTime >= grid[newX][newY]) {\\n              q.add(Tuple(newX, newY, plusTime));\\n            } else {\\n              int diff = grid[newX][newY] - time;\\n\\n              if (diff.isEven) {\\n                q.add(Tuple(newX, newY, grid[newX][newY] + 1));\\n              } else {\\n                q.add(Tuple(newX, newY, grid[newX][newY]));\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    return -1;\\n  }\\n}\\n\\nclass Tuple {\\n  final int i;\\n  final int j;\\n  final int time;\\n\\n  Tuple(this.i, this.j, this.time);\\n\\n  @override\\n  String toString() {\\n    return \\'($i, $j, $time)\\';\\n  }\\n}\\n\\nint defaultCompare(Object? value1, Object? value2) =>\\n    (value1 as Comparable<Object?>).compareTo(value2);\\n\\n/// A reusable identity function at any type.\\nT identity<T>(T value) => value;\\n\\n/// A reusable typed comparable comparator.\\nint compareComparable<T extends Comparable<T>>(T a, T b) => a.compareTo(b);\\n\\nabstract class PriorityQueue<E> {\\n  /// Creates an empty [PriorityQueue].\\n  ///\\n  /// The created [PriorityQueue] is a plain [HeapPriorityQueue].\\n  ///\\n  /// The [comparison] is a [Comparator] used to compare the priority of\\n  /// elements. An element that compares as less than another element has\\n  /// a higher priority.\\n  ///\\n  /// If [comparison] is omitted, it defaults to [Comparable.compare]. If this\\n  /// is the case, `E` must implement [Comparable], and this is checked at\\n  /// runtime for every comparison.\\n  factory PriorityQueue([int Function(E, E)? comparison]) =\\n      HeapPriorityQueue<E>;\\n\\n  /// Number of elements in the queue.\\n  int get length;\\n\\n  /// Whether the queue is empty.\\n  bool get isEmpty;\\n\\n  /// Whether the queue has any elements.\\n  bool get isNotEmpty;\\n\\n  /// Checks if [object] is in the queue.\\n  ///\\n  /// Returns true if the element is found.\\n  ///\\n  /// Uses the [Object.==] of elements in the queue to check\\n  /// for whether they are equal to [object].\\n  /// Equal objects objects must have the same priority\\n  /// according to the [comparison] function.\\n  /// That is, if `a == b` then `comparison(a, b) == 0`.\\n  /// If that is not the case, this check might fail to find\\n  /// an object.\\n  bool contains(E object);\\n\\n  /// Provides efficient access to all the elements currently in the queue.\\n  ///\\n  /// The operation should be performed without copying or moving\\n  /// the elements, if at all possible.\\n  ///\\n  /// The elements are iterated in no particular order.\\n  /// The order is stable as long as the queue is not modified.\\n  /// The queue must not be modified during an iteration.\\n  Iterable<E> get unorderedElements;\\n\\n  /// Adds element to the queue.\\n  ///\\n  /// The element will become the next to be removed by [removeFirst]\\n  /// when all elements with higher priority have been removed.\\n  void add(E element);\\n\\n  /// Adds all [elements] to the queue.\\n  void addAll(Iterable<E> elements);\\n\\n  /// Returns the next element that will be returned by [removeFirst].\\n  ///\\n  /// The element is not removed from the queue.\\n  ///\\n  /// The queue must not be empty when this method is called.\\n  E get first;\\n\\n  /// Removes and returns the element with the highest priority.\\n  ///\\n  /// Repeatedly calling this method, without adding element in between,\\n  /// is guaranteed to return elements in non-decreasing order as, specified by\\n  /// [comparison].\\n  ///\\n  /// The queue must not be empty when this method is called.\\n  E removeFirst();\\n\\n  /// Removes an element of the queue that compares equal to [element].\\n  ///\\n  /// Returns true if an element is found and removed,\\n  /// and false if no equal element is found.\\n  ///\\n  /// If the queue contains more than one object equal to [element],\\n  /// only one of them is removed.\\n  ///\\n  /// Uses the [Object.==] of elements in the queue to check\\n  /// for whether they are equal to [element].\\n  /// Equal objects objects must have the same priority\\n  /// according to the [comparison] function.\\n  /// That is, if `a == b` then `comparison(a, b) == 0`.\\n  /// If that is not the case, this check might fail to find\\n  /// an object.\\n  bool remove(E element);\\n\\n  /// Removes all the elements from this queue and returns them.\\n  ///\\n  /// The returned iterable has no specified order.\\n  Iterable<E> removeAll();\\n\\n  /// Removes all the elements from this queue.\\n  void clear();\\n\\n  /// Returns a list of the elements of this queue in priority order.\\n  ///\\n  /// The queue is not modified.\\n  ///\\n  /// The order is the order that the elements would be in if they were\\n  /// removed from this queue using [removeFirst].\\n  List<E> toList();\\n\\n  /// Returns a list of the elements of this queue in no specific order.\\n  ///\\n  /// The queue is not modified.\\n  ///\\n  /// The order of the elements is implementation specific.\\n  /// The order may differ between different calls on the same queue.\\n  List<E> toUnorderedList();\\n\\n  /// Return a comparator based set using the comparator of this queue.\\n  ///\\n  /// The queue is not modified.\\n  ///\\n  /// The returned [Set] is currently a [SplayTreeSet],\\n  /// but this may change as other ordered sets are implemented.\\n  ///\\n  /// The set contains all the elements of this queue.\\n  /// If an element occurs more than once in the queue,\\n  /// the set will contain it only once.\\n  Set<E> toSet();\\n}\\n\\n/// Heap based priority queue.\\n///\\n/// The elements are kept in a heap structure,\\n/// where the element with the highest priority is immediately accessible,\\n/// and modifying a single element takes\\n/// logarithmic time in the number of elements on average.\\n///\\n/// * The [add] and [removeFirst] operations take amortized logarithmic time,\\n///   O(log(n)), but may occasionally take linear time when growing the capacity\\n///   of the heap.\\n/// * The [addAll] operation works as doing repeated [add] operations.\\n/// * The [first] getter takes constant time, O(1).\\n/// * The [clear] and [removeAll] methods also take constant time, O(1).\\n/// * The [contains] and [remove] operations may need to search the entire\\n///   queue for the elements, taking O(n) time.\\n/// * The [toList] operation effectively sorts the elements, taking O(n*log(n))\\n///   time.\\n/// * The [toUnorderedList] operation copies, but does not sort, the elements,\\n///   and is linear, O(n).\\n/// * The [toSet] operation effectively adds each element to the new set, taking\\n///   an expected O(n*log(n)) time.\\nclass HeapPriorityQueue<E> implements PriorityQueue<E> {\\n  /// Initial capacity of a queue when created, or when added to after a\\n  /// [clear].\\n  ///\\n  /// Number can be any positive value. Picking a size that gives a whole\\n  /// number of \"tree levels\" in the heap is only done for aesthetic reasons.\\n  static const int _initialCapacity = 7;\\n\\n  /// The comparison being used to compare the priority of elements.\\n  final Comparator<E> comparison;\\n\\n  /// List implementation of a heap.\\n  List<E?> _queue = List<E?>.filled(_initialCapacity, null);\\n\\n  /// Number of elements in queue.\\n  ///\\n  /// The heap is implemented in the first [_length] entries of [_queue].\\n  int _length = 0;\\n\\n  /// Modification count.\\n  ///\\n  /// Used to detect concurrent modifications during iteration.\\n  int _modificationCount = 0;\\n\\n  /// Create a new priority queue.\\n  ///\\n  /// The [comparison] is a [Comparator] used to compare the priority of\\n  /// elements. An element that compares as less than another element has\\n  /// a higher priority.\\n  ///\\n  /// If [comparison] is omitted, it defaults to [Comparable.compare]. If this\\n  /// is the case, `E` must implement [Comparable], and this is checked at\\n  /// runtime for every comparison.\\n  HeapPriorityQueue([int Function(E, E)? comparison])\\n      : comparison = comparison ?? defaultCompare;\\n\\n  E _elementAt(int index) => _queue[index] ?? (null as E);\\n\\n  @override\\n  void add(E element) {\\n    _modificationCount++;\\n    _add(element);\\n  }\\n\\n  @override\\n  void addAll(Iterable<E> elements) {\\n    var modified = 0;\\n    for (var element in elements) {\\n      modified = 1;\\n      _add(element);\\n    }\\n    _modificationCount += modified;\\n  }\\n\\n  @override\\n  void clear() {\\n    _modificationCount++;\\n    _queue = const [];\\n    _length = 0;\\n  }\\n\\n  @override\\n  bool contains(E object) => _locate(object) >= 0;\\n\\n  /// Provides efficient access to all the elements currently in the queue.\\n  ///\\n  /// The operation is performed in the order they occur\\n  /// in the underlying heap structure.\\n  ///\\n  /// The order is stable as long as the queue is not modified.\\n  /// The queue must not be modified during an iteration.\\n  @override\\n  Iterable<E> get unorderedElements => _UnorderedElementsIterable<E>(this);\\n\\n  @override\\n  E get first {\\n    if (_length == 0) throw StateError(\\'No element\\');\\n    return _elementAt(0);\\n  }\\n\\n  @override\\n  bool get isEmpty => _length == 0;\\n\\n  @override\\n  bool get isNotEmpty => _length != 0;\\n\\n  @override\\n  int get length => _length;\\n\\n  @override\\n  bool remove(E element) {\\n    var index = _locate(element);\\n    if (index < 0) return false;\\n    _modificationCount++;\\n    var last = _removeLast();\\n    if (index < _length) {\\n      var comp = comparison(last, element);\\n      if (comp <= 0) {\\n        _bubbleUp(last, index);\\n      } else {\\n        _bubbleDown(last, index);\\n      }\\n    }\\n    return true;\\n  }\\n\\n  /// Removes all the elements from this queue and returns them.\\n  ///\\n  /// The returned iterable has no specified order.\\n  /// The operation does not copy the elements,\\n  /// but instead keeps them in the existing heap structure,\\n  /// and iterates over that directly.\\n  @override\\n  Iterable<E> removeAll() {\\n    _modificationCount++;\\n    var result = _queue;\\n    var length = _length;\\n    _queue = const [];\\n    _length = 0;\\n    return result.take(length).cast();\\n  }\\n\\n  @override\\n  E removeFirst() {\\n    if (_length == 0) throw StateError(\\'No element\\');\\n    _modificationCount++;\\n    var result = _elementAt(0);\\n    var last = _removeLast();\\n    if (_length > 0) {\\n      _bubbleDown(last, 0);\\n    }\\n    return result;\\n  }\\n\\n  @override\\n  List<E> toList() => _toUnorderedList()..sort(comparison);\\n\\n  @override\\n  Set<E> toSet() {\\n    var set = SplayTreeSet<E>(comparison);\\n    for (var i = 0; i < _length; i++) {\\n      set.add(_elementAt(i));\\n    }\\n    return set;\\n  }\\n\\n  @override\\n  List<E> toUnorderedList() => _toUnorderedList();\\n\\n  List<E> _toUnorderedList() =>\\n      [for (var i = 0; i < _length; i++) _elementAt(i)];\\n\\n  /// Returns some representation of the queue.\\n  ///\\n  /// The format isn\\'t significant, and may change in the future.\\n  @override\\n  String toString() {\\n    return _queue.take(_length).toString();\\n  }\\n\\n  /// Add element to the queue.\\n  ///\\n  /// Grows the capacity if the backing list is full.\\n  void _add(E element) {\\n    if (_length == _queue.length) _grow();\\n    _bubbleUp(element, _length++);\\n  }\\n\\n  /// Find the index of an object in the heap.\\n  ///\\n  /// Returns -1 if the object is not found.\\n  ///\\n  /// A matching object, `o`, must satisfy that\\n  /// `comparison(o, object) == 0 && o == object`.\\n  int _locate(E object) {\\n    if (_length == 0) return -1;\\n    // Count positions from one instead of zero. This gives the numbers\\n    // some nice properties. For example, all right children are odd,\\n    // their left sibling is even, and the parent is found by shifting\\n    // right by one.\\n    // Valid range for position is [1.._length], inclusive.\\n    var position = 1;\\n    // Pre-order depth first search, omit child nodes if the current\\n    // node has lower priority than [object], because all nodes lower\\n    // in the heap will also have lower priority.\\n    do {\\n      var index = position - 1;\\n      var element = _elementAt(index);\\n      var comp = comparison(element, object);\\n      if (comp <= 0) {\\n        if (comp == 0 && element == object) return index;\\n        // Element may be in subtree.\\n        // Continue with the left child, if it is there.\\n        var leftChildPosition = position * 2;\\n        if (leftChildPosition <= _length) {\\n          position = leftChildPosition;\\n          continue;\\n        }\\n      }\\n      // Find the next right sibling or right ancestor sibling.\\n      do {\\n        while (position.isOdd) {\\n          // While position is a right child, go to the parent.\\n          position >>= 1;\\n        }\\n        // Then go to the right sibling of the left-child.\\n        position += 1;\\n      } while (position > _length); // Happens if last element is a left child.\\n    } while (position != 1); // At root again. Happens for right-most element.\\n    return -1;\\n  }\\n\\n  E _removeLast() {\\n    var newLength = _length - 1;\\n    var last = _elementAt(newLength);\\n    _queue[newLength] = null;\\n    _length = newLength;\\n    return last;\\n  }\\n\\n  /// Place [element] in heap at [index] or above.\\n  ///\\n  /// Put element into the empty cell at `index`.\\n  /// While the `element` has higher priority than the\\n  /// parent, swap it with the parent.\\n  void _bubbleUp(E element, int index) {\\n    while (index > 0) {\\n      var parentIndex = (index - 1) ~/ 2;\\n      var parent = _elementAt(parentIndex);\\n      if (comparison(element, parent) > 0) break;\\n      _queue[index] = parent;\\n      index = parentIndex;\\n    }\\n    _queue[index] = element;\\n  }\\n\\n  /// Place [element] in heap at [index] or above.\\n  ///\\n  /// Put element into the empty cell at `index`.\\n  /// While the `element` has lower priority than either child,\\n  /// swap it with the highest priority child.\\n  void _bubbleDown(E element, int index) {\\n    var rightChildIndex = index * 2 + 2;\\n    while (rightChildIndex < _length) {\\n      var leftChildIndex = rightChildIndex - 1;\\n      var leftChild = _elementAt(leftChildIndex);\\n      var rightChild = _elementAt(rightChildIndex);\\n      var comp = comparison(leftChild, rightChild);\\n      int minChildIndex;\\n      E minChild;\\n      if (comp < 0) {\\n        minChild = leftChild;\\n        minChildIndex = leftChildIndex;\\n      } else {\\n        minChild = rightChild;\\n        minChildIndex = rightChildIndex;\\n      }\\n      comp = comparison(element, minChild);\\n      if (comp <= 0) {\\n        _queue[index] = element;\\n        return;\\n      }\\n      _queue[index] = minChild;\\n      index = minChildIndex;\\n      rightChildIndex = index * 2 + 2;\\n    }\\n    var leftChildIndex = rightChildIndex - 1;\\n    if (leftChildIndex < _length) {\\n      var child = _elementAt(leftChildIndex);\\n      var comp = comparison(element, child);\\n      if (comp > 0) {\\n        _queue[index] = child;\\n        index = leftChildIndex;\\n      }\\n    }\\n    _queue[index] = element;\\n  }\\n\\n  /// Grows the capacity of the list holding the heap.\\n  ///\\n  /// Called when the list is full.\\n  void _grow() {\\n    var newCapacity = _queue.length * 2 + 1;\\n    if (newCapacity < _initialCapacity) newCapacity = _initialCapacity;\\n    var newQueue = List<E?>.filled(newCapacity, null);\\n    newQueue.setRange(0, _length, _queue);\\n    _queue = newQueue;\\n  }\\n}\\n\\n/// Implementation of [HeapPriorityQueue.unorderedElements].\\nclass _UnorderedElementsIterable<E> extends Iterable<E> {\\n  final HeapPriorityQueue<E> _queue;\\n  _UnorderedElementsIterable(this._queue);\\n  @override\\n  Iterator<E> get iterator => _UnorderedElementsIterator<E>(_queue);\\n}\\n\\nclass _UnorderedElementsIterator<E> implements Iterator<E> {\\n  final HeapPriorityQueue<E> _queue;\\n  final int _initialModificationCount;\\n  E? _current;\\n  int _index = -1;\\n\\n  _UnorderedElementsIterator(this._queue)\\n      : _initialModificationCount = _queue._modificationCount;\\n\\n  @override\\n  bool moveNext() {\\n    if (_initialModificationCount != _queue._modificationCount) {\\n      throw ConcurrentModificationError(_queue);\\n    }\\n    var nextIndex = _index + 1;\\n    if (0 <= nextIndex && nextIndex < _queue.length) {\\n      _current = _queue._queue[nextIndex];\\n      _index = nextIndex;\\n      return true;\\n    }\\n    _current = null;\\n    _index = -2;\\n    return false;\\n  }\\n\\n  @override\\n  E get current =>\\n      _index < 0 ? throw StateError(\\'No element\\') : (_current ?? null as E);\\n}\\n\\n//91199\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int minimumTime(List<List<int>> grid) {\\n    if (grid[0][1] > 1 && grid[1][0] > 1) {\\n      return -1;\\n    }\\n    int n = grid.length;\\n    int m = grid[0].length;\\n    final q = PriorityQueue<Tuple>((a, b) => a.time.compareTo(b.time));\\n    q.add(Tuple(0, 0, 0));\\n    List<List<bool>> visited = List.generate(\\n      n,\\n      (index) => List.filled(m, false),\\n    );\\n\\n    List<List<int>> dir = [\\n      [1, 0],\\n      [-1, 0],\\n      [0, 1],\\n      [0, -1]\\n    ];\\n    while (q.isNotEmpty) {\\n      int k = q.length;\\n\\n      for (var i = 0; i < k; i++) {\\n        Tuple t = q.removeFirst();\\n        int i = t.i, j = t.j, time = t.time;\\n        if (i == n - 1 && j == m - 1) {\\n          return time;\\n        }\\n\\n        if (visited[i][j]) {\\n          continue;\\n        }\\n        visited[i][j] = true;\\n\\n        var plusTime = time + 1;\\n\\n        for (var pos in dir) {\\n          int newX = i + pos[0];\\n          int newY = j + pos[1];\\n\\n          if (newX >= 0 &&\\n              newX < n &&\\n              newY >= 0 &&\\n              newY < m) {\\n            if (plusTime >= grid[newX][newY]) {\\n              q.add(Tuple(newX, newY, plusTime));\\n            } else {\\n              int diff = grid[newX][newY] - time;\\n\\n              if (diff.isEven) {\\n                q.add(Tuple(newX, newY, grid[newX][newY] + 1));\\n              } else {\\n                q.add(Tuple(newX, newY, grid[newX][newY]));\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    return -1;\\n  }\\n}\\n\\nclass Tuple {\\n  final int i;\\n  final int j;\\n  final int time;\\n\\n  Tuple(this.i, this.j, this.time);\\n\\n  @override\\n  String toString() {\\n    return \\'($i, $j, $time)\\';\\n  }\\n}\\n\\nint defaultCompare(Object? value1, Object? value2) =>\\n    (value1 as Comparable<Object?>).compareTo(value2);\\n\\n/// A reusable identity function at any type.\\nT identity<T>(T value) => value;\\n\\n/// A reusable typed comparable comparator.\\nint compareComparable<T extends Comparable<T>>(T a, T b) => a.compareTo(b);\\n\\nabstract class PriorityQueue<E> {\\n  /// Creates an empty [PriorityQueue].\\n  ///\\n  /// The created [PriorityQueue] is a plain [HeapPriorityQueue].\\n  ///\\n  /// The [comparison] is a [Comparator] used to compare the priority of\\n  /// elements. An element that compares as less than another element has\\n  /// a higher priority.\\n  ///\\n  /// If [comparison] is omitted, it defaults to [Comparable.compare]. If this\\n  /// is the case, `E` must implement [Comparable], and this is checked at\\n  /// runtime for every comparison.\\n  factory PriorityQueue([int Function(E, E)? comparison]) =\\n      HeapPriorityQueue<E>;\\n\\n  /// Number of elements in the queue.\\n  int get length;\\n\\n  /// Whether the queue is empty.\\n  bool get isEmpty;\\n\\n  /// Whether the queue has any elements.\\n  bool get isNotEmpty;\\n\\n  /// Checks if [object] is in the queue.\\n  ///\\n  /// Returns true if the element is found.\\n  ///\\n  /// Uses the [Object.==] of elements in the queue to check\\n  /// for whether they are equal to [object].\\n  /// Equal objects objects must have the same priority\\n  /// according to the [comparison] function.\\n  /// That is, if `a == b` then `comparison(a, b) == 0`.\\n  /// If that is not the case, this check might fail to find\\n  /// an object.\\n  bool contains(E object);\\n\\n  /// Provides efficient access to all the elements currently in the queue.\\n  ///\\n  /// The operation should be performed without copying or moving\\n  /// the elements, if at all possible.\\n  ///\\n  /// The elements are iterated in no particular order.\\n  /// The order is stable as long as the queue is not modified.\\n  /// The queue must not be modified during an iteration.\\n  Iterable<E> get unorderedElements;\\n\\n  /// Adds element to the queue.\\n  ///\\n  /// The element will become the next to be removed by [removeFirst]\\n  /// when all elements with higher priority have been removed.\\n  void add(E element);\\n\\n  /// Adds all [elements] to the queue.\\n  void addAll(Iterable<E> elements);\\n\\n  /// Returns the next element that will be returned by [removeFirst].\\n  ///\\n  /// The element is not removed from the queue.\\n  ///\\n  /// The queue must not be empty when this method is called.\\n  E get first;\\n\\n  /// Removes and returns the element with the highest priority.\\n  ///\\n  /// Repeatedly calling this method, without adding element in between,\\n  /// is guaranteed to return elements in non-decreasing order as, specified by\\n  /// [comparison].\\n  ///\\n  /// The queue must not be empty when this method is called.\\n  E removeFirst();\\n\\n  /// Removes an element of the queue that compares equal to [element].\\n  ///\\n  /// Returns true if an element is found and removed,\\n  /// and false if no equal element is found.\\n  ///\\n  /// If the queue contains more than one object equal to [element],\\n  /// only one of them is removed.\\n  ///\\n  /// Uses the [Object.==] of elements in the queue to check\\n  /// for whether they are equal to [element].\\n  /// Equal objects objects must have the same priority\\n  /// according to the [comparison] function.\\n  /// That is, if `a == b` then `comparison(a, b) == 0`.\\n  /// If that is not the case, this check might fail to find\\n  /// an object.\\n  bool remove(E element);\\n\\n  /// Removes all the elements from this queue and returns them.\\n  ///\\n  /// The returned iterable has no specified order.\\n  Iterable<E> removeAll();\\n\\n  /// Removes all the elements from this queue.\\n  void clear();\\n\\n  /// Returns a list of the elements of this queue in priority order.\\n  ///\\n  /// The queue is not modified.\\n  ///\\n  /// The order is the order that the elements would be in if they were\\n  /// removed from this queue using [removeFirst].\\n  List<E> toList();\\n\\n  /// Returns a list of the elements of this queue in no specific order.\\n  ///\\n  /// The queue is not modified.\\n  ///\\n  /// The order of the elements is implementation specific.\\n  /// The order may differ between different calls on the same queue.\\n  List<E> toUnorderedList();\\n\\n  /// Return a comparator based set using the comparator of this queue.\\n  ///\\n  /// The queue is not modified.\\n  ///\\n  /// The returned [Set] is currently a [SplayTreeSet],\\n  /// but this may change as other ordered sets are implemented.\\n  ///\\n  /// The set contains all the elements of this queue.\\n  /// If an element occurs more than once in the queue,\\n  /// the set will contain it only once.\\n  Set<E> toSet();\\n}\\n\\n/// Heap based priority queue.\\n///\\n/// The elements are kept in a heap structure,\\n/// where the element with the highest priority is immediately accessible,\\n/// and modifying a single element takes\\n/// logarithmic time in the number of elements on average.\\n///\\n/// * The [add] and [removeFirst] operations take amortized logarithmic time,\\n///   O(log(n)), but may occasionally take linear time when growing the capacity\\n///   of the heap.\\n/// * The [addAll] operation works as doing repeated [add] operations.\\n/// * The [first] getter takes constant time, O(1).\\n/// * The [clear] and [removeAll] methods also take constant time, O(1).\\n/// * The [contains] and [remove] operations may need to search the entire\\n///   queue for the elements, taking O(n) time.\\n/// * The [toList] operation effectively sorts the elements, taking O(n*log(n))\\n///   time.\\n/// * The [toUnorderedList] operation copies, but does not sort, the elements,\\n///   and is linear, O(n).\\n/// * The [toSet] operation effectively adds each element to the new set, taking\\n///   an expected O(n*log(n)) time.\\nclass HeapPriorityQueue<E> implements PriorityQueue<E> {\\n  /// Initial capacity of a queue when created, or when added to after a\\n  /// [clear].\\n  ///\\n  /// Number can be any positive value. Picking a size that gives a whole\\n  /// number of \"tree levels\" in the heap is only done for aesthetic reasons.\\n  static const int _initialCapacity = 7;\\n\\n  /// The comparison being used to compare the priority of elements.\\n  final Comparator<E> comparison;\\n\\n  /// List implementation of a heap.\\n  List<E?> _queue = List<E?>.filled(_initialCapacity, null);\\n\\n  /// Number of elements in queue.\\n  ///\\n  /// The heap is implemented in the first [_length] entries of [_queue].\\n  int _length = 0;\\n\\n  /// Modification count.\\n  ///\\n  /// Used to detect concurrent modifications during iteration.\\n  int _modificationCount = 0;\\n\\n  /// Create a new priority queue.\\n  ///\\n  /// The [comparison] is a [Comparator] used to compare the priority of\\n  /// elements. An element that compares as less than another element has\\n  /// a higher priority.\\n  ///\\n  /// If [comparison] is omitted, it defaults to [Comparable.compare]. If this\\n  /// is the case, `E` must implement [Comparable], and this is checked at\\n  /// runtime for every comparison.\\n  HeapPriorityQueue([int Function(E, E)? comparison])\\n      : comparison = comparison ?? defaultCompare;\\n\\n  E _elementAt(int index) => _queue[index] ?? (null as E);\\n\\n  @override\\n  void add(E element) {\\n    _modificationCount++;\\n    _add(element);\\n  }\\n\\n  @override\\n  void addAll(Iterable<E> elements) {\\n    var modified = 0;\\n    for (var element in elements) {\\n      modified = 1;\\n      _add(element);\\n    }\\n    _modificationCount += modified;\\n  }\\n\\n  @override\\n  void clear() {\\n    _modificationCount++;\\n    _queue = const [];\\n    _length = 0;\\n  }\\n\\n  @override\\n  bool contains(E object) => _locate(object) >= 0;\\n\\n  /// Provides efficient access to all the elements currently in the queue.\\n  ///\\n  /// The operation is performed in the order they occur\\n  /// in the underlying heap structure.\\n  ///\\n  /// The order is stable as long as the queue is not modified.\\n  /// The queue must not be modified during an iteration.\\n  @override\\n  Iterable<E> get unorderedElements => _UnorderedElementsIterable<E>(this);\\n\\n  @override\\n  E get first {\\n    if (_length == 0) throw StateError(\\'No element\\');\\n    return _elementAt(0);\\n  }\\n\\n  @override\\n  bool get isEmpty => _length == 0;\\n\\n  @override\\n  bool get isNotEmpty => _length != 0;\\n\\n  @override\\n  int get length => _length;\\n\\n  @override\\n  bool remove(E element) {\\n    var index = _locate(element);\\n    if (index < 0) return false;\\n    _modificationCount++;\\n    var last = _removeLast();\\n    if (index < _length) {\\n      var comp = comparison(last, element);\\n      if (comp <= 0) {\\n        _bubbleUp(last, index);\\n      } else {\\n        _bubbleDown(last, index);\\n      }\\n    }\\n    return true;\\n  }\\n\\n  /// Removes all the elements from this queue and returns them.\\n  ///\\n  /// The returned iterable has no specified order.\\n  /// The operation does not copy the elements,\\n  /// but instead keeps them in the existing heap structure,\\n  /// and iterates over that directly.\\n  @override\\n  Iterable<E> removeAll() {\\n    _modificationCount++;\\n    var result = _queue;\\n    var length = _length;\\n    _queue = const [];\\n    _length = 0;\\n    return result.take(length).cast();\\n  }\\n\\n  @override\\n  E removeFirst() {\\n    if (_length == 0) throw StateError(\\'No element\\');\\n    _modificationCount++;\\n    var result = _elementAt(0);\\n    var last = _removeLast();\\n    if (_length > 0) {\\n      _bubbleDown(last, 0);\\n    }\\n    return result;\\n  }\\n\\n  @override\\n  List<E> toList() => _toUnorderedList()..sort(comparison);\\n\\n  @override\\n  Set<E> toSet() {\\n    var set = SplayTreeSet<E>(comparison);\\n    for (var i = 0; i < _length; i++) {\\n      set.add(_elementAt(i));\\n    }\\n    return set;\\n  }\\n\\n  @override\\n  List<E> toUnorderedList() => _toUnorderedList();\\n\\n  List<E> _toUnorderedList() =>\\n      [for (var i = 0; i < _length; i++) _elementAt(i)];\\n\\n  /// Returns some representation of the queue.\\n  ///\\n  /// The format isn\\'t significant, and may change in the future.\\n  @override\\n  String toString() {\\n    return _queue.take(_length).toString();\\n  }\\n\\n  /// Add element to the queue.\\n  ///\\n  /// Grows the capacity if the backing list is full.\\n  void _add(E element) {\\n    if (_length == _queue.length) _grow();\\n    _bubbleUp(element, _length++);\\n  }\\n\\n  /// Find the index of an object in the heap.\\n  ///\\n  /// Returns -1 if the object is not found.\\n  ///\\n  /// A matching object, `o`, must satisfy that\\n  /// `comparison(o, object) == 0 && o == object`.\\n  int _locate(E object) {\\n    if (_length == 0) return -1;\\n    // Count positions from one instead of zero. This gives the numbers\\n    // some nice properties. For example, all right children are odd,\\n    // their left sibling is even, and the parent is found by shifting\\n    // right by one.\\n    // Valid range for position is [1.._length], inclusive.\\n    var position = 1;\\n    // Pre-order depth first search, omit child nodes if the current\\n    // node has lower priority than [object], because all nodes lower\\n    // in the heap will also have lower priority.\\n    do {\\n      var index = position - 1;\\n      var element = _elementAt(index);\\n      var comp = comparison(element, object);\\n      if (comp <= 0) {\\n        if (comp == 0 && element == object) return index;\\n        // Element may be in subtree.\\n        // Continue with the left child, if it is there.\\n        var leftChildPosition = position * 2;\\n        if (leftChildPosition <= _length) {\\n          position = leftChildPosition;\\n          continue;\\n        }\\n      }\\n      // Find the next right sibling or right ancestor sibling.\\n      do {\\n        while (position.isOdd) {\\n          // While position is a right child, go to the parent.\\n          position >>= 1;\\n        }\\n        // Then go to the right sibling of the left-child.\\n        position += 1;\\n      } while (position > _length); // Happens if last element is a left child.\\n    } while (position != 1); // At root again. Happens for right-most element.\\n    return -1;\\n  }\\n\\n  E _removeLast() {\\n    var newLength = _length - 1;\\n    var last = _elementAt(newLength);\\n    _queue[newLength] = null;\\n    _length = newLength;\\n    return last;\\n  }\\n\\n  /// Place [element] in heap at [index] or above.\\n  ///\\n  /// Put element into the empty cell at `index`.\\n  /// While the `element` has higher priority than the\\n  /// parent, swap it with the parent.\\n  void _bubbleUp(E element, int index) {\\n    while (index > 0) {\\n      var parentIndex = (index - 1) ~/ 2;\\n      var parent = _elementAt(parentIndex);\\n      if (comparison(element, parent) > 0) break;\\n      _queue[index] = parent;\\n      index = parentIndex;\\n    }\\n    _queue[index] = element;\\n  }\\n\\n  /// Place [element] in heap at [index] or above.\\n  ///\\n  /// Put element into the empty cell at `index`.\\n  /// While the `element` has lower priority than either child,\\n  /// swap it with the highest priority child.\\n  void _bubbleDown(E element, int index) {\\n    var rightChildIndex = index * 2 + 2;\\n    while (rightChildIndex < _length) {\\n      var leftChildIndex = rightChildIndex - 1;\\n      var leftChild = _elementAt(leftChildIndex);\\n      var rightChild = _elementAt(rightChildIndex);\\n      var comp = comparison(leftChild, rightChild);\\n      int minChildIndex;\\n      E minChild;\\n      if (comp < 0) {\\n        minChild = leftChild;\\n        minChildIndex = leftChildIndex;\\n      } else {\\n        minChild = rightChild;\\n        minChildIndex = rightChildIndex;\\n      }\\n      comp = comparison(element, minChild);\\n      if (comp <= 0) {\\n        _queue[index] = element;\\n        return;\\n      }\\n      _queue[index] = minChild;\\n      index = minChildIndex;\\n      rightChildIndex = index * 2 + 2;\\n    }\\n    var leftChildIndex = rightChildIndex - 1;\\n    if (leftChildIndex < _length) {\\n      var child = _elementAt(leftChildIndex);\\n      var comp = comparison(element, child);\\n      if (comp > 0) {\\n        _queue[index] = child;\\n        index = leftChildIndex;\\n      }\\n    }\\n    _queue[index] = element;\\n  }\\n\\n  /// Grows the capacity of the list holding the heap.\\n  ///\\n  /// Called when the list is full.\\n  void _grow() {\\n    var newCapacity = _queue.length * 2 + 1;\\n    if (newCapacity < _initialCapacity) newCapacity = _initialCapacity;\\n    var newQueue = List<E?>.filled(newCapacity, null);\\n    newQueue.setRange(0, _length, _queue);\\n    _queue = newQueue;\\n  }\\n}\\n\\n/// Implementation of [HeapPriorityQueue.unorderedElements].\\nclass _UnorderedElementsIterable<E> extends Iterable<E> {\\n  final HeapPriorityQueue<E> _queue;\\n  _UnorderedElementsIterable(this._queue);\\n  @override\\n  Iterator<E> get iterator => _UnorderedElementsIterator<E>(_queue);\\n}\\n\\nclass _UnorderedElementsIterator<E> implements Iterator<E> {\\n  final HeapPriorityQueue<E> _queue;\\n  final int _initialModificationCount;\\n  E? _current;\\n  int _index = -1;\\n\\n  _UnorderedElementsIterator(this._queue)\\n      : _initialModificationCount = _queue._modificationCount;\\n\\n  @override\\n  bool moveNext() {\\n    if (_initialModificationCount != _queue._modificationCount) {\\n      throw ConcurrentModificationError(_queue);\\n    }\\n    var nextIndex = _index + 1;\\n    if (0 <= nextIndex && nextIndex < _queue.length) {\\n      _current = _queue._queue[nextIndex];\\n      _index = nextIndex;\\n      return true;\\n    }\\n    _current = null;\\n    _index = -2;\\n    return false;\\n  }\\n\\n  @override\\n  E get current =>\\n      _index < 0 ? throw StateError(\\'No element\\') : (_current ?? null as E);\\n}\\n\\n//91199\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233074,
                "title": "full-explanation-and-commented-code-c-o-mn-log-mn-tc-dijkstra-algorithm",
                "content": "# Intuition\\nWe are required to find the shortest cost path to reach right-bottom of matrix in nlogn time (n being the number of nodes in the graph).\\nDijkstra Algorithm or Single Source Shortest Path Algorithm is the way to achieve this.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSimple Dijkstra Algorithm on grid, where left-right-up-down are the neighbouring nodes. The Challenge here is what to do when the cost to reach neighbouring node is less than the required cost.\\n\\nLet\\'s consider a situation:\\n- (x, y) : current node\\n- (xprev, yprev) : the neighbouring node of (x, y), which we come from\\n- (X, Y) : another neighbouring node of (x, y), where we want to go, and\\n- currCostToReach(x, y) + 1 < requiredCostToReach(X, Y)\\n\\nIn this situation, we can\\'t go to (X, Y) from (x, y) with currCost + 1.\\nBut there is one way to reach (X, Y), if we go to-and-fro from (x, y) to (xprev, yprev) and again back to (x, y) increasing currCost by 2 every time, until currCost + 1 >= requiredCostToReach(X, Y).\\n\\nHere, some of you might be thinking that why do we need to go to (X, Y) forcefully (Don\\'t judge for my english).\\nBecause what if currCost is 3 and requiredCost is 7, then we do to-and-fro motion twice, increment currCost by 4 and go to (X, Y) with cost 8 (3(currCost) + 4(to-and-fro twice) + 1(cost to move to neighbouring node) >= 7(requiredCost)).\\nLet say we can there is another neighbouring node of (X, Y) whose currCost is 9, then we reach to (X, Y) from that neighbouring node with cost 10 (9 + 1), which is not optimal.\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(mn(log(mn)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int n, m;\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>> > pq;\\n        \\n        vector<vector<int>> dp(n, vector<int>(m, 2e9));\\n        // pushing the neighbouring nodes of (0,0) in the priority queue\\n        if(grid[0][1] <= 1) pq.push({1, 0, 1}), dp[0][1] = 1;\\n        if(grid[1][0] <= 1) pq.push({1, 1, 0}), dp[1][0] = 1;\\n        dp[0][0] = 0;\\n        \\n        vector<int> dirn = {1, 0, -1, 0, 1};\\n        while(pq.size()) {\\n            vector<int> f = pq.top();   pq.pop();\\n            int currDist = f[0], x = f[1], y = f[2];\\n            \\n            if(x == n-1 && y == m-1)   return currDist;\\n            \\n            if(currDist > dp[x][y]) continue;\\n            currDist++; // add cost 1 to reach neighbour nodes ie, (x,y) -> (X,Y)\\n            \\n            // going right, left, up and down\\n            for(int i=0; i<4; i++) {\\n                int X = x + dirn[i];\\n                int Y = y + dirn[i+1];\\n                if(X < 0 || Y < 0 || X >= n || Y >= m) continue;\\n                \\n                // check additional Cost currCost to reach (X,Y) is lesser than required(grid[X][Y])\\n                int reqAddition = max(0, grid[X][Y] - currDist);\\n                // if required additional cost is odd, then increment 1 because going back to (x,y) and coming back to (X,Y) will add 2 every times in the cost\\n                if(reqAddition & 1) reqAddition++;\\n                \\n                // If it\\'s the least possible cost until now, to reach (X,Y)\\n                if(dp[X][Y] > currDist + reqAddition) {\\n                    dp[X][Y] = currDist + reqAddition;\\n                    pq.push({dp[X][Y], X, Y});\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\n    int n, m;\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>> > pq;\\n        \\n        vector<vector<int>> dp(n, vector<int>(m, 2e9));\\n        // pushing the neighbouring nodes of (0,0) in the priority queue\\n        if(grid[0][1] <= 1) pq.push({1, 0, 1}), dp[0][1] = 1;\\n        if(grid[1][0] <= 1) pq.push({1, 1, 0}), dp[1][0] = 1;\\n        dp[0][0] = 0;\\n        \\n        vector<int> dirn = {1, 0, -1, 0, 1};\\n        while(pq.size()) {\\n            vector<int> f = pq.top();   pq.pop();\\n            int currDist = f[0], x = f[1], y = f[2];\\n            \\n            if(x == n-1 && y == m-1)   return currDist;\\n            \\n            if(currDist > dp[x][y]) continue;\\n            currDist++; // add cost 1 to reach neighbour nodes ie, (x,y) -> (X,Y)\\n            \\n            // going right, left, up and down\\n            for(int i=0; i<4; i++) {\\n                int X = x + dirn[i];\\n                int Y = y + dirn[i+1];\\n                if(X < 0 || Y < 0 || X >= n || Y >= m) continue;\\n                \\n                // check additional Cost currCost to reach (X,Y) is lesser than required(grid[X][Y])\\n                int reqAddition = max(0, grid[X][Y] - currDist);\\n                // if required additional cost is odd, then increment 1 because going back to (x,y) and coming back to (X,Y) will add 2 every times in the cost\\n                if(reqAddition & 1) reqAddition++;\\n                \\n                // If it\\'s the least possible cost until now, to reach (X,Y)\\n                if(dp[X][Y] > currDist + reqAddition) {\\n                    dp[X][Y] = currDist + reqAddition;\\n                    pq.push({dp[X][Y], X, Y});\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232993,
                "title": "c-solution-simple-and-easy-solution-dijikstra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n,m;\\n    bool check(int i,int j,vector<vector<int>>&vis){\\n        if(i<0 or j<0 or i>=n or j>=m or vis[i][j]==1)\\n            return false;\\n        vis[i][j]=1;\\n        return true;\\n    }\\n\\n        \\n    int minimumTime(vector<vector<int>>& grid) {\\n        n=grid.size(),m=grid[0].size();\\n        \\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n\\n        if(grid[0][1]>1 and grid[1][0]>1)\\n            return -1;\\n        \\n        pq.push({0,{0,0}});\\n        vis[0][0]=1;\\n        while(!pq.empty()){\\n            int time=pq.top().first;\\n            int i=pq.top().second.first;\\n            int j=pq.top().second.second;\\n            pq.pop();\\n            if(i==n-1 and j==m-1)\\n                return time;\\n            int dr[]={-1,0,1,0};\\n            int dc[]={0,-1,0,1};\\n            time+=1;\\n            for(int a=0;a<4;a++){\\n                int nr=i+dr[a];\\n                int nc=j+dc[a];\\n                if(check(nr,nc,vis)==false)\\n                    continue;\\n                int wait_time=(grid[nr][nc]-time);\\n                if(wait_time<0)\\n                    wait_time=0;\\n                if(wait_time%2!=0)\\n                    wait_time+=1;\\n                pq.push({time+wait_time,{nr,nc}});\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    bool check(int i,int j,vector<vector<int>>&vis){\\n        if(i<0 or j<0 or i>=n or j>=m or vis[i][j]==1)\\n            return false;\\n        vis[i][j]=1;\\n        return true;\\n    }\\n\\n        \\n    int minimumTime(vector<vector<int>>& grid) {\\n        n=grid.size(),m=grid[0].size();\\n        \\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n\\n        if(grid[0][1]>1 and grid[1][0]>1)\\n            return -1;\\n        \\n        pq.push({0,{0,0}});\\n        vis[0][0]=1;\\n        while(!pq.empty()){\\n            int time=pq.top().first;\\n            int i=pq.top().second.first;\\n            int j=pq.top().second.second;\\n            pq.pop();\\n            if(i==n-1 and j==m-1)\\n                return time;\\n            int dr[]={-1,0,1,0};\\n            int dc[]={0,-1,0,1};\\n            time+=1;\\n            for(int a=0;a<4;a++){\\n                int nr=i+dr[a];\\n                int nc=j+dc[a];\\n                if(check(nr,nc,vis)==false)\\n                    continue;\\n                int wait_time=(grid[nr][nc]-time);\\n                if(wait_time<0)\\n                    wait_time=0;\\n                if(wait_time%2!=0)\\n                    wait_time+=1;\\n                pq.push({time+wait_time,{nr,nc}});\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232780,
                "title": "graph-traversal-using-a-priority-queue-golang",
                "content": "# Intuition\\nGraph traversal using a priority queue.\\n\\nIf the time difference with the neighboring cell is even, then we can go back and forth (for example, to the previous cell), thus \"wait\"\\n\\n# Code\\n```\\ntype Cell struct {\\n\\ttime int\\n\\trow  int\\n\\tcol  int\\n}\\n\\ntype PriorityQueue []*Cell\\n\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\n\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n\\treturn pq[i].time < pq[j].time\\n}\\n\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n\\tpq[i], pq[j] = pq[j], pq[i]\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\t*pq = append(*pq, x.(*Cell))\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\titem := old[n-1]\\n\\told[n-1] = nil\\n\\t*pq = old[0 : n-1]\\n\\treturn item\\n}\\n\\nfunc minimumTime(grid [][]int) int {\\n\\tif grid[0][1] > 1 && grid[1][0] > 1 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\tvar row, col, extra int\\n\\n\\tm, n := len(grid), len(grid[0])\\n\\n\\tvisited := make([]int, 1001*1001+1, 1001*1001+1)\\n\\n\\tds := [][]int{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}\\n\\n\\tpq := make(PriorityQueue, 0)\\n\\theap.Push(&pq, &Cell{grid[0][0], 0, 0})\\n\\n\\tfor len(pq) > 0 {\\n\\t\\tcell := heap.Pop(&pq).(*Cell)\\n\\n\\t\\tif cell.row == m-1 && cell.col == n-1 {\\n\\t\\t\\treturn cell.time\\n\\t\\t}\\n\\n\\t\\tif visited[cell.row*1001+cell.col] == 1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tvisited[cell.row*1001+cell.col] = 1\\n\\n\\t\\tfor _, d := range ds {\\n\\t\\t\\trow, col = cell.row+d[0], cell.col+d[1]\\n\\t\\t\\tif 0 <= row && row < m && 0 <= col && col < n && visited[row*1001+col] == 0 {\\n\\t\\t\\t\\textra = 0\\n\\t\\t\\t\\tif (grid[row][col]-cell.time)%2 == 0 {\\n\\t\\t\\t\\t\\textra = 1\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\theap.Push(&pq, &Cell{max(cell.time+1, grid[row][col]+extra), row, col})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Cell struct {\\n\\ttime int\\n\\trow  int\\n\\tcol  int\\n}\\n\\ntype PriorityQueue []*Cell\\n\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\n\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n\\treturn pq[i].time < pq[j].time\\n}\\n\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n\\tpq[i], pq[j] = pq[j], pq[i]\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\t*pq = append(*pq, x.(*Cell))\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\titem := old[n-1]\\n\\told[n-1] = nil\\n\\t*pq = old[0 : n-1]\\n\\treturn item\\n}\\n\\nfunc minimumTime(grid [][]int) int {\\n\\tif grid[0][1] > 1 && grid[1][0] > 1 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\tvar row, col, extra int\\n\\n\\tm, n := len(grid), len(grid[0])\\n\\n\\tvisited := make([]int, 1001*1001+1, 1001*1001+1)\\n\\n\\tds := [][]int{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}\\n\\n\\tpq := make(PriorityQueue, 0)\\n\\theap.Push(&pq, &Cell{grid[0][0], 0, 0})\\n\\n\\tfor len(pq) > 0 {\\n\\t\\tcell := heap.Pop(&pq).(*Cell)\\n\\n\\t\\tif cell.row == m-1 && cell.col == n-1 {\\n\\t\\t\\treturn cell.time\\n\\t\\t}\\n\\n\\t\\tif visited[cell.row*1001+cell.col] == 1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tvisited[cell.row*1001+cell.col] = 1\\n\\n\\t\\tfor _, d := range ds {\\n\\t\\t\\trow, col = cell.row+d[0], cell.col+d[1]\\n\\t\\t\\tif 0 <= row && row < m && 0 <= col && col < n && visited[row*1001+col] == 0 {\\n\\t\\t\\t\\textra = 0\\n\\t\\t\\t\\tif (grid[row][col]-cell.time)%2 == 0 {\\n\\t\\t\\t\\t\\textra = 1\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\theap.Push(&pq, &Cell{max(cell.time+1, grid[row][col]+extra), row, col})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3232704,
                "title": "c-java",
                "content": "# C++\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\\n            return -1;\\n        }\\n        vector<vector<int>> directions{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        priority_queue<vector<int>, vector<vector<int>>, greater<>> pq;\\n        pq.push({0, 0, 0}); // (t, r, c)\\n        while (!pq.empty()) {\\n            auto cur = pq.top();\\n            int t = cur[0], r = cur[1], c = cur[2];\\n            pq.pop();\\n            if (r == m - 1 && c == n - 1) {\\n                return t;\\n            }\\n            if (visited[r][c]) {\\n                continue;\\n            }\\n            visited[r][c] = true;\\n            for (const auto& dir : directions) {\\n                int nr = r + dir[0], nc = c + dir[1];\\n                if (nr < 0 || nr >= m || nc < 0 || nc >= n || visited[nr][nc]) {\\n                    continue;\\n                }\\n                bool wait = (grid[nr][nc] - t) % 2 == 0;\\n                int nt = max(grid[nr][nc] + wait, t + 1);\\n                pq.push({nt, nr, nc});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n# Java\\n```\\npublic int minimumTime(int[][] grid) {\\n    if (grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n    \\n    int m = grid.length, n = grid[0].length;\\n    int[][] dirs = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    boolean[] visited = new boolean[m * n];\\n    TreeSet<int[]> ts = new TreeSet<>((a, b) -> {\\n        if (a[0] != b[0]) return a[0] - b[0];\\n        if (a[1] != b[1]) return a[1] - b[1];\\n        return a[2] - b[2];\\n    });\\n    ts.add(new int[]{grid[0][0], 0, 0});\\n    \\n    while (!ts.isEmpty()) {\\n        int[] curr = ts.pollFirst();\\n        int time = curr[0], row = curr[1], col = curr[2];\\n        int idx = row * n + col;\\n        \\n        if (idx == m * n - 1) return time;\\n        if (visited[idx]) continue;\\n        visited[idx] = true;\\n        \\n        int[][] adjDirs = {{1, 0}, {0, 1}}; // check adjacent neighbors first\\n        if (row == m - 1) adjDirs = new int[][]{{0, 1}, {-1, 0}};\\n        else if (col == n - 1) adjDirs = new int[][]{{1, 0}, {0, -1}};\\n        \\n        for (int[] dir : adjDirs) {\\n            int r = row + dir[0], c = col + dir[1];\\n            if (r < 0 || r >= m || c < 0 || c >= n) continue;\\n            int idx2 = r * n + c;\\n            if (visited[idx2]) continue;\\n            int wait = ((grid[r][c] - time) % 2 == 0) ? 1 : 0;\\n            ts.add(new int[]{Math.max(grid[r][c] + wait, time + 1), r, c});\\n        }\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\\n            return -1;\\n        }\\n        vector<vector<int>> directions{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        priority_queue<vector<int>, vector<vector<int>>, greater<>> pq;\\n        pq.push({0, 0, 0}); // (t, r, c)\\n        while (!pq.empty()) {\\n            auto cur = pq.top();\\n            int t = cur[0], r = cur[1], c = cur[2];\\n            pq.pop();\\n            if (r == m - 1 && c == n - 1) {\\n                return t;\\n            }\\n            if (visited[r][c]) {\\n                continue;\\n            }\\n            visited[r][c] = true;\\n            for (const auto& dir : directions) {\\n                int nr = r + dir[0], nc = c + dir[1];\\n                if (nr < 0 || nr >= m || nc < 0 || nc >= n || visited[nr][nc]) {\\n                    continue;\\n                }\\n                bool wait = (grid[nr][nc] - t) % 2 == 0;\\n                int nt = max(grid[nr][nc] + wait, t + 1);\\n                pq.push({nt, nr, nc});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\npublic int minimumTime(int[][] grid) {\\n    if (grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n    \\n    int m = grid.length, n = grid[0].length;\\n    int[][] dirs = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    boolean[] visited = new boolean[m * n];\\n    TreeSet<int[]> ts = new TreeSet<>((a, b) -> {\\n        if (a[0] != b[0]) return a[0] - b[0];\\n        if (a[1] != b[1]) return a[1] - b[1];\\n        return a[2] - b[2];\\n    });\\n    ts.add(new int[]{grid[0][0], 0, 0});\\n    \\n    while (!ts.isEmpty()) {\\n        int[] curr = ts.pollFirst();\\n        int time = curr[0], row = curr[1], col = curr[2];\\n        int idx = row * n + col;\\n        \\n        if (idx == m * n - 1) return time;\\n        if (visited[idx]) continue;\\n        visited[idx] = true;\\n        \\n        int[][] adjDirs = {{1, 0}, {0, 1}}; // check adjacent neighbors first\\n        if (row == m - 1) adjDirs = new int[][]{{0, 1}, {-1, 0}};\\n        else if (col == n - 1) adjDirs = new int[][]{{1, 0}, {0, -1}};\\n        \\n        for (int[] dir : adjDirs) {\\n            int r = row + dir[0], c = col + dir[1];\\n            if (r < 0 || r >= m || c < 0 || c >= n) continue;\\n            int idx2 = r * n + c;\\n            if (visited[idx2]) continue;\\n            int wait = ((grid[r][c] - time) % 2 == 0) ? 1 : 0;\\n            ts.add(new int[]{Math.max(grid[r][c] + wait, time + 1), r, c});\\n        }\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232609,
                "title": "video-explanation-clean-dijkstra-s-algorithm-solution",
                "content": "# Approach\\nThe approach is to use Dijkstra\\'s algorithm with a priority queue to find the minimum time required to travel from the starting point to the ending point. The priority queue is used to prioritize the cells with the lowest time required to travel through them.\\n\\nInitially, we check if the starting point and the ending point are reachable by checking the time required to travel through the adjacent cells. If both of these points are unreachable, we return -1.\\n\\nWe then create a visited array to keep track of the visited cells and a priority queue to keep track of the cells with the lowest time required to travel through them. We add the starting point to the priority queue with a time of 0.\\n\\nWe then loop through the priority queue until it is empty. For each cell in the priority queue, we check if it is the ending point. If it is, we return the time required to travel through that cell.\\n\\nWe then check if the current cell has already been visited. If it has, we skip it. Otherwise, we mark it as visited.\\n\\nWe then check the adjacent cells to the current cell. If they are out of bounds or have already been visited, we skip them. Otherwise, we calculate the time required to travel through the adjacent cell based on the current time and the time required to travel through the cell. We add the adjacent cell to the priority queue with the calculated time.\\n\\nIf we have looped through the entire priority queue and haven\\'t found the ending point, we return -1, indicating that the ending point is unreachable.\\n\\n# Complexity\\n- Time complexity: O(m * n * log(m * n))\\n\\n- Space complexity: O(log(m * n))\\n\\n# Video \\n   [https://www.youtube.com/watch?v=w9oMct1YeAg](https://www.youtube.com/watch?v=w9oMct1YeAg)\\n# Code\\n```\\n/**\\n * Finds the minimum time required to travel from the top-left corner to the bottom-right corner of a grid.\\n *\\n * @param {number[][]} grid - The grid to traverse, represented as a 2D array of integers.\\n * @returns {number} - The minimum time required to travel from the top-left corner to the bottom-right corner, or -1 if it\\'s not possible to reach the end point.\\n */\\nconst minimumTime = function(grid) {\\n    const numRows = grid.length;\\n    const numCols = grid[0].length;\\n\\n    // Check if the start and end points are reachable.\\n    if (grid[0][1] > 1 && grid[1][0] > 1) {\\n        return -1;\\n    }\\n\\n    const visited = new Array(numRows)\\n        .fill()\\n        .map(() => new Array(numCols).fill(false));\\n\\n    const priorityQueue = new MinPriorityQueue({ priority: ([time]) => time });\\n\\n    if (grid[0][0] === 0) {\\n        priorityQueue.enqueue([0, 0, 0]);\\n    }\\n\\n    const directions = [[1, 0], [0, -1], [0, 1], [-1, 0]];\\n\\n    while (!priorityQueue.isEmpty()) {\\n        const [time, currentRow, currentCol] = priorityQueue.dequeue().element;\\n\\n        if (currentRow === numRows - 1 && currentCol === numCols - 1) {\\n            return time;\\n        }\\n\\n        if (visited[currentRow][currentCol]) {\\n            continue;\\n        }\\n\\n        visited[currentRow][currentCol] = true;\\n\\n        for (const [rowOffset, colOffset] of directions) {\\n            const newRow = currentRow + rowOffset;\\n            const newCol = currentCol + colOffset;\\n\\n            if (\\n                newRow < 0 ||\\n                newCol < 0 ||\\n                newRow >= numRows ||\\n                newCol >= numCols ||\\n                visited[newRow][newCol]\\n            ) {\\n                continue;\\n            }\\n\\n            const isEven = (grid[newRow][newCol] - time) % 2 === 0;\\n            const timeReq = Math.max(grid[newRow][newCol] + isEven, time + 1);\\n            priorityQueue.enqueue([timeReq, newRow, newCol]);\\n        }\\n    }\\n\\n    return -1;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * Finds the minimum time required to travel from the top-left corner to the bottom-right corner of a grid.\\n *\\n * @param {number[][]} grid - The grid to traverse, represented as a 2D array of integers.\\n * @returns {number} - The minimum time required to travel from the top-left corner to the bottom-right corner, or -1 if it\\'s not possible to reach the end point.\\n */\\nconst minimumTime = function(grid) {\\n    const numRows = grid.length;\\n    const numCols = grid[0].length;\\n\\n    // Check if the start and end points are reachable.\\n    if (grid[0][1] > 1 && grid[1][0] > 1) {\\n        return -1;\\n    }\\n\\n    const visited = new Array(numRows)\\n        .fill()\\n        .map(() => new Array(numCols).fill(false));\\n\\n    const priorityQueue = new MinPriorityQueue({ priority: ([time]) => time });\\n\\n    if (grid[0][0] === 0) {\\n        priorityQueue.enqueue([0, 0, 0]);\\n    }\\n\\n    const directions = [[1, 0], [0, -1], [0, 1], [-1, 0]];\\n\\n    while (!priorityQueue.isEmpty()) {\\n        const [time, currentRow, currentCol] = priorityQueue.dequeue().element;\\n\\n        if (currentRow === numRows - 1 && currentCol === numCols - 1) {\\n            return time;\\n        }\\n\\n        if (visited[currentRow][currentCol]) {\\n            continue;\\n        }\\n\\n        visited[currentRow][currentCol] = true;\\n\\n        for (const [rowOffset, colOffset] of directions) {\\n            const newRow = currentRow + rowOffset;\\n            const newCol = currentCol + colOffset;\\n\\n            if (\\n                newRow < 0 ||\\n                newCol < 0 ||\\n                newRow >= numRows ||\\n                newCol >= numCols ||\\n                visited[newRow][newCol]\\n            ) {\\n                continue;\\n            }\\n\\n            const isEven = (grid[newRow][newCol] - time) % 2 === 0;\\n            const timeReq = Math.max(grid[newRow][newCol] + isEven, time + 1);\\n            priorityQueue.enqueue([timeReq, newRow, newCol]);\\n        }\\n    }\\n\\n    return -1;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3232326,
                "title": "c-bfs-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want to find minimum time to reach bottom right cell. We\\'ll have to traverse the matrix as the time in each cell allows. We can use a priority queue to keep track of time.\\nSome things to keep in mind:\\n\\nIf we can not move to the neighboring cells from starting position we can not move anywhere in the matrix hence answer is -1.\\nBut if we can move to the neighboring cells from starting position, we can move anywhere in the matrix. We can wait by playing \"ping pong\" between previous cell and current cell till a neighboring cell opens up.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //if grid[i][j]>t, then wait before going to that grid\\n    int minimumTime(vector<vector<int>>& grid) {\\n        if(grid[0][1]>1 && grid[1][0]>1)\\n        return -1;\\n        int m=grid.size(),n=grid[0].size();\\n        int row[4]={-1,0,1,0};\\n        int col[4]={0,1,0,-1};\\n        priority_queue<vector<int>,vector<vector<int>>,greater<>>pq;\\n        vector<vector<bool>>vis(m,vector<bool>(n,false));\\n        pq.push({0,0,0}); //time,row,col\\n        while(!pq.empty())\\n        {\\n            auto it=pq.top();pq.pop();\\n            int t=it[0],r=it[1],c=it[2];\\n            if(r==m-1 && c==n-1)\\n            return t;\\n            if(vis[r][c])\\n            continue;\\n            vis[r][c]=true;\\n            for(int i=0;i<4;i++)\\n            {\\n                int newrow=r+row[i];\\n                int newcol=c+col[i];\\n                if(newrow<0 || newcol<0 || newrow>=m || newcol>=n || vis[newrow][newcol])\\n                continue;\\n                if(t>=grid[newrow][newcol])\\n                pq.push({t+1,newrow,newcol});\\n                else if((grid[newrow][newcol]-t)%2==1) //adding wait time\\n                pq.push({grid[newrow][newcol],newrow,newcol});\\n                else if((grid[newrow][newcol]-t)%2==0)\\n                pq.push({grid[newrow][newcol]+1,newrow,newcol}); //adding wait time\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //if grid[i][j]>t, then wait before going to that grid\\n    int minimumTime(vector<vector<int>>& grid) {\\n        if(grid[0][1]>1 && grid[1][0]>1)\\n        return -1;\\n        int m=grid.size(),n=grid[0].size();\\n        int row[4]={-1,0,1,0};\\n        int col[4]={0,1,0,-1};\\n        priority_queue<vector<int>,vector<vector<int>>,greater<>>pq;\\n        vector<vector<bool>>vis(m,vector<bool>(n,false));\\n        pq.push({0,0,0}); //time,row,col\\n        while(!pq.empty())\\n        {\\n            auto it=pq.top();pq.pop();\\n            int t=it[0],r=it[1],c=it[2];\\n            if(r==m-1 && c==n-1)\\n            return t;\\n            if(vis[r][c])\\n            continue;\\n            vis[r][c]=true;\\n            for(int i=0;i<4;i++)\\n            {\\n                int newrow=r+row[i];\\n                int newcol=c+col[i];\\n                if(newrow<0 || newcol<0 || newrow>=m || newcol>=n || vis[newrow][newcol])\\n                continue;\\n                if(t>=grid[newrow][newcol])\\n                pq.push({t+1,newrow,newcol});\\n                else if((grid[newrow][newcol]-t)%2==1) //adding wait time\\n                pq.push({grid[newrow][newcol],newrow,newcol});\\n                else if((grid[newrow][newcol]-t)%2==0)\\n                pq.push({grid[newrow][newcol]+1,newrow,newcol}); //adding wait time\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232300,
                "title": "dijkstra-easy-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int dx[4]={0,1,0,-1};\\n        int dy[4]={1,0,-1,0};\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;\\n        pq.push({0,{0,0}});\\n        vector<vector<int>> dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0]=0;\\n        if (min(grid[0][1], grid[1][0]) > 1)// edge case : if grid[0,1] or grid[1,0] is greater than 1 , then it will not possible to move because we have to move in a cell only if reaching time is greater or equal to value of the cell\\n            return -1;\\n        while(pq.empty()==false)\\n        {\\n            auto it=pq.top(); // getting the top of the priority queue\\n            pq.pop(); // removing the top of the prioirity queue\\n            int dstnce=it.first; // getting the distance\\n            int x1=it.second.first; // getting the x coordinate\\n            int y1=it.second.second; // getting the y coordinate\\n            for(int i=0;i<4;i++)\\n            {\\n                int x=x1+dx[i];\\n                int y=y1+dy[i];\\n                int dis1=dstnce+1;\\n                if(x>=0 && x<m && y>=0 && y<n)\\n                {\\n                    if(dis1<grid[x][y])\\n                    {\\n                        dis1=grid[x][y]+(grid[x][y]-dis1)%2;\\n                    }\\n                    if(dist[x][y]>dis1)\\n                    {\\n                        dist[x][y]=dis1;\\n                        pq.push({dis1,{x,y}});\\n                    }\\n                    \\n                }\\n            }\\n            \\n        }\\n        return dist[m-1][n-1];\\n    }\\n};\\n```\\n**please Upvote if u like my solution**\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int dx[4]={0,1,0,-1};\\n        int dy[4]={1,0,-1,0};\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;\\n        pq.push({0,{0,0}});\\n        vector<vector<int>> dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0]=0;\\n        if (min(grid[0][1], grid[1][0]) > 1)// edge case : if grid[0,1] or grid[1,0] is greater than 1 , then it will not possible to move because we have to move in a cell only if reaching time is greater or equal to value of the cell\\n            return -1;\\n        while(pq.empty()==false)\\n        {\\n            auto it=pq.top(); // getting the top of the priority queue\\n            pq.pop(); // removing the top of the prioirity queue\\n            int dstnce=it.first; // getting the distance\\n            int x1=it.second.first; // getting the x coordinate\\n            int y1=it.second.second; // getting the y coordinate\\n            for(int i=0;i<4;i++)\\n            {\\n                int x=x1+dx[i];\\n                int y=y1+dy[i];\\n                int dis1=dstnce+1;\\n                if(x>=0 && x<m && y>=0 && y<n)\\n                {\\n                    if(dis1<grid[x][y])\\n                    {\\n                        dis1=grid[x][y]+(grid[x][y]-dis1)%2;\\n                    }\\n                    if(dist[x][y]>dis1)\\n                    {\\n                        dist[x][y]=dis1;\\n                        pq.push({dis1,{x,y}});\\n                    }\\n                    \\n                }\\n            }\\n            \\n        }\\n        return dist[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232249,
                "title": "c-dijkstra",
                "content": "```\\nclass Solution {\\npublic:\\n  int minimumTime(vector<vector<int>>& grid) {\\n    int rows = grid.size(), cols = grid[0].size();\\n    \\n    // We must be able to go beyond point [0, 0] in order to visit the rest of the\\n    // matrix.\\n    if (grid[0][0] != 0) return -1;\\n    if (rows > 1 && cols > 1) {\\n      if (grid[1][0] > 1 && grid[0][1] > 1) return -1;\\n    } else if (rows > 1) {\\n      if (grid[1][0] > 1) return -1;\\n    } else if (cols > 1) {\\n      if (grid[0][1] > 1) return -1;\\n    }\\n    \\n    vector<vector<bool>> visited(rows, vector<bool>(cols, false));\\n    priority_queue<tuple<int, int, int>> pq;\\n    pq.push({-grid[0][0], 0, 0});\\n    \\n    // Use a Dijkstra like algorithm.\\n    while (!pq.empty()) {\\n      auto [t, r, c] = pq.top(); pq.pop();\\n      if (visited[r][c]) continue;\\n      t *= -1;\\n      visited[r][c] = true;\\n      if (r == (rows - 1) && (c == (cols - 1))) return t;\\n      \\n      vector<pair<int, int>> notImmediate;\\n      \\n      if (r > 0 && !visited[r - 1][c]) {\\n        if ((t + 1) >= grid[r - 1][c]) {\\n          pq.push({-(t + 1), r - 1, c});\\n        } else {\\n          notImmediate.push_back({r - 1, c});\\n        }\\n      }\\n      \\n      if (r < (rows - 1) && !visited[r + 1][c]) {\\n        if ((t + 1) >= grid[r + 1][c]) {\\n          pq.push({-(t + 1), r + 1, c});\\n        } else {\\n          notImmediate.push_back({r + 1, c});\\n        }\\n      }\\n      \\n      if (c > 0 && !visited[r][c - 1]) {\\n        if ((t + 1) >= grid[r][c - 1]) {\\n          pq.push({-(t + 1), r, c - 1});\\n        } else {\\n          notImmediate.push_back({r, c - 1});\\n        }\\n      }\\n      \\n      if (c < (cols - 1) && !visited[r][c + 1]) {\\n        if ((t + 1) >= grid[r][c + 1]) {\\n          pq.push({-(t + 1), r, c + 1});\\n        } else {\\n          notImmediate.push_back({r, c + 1});\\n        }\\n      }\\n      \\n      // For the ones that cannot be immediately visited, we can visit an immediately\\n      // visitable neighbor and go back and forth for some time.\\n      // We already check for [1, 0] and [0, 1] to be immediately visitable from\\n      // [0, 0] at the start and for every other point, we know it has at least one\\n      // immediately visitable neighbor which is the point we just came from.\\n      for (auto& pr : notImmediate) {\\n        int diff = grid[pr.first][pr.second] - (t + 1);\\n        if (diff % 2 == 0) {\\n          pq.push({-grid[pr.first][pr.second], pr.first, pr.second});\\n        } else {\\n          pq.push({-(grid[pr.first][pr.second] + 1), pr.first, pr.second});\\n        }\\n      }\\n    }\\n    return -1;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int minimumTime(vector<vector<int>>& grid) {\\n    int rows = grid.size(), cols = grid[0].size();\\n    \\n    // We must be able to go beyond point [0, 0] in order to visit the rest of the\\n    // matrix.\\n    if (grid[0][0] != 0) return -1;\\n    if (rows > 1 && cols > 1) {\\n      if (grid[1][0] > 1 && grid[0][1] > 1) return -1;\\n    } else if (rows > 1) {\\n      if (grid[1][0] > 1) return -1;\\n    } else if (cols > 1) {\\n      if (grid[0][1] > 1) return -1;\\n    }\\n    \\n    vector<vector<bool>> visited(rows, vector<bool>(cols, false));\\n    priority_queue<tuple<int, int, int>> pq;\\n    pq.push({-grid[0][0], 0, 0});\\n    \\n    // Use a Dijkstra like algorithm.\\n    while (!pq.empty()) {\\n      auto [t, r, c] = pq.top(); pq.pop();\\n      if (visited[r][c]) continue;\\n      t *= -1;\\n      visited[r][c] = true;\\n      if (r == (rows - 1) && (c == (cols - 1))) return t;\\n      \\n      vector<pair<int, int>> notImmediate;\\n      \\n      if (r > 0 && !visited[r - 1][c]) {\\n        if ((t + 1) >= grid[r - 1][c]) {\\n          pq.push({-(t + 1), r - 1, c});\\n        } else {\\n          notImmediate.push_back({r - 1, c});\\n        }\\n      }\\n      \\n      if (r < (rows - 1) && !visited[r + 1][c]) {\\n        if ((t + 1) >= grid[r + 1][c]) {\\n          pq.push({-(t + 1), r + 1, c});\\n        } else {\\n          notImmediate.push_back({r + 1, c});\\n        }\\n      }\\n      \\n      if (c > 0 && !visited[r][c - 1]) {\\n        if ((t + 1) >= grid[r][c - 1]) {\\n          pq.push({-(t + 1), r, c - 1});\\n        } else {\\n          notImmediate.push_back({r, c - 1});\\n        }\\n      }\\n      \\n      if (c < (cols - 1) && !visited[r][c + 1]) {\\n        if ((t + 1) >= grid[r][c + 1]) {\\n          pq.push({-(t + 1), r, c + 1});\\n        } else {\\n          notImmediate.push_back({r, c + 1});\\n        }\\n      }\\n      \\n      // For the ones that cannot be immediately visited, we can visit an immediately\\n      // visitable neighbor and go back and forth for some time.\\n      // We already check for [1, 0] and [0, 1] to be immediately visitable from\\n      // [0, 0] at the start and for every other point, we know it has at least one\\n      // immediately visitable neighbor which is the point we just came from.\\n      for (auto& pr : notImmediate) {\\n        int diff = grid[pr.first][pr.second] - (t + 1);\\n        if (diff % 2 == 0) {\\n          pq.push({-grid[pr.first][pr.second], pr.first, pr.second});\\n        } else {\\n          pq.push({-(grid[pr.first][pr.second] + 1), pr.first, pr.second});\\n        }\\n      }\\n    }\\n    return -1;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232135,
                "title": "c-dijkstra",
                "content": "\\n1. we return -1 only if we cannot move from position (0,0) to its adjacent vertex because if we\\n   are able to go from point a->b we can go back and forth between these points to unlock higher\\n   value adjacent cells.\\n2. Minimum time or shortest path... thinking Dijkstra or BFS\\n3. Some observation for adjacent cell A,B\\n    if `Grid_val(B) <= T(A)+1` we can go from A to B in time T(A)+1 [T(A) = time to reach A]\\n    if `Grid_val(B) >  T(A)+1` we can still go from A to B why? Since we came to A from some\\n    prev cell say C we can go back and forth between A & C to reach back at A with some time T\\n    such that T(A) becomes >=  Grid_val(B)-1. Another thing is say T(A) is odd and Grid_val(B) is\\n    also odd say(T(A) = 1 && Grid_val(B) = 5) then we go back and forth from C to A and go to B at\\n    time Grid_val(B)+1 \\n    `[A->1,C->2,A->3,C->4,A->5 we stop here then go to B at time 6]`\\n    Same will be the case if both are even\\n    Now if T(A) is odd and Grid_val(B) is even or vice verse then we go back and forth from C to A\\n    and go to B at time Grid_val(B) say(T(A) = 2 && Grid_val(B) = 5)\\n    `[A->2,C->3,A->4 we stop here then go to B at time 5]`\\n    \\n    So, if `Grid_val(B) >  T(A)+1` we can go to B at `Grid_val(B)+(T(a)%2 == Grid_val(b)%2)`\\n4. Rest is Normal Dijkstra\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int m = grid.size(), n =grid[0].size();\\n        \\n        if(grid[0][1]-grid[0][0] > 1 && grid[1][0]-grid[0][0] > 1) return -1;\\n        \\n        vector<vector<int>> time(m,vector<int>(n,INT_MAX));\\n        time[0][0] = 0;\\n        \\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        pq.push({0,0,0}); \\n        \\n        vector<pair<int,int>> directions{{0,1},{0,-1},{1,0},{-1,0}};\\n        vector<int> pos;\\n        \\n        int i,j,x,y;\\n        while(!pq.empty()){\\n            pos = pq.top();\\n            pq.pop();\\n            i = pos[1], j = pos[2];\\n            for(auto& [a,b] : directions){\\n                x = i+a, y = j+b;\\n                if(x >= 0 && x < m && y >= 0 && y < n){\\n\\t\\t\\t\\t// (time[i][j]%2) == (grid[x][y]%2) T(A) & Grid_val(B) both are even or odd\\n                    if(grid[x][y] > time[i][j]+1 && \\n                       time[x][y] > grid[x][y]+((time[i][j]%2) == (grid[x][y]%2))){\\n                        time[x][y] = grid[x][y]+((time[i][j]%2) == (grid[x][y]%2));\\n                        pq.push({time[x][y],x,y});\\n                    }\\n                    else if(grid[x][y] <= time[i][j]+1 && time[x][y] > time[i][j]+1){\\n                        time[x][y] = time[i][j]+1;\\n                        pq.push({time[x][y],x,y});\\n                    }\\n                }\\n            }\\n        }\\n        return time[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int m = grid.size(), n =grid[0].size();\\n        \\n        if(grid[0][1]-grid[0][0] > 1 && grid[1][0]-grid[0][0] > 1) return -1;\\n        \\n        vector<vector<int>> time(m,vector<int>(n,INT_MAX));\\n        time[0][0] = 0;\\n        \\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        pq.push({0,0,0}); \\n        \\n        vector<pair<int,int>> directions{{0,1},{0,-1},{1,0},{-1,0}};\\n        vector<int> pos;\\n        \\n        int i,j,x,y;\\n        while(!pq.empty()){\\n            pos = pq.top();\\n            pq.pop();\\n            i = pos[1], j = pos[2];\\n            for(auto& [a,b] : directions){\\n                x = i+a, y = j+b;\\n                if(x >= 0 && x < m && y >= 0 && y < n){\\n\\t\\t\\t\\t// (time[i][j]%2) == (grid[x][y]%2) T(A) & Grid_val(B) both are even or odd\\n                    if(grid[x][y] > time[i][j]+1 && \\n                       time[x][y] > grid[x][y]+((time[i][j]%2) == (grid[x][y]%2))){\\n                        time[x][y] = grid[x][y]+((time[i][j]%2) == (grid[x][y]%2));\\n                        pq.push({time[x][y],x,y});\\n                    }\\n                    else if(grid[x][y] <= time[i][j]+1 && time[x][y] > time[i][j]+1){\\n                        time[x][y] = time[i][j]+1;\\n                        pq.push({time[x][y],x,y});\\n                    }\\n                }\\n            }\\n        }\\n        return time[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232027,
                "title": "c-bfs-dijkstra",
                "content": "```\\n// using the word \"place\" to denote adjacent positions. Example for (i,j) -> (i+1,j) is an adjacent place\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int tm=0;\\n\\t\\t// In the following case no solution exists\\n        if(grid[0][1]>1 && grid[1][0]>1){\\n            return -1;\\n        }\\n\\t\\t// following typical Dijkstra algorithm using priority queue\\n        vector<vector<int>> a(grid.size(),vector<int> (grid[0].size(),-1));\\n        a[0][0]=0;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> q;\\n        q.push({0,{0,0}});\\n        while(!q.empty()){\\n            pair<int,int> cur = q.top().second;\\n            q.pop();\\n\\t\\t\\t// if not already visited then pushing it into priority-queue\\n            if(cur.first+1<grid.size() && a[cur.first+1][cur.second]==-1){\\n\\t\\t\\t// checking if can directly go to the adjacent place (i+1,j) | (i-1,j) | (i,j+1) | (i,j-1)\\n                if(grid[cur.first+1][cur.second]-1<=a[cur.first][cur.second]){\\n                    a[cur.first+1][cur.second]=a[cur.first][cur.second]+1;\\n                }\\n\\t\\t\\t\\t// if cannot go directly, going back and forth the adjacent place, this increases the time by even time-steps and going \\n\\t\\t\\t\\t// to the adjacent place requires one extra time-step. Doing this for the rest of the if-else statements.\\n                else\\n                    a[cur.first+1][cur.second] = a[cur.first][cur.second] + (grid[cur.first+1][cur.second]-a[cur.first][cur.second]+1)%2+(grid[cur.first+1][cur.second]-a[cur.first][cur.second]);\\n                q.push({a[cur.first+1][cur.second],{cur.first+1,cur.second}});\\n            }\\n            if(cur.first-1>=0 && a[cur.first-1][cur.second]==-1){\\n                if(grid[cur.first-1][cur.second]-1<=a[cur.first][cur.second]){\\n                    a[cur.first-1][cur.second]=a[cur.first][cur.second]+1;\\n                }\\n                else\\n                    a[cur.first-1][cur.second] = a[cur.first][cur.second] + (grid[cur.first-1][cur.second]-a[cur.first][cur.second]+1)%2+(grid[cur.first-1][cur.second]-a[cur.first][cur.second]);\\n                q.push({a[cur.first-1][cur.second],{cur.first-1,cur.second}});\\n            }\\n            if(cur.second+1<grid[0].size() && a[cur.first][cur.second+1]==-1){\\n                if(grid[cur.first][cur.second+1]-1<=a[cur.first][cur.second]){\\n                    a[cur.first][cur.second+1]=a[cur.first][cur.second]+1;\\n                }\\n                else\\n                    a[cur.first][cur.second+1] = a[cur.first][cur.second] + (grid[cur.first][cur.second+1]-a[cur.first][cur.second]+1)%2+(grid[cur.first][cur.second+1]-a[cur.first][cur.second]);\\n                q.push({a[cur.first][cur.second+1],{cur.first,cur.second+1}});\\n            }\\n            if(cur.second-1>=0 && a[cur.first][cur.second-1]==-1){\\n                if(grid[cur.first][cur.second-1]-1<=a[cur.first][cur.second]){\\n                    a[cur.first][cur.second-1]=a[cur.first][cur.second]+1;\\n                }\\n                else\\n                    a[cur.first][cur.second-1] = a[cur.first][cur.second] + (grid[cur.first][cur.second-1]-a[cur.first][cur.second]+1)%2+(grid[cur.first][cur.second-1]-a[cur.first][cur.second]);\\n                q.push({a[cur.first][cur.second-1],{cur.first,cur.second-1}});\\n            }\\n            \\n        }\\n\\t\\t// returning the time for the last index\\n        return a[grid.size()-1][grid[0].size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// using the word \"place\" to denote adjacent positions. Example for (i,j) -> (i+1,j) is an adjacent place\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int tm=0;\\n\\t\\t// In the following case no solution exists\\n        if(grid[0][1]>1 && grid[1][0]>1){\\n            return -1;\\n        }\\n\\t\\t// following typical Dijkstra algorithm using priority queue\\n        vector<vector<int>> a(grid.size(),vector<int> (grid[0].size(),-1));\\n        a[0][0]=0;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> q;\\n        q.push({0,{0,0}});\\n        while(!q.empty()){\\n            pair<int,int> cur = q.top().second;\\n            q.pop();\\n\\t\\t\\t// if not already visited then pushing it into priority-queue\\n            if(cur.first+1<grid.size() && a[cur.first+1][cur.second]==-1){\\n\\t\\t\\t// checking if can directly go to the adjacent place (i+1,j) | (i-1,j) | (i,j+1) | (i,j-1)\\n                if(grid[cur.first+1][cur.second]-1<=a[cur.first][cur.second]){\\n                    a[cur.first+1][cur.second]=a[cur.first][cur.second]+1;\\n                }\\n\\t\\t\\t\\t// if cannot go directly, going back and forth the adjacent place, this increases the time by even time-steps and going \\n\\t\\t\\t\\t// to the adjacent place requires one extra time-step. Doing this for the rest of the if-else statements.\\n                else\\n                    a[cur.first+1][cur.second] = a[cur.first][cur.second] + (grid[cur.first+1][cur.second]-a[cur.first][cur.second]+1)%2+(grid[cur.first+1][cur.second]-a[cur.first][cur.second]);\\n                q.push({a[cur.first+1][cur.second],{cur.first+1,cur.second}});\\n            }\\n            if(cur.first-1>=0 && a[cur.first-1][cur.second]==-1){\\n                if(grid[cur.first-1][cur.second]-1<=a[cur.first][cur.second]){\\n                    a[cur.first-1][cur.second]=a[cur.first][cur.second]+1;\\n                }\\n                else\\n                    a[cur.first-1][cur.second] = a[cur.first][cur.second] + (grid[cur.first-1][cur.second]-a[cur.first][cur.second]+1)%2+(grid[cur.first-1][cur.second]-a[cur.first][cur.second]);\\n                q.push({a[cur.first-1][cur.second],{cur.first-1,cur.second}});\\n            }\\n            if(cur.second+1<grid[0].size() && a[cur.first][cur.second+1]==-1){\\n                if(grid[cur.first][cur.second+1]-1<=a[cur.first][cur.second]){\\n                    a[cur.first][cur.second+1]=a[cur.first][cur.second]+1;\\n                }\\n                else\\n                    a[cur.first][cur.second+1] = a[cur.first][cur.second] + (grid[cur.first][cur.second+1]-a[cur.first][cur.second]+1)%2+(grid[cur.first][cur.second+1]-a[cur.first][cur.second]);\\n                q.push({a[cur.first][cur.second+1],{cur.first,cur.second+1}});\\n            }\\n            if(cur.second-1>=0 && a[cur.first][cur.second-1]==-1){\\n                if(grid[cur.first][cur.second-1]-1<=a[cur.first][cur.second]){\\n                    a[cur.first][cur.second-1]=a[cur.first][cur.second]+1;\\n                }\\n                else\\n                    a[cur.first][cur.second-1] = a[cur.first][cur.second] + (grid[cur.first][cur.second-1]-a[cur.first][cur.second]+1)%2+(grid[cur.first][cur.second-1]-a[cur.first][cur.second]);\\n                q.push({a[cur.first][cur.second-1],{cur.first,cur.second-1}});\\n            }\\n            \\n        }\\n\\t\\t// returning the time for the last index\\n        return a[grid.size()-1][grid[0].size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232016,
                "title": "c-solution-bfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<pair<int,int>> dir{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    int n,m;\\n    int minimumTime(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n\\n        if(grid[0][1]>1 and grid[1][0]>1) return -1;\\n\\n\\n        vector<vector<bool>>vis(n,vector<bool>(m,false));\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n        // t i j\\n        pq.push({0,0,0});\\n\\n        while(!pq.empty()){\\n            auto temp = pq.top();\\n            pq.pop();\\n            int t = temp[0];\\n            int x = temp[1];\\n            int y = temp[2];\\n\\n            if(x == n-1 and y == m-1) return t;\\n\\n            if(vis[x][y]) continue;\\n\\n            vis[x][y] = true;\\n\\n            for(auto it : dir){\\n                int xx = it.first + x;\\n                int yy = it.second + y;\\n                if(xx<0 || yy<0 || xx>=n || yy>=m || vis[xx][yy]) continue;\\n                bool wait = ((grid[xx][yy] - t)%2 == 0);\\n                pq.push({max(t+1,wait+grid[xx][yy]),xx,yy});\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<pair<int,int>> dir{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    int n,m;\\n    int minimumTime(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n\\n        if(grid[0][1]>1 and grid[1][0]>1) return -1;\\n\\n\\n        vector<vector<bool>>vis(n,vector<bool>(m,false));\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n        // t i j\\n        pq.push({0,0,0});\\n\\n        while(!pq.empty()){\\n            auto temp = pq.top();\\n            pq.pop();\\n            int t = temp[0];\\n            int x = temp[1];\\n            int y = temp[2];\\n\\n            if(x == n-1 and y == m-1) return t;\\n\\n            if(vis[x][y]) continue;\\n\\n            vis[x][y] = true;\\n\\n            for(auto it : dir){\\n                int xx = it.first + x;\\n                int yy = it.second + y;\\n                if(xx<0 || yy<0 || xx>=n || yy>=m || vis[xx][yy]) continue;\\n                bool wait = ((grid[xx][yy] - t)%2 == 0);\\n                pq.push({max(t+1,wait+grid[xx][yy]),xx,yy});\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232005,
                "title": "c-bfs-solution",
                "content": "# Intuition\\nUPVOTE\\n\\n# Approach\\nEasy BFS\\n\\n# Complexity\\n- Time complexity:\\nm*n+log(m+n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        \\n        vector<vector<int>> dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n\\n        priority_queue<vector<int>, vector<vector<int>>, greater<>> q;\\n        vis[0][0] = 1;\\n\\n        if(grid[1][0] <= 1) {\\n            q.push({1, 1, 0});\\n            vis[1][0] = 1;\\n        }\\n        if(grid[0][1] <= 1) {\\n            q.push({1, 0, 1});\\n            vis[0][1] = 1;\\n        }\\n        if(q.empty()) return -1;\\n\\n        while(!q.empty()) {\\n            vector<int> v = q.top(); q.pop();\\n            int t = v[0], i = v[1], j = v[2];\\n            if(i == n-1 && j == m-1) return t;\\n\\n            for(auto X: dir) {\\n                int r = i + X[0], c = j + X[1];\\n                if(r < n && r >= 0 && c < m && c >= 0 && !vis[r][c]) {\\n                    if(grid[r][c] <= t+1) {\\n                        q.push({t+1, r, c});\\n                    } else {\\n                        int d = grid[r][c] - t;\\n                        if(d%2 == 0) {\\n                            q.push({grid[r][c]+1, r, c});\\n                        } else {\\n                            q.push({grid[r][c], r, c});\\n                        }\\n                    }\\n                    vis[r][c] = 1;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        \\n        vector<vector<int>> dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n\\n        priority_queue<vector<int>, vector<vector<int>>, greater<>> q;\\n        vis[0][0] = 1;\\n\\n        if(grid[1][0] <= 1) {\\n            q.push({1, 1, 0});\\n            vis[1][0] = 1;\\n        }\\n        if(grid[0][1] <= 1) {\\n            q.push({1, 0, 1});\\n            vis[0][1] = 1;\\n        }\\n        if(q.empty()) return -1;\\n\\n        while(!q.empty()) {\\n            vector<int> v = q.top(); q.pop();\\n            int t = v[0], i = v[1], j = v[2];\\n            if(i == n-1 && j == m-1) return t;\\n\\n            for(auto X: dir) {\\n                int r = i + X[0], c = j + X[1];\\n                if(r < n && r >= 0 && c < m && c >= 0 && !vis[r][c]) {\\n                    if(grid[r][c] <= t+1) {\\n                        q.push({t+1, r, c});\\n                    } else {\\n                        int d = grid[r][c] - t;\\n                        if(d%2 == 0) {\\n                            q.push({grid[r][c]+1, r, c});\\n                        } else {\\n                            q.push({grid[r][c], r, c});\\n                        }\\n                    }\\n                    vis[r][c] = 1;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231924,
                "title": "easy-cpp-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>row={1,-1,0,0},col={0,0,1,-1};\\n    \\n    int minimumTime(vector<vector<int>>& grid) {\\n        if(grid[0][1]>1 && grid[1][0]>1)return -1;\\n        \\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>vis(m,vector<int>(n));\\n        \\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>q;\\n        \\n        q.push({0,0,0});\\n        \\n        while(!q.empty()){\\n            auto a=q.top();\\n            q.pop();\\n            \\n            int r1=a[1],c1=a[2],t=a[0];\\n\\n            if(r1==m-1 && c1==n-1)return t;\\n            \\n            if(vis[r1][c1])continue;\\n            vis[r1][c1]=1;\\n            \\n            for(int i=0;i<4;i++){\\n                int r=r1+row[i],c=c1+col[i];\\n                \\n                if(r>=0 && c>=0 && r<m && c<n && !vis[r][c]){\\n                    if(grid[r][c]<=t+1){\\n                        q.push({t+1,r,c});\\n                    }\\n                    else {\\n                        int val=grid[r][c]-t;\\n                        if(val%2==0){\\n                            q.push({grid[r][c]+1,r,c});\\n                        }\\n                        else{\\n                            q.push({grid[r][c],r,c});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>row={1,-1,0,0},col={0,0,1,-1};\\n    \\n    int minimumTime(vector<vector<int>>& grid) {\\n        if(grid[0][1]>1 && grid[1][0]>1)return -1;\\n        \\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>vis(m,vector<int>(n));\\n        \\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>q;\\n        \\n        q.push({0,0,0});\\n        \\n        while(!q.empty()){\\n            auto a=q.top();\\n            q.pop();\\n            \\n            int r1=a[1],c1=a[2],t=a[0];\\n\\n            if(r1==m-1 && c1==n-1)return t;\\n            \\n            if(vis[r1][c1])continue;\\n            vis[r1][c1]=1;\\n            \\n            for(int i=0;i<4;i++){\\n                int r=r1+row[i],c=c1+col[i];\\n                \\n                if(r>=0 && c>=0 && r<m && c<n && !vis[r][c]){\\n                    if(grid[r][c]<=t+1){\\n                        q.push({t+1,r,c});\\n                    }\\n                    else {\\n                        int val=grid[r][c]-t;\\n                        if(val%2==0){\\n                            q.push({grid[r][c]+1,r,c});\\n                        }\\n                        else{\\n                            q.push({grid[r][c],r,c});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231675,
                "title": "java-easiest-solution-dijkstra-algo-with-explanation",
                "content": "```\\nclass Solution {\\n    static class Pair {\\n        int x;\\n        int y;\\n        int time;\\n\\n        public Pair(int x, int y, int time) {\\n            this.x = x;\\n            this.y = y;\\n            this.time = time;\\n        }\\n    }\\n\\n    public static int minimumTime(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        if (grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n\\n        boolean[][] vis = new boolean[n][m];\\n        Queue<Pair> pq = new PriorityQueue<>((a, b) -> a.time - b.time);\\n        pq.offer(new Pair(0, 0, 0));\\n        vis[0][0] = true;\\n\\n        int[] xcor = new int[]{1, -1, 0, 0};\\n        int[] ycor = new int[]{0, 0, -1, 1};\\n\\n        while (!pq.isEmpty()) {\\n            Pair pair = pq.poll();\\n            int x = pair.x;\\n            int y = pair.y;\\n            if (x == n - 1 && y == m - 1) {\\n                return pair.time;\\n            }\\n            for (int i = 0; i < 4; i++) {\\n                int newX = xcor[i] + x;\\n                int newY = ycor[i] + y;\\n                if (newX < 0 || newX >= n || newY < 0 || newY >= m || vis[newX][newY]) continue;\\n\\n                if (grid[newX][newY] <= pair.time + 1) {\\n                    pq.offer(new Pair(newX, newY, pair.time + 1));\\n                } else {\\n\\t\\t\\t\\t\\t// If we cant move to neighbor yet, we can hop to the previous cell\\n                    // and back to current cell as many times as we need to until\\n                    // sufficient time has passed.\\n                    // The trick here is that if the difference between the current time\\n                    // and the time we need is even, we will arrive back at the current cell\\n                    // 1 second \"late\" and so we will move to the neighbor 1 second after\\n                    // the minimum neighbor time.\\n                    \\n                    int diff = grid[newX][newY] - pair.time;\\n                    if (diff % 2 == 1) {\\n                        pq.offer(new Pair(newX, newY, pair.time + diff));\\n                    } else {\\n                        pq.offer(new Pair(newX, newY, pair.time + diff + 1));\\n                    }\\n                }\\n                vis[newX][newY] = true;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    static class Pair {\\n        int x;\\n        int y;\\n        int time;\\n\\n        public Pair(int x, int y, int time) {\\n            this.x = x;\\n            this.y = y;\\n            this.time = time;\\n        }\\n    }\\n\\n    public static int minimumTime(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        if (grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n\\n        boolean[][] vis = new boolean[n][m];\\n        Queue<Pair> pq = new PriorityQueue<>((a, b) -> a.time - b.time);\\n        pq.offer(new Pair(0, 0, 0));\\n        vis[0][0] = true;\\n\\n        int[] xcor = new int[]{1, -1, 0, 0};\\n        int[] ycor = new int[]{0, 0, -1, 1};\\n\\n        while (!pq.isEmpty()) {\\n            Pair pair = pq.poll();\\n            int x = pair.x;\\n            int y = pair.y;\\n            if (x == n - 1 && y == m - 1) {\\n                return pair.time;\\n            }\\n            for (int i = 0; i < 4; i++) {\\n                int newX = xcor[i] + x;\\n                int newY = ycor[i] + y;\\n                if (newX < 0 || newX >= n || newY < 0 || newY >= m || vis[newX][newY]) continue;\\n\\n                if (grid[newX][newY] <= pair.time + 1) {\\n                    pq.offer(new Pair(newX, newY, pair.time + 1));\\n                } else {\\n\\t\\t\\t\\t\\t// If we cant move to neighbor yet, we can hop to the previous cell\\n                    // and back to current cell as many times as we need to until\\n                    // sufficient time has passed.\\n                    // The trick here is that if the difference between the current time\\n                    // and the time we need is even, we will arrive back at the current cell\\n                    // 1 second \"late\" and so we will move to the neighbor 1 second after\\n                    // the minimum neighbor time.\\n                    \\n                    int diff = grid[newX][newY] - pair.time;\\n                    if (diff % 2 == 1) {\\n                        pq.offer(new Pair(newX, newY, pair.time + diff));\\n                    } else {\\n                        pq.offer(new Pair(newX, newY, pair.time + diff + 1));\\n                    }\\n                }\\n                vis[newX][newY] = true;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231649,
                "title": "a-shortest-path-algorithm-with-a-twist-detailed-explanation-dijkstra-s-algorithm-cpp",
                "content": "# Intuition\\nWe can model the given problem as a graph where each cell is a node and each node is connected with its neighboring cells. The weight of the edge between two nodes is the amount of time required to move from one cell to another. To minimize the time to reach the bottom-right corner, we need to find the shortest path from the top-left corner to the bottom-right corner. We can use Dijkstra\\'s algorithm to find the shortest path in an undirected, weighted graph.\\n\\n# Approach\\nWe can use Dijkstra\\'s algorithm to find the shortest path from the top-left corner to the bottom-right corner of the grid. To implement Dijkstra\\'s algorithm, we can use a priority queue to keep track of the nodes with minimum distance. We start from the top-left corner and push it into the priority queue. We also keep track of the nodes that we have already visited to avoid visiting them again. In each iteration, we pop the node with minimum distance from the priority queue, update the distance of its neighbors, and push them into the priority queue if they have not been visited before. We stop when we reach the bottom-right corner or when there are no more nodes to visit.\\n\\nTo update the distance of a neighbor, we need to consider the time required to move from the current cell to the neighbor cell. If the time required to move from the current cell to the neighbor cell is odd, we need to wait one second before we can start moving. For example, if the current cell has a time of 2 and the neighbor cell has a time of 3, we need to wait one second before we can start moving. In this case, the total time required to move from the current cell to the neighbor cell is 4. If the time required to move from the current cell to the neighbor cell is even, we can move without waiting. For example, if the current cell has a time of 2 and the neighbor cell has a time of 4, we can move without waiting. In this case, the total time required to move from the current cell to the neighbor cell is 4.\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity: **O(mn log(mn))**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n- Space complexity: **O(mn)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\\n            return -1;\\n        }\\n        vector<vector<int>> directions{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        priority_queue<vector<int>, vector<vector<int>>, greater<>> pq;\\n        pq.push({0, 0, 0}); // (t, r, c)\\n        while (!pq.empty()) {\\n            vector<int> cur = pq.top();\\n            int t = cur[0], r = cur[1], c = cur[2];\\n            pq.pop();\\n            if (r == m - 1 && c == n - 1) {\\n                return t;\\n            }\\n            if (visited[r][c]) {\\n                continue;\\n            }\\n            visited[r][c] = true;\\n            for (const auto& dir : directions) {\\n                int nr = r + dir[0], nc = c + dir[1];\\n                if (nr < 0 || nr >= m || nc < 0 || nc >= n || visited[nr][nc]) {\\n                    continue;\\n                }\\n                bool wait = (grid[nr][nc] - t) % 2 == 0;\\n                int nt = max(grid[nr][nc] + wait, t + 1);\\n                pq.push({nt, nr, nc});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\\n            return -1;\\n        }\\n        vector<vector<int>> directions{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        priority_queue<vector<int>, vector<vector<int>>, greater<>> pq;\\n        pq.push({0, 0, 0}); // (t, r, c)\\n        while (!pq.empty()) {\\n            vector<int> cur = pq.top();\\n            int t = cur[0], r = cur[1], c = cur[2];\\n            pq.pop();\\n            if (r == m - 1 && c == n - 1) {\\n                return t;\\n            }\\n            if (visited[r][c]) {\\n                continue;\\n            }\\n            visited[r][c] = true;\\n            for (const auto& dir : directions) {\\n                int nr = r + dir[0], nc = c + dir[1];\\n                if (nr < 0 || nr >= m || nc < 0 || nc >= n || visited[nr][nc]) {\\n                    continue;\\n                }\\n                bool wait = (grid[nr][nc] - t) % 2 == 0;\\n                int nt = max(grid[nr][nc] + wait, t + 1);\\n                pq.push({nt, nr, nc});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231627,
                "title": "dijkstra-s-algorithm",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    public int minimumTime(int[][] grid) {\\n\\n        if(grid[0][1] > 1 && grid[1][0] > 1) {\\n            return -1;\\n        }\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] minTime = new int[m][n];\\n        for (int i = 0; i < m; i++) {\\n            Arrays.fill(minTime[i], Integer.MAX_VALUE);\\n        }\\n\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        queue.offer(new int[]{0, 0, 0});\\n\\n        while (!queue.isEmpty()) {\\n\\n            int[] cur = queue.poll();\\n            int x = cur[0];\\n            int y = cur[1];\\n            int time = cur[2];\\n            if (x == m - 1 && y == n - 1) {\\n                return time;\\n            }\\n            for (int[] dir : dirs) {\\n                int nx = x + dir[0];\\n                int ny = y + dir[1];\\n                if (nx >= 0 && ny >= 0 && nx < m && ny < n) {\\n                    int nTime = time + 1;\\n                    if (nTime < grid[nx][ny]) {\\n                        nTime = (grid[nx][ny] - nTime) % 2 == 0 ? grid[nx][ny] : grid[nx][ny] + 1;\\n                    }\\n                    if (nTime < minTime[nx][ny]) {\\n                        minTime[nx][ny] = nTime;\\n                        queue.offer(new int[]{nx, ny, nTime});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    public int minimumTime(int[][] grid) {\\n\\n        if(grid[0][1] > 1 && grid[1][0] > 1) {\\n            return -1;\\n        }\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] minTime = new int[m][n];\\n        for (int i = 0; i < m; i++) {\\n            Arrays.fill(minTime[i], Integer.MAX_VALUE);\\n        }\\n\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        queue.offer(new int[]{0, 0, 0});\\n\\n        while (!queue.isEmpty()) {\\n\\n            int[] cur = queue.poll();\\n            int x = cur[0];\\n            int y = cur[1];\\n            int time = cur[2];\\n            if (x == m - 1 && y == n - 1) {\\n                return time;\\n            }\\n            for (int[] dir : dirs) {\\n                int nx = x + dir[0];\\n                int ny = y + dir[1];\\n                if (nx >= 0 && ny >= 0 && nx < m && ny < n) {\\n                    int nTime = time + 1;\\n                    if (nTime < grid[nx][ny]) {\\n                        nTime = (grid[nx][ny] - nTime) % 2 == 0 ? grid[nx][ny] : grid[nx][ny] + 1;\\n                    }\\n                    if (nTime < minTime[nx][ny]) {\\n                        minTime[nx][ny] = nTime;\\n                        queue.offer(new int[]{nx, ny, nTime});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231623,
                "title": "dijkstra-solution",
                "content": "# Intuition\\nTreat matrix as a graph, then we can apply Dijkstra algorithm to find the shortest path between start and end cells.\\n\\nThe tricky part is the \"time\" constraint, specifically, `grid[row][col]` represents the minimum time required to be able to visit the cell.\\n\\nThe key observation is that if we can move between 2 cells, by constantly doing that, we can make the \"time\" arbitrary large. So in Dijkstra, the \"dist\" should be the \"normal dist\" and the time waited to be able to visit a cell.\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /*\\n    Runtime 200 ms Beats 71.43%\\n    Memory 52.9 MB Beats 71.43%\\n     */\\n    private static final int[][] DIRS = new int[][] {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n\\n    public int minimumTime(int[][] grid) {\\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\\n            return -1;\\n        }\\n\\n        int[][] distTo = new int[grid.length][grid[0].length];\\n        for (int[] row : distTo) {\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        }\\n        distTo[0][0] = 0;\\n\\n        Queue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(i -> i[2]));\\n        queue.add(new int[] {0, 0, 0});\\n\\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n\\n            for (int[] dir : DIRS) {\\n                int nextR = curr[0] + dir[0];\\n                int nextC = curr[1] + dir[1];\\n                if (nextR >= 0 && nextR < grid.length && nextC >= 0 && nextC < grid[0].length) {\\n                    int nextDist = curr[2] + 1;\\n                    if (nextDist < grid[nextR][nextC]) {\\n                        if (nextDist % 2 == grid[nextR][nextC] % 2) {\\n                            nextDist = grid[nextR][nextC];\\n                        } else {\\n                            nextDist = grid[nextR][nextC] + 1;\\n                        }\\n                    }\\n                    if (distTo[nextR][nextC] > nextDist) {\\n                        if (nextR == grid.length - 1 && nextC == grid[0].length - 1) {\\n                            return nextDist;\\n                        }\\n                        distTo[nextR][nextC] = nextDist;\\n                        queue.add(new int[] {nextR, nextC, nextDist});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    /*\\n    Runtime 200 ms Beats 71.43%\\n    Memory 52.9 MB Beats 71.43%\\n     */\\n    private static final int[][] DIRS = new int[][] {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n\\n    public int minimumTime(int[][] grid) {\\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\\n            return -1;\\n        }\\n\\n        int[][] distTo = new int[grid.length][grid[0].length];\\n        for (int[] row : distTo) {\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        }\\n        distTo[0][0] = 0;\\n\\n        Queue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(i -> i[2]));\\n        queue.add(new int[] {0, 0, 0});\\n\\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n\\n            for (int[] dir : DIRS) {\\n                int nextR = curr[0] + dir[0];\\n                int nextC = curr[1] + dir[1];\\n                if (nextR >= 0 && nextR < grid.length && nextC >= 0 && nextC < grid[0].length) {\\n                    int nextDist = curr[2] + 1;\\n                    if (nextDist < grid[nextR][nextC]) {\\n                        if (nextDist % 2 == grid[nextR][nextC] % 2) {\\n                            nextDist = grid[nextR][nextC];\\n                        } else {\\n                            nextDist = grid[nextR][nextC] + 1;\\n                        }\\n                    }\\n                    if (distTo[nextR][nextC] > nextDist) {\\n                        if (nextR == grid.length - 1 && nextC == grid[0].length - 1) {\\n                            return nextDist;\\n                        }\\n                        distTo[nextR][nextC] = nextDist;\\n                        queue.add(new int[] {nextR, nextC, nextDist});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231500,
                "title": "java-pq",
                "content": "```\\nclass Solution {\\n    int[][] grid;\\n    int[][] visited;\\n    int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    public int minimumTime(int[][] grid) {\\n        if (grid[0][0] + 1 < grid[0][1] && grid[0][0] + 1 < grid[1][0]) return -1;\\n        this.grid = grid;\\n        this.visited = new int[grid.length][grid[0].length];\\n        for (int[] i : visited) Arrays.fill(i, 100000 * 4);\\n        visited[0][0] = 0;\\n        PriorityQueue<int[]> q = new PriorityQueue<>((a,b) -> a[0] - b[0]);\\n        q.add(new int[]{0, 0, 0});\\n        while (q.peek()[1] != grid.length - 1 || q.peek()[2] != grid[0].length - 1) {\\n            int[] curr = q.poll();\\n            int x = curr[1], y = curr[2];\\n            if (visited[x][y] < curr[0]) continue;\\n            for (int[] d : dir) {\\n                int a = x + d[0], b = y + d[1];\\n                if (isbound(a, b) && (visited[a][b] == 100000 * 4 || visited[x][y] + 1 < visited[a][b])) {\\n                    if (visited[x][y] + 1 >= grid[a][b]) {\\n                        visited[a][b] = visited[x][y] + 1;\\n                    } else {\\n                        int diff = grid[a][b] - visited[x][y];\\n                        diff = diff % 2 == 0 ? diff + 1 : diff;\\n                        visited[a][b] = visited[x][y] + diff;\\n                    }\\n                    q.add(new int[]{visited[a][b], a, b});\\n                }\\n            }\\n        }\\n        \\n        return q.peek()[0];\\n    }\\n    \\n    public boolean isbound(int x, int y) {\\n        if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length) return false;\\n        return true;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] grid;\\n    int[][] visited;\\n    int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    public int minimumTime(int[][] grid) {\\n        if (grid[0][0] + 1 < grid[0][1] && grid[0][0] + 1 < grid[1][0]) return -1;\\n        this.grid = grid;\\n        this.visited = new int[grid.length][grid[0].length];\\n        for (int[] i : visited) Arrays.fill(i, 100000 * 4);\\n        visited[0][0] = 0;\\n        PriorityQueue<int[]> q = new PriorityQueue<>((a,b) -> a[0] - b[0]);\\n        q.add(new int[]{0, 0, 0});\\n        while (q.peek()[1] != grid.length - 1 || q.peek()[2] != grid[0].length - 1) {\\n            int[] curr = q.poll();\\n            int x = curr[1], y = curr[2];\\n            if (visited[x][y] < curr[0]) continue;\\n            for (int[] d : dir) {\\n                int a = x + d[0], b = y + d[1];\\n                if (isbound(a, b) && (visited[a][b] == 100000 * 4 || visited[x][y] + 1 < visited[a][b])) {\\n                    if (visited[x][y] + 1 >= grid[a][b]) {\\n                        visited[a][b] = visited[x][y] + 1;\\n                    } else {\\n                        int diff = grid[a][b] - visited[x][y];\\n                        diff = diff % 2 == 0 ? diff + 1 : diff;\\n                        visited[a][b] = visited[x][y] + diff;\\n                    }\\n                    q.add(new int[]{visited[a][b], a, b});\\n                }\\n            }\\n        }\\n        \\n        return q.peek()[0];\\n    }\\n    \\n    public boolean isbound(int x, int y) {\\n        if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length) return false;\\n        return true;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231460,
                "title": "python-solution-bfs-heap-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are 2 conditions. One, if we can visit a cell at current time and other condition if we cannot. In the other condition, we must retrace our path where we came from and return to the specified cell in optimal time. Run a BFS for both the conditions and maintain a heap to get the minimum time for a particular step.\\n\\n# Complexity\\n- Time complexity: $$O(m * n * log(m * n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m * n)$$ for the heap and `visited` set\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        directions, visited = [(1, 0), (-1, 0), (0, 1), (0, -1)], set()\\n        heap, numRows, numCols = [(0, 0, 0)], len(grid), len(grid[0])\\n        visited.add((0, 0))\\n        while heap:\\n            curTime, curRow, curCol = heappop(heap)\\n            if curRow == numRows - 1 and curCol == numCols - 1:\\n                return curTime\\n            if curTime > 10 ** 5 + 7:\\n                return -1\\n            canMove = False\\n            for drow, dcol in directions:\\n                newRow, newCol = curRow + drow, curCol + dcol\\n                if 0 <= newRow < numRows and 0 <= newCol < numCols and curTime >= grid[newRow][newCol]:\\n                    canMove = True; break\\n            for drow, dcol in directions:\\n                newRow, newCol = curRow + drow, curCol + dcol\\n                if 0 <= newRow < numRows and 0 <= newCol < numCols and (newRow, newCol) not in visited:\\n                    if grid[newRow][newCol] <= curTime + 1:\\n                        heappush(heap, (curTime + 1, newRow, newCol))\\n                    elif canMove:\\n                        newTime = grid[newRow][newCol] - curTime - 1\\n                        if newTime % 2: newTime = grid[newRow][newCol] + 1\\n                        else: newTime = grid[newRow][newCol]\\n                        heappush(heap, (newTime, newRow, newCol))\\n                    visited.add((newRow, newCol))\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```python []\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        directions, visited = [(1, 0), (-1, 0), (0, 1), (0, -1)], set()\\n        heap, numRows, numCols = [(0, 0, 0)], len(grid), len(grid[0])\\n        visited.add((0, 0))\\n        while heap:\\n            curTime, curRow, curCol = heappop(heap)\\n            if curRow == numRows - 1 and curCol == numCols - 1:\\n                return curTime\\n            if curTime > 10 ** 5 + 7:\\n                return -1\\n            canMove = False\\n            for drow, dcol in directions:\\n                newRow, newCol = curRow + drow, curCol + dcol\\n                if 0 <= newRow < numRows and 0 <= newCol < numCols and curTime >= grid[newRow][newCol]:\\n                    canMove = True; break\\n            for drow, dcol in directions:\\n                newRow, newCol = curRow + drow, curCol + dcol\\n                if 0 <= newRow < numRows and 0 <= newCol < numCols and (newRow, newCol) not in visited:\\n                    if grid[newRow][newCol] <= curTime + 1:\\n                        heappush(heap, (curTime + 1, newRow, newCol))\\n                    elif canMove:\\n                        newTime = grid[newRow][newCol] - curTime - 1\\n                        if newTime % 2: newTime = grid[newRow][newCol] + 1\\n                        else: newTime = grid[newRow][newCol]\\n                        heappush(heap, (newTime, newRow, newCol))\\n                    visited.add((newRow, newCol))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231335,
                "title": "js-bfs-min-priority-queue",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minimumTime = function(grid) {\\n    if(grid[0][1] > 1 && grid[1][0] > 1) {\\n        // edge case at 1st step\\n        return -1;\\n    }\\n    const m = grid.length, n = grid[0].length;\\n    const pq = new MinPriorityQueue({ priority: (bid) => bid[0] });\\n    const dir = [[0,1], [1,0], [0,-1], [-1, 0]];\\n    let i, j, curTime;\\n    const visited = new Set();\\n    pq.enqueue([0,0,0]);\\n\\n    while(!pq.isEmpty()) {\\n        const cur = pq.dequeue().element;\\n        i = cur[1];\\n        j = cur[2];\\n        if(i === m-1 && j === n-1) {\\n            // arrive at the destination\\n            return cur[0];\\n        }\\n        if(visited.has(`${i}:${j}`)) {\\n            continue;\\n        }\\n        curTime = cur[0] + 1; // step + 1 for next move\\n        visited.add(`${i}:${j}`);\\n        // search all 4 directions for next move options\\n        for(const d of dir) {\\n            const x = d[0] + i;\\n            const y = d[1] + j;\\n            if(x>=0 && y>=0 && x<m && y<n && !visited.has(`${x}:${y}`)) {\\n                let nextTime;\\n                if(curTime >= grid[x][y]) {\\n                    nextTime = curTime;\\n                }\\n                else {\\n                    let diff = 0;\\n                    if( (grid[x][y] - curTime ) % 2 === 1) {\\n                        // each circle of 2 and wait at same location\\n                        diff++;\\n                    }\\n                    nextTime = grid[x][y] + diff;\\n                }\\n                pq.enqueue([nextTime, x, y]);\\n            }\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minimumTime = function(grid) {\\n    if(grid[0][1] > 1 && grid[1][0] > 1) {\\n        // edge case at 1st step\\n        return -1;\\n    }\\n    const m = grid.length, n = grid[0].length;\\n    const pq = new MinPriorityQueue({ priority: (bid) => bid[0] });\\n    const dir = [[0,1], [1,0], [0,-1], [-1, 0]];\\n    let i, j, curTime;\\n    const visited = new Set();\\n    pq.enqueue([0,0,0]);\\n\\n    while(!pq.isEmpty()) {\\n        const cur = pq.dequeue().element;\\n        i = cur[1];\\n        j = cur[2];\\n        if(i === m-1 && j === n-1) {\\n            // arrive at the destination\\n            return cur[0];\\n        }\\n        if(visited.has(`${i}:${j}`)) {\\n            continue;\\n        }\\n        curTime = cur[0] + 1; // step + 1 for next move\\n        visited.add(`${i}:${j}`);\\n        // search all 4 directions for next move options\\n        for(const d of dir) {\\n            const x = d[0] + i;\\n            const y = d[1] + j;\\n            if(x>=0 && y>=0 && x<m && y<n && !visited.has(`${x}:${y}`)) {\\n                let nextTime;\\n                if(curTime >= grid[x][y]) {\\n                    nextTime = curTime;\\n                }\\n                else {\\n                    let diff = 0;\\n                    if( (grid[x][y] - curTime ) % 2 === 1) {\\n                        // each circle of 2 and wait at same location\\n                        diff++;\\n                    }\\n                    nextTime = grid[x][y] + diff;\\n                }\\n                pq.enqueue([nextTime, x, y]);\\n            }\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3231302,
                "title": "priorityqueue-with-dijkstra-algorithm",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minimumTime(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        if (grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        pq.offer(new int[]{0, 0, 0});\\n        boolean[][] visited = new boolean[m][n];\\n        int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        int ans = Integer.MAX_VALUE;\\n        \\n        while (!pq.isEmpty())\\n        {\\n            int[] cur = pq.poll();\\n            if (cur[0] == m - 1 && cur[1] == n - 1)\\n            {\\n                return cur[2];\\n            }\\n\\n            if (visited[cur[0]][cur[1]]) continue;\\n            visited[cur[0]][cur[1]] = true;\\n            \\n            for (int[] dir : dirs)\\n            {\\n                int x = cur[0] + dir[0], y = cur[1] + dir[1];\\n                if (x < 0 || y < 0 || x >= m || y >= n || visited[x][y]) continue;\\n                pq.offer(new int[]{x, y, Math.max((grid[x][y] - cur[2]) / 2 * 2, 0) + cur[2] + 1});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTime(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        if (grid[0][1] > 1 && grid[1][0] > 1) return -1;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        pq.offer(new int[]{0, 0, 0});\\n        boolean[][] visited = new boolean[m][n];\\n        int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        int ans = Integer.MAX_VALUE;\\n        \\n        while (!pq.isEmpty())\\n        {\\n            int[] cur = pq.poll();\\n            if (cur[0] == m - 1 && cur[1] == n - 1)\\n            {\\n                return cur[2];\\n            }\\n\\n            if (visited[cur[0]][cur[1]]) continue;\\n            visited[cur[0]][cur[1]] = true;\\n            \\n            for (int[] dir : dirs)\\n            {\\n                int x = cur[0] + dir[0], y = cur[1] + dir[1];\\n                if (x < 0 || y < 0 || x >= m || y >= n || visited[x][y]) continue;\\n                pq.offer(new int[]{x, y, Math.max((grid[x][y] - cur[2]) / 2 * 2, 0) + cur[2] + 1});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231289,
                "title": "javascript-dijkstra-with-heap-easy-simple",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minimumTime = function(grid) {\\n    \\n    if(grid[0][1]>1 && grid[1][0]>1){\\n        return -1;\\n    }\\n    //START Heap class in javascript\\n    class Heap{\\n        constructor(type){\\n            this.type = type;\\n            this.data = [];\\n            this.data[0] = undefined;\\n        }\\n        print(){\\n            for(let i=1;i<this.data.length;i++){\\n                console.log(this.data[i])\\n            }\\n        }\\n        getSize(){\\n            return this.data.length-1;\\n        }\\n        insert(value){\\n            this.data.push(value);\\n            if(this.data.length==2){\\n                return ;\\n            }\\n            let lastIndex = this.data.length-1;\\n            while(this.data[Math.floor(lastIndex/2)]!==undefined && this.compare(this.data[lastIndex],this.data[Math.floor(lastIndex/2)])>0){\\n                let temp = this.data[Math.floor(lastIndex/2)];\\n                this.data[Math.floor(lastIndex/2)] = this.data[lastIndex];\\n                this.data[lastIndex] = temp;\\n                lastIndex = Math.floor(lastIndex/2);\\n            }\\n        }\\n        //This returns a positive number if a is greater than b. Here meaing of being greater depends on the type of heap. For max heap it will return positive number if a>b and for min heap it will return positive number if a<b . \\n        compare(a,b){\\n            if(this.type===\"min\"){\\n                if(Array.isArray(a) && Array.isArray(b)){\\n                    return b[0]-a[0];\\n                }else{\\n                    return b-a;\\n                }\\n            }else{\\n                if(Array.isArray(a) && Array.isArray(b)){\\n                    return a[0]-b[0];\\n                }else{\\n                    return a-b;\\n                }\\n            }\\n        }\\n        removeTop(){\\n            let max = this.data[1];\\n            if(this.getSize()>1){\\n                this.data[1] = this.data.pop();\\n                this.heapify(1);\\n            }else{//If the size is 0 then just remove the element, no shifting and hipify will be applicable\\n                this.data.pop();\\n            }\\n            return max;\\n        }\\n        getTop(){\\n            let max = null;\\n            if(this.getSize()>=1){\\n                max = this.data[1];\\n            }\\n            return max;\\n        }\\n        heapify(pos){\\n            if(pos*2>this.data.length-1){\\n                //That means element at index \\'pos\\' is not having any child\\n                return;\\n            }\\n            if(\\n                (this.data[pos*2]!==undefined && this.compare(this.data[pos*2],this.data[pos])>0)\\n              || (this.data[pos*2+1]!==undefined && this.compare(this.data[pos*2+1],this.data[pos])>0)\\n              ){\\n                if(this.data[pos*2+1]===undefined || this.compare(this.data[pos*2+1],this.data[pos*2])<=0){\\n                    let temp = this.data[pos*2];\\n                    this.data[pos*2] = this.data[pos];\\n                    this.data[pos] = temp;\\n                    this.heapify(pos*2);\\n                }else{\\n                    let temp = this.data[pos*2+1];\\n                    this.data[pos*2+1] = this.data[pos];\\n                    this.data[pos] = temp;\\n                    this.heapify(pos*2+1);\\n                }\\n            }\\n        }\\n    }\\n    //END Heap class in javascript\\n    \\n    let ans = check(0);\\n    return ans;\\n    \\n    \\n    function check(cap){\\n        let minHeap = new Heap(\\'min\\');\\n        let queue=[],dx=[[0,1],[0,-1],[1,0],[-1,0]];\\n        let visited={};\\n        visited[0+\"_\"+0]=true;\\n        \\n        minHeap.insert([grid[0][0],0,0]);\\n        while(minHeap.getSize()>0){\\n            let item = minHeap.removeTop();\\n            let distance = item[0];\\n            let row = item[1];\\n            let col = item[2];\\n            if(row===grid.length-1 && col===grid[row].length-1){\\n                return distance;\\n            }\\n            for(let d=0;d<dx.length;d++){\\n                let i = row+dx[d][0];\\n                let j = col+dx[d][1];\\n                if(i>=0 && i<grid.length && j>=0 && j<grid[i].length && visited[i+\"_\"+j]===undefined){\\n                    if(distance+1>=grid[i][j]){\\n                        minHeap.insert([distance+1,i,j]);\\n                    }else{\\n                        let diff = grid[i][j]-distance;\\n                        let neighbhourDistance = grid[i][j];\\n                        if(diff%2===0){\\n                            neighbhourDistance++;\\n                        }\\n                        minHeap.insert([neighbhourDistance,i,j]);\\n                    }\\n                    visited[i+\"_\"+j] = true;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minimumTime = function(grid) {\\n    \\n    if(grid[0][1]>1 && grid[1][0]>1){\\n        return -1;\\n    }\\n    //START Heap class in javascript\\n    class Heap{\\n        constructor(type){\\n            this.type = type;\\n            this.data = [];\\n            this.data[0] = undefined;\\n        }\\n        print(){\\n            for(let i=1;i<this.data.length;i++){\\n                console.log(this.data[i])\\n            }\\n        }\\n        getSize(){\\n            return this.data.length-1;\\n        }\\n        insert(value){\\n            this.data.push(value);\\n            if(this.data.length==2){\\n                return ;\\n            }\\n            let lastIndex = this.data.length-1;\\n            while(this.data[Math.floor(lastIndex/2)]!==undefined && this.compare(this.data[lastIndex],this.data[Math.floor(lastIndex/2)])>0){\\n                let temp = this.data[Math.floor(lastIndex/2)];\\n                this.data[Math.floor(lastIndex/2)] = this.data[lastIndex];\\n                this.data[lastIndex] = temp;\\n                lastIndex = Math.floor(lastIndex/2);\\n            }\\n        }\\n        //This returns a positive number if a is greater than b. Here meaing of being greater depends on the type of heap. For max heap it will return positive number if a>b and for min heap it will return positive number if a<b . \\n        compare(a,b){\\n            if(this.type===\"min\"){\\n                if(Array.isArray(a) && Array.isArray(b)){\\n                    return b[0]-a[0];\\n                }else{\\n                    return b-a;\\n                }\\n            }else{\\n                if(Array.isArray(a) && Array.isArray(b)){\\n                    return a[0]-b[0];\\n                }else{\\n                    return a-b;\\n                }\\n            }\\n        }\\n        removeTop(){\\n            let max = this.data[1];\\n            if(this.getSize()>1){\\n                this.data[1] = this.data.pop();\\n                this.heapify(1);\\n            }else{//If the size is 0 then just remove the element, no shifting and hipify will be applicable\\n                this.data.pop();\\n            }\\n            return max;\\n        }\\n        getTop(){\\n            let max = null;\\n            if(this.getSize()>=1){\\n                max = this.data[1];\\n            }\\n            return max;\\n        }\\n        heapify(pos){\\n            if(pos*2>this.data.length-1){\\n                //That means element at index \\'pos\\' is not having any child\\n                return;\\n            }\\n            if(\\n                (this.data[pos*2]!==undefined && this.compare(this.data[pos*2],this.data[pos])>0)\\n              || (this.data[pos*2+1]!==undefined && this.compare(this.data[pos*2+1],this.data[pos])>0)\\n              ){\\n                if(this.data[pos*2+1]===undefined || this.compare(this.data[pos*2+1],this.data[pos*2])<=0){\\n                    let temp = this.data[pos*2];\\n                    this.data[pos*2] = this.data[pos];\\n                    this.data[pos] = temp;\\n                    this.heapify(pos*2);\\n                }else{\\n                    let temp = this.data[pos*2+1];\\n                    this.data[pos*2+1] = this.data[pos];\\n                    this.data[pos] = temp;\\n                    this.heapify(pos*2+1);\\n                }\\n            }\\n        }\\n    }\\n    //END Heap class in javascript\\n    \\n    let ans = check(0);\\n    return ans;\\n    \\n    \\n    function check(cap){\\n        let minHeap = new Heap(\\'min\\');\\n        let queue=[],dx=[[0,1],[0,-1],[1,0],[-1,0]];\\n        let visited={};\\n        visited[0+\"_\"+0]=true;\\n        \\n        minHeap.insert([grid[0][0],0,0]);\\n        while(minHeap.getSize()>0){\\n            let item = minHeap.removeTop();\\n            let distance = item[0];\\n            let row = item[1];\\n            let col = item[2];\\n            if(row===grid.length-1 && col===grid[row].length-1){\\n                return distance;\\n            }\\n            for(let d=0;d<dx.length;d++){\\n                let i = row+dx[d][0];\\n                let j = col+dx[d][1];\\n                if(i>=0 && i<grid.length && j>=0 && j<grid[i].length && visited[i+\"_\"+j]===undefined){\\n                    if(distance+1>=grid[i][j]){\\n                        minHeap.insert([distance+1,i,j]);\\n                    }else{\\n                        let diff = grid[i][j]-distance;\\n                        let neighbhourDistance = grid[i][j];\\n                        if(diff%2===0){\\n                            neighbhourDistance++;\\n                        }\\n                        minHeap.insert([neighbhourDistance,i,j]);\\n                    }\\n                    visited[i+\"_\"+j] = true;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231279,
                "title": "c-simple-bfs-using-priority-queue-easy-intuitive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int dx[4]={1,0,-1,0};\\n        int dy[4]={0,1,0,-1};\\n        priority_queue<vector<int>> q;\\n        q.push({0,0,0});\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>> vis(n,vector<int> (m,0));\\n        vis[0][0]=1;\\n        while(!q.empty()){\\n            auto t = q.top();\\n            q.pop();\\n            int x=t[1],y=t[2],z=t[0];\\n            if(t[1]==n-1 && t[2]==m-1) return -t[0];\\n            if(-t[0] > 1e5+7) return -1;\\n            int rr=0;\\n             for(int i=0;i<4;i++){\\n                int u=x+dx[i];\\n                int v=y+dy[i];\\n              if(u>=0 && u<n && v>=0 && v<m && -t[0] >= grid[u][v]){\\n                  rr=1;break;\\n              }\\n             }\\n            \\n            \\n            for(int i=0;i<4;i++){\\n                int u=x+dx[i];\\n                int v=y+dy[i];\\n                if(u>=0 && u<n && v>=0 && v<m && vis[u][v]== 0){\\n                    if(grid[u][v]<=-t[0]+1)\\n                    q.push({t[0]-1,u,v});\\n                    else if(rr){\\n                        int tt = grid[u][v]-1+t[0];\\n                        if(tt%2) tt = grid[u][v] + 1;\\n                        else tt=grid[u][v];\\n                        q.push({-tt,u,v});\\n                    }\\n                    vis[u][v]=1;\\n                }\\n            }\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int dx[4]={1,0,-1,0};\\n        int dy[4]={0,1,0,-1};\\n        priority_queue<vector<int>> q;\\n        q.push({0,0,0});\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>> vis(n,vector<int> (m,0));\\n        vis[0][0]=1;\\n        while(!q.empty()){\\n            auto t = q.top();\\n            q.pop();\\n            int x=t[1],y=t[2],z=t[0];\\n            if(t[1]==n-1 && t[2]==m-1) return -t[0];\\n            if(-t[0] > 1e5+7) return -1;\\n            int rr=0;\\n             for(int i=0;i<4;i++){\\n                int u=x+dx[i];\\n                int v=y+dy[i];\\n              if(u>=0 && u<n && v>=0 && v<m && -t[0] >= grid[u][v]){\\n                  rr=1;break;\\n              }\\n             }\\n            \\n            \\n            for(int i=0;i<4;i++){\\n                int u=x+dx[i];\\n                int v=y+dy[i];\\n                if(u>=0 && u<n && v>=0 && v<m && vis[u][v]== 0){\\n                    if(grid[u][v]<=-t[0]+1)\\n                    q.push({t[0]-1,u,v});\\n                    else if(rr){\\n                        int tt = grid[u][v]-1+t[0];\\n                        if(tt%2) tt = grid[u][v] + 1;\\n                        else tt=grid[u][v];\\n                        q.push({-tt,u,v});\\n                    }\\n                    vis[u][v]=1;\\n                }\\n            }\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231237,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\n#define vi(x) vector<x>\\n\\nclass cmp{\\n    public:\\n    bool operator()(const vi(ll)&a, const vi(ll)&b){\\n        return (a[2]>b[2]);\\n    }\\n};\\n\\nint minimumTime(vector<vector<int>>&v) {\\n    if(v[0][1]>1 && v[1][0]>1){\\n        return -1;\\n    }\\n    ll m=v.size(), n=v[0].size();\\n    vi(vi(ll))dirs={{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\\n    vi(vi(bool))vis(m, vi(bool)(n, 0));\\n    priority_queue<vi(ll), vi(vi(ll)), cmp>pq;\\n    pq.push({0, 0, 0});\\n    vis[0][0]=1;\\n    while(!pq.empty()){\\n        vi(ll)it=pq.top();\\n        pq.pop();\\n        if(it[0]==m-1 && it[1]==n-1){\\n            return it[2];\\n        }\\n        for(const vi(ll)&dir:dirs){\\n            ll x=it[0]+dir[0], y=it[1]+dir[1];\\n            if(x<0 || y<0 || x>=m || y>=n || vis[x][y]){\\n                continue;\\n            }\\n            vis[x][y]=1;\\n            if(it[2]+1>=v[x][y]){\\n                pq.push({x, y, it[2]+1});\\n            }\\n            else{\\n                bool inc=!((v[x][y]-it[2])&1);\\n                pq.push({x, y, v[x][y]+inc});\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\n#define vi(x) vector<x>\\n\\nclass cmp{\\n    public:\\n    bool operator()(const vi(ll)&a, const vi(ll)&b){\\n        return (a[2]>b[2]);\\n    }\\n};\\n\\nint minimumTime(vector<vector<int>>&v) {\\n    if(v[0][1]>1 && v[1][0]>1){\\n        return -1;\\n    }\\n    ll m=v.size(), n=v[0].size();\\n    vi(vi(ll))dirs={{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\\n    vi(vi(bool))vis(m, vi(bool)(n, 0));\\n    priority_queue<vi(ll), vi(vi(ll)), cmp>pq;\\n    pq.push({0, 0, 0});\\n    vis[0][0]=1;\\n    while(!pq.empty()){\\n        vi(ll)it=pq.top();\\n        pq.pop();\\n        if(it[0]==m-1 && it[1]==n-1){\\n            return it[2];\\n        }\\n        for(const vi(ll)&dir:dirs){\\n            ll x=it[0]+dir[0], y=it[1]+dir[1];\\n            if(x<0 || y<0 || x>=m || y>=n || vis[x][y]){\\n                continue;\\n            }\\n            vis[x][y]=1;\\n            if(it[2]+1>=v[x][y]){\\n                pq.push({x, y, it[2]+1});\\n            }\\n            else{\\n                bool inc=!((v[x][y]-it[2])&1);\\n                pq.push({x, y, v[x][y]+inc});\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231225,
                "title": "dijkstra-algo-priority-queue-bfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(grid[0][1]>1 && grid[1][0]>1)return -1;//to check if we can move forward or not\\n        \\n        vector<vector<int>> vis(n,vector<int> (m,0));\\nvis[0][0]=1;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;//so that only mininmum path is accessed\\n        pq.push({0,{0,0}});\\n        int delcol[]={-1,0,1,0};//for adjecent cells\\n        int delrow[]={0,1,0,-1};\\n        while(!pq.empty()){\\n            int steps=pq.top().first;\\n            int currRow=pq.top().second.first;\\n             int currCol=pq.top().second.second;\\n            pq.pop();\\n            if(currRow==n-1 && currCol==m-1) return steps;\\n            for(int i=0;i<4;i++){\\n                int nrow=currRow+delrow[i];\\n                int ncol=currCol+delcol[i];\\n                if(nrow>=0 && nrow<n && ncol>=0 && ncol<m &&!vis[nrow][ncol]){\\n                    if(grid[nrow][ncol]<=steps+1){\\n                        pq.push({steps+1,{nrow,ncol}});  \\n                    }\\n                    else{\\n                        int diff=grid[nrow][ncol]-steps;\\n//for next step\\n                        if(diff%2==0)pq.push({grid[nrow][ncol]+1,{nrow,ncol}});\\n                        else pq.push({grid[nrow][ncol],{nrow,ncol}});\\n                    }\\n                vis[nrow][ncol]=1;\\n                }\\n            }\\n\\n        }\\n        return -1;\\n//please upvote if found helpful;)\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(grid[0][1]>1 && grid[1][0]>1)return -1;//to check if we can move forward or not\\n        \\n        vector<vector<int>> vis(n,vector<int> (m,0));\\nvis[0][0]=1;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;//so that only mininmum path is accessed\\n        pq.push({0,{0,0}});\\n        int delcol[]={-1,0,1,0};//for adjecent cells\\n        int delrow[]={0,1,0,-1};\\n        while(!pq.empty()){\\n            int steps=pq.top().first;\\n            int currRow=pq.top().second.first;\\n             int currCol=pq.top().second.second;\\n            pq.pop();\\n            if(currRow==n-1 && currCol==m-1) return steps;\\n            for(int i=0;i<4;i++){\\n                int nrow=currRow+delrow[i];\\n                int ncol=currCol+delcol[i];\\n                if(nrow>=0 && nrow<n && ncol>=0 && ncol<m &&!vis[nrow][ncol]){\\n                    if(grid[nrow][ncol]<=steps+1){\\n                        pq.push({steps+1,{nrow,ncol}});  \\n                    }\\n                    else{\\n                        int diff=grid[nrow][ncol]-steps;\\n//for next step\\n                        if(diff%2==0)pq.push({grid[nrow][ncol]+1,{nrow,ncol}});\\n                        else pq.push({grid[nrow][ncol],{nrow,ncol}});\\n                    }\\n                vis[nrow][ncol]=1;\\n                }\\n            }\\n\\n        }\\n        return -1;\\n//please upvote if found helpful;)\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231222,
                "title": "simple-bfs-priority-queue-c",
                "content": "\\n\\n# Code\\n```\\n#define v vector<int>\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n      \\n       if(grid[0][1]>1 && grid[1][0]>1) return -1 ;// only condition where we can\\'t reach the last cell \\n        \\n        priority_queue<v,vector<v>,greater<v>>q; \\n        \\n        q.push({0,0,0}) ;\\n        int n=grid.size();\\n        int m=grid[0].size() ; \\n        vector<vector<int>>vis(n,vector<int>(m,0)) ;\\n        int R[]={0,0,1,-1};\\n        int C[]={1,-1,0,0} ; \\n        \\n        vis[0][0]=1;\\n      \\n        while(!q.empty()){\\n          \\n            auto x=q.top();\\n            q.pop() ;\\n            \\n               int t=x[0] ;\\n               int i=x[1];\\n               int j=x[2] ; \\n              // cout<<i<<\" \"<<j<<\" \"<<t<<\"\\\\n\";\\n            \\n             if(i==n-1 && j==m-1){\\n                  return t;\\n             }\\n             vis[i][j]=1;\\n            \\n             for(int k=0;k<4;k++){\\n                 \\n                  int r=i+R[k] ;\\n                  int c=j+C[k] ;\\n                 \\n                 if(r>=0 && c>=0 && r<n && c<m && !vis[r][c]){\\n                     if(grid[r][c]<=t+1)\\n                      q.push({t+1,r,c}) ;\\n                     else{\\n                          int rr=grid[r][c]-t ;\\n                       \\n                          if(rr%2){\\n                             q.push({grid[r][c],r,c}) ;  \\n                          }        \\n                         else\\n                            q.push({grid[r][c]+1,r,c}) ;      \\n                         \\n                     }\\n                       vis[r][c]=1;\\n                 }\\n                 \\n             }\\n            \\n        }\\n        return 0; // never reach here\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define v vector<int>\\nclass Solution {\\npublic:\\n    int minimumTime(vector<vector<int>>& grid) {\\n      \\n       if(grid[0][1]>1 && grid[1][0]>1) return -1 ;// only condition where we can\\'t reach the last cell \\n        \\n        priority_queue<v,vector<v>,greater<v>>q; \\n        \\n        q.push({0,0,0}) ;\\n        int n=grid.size();\\n        int m=grid[0].size() ; \\n        vector<vector<int>>vis(n,vector<int>(m,0)) ;\\n        int R[]={0,0,1,-1};\\n        int C[]={1,-1,0,0} ; \\n        \\n        vis[0][0]=1;\\n      \\n        while(!q.empty()){\\n          \\n            auto x=q.top();\\n            q.pop() ;\\n            \\n               int t=x[0] ;\\n               int i=x[1];\\n               int j=x[2] ; \\n              // cout<<i<<\" \"<<j<<\" \"<<t<<\"\\\\n\";\\n            \\n             if(i==n-1 && j==m-1){\\n                  return t;\\n             }\\n             vis[i][j]=1;\\n            \\n             for(int k=0;k<4;k++){\\n                 \\n                  int r=i+R[k] ;\\n                  int c=j+C[k] ;\\n                 \\n                 if(r>=0 && c>=0 && r<n && c<m && !vis[r][c]){\\n                     if(grid[r][c]<=t+1)\\n                      q.push({t+1,r,c}) ;\\n                     else{\\n                          int rr=grid[r][c]-t ;\\n                       \\n                          if(rr%2){\\n                             q.push({grid[r][c],r,c}) ;  \\n                          }        \\n                         else\\n                            q.push({grid[r][c]+1,r,c}) ;      \\n                         \\n                     }\\n                       vis[r][c]=1;\\n                 }\\n                 \\n             }\\n            \\n        }\\n        return 0; // never reach here\\n         \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3231218,
                "title": "python-o-n-m-log-n-m-time-o-n-m-space",
                "content": "# Complexity\\n- Time complexity: $$O(n*m*log(n*m))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        if grid[0][1] > 1 and grid[1][0] > 1:\\n            return -1\\n        visited = set()\\n        visited.add((0,0))\\n        heap = [(0,0,0)]\\n        moves = ((-1,0),(1,0),(0,-1),(0,1))\\n        while heap:\\n            node = heappop(heap)\\n            time = node[0]\\n            r = node[1]\\n            c = node[2]\\n            if r == n-1 and c == m-1:\\n                return time\\n            for x,y in moves:\\n                row = r+x\\n                col = c+y\\n                if 0<=row<n and 0<=col<m and (row,col) not in visited:\\n                    visited.add((row,col))\\n                    if grid[row][col] <= node[0]:\\n                        heappush(heap,(time+1,row,col))\\n                    elif (grid[row][col] - node[0]) % 2 == 0:\\n                        heappush(heap,(grid[row][col]+1,row,col))\\n                    else:\\n                        heappush(heap,(grid[row][col],row,col))\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```python []\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        if grid[0][1] > 1 and grid[1][0] > 1:\\n            return -1\\n        visited = set()\\n        visited.add((0,0))\\n        heap = [(0,0,0)]\\n        moves = ((-1,0),(1,0),(0,-1),(0,1))\\n        while heap:\\n            node = heappop(heap)\\n            time = node[0]\\n            r = node[1]\\n            c = node[2]\\n            if r == n-1 and c == m-1:\\n                return time\\n            for x,y in moves:\\n                row = r+x\\n                col = c+y\\n                if 0<=row<n and 0<=col<m and (row,col) not in visited:\\n                    visited.add((row,col))\\n                    if grid[row][col] <= node[0]:\\n                        heappush(heap,(time+1,row,col))\\n                    elif (grid[row][col] - node[0]) % 2 == 0:\\n                        heappush(heap,(grid[row][col]+1,row,col))\\n                    else:\\n                        heappush(heap,(grid[row][col],row,col))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231200,
                "title": "my-solution",
                "content": "```\\nclass Solution {\\n public:\\n  int minimumTime(const vector<vector<int>> &grid) {\\n    using node_t = tuple<int, int, int>;   // {the row, the column, the time consumed}\\n    constexpr int i_row = 0;\\n    constexpr int i_col = 1;\\n    constexpr int i_time = 2;\\n    constexpr int directions[] = {0, 1, 0, -1, 0};\\n    constexpr int n_directions = 4;\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    \\n    unsigned int consumed_time[rows][cols];\\n    memset(consumed_time, -1, sizeof(consumed_time));\\n    consumed_time[0][0] = 0;\\n    auto compare = [](const node_t &lhs, const node_t &rhs) -> bool {\\n      return !(get<i_time>(lhs) < get<i_time>(rhs));\\n    };\\n    priority_queue<node_t, vector<node_t>, decltype(compare)> pq(compare);\\n    pq.emplace(0, 0, 0);\\n    while (!pq.empty()) {\\n      const auto [r, c, t] = pq.top();\\n      pq.pop();\\n      if (r == rows - 1 && c == cols - 1) {\\n        return t;\\n      }\\n      for (int d = 0; d < n_directions; ++d) {\\n        const int nr = r + directions[d];\\n        const int nc = c + directions[d + 1];\\n        if (nr < 0 || nr >= rows || nc < 0 || nc >= cols) {\\n          continue;\\n        }\\n        if (r == 0 && c == 0 && grid[nr][nc] > 1) {\\n          continue;\\n        }\\n        const int nt = grid[nr][nc] > t + 1 ? t + 1 + (grid[nr][nc] - t) / 2 * 2 : t + 1;\\n        if (nt < consumed_time[nr][nc]) {\\n          consumed_time[nr][nc] = nt;\\n          pq.emplace(nr, nc, nt);\\n        }\\n      }\\n    }\\n    return -1;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  int minimumTime(const vector<vector<int>> &grid) {\\n    using node_t = tuple<int, int, int>;   // {the row, the column, the time consumed}\\n    constexpr int i_row = 0;\\n    constexpr int i_col = 1;\\n    constexpr int i_time = 2;\\n    constexpr int directions[] = {0, 1, 0, -1, 0};\\n    constexpr int n_directions = 4;\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    \\n    unsigned int consumed_time[rows][cols];\\n    memset(consumed_time, -1, sizeof(consumed_time));\\n    consumed_time[0][0] = 0;\\n    auto compare = [](const node_t &lhs, const node_t &rhs) -> bool {\\n      return !(get<i_time>(lhs) < get<i_time>(rhs));\\n    };\\n    priority_queue<node_t, vector<node_t>, decltype(compare)> pq(compare);\\n    pq.emplace(0, 0, 0);\\n    while (!pq.empty()) {\\n      const auto [r, c, t] = pq.top();\\n      pq.pop();\\n      if (r == rows - 1 && c == cols - 1) {\\n        return t;\\n      }\\n      for (int d = 0; d < n_directions; ++d) {\\n        const int nr = r + directions[d];\\n        const int nc = c + directions[d + 1];\\n        if (nr < 0 || nr >= rows || nc < 0 || nc >= cols) {\\n          continue;\\n        }\\n        if (r == 0 && c == 0 && grid[nr][nc] > 1) {\\n          continue;\\n        }\\n        const int nt = grid[nr][nc] > t + 1 ? t + 1 + (grid[nr][nc] - t) / 2 * 2 : t + 1;\\n        if (nt < consumed_time[nr][nc]) {\\n          consumed_time[nr][nc] = nt;\\n          pq.emplace(nr, nc, nt);\\n        }\\n      }\\n    }\\n    return -1;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231168,
                "title": "simple-java-solution-with-explanation-using-priority-queue",
                "content": "# Approach\\nUsing Prioity Queue ( Modified Dijsktra). \\n\\n\\n# Code\\n```\\nclass Solution {\\n    private int[]dx = new int[]{-1,0,1,0}; // change in rows\\n    private int[] dy = new int[]{0,1,0,-1}; // change in cols\\n    public int minimumTime(int[][] grid) {\\n        //if both 0,1 & 1,0 not reachable we cannot got further\\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\\n            return -1;\\n        }\\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);//heapify based on time\\n        pq.offer(new int[] { 0, 0, 0 }); // storing i,j, time=> row, col, time starting with 0;\\n        \\n        boolean[][] visited = new boolean[m][n];\\n        \\n        while (!pq.isEmpty()) {\\n            int[] temp = pq.poll();\\n            int row = temp[0];\\n            int col = temp[1];\\n            int time = temp[2];\\n            if (row == m - 1 && col == n - 1) {\\n                return time;\\n            }\\n            if (visited[row][col]) {\\n                continue;\\n            }\\n            visited[row][col] = true;\\n            for(int i=0;i<4;i++){ // moving 4 directions\\n                int r = row + dx[i];\\n                int c = col + dy[i];\\n                if (r < 0 || r == m || c < 0 || c == n || visited[r][c]) continue;//if out of bound or repetitive cell\\n                //if neighbour distance is less than time we can go there\\n                if (grid[r][c] <= time + 1)pq.offer(new int[] { r, c, time + 1 });\\n                else {\\n                    // here is the trick we can do some timepass i.e we can elapse time by going back to previous cell\\n                   // and come back after few seconds so that needed time has been elapsed;\\n\\n                    //if the (current time - time we need i.e grid[r][c]) is even,\\n\\n                    //then we come back from previous to new column with 1 sec delay\\n                    // suppose t=2 when i am at point \\'b\\' and grid[r][c] = 4 i.e to go to point \\'c\\' i need 4 secs\\n                    // we go one step back to point \\'a\\', t=3 come back to current step (\\'b\\') t=4 \\n                    //then for going to new cell i.e pont \\'c\\' it will take another 1 sec it becomes 5;\\n\\n                    // if it is odd we arrive on time\\n                    int diff = grid[r][c] - time;\\n                    if (diff % 2 == 1) {\\n                        pq.offer(new int[] { r, c, grid[r][c] }); // on time\\n                    } else {\\n                        pq.offer(new int[] { r, c, grid[r][c] + 1 });//1 sec late\\n                    }\\n                }\\n            }\\n        }\\n        return -1; // if we can reach  n,m coordinates\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int[]dx = new int[]{-1,0,1,0}; // change in rows\\n    private int[] dy = new int[]{0,1,0,-1}; // change in cols\\n    public int minimumTime(int[][] grid) {\\n        //if both 0,1 & 1,0 not reachable we cannot got further\\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\\n            return -1;\\n        }\\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);//heapify based on time\\n        pq.offer(new int[] { 0, 0, 0 }); // storing i,j, time=> row, col, time starting with 0;\\n        \\n        boolean[][] visited = new boolean[m][n];\\n        \\n        while (!pq.isEmpty()) {\\n            int[] temp = pq.poll();\\n            int row = temp[0];\\n            int col = temp[1];\\n            int time = temp[2];\\n            if (row == m - 1 && col == n - 1) {\\n                return time;\\n            }\\n            if (visited[row][col]) {\\n                continue;\\n            }\\n            visited[row][col] = true;\\n            for(int i=0;i<4;i++){ // moving 4 directions\\n                int r = row + dx[i];\\n                int c = col + dy[i];\\n                if (r < 0 || r == m || c < 0 || c == n || visited[r][c]) continue;//if out of bound or repetitive cell\\n                //if neighbour distance is less than time we can go there\\n                if (grid[r][c] <= time + 1)pq.offer(new int[] { r, c, time + 1 });\\n                else {\\n                    // here is the trick we can do some timepass i.e we can elapse time by going back to previous cell\\n                   // and come back after few seconds so that needed time has been elapsed;\\n\\n                    //if the (current time - time we need i.e grid[r][c]) is even,\\n\\n                    //then we come back from previous to new column with 1 sec delay\\n                    // suppose t=2 when i am at point \\'b\\' and grid[r][c] = 4 i.e to go to point \\'c\\' i need 4 secs\\n                    // we go one step back to point \\'a\\', t=3 come back to current step (\\'b\\') t=4 \\n                    //then for going to new cell i.e pont \\'c\\' it will take another 1 sec it becomes 5;\\n\\n                    // if it is odd we arrive on time\\n                    int diff = grid[r][c] - time;\\n                    if (diff % 2 == 1) {\\n                        pq.offer(new int[] { r, c, grid[r][c] }); // on time\\n                    } else {\\n                        pq.offer(new int[] { r, c, grid[r][c] + 1 });//1 sec late\\n                    }\\n                }\\n            }\\n        }\\n        return -1; // if we can reach  n,m coordinates\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231139,
                "title": "python3-custom-priorityqueue-solution",
                "content": "Custom Priority Queue was borrowed from stackoverflow\\nhttps://stackoverflow.com/questions/23735563/python-how-to-sort-priority-queue-by-second-argument\\n\\n# Code\\n```\\nfrom queue import PriorityQueue\\n\\nclass CustomPriorityQueue(PriorityQueue):\\n    def _put(self, item):\\n        return super()._put((self._get_priority(item), item))\\n\\n    def _get(self):\\n        return super()._get()[1]\\n\\n    # Sort by time\\n    def _get_priority(self, item):\\n        return item[2]\\n\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        rDir = [-1, 0, 1, 0]\\n        cDir = [0, 1, 0, -1]\\n        \\n        q = CustomPriorityQueue()\\n        q.put([0,0,0])\\n\\n        minDist = [[float(\\'inf\\') for j in range(n)] for i in range(m)]\\n        minDist[0][0] = 0\\n        \\n        if grid[0][1] > 1 and grid[1][0] > 1: return -1\\n        \\n        while q.qsize()>0:\\n            cur = q.get()\\n            r = cur[0]\\n            c = cur[1]\\n            t = cur[2]\\n\\n            if r==m-1 and c==n-1:\\n                return t\\n            \\n            for i in range(4):\\n                nR = r+rDir[i]\\n                nC = c+cDir[i]\\n                nT = t+1\\n                \\n                if nR<0 or nR>=m or nC<0 or nC>=n: continue\\n                \\n                if nT < grid[nR][nC]:\\n                    diff = grid[nR][nC]-nT\\n                    if diff % 2 == 1:\\n                        diff += 1\\n                    nT += diff\\n\\n                if nT>=minDist[nR][nC]:\\n                    continue\\n                minDist[nR][nC] = nT\\n                \\n                entry = [nR, nC, nT]\\n                q.put(entry)\\n                    \\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom queue import PriorityQueue\\n\\nclass CustomPriorityQueue(PriorityQueue):\\n    def _put(self, item):\\n        return super()._put((self._get_priority(item), item))\\n\\n    def _get(self):\\n        return super()._get()[1]\\n\\n    # Sort by time\\n    def _get_priority(self, item):\\n        return item[2]\\n\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        rDir = [-1, 0, 1, 0]\\n        cDir = [0, 1, 0, -1]\\n        \\n        q = CustomPriorityQueue()\\n        q.put([0,0,0])\\n\\n        minDist = [[float(\\'inf\\') for j in range(n)] for i in range(m)]\\n        minDist[0][0] = 0\\n        \\n        if grid[0][1] > 1 and grid[1][0] > 1: return -1\\n        \\n        while q.qsize()>0:\\n            cur = q.get()\\n            r = cur[0]\\n            c = cur[1]\\n            t = cur[2]\\n\\n            if r==m-1 and c==n-1:\\n                return t\\n            \\n            for i in range(4):\\n                nR = r+rDir[i]\\n                nC = c+cDir[i]\\n                nT = t+1\\n                \\n                if nR<0 or nR>=m or nC<0 or nC>=n: continue\\n                \\n                if nT < grid[nR][nC]:\\n                    diff = grid[nR][nC]-nT\\n                    if diff % 2 == 1:\\n                        diff += 1\\n                    nT += diff\\n\\n                if nT>=minDist[nR][nC]:\\n                    continue\\n                minDist[nR][nC] = nT\\n                \\n                entry = [nR, nC, nT]\\n                q.put(entry)\\n                    \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231126,
                "title": "python-dijkstra",
                "content": "****\\n***Intution***\\n*when you are not stuck in the first cell , you can buy time by going back and fourth\\n*\\n```\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        pq = [(0,0,0)]\\n        n,m = len(grid[0]), len(grid)\\n\\n        dist = [[inf] * n for _ in range(m)]\\n        while pq:\\n            t , i , j = heappop(pq)\\n            if i == m-1 and j == n-1:\\n                return t\\n\\n            for x,y in [[1,0],[0,1],[-1,0],[0,-1]]:\\n                nx, ny = i + x, j + y\\n                if 0 <= nx < m and 0 <= ny < n:\\n                    if dist[nx][ny] == inf :\\n                        if grid[nx][ny] > (t+1):\\n                            if i == 0 and j == 0:\\n                                continue\\n                            dist[nx][ny] = (grid[nx][ny]-(t)) + (t) + ((grid[nx][ny]-(t)) % 2 == 0)\\n                        else:\\n                            dist[nx][ny] = (t+1)\\n                        heappush(pq,(dist[nx][ny],nx, ny))\\n        return -1\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, grid: List[List[int]]) -> int:\\n        pq = [(0,0,0)]\\n        n,m = len(grid[0]), len(grid)\\n\\n        dist = [[inf] * n for _ in range(m)]\\n        while pq:\\n            t , i , j = heappop(pq)\\n            if i == m-1 and j == n-1:\\n                return t\\n\\n            for x,y in [[1,0],[0,1],[-1,0],[0,-1]]:\\n                nx, ny = i + x, j + y\\n                if 0 <= nx < m and 0 <= ny < n:\\n                    if dist[nx][ny] == inf :\\n                        if grid[nx][ny] > (t+1):\\n                            if i == 0 and j == 0:\\n                                continue\\n                            dist[nx][ny] = (grid[nx][ny]-(t)) + (t) + ((grid[nx][ny]-(t)) % 2 == 0)\\n                        else:\\n                            dist[nx][ny] = (t+1)\\n                        heappush(pq,(dist[nx][ny],nx, ny))\\n        return -1\\n\\t\\t```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1820792,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "it should have been mentioned that staying static is not allowed!!!"
                    },
                    {
                        "username": "amitnehra060",
                        "content": "It is clear from 2nd example"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "I feel like the curx of this problem is to realise the fact that time only passes when you make a move. This is why when the neighboring cells have a value larger than currTime + 1, you have to alternately between current and previously visited position in order to pass the time. This is not as simple as waiting at the current position to wait for the time to automatically pass. You would have to move."
                    },
                    {
                        "username": "gautamsw5",
                        "content": "This should be mentioned in the description"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "What is wrong with my DFS solution? I\\'m getting stack overflow error when I can\\'t find any possible error in my solution:---\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int f(int i,int j,int time,vector<vector<int>>& grid){\\n        if(i==grid.size()-1 and j==grid[0].size()-1 and grid[i][j]<=time)return time;\\n        if(i>=grid.size() or j>=grid[0].size() or j<0 or i<0)return 1e9;\\n        \\n        int d=1e9,u=1e9,r=1e9,l=1e9;\\n        \\n        if(i+1<grid.size() and grid[i+1][j]<=time+1)\\n            d=f(i+1,j,time+1,grid);\\n        if(i-1>=0 and grid[i-1][j]<=time+1)\\n            u=f(i-1,j,time+1,grid);\\n        if(j+1<grid[0].size() and grid[i][j+1]<=time+1)\\n            r=f(i,j+1,time+1,grid);\\n        if(j-1>=0 and grid[i][j-1]<=time+1)\\n            l=f(i,j-1,time+1,grid);\\n        \\n        \\n        if(l==1e9 and r==1e9 and u==1e9 and d==1e9)return 1e9;\\n        \\n        return min({l,u,d,r}); \\n    }\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int time=0;\\n        int res= f(0,0,time,grid);\\n        if(res==1e9)return -1;\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "binayKr",
                        "content": "[@SuryaTejaswi2504](/SuryaTejaswi2504) maybe because the problem says you to find the minimum time, but in DFS you might end up getting all the solutions and then comparing all the answers to one another to get the minimum of all.\nWhereas in BFS, we step by step move ahead in all directions simultaneously and the moment we get our condition fulfilled, we just return it right there, instead of looking for each and every solutions.\nhence in graph problems, my own intuition on whenever i am supposed to get the minimum values (let it be anything e.g. time or distance), I try to apply BFS approach and Dijkstra is nothing but a BFS algorithm."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "- About the DFS, unless I am mistaken (I only use Python and Rust so I am not 100% sure), it seems that you do not mark cells you have already visited so you will have issues with infinite recursion.\\n\\n- About the stack overflow, irrespective of the infinite recursion issue, you can see in the constraints that m * n can reach 10^5. Each recursive call consumes at least 4 bytes (for i) + 4 bytes (for j) + 4 bytes (for t) + 8 bytes (for the return address, I assume that leetcode uses 64-bits) so you might need up to 2 MB of memory in the stack which might be too much on some systems."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Extension to this problem:\\nInstead of shuffling back and forth taking 2 seconds, what if a wait cycle takes variable number of seconds? Supposed some cells force you to stay there for multiple seconds or something. Can Dijistra still be easily applied? Would there be a need to track prime number wait cycles to avoid the wasted seconds? "
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Why can\\'t I do this using simple bfs , with same logic? "
                    },
                    {
                        "username": "Hegwin",
                        "content": "Using Dijkstra in Ruby got a TLE"
                    }
                ]
            },
            {
                "id": 1816308,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "it should have been mentioned that staying static is not allowed!!!"
                    },
                    {
                        "username": "amitnehra060",
                        "content": "It is clear from 2nd example"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "I feel like the curx of this problem is to realise the fact that time only passes when you make a move. This is why when the neighboring cells have a value larger than currTime + 1, you have to alternately between current and previously visited position in order to pass the time. This is not as simple as waiting at the current position to wait for the time to automatically pass. You would have to move."
                    },
                    {
                        "username": "gautamsw5",
                        "content": "This should be mentioned in the description"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "What is wrong with my DFS solution? I\\'m getting stack overflow error when I can\\'t find any possible error in my solution:---\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int f(int i,int j,int time,vector<vector<int>>& grid){\\n        if(i==grid.size()-1 and j==grid[0].size()-1 and grid[i][j]<=time)return time;\\n        if(i>=grid.size() or j>=grid[0].size() or j<0 or i<0)return 1e9;\\n        \\n        int d=1e9,u=1e9,r=1e9,l=1e9;\\n        \\n        if(i+1<grid.size() and grid[i+1][j]<=time+1)\\n            d=f(i+1,j,time+1,grid);\\n        if(i-1>=0 and grid[i-1][j]<=time+1)\\n            u=f(i-1,j,time+1,grid);\\n        if(j+1<grid[0].size() and grid[i][j+1]<=time+1)\\n            r=f(i,j+1,time+1,grid);\\n        if(j-1>=0 and grid[i][j-1]<=time+1)\\n            l=f(i,j-1,time+1,grid);\\n        \\n        \\n        if(l==1e9 and r==1e9 and u==1e9 and d==1e9)return 1e9;\\n        \\n        return min({l,u,d,r}); \\n    }\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int time=0;\\n        int res= f(0,0,time,grid);\\n        if(res==1e9)return -1;\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "binayKr",
                        "content": "[@SuryaTejaswi2504](/SuryaTejaswi2504) maybe because the problem says you to find the minimum time, but in DFS you might end up getting all the solutions and then comparing all the answers to one another to get the minimum of all.\nWhereas in BFS, we step by step move ahead in all directions simultaneously and the moment we get our condition fulfilled, we just return it right there, instead of looking for each and every solutions.\nhence in graph problems, my own intuition on whenever i am supposed to get the minimum values (let it be anything e.g. time or distance), I try to apply BFS approach and Dijkstra is nothing but a BFS algorithm."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "- About the DFS, unless I am mistaken (I only use Python and Rust so I am not 100% sure), it seems that you do not mark cells you have already visited so you will have issues with infinite recursion.\\n\\n- About the stack overflow, irrespective of the infinite recursion issue, you can see in the constraints that m * n can reach 10^5. Each recursive call consumes at least 4 bytes (for i) + 4 bytes (for j) + 4 bytes (for t) + 8 bytes (for the return address, I assume that leetcode uses 64-bits) so you might need up to 2 MB of memory in the stack which might be too much on some systems."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Extension to this problem:\\nInstead of shuffling back and forth taking 2 seconds, what if a wait cycle takes variable number of seconds? Supposed some cells force you to stay there for multiple seconds or something. Can Dijistra still be easily applied? Would there be a need to track prime number wait cycles to avoid the wasted seconds? "
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Why can\\'t I do this using simple bfs , with same logic? "
                    },
                    {
                        "username": "Hegwin",
                        "content": "Using Dijkstra in Ruby got a TLE"
                    }
                ]
            },
            {
                "id": 1815367,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "it should have been mentioned that staying static is not allowed!!!"
                    },
                    {
                        "username": "amitnehra060",
                        "content": "It is clear from 2nd example"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "I feel like the curx of this problem is to realise the fact that time only passes when you make a move. This is why when the neighboring cells have a value larger than currTime + 1, you have to alternately between current and previously visited position in order to pass the time. This is not as simple as waiting at the current position to wait for the time to automatically pass. You would have to move."
                    },
                    {
                        "username": "gautamsw5",
                        "content": "This should be mentioned in the description"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "What is wrong with my DFS solution? I\\'m getting stack overflow error when I can\\'t find any possible error in my solution:---\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int f(int i,int j,int time,vector<vector<int>>& grid){\\n        if(i==grid.size()-1 and j==grid[0].size()-1 and grid[i][j]<=time)return time;\\n        if(i>=grid.size() or j>=grid[0].size() or j<0 or i<0)return 1e9;\\n        \\n        int d=1e9,u=1e9,r=1e9,l=1e9;\\n        \\n        if(i+1<grid.size() and grid[i+1][j]<=time+1)\\n            d=f(i+1,j,time+1,grid);\\n        if(i-1>=0 and grid[i-1][j]<=time+1)\\n            u=f(i-1,j,time+1,grid);\\n        if(j+1<grid[0].size() and grid[i][j+1]<=time+1)\\n            r=f(i,j+1,time+1,grid);\\n        if(j-1>=0 and grid[i][j-1]<=time+1)\\n            l=f(i,j-1,time+1,grid);\\n        \\n        \\n        if(l==1e9 and r==1e9 and u==1e9 and d==1e9)return 1e9;\\n        \\n        return min({l,u,d,r}); \\n    }\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int time=0;\\n        int res= f(0,0,time,grid);\\n        if(res==1e9)return -1;\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "binayKr",
                        "content": "[@SuryaTejaswi2504](/SuryaTejaswi2504) maybe because the problem says you to find the minimum time, but in DFS you might end up getting all the solutions and then comparing all the answers to one another to get the minimum of all.\nWhereas in BFS, we step by step move ahead in all directions simultaneously and the moment we get our condition fulfilled, we just return it right there, instead of looking for each and every solutions.\nhence in graph problems, my own intuition on whenever i am supposed to get the minimum values (let it be anything e.g. time or distance), I try to apply BFS approach and Dijkstra is nothing but a BFS algorithm."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "- About the DFS, unless I am mistaken (I only use Python and Rust so I am not 100% sure), it seems that you do not mark cells you have already visited so you will have issues with infinite recursion.\\n\\n- About the stack overflow, irrespective of the infinite recursion issue, you can see in the constraints that m * n can reach 10^5. Each recursive call consumes at least 4 bytes (for i) + 4 bytes (for j) + 4 bytes (for t) + 8 bytes (for the return address, I assume that leetcode uses 64-bits) so you might need up to 2 MB of memory in the stack which might be too much on some systems."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Extension to this problem:\\nInstead of shuffling back and forth taking 2 seconds, what if a wait cycle takes variable number of seconds? Supposed some cells force you to stay there for multiple seconds or something. Can Dijistra still be easily applied? Would there be a need to track prime number wait cycles to avoid the wasted seconds? "
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Why can\\'t I do this using simple bfs , with same logic? "
                    },
                    {
                        "username": "Hegwin",
                        "content": "Using Dijkstra in Ruby got a TLE"
                    }
                ]
            },
            {
                "id": 1814895,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "it should have been mentioned that staying static is not allowed!!!"
                    },
                    {
                        "username": "amitnehra060",
                        "content": "It is clear from 2nd example"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "I feel like the curx of this problem is to realise the fact that time only passes when you make a move. This is why when the neighboring cells have a value larger than currTime + 1, you have to alternately between current and previously visited position in order to pass the time. This is not as simple as waiting at the current position to wait for the time to automatically pass. You would have to move."
                    },
                    {
                        "username": "gautamsw5",
                        "content": "This should be mentioned in the description"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "What is wrong with my DFS solution? I\\'m getting stack overflow error when I can\\'t find any possible error in my solution:---\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int f(int i,int j,int time,vector<vector<int>>& grid){\\n        if(i==grid.size()-1 and j==grid[0].size()-1 and grid[i][j]<=time)return time;\\n        if(i>=grid.size() or j>=grid[0].size() or j<0 or i<0)return 1e9;\\n        \\n        int d=1e9,u=1e9,r=1e9,l=1e9;\\n        \\n        if(i+1<grid.size() and grid[i+1][j]<=time+1)\\n            d=f(i+1,j,time+1,grid);\\n        if(i-1>=0 and grid[i-1][j]<=time+1)\\n            u=f(i-1,j,time+1,grid);\\n        if(j+1<grid[0].size() and grid[i][j+1]<=time+1)\\n            r=f(i,j+1,time+1,grid);\\n        if(j-1>=0 and grid[i][j-1]<=time+1)\\n            l=f(i,j-1,time+1,grid);\\n        \\n        \\n        if(l==1e9 and r==1e9 and u==1e9 and d==1e9)return 1e9;\\n        \\n        return min({l,u,d,r}); \\n    }\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int time=0;\\n        int res= f(0,0,time,grid);\\n        if(res==1e9)return -1;\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "binayKr",
                        "content": "[@SuryaTejaswi2504](/SuryaTejaswi2504) maybe because the problem says you to find the minimum time, but in DFS you might end up getting all the solutions and then comparing all the answers to one another to get the minimum of all.\nWhereas in BFS, we step by step move ahead in all directions simultaneously and the moment we get our condition fulfilled, we just return it right there, instead of looking for each and every solutions.\nhence in graph problems, my own intuition on whenever i am supposed to get the minimum values (let it be anything e.g. time or distance), I try to apply BFS approach and Dijkstra is nothing but a BFS algorithm."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "- About the DFS, unless I am mistaken (I only use Python and Rust so I am not 100% sure), it seems that you do not mark cells you have already visited so you will have issues with infinite recursion.\\n\\n- About the stack overflow, irrespective of the infinite recursion issue, you can see in the constraints that m * n can reach 10^5. Each recursive call consumes at least 4 bytes (for i) + 4 bytes (for j) + 4 bytes (for t) + 8 bytes (for the return address, I assume that leetcode uses 64-bits) so you might need up to 2 MB of memory in the stack which might be too much on some systems."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Extension to this problem:\\nInstead of shuffling back and forth taking 2 seconds, what if a wait cycle takes variable number of seconds? Supposed some cells force you to stay there for multiple seconds or something. Can Dijistra still be easily applied? Would there be a need to track prime number wait cycles to avoid the wasted seconds? "
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Why can\\'t I do this using simple bfs , with same logic? "
                    },
                    {
                        "username": "Hegwin",
                        "content": "Using Dijkstra in Ruby got a TLE"
                    }
                ]
            },
            {
                "id": 1904483,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "it should have been mentioned that staying static is not allowed!!!"
                    },
                    {
                        "username": "amitnehra060",
                        "content": "It is clear from 2nd example"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "I feel like the curx of this problem is to realise the fact that time only passes when you make a move. This is why when the neighboring cells have a value larger than currTime + 1, you have to alternately between current and previously visited position in order to pass the time. This is not as simple as waiting at the current position to wait for the time to automatically pass. You would have to move."
                    },
                    {
                        "username": "gautamsw5",
                        "content": "This should be mentioned in the description"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "What is wrong with my DFS solution? I\\'m getting stack overflow error when I can\\'t find any possible error in my solution:---\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int f(int i,int j,int time,vector<vector<int>>& grid){\\n        if(i==grid.size()-1 and j==grid[0].size()-1 and grid[i][j]<=time)return time;\\n        if(i>=grid.size() or j>=grid[0].size() or j<0 or i<0)return 1e9;\\n        \\n        int d=1e9,u=1e9,r=1e9,l=1e9;\\n        \\n        if(i+1<grid.size() and grid[i+1][j]<=time+1)\\n            d=f(i+1,j,time+1,grid);\\n        if(i-1>=0 and grid[i-1][j]<=time+1)\\n            u=f(i-1,j,time+1,grid);\\n        if(j+1<grid[0].size() and grid[i][j+1]<=time+1)\\n            r=f(i,j+1,time+1,grid);\\n        if(j-1>=0 and grid[i][j-1]<=time+1)\\n            l=f(i,j-1,time+1,grid);\\n        \\n        \\n        if(l==1e9 and r==1e9 and u==1e9 and d==1e9)return 1e9;\\n        \\n        return min({l,u,d,r}); \\n    }\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int time=0;\\n        int res= f(0,0,time,grid);\\n        if(res==1e9)return -1;\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "binayKr",
                        "content": "[@SuryaTejaswi2504](/SuryaTejaswi2504) maybe because the problem says you to find the minimum time, but in DFS you might end up getting all the solutions and then comparing all the answers to one another to get the minimum of all.\nWhereas in BFS, we step by step move ahead in all directions simultaneously and the moment we get our condition fulfilled, we just return it right there, instead of looking for each and every solutions.\nhence in graph problems, my own intuition on whenever i am supposed to get the minimum values (let it be anything e.g. time or distance), I try to apply BFS approach and Dijkstra is nothing but a BFS algorithm."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "- About the DFS, unless I am mistaken (I only use Python and Rust so I am not 100% sure), it seems that you do not mark cells you have already visited so you will have issues with infinite recursion.\\n\\n- About the stack overflow, irrespective of the infinite recursion issue, you can see in the constraints that m * n can reach 10^5. Each recursive call consumes at least 4 bytes (for i) + 4 bytes (for j) + 4 bytes (for t) + 8 bytes (for the return address, I assume that leetcode uses 64-bits) so you might need up to 2 MB of memory in the stack which might be too much on some systems."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Extension to this problem:\\nInstead of shuffling back and forth taking 2 seconds, what if a wait cycle takes variable number of seconds? Supposed some cells force you to stay there for multiple seconds or something. Can Dijistra still be easily applied? Would there be a need to track prime number wait cycles to avoid the wasted seconds? "
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Why can\\'t I do this using simple bfs , with same logic? "
                    },
                    {
                        "username": "Hegwin",
                        "content": "Using Dijkstra in Ruby got a TLE"
                    }
                ]
            },
            {
                "id": 1815562,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "it should have been mentioned that staying static is not allowed!!!"
                    },
                    {
                        "username": "amitnehra060",
                        "content": "It is clear from 2nd example"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "I feel like the curx of this problem is to realise the fact that time only passes when you make a move. This is why when the neighboring cells have a value larger than currTime + 1, you have to alternately between current and previously visited position in order to pass the time. This is not as simple as waiting at the current position to wait for the time to automatically pass. You would have to move."
                    },
                    {
                        "username": "gautamsw5",
                        "content": "This should be mentioned in the description"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "What is wrong with my DFS solution? I\\'m getting stack overflow error when I can\\'t find any possible error in my solution:---\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int f(int i,int j,int time,vector<vector<int>>& grid){\\n        if(i==grid.size()-1 and j==grid[0].size()-1 and grid[i][j]<=time)return time;\\n        if(i>=grid.size() or j>=grid[0].size() or j<0 or i<0)return 1e9;\\n        \\n        int d=1e9,u=1e9,r=1e9,l=1e9;\\n        \\n        if(i+1<grid.size() and grid[i+1][j]<=time+1)\\n            d=f(i+1,j,time+1,grid);\\n        if(i-1>=0 and grid[i-1][j]<=time+1)\\n            u=f(i-1,j,time+1,grid);\\n        if(j+1<grid[0].size() and grid[i][j+1]<=time+1)\\n            r=f(i,j+1,time+1,grid);\\n        if(j-1>=0 and grid[i][j-1]<=time+1)\\n            l=f(i,j-1,time+1,grid);\\n        \\n        \\n        if(l==1e9 and r==1e9 and u==1e9 and d==1e9)return 1e9;\\n        \\n        return min({l,u,d,r}); \\n    }\\n    int minimumTime(vector<vector<int>>& grid) {\\n        int time=0;\\n        int res= f(0,0,time,grid);\\n        if(res==1e9)return -1;\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "binayKr",
                        "content": "[@SuryaTejaswi2504](/SuryaTejaswi2504) maybe because the problem says you to find the minimum time, but in DFS you might end up getting all the solutions and then comparing all the answers to one another to get the minimum of all.\nWhereas in BFS, we step by step move ahead in all directions simultaneously and the moment we get our condition fulfilled, we just return it right there, instead of looking for each and every solutions.\nhence in graph problems, my own intuition on whenever i am supposed to get the minimum values (let it be anything e.g. time or distance), I try to apply BFS approach and Dijkstra is nothing but a BFS algorithm."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "- About the DFS, unless I am mistaken (I only use Python and Rust so I am not 100% sure), it seems that you do not mark cells you have already visited so you will have issues with infinite recursion.\\n\\n- About the stack overflow, irrespective of the infinite recursion issue, you can see in the constraints that m * n can reach 10^5. Each recursive call consumes at least 4 bytes (for i) + 4 bytes (for j) + 4 bytes (for t) + 8 bytes (for the return address, I assume that leetcode uses 64-bits) so you might need up to 2 MB of memory in the stack which might be too much on some systems."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Extension to this problem:\\nInstead of shuffling back and forth taking 2 seconds, what if a wait cycle takes variable number of seconds? Supposed some cells force you to stay there for multiple seconds or something. Can Dijistra still be easily applied? Would there be a need to track prime number wait cycles to avoid the wasted seconds? "
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Why can\\'t I do this using simple bfs , with same logic? "
                    },
                    {
                        "username": "Hegwin",
                        "content": "Using Dijkstra in Ruby got a TLE"
                    }
                ]
            }
        ]
    }
]