[
    {
        "title": "Friends Of Appropriate Ages",
        "question_content": "There are n persons on a social media website. You are given an integer array ages where ages[i] is the age of the ith person.\nA Person x will not send a friend request to a person y (x != y) if any of the following conditions is true:\n\n\tage[y] <= 0.5 * age[x] + 7\n\tage[y] > age[x]\n\tage[y] > 100 && age[x] < 100\n\nOtherwise, x will send a friend request to y.\nNote that if x sends a request to y, y will not necessarily send a request to x. Also, a person will not send a friend request to themself.\nReturn the total number of friend requests made.\n&nbsp;\nExample 1:\n\nInput: ages = [16,16]\nOutput: 2\nExplanation: 2 people friend request each other.\n\nExample 2:\n\nInput: ages = [16,17,18]\nOutput: 2\nExplanation: Friend requests are made 17 -> 16, 18 -> 17.\n\nExample 3:\n\nInput: ages = [20,30,100,110,120]\nOutput: 3\nExplanation: Friend requests are made 110 -> 100, 120 -> 110, 120 -> 100.\n\n&nbsp;\nConstraints:\n\n\tn == ages.length\n\t1 <= n <= 2 * 104\n\t1 <= ages[i] <= 120",
        "solutions": [
            {
                "id": 127029,
                "title": "c-java-python-easy-and-straight-forward",
                "content": "## **Explanation**\\n1. Write a sub function `request(a, b)` to check if age `a` will friend requests age `b`.\\nI just copy it from description:\\n`return !(condition1 || condition2 || condition3)`\\n\\n2. Count nunmber of all ages to a `map`.\\nBecause we have at most 20000 ages but only in range [1, 120].\\n3. For each age `a` and each age `b != a`, if request(a, b), we will make count[a] * count[b] requests.\\n4. For each age `a`, if request(a, a), we will make `count[a] * (count[a] - 1)` requests.\\n\\n**C++:**\\n```cpp\\n    int numFriendRequests(vector<int>& ages) {\\n        unordered_map<int, int> count;\\n        for (int &age : ages)\\n            count[age]++;\\n        int res = 0;\\n        for (auto &a : count)\\n            for (auto &b : count)\\n                if (request(a.first, b.first))\\n                    res += a.second * (b.second - (a.first == b.first ? 1 : 0));\\n        return res;\\n    }\\n\\n    bool request(int a, int b) {\\n        return !(b <= 0.5 * a + 7 || b > a || (b > 100 && a < 100));\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public int numFriendRequests(int[] ages) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for (int age : ages)\\n            count.put(age, count.getOrDefault(age, 0) + 1);\\n        int res = 0;\\n        for (Integer a : count.keySet())\\n            for (Integer b : count.keySet())\\n                if (request(a, b)) res += count.get(a) * (count.get(b) - (a == b ? 1 : 0));\\n        return res;\\n    }\\n\\n    private boolean request(int a, int b) {\\n        return !(b <= 0.5 * a + 7 || b > a || (b > 100 && a < 100));\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def numFriendRequests(self, ages):\\n        def request(a, b):\\n            return not (b <= 0.5 * a + 7 or b > a or b > 100 and a < 100)\\n        c = collections.Counter(ages)\\n        return sum(request(a, b) * c[a] * (c[b] - (a == b)) for a in c for b in c)\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\n    int numFriendRequests(vector<int>& ages) {\\n        unordered_map<int, int> count;\\n        for (int &age : ages)\\n            count[age]++;\\n        int res = 0;\\n        for (auto &a : count)\\n            for (auto &b : count)\\n                if (request(a.first, b.first))\\n                    res += a.second * (b.second - (a.first == b.first ? 1 : 0));\\n        return res;\\n    }\\n\\n    bool request(int a, int b) {\\n        return !(b <= 0.5 * a + 7 || b > a || (b > 100 && a < 100));\\n    }\\n```\n```java\\n    public int numFriendRequests(int[] ages) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for (int age : ages)\\n            count.put(age, count.getOrDefault(age, 0) + 1);\\n        int res = 0;\\n        for (Integer a : count.keySet())\\n            for (Integer b : count.keySet())\\n                if (request(a, b)) res += count.get(a) * (count.get(b) - (a == b ? 1 : 0));\\n        return res;\\n    }\\n\\n    private boolean request(int a, int b) {\\n        return !(b <= 0.5 * a + 7 || b > a || (b > 100 && a < 100));\\n    }\\n```\n```py\\n    def numFriendRequests(self, ages):\\n        def request(a, b):\\n            return not (b <= 0.5 * a + 7 or b > a or b > 100 and a < 100)\\n        c = collections.Counter(ages)\\n        return sum(request(a, b) * c[a] * (c[b] - (a == b)) for a in c for b in c)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 127341,
                "title": "10ms-concise-java-solution-o-n-time-and-o-1-space",
                "content": "Three conditions could be merged to one: \\nThe Person with age A can request person with age B if\\n* B is in range **(** 0.5 * A + 7, A **]** \\n```\\n    public int numFriendRequests(int[] ages) {\\n        int res = 0;\\n        int[] numInAge = new int[121], sumInAge = new int[121];\\n        \\n        for(int i : ages) \\n            numInAge[i] ++;\\n        \\n        for(int i = 1; i <= 120; ++i) \\n            sumInAge[i] = numInAge[i] + sumInAge[i - 1];\\n        \\n        for(int i = 15; i <= 120; ++i) {\\n            if(numInAge[i] == 0) continue;\\n            int count = sumInAge[i] - sumInAge[i / 2 + 7];\\n            res += count * numInAge[i] - numInAge[i]; //people will not friend request themselves, so  - numInAge[i]\\n        }\\n        return res;\\n    }\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n    public int numFriendRequests(int[] ages) {\\n        int res = 0;\\n        int[] numInAge = new int[121], sumInAge = new int[121];\\n        \\n        for(int i : ages) \\n            numInAge[i] ++;\\n        \\n        for(int i = 1; i <= 120; ++i) \\n            sumInAge[i] = numInAge[i] + sumInAge[i - 1];\\n        \\n        for(int i = 15; i <= 120; ++i) {\\n            if(numInAge[i] == 0) continue;\\n            int count = sumInAge[i] - sumInAge[i / 2 + 7];\\n            res += count * numInAge[i] - numInAge[i]; //people will not friend request themselves, so  - numInAge[i]\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 126930,
                "title": "c-5-lines-o-n-sliding-sum",
                "content": "Since the age range is limited to [1..120], we can count number of people of each age and store in the array. Then we can use that array to count friend requests:\\n* People younger than 15 cannot make requests due to the first rule.\\n* From the age of 15, people can make requests to the same age: ```a[i] * (a[i] - 1)``` requests.\\n* People can make requests to younger people older than 0.5 * i + 7: ```a[j] * a[i]``` requests.\\n    * The third rule is redundant as the condition is already covered by the second rule.\\n\\nThe complexity is O(n) as we need to count ages in the input array. Counting requests is O(1) as it always takes 2862 operations precisely. \\n```\\nint numFriendRequests(vector<int>& ages) {\\n  int a[121] = {}, res = 0;\\n  for (auto age : ages) ++a[age];\\n  for (auto i = 15; i <= 120; ++i)\\n    for (int j = 0.5 * i + 8; j <= i; ++j) res += a[j] * (a[i] - (i == j));\\n  return res;\\n}\\n```\\nWe can optimize the counting by using a sliding sum of friend requests. Note that the sum starts at the minimum age (```0.5 * i + 7```), per the first rule.\\n\\nThe complexity of optimized solution is O(n + m) vs. O(n + m * m), where m is the age range. In our case, we need only 159 operations for [1..120] range. I did not see much of a difference in the OJ runtime, though, probably because of the tight constraint. The second solution will shine if we need, for example, use days instead of years to compare ages.\\n```\\nint numFriendRequests(vector<int>& ages) {\\n  int a[121] = {}, res = 0;\\n  for (auto age : ages) ++a[age];\\n  for (auto i = 15, minAge = 15, sSum = 0; i <= 120; sSum += a[i], res += a[i++] * (sSum - 1))\\n    while (minAge <= 0.5 * i + 7) sSum -= a[minAge++];\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```a[i] * (a[i] - 1)```\n```a[j] * a[i]```\n```\\nint numFriendRequests(vector<int>& ages) {\\n  int a[121] = {}, res = 0;\\n  for (auto age : ages) ++a[age];\\n  for (auto i = 15; i <= 120; ++i)\\n    for (int j = 0.5 * i + 8; j <= i; ++j) res += a[j] * (a[i] - (i == j));\\n  return res;\\n}\\n```\n```0.5 * i + 7```\n```\\nint numFriendRequests(vector<int>& ages) {\\n  int a[121] = {}, res = 0;\\n  for (auto age : ages) ++a[age];\\n  for (auto i = 15, minAge = 15, sSum = 0; i <= 120; sSum += a[i], res += a[i++] * (sSum - 1))\\n    while (minAge <= 0.5 * i + 7) sSum -= a[minAge++];\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 231649,
                "title": "java-i-think-this-is-the-solution-interviewers-would-like-to-see",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int res = 0;\\n        Arrays.sort(ages);\\n        for (int i = 0; i < ages.length; ++i) {\\n            int age = ages[i];\\n            int lower = firstIdx(ages, age/2+7);\\n            int upper = firstIdx(ages, age);\\n            res += Math.max(upper-lower-1, 0);\\n        }\\n        return res;\\n    }\\n    \\n    private static int firstIdx(int[] ages, int target) {\\n        int beg = 0;\\n        int end = ages.length-1;\\n        while (beg <= end) {\\n            int mid = beg + (end-beg)/2;\\n            if (ages[mid] <= target) beg = mid + 1;\\n            else end = mid - 1;\\n        }\\n        return beg;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int res = 0;\\n        Arrays.sort(ages);\\n        for (int i = 0; i < ages.length; ++i) {\\n            int age = ages[i];\\n            int lower = firstIdx(ages, age/2+7);\\n            int upper = firstIdx(ages, age);\\n            res += Math.max(upper-lower-1, 0);\\n        }\\n        return res;\\n    }\\n    \\n    private static int firstIdx(int[] ages, int target) {\\n        int beg = 0;\\n        int end = ages.length-1;\\n        while (beg <= end) {\\n            int mid = beg + (end-beg)/2;\\n            if (ages[mid] <= target) beg = mid + 1;\\n            else end = mid - 1;\\n        }\\n        return beg;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 129665,
                "title": "super-clear-explanation-on-both-o-nlgn-and-o-n-solution-step-by-step",
                "content": "The NAIVE solution should be comparing each pair and has O(N^2) time complexity. However, after careful consideration, we can easily find that for every person, there\\'s a range of ages that he will make request to. As a result, it is not hard to think of an O(NlgN) solution, where we sort the array first, and for each person, we calculate the expected range, and use binary search to find the number of elements in ages[] that sit in that range. Note that,\\nage[B] > 100 && age[A] < 100 is an useless condition which is fully convered by the second one. Here is the code:\\n```\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end());\\n        int res = 0;\\n        for (int i = 0; i < ages.size(); ++i) {\\n            int low_bound = ages[i]/2 + 8;\\n            auto low_it = lower_bound(ages.begin(), ages.end(), low_bound);\\n            auto high_it = upper_bound(ages.begin(), ages.end(), ages[i]);\\n            int request = distance(low_it, high_it) - 1;\\n            res += max(request, 0);\\n        }\\n        return res;\\n    }\\n```\\nlow_bound is the inclusive left bound for the range. the \"-1\" in the cacluation of request is getting rid of making request to himself/herself . However, it is not necessary that his own age is in the expected result (and also it is not necessary that low_it is before high_it), so in the end, we make sure that for every person, the minimum request he/she will make is 0 (get rid of negative values).\\nAfter this, I was thinking if we can get faster? I observerd that low_it and hight_it is always proceeding, which makes sense as the age of the person cannot decrease (after sort), the left and right bound of his/her expected range should also not decrease. So, we don\\'t need to apply the binary search for low_it and high_it in every step.\\nHere comes the code:\\n```\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end());\\n        auto low_it = lower_bound(ages.begin(), ages.end(), ages[0]/2 + 8);\\n        auto high_it = upper_bound(ages.begin(), ages.end(), ages[0]);\\n        int res = 0;\\n        for (int i = 0; i < ages.size(); ++i) {\\n            int low_bound = ages[i]/2 + 8;\\n            while (*low_it < low_bound) ++low_it;\\n            while (high_it != ages.end() && *high_it <= ages[i]) ++high_it;\\n            int request = distance(low_it, high_it) - 1;\\n            res += max(request, 0);\\n        }\\n        return res;\\n    }\\n```\\nWe can find the expected range for the first element and then increase its boundaries when possible. In the for loop, low_it, high_it, and index i cannot decrease, so the time complexity for the for loop is only O(N). Someone may argue that, the sort takes O(NlgN) and that is right! However, please remember the range of of age : 1 <= ages[i] <= 120. We can definitely apply an O(N) bucket sort if we want.\\nThe code is not optmized for the smallest xx ms on the test cases but should elaborate my idea for you!",
                "solutionTags": [],
                "code": "```\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end());\\n        int res = 0;\\n        for (int i = 0; i < ages.size(); ++i) {\\n            int low_bound = ages[i]/2 + 8;\\n            auto low_it = lower_bound(ages.begin(), ages.end(), low_bound);\\n            auto high_it = upper_bound(ages.begin(), ages.end(), ages[i]);\\n            int request = distance(low_it, high_it) - 1;\\n            res += max(request, 0);\\n        }\\n        return res;\\n    }\\n```\n```\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end());\\n        auto low_it = lower_bound(ages.begin(), ages.end(), ages[0]/2 + 8);\\n        auto high_it = upper_bound(ages.begin(), ages.end(), ages[0]);\\n        int res = 0;\\n        for (int i = 0; i < ages.size(); ++i) {\\n            int low_bound = ages[i]/2 + 8;\\n            while (*low_it < low_bound) ++low_it;\\n            while (high_it != ages.end() && *high_it <= ages[i]) ++high_it;\\n            int request = distance(low_it, high_it) - 1;\\n            res += max(request, 0);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 166776,
                "title": "2-solutions-both-with-o-n-time-and-o-1-space-chinese-explaination",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] map = new int[121]; //\\u6BCF\\u4E2A\\u5E74\\u9F84\\u6709\\u591A\\u5C11\\u4EBA, \\u4F18\\u53161 \\u4E0D\\u7528map\\u7528\\u5E38\\u6570\\u5927\\u5C0F\\u6570\\u7EC4\\uFF0C\\u8FD9\\u6837\\u65F6\\u95F4\\u548C\\u7A7A\\u95F4\\u90FD\\u662FO\\uFF081\\uFF09\\n        for (int age : ages) map[age]++;\\n        int count = 0;\\n        for (int i = 0; i <= 120; i++) {\\n            for (int j = 0; j <= 120; j++) {\\n                if (valid(i, j)) count += map[i] * (i == j ? map[j] - 1 : map[j]); //\\u6CE8\\u610Fi,j\\u76F8\\u7B49\\u4E0D\\u80FDskip\\uFF0C\\u56E0\\u4E3A\\u53EF\\u80FD\\u591A\\u4E2A\\u76F8\\u7B49\\u5E74\\u9F84\\n            }\\n        }\\n        return count;\\n    }\\n    public boolean valid(int a, int b) {\\n        return !(b <= 0.5 * a + 7 || b > a || (b > 100 && a < 100)); //\\u5176\\u5B9E\\u6761\\u4EF62\\u548C3\\u91CD\\u590D\\u4E86\\n    }\\n}\\n\\nclass Solution {\\n    public int numFriendRequests(int[] ages) { //\\u4F18\\u53162\\uFF0C\\u53E6\\u4E00\\u6570\\u7EC4sums\\u8BB0\\u5F55\\u8303\\u56F4\\uFF0C\\u8FD9\\u6837\\u8BA1\\u7B97count\\u4E0D\\u75282 for\\uFF0C\\u76F4\\u63A5\\u627E\\u8303\\u56F4\\u5185\\u4E2A\\u6570\\u5373\\u53EF\\n        int[] nums = new int[121], sums = new int[121];\\n        for (int age : ages) nums[age]++; //\\u8BB0\\u5F55\\u6BCF\\u4E2A\\u5E74\\u9F84\\u591A\\u5C11\\u4EBA\\n        for (int i = 1; i < sums.length; i++) sums[i] = sums[i - 1] + nums[i]; //\\u76F8\\u5F53\\u4E8E\\u8BB0\\u5F55\\u5C0F\\u4E8Ei\\u7684\\u6709\\u591A\\u5C11\\u4EBA\\n        int res = 0;\\n        for (int i = 15; i < sums.length; i++) { //i / 2 + 7 < i -> i>14\\n            if (nums[i] == 0) continue; //0\\u4E00\\u5B9A\\u8981\\u8DF3\\u8FC7\\uFF0C\\u5426\\u5219\\u540E\\u9762\\u662F\\u8D1F\\u6570\\n            int count = sums[i] - sums[i / 2 + 7]; //(i/2+7, i] \\u6709\\u591A\\u5C11\\u4E2A\\n            res += (count - 1) * nums[i]; //\\u4E0D\\u80FD\\u548C\\u81EA\\u8EABrequest\\n        }\\n        return res;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] map = new int[121]; //\\u6BCF\\u4E2A\\u5E74\\u9F84\\u6709\\u591A\\u5C11\\u4EBA, \\u4F18\\u53161 \\u4E0D\\u7528map\\u7528\\u5E38\\u6570\\u5927\\u5C0F\\u6570\\u7EC4\\uFF0C\\u8FD9\\u6837\\u65F6\\u95F4\\u548C\\u7A7A\\u95F4\\u90FD\\u662FO\\uFF081\\uFF09\\n        for (int age : ages) map[age]++;\\n        int count = 0;\\n        for (int i = 0; i <= 120; i++) {\\n            for (int j = 0; j <= 120; j++) {\\n                if (valid(i, j)) count += map[i] * (i == j ? map[j] - 1 : map[j]); //\\u6CE8\\u610Fi,j\\u76F8\\u7B49\\u4E0D\\u80FDskip\\uFF0C\\u56E0\\u4E3A\\u53EF\\u80FD\\u591A\\u4E2A\\u76F8\\u7B49\\u5E74\\u9F84\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 744947,
                "title": "c-binary-search",
                "content": "A will friend B only if: \\n\\ni) B\\'s age is <= A and if, \\nii) B\\'s age is > 0.5*age[A]+7.\\n\\nAlgorithm: \\n\\n1) Sort the ages. \\n2) In the sorted array for any  j<sup>th</sup> index, we have to find all indexes which satisfy condition (i) and (ii). We do that using a binary search on the array to the left of the j<sup>th</sup> index. We terminate the search when we find the smallest index which satisfies the condition ages[mid] > 0.5*age[j]+7. Return the length of the array between j-1 and mid. \\n3) Keep a hash-map to store age and calculated friend-requests. That way if we have already found the number of friend requests that can be sent for a particular age, we can re-use it (since the array has duplicate ages). \\n4) **Traverse the age array from right to left** in the main function to compute step 2 for each index in the ages array.  \\n\\n**There is an important benefit to traverse the array from right to left (from ages.size()-1 to 0). It lets us compute the number of people of the same age as the j<sup>th</sup> person and the ones less than the j<sup>th</sup> person satisfying condition (ii), in the same binary search function.**\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map <int,int> map; // key: age, val: FriendRequestCount. \\n    \\n    int findRequests (vector<int> & ages, int index) {\\n        \\n        if (map.find(ages[index]) != map.end()) {\\n            return map[ages[index]];\\n        }\\n        \\n        int left = 0;\\n        int right = index-1;\\n        double target = (double) (0.5*ages[index]) + 7; // find ages >= target.\\n        \\n        while (left <= right) {\\n            int mid = left + (right-left)/2;\\n            if (ages[mid] <= target) {\\n                left = mid+1;\\n            } else {\\n                right = mid-1;\\n            }\\n        }\\n        \\n        map[ages[index]] = index-left;\\n        return index-left; // len between index-1 and left. \\n    }\\n    \\n    int numFriendRequests(vector<int>& ages) {\\n        \\n        sort (ages.begin(), ages.end());\\n        \\n        int count = 0;\\n        \\n        for (int i = ages.size()-1; i >= 0 ; i--) {\\n            count += findRequests (ages, i);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map <int,int> map; // key: age, val: FriendRequestCount. \\n    \\n    int findRequests (vector<int> & ages, int index) {\\n        \\n        if (map.find(ages[index]) != map.end()) {\\n            return map[ages[index]];\\n        }\\n        \\n        int left = 0;\\n        int right = index-1;\\n        double target = (double) (0.5*ages[index]) + 7; // find ages >= target.\\n        \\n        while (left <= right) {\\n            int mid = left + (right-left)/2;\\n            if (ages[mid] <= target) {\\n                left = mid+1;\\n            } else {\\n                right = mid-1;\\n            }\\n        }\\n        \\n        map[ages[index]] = index-left;\\n        return index-left; // len between index-1 and left. \\n    }\\n    \\n    int numFriendRequests(vector<int>& ages) {\\n        \\n        sort (ages.begin(), ages.end());\\n        \\n        int count = 0;\\n        \\n        for (int i = ages.size()-1; i >= 0 ; i--) {\\n            count += findRequests (ages, i);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126944,
                "title": "python-easy-solution-using-binary-search",
                "content": "```\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        if not ages: return 0\\n        cnt = 0\\n        N = len(ages)\\n        ages.sort()\\n        for i in range(N):\\n            a = ages[i]\\n            if a<=14: continue\\n            idx1 = bisect.bisect(ages, a)\\n            x = 0.5*a+7\\n            idx2 = bisect.bisect(ages, x)\\n            while idx2<N and ages[idx2]==x:\\n                idx2 += 1\\n            cnt += max(0, idx1-idx2+(-1 if idx2<=i<=idx1 else 0)) \\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        if not ages: return 0\\n        cnt = 0\\n        N = len(ages)\\n        ages.sort()\\n        for i in range(N):\\n            a = ages[i]\\n            if a<=14: continue\\n            idx1 = bisect.bisect(ages, a)\\n            x = 0.5*a+7\\n            idx2 = bisect.bisect(ages, x)\\n            while idx2<N and ages[idx2]==x:\\n                idx2 += 1\\n            cnt += max(0, idx1-idx2+(-1 if idx2<=i<=idx1 else 0)) \\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558722,
                "title": "java-2-ms-short-and-simple",
                "content": "Many posts have already mentioned the conditions can be summed up as:\\n> Person A will friend request B iif \\n> **0.5 * age[A] + 7 < age[B] <= age[A]**\\n\\nSo just iterate over the possible values of B\\'s age.\\nSum how many people there are in each age year to make calculations more efficient.\\n\\n```\\n    public int numFriendRequests(int[] ages) {\\n        int[] ageCounts = new int[121];\\n        int friendReqCount = 0;\\n        \\n        // Count how many people there are for each age\\n        for(int age : ages) {\\n            ageCounts[age]++;\\n        }\\n        \\n        for(int a=0; a<=120; a++) {\\n            // Iterate over the allowed range for B\\'s age\\n            for(int b=(int)(0.5*a)+7+1; b<=a; b++) {\\n                friendReqCount += ageCounts[a] * ageCounts[b];\\n                \\n                if(a==b) {\\n                    // A will not friend request him/herself\\n                    friendReqCount -= ageCounts[a];\\n                }\\n            }\\n        }\\n        \\n        return friendReqCount;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int numFriendRequests(int[] ages) {\\n        int[] ageCounts = new int[121];\\n        int friendReqCount = 0;\\n        \\n        // Count how many people there are for each age\\n        for(int age : ages) {\\n            ageCounts[age]++;\\n        }\\n        \\n        for(int a=0; a<=120; a++) {\\n            // Iterate over the allowed range for B\\'s age\\n            for(int b=(int)(0.5*a)+7+1; b<=a; b++) {\\n                friendReqCount += ageCounts[a] * ageCounts[b];\\n                \\n                if(a==b) {\\n                    // A will not friend request him/herself\\n                    friendReqCount -= ageCounts[a];\\n                }\\n            }\\n        }\\n        \\n        return friendReqCount;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1704499,
                "title": "python-bucket-sorting-o-n-time",
                "content": "```\\ndef numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        smaller_eq = [0] * 121\\n        for age in ages:\\n          smaller_eq[age] += 1\\n        for i in range(1, 121):\\n          smaller_eq[i] += smaller_eq[i-1]\\n\\n        res = 0\\n        for age in ages:\\n            res += max(0, smaller_eq[age] - smaller_eq[int(0.5*age)+7]-1)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        smaller_eq = [0] * 121\\n        for age in ages:\\n          smaller_eq[age] += 1\\n        for i in range(1, 121):\\n          smaller_eq[i] += smaller_eq[i-1]\\n\\n        res = 0\\n        for age in ages:\\n            res += max(0, smaller_eq[age] - smaller_eq[int(0.5*age)+7]-1)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 737217,
                "title": "python-simple-solution-using-counters-beats-85",
                "content": "### Algorithm\\n**Step 1**: construct a dictionary with age as key and number of members in that age group as values. This can be done using Counter in collections module.\\n**Step 2**: iterate for every age group (not every person!!) say \"me\"\\n**Step 3**: for every age group check condition take (\"age\",\"me\") pair and check if the conditions asked are satisfied with \\n* age<= 0.5 * me +7\\n* age>me\\n* 3rd condition is always false so we can omit it.\\n\\n**Step 4**:\\nHere we have 2 cases.\\n* **case(a): if your age is different from the other age**\\nfor example 16,15,15 then 15->16 and 15->16\\n\\t\\tie 2\\\\*1 which is `age_count * me_count`\\n* **case(b): if your age is same as other age**\\nfor example 16,16 then 16<->16 ie 2. \\nThis would be same as number of edges in a graph with n vertices where each edge considered 2 times which is 2\\\\*nC2 which would be `me_count*(me_count-1)`\\n### Python code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        count=0\\n\\t\\t# Step 1\\n        dicto=Counter(ages)\\n\\t\\t# Step 2\\n        for me in dicto:\\n            my_age_count=dicto[me]\\n\\t\\t\\t# Step 3\\n            for age in dicto:\\n                if not (age<= 0.5 * me +7 or age>me):\\n\\t\\t\\t\\t\\t# Step 4 case (a)\\n                    if age!=me :\\n                        count+=dicto[age]*my_age_count\\n\\t\\t\\t\\t\\t# Step 4 case (b)\\n                    else:\\n                        count+=int(my_age_count*(my_age_count-1))\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        count=0\\n\\t\\t# Step 1\\n        dicto=Counter(ages)\\n\\t\\t# Step 2\\n        for me in dicto:\\n            my_age_count=dicto[me]\\n\\t\\t\\t# Step 3\\n            for age in dicto:\\n                if not (age<= 0.5 * me +7 or age>me):\\n\\t\\t\\t\\t\\t# Step 4 case (a)\\n                    if age!=me :\\n                        count+=dicto[age]*my_age_count\\n\\t\\t\\t\\t\\t# Step 4 case (b)\\n                    else:\\n                        count+=int(my_age_count*(my_age_count-1))\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141466,
                "title": "python-3-with-counter",
                "content": "The third contion is redundant. \\n```python\\nclass Solution:\\n    def numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        cnt = collections.Counter(ages)\\n        for k1, v1 in cnt.items():\\n            for k2, v2 in cnt.items():\\n                if (k2 > 0.5*k1 + 7 and\\n                    k2 <= k1):\\n                    # if both conditions met\\n                    ans += v1 * v2\\n                    if k1 == k2:\\n                        ans -= v1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        cnt = collections.Counter(ages)\\n        for k1, v1 in cnt.items():\\n            for k2, v2 in cnt.items():\\n                if (k2 > 0.5*k1 + 7 and\\n                    k2 <= k1):\\n                    # if both conditions met\\n                    ans += v1 * v2\\n                    if k1 == k2:\\n                        ans -= v1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074946,
                "title": "python-3-three-methods-binary-search-counter-hashmap-math-explanation",
                "content": "### Approach 1. Binary Search + Math\\n- Time Complexity: `O(NlogN), N = len(ages)`\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()                                   # sort the `ages`\\n        ans = 0\\n        n = len(ages)\\n        for idx, age in enumerate(ages):              # for each age\\n            lb = age                                  # lower bound\\n            ub = (age - 7) * 2                        # upper bound\\n            i = bisect.bisect_left(ages, lb)          # binary search lower bound\\n            j = bisect.bisect_left(ages, ub)          # binary search upper bound\\n            if j - i <= 0: continue\\n            ans += j - i                              # count number of potential friends\\n            if lb <= age < ub:                        # ignore itself\\n                ans -= 1\\n        return ans\\n```\\n### Approach 2. Counter + Nested loop\\n- Time complexity: `max(O(121*121), N), N = len(ages)`\\n```\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        count = [0] * 121                           # counter: count frequency of each age\\n        for age in ages:\\n            count[age] += 1\\n        ans = 0\\n        for ageA, countA in enumerate(count):       # nested loop, pretty straightforward\\n            for ageB, countB in enumerate(count):\\n                if ageA * 0.5 + 7 >= ageB: continue\\n                if ageA < ageB: continue\\n                if ageA < 100 < ageB: continue\\n                ans += countA * countB\\n                if ageA == ageB: ans -= countA\\n        return ans    \\n```\\t\\t\\n### Approach 3. Counter + Binary Search + Math\\n- Time complexity: `max(O(121*log(121)), N), N = len(ages)`\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages):\\n        count = [0] * 121                               # counter: count frequency of each age\\n        for age in ages:\\n            count[age] += 1\\n        prefix = [0] * 121                              # prefix-sum: prefix sum of frequency, we will use this for range subtraction\\n        for i in range(1, 121):\\n            prefix[i] = prefix[i-1] + count[i]\\n        nums = [i for i in range(121)]                  # a dummy age list, which will be used in binary search\\n        ans = 0\\n        for age, cnt in enumerate(count):\\n            if not cnt: continue\\n            lb = age                                    # lower bound\\n            ub = (age - 7) * 2                          # upper bound\\n            i = bisect.bisect_left(nums, lb)            # binary search on lower bound, O(log(121))\\n            j = bisect.bisect_left(nums, ub)            # binary search on upper bound, O(log(121))\\n            if j - i <= 0: continue\\n            total = prefix[j-1] - prefix[i-1]           # range subtraction - how many ages in total can be considered as friend, including current age itself\\n            if lb <= age < ub:                          # considering itself, e.g. [17, 17, 17]\\n                # total -= cnt                          # minus itself\\n                # total = (cnt - 1) * cnt + total * cnt # make friends with other at same age `(cnt-1) * cnt`; with other at different age `total * cnt`\\n                total = cnt * (total - 1)               # a cleaner presentation of above two lines\\n            ans += total    \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()                                   # sort the `ages`\\n        ans = 0\\n        n = len(ages)\\n        for idx, age in enumerate(ages):              # for each age\\n            lb = age                                  # lower bound\\n            ub = (age - 7) * 2                        # upper bound\\n            i = bisect.bisect_left(ages, lb)          # binary search lower bound\\n            j = bisect.bisect_left(ages, ub)          # binary search upper bound\\n            if j - i <= 0: continue\\n            ans += j - i                              # count number of potential friends\\n            if lb <= age < ub:                        # ignore itself\\n                ans -= 1\\n        return ans\\n```\n```\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        count = [0] * 121                           # counter: count frequency of each age\\n        for age in ages:\\n            count[age] += 1\\n        ans = 0\\n        for ageA, countA in enumerate(count):       # nested loop, pretty straightforward\\n            for ageB, countB in enumerate(count):\\n                if ageA * 0.5 + 7 >= ageB: continue\\n                if ageA < ageB: continue\\n                if ageA < 100 < ageB: continue\\n                ans += countA * countB\\n                if ageA == ageB: ans -= countA\\n        return ans    \\n```\n```\\nclass Solution:\\n    def numFriendRequests(self, ages):\\n        count = [0] * 121                               # counter: count frequency of each age\\n        for age in ages:\\n            count[age] += 1\\n        prefix = [0] * 121                              # prefix-sum: prefix sum of frequency, we will use this for range subtraction\\n        for i in range(1, 121):\\n            prefix[i] = prefix[i-1] + count[i]\\n        nums = [i for i in range(121)]                  # a dummy age list, which will be used in binary search\\n        ans = 0\\n        for age, cnt in enumerate(count):\\n            if not cnt: continue\\n            lb = age                                    # lower bound\\n            ub = (age - 7) * 2                          # upper bound\\n            i = bisect.bisect_left(nums, lb)            # binary search on lower bound, O(log(121))\\n            j = bisect.bisect_left(nums, ub)            # binary search on upper bound, O(log(121))\\n            if j - i <= 0: continue\\n            total = prefix[j-1] - prefix[i-1]           # range subtraction - how many ages in total can be considered as friend, including current age itself\\n            if lb <= age < ub:                          # considering itself, e.g. [17, 17, 17]\\n                # total -= cnt                          # minus itself\\n                # total = (cnt - 1) * cnt + total * cnt # make friends with other at same age `(cnt-1) * cnt`; with other at different age `total * cnt`\\n                total = cnt * (total - 1)               # a cleaner presentation of above two lines\\n            ans += total    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547711,
                "title": "binary-search-c-very-easy-solution",
                "content": "->First We will Sort the array \\n->now for all element i we have to find range of ind which satisfy the condition of friendship\\n->condition for friendship\\nlet x and y be 2 person and x want to be friend of y then\\n->x>y/2+7 &&x<=y \\n->or we can say   (y/2+7<x<=y)\\n\\n->now to find val >y/2+7 we can apply binary search \\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n       sort(ages.begin(),ages.end());\\n        int count =0;\\n        for(int i=0;i<ages.size();i++)\\n        {\\n             int val=ages[i]/2+7;\\n            if(ages[i]<=val) //invalid condition\\n                continue;\\n            \\n            int ind1=upper_bound(ages.begin(),ages.end(),val)-ages.begin();\\n            int ind2=upper_bound(ages.begin(),ages.end(),ages[i])-ages.begin();\\n            \\n            ind2--;         //because upper bound will give val greater than ages[i] soo we need to decrement ind2 to get \\n            if(ind2>=ind1)    // val<=ages[i]\\n                count+=ind2-ind1;\\n            \\n         }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n       sort(ages.begin(),ages.end());\\n        int count =0;\\n        for(int i=0;i<ages.size();i++)\\n        {\\n             int val=ages[i]/2+7;\\n            if(ages[i]<=val) //invalid condition\\n                continue;\\n            \\n            int ind1=upper_bound(ages.begin(),ages.end(),val)-ages.begin();\\n            int ind2=upper_bound(ages.begin(),ages.end(),ages[i])-ages.begin();\\n            \\n            ind2--;         //because upper bound will give val greater than ages[i] soo we need to decrement ind2 to get \\n            if(ind2>=ind1)    // val<=ages[i]\\n                count+=ind2-ind1;\\n            \\n         }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152040,
                "title": "cpp-100-easy-to-understand-and-elegant",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int map[121] = { 0 };\\n        int minage = 0, ans = 0, group = 0;\\n        \\n        for (auto a : ages)\\n            map[a]++;\\n        \\n        for (int i = 1; i < 121; ++i)\\n            map[i] += map[i-1];\\n        \\n        for (int i = 15; i < 121; ++i) {\\n            minage = (i/2 + 7);\\n            group = map[i]-map[i-1];\\n            ans += group * (map[i] - map[minage] - 1); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int map[121] = { 0 };\\n        int minage = 0, ans = 0, group = 0;\\n        \\n        for (auto a : ages)\\n            map[a]++;\\n        \\n        for (int i = 1; i < 121; ++i)\\n            map[i] += map[i-1];\\n        \\n        for (int i = 15; i < 121; ++i) {\\n            minage = (i/2 + 7);\\n            group = map[i]-map[i-1];\\n            ans += group * (map[i] - map[minage] - 1); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225554,
                "title": "o-n-solution-with-explanation",
                "content": "```\\n public int NumFriendRequests(int[] ages) {\\n        //we can see that condition age[B] > 100 && age[A] < 100 are redunant just \\n        //because of condition age[B] > age[A], the condition is actually that B should be in         //a range of (0.5 * age[A] + 7, A]\\n        // We would solve it with commulative sum approach solution:\\n        // Max age is set as 120\\n        // We would mark how many people in each age exists;\\n        var peopleInAge = new int[121];\\n        for (int i = 0; i < ages.Length; i++) {\\n            peopleInAge[ages[i]]++;\\n        }\\n        //here we count how many people bellow their age, using commulative sum approach.\\n        var countYongestPeople = new int[121];\\n        for (int  i = 1; i < 121; i++) {\\n           countYongestPeople[i] = peopleInAge[i] + countYongestPeople[i-1];\\n        }\\n        \\n        var result = 0;\\n        //there is conditions:\\n        // (1) B < A;\\n        // (2) B >= 0.5*A + 7;\\n        // if B is greater than or equal to (0.5*A + 7) then from (1), A is greater than (0.5)*A + 7;\\n        // A > 0.5*A + 7;\\n        // A - 0.5*A > 7;\\n        // 0.5*A > 7;\\n        // A > 15;\\n        for (int i = 15; i < 121; i++) {\\n            //if we don\\'t have such people, just skip it\\n            if (peopleInAge[i] == 0) continue;\\n            \\n            //calculate how many people between range (0.5 * age[A] + 7, A];\\n            var suitablePeople = countYongestPeople[i] - countYongestPeople[i/2 + 7];\\n            var suitableWithoutThemSelf = suitablePeople*peopleInAge[i] - peopleInAge[i];\\n            result += suitableWithoutThemSelf;\\n        }\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int NumFriendRequests(int[] ages) {\\n        //we can see that condition age[B] > 100 && age[A] < 100 are redunant just \\n        //because of condition age[B] > age[A], the condition is actually that B should be in         //a range of (0.5 * age[A] + 7, A]\\n        // We would solve it with commulative sum approach solution:\\n        // Max age is set as 120\\n        // We would mark how many people in each age exists;\\n        var peopleInAge = new int[121];\\n        for (int i = 0; i < ages.Length; i++) {\\n            peopleInAge[ages[i]]++;\\n        }\\n        //here we count how many people bellow their age, using commulative sum approach.\\n        var countYongestPeople = new int[121];\\n        for (int  i = 1; i < 121; i++) {\\n           countYongestPeople[i] = peopleInAge[i] + countYongestPeople[i-1];\\n        }\\n        \\n        var result = 0;\\n        //there is conditions:\\n        // (1) B < A;\\n        // (2) B >= 0.5*A + 7;\\n        // if B is greater than or equal to (0.5*A + 7) then from (1), A is greater than (0.5)*A + 7;\\n        // A > 0.5*A + 7;\\n        // A - 0.5*A > 7;\\n        // 0.5*A > 7;\\n        // A > 15;\\n        for (int i = 15; i < 121; i++) {\\n            //if we don\\'t have such people, just skip it\\n            if (peopleInAge[i] == 0) continue;\\n            \\n            //calculate how many people between range (0.5 * age[A] + 7, A];\\n            var suitablePeople = countYongestPeople[i] - countYongestPeople[i/2 + 7];\\n            var suitableWithoutThemSelf = suitablePeople*peopleInAge[i] - peopleInAge[i];\\n            result += suitableWithoutThemSelf;\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1000595,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\n\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end());\\n        int n = ages.size(), count = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            int val = 0.5 * ages[i] + 7;\\n            int index = upper_bound(ages.begin(), ages.end(), val) - ages.begin();\\n            int c = 1, prev = i;\\n            while (i - 1 >= 0 && ages[i] == ages[i - 1]) {\\n                c++;\\n                i--;\\n            }\\n            if (index >= prev) continue;\\n            count += (prev - index) * c;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end());\\n        int n = ages.size(), count = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            int val = 0.5 * ages[i] + 7;\\n            int index = upper_bound(ages.begin(), ages.end(), val) - ages.begin();\\n            int c = 1, prev = i;\\n            while (i - 1 >= 0 && ages[i] == ages[i - 1]) {\\n                c++;\\n                i--;\\n            }\\n            if (index >= prev) continue;\\n            count += (prev - index) * c;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707318,
                "title": "python-2-solutions-binary-search-and-using-counter",
                "content": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH  : BINARY SEARCH ##\\n        ## 1. Sort by age\\n        ## 2. index i person will not send friend request to ages[i]+1, ages[i]+2 ....\\n        ## 3. index i person will not send friend request to elements whose age is less than (0.5 * ages[i] + 7)\\n        ## 4. Using binary search we can find upper and lower limit, persons which fall in this range, can send friend requests (remove 1, ith person itself)\\n        \\n        ages.sort()\\n        count = 0\\n        for i in range(len(ages)):\\n            left = bisect.bisect_right( ages, (0.5 * ages[i]) + 7 )\\n            right = bisect.bisect_right( ages, ages[i])\\n            count += max(0, right - left - 1)                       # you cannot have negative count\\n        return count\\n    \\n        ## APPROACH : COUNTER ##\\n        ages = collections.Counter(ages)\\n        ans = 0\\n        for ageA, countA in ages.items():\\n            for ageB, countB in ages.items():\\n                if ageA * 0.5 + 7 >= ageB: continue\\n                if ageA < ageB: continue\\n                ans += countA * countB\\n                if ageA == ageB: ans -= countA\\n        return ans\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH  : BINARY SEARCH ##\\n        ## 1. Sort by age\\n        ## 2. index i person will not send friend request to ages[i]+1, ages[i]+2 ....\\n        ## 3. index i person will not send friend request to elements whose age is less than (0.5 * ages[i] + 7)\\n        ## 4. Using binary search we can find upper and lower limit, persons which fall in this range, can send friend requests (remove 1, ith person itself)\\n        \\n        ages.sort()\\n        count = 0\\n        for i in range(len(ages)):\\n            left = bisect.bisect_right( ages, (0.5 * ages[i]) + 7 )\\n            right = bisect.bisect_right( ages, ages[i])\\n            count += max(0, right - left - 1)                       # you cannot have negative count\\n        return count\\n    \\n        ## APPROACH : COUNTER ##\\n        ages = collections.Counter(ages)\\n        ans = 0\\n        for ageA, countA in ages.items():\\n            for ageB, countB in ages.items():\\n                if ageA * 0.5 + 7 >= ageB: continue\\n                if ageA < ageB: continue\\n                ans += countA * countB\\n                if ageA == ageB: ans -= countA\\n        return ans\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 212431,
                "title": "o-n-counting-dp-c",
                "content": "Since we have the condition 1 <= age <= 120, we can do something similar to counting sort. Then for every age, `a`, we want to count the number of ages within (a,b] (specifically `(a/2+7, a]`). To do this we can simply use the accumulation of the counts (i.e. first we preprocess our count array via modifying it such that it is a cumulative sum array, i.e. `count[i] = count[i] + count[i-1]`), and then we simply have: # people between `(a/2+7, a]` = `count[a] - count[a/2+7] - 1` (using `-1` to remove counting ourself).\\n\\n```\\nint counts[121] = {};\\nfor(int age : ages) {\\n\\tcounts[age]++;\\n}\\n\\nfor(int i = 1; i < 121; ++i) {\\n\\tcounts[i] += counts[i - 1];\\n}\\n\\nint total = 0;\\nfor(int age : ages) {\\n\\tint lower = age/2 + 7;\\n\\tif(lower >= age) continue;\\n\\ttotal += (counts[age] - counts[lower] - 1);\\n}\\n\\nreturn total;\\n```",
                "solutionTags": [],
                "code": "```\\nint counts[121] = {};\\nfor(int age : ages) {\\n\\tcounts[age]++;\\n}\\n\\nfor(int i = 1; i < 121; ++i) {\\n\\tcounts[i] += counts[i - 1];\\n}\\n\\nint total = 0;\\nfor(int age : ages) {\\n\\tint lower = age/2 + 7;\\n\\tif(lower >= age) continue;\\n\\ttotal += (counts[age] - counts[lower] - 1);\\n}\\n\\nreturn total;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 128010,
                "title": "java-o-n-solution",
                "content": "    public int numFriendRequests(int[] ages) {\\n        int[] count = new int[121];\\n        for(int x : ages) count[x]++;\\n        int ans = 0;\\n        for(int i = 1; i <= 120; i++) {\\n            if (i > 14)\\n                ans += count[i] * (count[i]-1 + count[i-1] - count[i/2 + 7]);\\n            count[i] += count[i-1];\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "    public int numFriendRequests(int[] ages) {\\n        int[] count = new int[121];\\n        for(int x : ages) count[x]++;\\n        int ans = 0;\\n        for(int i = 1; i <= 120; i++) {\\n            if (i > 14)\\n                ans += count[i] * (count[i]-1 + count[i-1] - count[i/2 + 7]);\\n            count[i] += count[i-1];\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3185944,
                "title": "java-o-nlogn-easy-to-understand-highly-commented-for-beginners",
                "content": "```\\n//     the basic intution of this code is to sort the array\\n//     and for each element we must search the first index where the condition age[y]>0.5*age[x]+7 is satisified \\n//     after that we just need to subtract the index of the array and the starting index to get no of pairs\\n//     but there is  a trick here as array contains duplicate elements if we calculate ans for ages=[16,16]\\n//     we will get wrong ans \\n//     so we maintain hashmap named index which contains last index of the element\\n//     we also maintain an hashmap named count which contains count of each element\\n//     we must now just iterate through keys of hashmap named index and search the first index satisfiying the given\\n//     condition and keep the count of no of pairs\\nclass Solution {\\n    private int solve(int ages[],int start,int end,int num){\\n        int flag=-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(ages[mid]>(.5*num+7)){\\n                flag=1;\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n//         this flag is the check whether there is any element which satisfies the conndition \\n//          if no such element is found we return -1 \\n        if(flag==-1){\\n            return -1;\\n        }\\n        return start;\\n    }\\n    public int numFriendRequests(int[] ages) {\\n//         to apply binary search we are sorting \\n        Arrays.sort(ages); \\n        int c=0;\\n        HashMap<Integer,Integer>index=new HashMap<>();\\n        HashMap<Integer,Integer>count=new HashMap<>();\\n//         storing the count of each element as well as the last index of each element\\n        for(int i=0;i<ages.length;i++){\\n            index.put(ages[i],i);\\n            count.put(ages[i],count.getOrDefault(ages[i],0)+1);\\n        }\\n// iterating through the hashmap keys and find the first index where the condition age[y]>0.5*age[x]+7 is satisfied\\n//  the function will returen index subtract start current index from start index  add 1 to include that index and add the final result to c\\n        for(int x:index.keySet()){\\n            int k=solve(ages,0,index.get(x)-1,x);\\n          \\n            if(k!=-1){\\n            c+=((index.get(x)-k)*count.get(x));\\n            }\\n          \\n        }\\n        return c;\\n    }\\n}\\n// Pls do Upvote if you like :)\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n//     the basic intution of this code is to sort the array\\n//     and for each element we must search the first index where the condition age[y]>0.5*age[x]+7 is satisified \\n//     after that we just need to subtract the index of the array and the starting index to get no of pairs\\n//     but there is  a trick here as array contains duplicate elements if we calculate ans for ages=[16,16]\\n//     we will get wrong ans \\n//     so we maintain hashmap named index which contains last index of the element\\n//     we also maintain an hashmap named count which contains count of each element\\n//     we must now just iterate through keys of hashmap named index and search the first index satisfiying the given\\n//     condition and keep the count of no of pairs\\nclass Solution {\\n    private int solve(int ages[],int start,int end,int num){\\n        int flag=-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(ages[mid]>(.5*num+7)){\\n                flag=1;\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n//         this flag is the check whether there is any element which satisfies the conndition \\n//          if no such element is found we return -1 \\n        if(flag==-1){\\n            return -1;\\n        }\\n        return start;\\n    }\\n    public int numFriendRequests(int[] ages) {\\n//         to apply binary search we are sorting \\n        Arrays.sort(ages); \\n        int c=0;\\n        HashMap<Integer,Integer>index=new HashMap<>();\\n        HashMap<Integer,Integer>count=new HashMap<>();\\n//         storing the count of each element as well as the last index of each element\\n        for(int i=0;i<ages.length;i++){\\n            index.put(ages[i],i);\\n            count.put(ages[i],count.getOrDefault(ages[i],0)+1);\\n        }\\n// iterating through the hashmap keys and find the first index where the condition age[y]>0.5*age[x]+7 is satisfied\\n//  the function will returen index subtract start current index from start index  add 1 to include that index and add the final result to c\\n        for(int x:index.keySet()){\\n            int k=solve(ages,0,index.get(x)-1,x);\\n          \\n            if(k!=-1){\\n            c+=((index.get(x)-k)*count.get(x));\\n            }\\n          \\n        }\\n        return c;\\n    }\\n}\\n// Pls do Upvote if you like :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886317,
                "title": "c-self-explained-simple-code-easy-to-understand-tc-o-n-sc-o-1",
                "content": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\n\\tint numFriendRequests(vector<int>& ages) {\\n        int n=ages.size(), ages_count[121]={0};\\n        for(int i=0;i<n;++i) ages_count[ages[i]]++;\\n        \\n        int friend_request=0;\\n        for(int i=1;i<=120;i++){\\n            for(int j=1;j<=120;++j){\\n                if(i<=0.5*double(j)+7 ||  i>j || (i>100 && j<100)) continue;\\n                if(i==j) friend_request+=(ages_count[i]-1)*(ages_count[i]);\\n                else friend_request+=(ages_count[i])*(ages_count[j]);\\n            }\\n        }\\n        \\n        return friend_request;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tint numFriendRequests(vector<int>& ages) {\\n        int n=ages.size(), ages_count[121]={0};\\n        for(int i=0;i<n;++i) ages_count[ages[i]]++;\\n        \\n        int friend_request=0;\\n        for(int i=1;i<=120;i++){\\n            for(int j=1;j<=120;++j){\\n                if(i<=0.5*double(j)+7 ||  i>j || (i>100 && j<100)) continue;\\n                if(i==j) friend_request+=(ages_count[i]-1)*(ages_count[i]);\\n                else friend_request+=(ages_count[i])*(ages_count[j]);\\n            }\\n        }\\n        \\n        return friend_request;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1881256,
                "title": "prefix-sum",
                "content": "`age_count[i]` is a accumulative number of people with age up to ` i`.\\nExample:\\n`age_count[1]` is the number of people of age 1\\n`age_count[2]` is the number of people of age 1,2\\n`age_count[3]` is the number of people of age 1,2,3\\n...\\n`age_count[120]` is the number of people of age 1,2,3,...,120\\n\\nTo find the requests a person can make, we find the age lower bound and upper bound according to the rules. Let\\'s say the current person of the `age`.\\n\\nage[y] <= 0.5 * age[x] + 7            => discard any one with age <= `0.5 * age + 7`\\nage[y] > age[x]                              => discard any one with age > `age`\\nage[y] > 100 && age[x] < 100     => this rule is satisfied if the second one is satisfied.\\n\\nThe firsst rule will form the lower bound and the second rule will form the upper bound.\\nLet\\'s recall how sum range works with prefix sum. Suppose we have the following prefix sum:\\n```\\n0      l         r\\n.......a.........b\\n```\\nwhere \\n`l` stands for running sum from source array [0..l],\\n`r` stands for running sum from source array [0..r],\\n\\nthen, `prefix[r] - prefix[l]` is the running sum from source array [l+1..r].\\n\\nThis fits perfectly into our scenario. Here \\n`l` will be `0.5 * age + 7`\\n`r` will be `age` of the current person.\\n\\nOne edge case if when `0.5 * age + 7 > age`, there is no requests can be made.\\nIt happens when age is < 14.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        // age_count[i] means the number of people with age <= i\\n        vector<int> age_count(121, 0);\\n        for(int age: ages)\\n            age_count[age]++;\\n        for(int i=2; i<=120; i++) {\\n            age_count[i] += age_count[i-1];\\n        }\\n        \\n        int requests = 0;\\n        for(int age: ages) {\\n            int left = age*0.5+7; \\n            int right = age;\\n            if(left < right) {\\n                // -1 to excluse self\\n                requests += age_count[right] - age_count[left] - 1; \\n            }\\n        }\\n        \\n        return requests;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n0      l         r\\n.......a.........b\\n```\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        // age_count[i] means the number of people with age <= i\\n        vector<int> age_count(121, 0);\\n        for(int age: ages)\\n            age_count[age]++;\\n        for(int i=2; i<=120; i++) {\\n            age_count[i] += age_count[i-1];\\n        }\\n        \\n        int requests = 0;\\n        for(int age: ages) {\\n            int left = age*0.5+7; \\n            int right = age;\\n            if(left < right) {\\n                // -1 to excluse self\\n                requests += age_count[right] - age_count[left] - 1; \\n            }\\n        }\\n        \\n        return requests;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621896,
                "title": "java-sorting-binary-search-o-n-log-n",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        int n = ages.length, ans = 0;\\n        int [] cnt = new int[121];\\n        for (int i = 0; i<n; i++) {\\n            int lo = 0, hi = i-1, res = -1;\\n            // lower bound\\n            while (lo<=hi) {\\n                int mid = (lo+hi)/2;\\n                if (0.5*ages[i]+7.0>=ages[mid]) {\\n                    lo = mid+1;\\n                }\\n                else {\\n                    hi = mid-1;\\n                    res = mid;\\n                }\\n            }\\n            if (res!=-1) {\\n                ans+=(i-res); \\n                ans+=cnt[ages[i]];\\n            }\\n            cnt[ages[i]]++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        int n = ages.length, ans = 0;\\n        int [] cnt = new int[121];\\n        for (int i = 0; i<n; i++) {\\n            int lo = 0, hi = i-1, res = -1;\\n            // lower bound\\n            while (lo<=hi) {\\n                int mid = (lo+hi)/2;\\n                if (0.5*ages[i]+7.0>=ages[mid]) {\\n                    lo = mid+1;\\n                }\\n                else {\\n                    hi = mid-1;\\n                    res = mid;\\n                }\\n            }\\n            if (res!=-1) {\\n                ans+=(i-res); \\n                ans+=cnt[ages[i]];\\n            }\\n            cnt[ages[i]]++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761812,
                "title": "python-easy-solution-with-sort-and-sliding-window",
                "content": "I think the intuition is pretty simple. Once we look at the rules carefully, we realize that each person wants to Add others who are younger or at the same age at them, but also, not too young.\\nWe use a dict to store the rightmost index of each age at the array. This is to make sure we consider people of the same age.\\nWe also keep a counter at the left side of the array too keep track of ages that are too young to befriend.\\nSo basically, this will end up being very much similar to a typical sliding window approach where we expand the window at each step and shrink it when it starts to become invalid.\\n\\n```\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        right_most = {}\\n        for ix,x in enumerate(ages):\\n            right_most[x] = ix\\n        \\n        l = 0\\n        count = 0\\n        for ix,x in enumerate(ages):\\n            while ages[l]<= (x/2 + 7) and l<right_most[x]:\\n                l+=1\\n            count+= right_most[x] - l\\n        return count\\n",
                "solutionTags": [],
                "code": "I think the intuition is pretty simple. Once we look at the rules carefully, we realize that each person wants to Add others who are younger or at the same age at them, but also, not too young.\\nWe use a dict to store the rightmost index of each age at the array. This is to make sure we consider people of the same age.\\nWe also keep a counter at the left side of the array too keep track of ages that are too young to befriend.\\nSo basically, this will end up being very much similar to a typical sliding window approach where we expand the window at each step and shrink it when it starts to become invalid.\\n\\n```\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        right_most = {}\\n        for ix,x in enumerate(ages):\\n            right_most[x] = ix\\n        \\n        l = 0\\n        count = 0\\n        for ix,x in enumerate(ages):\\n            while ages[l]<= (x/2 + 7) and l<right_most[x]:\\n                l+=1\\n            count+= right_most[x] - l\\n        return count\\n",
                "codeTag": "Python3"
            },
            {
                "id": 565958,
                "title": "python-counting-and-then-one-pass",
                "content": "Calculate the min idx (age) for every age to be considered as friend\\n```\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        cnts = [0] * 121\\n        for age in ages:\\n            cnts[age] += 1\\n        count = cnts\\n        res = 0\\n        for i in range(1,121):\\n            if cnts[i]:\\n                k = int(i* 0.5 + 7)\\n                res += cnts[i]*sum(cnts[k+1:i])\\n                if i>k:\\n                    res += cnts[i]*(cnts[i]-1)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        cnts = [0] * 121\\n        for age in ages:\\n            cnts[age] += 1\\n        count = cnts\\n        res = 0\\n        for i in range(1,121):\\n            if cnts[i]:\\n                k = int(i* 0.5 + 7)\\n                res += cnts[i]*sum(cnts[k+1:i])\\n                if i>k:\\n                    res += cnts[i]*(cnts[i]-1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148918,
                "title": "binary-search-upper-and-lower-bound-solution-java",
                "content": "```\\nclass Solution {\\n     public int numFriendRequests(int[] ages) {\\n        if (ages == null || ages.length == 0) {\\n            return 0;\\n        }\\n        int res = 0;\\n        Arrays.sort(ages);\\n        for (int i : ages) {\\n\\n            int lowerBound = (int )(0.5*i + 8);\\n            int upperBound = i > 100 ? i :  Math.min(100, i);\\n            int index = lower(ages, lowerBound);\\n            int index2 = upper(ages, upperBound);\\n            if (index != -1 && index2 != -1 && index2 >= index) {\\n                res += index2 - index + 1;\\n                if ( i <= upperBound && i >= lowerBound) {\\n                    res--;\\n                }\\n            }\\n\\n        }\\n\\n        return res;\\n\\n    }\\n\\n    public int lower(int[] ages, int target) {\\n        if (ages == null || ages.length == 0) {\\n            return 0;\\n        }\\n        int l = 0;\\n        int r = ages.length - 1;\\n        if (target <= ages[0]) {\\n            return 0;\\n        }\\n        if (target > ages[r]) {\\n            return -1;\\n        }\\n        while (l  <  r) {\\n            int m = l + (r - l ) / 2 ;\\n\\n            if (ages[m] >= target) {\\n                r = m;\\n            }else {\\n                l = m + 1;\\n            }\\n        }\\n        return r;\\n    }\\n\\n    public int upper(int[] ages, int target) {\\n        if (ages == null || ages.length == 0) {\\n            return 0;\\n        }\\n        int l = 0;\\n        int r = ages.length - 1;\\n        if (target < ages[0]) {\\n            return -1;\\n        }\\n        if (target >= ages[r]) {\\n            return r;\\n        }\\n        while (l  <  r - 1) {\\n            int m = l + (r - l ) / 2 ;\\n            if (ages[m] <= target) {\\n                l = m;\\n            }else {\\n                r = m - 1;\\n            }\\n        }\\n        return ages[r] <= target ? r : l;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     public int numFriendRequests(int[] ages) {\\n        if (ages == null || ages.length == 0) {\\n            return 0;\\n        }\\n        int res = 0;\\n        Arrays.sort(ages);\\n        for (int i : ages) {\\n\\n            int lowerBound = (int )(0.5*i + 8);\\n            int upperBound = i > 100 ? i :  Math.min(100, i);\\n            int index = lower(ages, lowerBound);\\n            int index2 = upper(ages, upperBound);\\n            if (index != -1 && index2 != -1 && index2 >= index) {\\n                res += index2 - index + 1;\\n                if ( i <= upperBound && i >= lowerBound) {\\n                    res--;\\n                }\\n            }\\n\\n        }\\n\\n        return res;\\n\\n    }\\n\\n    public int lower(int[] ages, int target) {\\n        if (ages == null || ages.length == 0) {\\n            return 0;\\n        }\\n        int l = 0;\\n        int r = ages.length - 1;\\n        if (target <= ages[0]) {\\n            return 0;\\n        }\\n        if (target > ages[r]) {\\n            return -1;\\n        }\\n        while (l  <  r) {\\n            int m = l + (r - l ) / 2 ;\\n\\n            if (ages[m] >= target) {\\n                r = m;\\n            }else {\\n                l = m + 1;\\n            }\\n        }\\n        return r;\\n    }\\n\\n    public int upper(int[] ages, int target) {\\n        if (ages == null || ages.length == 0) {\\n            return 0;\\n        }\\n        int l = 0;\\n        int r = ages.length - 1;\\n        if (target < ages[0]) {\\n            return -1;\\n        }\\n        if (target >= ages[r]) {\\n            return r;\\n        }\\n        while (l  <  r - 1) {\\n            int m = l + (r - l ) / 2 ;\\n            if (ages[m] <= target) {\\n                l = m;\\n            }else {\\n                r = m - 1;\\n            }\\n        }\\n        return ages[r] <= target ? r : l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 127303,
                "title": "java-two-pointer-o-1-space-solution",
                "content": "ages[A] >= ages[B] > ages[A] * 0.5 +7,\\nB has to be older than 14 to make the above equation valid.\\n\\nThere are two possible directions of requests after we sort ages int[]:\\n1. From upstream bigger or equal number to all people with age bigger than ages[A] * 0.5 +7.\\n2. From downstream to all people with same age upwards in the array\\n\\nFor No.1, one way to is to use binary search to find the lower bound, then add to result, but we can also just keep a pointer j to current upstream number, then keep going down. Since ages are sorted, and the lower bounder if a linear function of ages[A], before we process the higher ages[A] lower bound, we won\\'t have to worry about missing other friend requests from other people with lower ages than A.\\nFor No.2, we keep a state variable ageSame. Each time we find a j, lower j by 1, we compare and see if it has same age as last one, if same, sameAge++, if not, we reset it to 0. \\nLastly, after we break out of for loop, j needs to keep going down until it hits the end or someone with age under 15, with same logic as the for loop.\\n```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        int res = 0;\\n        int sameAge = 0;\\n        int curLowerBound = (int) (ages[ages.length - 1]/2) + 7;\\n        int j = ages.length - 1;\\n        int i = 0;\\n        for (i = ages.length - 2; i >= 0; i--) {\\n            if (ages[i] < 15) break;\\n            while (ages[i] <= curLowerBound) {\\n                res += j - i - 1;\\n                j--;\\n                curLowerBound = (int)(ages[j]/2) + 7;\\n                if (ages[j] == ages[j+1]) {\\n                    sameAge++;\\n                    res += sameAge;\\n                } else sameAge = 0;\\n            }\\n        }\\n\\n        while (j > 0 && ages[j] > 14) {        \\n            res += j - i - 1;\\n            j--;\\n            if (ages[j] == ages[j+1]) {\\n                sameAge++;\\n                res += sameAge;\\n            } else sameAge = 0;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        int res = 0;\\n        int sameAge = 0;\\n        int curLowerBound = (int) (ages[ages.length - 1]/2) + 7;\\n        int j = ages.length - 1;\\n        int i = 0;\\n        for (i = ages.length - 2; i >= 0; i--) {\\n            if (ages[i] < 15) break;\\n            while (ages[i] <= curLowerBound) {\\n                res += j - i - 1;\\n                j--;\\n                curLowerBound = (int)(ages[j]/2) + 7;\\n                if (ages[j] == ages[j+1]) {\\n                    sameAge++;\\n                    res += sameAge;\\n                } else sameAge = 0;\\n            }\\n        }\\n\\n        while (j > 0 && ages[j] > 14) {        \\n            res += j - i - 1;\\n            j--;\\n            if (ages[j] == ages[j+1]) {\\n                sameAge++;\\n                res += sameAge;\\n            } else sameAge = 0;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748863,
                "title": "python-o-n-2-o-nlogn-easy-to-understand",
                "content": "## **1. BRUTE FORCE - O(N^2)**\\n\\nThe Brute Force Solution is pretty simple. For every age, find every other age to which friend request can be sent.\\n\\n\\tIt is given that, \"x\" cannot send a friend request to \"y\" if - \\n\\t\\n\\t\\tage[y] <= 0.5 * age[x] + 7\\n\\t\\tage[y] > age[x]\\n\\t\\tage[y] > 100 && age[x] < 100\\n\\t\\t\\nWe can rewrite these conditions such that,\\n\\n\\t\"x\" can send a friend request to \"y\" if - \\n\\t\\n\\t\\tage[y] > 0.5 * age[x] + 7\\n\\t\\tage[y] <= age[x]\\n\\t\\t\\nWe do not need to care about third condition as that will be covered in the above two because in the above two, we are checking that age of \"y\" should be at most equal to age of \"x\", not more than that. \\n\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        requestCount = 0\\n        \\n        # For every person, we need to find how many friend requests he/she can make\\n        for i in range(len(ages)):\\n            for j in range(len(ages)):\\n                \\n                if i != j:\\n                    # A person \"x\" can send a request to \"y if\\n                    # age[y] > 0.5 * age[x] + 7\\n                    # and age[y] <= age[x]\\n                    \\n                    condition1 = ages[j] > 0.5 * ages[i] + 7\\n                    condition2 = ages[j] <= ages[i]\\n                \\n                    if (condition1 and condition2): requestCount += 1\\n\\n        return requestCount\\n\\t\\t\\n## **2. BINARY SEARCH - O(NLogN)**\\t\\t\\n\\nTake a look at the conditions carefully -\\n\\n\\t\\tage[y] > 0.5 * age[x] + 7\\n\\t\\tage[y] <= age[x]\\n\\t\\t\\n\\nThis means, the range of valid values of age[y] for any age[x] is from -> 0.5 * age[x] + 7 to age[x]\\n\\nHence, for any age[x], we can try to find the smallest possible value in the array that is  > 0.5 * age[x] + 7\\nAnd also, we can try to find the largest possible value that is =<= age[x]\\n\\nAnd then, the number of values in between will be the number of friend requests that x can send.\\n\\nWe can do that using Binary Search but for that, we also need to sort the list first.\\n\\n\\n```\\ndef numFriendRequests(self, ages: List[int]) -> int:\\n        requestCount = 0\\n        \\n        # Sort the list before applying Binary Search on it\\n        ages.sort()\\n        \\n        n = len(ages)\\n        \\n        for i in range(n):\\n\\n            # First, find the index of smallest possible value of \"y\"\\n            # That is, the smallest value in the array that is > 0.5 * age[x] + 7\\n            \\n            leftmostValidIndex = -1\\n            \\n            start, end = 0, n - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if ages[mid] > 0.5 * ages[i] + 7:\\n                    leftmostValidIndex = mid\\n                    end = mid - 1\\n                else: start = mid + 1\\n                    \\n            # If we couldn\\'t find any valid value that is > 0.5 * age[x] + 7\\n            if leftmostValidIndex < 0: continue\\n                    \\n            # Now, find the index of largest possible value of \"y\"\\n            # That is, the largest value in the array that is <= x\\n            \\n            rightmostValidIndex = -1\\n            start, end = 0, n - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if ages[mid] <= ages[i]:\\n                    rightmostValidIndex = mid\\n                    start = mid + 1\\n                else: end = mid - 1\\n                    \\n            # How many ages are there to which we can send friend request?\\n            count = rightmostValidIndex - leftmostValidIndex\\n            requestCount += count if count > 0 else 0\\n            \\n        \\n        return requestCount\\n```\\n\\n\\n## **3. OPTIMIZED BINARY SEARCH FOR DUPLICATE AGES - O(NLogN)**\\t\\t\\n\\nSince ages may be duplicate, why do the same process for an age if we have done it before? \\n\\n```\\ndef numFriendRequests(self, ages: List[int]) -> int:\\n        requestCount = 0\\n        \\n        # Sort the list before applying Binary Search on it\\n        ages.sort()\\n        \\n        n = len(ages)\\n        \\n        # Since there can be duplicate ages\\n        # We can avoid doing same work again for same age\\n        dict = {}\\n        \\n        for i in range(n):\\n            \\n            # Avoid running below code if we have already have the count availabl\\n            # This is for duplicate ages\\n            if ages[i] in dict: \\n                requestCount += dict[ages[i]]\\n                continue\\n\\n            # First, find the index of smallest possible value of \"y\"\\n            # That is, the smallest value in the array that is > 0.5 * age[x] + 7\\n            \\n            leftmostValidIndex = -1\\n            \\n            start, end = 0, n - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if ages[mid] > 0.5 * ages[i] + 7:\\n                    leftmostValidIndex = mid\\n                    end = mid - 1\\n                else: start = mid + 1\\n                    \\n            # If we couldn\\'t find any valid value that is > 0.5 * age[x] + 7\\n            if leftmostValidIndex < 0: continue\\n                    \\n            # Now, find the index of largest possible value of \"y\"\\n            # That is, the largest value in the array that is <= x\\n            \\n            rightmostValidIndex = -1\\n            start, end = 0, n - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if ages[mid] <= ages[i]:\\n                    rightmostValidIndex = mid\\n                    start = mid + 1\\n                else: end = mid - 1\\n                    \\n            # How many ages are there to which we can send friend request?\\n            count = rightmostValidIndex - leftmostValidIndex\\n            \\n            requestCount += count if count > 0 else 0\\n            \\n            # For this age value, how many friend requests can we send?\\n            dict[ages[i]] = count if count > 0 else 0\\n            \\n        \\n        return requestCount\\n```\\n                \\n                \\n                \\n                \\n                \\n                \\n                \\n                \\n                \\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\ndef numFriendRequests(self, ages: List[int]) -> int:\\n        requestCount = 0\\n        \\n        # Sort the list before applying Binary Search on it\\n        ages.sort()\\n        \\n        n = len(ages)\\n        \\n        for i in range(n):\\n\\n            # First, find the index of smallest possible value of \"y\"\\n            # That is, the smallest value in the array that is > 0.5 * age[x] + 7\\n            \\n            leftmostValidIndex = -1\\n            \\n            start, end = 0, n - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if ages[mid] > 0.5 * ages[i] + 7:\\n                    leftmostValidIndex = mid\\n                    end = mid - 1\\n                else: start = mid + 1\\n                    \\n            # If we couldn\\'t find any valid value that is > 0.5 * age[x] + 7\\n            if leftmostValidIndex < 0: continue\\n                    \\n            # Now, find the index of largest possible value of \"y\"\\n            # That is, the largest value in the array that is <= x\\n            \\n            rightmostValidIndex = -1\\n            start, end = 0, n - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if ages[mid] <= ages[i]:\\n                    rightmostValidIndex = mid\\n                    start = mid + 1\\n                else: end = mid - 1\\n                    \\n            # How many ages are there to which we can send friend request?\\n            count = rightmostValidIndex - leftmostValidIndex\\n            requestCount += count if count > 0 else 0\\n            \\n        \\n        return requestCount\\n```\n```\\ndef numFriendRequests(self, ages: List[int]) -> int:\\n        requestCount = 0\\n        \\n        # Sort the list before applying Binary Search on it\\n        ages.sort()\\n        \\n        n = len(ages)\\n        \\n        # Since there can be duplicate ages\\n        # We can avoid doing same work again for same age\\n        dict = {}\\n        \\n        for i in range(n):\\n            \\n            # Avoid running below code if we have already have the count availabl\\n            # This is for duplicate ages\\n            if ages[i] in dict: \\n                requestCount += dict[ages[i]]\\n                continue\\n\\n            # First, find the index of smallest possible value of \"y\"\\n            # That is, the smallest value in the array that is > 0.5 * age[x] + 7\\n            \\n            leftmostValidIndex = -1\\n            \\n            start, end = 0, n - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if ages[mid] > 0.5 * ages[i] + 7:\\n                    leftmostValidIndex = mid\\n                    end = mid - 1\\n                else: start = mid + 1\\n                    \\n            # If we couldn\\'t find any valid value that is > 0.5 * age[x] + 7\\n            if leftmostValidIndex < 0: continue\\n                    \\n            # Now, find the index of largest possible value of \"y\"\\n            # That is, the largest value in the array that is <= x\\n            \\n            rightmostValidIndex = -1\\n            start, end = 0, n - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if ages[mid] <= ages[i]:\\n                    rightmostValidIndex = mid\\n                    start = mid + 1\\n                else: end = mid - 1\\n                    \\n            # How many ages are there to which we can send friend request?\\n            count = rightmostValidIndex - leftmostValidIndex\\n            \\n            requestCount += count if count > 0 else 0\\n            \\n            # For this age value, how many friend requests can we send?\\n            dict[ages[i]] = count if count > 0 else 0\\n            \\n        \\n        return requestCount\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2635031,
                "title": "java-8-feature-s-more-concise-code-3-lines-most-voted",
                "content": "```\\n**UPVOTE PLEASE**\\n\\npublic int numFriendRequests(int[] ages) {\\nvar count = new HashMap<Integer,Integer>();\\n    BiPredicate<Integer,Integer> p=(a,b)->!(b <= 0.5 * a + 7 || b > a || (b > 100 && a < 100));\\n    Arrays.stream(ages).boxed().forEach(age->count.put(age, count.getOrDefault(age,0)+1));\\n    var res = new AtomicInteger(0);\\n    count.keySet().forEach(a->count.keySet().forEach(b->{if (p.test(a, b)){res.set(count.get(a) * (count.get(b) - (a == b ? 1 : 0))+res.get());}}));\\n    return res.get();    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n**UPVOTE PLEASE**\\n\\npublic int numFriendRequests(int[] ages) {\\nvar count = new HashMap<Integer,Integer>();\\n    BiPredicate<Integer,Integer> p=(a,b)->!(b <= 0.5 * a + 7 || b > a || (b > 100 && a < 100));\\n    Arrays.stream(ages).boxed().forEach(age->count.put(age, count.getOrDefault(age,0)+1));\\n    var res = new AtomicInteger(0);\\n    count.keySet().forEach(a->count.keySet().forEach(b->{if (p.test(a, b)){res.set(count.get(a) * (count.get(b) - (a == b ? 1 : 0))+res.get());}}));\\n    return res.get();    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2043130,
                "title": "simple-python-solution-beats-88",
                "content": "\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n\\t    # send request or not\\n        def request(x,y):\\n            if y <= 0.5 * x + 7 or y > x or (y > 100 and x < 100):\\n                return False\\n            return True\\n        \\n\\t\\t# Construct a dictionary that the keys are ages and the values are the frequency of the age in the list. \\n        ages_map = collections.Counter(ages)\\n\\t\\t\\n\\t\\t# Sort age list\\n        ages = list(ages_map.keys())\\n        ages.sort(reverse=True)\\n\\n        count = 0\\n        for i in range(len(ages)):\\n            for j in range(i+1,len(ages)):\\n\\t\\t\\t# Different age: {a:2, b:3}\\n\\t\\t\\t# a --> b :  number of a * number of b\\n                if request(ages[i],ages[j]):\\n                    count += ages_map[ages[i]]* ages_map[ages[j]]\\n            # Same age: {a:2}\\n\\t\\t\\t# a --> a: n * (n -1)\\n\\t\\t\\t\\t# example1 : [16, 16, 16]: request --> True --> 3 * (3-1) = 6\\n\\t\\t\\t\\t# example2: [6,6] : request --> False \\n            if request(ages[i],ages[i]):\\n                count += ages_map[ages[i]]*(ages_map[ages[i]]-1)\\n        return count\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n\\t    # send request or not\\n        def request(x,y):\\n            if y <= 0.5 * x + 7 or y > x or (y > 100 and x < 100):\\n                return False\\n            return True\\n        \\n\\t\\t# Construct a dictionary that the keys are ages and the values are the frequency of the age in the list. \\n        ages_map = collections.Counter(ages)\\n\\t\\t\\n\\t\\t# Sort age list\\n        ages = list(ages_map.keys())\\n        ages.sort(reverse=True)\\n\\n        count = 0\\n        for i in range(len(ages)):\\n            for j in range(i+1,len(ages)):\\n\\t\\t\\t# Different age: {a:2, b:3}\\n\\t\\t\\t# a --> b :  number of a * number of b\\n                if request(ages[i],ages[j]):\\n                    count += ages_map[ages[i]]* ages_map[ages[j]]\\n            # Same age: {a:2}\\n\\t\\t\\t# a --> a: n * (n -1)\\n\\t\\t\\t\\t# example1 : [16, 16, 16]: request --> True --> 3 * (3-1) = 6\\n\\t\\t\\t\\t# example2: [6,6] : request --> False \\n            if request(ages[i],ages[i]):\\n                count += ages_map[ages[i]]*(ages_map[ages[i]]-1)\\n        return count\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1999119,
                "title": "the-actual-facebook-interview-question-java",
                "content": "Thanks to @connect2grp for pointing out an error in my initial solution :)\\n```\\n/*\\nA group of centaurs (mythical half-human, half-horse creatures) all sign up for Facebook accounts at the same time. They immediately start sending each other friend requests, in accordance with the ancient rules that have governed centaur friendship since the dawn of time:\\n\\n1. A centaur will only send a friend request to another centaur if the recipient is at least (X/2 + 7) of the sender\\'s age. For example, a 200-year old centaur can only send friend requests to centaurs that are at least 107 years old.\\n2. A centaur will not send a friend request to another centaur that is older than it is.\\n3. A centaur over 100 years old will not send a friend request to a recipient under 100 years old. But centaurs under 100 years old can friend each other.\\n4. If any of the conditions for sending a friend request are not met, no friend request will be sent.\\nWrite a function that, given an array of centaur ages, returns an integer of the total number of friend requests that the group of centaurs will send to each other.\\n*/\\npublic class Main {\\n    public static void main(String[] args) {\\n        int[] test1 = new int[]{120, 110}; // => 1\\n        int[] test2 = new int[]{120,110,99}; // => 1\\n        int[] test3 = new int[]{120,45,230,400,88,300,101}; // => 4\\n        int[] test4 = new int[]{120,45,55,230,400,88,300,101}; // => 6\\n        int[] test5 = new int[]{100,110,120};\\n    }\\n\\n    public static int numFriendRequests(int[] ages) {\\n        if (ages.length == 0) {\\n            return 0;\\n        }\\n        \\n        Arrays.sort(ages);\\n        int requests = 0;\\n        \\n        for (int i = 0; i < ages.length; i++) {\\n            int curr_age = ages[i];\\n            int left = findIndex(ages, curr_age, curr_age / 2 + 7);\\n            int right = findIndex(ages, curr_age, curr_age);\\n            requests += Math.max(0, right - left);\\n        }\\n        return requests;\\n    }\\n    \\n    public static int findIndex(int[] ages, int curr_age, int target) {\\n        if (curr_age >= 100) {\\n            target = Math.max(target, 100);\\n        }\\n        \\n        int left = 0;\\n        int right = ages.length - 1;\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (ages[mid] >= target) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nA group of centaurs (mythical half-human, half-horse creatures) all sign up for Facebook accounts at the same time. They immediately start sending each other friend requests, in accordance with the ancient rules that have governed centaur friendship since the dawn of time:\\n\\n1. A centaur will only send a friend request to another centaur if the recipient is at least (X/2 + 7) of the sender\\'s age. For example, a 200-year old centaur can only send friend requests to centaurs that are at least 107 years old.\\n2. A centaur will not send a friend request to another centaur that is older than it is.\\n3. A centaur over 100 years old will not send a friend request to a recipient under 100 years old. But centaurs under 100 years old can friend each other.\\n4. If any of the conditions for sending a friend request are not met, no friend request will be sent.\\nWrite a function that, given an array of centaur ages, returns an integer of the total number of friend requests that the group of centaurs will send to each other.\\n*/\\npublic class Main {\\n    public static void main(String[] args) {\\n        int[] test1 = new int[]{120, 110}; // => 1\\n        int[] test2 = new int[]{120,110,99}; // => 1\\n        int[] test3 = new int[]{120,45,230,400,88,300,101}; // => 4\\n        int[] test4 = new int[]{120,45,55,230,400,88,300,101}; // => 6\\n        int[] test5 = new int[]{100,110,120};\\n    }\\n\\n    public static int numFriendRequests(int[] ages) {\\n        if (ages.length == 0) {\\n            return 0;\\n        }\\n        \\n        Arrays.sort(ages);\\n        int requests = 0;\\n        \\n        for (int i = 0; i < ages.length; i++) {\\n            int curr_age = ages[i];\\n            int left = findIndex(ages, curr_age, curr_age / 2 + 7);\\n            int right = findIndex(ages, curr_age, curr_age);\\n            requests += Math.max(0, right - left);\\n        }\\n        return requests;\\n    }\\n    \\n    public static int findIndex(int[] ages, int curr_age, int target) {\\n        if (curr_age >= 100) {\\n            target = Math.max(target, 100);\\n        }\\n        \\n        int left = 0;\\n        int right = ages.length - 1;\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (ages[mid] >= target) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1973990,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> v(121,0);\\n        int n=ages.size();\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            v[ages[i]]++;\\n        }\\n        \\n        int ans=0;\\n        \\n        for(int i=15;i<=120;i++)\\n        {\\n            ans+=v[i]*(v[i]-1);\\n        }\\n        \\n        for(int i=1;i<=120;i++)\\n        {\\n            for(int j=1;j<i;j++)\\n            {\\n                if(j>(i/2)+7)\\n                {\\n                    ans+=v[i]*v[j];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> v(121,0);\\n        int n=ages.size();\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            v[ages[i]]++;\\n        }\\n        \\n        int ans=0;\\n        \\n        for(int i=15;i<=120;i++)\\n        {\\n            ans+=v[i]*(v[i]-1);\\n        }\\n        \\n        for(int i=1;i<=120;i++)\\n        {\\n            for(int j=1;j<i;j++)\\n            {\\n                if(j>(i/2)+7)\\n                {\\n                    ans+=v[i]*v[j];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1855680,
                "title": "javascript-cumulative-sum-o-n",
                "content": "This approach uses multiple O(Max(N, 120)) passes and O(Max(N, 120)) auxiliary space.\\nPlease let me know if you have suggestions for improvement or if my time / space analysis is off.\\n\\nGeneral Approach:\\nAnother way to rephrase the requirements is that, for each age X, there is an acceptable age interval [Y1, Y2]  to which we can send friend requests.\\nLower boundary (Y1): Y must be > 7 + 0.5 * X\\nUpper boundary (Y2): Y must be <= X\\nThe last condition described in the problem (\"no request sent if X < 100 and Y > 100\") is essentially covered by our upper bound, so the problem can really be reduced to dealing with the interval described above.\\n\\n\\n```\\nvar numFriendRequests = function(ages) {\\n    let count = 0;\\n    \\n    const ageCountMap = new Map(); // S: O(N)\\n    const ageCountArr = [0]; // S: O(120)\\n    \\n    // Count how many people have a certain age.\\n    for (let age of ages) { // T: O(N)\\n        let currCount = ageCountMap.get(age) || 0;\\n        ageCountMap.set(age, currCount + 1);\\n    }\\n    // Count how many people have up to (and including) a certain age\\n    for (let i = 1; i <= 120; i++) { // T: O(120)\\n        let ageCount = ageCountMap.get(i) || 0;\\n        ageCountArr.push(ageCount + ageCountArr[i - 1]);\\n    }\\n    \\n    for (let age of ages) { // T: O(N)\\n        let lowerBound = Math.floor((age * 0.5)) + 7 + 1; // Inclusive\\n        let upperBound = age; // Inclusive\\n\\t\\t// Calculate requests by subtracting cumulative sum up to the lower bound from the cumulative sum up to the upper bound\\n\\t\\t// Need \"-1\" to deduct a given person from the request, since we can\\'t send requests to ourselves\\n        let requests = ageCountArr[upperBound] - ageCountArr[lowerBound - 1] - 1; \\n        if (requests < 0) continue;\\n        count += requests;\\n    }\\n    return count;\\n};",
                "solutionTags": [
                    "Array"
                ],
                "code": "This approach uses multiple O(Max(N, 120)) passes and O(Max(N, 120)) auxiliary space.\\nPlease let me know if you have suggestions for improvement or if my time / space analysis is off.\\n\\nGeneral Approach:\\nAnother way to rephrase the requirements is that, for each age X, there is an acceptable age interval [Y1, Y2]  to which we can send friend requests.\\nLower boundary (Y1): Y must be > 7 + 0.5 * X\\nUpper boundary (Y2): Y must be <= X\\nThe last condition described in the problem (\"no request sent if X < 100 and Y > 100\") is essentially covered by our upper bound, so the problem can really be reduced to dealing with the interval described above.\\n\\n\\n```\\nvar numFriendRequests = function(ages) {\\n    let count = 0;\\n    \\n    const ageCountMap = new Map(); // S: O(N)\\n    const ageCountArr = [0]; // S: O(120)\\n    \\n    // Count how many people have a certain age.\\n    for (let age of ages) { // T: O(N)\\n        let currCount = ageCountMap.get(age) || 0;\\n        ageCountMap.set(age, currCount + 1);\\n    }\\n    // Count how many people have up to (and including) a certain age\\n    for (let i = 1; i <= 120; i++) { // T: O(120)\\n        let ageCount = ageCountMap.get(i) || 0;\\n        ageCountArr.push(ageCount + ageCountArr[i - 1]);\\n    }\\n    \\n    for (let age of ages) { // T: O(N)\\n        let lowerBound = Math.floor((age * 0.5)) + 7 + 1; // Inclusive\\n        let upperBound = age; // Inclusive\\n\\t\\t// Calculate requests by subtracting cumulative sum up to the lower bound from the cumulative sum up to the upper bound\\n\\t\\t// Need \"-1\" to deduct a given person from the request, since we can\\'t send requests to ourselves\\n        let requests = ageCountArr[upperBound] - ageCountArr[lowerBound - 1] - 1; \\n        if (requests < 0) continue;\\n        count += requests;\\n    }\\n    return count;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1397398,
                "title": "java-easy-map",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n         Map<Integer,Integer> mp = new HashMap<>();\\n      \\n         for(int age : ages){\\n            mp.put(age,mp.getOrDefault(age,0) + 1);\\n         }\\n        int count = 0; //count of friend requests\\n        for(int a : mp.keySet()){\\n           for(int b : mp.keySet()){\\n              if(canSendFReq(a,b) == true){\\n                  int AsF = mp.get(a); //A\\'s Friends\\n                  int BsF = mp.get(b); //B\\'s Friends\\n                //As a person cannot send req to himself\\n                  if(a == b){\\n                     BsF--;   //Reduce B\\'s friends by one as B is iterating inside the inner loop\\n                  }\\n\\t\\t\\t   //As both of them gonna sent req to each other (also persons with same ages will be doing same thing)\\n                 count = count + AsF * BsF;\\n              }\\n           }\\n        }\\n      return count;\\n    }\\n    public boolean canSendFReq(int x,int y){\\n        return !(y <= 0.5 * x + 7 || y > x || (y > 100 && x < 100));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n         Map<Integer,Integer> mp = new HashMap<>();\\n      \\n         for(int age : ages){\\n            mp.put(age,mp.getOrDefault(age,0) + 1);\\n         }\\n        int count = 0; //count of friend requests\\n        for(int a : mp.keySet()){\\n           for(int b : mp.keySet()){\\n              if(canSendFReq(a,b) == true){\\n                  int AsF = mp.get(a); //A\\'s Friends\\n                  int BsF = mp.get(b); //B\\'s Friends\\n                //As a person cannot send req to himself\\n                  if(a == b){\\n                     BsF--;   //Reduce B\\'s friends by one as B is iterating inside the inner loop\\n                  }\\n\\t\\t\\t   //As both of them gonna sent req to each other (also persons with same ages will be doing same thing)\\n                 count = count + AsF * BsF;\\n              }\\n           }\\n        }\\n      return count;\\n    }\\n    public boolean canSendFReq(int x,int y){\\n        return !(y <= 0.5 * x + 7 || y > x || (y > 100 && x < 100));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297207,
                "title": "javascript-solution-cumulative-sum-and-sliding-window",
                "content": "```\\nvar numFriendRequests = function(ages) {\\n    const count = new Array(121).fill(0);\\n    \\n    ages.forEach((age) => count[age]++);\\n\\n    let res = 0; // total friend request sent\\n    let tot = 0;  // cumulative count of people so far\\n    \\n    for (let i = 0; i <= 120; i++) {\\n\\n        if (i > 14 && count[i] != 0) {\\n            const limit = Math.floor(0.5 * i) + 7;\\n            const rest = tot - count[limit];\\n\\n            res += (count[i] * rest); // current age group send friend request to other people who are within their limit\\n            res += (count[i] * (count[i] - 1)); // current age group send friend request to each other\\n        }\\n\\n        tot += count[i];\\n        count[i] = tot; \\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nvar numFriendRequests = function(ages) {\\n    const count = new Array(121).fill(0);\\n    \\n    ages.forEach((age) => count[age]++);\\n\\n    let res = 0; // total friend request sent\\n    let tot = 0;  // cumulative count of people so far\\n    \\n    for (let i = 0; i <= 120; i++) {\\n\\n        if (i > 14 && count[i] != 0) {\\n            const limit = Math.floor(0.5 * i) + 7;\\n            const rest = tot - count[limit];\\n\\n            res += (count[i] * rest); // current age group send friend request to other people who are within their limit\\n            res += (count[i] * (count[i] - 1)); // current age group send friend request to each other\\n        }\\n\\n        tot += count[i];\\n        count[i] = tot; \\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1216308,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n            int k , count=0;\\n               sort(ages.begin(),ages.end());\\n        for(int i=ages.size()-1;i>0;i--)\\n        {\\n                  k=upper_bound(ages.begin(),ages.begin()+i,((ages[i]/2)+7))-ages.begin(); \\n\\t\\t\\t\\t       // it returns the index that is greater than (ages[i]/2+7) \\n             \\n                     if(k<=i)  \\n                      {\\n\\t\\t\\t\\t\\t       count+=i-k;   // i-k gives the no of requests can ages[i] can send \\n\\t\\t\\t\\t\\t  }   \\n\\t\\t\\t\\t\\t     // k is greater than i if upper_bound of (ages[i]/2+7)  is not found\\n              \\n\\t\\t\\t      k=i-1;\\n               while(k>=0&&ages[k]==ages[i]&&ages[k]>((ages[i]/2)+7))\\n               {\\n                   count++;\\n                   k--;\\n               }\\n\\t\\t\\t   // to check if there are any equal ages and also satisfy (ages[i]/2+7)  condition\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n            int k , count=0;\\n               sort(ages.begin(),ages.end());\\n        for(int i=ages.size()-1;i>0;i--)\\n        {\\n                  k=upper_bound(ages.begin(),ages.begin()+i,((ages[i]/2)+7))-ages.begin(); \\n\\t\\t\\t\\t       // it returns the index that is greater than (ages[i]/2+7) \\n             \\n                     if(k<=i)  \\n                      {\\n\\t\\t\\t\\t\\t       count+=i-k;   // i-k gives the no of requests can ages[i] can send \\n\\t\\t\\t\\t\\t  }   \\n\\t\\t\\t\\t\\t     // k is greater than i if upper_bound of (ages[i]/2+7)  is not found\\n              \\n\\t\\t\\t      k=i-1;\\n               while(k>=0&&ages[k]==ages[i]&&ages[k]>((ages[i]/2)+7))\\n               {\\n                   count++;\\n                   k--;\\n               }\\n\\t\\t\\t   // to check if there are any equal ages and also satisfy (ages[i]/2+7)  condition\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1066096,
                "title": "evolve-from-brute-force-to-optimal",
                "content": "1. Brute force O(n^2)\\n```\\n\\tpublic int numFriendRequests(int[] ages) {\\n        int num=0,n =ages.length;\\n        for(int i=0;i<n-1;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(canMakeRequest(ages[i],ages[j])) {\\n                    num++;\\n                }\\n                if(canMakeRequest(ages[j],ages[i])) {\\n                    num++;\\n                }\\n            }\\n        }\\n        return num;\\n    }\\n    private boolean canMakeRequest(int from, int to) {\\n        return to<=from && to>0.5*from+7;\\n    }\\n```\\n2. Binary search O(nlogn). B is in (0.5A+7, A]. We can sort the array and compute number of Bs for each A.\\n```\\n\\tpublic int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        int num=0;\\n        for(int i=0;i<ages.length;i++) {\\n            int left = leftBound(ages[i]/2+8,ages), right = rightBound(ages[i], ages);\\n            num+=Math.max(right-left,0);   \\n        }\\n        return num;\\n    }\\n    private int leftBound(int target, int[] ages) {\\n        int l=0, r=ages.length-1;\\n        while(l<r) {\\n            int mid = (l+r)/2;\\n            if(ages[mid]<target) {\\n                l = mid+1;\\n            } else {\\n                r = mid;\\n            }\\n        }\\n        return r;\\n    }\\n    private int rightBound(int target, int[] ages) {\\n        int l=0, r=ages.length-1;\\n        while(l<r) {\\n            int mid = (l+r+1)/2;\\n            if(ages[mid]<=target) {\\n                l = mid;\\n            } else {\\n                r = mid-1;\\n            }\\n        }\\n        return l;\\n    }\\n```\\n3. Bucket sort O(n)\\n```\\n\\tpublic int numFriendRequests(int[] ages) {\\n        int[] count = new int[121];\\n        for(int age:ages) {\\n            count[age]++;\\n        }\\n        int num=0;\\n        for(int i=1;i<=120;i++) {\\n            for(int j=i/2+8;j<=i;j++) {\\n                if(i == j) {\\n                    num += count[i]*(count[i]-1);\\n                } else {\\n                    num += count[i]*count[j];   \\n                }\\n            }\\n        }\\n        return num;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int numFriendRequests(int[] ages) {\\n        int num=0,n =ages.length;\\n        for(int i=0;i<n-1;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(canMakeRequest(ages[i],ages[j])) {\\n                    num++;\\n                }\\n                if(canMakeRequest(ages[j],ages[i])) {\\n                    num++;\\n                }\\n            }\\n        }\\n        return num;\\n    }\\n    private boolean canMakeRequest(int from, int to) {\\n        return to<=from && to>0.5*from+7;\\n    }\\n```\n```\\n\\tpublic int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        int num=0;\\n        for(int i=0;i<ages.length;i++) {\\n            int left = leftBound(ages[i]/2+8,ages), right = rightBound(ages[i], ages);\\n            num+=Math.max(right-left,0);   \\n        }\\n        return num;\\n    }\\n    private int leftBound(int target, int[] ages) {\\n        int l=0, r=ages.length-1;\\n        while(l<r) {\\n            int mid = (l+r)/2;\\n            if(ages[mid]<target) {\\n                l = mid+1;\\n            } else {\\n                r = mid;\\n            }\\n        }\\n        return r;\\n    }\\n    private int rightBound(int target, int[] ages) {\\n        int l=0, r=ages.length-1;\\n        while(l<r) {\\n            int mid = (l+r+1)/2;\\n            if(ages[mid]<=target) {\\n                l = mid;\\n            } else {\\n                r = mid-1;\\n            }\\n        }\\n        return l;\\n    }\\n```\n```\\n\\tpublic int numFriendRequests(int[] ages) {\\n        int[] count = new int[121];\\n        for(int age:ages) {\\n            count[age]++;\\n        }\\n        int num=0;\\n        for(int i=1;i<=120;i++) {\\n            for(int j=i/2+8;j<=i;j++) {\\n                if(i == j) {\\n                    num += count[i]*(count[i]-1);\\n                } else {\\n                    num += count[i]*count[j];   \\n                }\\n            }\\n        }\\n        return num;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1022078,
                "title": "python-3-sliding-window-beats-99-6",
                "content": "Nothing fancy, I just applied counter to speed up processing same agers.\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages = sorted(Counter(ages).items(), key=lambda x: x[0])\\n\\n        def calc(arr):\\n            total = 0\\n            window = 0\\n            left = 0\\n            for right, (age, count) in enumerate(arr):\\n                while left < right and arr[left][0] <= 0.5 * age + 7:\\n                    window -= arr[left][1]\\n                    left += 1\\n                total += window * count\\n                if count > 1 and age > 0.5 * age + 7:\\n                    total += (count - 1) * count\\n                window += count\\n            return total\\n\\n        return calc(ages)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages = sorted(Counter(ages).items(), key=lambda x: x[0])\\n\\n        def calc(arr):\\n            total = 0\\n            window = 0\\n            left = 0\\n            for right, (age, count) in enumerate(arr):\\n                while left < right and arr[left][0] <= 0.5 * age + 7:\\n                    window -= arr[left][1]\\n                    left += 1\\n                total += window * count\\n                if count > 1 and age > 0.5 * age + 7:\\n                    total += (count - 1) * count\\n                window += count\\n            return total\\n\\n        return calc(ages)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923906,
                "title": "java-1-ms-faster-than-100-00-40-9-mb-less-than-7-93",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] cnts = new int[121];\\n        int[] sums = new int[121];\\n        for (int age : ages) {\\n            ++cnts[age];\\n        }\\n        for (int i = 1; i <= 120; ++i) {\\n            sums[i] = sums[i - 1] + cnts[i];\\n        }\\n        int sum = 0;\\n        for (int i = 15; i <= 120; ++i) {\\n            if (cnts[i] <= 0) {\\n                continue;\\n            }\\n            int cnt = sums[i] - sums[i / 2 + 7];\\n            sum += (cnt - 1) * cnts[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] cnts = new int[121];\\n        int[] sums = new int[121];\\n        for (int age : ages) {\\n            ++cnts[age];\\n        }\\n        for (int i = 1; i <= 120; ++i) {\\n            sums[i] = sums[i - 1] + cnts[i];\\n        }\\n        int sum = 0;\\n        for (int i = 15; i <= 120; ++i) {\\n            if (cnts[i] <= 0) {\\n                continue;\\n            }\\n            int cnt = sums[i] - sums[i / 2 + 7];\\n            sum += (cnt - 1) * cnts[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388169,
                "title": "wrong-test-case",
                "content": "```\\nInput: [16,17,18]\\nOutput: 2\\nExplanation: Friend requests are made 17 -> 16, 18 -> 17.\\n```\\n\\nIn this given test case, how come ages[2] doesn\\'t friend request ages[0]? (i.e. why is 18 -> 16 invalid?)",
                "solutionTags": [],
                "code": "```\\nInput: [16,17,18]\\nOutput: 2\\nExplanation: Friend requests are made 17 -> 16, 18 -> 17.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 330880,
                "title": "python-sliding-window-one-pass",
                "content": "I use `L` and `R` to maintain a sliding window to calculate the requests made from the current element to elements in the window.\\nAnd I also use the varible `n` to calculate the request made from within the window to the current element ( Since we have sorted the array, the elements which made requests from within the window must have the same value with the current element).\\n```python\\ndef numFriendRequests(self, ages):\\n    ages.sort()\\n    L = res = n = 0\\n    for R, V in enumerate(ages):\\n        limit = V/2 + 7\\n        while L < R and ages[L] <= limit:\\n            L += 1\\n        n = n+1 if R and ages[R] == ages[R-1] and ages[R] > 14 else 0\\n        res += R-L+n\\n    return res\\n```",
                "solutionTags": [],
                "code": "```python\\ndef numFriendRequests(self, ages):\\n    ages.sort()\\n    L = res = n = 0\\n    for R, V in enumerate(ages):\\n        limit = V/2 + 7\\n        while L < R and ages[L] <= limit:\\n            L += 1\\n        n = n+1 if R and ages[R] == ages[R-1] and ages[R] > 14 else 0\\n        res += R-L+n\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 282361,
                "title": "o-n-high-school-logic-a-2-7-b-a",
                "content": "A cannot send B request if (B<=A/2+7) || (B>A) || (B>100&&A<100). Then\\nA can send B request if ![(B<=A/2+7) || (B>A) || (B>100&&A<100)], which is equivalent to\\nA/2+7<B<=A && (B<=100 || A>=100).\\nLastly, we can see that (B<=100 || A>=100) is redundant, this is because (1) if A >= 100, we don\\'t need to consider B, since the boolean expression is already true. (2) if A <100, then by B<=A, B has to be less than 100, hence B<=100 is true. Hence, the restriction can be reduced to A/2+7<B<=A. By simple algebra, we can see that A/2+7<A, A>14.\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> count(121, 0);\\n        for(auto age : ages) count[age] += 1;\\n        //A send request to B if A/2+7<B<=A && (B<=100 || A >=100)\\n        int ret = 0;\\n        for(int A=15; A<=120; A++) {\\n            for(int B=A/2+8; B<=A; B++) {\\n                if(B < A) ret += count[B]*count[A];\\n                else if(B == A) ret += count[A] * (count[A]-1);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```\\nThe above time complexity is O(N^2), however If we watch the second loop carefully, we can see that it is actually the **count[A]\\\\*(range sum of count[A/2+8 : A] - 1)**, hence we can use prefix sum to handle it quickly in O(N). The optimization is shown below.\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> count(121, 0);\\n        for(auto age : ages) count[age] += 1;\\n        for(int i=1; i<=120; i++) count[i] += count[i-1];\\n        int ret = 0;\\n        for(int A=15; A<=120; A++) {\\n            int B = A/2+8;\\n            ret += (count[A]-count[A-1]) * (count[A] - count[B-1] - 1);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> count(121, 0);\\n        for(auto age : ages) count[age] += 1;\\n        //A send request to B if A/2+7<B<=A && (B<=100 || A >=100)\\n        int ret = 0;\\n        for(int A=15; A<=120; A++) {\\n            for(int B=A/2+8; B<=A; B++) {\\n                if(B < A) ret += count[B]*count[A];\\n                else if(B == A) ret += count[A] * (count[A]-1);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> count(121, 0);\\n        for(auto age : ages) count[age] += 1;\\n        for(int i=1; i<=120; i++) count[i] += count[i-1];\\n        int ret = 0;\\n        for(int A=15; A<=120; A++) {\\n            int B = A/2+8;\\n            ret += (count[A]-count[A-1]) * (count[A] - count[B-1] - 1);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126969,
                "title": "python-collections-counter-ac-solution",
                "content": "```\\nfrom collections import Counter\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cntr=Counter(ages)\\n        res=0\\n        for A in cntr:\\n            for B in cntr:\\n                if A==B:\\n                    if B<=0.5*A+7 or B>A or (B>100 and A<100): continue\\n                    res+=(cntr[A]*(cntr[A]-1))\\n                else:\\n                    if B<=0.5*A+7 or B>A or (B>100 and A<100): continue\\n                    res+=cntr[A]*cntr[B]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cntr=Counter(ages)\\n        res=0\\n        for A in cntr:\\n            for B in cntr:\\n                if A==B:\\n                    if B<=0.5*A+7 or B>A or (B>100 and A<100): continue\\n                    res+=(cntr[A]*(cntr[A]-1))\\n                else:\\n                    if B<=0.5*A+7 or B>A or (B>100 and A<100): continue\\n                    res+=cntr[A]*cntr[B]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126943,
                "title": "simple-java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        if(ages.length < 2) return 0;\\n        int[] cnt = new int[125];\\n        for(int n:ages){\\n            cnt[n]++;\\n        }\\n        int res = 0;\\n        for(int i=2;i<=120;i++){\\n            if(cnt[i] == 0) continue;\\n            int total = 0;\\n            int start = (int)(0.5 * i) + 8;    \\n            if(start > i) continue;// violates this rule age[B] <= 0.5 * age[A] + 7...so skip this i\\n            for(int j=start;j<i;j++){\\n                total += cnt[j];\\n            }            \\n            if(cnt[i] > 1)\\n                total += (cnt[i] - 1);            \\n            res += (total * cnt[i]);\\n        }\\n        return res;\\n    }\\n}\\n```\\nNote: Please see comments for explanation",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        if(ages.length < 2) return 0;\\n        int[] cnt = new int[125];\\n        for(int n:ages){\\n            cnt[n]++;\\n        }\\n        int res = 0;\\n        for(int i=2;i<=120;i++){\\n            if(cnt[i] == 0) continue;\\n            int total = 0;\\n            int start = (int)(0.5 * i) + 8;    \\n            if(start > i) continue;// violates this rule age[B] <= 0.5 * age[A] + 7...so skip this i\\n            for(int j=start;j<i;j++){\\n                total += cnt[j];\\n            }            \\n            if(cnt[i] > 1)\\n                total += (cnt[i] - 1);            \\n            res += (total * cnt[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126935,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int freq [] = new int [121];\\n        int ret = 0;\\n        \\n        for(int i = 0; i < ages.length; i++){\\n            freq[ages[i]]++;\\n        }\\n        \\n        for(int i = 1; i <= 120; i++){\\n            for(int j = 1; j <= 120; j++){\\n                if(!((j <= 0.5 * i + 7) || (j > i) || (j > 100 && i < 100))){\\n                    if(i == j) {\\n                        ret = ret + ((freq[i] * (freq[i] - 1)));\\n                    } else {\\n                        ret = ret + (freq[i] * freq[j]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int freq [] = new int [121];\\n        int ret = 0;\\n        \\n        for(int i = 0; i < ages.length; i++){\\n            freq[ages[i]]++;\\n        }\\n        \\n        for(int i = 1; i <= 120; i++){\\n            for(int j = 1; j <= 120; j++){\\n                if(!((j <= 0.5 * i + 7) || (j > i) || (j > 100 && i < 100))){\\n                    if(i == j) {\\n                        ret = ret + ((freq[i] * (freq[i] - 1)));\\n                    } else {\\n                        ret = ret + (freq[i] * freq[j]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034801,
                "title": "best-java-solution-beats-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int map[]=new int[121];\\n        for(int j=0;j<ages.length;j++){\\n            map[ages[j]]++;\\n        }\\n\\n        for(int i=1;i<=120;i++){\\n            map[i]+=map[i-1];\\n        }\\n        int totalFriend=0;\\n        for(int i=0;i<ages.length;i++){\\n            int cond=ages[i]/2+7;\\n            if(cond>=ages[i]){\\n                continue;\\n            }\\n            totalFriend+=map[ages[i]]-map[cond]-1;\\n        }\\n        return totalFriend;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int map[]=new int[121];\\n        for(int j=0;j<ages.length;j++){\\n            map[ages[j]]++;\\n        }\\n\\n        for(int i=1;i<=120;i++){\\n            map[i]+=map[i-1];\\n        }\\n        int totalFriend=0;\\n        for(int i=0;i<ages.length;i++){\\n            int cond=ages[i]/2+7;\\n            if(cond>=ages[i]){\\n                continue;\\n            }\\n            totalFriend+=map[ages[i]]-map[cond]-1;\\n        }\\n        return totalFriend;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481569,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> v(121, 0);\\n        for(auto it: ages)\\n            v[it]++;\\n        int ans=0;\\n        for(int i=1; i<121; i++)\\n        {\\n            if(v[i]==0) continue;\\n            int tmp =0;\\n            for(int j=1; j<121; j++)\\n            {\\n                if(v[j]==0) continue;\\n                if(i==j)\\n                {\\n                    if(j>(i*0.5+7))\\n                        tmp+=(v[i]-1);\\n                }\\n                else\\n                {\\n                    bool flag= true;\\n                    if(j<=(i*0.5+7)) flag= false;\\n                    if(j>i) flag= false;\\n                    if(i<100 && j>100) flag= false;\\n                    if(flag)\\n                        tmp+=v[j];\\n                }\\n            }\\n            ans= ans + v[i]*tmp;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass FriendRequest:\\n    def _binarySearch(self, ages, target):\\n        lo = 0\\n        hi = len(ages) - 1\\n        while lo <= hi:\\n            mid = lo + (hi - lo) // 2\\n            if ages[mid] <= target:\\n                lo = mid + 1\\n            else:\\n                hi = mid - 1\\n        return lo\\n    \\n    def numOfRequests(self, ages):\\n        requests = 0\\n        ages.sort()\\n        for age in ages:\\n            left = self._binarySearch(ages, age // 2 + 7)\\n            right = self._binarySearch(ages, age) - 1\\n            requests += max(0, right - left)\\n        return requests\\n\\nclass FriendRequest2:\\n    def _bucketSort(self, ages):\\n        buckets = [0] * 121\\n        for age in ages:\\n            buckets[age] += 1\\n        return buckets\\n    \\n    def _buildPrefixSum(self, buckets):\\n        prefix = [0] * 121\\n        for i in range(1, 121):\\n            prefix[i] += prefix[i - 1] + buckets[i]\\n        return prefix\\n    \\n    def numOfRequests(self, ages):\\n        buckets = self._bucketSort(ages)\\n        prefix = self._buildPrefixSum(buckets)\\n        requests = 0\\n        for age in range(15, 121):\\n            if buckets[age] == 0:\\n                continue\\n            cur_requests = prefix[age] - prefix[age // 2 + 7]\\n            requests += buckets[age] * cur_requests - buckets[age]\\n        return requests\\n\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        return FriendRequest2().numOfRequests(ages)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int res = 0;\\n        int[] numInAge = new int[121], sumInAge = new int[121];\\n        for(int a : ages) {\\n            numInAge[a]++;\\n        }\\n        for(int i = 1; i <= 120; i++) {\\n            sumInAge[i] = numInAge[i] + sumInAge[i-1];\\n        }\\n        for(int i = 15; i <= 120; i++) {\\n            if (numInAge[i] == 0)   continue;\\n            int c = sumInAge[i] - sumInAge[i/2 + 7];\\n            res += c * numInAge[i] - numInAge[i];\\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> v(121, 0);\\n        for(auto it: ages)\\n            v[it]++;\\n        int ans=0;\\n        for(int i=1; i<121; i++)\\n        {\\n            if(v[i]==0) continue;\\n            int tmp =0;\\n            for(int j=1; j<121; j++)\\n            {\\n                if(v[j]==0) continue;\\n                if(i==j)\\n                {\\n                    if(j>(i*0.5+7))\\n                        tmp+=(v[i]-1);\\n                }\\n                else\\n                {\\n                    bool flag= true;\\n                    if(j<=(i*0.5+7)) flag= false;\\n                    if(j>i) flag= false;\\n                    if(i<100 && j>100) flag= false;\\n                    if(flag)\\n                        tmp+=v[j];\\n                }\\n            }\\n            ans= ans + v[i]*tmp;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass FriendRequest:\\n    def _binarySearch(self, ages, target):\\n        lo = 0\\n        hi = len(ages) - 1\\n        while lo <= hi:\\n            mid = lo + (hi - lo) // 2\\n            if ages[mid] <= target:\\n                lo = mid + 1\\n            else:\\n                hi = mid - 1\\n        return lo\\n    \\n    def numOfRequests(self, ages):\\n        requests = 0\\n        ages.sort()\\n        for age in ages:\\n            left = self._binarySearch(ages, age // 2 + 7)\\n            right = self._binarySearch(ages, age) - 1\\n            requests += max(0, right - left)\\n        return requests\\n\\nclass FriendRequest2:\\n    def _bucketSort(self, ages):\\n        buckets = [0] * 121\\n        for age in ages:\\n            buckets[age] += 1\\n        return buckets\\n    \\n    def _buildPrefixSum(self, buckets):\\n        prefix = [0] * 121\\n        for i in range(1, 121):\\n            prefix[i] += prefix[i - 1] + buckets[i]\\n        return prefix\\n    \\n    def numOfRequests(self, ages):\\n        buckets = self._bucketSort(ages)\\n        prefix = self._buildPrefixSum(buckets)\\n        requests = 0\\n        for age in range(15, 121):\\n            if buckets[age] == 0:\\n                continue\\n            cur_requests = prefix[age] - prefix[age // 2 + 7]\\n            requests += buckets[age] * cur_requests - buckets[age]\\n        return requests\\n\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        return FriendRequest2().numOfRequests(ages)\\n```\n```Java []\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int res = 0;\\n        int[] numInAge = new int[121], sumInAge = new int[121];\\n        for(int a : ages) {\\n            numInAge[a]++;\\n        }\\n        for(int i = 1; i <= 120; i++) {\\n            sumInAge[i] = numInAge[i] + sumInAge[i-1];\\n        }\\n        for(int i = 15; i <= 120; i++) {\\n            if (numInAge[i] == 0)   continue;\\n            int c = sumInAge[i] - sumInAge[i/2 + 7];\\n            res += c * numInAge[i] - numInAge[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230757,
                "title": "golang-two-pointers",
                "content": "It is a straightforward solution but took a bit of time to get it right for people with same ages.\\n\\n```go\\nfunc numFriendRequests(ages []int) int {\\n  // Let\\'s sort the ages in ascendig order\\n  sort.Ints(ages)\\n  counts := make(map[int]int)\\n  // Keep track of the first occurrence of each age in the sorted order\\n  // so that we can get the number of people that are below the current age\\n  // and the other same age people that we can send friend requests to.\\n  first := make(map[int]int)\\n  for i := 0; i < len(ages); i++ {\\n    counts[ages[i]]++\\n    if _, ok := first[ages[i]]; !ok {\\n      first[ages[i]] = i\\n    }\\n  }\\n  // We\\'re going to use a two pointers approach. Left is updated to point to the\\n  // person with the minimum age that follows the requirements for the current person.\\n  // Then the number of people the current person can send friend requests to is the\\n  // number of people between pointed by left and current person (excluding)\\n  left := 0\\n  var res int\\n  for right := 0; right < len(ages); right++ {\\n    minAge := float64(ages[right]) * 0.5 + 7.0\\n    for left < right && float64(ages[left]) <= minAge {\\n      left++\\n    }\\n    // left can move forward when we have the same age repeated\\n    res += first[ages[right]] - min(first[ages[right]], left)\\n    if float64(ages[right]) > minAge {\\n      res += counts[ages[right]]-1\\n    }\\n  }\\n  return res\\n}\\n\\nfunc min(a, b int) int {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```go\\nfunc numFriendRequests(ages []int) int {\\n  // Let\\'s sort the ages in ascendig order\\n  sort.Ints(ages)\\n  counts := make(map[int]int)\\n  // Keep track of the first occurrence of each age in the sorted order\\n  // so that we can get the number of people that are below the current age\\n  // and the other same age people that we can send friend requests to.\\n  first := make(map[int]int)\\n  for i := 0; i < len(ages); i++ {\\n    counts[ages[i]]++\\n    if _, ok := first[ages[i]]; !ok {\\n      first[ages[i]] = i\\n    }\\n  }\\n  // We\\'re going to use a two pointers approach. Left is updated to point to the\\n  // person with the minimum age that follows the requirements for the current person.\\n  // Then the number of people the current person can send friend requests to is the\\n  // number of people between pointed by left and current person (excluding)\\n  left := 0\\n  var res int\\n  for right := 0; right < len(ages); right++ {\\n    minAge := float64(ages[right]) * 0.5 + 7.0\\n    for left < right && float64(ages[left]) <= minAge {\\n      left++\\n    }\\n    // left can move forward when we have the same age repeated\\n    res += first[ages[right]] - min(first[ages[right]], left)\\n    if float64(ages[right]) > minAge {\\n      res += counts[ages[right]]-1\\n    }\\n  }\\n  return res\\n}\\n\\nfunc min(a, b int) int {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2648164,
                "title": "cpp-easy-solution",
                "content": "Any person of age x will send request to every person of age from 0.5x + 7(not including) to x(including). The minus sign is because we are also adding the person itself and acccording to the question the person himself cannot send request to himself. \\n\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int* temp = new int[122]{0};\\n        for (int i = 0;i <  ages.size();i++)\\n        {\\n            temp[ages[i]]++;\\n        }\\n        \\n        for (int i = 1;i < 122;i++)\\n        {\\n            temp[i] = temp[i] + temp[i - 1];\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0;i < ages.size(); i++)\\n        {\\n            if (ages[i] > 14)\\n                res += (temp[ages[i]] - temp[(int)(0.5*ages[i]) + 7]) - 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int* temp = new int[122]{0};\\n        for (int i = 0;i <  ages.size();i++)\\n        {\\n            temp[ages[i]]++;\\n        }\\n        \\n        for (int i = 1;i < 122;i++)\\n        {\\n            temp[i] = temp[i] + temp[i - 1];\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0;i < ages.size(); i++)\\n        {\\n            if (ages[i] > 14)\\n                res += (temp[ages[i]] - temp[(int)(0.5*ages[i]) + 7]) - 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2505228,
                "title": "python-time-o-max-n-120-space-o-1-prefixsum-and-numbersort-solution",
                "content": "The ages is restricted to be between 1 and 120 so we can make an array with 120 slots to count all persons with a certain age.\\n\\nWe can then compute the prefix sum for every age by passing through the 120-slot array one time and summing up.\\n\\nNow we can compute all the values needed for our result by differencing prefix sums.\\n\\nALSO: The last restriction (age[y] > 100 && age[x] < 100) can be ignored, as it is covered by age[y] > age[x].\\n\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        \\n        # make a number sort\\n        sort_ages = [0]*120\\n        \\n        # sort the ages\\n        for age in ages:\\n            sort_ages[age-1] += 1\\n            \\n        # make prefix sum\\n        for age in range(2,121):\\n            sort_ages[age-1] = sort_ages[age-1] + sort_ages[age-2]\\n            \\n        # make a sliding window through the array\\n        result = 0\\n        for age in ages:\\n            \\n            # these ages fall out due to the first restriction\\n            # 14//2 + 7 = 14 -> 14 <= 14 -> falls out\\n            if age <= 14:\\n                continue\\n            \\n            # calculate the index of persons we don\\'t want\\n            dox = age//2 + 7\\n            \\n            # this is the amount of persons younger than ourselves\\n            # but older than age//2 + 7\\n            result += sort_ages[age-2] - sort_ages[dox-1]\\n            \\n            # this is the amount of persons the same age as us but\\n            # without ourselves as we don\\'t send a request to ourself\\n            result += (sort_ages[age-1] - sort_ages[age-2]) - 1\\n        \\n        return result\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        \\n        # make a number sort\\n        sort_ages = [0]*120\\n        \\n        # sort the ages\\n        for age in ages:\\n            sort_ages[age-1] += 1\\n            \\n        # make prefix sum\\n        for age in range(2,121):\\n            sort_ages[age-1] = sort_ages[age-1] + sort_ages[age-2]\\n            \\n        # make a sliding window through the array\\n        result = 0\\n        for age in ages:\\n            \\n            # these ages fall out due to the first restriction\\n            # 14//2 + 7 = 14 -> 14 <= 14 -> falls out\\n            if age <= 14:\\n                continue\\n            \\n            # calculate the index of persons we don\\'t want\\n            dox = age//2 + 7\\n            \\n            # this is the amount of persons younger than ourselves\\n            # but older than age//2 + 7\\n            result += sort_ages[age-2] - sort_ages[dox-1]\\n            \\n            # this is the amount of persons the same age as us but\\n            # without ourselves as we don\\'t send a request to ourself\\n            result += (sort_ages[age-1] - sort_ages[age-2]) - 1\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469842,
                "title": "simple-c-solution-binary-search",
                "content": "Please upvote if you like my solution .\\n```\\nclass Solution {\\npublic:\\n    \\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(),ages.end());\\n        int ans = 0;\\n        // 2 check \\n        // 1. ->  y > x/2 + 7 ;\\n        // 2. ->  y <= x;\\n        for(int i=0;i<ages.size();i++){\\n            int x = ages[i];\\n            int y = x/2 + 7;\\n\\t\\t\\t// condition check\\n            if(y >= x) continue;\\n            auto it = upper_bound(ages.begin() , ages.end() , y) - ages.begin();\\n            auto it2 = upper_bound(ages.begin(), ages.end() , x) - ages.begin();\\n            if(it < i){ans += (i - it);}\\n            if(it2 > i) ans += (it2 - i - 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(),ages.end());\\n        int ans = 0;\\n        // 2 check \\n        // 1. ->  y > x/2 + 7 ;\\n        // 2. ->  y <= x;\\n        for(int i=0;i<ages.size();i++){\\n            int x = ages[i];\\n            int y = x/2 + 7;\\n\\t\\t\\t// condition check\\n            if(y >= x) continue;\\n            auto it = upper_bound(ages.begin() , ages.end() , y) - ages.begin();\\n            auto it2 = upper_bound(ages.begin(), ages.end() , x) - ages.begin();\\n            if(it < i){ans += (i - it);}\\n            if(it2 > i) ans += (it2 - i - 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290506,
                "title": "python-counter-simple-iterative-approach-using-ifs",
                "content": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ct = {}     # counter\\n        for n in ages:\\n            if n not in ct:\\n                ct[n] = ages.count(n)\\n        mreq = 0\\n        for x in ct:\\n            for y in ct:\\n                if y <= (0.5*x) + 7 or y > x or (y > 100 and x < 100):\\n                    continue\\n                if x == y:\\n                    mreq += ct[x] * (ct[x] - 1)     # send reqs except itself\\n                else:\\n                    mreq += ct[x] * ct[y]                \\n        return mreq\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ct = {}     # counter\\n        for n in ages:\\n            if n not in ct:\\n                ct[n] = ages.count(n)\\n        mreq = 0\\n        for x in ct:\\n            for y in ct:\\n                if y <= (0.5*x) + 7 or y > x or (y > 100 and x < 100):\\n                    continue\\n                if x == y:\\n                    mreq += ct[x] * (ct[x] - 1)     # send reqs except itself\\n                else:\\n                    mreq += ct[x] * ct[y]                \\n        return mreq\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257939,
                "title": "simple-binary-search-solution",
                "content": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        cnt = 0\\n        N = len(ages)\\n        ages.sort()\\n        for i in range(N):\\n            a = ages[i]\\n            idx1 = bisect.bisect(ages, a)\\n            idx2 = bisect.bisect(ages, 0.5 * a + 7)\\n            cnt += max(0, idx1 - idx2 - 1) \\n        return cnt\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        cnt = 0\\n        N = len(ages)\\n        ages.sort()\\n        for i in range(N):\\n            a = ages[i]\\n            idx1 = bisect.bisect(ages, a)\\n            idx2 = bisect.bisect(ages, 0.5 * a + 7)\\n            cnt += max(0, idx1 - idx2 - 1) \\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166214,
                "title": "well-explained-c-easy-code-don-t-worry-have-fun",
                "content": "# intution:-\\nThese are ***the 3 conditions which must not follow to if we want to send a friend request according to the question.***\\n```\\nage[y] <= 0.5 * age[x] + 7\\nage[y] > age[x]\\nage[y] > 100 && age[x] < 100\\n```\\n\\nThink of something, yes take all the cases diffently what must not occur\\n  after thinking you know we need to do sorting because:-\\n  1. age[y] <= age[x]  so to do so  do sorting \\n  2.     age[y] > 100 than we must find age[x] >= 100  **** hint no.2****\\n  3.     age[x] must be =>     age[x] < 2*(age[y]-7)   so to find this index we need to apply lower_bound function **(so do sorting** \\n\\n---------age[y]-------------------------age[x]-------- -----    sorted array\\n            index = i                                  index = j\\n\\nso all the element which follow age[y] <= age[x]  it will be    j-i-1\\n\\nLet\\'s talk about why we need map here\\nso take example no.1 =>     *[16,16]*     each of them can send friend request to each other. but we have sorted the array so we need their first occurence that\\'s why we are using map.\\n\\n**second condition will be automatically followed no need to worrrrrry because of sorting**\\n\\n**Here is the code:-**\\n\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int ans = 0;\\n        sort(ages.begin(), ages.end());\\n        \\n        \\n        unordered_map<int,int> mp;\\n        for(int i = 0; i < ages.size(); i++) {\\n            if(!mp.count(ages[i])) mp[ages[i]] = i;\\n        }\\n        \\n        \\n        for(int i = 0; i < ages.size(); i++) {\\n            int x= lower_bound(ages.begin(), ages.end(), 2*(ages[i]-7)) - ages.begin();\\n            if(x <= i) continue;\\n            ans += x-mp[ages[i]]-1; \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nT.C. => O(nlonn)   n = ages.size()\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nage[y] <= 0.5 * age[x] + 7\\nage[y] > age[x]\\nage[y] > 100 && age[x] < 100\\n```\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int ans = 0;\\n        sort(ages.begin(), ages.end());\\n        \\n        \\n        unordered_map<int,int> mp;\\n        for(int i = 0; i < ages.size(); i++) {\\n            if(!mp.count(ages[i])) mp[ages[i]] = i;\\n        }\\n        \\n        \\n        for(int i = 0; i < ages.size(); i++) {\\n            int x= lower_bound(ages.begin(), ages.end(), 2*(ages[i]-7)) - ages.begin();\\n            if(x <= i) continue;\\n            ans += x-mp[ages[i]]-1; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1970058,
                "title": "the-question-is-wrong-the-100-years-condition-should-be-reversed",
                "content": "This question comes from Facebook tech screening: https://leetcode.com/discuss/interview-question/469422/facebook-phone-count-all-friend-requests\\n\\nBut note that in there it says \\n> A centaur over 100 years old will not send a friend request to a recipient under 100 years old. But centaurs under 100 years old can friend each other.\\n\\nwhereas in Leetcode, it says\\n> \"A Person x will not send a friend request to a person y if age[y] > 100 && age[x] < 100\". \\n\\nWhich is the opposite. So much so, that Leetcode also says that: \\n> \"A Person x will not send a friend request to a person y if age[y] > age[x]\"\\n\\nwhich is a generalization of the previous one. This makes this solution pass:\\n\\n```\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        int invites = 0;\\n        for (int x = ages.length - 1 ; x >= 0 ; x--) {\\n            boolean shouldContinue = true;\\n            for (int y = x-1 ; y >= 0 && shouldContinue ; y--) {\\n                if (ages[y] <= 0.5 * ages[x] + 7) {\\n                    shouldContinue = false;\\n                    break;\\n                }\\n                if (ages[x] == ages[y]) invites++;\\n                invites++;\\n            }\\n        }\\n        return invites;\\n    }\\n```\\n\\neven if it\\'s totally ignoring the 100 years condition.",
                "solutionTags": [],
                "code": "```\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        int invites = 0;\\n        for (int x = ages.length - 1 ; x >= 0 ; x--) {\\n            boolean shouldContinue = true;\\n            for (int y = x-1 ; y >= 0 && shouldContinue ; y--) {\\n                if (ages[y] <= 0.5 * ages[x] + 7) {\\n                    shouldContinue = false;\\n                    break;\\n                }\\n                if (ages[x] == ages[y]) invites++;\\n                invites++;\\n            }\\n        }\\n        return invites;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1958434,
                "title": "c-set-counting-prefix-sum-binary-search-solution-o-n-logn",
                "content": "Runtime: 70 ms, faster than 63.12% of C++ online submissions for Friends Of Appropriate Ages.\\nMemory Usage: 37.7 MB, less than 6.74% of C++ online submissions for Friends Of Appropriate Ages.\\n\\n\\n```\\n1. Sort ages on descending order and track all unique ages\\n2. Count the frequency of ages and do prefix sum on frequency count array on descending order\\n3. Loop through age array in descending order and check if current age > target => age/2 + 7\\n4. Then do binary search on right elements and find last index where age > target and get the count of\\nages until last index using prefix sum array. Total request  => current age count * other valid age count\\n5. In case of same age meet condition age > target request count => current age count * (current age count -1)\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& persons) {\\n        \\n        // count freq of the ages\\n        int freq[121] = {0};\\n        \\n        // track the descending order of age\\n        set<int,greater<int>>uniqueAges;\\n        \\n        int n = persons.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            uniqueAges.insert(persons[i]);\\n            freq[persons[i]]++;\\n        }\\n        \\n        // add unique age from set in descending order and update the prefix sum larger to smaller age\\n        vector<int>ages;\\n        for(auto iter=uniqueAges.begin();iter!=uniqueAges.end();iter++)\\n        {\\n            ages.push_back(*iter);\\n            if(next(iter)!=uniqueAges.end())\\n                freq[*next(iter)] += freq[*iter];\\n        }\\n\\n        // total request count\\n        int count = 0;\\n        \\n        int fcount; // current age freq\\n\\n        int left,right,mid,target,index;\\n        int ageLen = ages.size();\\n        \\n        for(int i=0;i<ageLen;i++)\\n        {\\n            // get current age count from prefix sum \\n            fcount = freq[ages[i]] - (i > 0 ? freq[ages[i-1]] : 0);\\n            \\n            // target age for sending request\\n            target = ages[i]/2 + 7;\\n             \\n            // if current age meets condition then search further\\n            if(ages[i] > target)\\n            {\\n                // send same age request count => n * (n-1) \\n                // as every n person can send request to other n-1 persons \\n                count += (fcount-1) * fcount;\\n                \\n                // check if next age meets condition then do binary search in the right elements\\n                if(i+1 < ageLen && ages[i+1] > target)\\n                {\\n                    left = i+1;\\n                    right = ages.size()-1;\\n                    index = i+1;\\n                    \\n                    // find the last index which meets the condition\\n                    while(left <= right)\\n                    {\\n                        mid = left + (right-left)/2;\\n\\n                        if(ages[mid] > target)left=mid+1,index=mid;\\n                        else right = mid-1,index=mid-1;\\n                    }\\n\\n                    // get freq count K from next of current age to last index age using prefix sum array\\n                    // then request count => fcount * K\\n                    if(index< ageLen && ages[index] > target)\\n                        count+= fcount * (freq[ages[index]] - freq[ages[i]]);                    \\n                }\\n            }    \\n        }\\n        \\n        return count;\\n            \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "```\\n1. Sort ages on descending order and track all unique ages\\n2. Count the frequency of ages and do prefix sum on frequency count array on descending order\\n3. Loop through age array in descending order and check if current age > target => age/2 + 7\\n4. Then do binary search on right elements and find last index where age > target and get the count of\\nages until last index using prefix sum array. Total request  => current age count * other valid age count\\n5. In case of same age meet condition age > target request count => current age count * (current age count -1)\\n```\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& persons) {\\n        \\n        // count freq of the ages\\n        int freq[121] = {0};\\n        \\n        // track the descending order of age\\n        set<int,greater<int>>uniqueAges;\\n        \\n        int n = persons.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            uniqueAges.insert(persons[i]);\\n            freq[persons[i]]++;\\n        }\\n        \\n        // add unique age from set in descending order and update the prefix sum larger to smaller age\\n        vector<int>ages;\\n        for(auto iter=uniqueAges.begin();iter!=uniqueAges.end();iter++)\\n        {\\n            ages.push_back(*iter);\\n            if(next(iter)!=uniqueAges.end())\\n                freq[*next(iter)] += freq[*iter];\\n        }\\n\\n        // total request count\\n        int count = 0;\\n        \\n        int fcount; // current age freq\\n\\n        int left,right,mid,target,index;\\n        int ageLen = ages.size();\\n        \\n        for(int i=0;i<ageLen;i++)\\n        {\\n            // get current age count from prefix sum \\n            fcount = freq[ages[i]] - (i > 0 ? freq[ages[i-1]] : 0);\\n            \\n            // target age for sending request\\n            target = ages[i]/2 + 7;\\n             \\n            // if current age meets condition then search further\\n            if(ages[i] > target)\\n            {\\n                // send same age request count => n * (n-1) \\n                // as every n person can send request to other n-1 persons \\n                count += (fcount-1) * fcount;\\n                \\n                // check if next age meets condition then do binary search in the right elements\\n                if(i+1 < ageLen && ages[i+1] > target)\\n                {\\n                    left = i+1;\\n                    right = ages.size()-1;\\n                    index = i+1;\\n                    \\n                    // find the last index which meets the condition\\n                    while(left <= right)\\n                    {\\n                        mid = left + (right-left)/2;\\n\\n                        if(ages[mid] > target)left=mid+1,index=mid;\\n                        else right = mid-1,index=mid-1;\\n                    }\\n\\n                    // get freq count K from next of current age to last index age using prefix sum array\\n                    // then request count => fcount * K\\n                    if(index< ageLen && ages[index] > target)\\n                        count+= fcount * (freq[ages[index]] - freq[ages[i]]);                    \\n                }\\n            }    \\n        }\\n        \\n        return count;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900650,
                "title": "a-c-solution-using-binary-search",
                "content": "First, we need to analyze these rules given from the problem. If any condition happens, x **won\\'t** send the friend request to y.\\n1. `age[y] <= 0.5 * age[x] + 7`\\n2. `age[y] > age[x]`\\n3. `age[y] > 100 && age[x] < 100`\\n\\nRule 2 is easy to understand. From this rule, we know that x may send the request to y if `y <= x`. And from rule 1, we know that x may send the request to y if `y > 0.5x + 7`. Based on rule 1 and 2, we can get the range of ages of y which fits x\\'s favor: `(0.5x + 7, x]`. \\n\\nNow, let\\'s deal with rule 3. And you will see that rule 3 never happens because in rule 3, y is greater than x which is out of the range of x\\' favor. So, we just need to focus on `0.5x + 7 < y <= x`.\\n\\nTime complexity : sorting is O(nlog(n)). Per-user checking is O(n). Binary search is O(log(n)). Overall will be O(nlog(n)).\\nSpace complexity: O(1)\\n\\n```c++\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int ans = 0;\\n        int l, u;\\n        \\n\\t\\t// Sorting ages, and then we can do binary search.\\n        sort(ages.begin(), ages.end());\\n        \\n\\t\\t// Find the range of each user.\\n        for (int i = 0; i < ages.size(); ++i) {\\n            \\n\\t\\t\\t// 0.5x + 7 may be greater than x. We can skip this loop if it happens.\\n            if (0.5 * ages[i] + 7 >= ages[i]) {\\n                continue;\\n            }\\n            \\n\\t\\t\\t// Search the smallest y in the range (0.5x + 7, x].\\n\\t\\t\\t// A trick is that passing right hand side to limit the searching range\\n\\t\\t\\t// which can improve its speed a little.\\n            l = searchLowerBound(ages, 0.5 * ages[i] + 7, i);\\n            \\n\\t\\t\\t// Search the largest y. Because we need to consider the duplicated values of x.\\n\\t\\t\\t// The index of largest y may be greater than i.\\n\\t\\t\\t// Minusing 1 at the end is to exclude self.\\n            u = upper_bound(\\n                ages.begin() + i, ages.end(), ages[i]) - ages.begin() - 1;\\n            \\n            ans += u - l;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n\\t// This function searchs the index of the smallest value greater than `val`\\n    int searchLowerBound(vector<int>& ages, int val, int r) {\\n        int l = 0;\\n        \\n        while (l <= r) {\\n            int m = (l + r) / 2;\\n            \\n            if (ages[m] <= val) {\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int ans = 0;\\n        int l, u;\\n        \\n\\t\\t// Sorting ages, and then we can do binary search.\\n        sort(ages.begin(), ages.end());\\n        \\n\\t\\t// Find the range of each user.\\n        for (int i = 0; i < ages.size(); ++i) {\\n            \\n\\t\\t\\t// 0.5x + 7 may be greater than x. We can skip this loop if it happens.\\n            if (0.5 * ages[i] + 7 >= ages[i]) {\\n                continue;\\n            }\\n            \\n\\t\\t\\t// Search the smallest y in the range (0.5x + 7, x].\\n\\t\\t\\t// A trick is that passing right hand side to limit the searching range\\n\\t\\t\\t// which can improve its speed a little.\\n            l = searchLowerBound(ages, 0.5 * ages[i] + 7, i);\\n            \\n\\t\\t\\t// Search the largest y. Because we need to consider the duplicated values of x.\\n\\t\\t\\t// The index of largest y may be greater than i.\\n\\t\\t\\t// Minusing 1 at the end is to exclude self.\\n            u = upper_bound(\\n                ages.begin() + i, ages.end(), ages[i]) - ages.begin() - 1;\\n            \\n            ans += u - l;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n\\t// This function searchs the index of the smallest value greater than `val`\\n    int searchLowerBound(vector<int>& ages, int val, int r) {\\n        int l = 0;\\n        \\n        while (l <= r) {\\n            int m = (l + r) / 2;\\n            \\n            if (ages[m] <= val) {\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876627,
                "title": "python-o-n-faster-99-5-cumulative-sum-and-age-buckets",
                "content": "I have seen a few solutions that do a sum in the main loop over the age buckets. To avoid this, we can precalculate the cumulative sums and use them instead to make the main logic loop highly efficient.\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        # in a sense: \"bucket sort\"\\n        ageMax = max(ages)\\n        ageBuckets = [0]*(ageMax+1)\\n        for age in ages:\\n            ageBuckets[age] += 1\\n        \\n        # build cumulative sum\\n        ageCum = [ageBuckets[0]]*(ageMax+1)\\n        for i in range(1,len(ageBuckets)):\\n            ageCum[i] = ageCum[i-1] + ageBuckets[i]\\n            \\n        # main logic\\n        ans = 0\\n        for age in range(1,len(ageBuckets)):\\n            if ageBuckets[age]:\\n                k = int(age * 0.5 + 7)\\n                if k < age:\\n                    ans += ageBuckets[age] * (ageCum[age-1] - ageCum[k])\\n                if age > k:\\n                    ans += ageBuckets[age]*(ageBuckets[age]-1)\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        # in a sense: \"bucket sort\"\\n        ageMax = max(ages)\\n        ageBuckets = [0]*(ageMax+1)\\n        for age in ages:\\n            ageBuckets[age] += 1\\n        \\n        # build cumulative sum\\n        ageCum = [ageBuckets[0]]*(ageMax+1)\\n        for i in range(1,len(ageBuckets)):\\n            ageCum[i] = ageCum[i-1] + ageBuckets[i]\\n            \\n        # main logic\\n        ans = 0\\n        for age in range(1,len(ageBuckets)):\\n            if ageBuckets[age]:\\n                k = int(age * 0.5 + 7)\\n                if k < age:\\n                    ans += ageBuckets[age] * (ageCum[age-1] - ageCum[k])\\n                if age > k:\\n                    ans += ageBuckets[age]*(ageBuckets[age]-1)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1853310,
                "title": "python-o-nlogn-bisect",
                "content": "There are cleaner implementations that include all ages when bisecting. This takes a slightly different approach and instead dedupes all ages and keeps counts.\\n```\\nimport bisect\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        new_ages = []\\n        counts = []\\n        for a in ages:\\n            if new_ages and new_ages[-1] == a:\\n                counts[-1] += 1\\n            else:\\n                new_ages.append(a)\\n                counts.append(1)\\n        prefix = [0]\\n        for c in counts:\\n            prefix.append(prefix[-1]+c)\\n        ages = new_ages\\n        total_requests = 0\\n        for i, age in enumerate(ages):\\n            min_age = age / 2 + 7\\n            j = bisect.bisect_right(ages, min_age)\\n            # we can\\'t friend someone older than us\\n            if j > i:\\n                continue\\n            # get number of people younger than `age` multiplied by number of people with `age`\\n            total_requests += (prefix[i]-prefix[j])*counts[i]\\n        # for any ages with more than 1 person, sum all possible requests n*(n-1)\\n        # but make sure that the age requirement is met (which is really only for young kids)\\n        # 6 < (6/2+7=10)\\n        # 16 > (16/2+7=15)\\n        total_requests += sum(n*(n-1) for a, n in zip(ages, counts) if a > (a / 2 + 7))\\n        return total_requests\\n```\\n\\nHere\\'s a cleaner solution:\\n```\\nimport bisect\\nfrom collections import Counter\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        counts = Counter(ages)\\n        total = 0\\n        for age in counts:\\n            min_age = age / 2 + 7\\n            left = bisect.bisect_right(ages, min_age)\\n            right = bisect.bisect_right(ages, age)\\n            total += max(right - left - 1, 0)*counts[age]\\n        return total\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nimport bisect\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        new_ages = []\\n        counts = []\\n        for a in ages:\\n            if new_ages and new_ages[-1] == a:\\n                counts[-1] += 1\\n            else:\\n                new_ages.append(a)\\n                counts.append(1)\\n        prefix = [0]\\n        for c in counts:\\n            prefix.append(prefix[-1]+c)\\n        ages = new_ages\\n        total_requests = 0\\n        for i, age in enumerate(ages):\\n            min_age = age / 2 + 7\\n            j = bisect.bisect_right(ages, min_age)\\n            # we can\\'t friend someone older than us\\n            if j > i:\\n                continue\\n            # get number of people younger than `age` multiplied by number of people with `age`\\n            total_requests += (prefix[i]-prefix[j])*counts[i]\\n        # for any ages with more than 1 person, sum all possible requests n*(n-1)\\n        # but make sure that the age requirement is met (which is really only for young kids)\\n        # 6 < (6/2+7=10)\\n        # 16 > (16/2+7=15)\\n        total_requests += sum(n*(n-1) for a, n in zip(ages, counts) if a > (a / 2 + 7))\\n        return total_requests\\n```\n```\\nimport bisect\\nfrom collections import Counter\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        counts = Counter(ages)\\n        total = 0\\n        for age in counts:\\n            min_age = age / 2 + 7\\n            left = bisect.bisect_right(ages, min_age)\\n            right = bisect.bisect_right(ages, age)\\n            total += max(right - left - 1, 0)*counts[age]\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847580,
                "title": "python-3-two-solutions",
                "content": "sorting + deque solution\\nO(nlogn) time\\nO(n) space\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        deque = collections.deque()\\n        ages.sort(reverse=True)\\n        res = 0\\n        curSame = 0\\n        \\n        for i, age in enumerate(ages):\\n            if i and age >= 15 and age == ages[i-1]:\\n                curSame += 1\\n            else:\\n                curSame = 0\\n\\n            while deque and age <= deque[0]:\\n                deque.popleft()\\n                \\n            res += len(deque) + curSame\\n            deque.append(0.5*age + 7)\\n        \\n        return res\\n```\\nprefix sum solution\\nO(n) time\\nO(1) space\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        prefixSum = collections.Counter(ages)\\n        for i in range(2, 121):\\n            prefixSum[i] += prefixSum[i-1]\\n        \\n        res = 0\\n        for age in ages:\\n            left = int(0.5*age + 7)\\n            if age > left:\\n                res += prefixSum[age] - prefixSum[left] - 1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        deque = collections.deque()\\n        ages.sort(reverse=True)\\n        res = 0\\n        curSame = 0\\n        \\n        for i, age in enumerate(ages):\\n            if i and age >= 15 and age == ages[i-1]:\\n                curSame += 1\\n            else:\\n                curSame = 0\\n\\n            while deque and age <= deque[0]:\\n                deque.popleft()\\n                \\n            res += len(deque) + curSame\\n            deque.append(0.5*age + 7)\\n        \\n        return res\\n```\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        prefixSum = collections.Counter(ages)\\n        for i in range(2, 121):\\n            prefixSum[i] += prefixSum[i-1]\\n        \\n        res = 0\\n        for age in ages:\\n            left = int(0.5*age + 7)\\n            if age > left:\\n                res += prefixSum[age] - prefixSum[left] - 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831668,
                "title": "java-solution-with-prefixsum-o-n",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int ans = 0;\\n        int[] prefixSum = new int[121];\\n        for (int age : ages) {\\n            prefixSum[age]++;\\n        }\\n        for (int i = 1; i < prefixSum.length; i++) {\\n            prefixSum[i] += prefixSum[i-1];\\n        }\\n        for (int age : ages) {\\n            int left = (int)(0.5 * age) + 7;\\n            if (left < age) {\\n                ans += prefixSum[age] - prefixSum[left] - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nThe last for loop could be optimized.\\n```\\nfor (int age = 1; age < 121; age++) {\\n\\tint left = (int)(0.5 * age) + 7;\\n\\tif (left < age) {\\n\\t\\tans += (prefixSum[age] - prefixSum[left] - 1) * (prefixSum[age] - prefixSum[age - 1]);\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int ans = 0;\\n        int[] prefixSum = new int[121];\\n        for (int age : ages) {\\n            prefixSum[age]++;\\n        }\\n        for (int i = 1; i < prefixSum.length; i++) {\\n            prefixSum[i] += prefixSum[i-1];\\n        }\\n        for (int age : ages) {\\n            int left = (int)(0.5 * age) + 7;\\n            if (left < age) {\\n                ans += prefixSum[age] - prefixSum[left] - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nfor (int age = 1; age < 121; age++) {\\n\\tint left = (int)(0.5 * age) + 7;\\n\\tif (left < age) {\\n\\t\\tans += (prefixSum[age] - prefixSum[left] - 1) * (prefixSum[age] - prefixSum[age - 1]);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734617,
                "title": "c-short",
                "content": "Using @votrubac solution\\nTime: O(n)\\nSpace: O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> count(121,0);\\n        for(int x : ages) {\\n            count[x]++;\\n        }\\n        int ans = 0;\\n        for(int i = 15;i<121;i++) {\\n            for(int j = 0.5*i + 8;j<=i;j++) {\\n                ans+= count[j] * (count[i]- (i==j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> count(121,0);\\n        for(int x : ages) {\\n            count[x]++;\\n        }\\n        int ans = 0;\\n        for(int i = 15;i<121;i++) {\\n            for(int j = 0.5*i + 8;j<=i;j++) {\\n                ans+= count[j] * (count[i]- (i==j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1698046,
                "title": "python-two-pointers-after-sorting",
                "content": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        if not ages:\\n            return 0\\n        \\n        ages.sort()\\n        \\n        count = 0\\n        left, right = 0, 0\\n        for age in ages:\\n            while left < len(ages) and ages[left] <= 0.5 * age + 7:\\n                left += 1\\n            while right < len(ages) and ages[right] <= age:\\n                right += 1\\n            if right - 1 >= left:\\n                count += right - left - 1\\n        \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        if not ages:\\n            return 0\\n        \\n        ages.sort()\\n        \\n        count = 0\\n        left, right = 0, 0\\n        for age in ages:\\n            while left < len(ages) and ages[left] <= 0.5 * age + 7:\\n                left += 1\\n            while right < len(ages) and ages[right] <= age:\\n                right += 1\\n            if right - 1 >= left:\\n                count += right - left - 1\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690666,
                "title": "ruby-o-n-and-o-1-space",
                "content": "The difficult part of this problem is avoiding the easy TLE. The first solution bellow results in it:\\n\\n```ruby\\n# @param {Integer[]} ages\\n# @return {Integer}\\ndef num_friend_requests(ages)\\n    count = 0\\n    ages.each.with_index do |age1, idx1|\\n        ages.each.with_index do |age2, idx2|\\n            next if idx1 == idx2\\n            count += 1 if possible_friend(age1, age2)\\n        end\\n    end\\n    count\\nend\\n\\ndef possible_friend(x, y)\\n    !((y <= 0.5*x + 7) || (y > x) || (y > 100 && x < 100))\\nend\\n```\\n\\nThere are some improvements that may be performed:\\n- as only 0 <= age <= 120 is valid, every number doesn\\'t need to be verified against every other element in the array. Counting how many occurrences of every number happens and then verifying it against every other number turns the total solution from O(n^2) into O(n + 121 * 121) = O(n). Space is O(121) = O(1);\\n\\n- instead of comparing every number with every other number, simply add to the total number of friend requests the product of count(age X) * count(age Y) for (age Y) that is valid. If age Y == age X, substract age X from the total number of friend requests. That is still a O(n) for time and O(1) for space,;\\n\\nBear in mind that the restriction age[y] > 100 && age[x] < 100 does not mean anything, as it is already taken care of by age[y] > age[x]. The other restriction, age[x] * 0.5 + 7 >= age[y] results in age[x] / 2 + 8 < age[y] for a friend request to happen.\\n\\nThe final solution is:\\n\\n```ruby\\n# @param {Integer[]} ages\\n# @return {Integer}\\ndef num_friend_requests(ages)\\n    count = 0\\n    age_count = Array.new(121) { 0 }\\n    ages.each { |age| age_count[age] += 1 }\\n    age_count.each.with_index do |curr_count, age|\\n        intervals = [age / 2 + 8, age]\\n        for i in intervals[0]..intervals[1]\\n            count += (age_count[i] * curr_count)\\n            count -= curr_count if i == age\\n        end\\n    end\\n    count\\nend\\n```\\n\\n",
                "solutionTags": [],
                "code": "```ruby\\n# @param {Integer[]} ages\\n# @return {Integer}\\ndef num_friend_requests(ages)\\n    count = 0\\n    ages.each.with_index do |age1, idx1|\\n        ages.each.with_index do |age2, idx2|\\n            next if idx1 == idx2\\n            count += 1 if possible_friend(age1, age2)\\n        end\\n    end\\n    count\\nend\\n\\ndef possible_friend(x, y)\\n    !((y <= 0.5*x + 7) || (y > x) || (y > 100 && x < 100))\\nend\\n```\n```ruby\\n# @param {Integer[]} ages\\n# @return {Integer}\\ndef num_friend_requests(ages)\\n    count = 0\\n    age_count = Array.new(121) { 0 }\\n    ages.each { |age| age_count[age] += 1 }\\n    age_count.each.with_index do |curr_count, age|\\n        intervals = [age / 2 + 8, age]\\n        for i in intervals[0]..intervals[1]\\n            count += (age_count[i] * curr_count)\\n            count -= curr_count if i == age\\n        end\\n    end\\n    count\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1686736,
                "title": "python-o-n-solution-beats-90-of-the-solution",
                "content": "Might be a bit redundant code, but I came up with this solution.\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        counter = Counter(ages)\\n        s = sorted(counter.keys())\\n        prefix = []\\n        sum_total = 0\\n        for i in s:\\n            sum_total += counter[i]\\n            prefix.append(sum_total)\\n            \\n        \\n        j = 0\\n        count = 0\\n        for i, age in enumerate(s):\\n            while j < i and (s[j] <= 0.5*age + 7):\\n                j += 1\\n            if j == i and s[j] <= 0.5*age + 7:\\n                continue\\n            if counter[s[i]] > 1:\\n                count += (counter[s[i]] * (counter[s[i]]-1))\\n            count += (counter[s[i]] * ((prefix[i-1] if i > 0 else 0) - (prefix[j-1] if j > 0 else 0)))\\n        return count\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        counter = Counter(ages)\\n        s = sorted(counter.keys())\\n        prefix = []\\n        sum_total = 0\\n        for i in s:\\n            sum_total += counter[i]\\n            prefix.append(sum_total)\\n            \\n        \\n        j = 0\\n        count = 0\\n        for i, age in enumerate(s):\\n            while j < i and (s[j] <= 0.5*age + 7):\\n                j += 1\\n            if j == i and s[j] <= 0.5*age + 7:\\n                continue\\n            if counter[s[i]] > 1:\\n                count += (counter[s[i]] * (counter[s[i]]-1))\\n            count += (counter[s[i]] * ((prefix[i-1] if i > 0 else 0) - (prefix[j-1] if j > 0 else 0)))\\n        return count\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646281,
                "title": "python-easy-solution-best-approach",
                "content": "**Condition 1:**  If your age is different from the other age\\n*E.g.* 16, 15, 15 then 15 ->16 and 15 ->16\\nie 2*1 which is **xCount** * **yCount**.\\n\\n**Condition 2:** If your age is the same.\\n*E.g.* 16, 16 then 16 <-> 16 *i.e.* 2 which is **xCount** * **(xCount-1)** or **yCount** * **(yCount-1)**\\n\\n\\tclass Solution:\\n\\t\\tdef numFriendRequests(self, ages: List[int]) -> int:\\n\\t\\t\\tcount = 0\\n\\t\\t\\tages = Counter(ages)\\n\\t\\t\\tfor x in ages:\\n\\t\\t\\t\\txCount = ages[x]\\n\\t\\t\\t\\tfor y in ages:\\n\\t\\t\\t\\t\\tif not (y <= 0.5*x+7 or y > x):\\n\\t\\t\\t\\t\\t\\tyCount = ages[y]\\n\\t\\t\\t\\t\\t\\tif x != y:\\n\\t\\t\\t\\t\\t\\t\\tcount += xCount*yCount\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tcount += xCount*(xCount-1)\\n\\t\\t\\treturn count",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "**Condition 1:**  If your age is different from the other age\\n*E.g.* 16, 15, 15 then 15 ->16 and 15 ->16\\nie 2*1 which is **xCount** * **yCount**.\\n\\n**Condition 2:** If your age is the same.\\n*E.g.* 16, 16 then 16 <-> 16 *i.e.* 2 which is **xCount** * **(xCount-1)** or **yCount** * **(yCount-1)**\\n\\n\\tclass Solution:\\n\\t\\tdef numFriendRequests(self, ages: List[int]) -> int:\\n\\t\\t\\tcount = 0\\n\\t\\t\\tages = Counter(ages)\\n\\t\\t\\tfor x in ages:\\n\\t\\t\\t\\txCount = ages[x]\\n\\t\\t\\t\\tfor y in ages:\\n\\t\\t\\t\\t\\tif not (y <= 0.5*x+7 or y > x):\\n\\t\\t\\t\\t\\t\\tyCount = ages[y]\\n\\t\\t\\t\\t\\t\\tif x != y:\\n\\t\\t\\t\\t\\t\\t\\tcount += xCount*yCount\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tcount += xCount*(xCount-1)\\n\\t\\t\\treturn count",
                "codeTag": "Java"
            },
            {
                "id": 1560590,
                "title": "simple-to-understand-using-map-binary-search-with-comments",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\nIn this solution, we sort the ages and use a map that keeps track of the ages, and the total friend request count that age can recieve.\\n\\nBinary search is used to get the age range in the array that satisfies the friend request conditions.\\n\\n```\\npublic class Solution {\\n    public int NumFriendRequests(int[] ages) {\\n        var result = 0;\\n        \\n        // Sort ages\\n        Array.Sort(ages);\\n        \\n        // Keep track of results calculated\\n        var seen = new Dictionary<int, int>();\\n        \\n        // Iterate array backwards\\n        for (int index = ages.Length - 1; index >= 0; --index) { \\n            // Check if we already calculated result for age\\n            if (!seen.ContainsKey(ages[index])) {\\n                // Binary search\\n                var lo = 0;\\n                var hi = index;\\n                while (lo < hi) {\\n                    var mid = lo + (hi - lo) / 2;\\n\\n                    // Check if friends can be made in this range\\n                    if (!CanFriend(ages[index], ages[mid])) {\\n                        lo = mid + 1;\\n                    } else {\\n                        hi = mid;\\n                    }\\n                }\\n                // Get distance between index and hi. This is the friend count for the age\\n                seen[ages[index]] = index - hi; \\n            }\\n            // Update result count\\n            result += seen[ages[index]];\\n        }        \\n        return result;\\n    }\\n    \\n    private bool CanFriend(int x, int y) {\\n        return !((y > x) || (y > 100 && x < 100) || (y <= 0.5 * x + 7));\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumFriendRequests(int[] ages) {\\n        var result = 0;\\n        \\n        // Sort ages\\n        Array.Sort(ages);\\n        \\n        // Keep track of results calculated\\n        var seen = new Dictionary<int, int>();\\n        \\n        // Iterate array backwards\\n        for (int index = ages.Length - 1; index >= 0; --index) { \\n            // Check if we already calculated result for age\\n            if (!seen.ContainsKey(ages[index])) {\\n                // Binary search\\n                var lo = 0;\\n                var hi = index;\\n                while (lo < hi) {\\n                    var mid = lo + (hi - lo) / 2;\\n\\n                    // Check if friends can be made in this range\\n                    if (!CanFriend(ages[index], ages[mid])) {\\n                        lo = mid + 1;\\n                    } else {\\n                        hi = mid;\\n                    }\\n                }\\n                // Get distance between index and hi. This is the friend count for the age\\n                seen[ages[index]] = index - hi; \\n            }\\n            // Update result count\\n            result += seen[ages[index]];\\n        }        \\n        return result;\\n    }\\n    \\n    private bool CanFriend(int x, int y) {\\n        return !((y > x) || (y > 100 && x < 100) || (y <= 0.5 * x + 7));\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223329,
                "title": "easy-c-solution-o-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int a,int b) {\\n         float A=a;\\n         float B=b;\\n         if(B<=(0.5*A)+7 || B>A || (B>100 && A<100)) return false;\\n         return true;\\n    }\\n    int numFriendRequests(vector<int>& ages) {\\n        unordered_map<int,int> mp;\\n        int ans=0;\\n        for(int i=0; i<ages.size(); i++) mp[ages[i]]++;\\n        for(pair<int,int> p : mp) {\\n            for(pair<int,int> q : mp) {\\n                if(isvalid(p.first,q.first)) {\\n                   if(p.first==q.first) ans+=p.second*(p.second-1);\\n                   else ans+=p.second*q.second;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int a,int b) {\\n         float A=a;\\n         float B=b;\\n         if(B<=(0.5*A)+7 || B>A || (B>100 && A<100)) return false;\\n         return true;\\n    }\\n    int numFriendRequests(vector<int>& ages) {\\n        unordered_map<int,int> mp;\\n        int ans=0;\\n        for(int i=0; i<ages.size(); i++) mp[ages[i]]++;\\n        for(pair<int,int> p : mp) {\\n            for(pair<int,int> q : mp) {\\n                if(isvalid(p.first,q.first)) {\\n                   if(p.first==q.first) ans+=p.second*(p.second-1);\\n                   else ans+=p.second*q.second;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169867,
                "title": "1ms-simple-java-solution-loop-with-window-o-1-space-o-n-time",
                "content": "Java 1ms, beats 100% time. Simple moving window loop over 120 ages starting age 15 with lower range as age/2+7. Linear time `O(n)` and constant space `O(1)` complexity.\\n\\n```java\\n\\n/**\\n* A will friend request B iff\\n* age: A/2+7 < B < A but for some  A /2+7 >=A -> A/2<=7 A<=14\\n* So anyone under 15 cannot friend request\\n* Solution: store people in age buckets and loop over it with window starting form age 15\\n**/\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] peopleByAge = new int[121];\\n        for(int i = 0; i < ages.length; i++)\\n            peopleByAge[ages[i]]++;\\n        int result = 0, peopleCount = 0, lowerAgeRange = 15;\\n        for(int i = 15; i <= 120; i++) {\\n            if (i % 2 == 0)\\n                peopleCount -= peopleByAge[lowerAgeRange++];\\n            peopleCount += peopleByAge[i];\\n            result += peopleByAge[i] * (peopleCount-1);  // we can all befriend each other. -1 is to exclude ourselves\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n\\n/**\\n* A will friend request B iff\\n* age: A/2+7 < B < A but for some  A /2+7 >=A -> A/2<=7 A<=14\\n* So anyone under 15 cannot friend request\\n* Solution: store people in age buckets and loop over it with window starting form age 15\\n**/\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] peopleByAge = new int[121];\\n        for(int i = 0; i < ages.length; i++)\\n            peopleByAge[ages[i]]++;\\n        int result = 0, peopleCount = 0, lowerAgeRange = 15;\\n        for(int i = 15; i <= 120; i++) {\\n            if (i % 2 == 0)\\n                peopleCount -= peopleByAge[lowerAgeRange++];\\n            peopleCount += peopleByAge[i];\\n            result += peopleByAge[i] * (peopleCount-1);  // we can all befriend each other. -1 is to exclude ourselves\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1100755,
                "title": "greedy-beats-90-time-and-space",
                "content": "O(N ^ 2) time, O(N) space\\n\\nSort and Filter out lower ages from earlier iterations\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        res = 0\\n        ages = sorted(Counter(ages).items())\\n\\n        left = 0\\n        for i, (ownAge, count) in enumerate(ages):\\n            if count > 1 and ownAge > 0.5 * ownAge + 7: res += count * (count - 1)\\n\\n            for j in range(left, i):\\n                if ages[j][0] > 0.5 * ownAge + 7: res += ages[j][1] * count\\n                else: left += 1\\n                    \\n        return res",
                "solutionTags": [],
                "code": "O(N ^ 2) time, O(N) space\\n\\nSort and Filter out lower ages from earlier iterations\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        res = 0\\n        ages = sorted(Counter(ages).items())\\n\\n        left = 0\\n        for i, (ownAge, count) in enumerate(ages):\\n            if count > 1 and ownAge > 0.5 * ownAge + 7: res += count * (count - 1)\\n\\n            for j in range(left, i):\\n                if ages[j][0] > 0.5 * ownAge + 7: res += ages[j][1] * count\\n                else: left += 1\\n                    \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1067229,
                "title": "javascript-easy-and-simple-solution",
                "content": "```javascript\\nvar numFriendRequests = function(ages) {\\n    const range = [];\\n    const freq = {}\\n    let count = 0;\\n    \\n    for(let n of ages) {\\n        freq[n] = (freq[n] || 0) + 1;\\n        const min = Math.floor(n/2 + 8);\\n        range.push([min, n]);\\n    }\\n    \\n    for(let i = 0; i < range.length; i++) {\\n        const [min, max] = range[i];\\n        \\n        for(let j = min; j <= max; j++) {\\n            if(!freq[j]) continue;\\n            count += freq[j];\\n            if(j === max) count--;\\n        }\\n    }\\n    return count;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar numFriendRequests = function(ages) {\\n    const range = [];\\n    const freq = {}\\n    let count = 0;\\n    \\n    for(let n of ages) {\\n        freq[n] = (freq[n] || 0) + 1;\\n        const min = Math.floor(n/2 + 8);\\n        range.push([min, n]);\\n    }\\n    \\n    for(let i = 0; i < range.length; i++) {\\n        const [min, max] = range[i];\\n        \\n        for(let j = min; j <= max; j++) {\\n            if(!freq[j]) continue;\\n            count += freq[j];\\n            if(j === max) count--;\\n        }\\n    }\\n    return count;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1062882,
                "title": "simple-o-n-java-solution-for-slow-learners-like-myself",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        ages = ages == null ? new int[0] : ages;\\n        \\n        int[] count = new int[121];\\n        int requests = 0;\\n        \\n        for (int age : ages)\\n            count[age]++;\\n        \\n        for (int a = 1; a <= 120; a++) {\\n            for (int b = 1; b <= 120; b++) {\\n                if (count[a] + count[b] <= 1 || aCannotRequestB(a, b))\\n                    continue; //not enough people or any of the rule violates\\n                \\n                int numAgesOfA = count[a], numAgesOfB = count[b];\\n                if (a == b) //special case if both a and b are pointing to the same age slot\\n                    numAgesOfB--;\\n                \\n                requests += numAgesOfA * numAgesOfB;\\n            }\\n        }\\n        \\n        return requests;\\n    }\\n    \\n    private boolean aCannotRequestB(int a, int b) {\\n        return b <= (a / 2 + 7) || b > a || b > 100 && a < 100;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        ages = ages == null ? new int[0] : ages;\\n        \\n        int[] count = new int[121];\\n        int requests = 0;\\n        \\n        for (int age : ages)\\n            count[age]++;\\n        \\n        for (int a = 1; a <= 120; a++) {\\n            for (int b = 1; b <= 120; b++) {\\n                if (count[a] + count[b] <= 1 || aCannotRequestB(a, b))\\n                    continue; //not enough people or any of the rule violates\\n                \\n                int numAgesOfA = count[a], numAgesOfB = count[b];\\n                if (a == b) //special case if both a and b are pointing to the same age slot\\n                    numAgesOfB--;\\n                \\n                requests += numAgesOfA * numAgesOfB;\\n            }\\n        }\\n        \\n        return requests;\\n    }\\n    \\n    private boolean aCannotRequestB(int a, int b) {\\n        return b <= (a / 2 + 7) || b > a || b > 100 && a < 100;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958504,
                "title": "5-ms-concise-java",
                "content": "```\\nclass Solution {\\n    /*\\n    Valid conditions for A to friend req. B\\n    0.5 * age[A] + 7 < age[B] <= age[A]\\n    \\n    1 <= ages.length <= 20000.\\n    1 <= ages[i] <= 120.\\n    */\\n    public int numFriendRequests(int[] ages) {\\n        int[] count = new int[121];\\n        int ans = 0;\\n        for(int age : ages){\\n            count[age]++;\\n        }\\n        // i -> age[A] ------ j -> age[B]\\n        for(int i=0; i<=120; i++){\\n            for(int j=0; j<=120; j++){\\n                if((0.5 * i + 7) < j && j <= i){\\n                    ans += count[i]*count[j];\\n                    if(i == j) {\\n                        ans -= count[i];\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /*\\n    Valid conditions for A to friend req. B\\n    0.5 * age[A] + 7 < age[B] <= age[A]\\n    \\n    1 <= ages.length <= 20000.\\n    1 <= ages[i] <= 120.\\n    */\\n    public int numFriendRequests(int[] ages) {\\n        int[] count = new int[121];\\n        int ans = 0;\\n        for(int age : ages){\\n            count[age]++;\\n        }\\n        // i -> age[A] ------ j -> age[B]\\n        for(int i=0; i<=120; i++){\\n            for(int j=0; j<=120; j++){\\n                if((0.5 * i + 7) < j && j <= i){\\n                    ans += count[i]*count[j];\\n                    if(i == j) {\\n                        ans -= count[i];\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934783,
                "title": "python3-two-approaches",
                "content": "**Approach 1 - sliding window**\\nSort `ages`. For each age, find the range of ages to make request based on \"no friend\" rule, i.e. given `x` requests friends whose ages fall in range `(0.5*x+7, x]`.  The range can be found via sliding window. \\n\\nImplementation (384ms, 34.85%)\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        ans = lo = hi = 0 \\n        for x in ages: \\n            while hi < len(ages) and x == ages[hi]: hi += 1\\n            while lo+1 < hi and ages[lo] <= x//2 + 7: lo += 1\\n            ans += hi - lo - 1\\n        return ans \\n```\\n\\nAnalysis\\nTime complexity `O(NlogN)`\\nSpace complexity `O(1)`\\n\\nApproach 2 - frequency table \\nAlthough the length of `ages` can go all the way up to `20000` there are only up to `120` distinct values. So we leverage on frequency table. \\n\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        freq = {}\\n        for x in ages: freq[x] = 1 + freq.get(x, 0)\\n        \\n        ans = 0 \\n        for x in freq: \\n            for y in freq: \\n                if 0.5*x + 7 < y <= x: \\n                    ans += freq[x] * freq[y]\\n                    if x == y: ans -= freq[x]\\n        return ans \\n```\\n\\nAnalysis \\nTime complexity `O(N)`\\nSpace complexity `O(1)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        ans = lo = hi = 0 \\n        for x in ages: \\n            while hi < len(ages) and x == ages[hi]: hi += 1\\n            while lo+1 < hi and ages[lo] <= x//2 + 7: lo += 1\\n            ans += hi - lo - 1\\n        return ans \\n```\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        freq = {}\\n        for x in ages: freq[x] = 1 + freq.get(x, 0)\\n        \\n        ans = 0 \\n        for x in freq: \\n            for y in freq: \\n                if 0.5*x + 7 < y <= x: \\n                    ans += freq[x] * freq[y]\\n                    if x == y: ans -= freq[x]\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 857963,
                "title": "java-solution-using-binary-search",
                "content": "We can use binary search to find the range of ages (age[A]*0.5 +7) where friend requests can be sent.\\n\\n\\n```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int ans = 0;\\n        Arrays.sort(ages);\\n        for(int i = 0; i < ages.length; i++) {\\n            int age = ages[i];\\n            //upper can be i but in same ages upper change\\n            //so need to find upper index also\\n            int upper = findIndex(ages, age);\\n            //lower index is from where all the ages comes in\\n            //range age[A]*.5 + 7 \\n            int lower = findIndex(ages, ((age/2)+7));\\n            ans += Math.max(upper-lower-1, 0);\\n        }\\n        return ans;\\n    }\\n    \\n    //binary search\\n    public static int findIndex(int[] ages, int target) {\\n        int start = 0;\\n        int end = ages.length-1;\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(ages[mid] <= target) start = mid + 1;\\n            else end = mid-1;\\n        }\\n        return start;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int ans = 0;\\n        Arrays.sort(ages);\\n        for(int i = 0; i < ages.length; i++) {\\n            int age = ages[i];\\n            //upper can be i but in same ages upper change\\n            //so need to find upper index also\\n            int upper = findIndex(ages, age);\\n            //lower index is from where all the ages comes in\\n            //range age[A]*.5 + 7 \\n            int lower = findIndex(ages, ((age/2)+7));\\n            ans += Math.max(upper-lower-1, 0);\\n        }\\n        return ans;\\n    }\\n    \\n    //binary search\\n    public static int findIndex(int[] ages, int target) {\\n        int start = 0;\\n        int end = ages.length-1;\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(ages[mid] <= target) start = mid + 1;\\n            else end = mid-1;\\n        }\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848515,
                "title": "java-1ms-solution-beats-100-time-o-n",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] count = new int[121];\\n        int[] ageSum = new int[121];\\n        for (int age : ages)\\n            count[age]++;\\n        int sum = 0;\\n        int ans = 0;\\n        for (int i = 15; i <= 120; i++) {\\n            sum += count[i];\\n            ageSum[i] = sum;\\n            if (count[i] > 0)\\n                ans += ((ageSum[i] - ageSum[i / 2 + 7] - 1) * count[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] count = new int[121];\\n        int[] ageSum = new int[121];\\n        for (int age : ages)\\n            count[age]++;\\n        int sum = 0;\\n        int ans = 0;\\n        for (int i = 15; i <= 120; i++) {\\n            sum += count[i];\\n            ageSum[i] = sum;\\n            if (count[i] > 0)\\n                ans += ((ageSum[i] - ageSum[i / 2 + 7] - 1) * count[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815506,
                "title": "javascript-solution-o-1-space-o-n-time",
                "content": "```\\n/**\\n * @param {number[]} ages\\n * @return {number}\\n */\\nvar numFriendRequests = function(ages) {\\n    if(ages.length <= 1) return 0;\\n    var nums = new Array(121).fill(0)\\n\\t//O(n) loop here\\n    for(let i of ages){ nums[i]++ }\\n        var ans = 0\\n    for(let i = 0 ;i <= 120; i++){\\n        let countA = nums[i]\\n        for(let j = 0; j <= 120; j++){\\n            let countB = nums[j]\\n            if((i * 0.5 + 7 >= j) || (i < j)) continue\\n            ans += countA * countB\\n            if(i === j) ans -= countA\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} ages\\n * @return {number}\\n */\\nvar numFriendRequests = function(ages) {\\n    if(ages.length <= 1) return 0;\\n    var nums = new Array(121).fill(0)\\n\\t//O(n) loop here\\n    for(let i of ages){ nums[i]++ }\\n        var ans = 0\\n    for(let i = 0 ;i <= 120; i++){\\n        let countA = nums[i]\\n        for(let j = 0; j <= 120; j++){\\n            let countB = nums[j]\\n            if((i * 0.5 + 7 >= j) || (i < j)) continue\\n            ans += countA * countB\\n            if(i === j) ans -= countA\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 738407,
                "title": "javascript-two-pointer",
                "content": "```\\nconst numFriendRequests = (ages) => {\\n    ages.sort((a, b) => a - b);\\n    let cnt = 0;\\n    let i = 0;\\n    while (i < ages.length) {\\n        let j = i + 1;\\n        let A = ages[i];\\n        while (j < ages.length) {\\n            let B = ages[j];\\n            if ((B > 0.5 * A + 7) && (B <= 100 || A >= 100) && (B == A)) {\\n                cnt++;\\n            }\\n            if ((A > 0.5 * B + 7) && (A <= 100 || B >= 100)) {\\n                cnt++;\\n            }\\n            j++;\\n        }\\n        i++;\\n    }\\n    return cnt;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst numFriendRequests = (ages) => {\\n    ages.sort((a, b) => a - b);\\n    let cnt = 0;\\n    let i = 0;\\n    while (i < ages.length) {\\n        let j = i + 1;\\n        let A = ages[i];\\n        while (j < ages.length) {\\n            let B = ages[j];\\n            if ((B > 0.5 * A + 7) && (B <= 100 || A >= 100) && (B == A)) {\\n                cnt++;\\n            }\\n            if ((A > 0.5 * B + 7) && (A <= 100 || B >= 100)) {\\n                cnt++;\\n            }\\n            j++;\\n        }\\n        i++;\\n    }\\n    return cnt;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 658569,
                "title": "the-easiest-way",
                "content": "```\\n/*\\u5B98\\u89E3\\u6CD5\\n *2020\\u5E745\\u670829\\u65E5 20:01\\n *\\u6267\\u884C\\u7528\\u65F6 :7 ms, \\u5728\\u6240\\u6709 Java \\u63D0\\u4EA4\\u4E2D\\u51FB\\u8D25\\u4E8653.67%\\u7684\\u7528\\u6237\\n *\\u5185\\u5B58\\u6D88\\u8017 :42.3 MB, \\u5728\\u6240\\u6709 Java \\u63D0\\u4EA4\\u4E2D\\u51FB\\u8D25\\u4E8611.11%\\u7684\\u7528\\u6237\\n *\\u4F5C\\u8005@v7fgg\\n */\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int nianling[]=new int[121];\\n        int ans=0;\\n        for(int a:ages){\\n            nianling[a]++;\\n        }\\n        for(int i=1;i<121;i++){\\n            for(int j=1;j<121;j++){\\n                int a=nianling[i];\\n                int b=nianling[j];\\n                if(j>0.5*i+7&&i>=j&&(j<=100||i>=100)){\\n                    ans+=i==j?a*b-a:a*b;\\n                }                \\n            }\\n        }return ans;\\n    }\\n}\\n//on leetcode.com\\n//Runtime: 6 ms, faster than 50.67% of Java online submissions for Friends Of Appropriate Ages.\\n//Memory Usage: 41.4 MB, less than 20.00% of Java online submissions for Friends Of Appropriate Ages.\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\u5B98\\u89E3\\u6CD5\\n *2020\\u5E745\\u670829\\u65E5 20:01\\n *\\u6267\\u884C\\u7528\\u65F6 :7 ms, \\u5728\\u6240\\u6709 Java \\u63D0\\u4EA4\\u4E2D\\u51FB\\u8D25\\u4E8653.67%\\u7684\\u7528\\u6237\\n *\\u5185\\u5B58\\u6D88\\u8017 :42.3 MB, \\u5728\\u6240\\u6709 Java \\u63D0\\u4EA4\\u4E2D\\u51FB\\u8D25\\u4E8611.11%\\u7684\\u7528\\u6237\\n *\\u4F5C\\u8005@v7fgg\\n */\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int nianling[]=new int[121];\\n        int ans=0;\\n        for(int a:ages){\\n            nianling[a]++;\\n        }\\n        for(int i=1;i<121;i++){\\n            for(int j=1;j<121;j++){\\n                int a=nianling[i];\\n                int b=nianling[j];\\n                if(j>0.5*i+7&&i>=j&&(j<=100||i>=100)){\\n                    ans+=i==j?a*b-a:a*b;\\n                }                \\n            }\\n        }return ans;\\n    }\\n}\\n//on leetcode.com\\n//Runtime: 6 ms, faster than 50.67% of Java online submissions for Friends Of Appropriate Ages.\\n//Memory Usage: 41.4 MB, less than 20.00% of Java online submissions for Friends Of Appropriate Ages.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 656218,
                "title": "pretty-fast-c-solution-using-hash-table-and-some-pruning-of-age-range",
                "content": "```\\nint numFriendRequests(int* ages, int agesSize){\\nint count=0;\\nint i, j;\\nint min_age;\\nint max_age;\\nint age_hash[150];\\n// Initialize a hash table of ages, 0 to 149, and hash all ages into it\\nfor (i=0; i<150; i++) age_hash[i]=0;\\nfor (i=0; i<agesSize; i++) age_hash[ages[i]]++;\\n\\n// Reduce the work by finding youngest and oldest ages\\nfor (i=0; i<150; i++) if (age_hash[i]!=0) { min_age=i; break; }\\nfor (i=149; i>0; i--) if (age_hash[i]!=0) { max_age=i; break; }\\n\\n// Check friending status of each pair of ages, and multiply by how\\n// many of each we have; if ages are same, remember you can\\'t friend\\n// yourself!\\nfor (i=min_age; i<=max_age; i++)\\n    for (j=min_age; j<=max_age; j++) {\\n        if ((age_hash[i]!=0) && (age_hash[j]!=0)) {\\n          if ((j>0.5*i+7) && (j<=i) && \\n              ((j<=100) || (i>=100)))\\n            if (i==j) count += age_hash[i] * (age_hash[i]-1);\\n              else count += age_hash[i] * age_hash[j];\\n        }\\n    }\\n        \\nreturn count;\\n}\\n",
                "solutionTags": [],
                "code": "```\\nint numFriendRequests(int* ages, int agesSize){\\nint count=0;\\nint i, j;\\nint min_age;\\nint max_age;\\nint age_hash[150];\\n// Initialize a hash table of ages, 0 to 149, and hash all ages into it\\nfor (i=0; i<150; i++) age_hash[i]=0;\\nfor (i=0; i<agesSize; i++) age_hash[ages[i]]++;\\n\\n// Reduce the work by finding youngest and oldest ages\\nfor (i=0; i<150; i++) if (age_hash[i]!=0) { min_age=i; break; }\\nfor (i=149; i>0; i--) if (age_hash[i]!=0) { max_age=i; break; }\\n\\n// Check friending status of each pair of ages, and multiply by how\\n// many of each we have; if ages are same, remember you can\\'t friend\\n// yourself!\\nfor (i=min_age; i<=max_age; i++)\\n    for (j=min_age; j<=max_age; j++) {\\n        if ((age_hash[i]!=0) && (age_hash[j]!=0)) {\\n          if ((j>0.5*i+7) && (j<=i) && \\n              ((j<=100) || (i>=100)))\\n            if (i==j) count += age_hash[i] * (age_hash[i]-1);\\n              else count += age_hash[i] * age_hash[j];\\n        }\\n    }\\n        \\nreturn count;\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 620199,
                "title": "c-hashmap",
                "content": "```\\nclass Solution {\\n    bool isReq(int ageA, int ageB) {\\n        \\n        if (ageB <= 0.5*ageA + 7) return false;\\n        if (ageB > ageA) return false;\\n        return true;\\n    }\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        \\n        int n = ages.size();\\n        \\n        unordered_map<int, int>hm;\\n        for (int i = 0; i < n; i++)\\n            hm[ages[i]]++;\\n        \\n        int ans = 0;\\n        for (auto a = hm.begin(); a != hm.end(); a++) {\\n            for (auto b = hm.begin(); b != hm.end(); b++) {\\n                if (isReq(a->first, b->first))\\n                    ans += a->second * (b->second - (a->first == b->first ? 1 : 0));\\n            } \\n        } \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool isReq(int ageA, int ageB) {\\n        \\n        if (ageB <= 0.5*ageA + 7) return false;\\n        if (ageB > ageA) return false;\\n        return true;\\n    }\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        \\n        int n = ages.size();\\n        \\n        unordered_map<int, int>hm;\\n        for (int i = 0; i < n; i++)\\n            hm[ages[i]]++;\\n        \\n        int ans = 0;\\n        for (auto a = hm.begin(); a != hm.end(); a++) {\\n            for (auto b = hm.begin(); b != hm.end(); b++) {\\n                if (isReq(a->first, b->first))\\n                    ans += a->second * (b->second - (a->first == b->first ? 1 : 0));\\n            } \\n        } \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609380,
                "title": "java-o-n-with-explanation",
                "content": "```   /**\\n     * O(n) solution\\n     * Thought: From  nlogn solution, the thing that cost most is the binary search to find the count of ages between lowerBound and upperBound\\n     * so the idea is to see whether we can reduce find counts from O(nlogn) O(1)\\n     *\\n     * since the total ages are between [1, 120]\\n     * so we can first use an array count the number of each ages O(n)\\n     *\\n     * for each age, we know there\\'s a lowerBound and higherBound that ages[i] will send request\\n     * lowerBound = ages[i] / 2 + 8, upperBound = ages[i]\\n     * \\n     * To calculate the count of ages between lowerBound and highBound in O(1), \\n     * we use a prefixCount array\\n     * The count between age[upperBound] and age[lowerBound] will be\\n     * int count = prefixCount[i] - prefixCount[i / 2 + 7]; (prefixCount[i / 2 + 7] is exclusive)\\n     * then we can calcute the res for ages[i] by \\n     * res += count * countAges[i] - countAges[i]; // people wont friend themselves\\n     *\\n     * @param ages\\n     * @return\\n     */\\n    public int numFriendRequestsII(int[] ages) {\\n\\n        // total 120 possible ages in this question, use + 1 avoid overflow\\n        int[] countAges = new int[121];\\n       // prefixSum used to easy find out count of ages between lowerBound and higherBound\\n        int[] prefixCount = new int[121];\\n        for (int i : ages) {\\n            countAges[i]++;\\n        }\\n        for(int i = 1; i <= 120; i++) {\\n            prefixCount[i] = countAges[i] + prefixCount[i - 1];\\n        }\\n\\n        int res = 0;\\n        for (int i = 0; i <= 120; i++) {\\n            if(countAges[i] == 0) {\\n                continue;\\n            }\\n            if(i / 2 + 7 >= i) {\\n                continue;\\n            }\\n            int count = prefixCount[i] - prefixCount[i / 2 + 7];\\n            res += count * countAges[i] - countAges[i]; // people wont friend themselves\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```   /**\\n     * O(n) solution\\n     * Thought: From  nlogn solution, the thing that cost most is the binary search to find the count of ages between lowerBound and upperBound\\n     * so the idea is to see whether we can reduce find counts from O(nlogn) O(1)\\n     *\\n     * since the total ages are between [1, 120]\\n     * so we can first use an array count the number of each ages O(n)\\n     *\\n     * for each age, we know there\\'s a lowerBound and higherBound that ages[i] will send request\\n     * lowerBound = ages[i] / 2 + 8, upperBound = ages[i]\\n     * \\n     * To calculate the count of ages between lowerBound and highBound in O(1), \\n     * we use a prefixCount array\\n     * The count between age[upperBound] and age[lowerBound] will be\\n     * int count = prefixCount[i] - prefixCount[i / 2 + 7]; (prefixCount[i / 2 + 7] is exclusive)\\n     * then we can calcute the res for ages[i] by \\n     * res += count * countAges[i] - countAges[i]; // people wont friend themselves\\n     *\\n     * @param ages\\n     * @return\\n     */\\n    public int numFriendRequestsII(int[] ages) {\\n\\n        // total 120 possible ages in this question, use + 1 avoid overflow\\n        int[] countAges = new int[121];\\n       // prefixSum used to easy find out count of ages between lowerBound and higherBound\\n        int[] prefixCount = new int[121];\\n        for (int i : ages) {\\n            countAges[i]++;\\n        }\\n        for(int i = 1; i <= 120; i++) {\\n            prefixCount[i] = countAges[i] + prefixCount[i - 1];\\n        }\\n\\n        int res = 0;\\n        for (int i = 0; i <= 120; i++) {\\n            if(countAges[i] == 0) {\\n                continue;\\n            }\\n            if(i / 2 + 7 >= i) {\\n                continue;\\n            }\\n            int count = prefixCount[i] - prefixCount[i / 2 + 7];\\n            res += count * countAges[i] - countAges[i]; // people wont friend themselves\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 534421,
                "title": "cpp-beats-100-submissions-in-time-and-space",
                "content": "```\\nstatic auto fast=[]{ios_base::sync_with_stdio(false);cin.tie(nullptr);return 0;}();\\n#define mod 1000000007\\nclass Solution \\n{\\npublic:\\n    int numFriendRequests(vector<int>& ages) \\n    {\\n        int ans=0;\\n        int freq[121]={0};\\n        for(int age : ages)\\n            freq[age]++;\\n        int vec[121];\\n        vec[0]=freq[0];\\n        for(int i=1;i<=120;i++)\\n            vec[i]=vec[i-1]+freq[i];\\n        //persons with age from 1 to 14 will not be able to make friend requests\\n        for(int i=15;i<=120;i++)\\n        {\\n            int t=i/2+7;\\n            int val=vec[i]-vec[t]-1;\\n            ans+=freq[i]*val;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstatic auto fast=[]{ios_base::sync_with_stdio(false);cin.tie(nullptr);return 0;}();\\n#define mod 1000000007\\nclass Solution \\n{\\npublic:\\n    int numFriendRequests(vector<int>& ages) \\n    {\\n        int ans=0;\\n        int freq[121]={0};\\n        for(int age : ages)\\n            freq[age]++;\\n        int vec[121];\\n        vec[0]=freq[0];\\n        for(int i=1;i<=120;i++)\\n            vec[i]=vec[i-1]+freq[i];\\n        //persons with age from 1 to 14 will not be able to make friend requests\\n        for(int i=15;i<=120;i++)\\n        {\\n            int t=i/2+7;\\n            int val=vec[i]-vec[t]-1;\\n            ans+=freq[i]*val;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 499670,
                "title": "why-doesn-t-this-work",
                "content": "```\\n public int numFriendRequests(int[] ages) { \\n        \\n        int[] counts = new int[121];\\n        for(int age : ages) {\\n            counts[age]++;\\n        }\\n        int result = 0;\\n        for(int i = 1; i < 121; i++) {\\n            for(int j = 1; j < 121; j++) {\\n               \\n                if(i == j) {\\n                    result += counts[i]*(counts[i]  - 1);\\n                } else {\\n                    if(canRequest(i, j)){\\n                      result += counts[i]*(counts[j]);\\n                    }\\n                  \\n                }\\n              \\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n\\t\\n\\tand if I make the logic change as follows it works\\n\\t  for(int i = 1; i < 121; i++) {\\n            for(int j = 1; j < 121; j++) {\\n               if(!canRequest(i,j)) continue;\\n                if(i == j) {\\n                    result += counts[i]*(counts[i]  - 1);\\n                } else {\\n                  \\n                      result += counts[i]*(counts[j]);\\n                    }\\n                  \\n                }\\n              \\n            }\\n        }\\n        \\n    \\n    private boolean canRequest(int A, int B) {\\n        if((B <= 0.5 * A + 7) ||  B > A || (B > 100 && A < 100 )) return false;\\n         \\n        return true;\\n    }",
                "solutionTags": [],
                "code": "```\\n public int numFriendRequests(int[] ages) { \\n        \\n        int[] counts = new int[121];\\n        for(int age : ages) {\\n            counts[age]++;\\n        }\\n        int result = 0;\\n        for(int i = 1; i < 121; i++) {\\n            for(int j = 1; j < 121; j++) {\\n               \\n                if(i == j) {\\n                    result += counts[i]*(counts[i]  - 1);\\n                } else {\\n                    if(canRequest(i, j)){\\n                      result += counts[i]*(counts[j]);\\n                    }\\n                  \\n                }\\n              \\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n\\t\\n\\tand if I make the logic change as follows it works\\n\\t  for(int i = 1; i < 121; i++) {\\n            for(int j = 1; j < 121; j++) {\\n               if(!canRequest(i,j)) continue;\\n                if(i == j) {\\n                    result += counts[i]*(counts[i]  - 1);\\n                } else {\\n                  \\n                      result += counts[i]*(counts[j]);\\n                    }\\n                  \\n                }\\n              \\n            }\\n        }\\n        \\n    \\n    private boolean canRequest(int A, int B) {\\n        if((B <= 0.5 * A + 7) ||  B > A || (B > 100 && A < 100 )) return false;\\n         \\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 478473,
                "title": "concise-solution-for-interviews-simpler-than-official-solution",
                "content": "\\tpublic int numFriendRequests(int[] ages) {\\n\\t\\tint[] freq = new int[121];\\n\\t\\tfor (int age : ages) {\\n\\t\\t  freq[age]++;\\n\\t\\t}\\n\\n\\t\\tint req = 0;\\n\\n\\t\\tfor (int a = 1; a <= 120; a++) {\\n\\t\\t  for (int b = 1; b <= 120; b++) {\\n\\t\\t\\tif (b > a || b <= 0.5 * a + 7) {\\n\\t\\t\\t  continue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (a == b) {\\n\\t\\t\\t  req += freq[a] * (freq[a] - 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t  req += freq[a] * freq[b];\\n\\t\\t\\t}\\n\\t\\t  }\\n\\t\\t}\\n\\n\\t\\treturn req;\\n\\t  }",
                "solutionTags": [
                    "Array"
                ],
                "code": "\\tpublic int numFriendRequests(int[] ages) {\\n\\t\\tint[] freq = new int[121];\\n\\t\\tfor (int age : ages) {\\n\\t\\t  freq[age]++;\\n\\t\\t}\\n\\n\\t\\tint req = 0;\\n\\n\\t\\tfor (int a = 1; a <= 120; a++) {\\n\\t\\t  for (int b = 1; b <= 120; b++) {\\n\\t\\t\\tif (b > a || b <= 0.5 * a + 7) {\\n\\t\\t\\t  continue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (a == b) {\\n\\t\\t\\t  req += freq[a] * (freq[a] - 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t  req += freq[a] * freq[b];\\n\\t\\t\\t}\\n\\t\\t  }\\n\\t\\t}\\n\\n\\t\\treturn req;\\n\\t  }",
                "codeTag": "Unknown"
            },
            {
                "id": 447775,
                "title": "javascript-solution",
                "content": "```\\nvar numFriendRequests = function(ages) {\\n    if(ages.length <= 1) return 0;\\n    var friendships = 0;\\n    var nums = {};\\n    ages.forEach(function(age){\\n        if(age >= 15) nums[age] = age in nums ? nums[age] + 1: 1;\\n    });\\n    var ages = Object.keys(nums).sort((a,b) => b - a);\\n    for(var i = 0; i < ages.length; i++){\\n        for(var j = i + 1; j < ages.length; j++){\\n            if(ages[j] > 0.5 * ages[i] + 7){\\n                friendships += nums[ages[i]] * nums[ages[j]];\\n            }\\n        }\\n        friendships += ((nums[ages[i]] - 1) * nums[ages[i]]);\\n    }\\n    return friendships;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numFriendRequests = function(ages) {\\n    if(ages.length <= 1) return 0;\\n    var friendships = 0;\\n    var nums = {};\\n    ages.forEach(function(age){\\n        if(age >= 15) nums[age] = age in nums ? nums[age] + 1: 1;\\n    });\\n    var ages = Object.keys(nums).sort((a,b) => b - a);\\n    for(var i = 0; i < ages.length; i++){\\n        for(var j = i + 1; j < ages.length; j++){\\n            if(ages[j] > 0.5 * ages[i] + 7){\\n                friendships += nums[ages[i]] * nums[ages[j]];\\n            }\\n        }\\n        friendships += ((nums[ages[i]] - 1) * nums[ages[i]]);\\n    }\\n    return friendships;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 401164,
                "title": "short-simple-python-binary-search-solution",
                "content": "```\\nfrom bisect import bisect_left, bisect_right\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        count = 0\\n        ages.sort()\\n        for n in ages:\\n            l, r = n//2 + 8, n \\n            ll = bisect_left(ages,l)\\n            rr = bisect_right(ages,r)\\n            val = rr - ll - 1\\n            count += val if val > 0  else 0\\n        return count\\n            ```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_left, bisect_right\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        count = 0\\n        ages.sort()\\n        for n in ages:\\n            l, r = n//2 + 8, n \\n            ll = bisect_left(ages,l)\\n            rr = bisect_right(ages,r)\\n            val = rr - ll - 1\\n            count += val if val > 0  else 0\\n        return count\\n            ```",
                "codeTag": "Java"
            },
            {
                "id": 342382,
                "title": "python-easy-to-understand-o-n-log-n-o-1-space",
                "content": "1. Sort the ages\\n2. Have a left pointer and right pointer\\n3. The pointers indicate which people can be friended\\n\\t- left pointer is increased until 0.5 * A + 7 is false\\n\\t- right pointer is the current age (people don\\'t friend people older than them)\\n4. Special handling is needed for the case where we have multiple people of the same age\\n\\t- to handle this keep track of the duplicates `sameAge` and add them to our ans\\n\\t- for example we have 3 people of age 30\\n\\t\\t- for first guy, sameAge = 0\\n\\t\\t- for second guy, sameAge = 1. ans += 1 - first guy making friends with the second guy\\n\\t\\t- for third guy, sameAge = 2. ans += 2  - first and second guy making friends with the third guy\\n\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages): \\n        ages.sort()\\n        ans = 0\\n        l = 0\\n        \\n        sameAge = 0\\n        \\n        for r, A in enumerate(ages):\\n            if r and ages[r] == ages[r - 1]:\\n                sameAge += 1\\n            else:\\n                sameAge = 0\\n            \\n            while l < len(ages) and ages[l] <= 0.5 * A + 7:\\n                l += 1\\n        \\n            if l <= r:\\n                ans += r - l + sameAge     \\n            \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages): \\n        ages.sort()\\n        ans = 0\\n        l = 0\\n        \\n        sameAge = 0\\n        \\n        for r, A in enumerate(ages):\\n            if r and ages[r] == ages[r - 1]:\\n                sameAge += 1\\n            else:\\n                sameAge = 0\\n            \\n            while l < len(ages) and ages[l] <= 0.5 * A + 7:\\n                l += 1\\n        \\n            if l <= r:\\n                ans += r - l + sameAge     \\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 146319,
                "title": "logical-thinking-with-java-code",
                "content": "**Logical Thinking**\\n```\\nNotes:\\n1 <= ages.length <= 20000.\\n1 <= ages[i] <= 120.\\n```\\nThe notes above is the key to solve the problem.\\nThe `value range of ages` is far smaller than the `number of ages`. Thus, we loop through all possible values for age rather than ages of all possible candidates, i.e.,  `[1, 120] rather than [1, 20000]`.\\nPlease note that, if A1 = ageA, A2 = ageA, B1 = ageB, B2 = ageB, B3 = ageB, then total requests made by ageA and ageB is 2 x 3 = 6, that is, `map[ageA] x map[ageB]`. What if ageA equals to ageB? The the result shoulD minus `map[ageA/ageB] `for people cannot make friend requests to himself.\\n\\n**Clear Java Code**\\n```\\n    public int numFriendRequests(int[] ages) {\\n        int cntFriendRequests = 0;\\n        int[] map = new int[121]; // 1 ~ 120;\\n        for (int age : ages) {\\n            map[age]++;\\n        }\\n        for (int A = 1; A <= 120; A++) {\\n            for (int B = 1; B <= 120; B++) {\\n                if (B <= 0.5 * A + 7) continue;\\n                if (B > A) continue;\\n                if (B > 100 && A < 100) continue;\\n                cntFriendRequests += map[A] * map[B];\\n                if (A == B) {\\n                    cntFriendRequests -= map[A];\\n                }\\n            }\\n        }\\n        return cntFriendRequests;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nNotes:\\n1 <= ages.length <= 20000.\\n1 <= ages[i] <= 120.\\n```\n```\\n    public int numFriendRequests(int[] ages) {\\n        int cntFriendRequests = 0;\\n        int[] map = new int[121]; // 1 ~ 120;\\n        for (int age : ages) {\\n            map[age]++;\\n        }\\n        for (int A = 1; A <= 120; A++) {\\n            for (int B = 1; B <= 120; B++) {\\n                if (B <= 0.5 * A + 7) continue;\\n                if (B > A) continue;\\n                if (B > 100 && A < 100) continue;\\n                cntFriendRequests += map[A] * map[B];\\n                if (A == B) {\\n                    cntFriendRequests -= map[A];\\n                }\\n            }\\n        }\\n        return cntFriendRequests;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 135447,
                "title": "concise-c-code",
                "content": "```\\nint\\nnumFriendRequests(const int *const ages, const int agesSize)\\n{\\n\\tstatic int cnt[121];\\n\\tint a, b, sum;\\n\\n\\t(void)memset(cnt, 0, sizeof(cnt));\\n\\tfor (a = 0; a < agesSize; ++a)\\n\\t\\t++cnt[ages[a]];\\n\\tsum = 0;\\n\\tfor (a = 15; a <= 120; ++a)\\n\\t\\tif (cnt[a] != 0)\\n\\t\\t\\tfor (b = a / 2 + 8; b <= a; ++b)\\n\\t\\t\\t\\tif (cnt[b] != 0)\\n\\t\\t\\t\\t\\tsum += (cnt[a] - (a == b)) * cnt[b];\\n\\n\\treturn sum;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint\\nnumFriendRequests(const int *const ages, const int agesSize)\\n{\\n\\tstatic int cnt[121];\\n\\tint a, b, sum;\\n\\n\\t(void)memset(cnt, 0, sizeof(cnt));\\n\\tfor (a = 0; a < agesSize; ++a)\\n\\t\\t++cnt[ages[a]];\\n\\tsum = 0;\\n\\tfor (a = 15; a <= 120; ++a)\\n\\t\\tif (cnt[a] != 0)\\n\\t\\t\\tfor (b = a / 2 + 8; b <= a; ++b)\\n\\t\\t\\t\\tif (cnt[b] != 0)\\n\\t\\t\\t\\t\\tsum += (cnt[a] - (a == b)) * cnt[b];\\n\\n\\treturn sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 127885,
                "title": "c-hash-map",
                "content": "I first have some difficulty to understand the problem.\\nThe three condition is C1, C2 and C3\\nA not friend request B: C1||C2||C3\\nA friend request B: !(C1||C2||C3)=!C1&&!C2&&!C3\\n!C1: B>0.5A+7. If B=A, B>14\\n!C2: B<=A\\n!C3: B<=100 || A>=100, this always is true\\nWe build a hash map (using a vector is simpler) and check the !C1 and !C2.\\nsame age friend request if met condition: N*(N-1)\\ndifferent age friend request if met condition: N*M\\n\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int va[121]={0};\\n        for(int i=0;i<ages.size();i++) va[ages[i]]++;\\n        //larger age friend request smaller age\\n        //age difference\\n        //can use binary search\\n        int total=0;\\n        for(int i=1;i<=120;i++)\\n        {\\n            if(i>14 && va[i]>1) total+=va[i]*(va[i]-1); //C1 condition\\n            if(i>1 && va[i]) //2nd condition, only friend request with smaller age\\n            {\\n                int smallest_age=i/2+7+1;//>age C1 condition\\n                //cout<<smallest_age<<endl;\\n                for(int j=smallest_age;j<i;j++) total+=va[j]*va[i];\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int va[121]={0};\\n        for(int i=0;i<ages.size();i++) va[ages[i]]++;\\n        //larger age friend request smaller age\\n        //age difference\\n        //can use binary search\\n        int total=0;\\n        for(int i=1;i<=120;i++)\\n        {\\n            if(i>14 && va[i]>1) total+=va[i]*(va[i]-1); //C1 condition\\n            if(i>1 && va[i]) //2nd condition, only friend request with smaller age\\n            {\\n                int smallest_age=i/2+7+1;//>age C1 condition\\n                //cout<<smallest_age<<endl;\\n                for(int j=smallest_age;j<i;j++) total+=va[j]*va[i];\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 127109,
                "title": "simple-java-solution",
                "content": "```\\n public int numFriendRequests(int[] ages) {\\n       int[] map =  new int[121];\\n       for(int n : ages)\\n           map[n]++;  // frequency count\\n       \\n       int req = 0;\\n        for(int i = 120; i>0 ;--i){\\n            if( map[i]  > 0){\\n                int k = i + 14;  // ages[j] must be > 0.5*ages[i] + 7  =>  ages[j]*2 > ages[i] + 14 \\n                for(int j = i-1; 2*j > k  ;--j){\\n                    if(map[j] > 0) req+=map[i]*map[j]; // ways A can make friend requests to B\\n                }\\n                if( 2*i > k)  req+=map[i]*(map[i]-1);  // friend requests made to each other (same age)\\n            }\\n        }\\n       return req;\\n   }",
                "solutionTags": [],
                "code": "```\\n public int numFriendRequests(int[] ages) {\\n       int[] map =  new int[121];\\n       for(int n : ages)\\n           map[n]++;  // frequency count\\n       \\n       int req = 0;\\n        for(int i = 120; i>0 ;--i){\\n            if( map[i]  > 0){\\n                int k = i + 14;  // ages[j] must be > 0.5*ages[i] + 7  =>  ages[j]*2 > ages[i] + 14 \\n                for(int j = i-1; 2*j > k  ;--j){\\n                    if(map[j] > 0) req+=map[i]*map[j]; // ways A can make friend requests to B\\n                }\\n                if( 2*i > k)  req+=map[i]*(map[i]-1);  // friend requests made to each other (same age)\\n            }\\n        }\\n       return req;\\n   }",
                "codeTag": "Unknown"
            },
            {
                "id": 127038,
                "title": "easy-and-simple-c-o-nlogn-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end());\\n        int ans = 0;\\n        for(int i = 0; i < ages.size(); i++){\\n            int j = i+1;\\n            while(j<ages.size() && ages[i]==ages[j]) j++;\\n            j--;\\n            auto itr = upper_bound(ages.begin(), ages.end(), 0.5*ages[i] + 7);\\n            if(itr != ages.end() && (itr-ages.begin())<j) {\\n                ans += j - (itr-ages.begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end());\\n        int ans = 0;\\n        for(int i = 0; i < ages.size(); i++){\\n            int j = i+1;\\n            while(j<ages.size() && ages[i]==ages[j]) j++;\\n            j--;\\n            auto itr = upper_bound(ages.begin(), ages.end(), 0.5*ages[i] + 7);\\n            if(itr != ages.end() && (itr-ages.begin())<j) {\\n                ans += j - (itr-ages.begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126971,
                "title": "python-solution",
                "content": "```\\n    def numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        from bisect import bisect_left, bisect_right\\n        total=0\\n        ages.sort()\\n\\n        for i in xrange(len(ages)-1, -1, -1):\\n            a = ages[i]\\n            r = bisect_right(ages, a) - 1\\n            l = bisect_right(ages, a/2 + 7)\\n            if r-l >= 0:\\n                total += (r-l)\\n        return total\\n```",
                "solutionTags": [],
                "code": "```\\n    def numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        from bisect import bisect_left, bisect_right\\n        total=0\\n        ages.sort()\\n\\n        for i in xrange(len(ages)-1, -1, -1):\\n            a = ages[i]\\n            r = bisect_right(ages, a) - 1\\n            l = bisect_right(ages, a/2 + 7)\\n            if r-l >= 0:\\n                total += (r-l)\\n        return total\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4090663,
                "title": "go-simple",
                "content": "```\\nfunc numFriendRequests(ages []int) int {\\n    people := make([]int, 121)\\n\\n    for _, age := range ages {\\n        people[age]++\\n    }\\n\\n    res := 0\\n\\n    for i := 1; i <= 120; i++ {\\n        if people[i] == 0 { continue }\\n\\n        limit := (i / 2) + 7\\n\\n        for j := limit + 1; j < i; j++ {\\n            res += people[i] * people[j]\\n        }\\n\\n        if i > limit {\\n            res += people[i] * (people[i] - 1)\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numFriendRequests(ages []int) int {\\n    people := make([]int, 121)\\n\\n    for _, age := range ages {\\n        people[age]++\\n    }\\n\\n    res := 0\\n\\n    for i := 1; i <= 120; i++ {\\n        if people[i] == 0 { continue }\\n\\n        limit := (i / 2) + 7\\n\\n        for j := limit + 1; j < i; j++ {\\n            res += people[i] * people[j]\\n        }\\n\\n        if i > limit {\\n            res += people[i] * (people[i] - 1)\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4024957,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java  []\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int map[]=new int[121];\\n        for(int j=0;j<ages.length;j++){\\n            map[ages[j]]++;\\n        }\\n\\n        for(int i=1;i<=120;i++){\\n            map[i]+=map[i-1];\\n        }\\n        int totalFriend=0;\\n        for(int i=0;i<ages.length;i++){\\n            int cond=ages[i]/2+7;\\n            if(cond>=ages[i]){\\n                continue;\\n            }\\n            totalFriend+=map[ages[i]]-map[cond]-1;\\n        }\\n        return totalFriend;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        counter = Counter(ages)\\n        s = sorted(counter.keys())\\n        prefix = []\\n        sum_total = 0\\n        for i in s:\\n            sum_total += counter[i]\\n            prefix.append(sum_total)\\n            \\n        \\n        j = 0\\n        count = 0\\n        for i, age in enumerate(s):\\n            while j < i and (s[j] <= 0.5*age + 7):\\n                j += 1\\n            if j == i and s[j] <= 0.5*age + 7:\\n                continue\\n            if counter[s[i]] > 1:\\n                count += (counter[s[i]] * (counter[s[i]]-1))\\n            count += (counter[s[i]] * ((prefix[i-1] if i > 0 else 0) - (prefix[j-1] if j > 0 else 0)))\\n        return count\\n            \\n```",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "```java  []\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int map[]=new int[121];\\n        for(int j=0;j<ages.length;j++){\\n            map[ages[j]]++;\\n        }\\n\\n        for(int i=1;i<=120;i++){\\n            map[i]+=map[i-1];\\n        }\\n        int totalFriend=0;\\n        for(int i=0;i<ages.length;i++){\\n            int cond=ages[i]/2+7;\\n            if(cond>=ages[i]){\\n                continue;\\n            }\\n            totalFriend+=map[ages[i]]-map[cond]-1;\\n        }\\n        return totalFriend;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        counter = Counter(ages)\\n        s = sorted(counter.keys())\\n        prefix = []\\n        sum_total = 0\\n        for i in s:\\n            sum_total += counter[i]\\n            prefix.append(sum_total)\\n            \\n        \\n        j = 0\\n        count = 0\\n        for i, age in enumerate(s):\\n            while j < i and (s[j] <= 0.5*age + 7):\\n                j += 1\\n            if j == i and s[j] <= 0.5*age + 7:\\n                continue\\n            if counter[s[i]] > 1:\\n                count += (counter[s[i]] * (counter[s[i]]-1))\\n            count += (counter[s[i]] * ((prefix[i-1] if i > 0 else 0) - (prefix[j-1] if j > 0 else 0)))\\n        return count\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3934494,
                "title": "java-code",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static boolean check(int x, int y) {\\n        return !((y <= (0.5*x)+7) || (y > x) || (y > 100 && x<100));\\n    }\\n    public int numFriendRequests(int[] ages) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int el : ages) {\\n            map.put(el, map.getOrDefault(el, 0)+1);\\n        }\\n\\n        int count = 0;\\n\\n        for(int a : map.keySet()) {\\n            for(int b : map.keySet()) {\\n                if(check(a,b)) {\\n                    count += map.get(a)*(map.get(b) - ((a == b)? 1 : 0));\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean check(int x, int y) {\\n        return !((y <= (0.5*x)+7) || (y > x) || (y > 100 && x<100));\\n    }\\n    public int numFriendRequests(int[] ages) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int el : ages) {\\n            map.put(el, map.getOrDefault(el, 0)+1);\\n        }\\n\\n        int count = 0;\\n\\n        for(int a : map.keySet()) {\\n            for(int b : map.keySet()) {\\n                if(check(a,b)) {\\n                    count += map.get(a)*(map.get(b) - ((a == b)? 1 : 0));\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891045,
                "title": "brute-force-and-optimised",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\no(N2) and O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n// || (b>100 and a<100)\\n    bool cond(int a,int b){\\n        if(b>a || b<=((0.5*a)+7))return false;\\n        return true;\\n    }\\n    int numFriendRequests(vector<int>& ages) {\\n        // unordered_map<int,int>mp;\\n        // for(auto it:ages)mp[it]++;\\n        // int ans=0;\\n        // for(auto &it1:mp){\\n        //     for(auto &it2:mp){\\n        //         if(cond(it1.first,it2.first)){\\n        //         if(it1.first==it2.first)ans+=it1.second*(it2.second-1);\\n        //          else ans+=it1.second*it2.second;\\n        //         }\\n                \\n        //     }\\n        // }\\n        // return ans;\\n        int n=ages.size();\\n\\n        sort(ages.begin(),ages.end());\\n        unordered_map<int,int>dict;\\n        int ans=0;\\n        for(auto it:ages){\\n            if(dict.find(it)!=dict.end()){\\n                ans+=dict[it];\\n                continue;\\n            }\\n            int leftmost=-1;\\n            int start=0;\\n            int end=n-1;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(ages[mid]>0.5*it+7){\\n                    leftmost=mid;\\n                    end=mid-1;\\n                }else start=mid+1;\\n                               \\n            }\\n            if(leftmost<0)continue;\\n            int rightmost=-1;\\n           start=0,end=n-1;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(ages[mid]<=it){\\n                    rightmost=mid;\\n                    start=mid+1;\\n                }else end=mid-1;\\n\\n            }\\n            int count=rightmost-leftmost;\\n            if(count>0){\\n                ans+=count;\\n            }\\n            if(count>0){\\n                dict[it]=count;\\n            }\\n        }\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// || (b>100 and a<100)\\n    bool cond(int a,int b){\\n        if(b>a || b<=((0.5*a)+7))return false;\\n        return true;\\n    }\\n    int numFriendRequests(vector<int>& ages) {\\n        // unordered_map<int,int>mp;\\n        // for(auto it:ages)mp[it]++;\\n        // int ans=0;\\n        // for(auto &it1:mp){\\n        //     for(auto &it2:mp){\\n        //         if(cond(it1.first,it2.first)){\\n        //         if(it1.first==it2.first)ans+=it1.second*(it2.second-1);\\n        //          else ans+=it1.second*it2.second;\\n        //         }\\n                \\n        //     }\\n        // }\\n        // return ans;\\n        int n=ages.size();\\n\\n        sort(ages.begin(),ages.end());\\n        unordered_map<int,int>dict;\\n        int ans=0;\\n        for(auto it:ages){\\n            if(dict.find(it)!=dict.end()){\\n                ans+=dict[it];\\n                continue;\\n            }\\n            int leftmost=-1;\\n            int start=0;\\n            int end=n-1;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(ages[mid]>0.5*it+7){\\n                    leftmost=mid;\\n                    end=mid-1;\\n                }else start=mid+1;\\n                               \\n            }\\n            if(leftmost<0)continue;\\n            int rightmost=-1;\\n           start=0,end=n-1;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(ages[mid]<=it){\\n                    rightmost=mid;\\n                    start=mid+1;\\n                }else end=mid-1;\\n\\n            }\\n            int count=rightmost-leftmost;\\n            if(count>0){\\n                ans+=count;\\n            }\\n            if(count>0){\\n                dict[it]=count;\\n            }\\n        }\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840372,
                "title": "100-in-time-100-in-space-why-no-idea",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI think the problem was somewhat poorly phrased since condition 2 is essentially condition 3, where you don\\'t friend people older than you. With that in mind, we can sort the array first and essentially eliminate needing to check 2/3 of conditions (since anyone before you in age won\\'t friend you back).\\n\\nAfter that it\\'s just a matter of checking for the calculated age condition, with a small statement to handle when people are the same age.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction numFriendRequests(ages: number[]): number {\\n\\n    let requests = 0\\n    ages.sort((a, b) => b - a)\\n\\n    for (let i = 0; i < ages.length - 1; i++) {\\n        const mylimit = Math.floor(ages[i] / 2) + 7\\n        inner: for (let k = i + 1; k < ages.length; k++) {\\n            if (ages[k] > mylimit) {\\n                requests++\\n                if (ages[k] === ages[i]) {\\n                    requests++\\n                }\\n            } else {\\n                break inner\\n\\n            }\\n        }\\n    }\\n    return requests\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction numFriendRequests(ages: number[]): number {\\n\\n    let requests = 0\\n    ages.sort((a, b) => b - a)\\n\\n    for (let i = 0; i < ages.length - 1; i++) {\\n        const mylimit = Math.floor(ages[i] / 2) + 7\\n        inner: for (let k = i + 1; k < ages.length; k++) {\\n            if (ages[k] > mylimit) {\\n                requests++\\n                if (ages[k] === ages[i]) {\\n                    requests++\\n                }\\n            } else {\\n                break inner\\n\\n            }\\n        }\\n    }\\n    return requests\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3825943,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe workflow of the code is as follows:\\n\\ncount is a list whose index represents age and whose value represents the number of people with that age. For example, if there are three people with age 15, count[15] = 3. This step is done in a for age in ages: count[age] += 1 loop.\\n\\nThe code then checks all possible age pairs (a,b) with two nested loops, where ageA and ageB represent the ages of a and b, respectively, and countA and countB represent the number of people of ages a and b, respectively.\\n\\nFor each age pair, if the age of b does not satisfy the condition for sending a friend request (i.e., ageB <= ageA * 0.5 + 7 or ageB > ageA or (ageB > 100 and ageA < 100)), then continue to the next age pair.\\n\\nOtherwise, the person with ageA can send friend requests to all people with ageB, so add countA * countB to the result.\\n\\nHowever, if a and b have the same age (i.e. ageA == ageB), then the person of age a cannot send a friend request to himself. Therefore, we need to subtract countA, which is the number of people of age a, from the result.\\n\\nFinally, return the result res, which is the total number of friend requests that satisfy the condition.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        count = [0] * 121  # \\u5E74\\u9F84\\u5230\\u9891\\u7387\\u7684\\u6620\\u5C04,121\\u662F\\u56E0\\u4E3A\\u6700\\u5927\\u5E74\\u9F84\\u662F120\\n        for age in ages:\\n            count[age] += 1\\n\\n        res = 0\\n        for ageA, countA in enumerate(count):\\n            for ageB, countB in enumerate(count):\\n                if ageB <= ageA * 0.5 + 7 or ageB > ageA or (ageB > 100 and ageA < 100):\\n                    continue\\n                res += countA * countB\\n                if ageA == ageB:  # \\u5E74\\u9F84\\u76F8\\u540C\\u7684\\u4EBA\\u4E0D\\u80FD\\u5411\\u81EA\\u5DF1\\u53D1\\u9001\\u8BF7\\u6C42\\n                    res -= countA\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        count = [0] * 121  # \\u5E74\\u9F84\\u5230\\u9891\\u7387\\u7684\\u6620\\u5C04,121\\u662F\\u56E0\\u4E3A\\u6700\\u5927\\u5E74\\u9F84\\u662F120\\n        for age in ages:\\n            count[age] += 1\\n\\n        res = 0\\n        for ageA, countA in enumerate(count):\\n            for ageB, countB in enumerate(count):\\n                if ageB <= ageA * 0.5 + 7 or ageB > ageA or (ageB > 100 and ageA < 100):\\n                    continue\\n                res += countA * countB\\n                if ageA == ageB:  # \\u5E74\\u9F84\\u76F8\\u540C\\u7684\\u4EBA\\u4E0D\\u80FD\\u5411\\u81EA\\u5DF1\\u53D1\\u9001\\u8BF7\\u6C42\\n                    res -= countA\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3803257,
                "title": "faster-than-100-python3-binary-search-prefix-sum-hash-table",
                "content": "# Intuition\\nUse a counter to count how many times an age is in array and work with all the distinct values.\\n# Approach\\nSort the list with different ages and for every age use binary search or use a last pointer approach to find the youngest one for a request. All the values beetwen this and current age will verify the conditions, and use a prefix sum to compute the sum of them faster.\\n\\n# Complexity\\n- Time complexity:\\nO( n + mlog(m)), m  = the number of distinct values\\n\\n# Code Approach 1: Binary Search\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        c = Counter(ages)\\n        l = [age for age in c.keys()]\\n        l.sort()\\n        prefixSum = []\\n        for age in l:\\n            if not prefixSum:\\n                prefixSum.append(c[age])\\n\\n            else:\\n                prefixSum.append(c[age]+prefixSum[-1])\\n\\n        \\n        ans = 0\\n        for i in range(len(l)):\\n            age = l[i]\\n            start = 0\\n            end = i-1\\n            last = -1\\n            while start <= end:\\n                m = (start + end) //2\\n                if l[m] <= 0.5*l[i]+7:\\n                    start = m+1\\n\\n                else:\\n                    last = m\\n                    end = m-1\\n\\n            if last>=0:\\n                if last == 0:\\n                    s = prefixSum[i-1]\\n                \\n                else:\\n                    s = prefixSum[i-1] - prefixSum[last-1]\\n\\n                ans += c[age] * s\\n\\n            if age > 14:\\n                ans += c[age] * (c[age]-1)\\n\\n        return ans\\n\\n\\n        \\n```\\n\\n# Code Approach 2: Two Pointers\\n\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        c = Counter(ages)\\n        l = [age for age in c.keys()]\\n        l.sort()\\n        prefixSum = []\\n        for age in l:\\n            if not prefixSum:\\n                prefixSum.append(c[age])\\n\\n            else:\\n                prefixSum.append(c[age]+prefixSum[-1])\\n\\n        \\n        ans = 0\\n        last = 0\\n        for i in range(len(l)):\\n            age = l[i]\\n        \\n            while last <= i-2 and l[last] <= 0.5 * age + 7:\\n                last += 1\\n\\n            if last <= i-1 and l[last] > 0.5 * age + 7:\\n                if last == 0:\\n                    s = prefixSum[i-1]\\n                \\n                else:\\n                    s = prefixSum[i-1] - prefixSum[last-1]\\n\\n                ans += c[age] * s\\n\\n            if age > 14:\\n                ans += c[age] * (c[age]-1)\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        c = Counter(ages)\\n        l = [age for age in c.keys()]\\n        l.sort()\\n        prefixSum = []\\n        for age in l:\\n            if not prefixSum:\\n                prefixSum.append(c[age])\\n\\n            else:\\n                prefixSum.append(c[age]+prefixSum[-1])\\n\\n        \\n        ans = 0\\n        for i in range(len(l)):\\n            age = l[i]\\n            start = 0\\n            end = i-1\\n            last = -1\\n            while start <= end:\\n                m = (start + end) //2\\n                if l[m] <= 0.5*l[i]+7:\\n                    start = m+1\\n\\n                else:\\n                    last = m\\n                    end = m-1\\n\\n            if last>=0:\\n                if last == 0:\\n                    s = prefixSum[i-1]\\n                \\n                else:\\n                    s = prefixSum[i-1] - prefixSum[last-1]\\n\\n                ans += c[age] * s\\n\\n            if age > 14:\\n                ans += c[age] * (c[age]-1)\\n\\n        return ans\\n\\n\\n        \\n```\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        c = Counter(ages)\\n        l = [age for age in c.keys()]\\n        l.sort()\\n        prefixSum = []\\n        for age in l:\\n            if not prefixSum:\\n                prefixSum.append(c[age])\\n\\n            else:\\n                prefixSum.append(c[age]+prefixSum[-1])\\n\\n        \\n        ans = 0\\n        last = 0\\n        for i in range(len(l)):\\n            age = l[i]\\n        \\n            while last <= i-2 and l[last] <= 0.5 * age + 7:\\n                last += 1\\n\\n            if last <= i-1 and l[last] > 0.5 * age + 7:\\n                if last == 0:\\n                    s = prefixSum[i-1]\\n                \\n                else:\\n                    s = prefixSum[i-1] - prefixSum[last-1]\\n\\n                ans += c[age] * s\\n\\n            if age > 14:\\n                ans += c[age] * (c[age]-1)\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751261,
                "title": "c-best-approach-and-easy-to-understand-t-c-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nfind all the age less then age[i] and find minimum age[j] (j<i) such that it follows the condition of friend request and all the ages after jth age till age[i] will follow the condition to send request.\\nso add (i-j) to count.\\n\\nAlong with the upper approach here is one catch.\\n\\nif we have same elements like [16,16,16]\\nnow as per the above example all the three 16 will be able to make friends with other two 16 so total requests sent is 3*(2 each)=6\\nso in such repeating ages what we will do is to count the number of repeating ages and find the requests for last most repeated age and multiply that answer with total number of repeated ages....\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nNlog(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nConstant space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLowerBound(vector<int>& a,int n,int x)\\n    {\\n        int l=0;\\n        int r=n-1;\\n        int ans=-1;\\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2;\\n            if(a[mid]>x/2+7)\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n\\n        return ans;\\n    }\\n\\n    int numFriendRequests(vector<int>& a) {\\n        \\n        sort(a.begin(),a.end());\\n        int count=0;\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n\\n            int j=i;\\n            int sameOccurences=0;\\n            while(j<n && a[i]==a[j])\\n            {\\n                j++;\\n                sameOccurences++;\\n            }\\n            int lowerBound=findLowerBound(a,j-1,a[i]);\\n            //cout<<\"i:\"<<i<<\"LB\"<<lowerBound<<endl;\\n            if(lowerBound!=-1)\\n            {\\n                count+=(j-1-lowerBound)*sameOccurences;\\n            }\\n            i=j-1;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLowerBound(vector<int>& a,int n,int x)\\n    {\\n        int l=0;\\n        int r=n-1;\\n        int ans=-1;\\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2;\\n            if(a[mid]>x/2+7)\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n\\n        return ans;\\n    }\\n\\n    int numFriendRequests(vector<int>& a) {\\n        \\n        sort(a.begin(),a.end());\\n        int count=0;\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n\\n            int j=i;\\n            int sameOccurences=0;\\n            while(j<n && a[i]==a[j])\\n            {\\n                j++;\\n                sameOccurences++;\\n            }\\n            int lowerBound=findLowerBound(a,j-1,a[i]);\\n            //cout<<\"i:\"<<i<<\"LB\"<<lowerBound<<endl;\\n            if(lowerBound!=-1)\\n            {\\n                count+=(j-1-lowerBound)*sameOccurences;\\n            }\\n            i=j-1;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3733163,
                "title": "c-upper-bound-start-and-end-of-range",
                "content": "1. Sort the Ages array\\n2. Find a range of appropriate ages to send requests to. Use *upper bound* flavor of binary search to place a pointer 1 after the first acceptable ages[i], and a pointer 1 position after the current ages[i]\\n3. Count the size of this range.\\n\\n```\\nclass Solution {\\npublic:\\n  int numFriendRequests(vector<int>& ages) {\\n    std::sort(ages.begin(), ages.end());\\n    int n = ages.size(), count = 0;\\n\\n    for (int i = 0; i < n; ++i) {\\n      int low_index = std::upper_bound(ages.begin(), ages.end(), (ages[i] / 2) + 7) - ages.begin();\\n      int high_index = std::upper_bound(ages.begin(), ages.end(), ages[i]) - ages.begin();\\n      count += std::max(high_index - low_index - 1, 0);\\n    }\\n\\n    return count;\\n  }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int numFriendRequests(vector<int>& ages) {\\n    std::sort(ages.begin(), ages.end());\\n    int n = ages.size(), count = 0;\\n\\n    for (int i = 0; i < n; ++i) {\\n      int low_index = std::upper_bound(ages.begin(), ages.end(), (ages[i] / 2) + 7) - ages.begin();\\n      int high_index = std::upper_bound(ages.begin(), ages.end(), ages[i]) - ages.begin();\\n      count += std::max(high_index - low_index - 1, 0);\\n    }\\n\\n    return count;\\n  }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690755,
                "title": "array",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf the negation of the second condition is True, then the negation of the third condition is True.(suppose age[y] <= age[x] and age[y] > 100 --> age[x] > 100 --> thus age[x] >= 100) Hence we could discard the third condition.\\n\\nSince range of age is relative small to the input size, DAA may come in handy.\\n\\nFrom the negation of the second condition we could realize that we might overcount someone who sends a friend request to themself and suppose his/her age is x. As the negation of the first condition is met, 2x > x + 14 --> x > 14.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(121)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ret = 0\\n        L = [0 for _ in range(121)]\\n        \\n        for age in ages:\\n            L[age] += 1\\n        \\n        for age_x in range(1, 121):\\n            for age_y in range(age_x//2+8, age_x+1):\\n                ret += L[age_x] * L[age_y]\\n            \\n            if age_x > 14:\\n                ret -= L[age_x]\\n        \\n        return ret\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ret = 0\\n        L = [0 for _ in range(121)]\\n        \\n        for age in ages:\\n            L[age] += 1\\n        \\n        for age_x in range(1, 121):\\n            for age_y in range(age_x//2+8, age_x+1):\\n                ret += L[age_x] * L[age_y]\\n            \\n            if age_x > 14:\\n                ret -= L[age_x]\\n        \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689143,
                "title": "swift-easy-solution-using-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n   func numFriendRequests(_ ages: [Int]) -> Int {\\n    var requestCount = 0\\n    var ages = ages.sorted()\\n    var length = ages.count\\n    for i in 0..<length{\\n        var leftMostValidIndex = -1\\n        var start1 = 0\\n        var end1 = length-1\\n        while start1 <= end1{\\n            var mid = start1 + (end1 - start1)/2\\n            if Double(ages[mid]) > Double(0.5) * Double(ages[i]) + 7{\\n                leftMostValidIndex = mid\\n                end1 = mid-1\\n            } else {\\n                start1 = mid+1\\n            }\\n        }\\n        if leftMostValidIndex < 0{\\n            continue\\n        }\\n        var rightmostValidIndex = -1\\n        var start = 0\\n        var end = length-1\\n        while start <= end{\\n            var mid = start + (end - start)/2\\n            if ages[mid] <= ages[i]{\\n                rightmostValidIndex = mid\\n                start = mid + 1\\n            }else{\\n                end = mid-1\\n            }\\n        }\\n        var count = rightmostValidIndex - leftMostValidIndex\\n        if count > 0{\\n            requestCount += count\\n        }else{\\n            requestCount += 0\\n        }\\n       \\n    }\\n    return requestCount\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n   func numFriendRequests(_ ages: [Int]) -> Int {\\n    var requestCount = 0\\n    var ages = ages.sorted()\\n    var length = ages.count\\n    for i in 0..<length{\\n        var leftMostValidIndex = -1\\n        var start1 = 0\\n        var end1 = length-1\\n        while start1 <= end1{\\n            var mid = start1 + (end1 - start1)/2\\n            if Double(ages[mid]) > Double(0.5) * Double(ages[i]) + 7{\\n                leftMostValidIndex = mid\\n                end1 = mid-1\\n            } else {\\n                start1 = mid+1\\n            }\\n        }\\n        if leftMostValidIndex < 0{\\n            continue\\n        }\\n        var rightmostValidIndex = -1\\n        var start = 0\\n        var end = length-1\\n        while start <= end{\\n            var mid = start + (end - start)/2\\n            if ages[mid] <= ages[i]{\\n                rightmostValidIndex = mid\\n                start = mid + 1\\n            }else{\\n                end = mid-1\\n            }\\n        }\\n        var count = rightmostValidIndex - leftMostValidIndex\\n        if count > 0{\\n            requestCount += count\\n        }else{\\n            requestCount += 0\\n        }\\n       \\n    }\\n    return requestCount\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683837,
                "title": "easy-solution-from-byte-benders",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n    \\n        int[] agecount = new int[121];\\n        for(int age : ages)\\n        {\\n            agecount[age]++;\\n        }\\n    int cnt=0;\\n    for(int i=1;i<=120;i++)\\n    {\\n        for(int j=i/2+8;j<=i;j++)\\n        {\\n            cnt+=agecount[i] * (agecount[j]-(i==j?1:0));\\n        }\\n    }\\n    return cnt;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n    /*class Solution {\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i:ages){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        }\\n        int count=0;\\n        for(int i1:map.keySet())\\n        {\\n            for(int i2:map.keySet()){\\n                if(help(i1,i2)){\\n                    count+=map.get(i1)*map.get(i2);\\n                    if(i1==i2)count-=map.get(i1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public static boolean help(int i1,int i2)\\n    {\\n        return i1<=(int)((i2/2)+7) || i1>i2?false:true;\\n    } \\n}\\n*/}}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n    \\n        int[] agecount = new int[121];\\n        for(int age : ages)\\n        {\\n            agecount[age]++;\\n        }\\n    int cnt=0;\\n    for(int i=1;i<=120;i++)\\n    {\\n        for(int j=i/2+8;j<=i;j++)\\n        {\\n            cnt+=agecount[i] * (agecount[j]-(i==j?1:0));\\n        }\\n    }\\n    return cnt;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n    /*class Solution {\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i:ages){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        }\\n        int count=0;\\n        for(int i1:map.keySet())\\n        {\\n            for(int i2:map.keySet()){\\n                if(help(i1,i2)){\\n                    count+=map.get(i1)*map.get(i2);\\n                    if(i1==i2)count-=map.get(i1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public static boolean help(int i1,int i2)\\n    {\\n        return i1<=(int)((i2/2)+7) || i1>i2?false:true;\\n    } \\n}\\n*/}}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615441,
                "title": "c-simple-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> v(121);\\n        for (auto& n : ages) if (n > 14) ++v[n];\\n        int ans = 0, c = 0;\\n        for (int i = 15; i <= 120; ++i){\\n            c += v[i] - v[i / 2 + 7];\\n            v[i / 2 + 7] = 0;\\n            ans += v[i] * (c - 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> v(121);\\n        for (auto& n : ages) if (n > 14) ++v[n];\\n        int ans = 0, c = 0;\\n        for (int i = 15; i <= 120; ++i){\\n            c += v[i] - v[i / 2 + 7];\\n            v[i / 2 + 7] = 0;\\n            ans += v[i] * (c - 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614765,
                "title": "python3-straightforward-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        counts = [0]*121\\n        \\n        for a in ages:\\n            counts[a]+=1\\n        ans = 0\\n        \\n        for i in ages:\\n            for j in range(i, 0, -1):\\n                if i==j and counts[i]==1: continue\\n                if counts[j]==0: continue\\n                if j<=0.5*i+7: continue\\n                if i==j:\\n                    ans += counts[j]-1\\n                else:\\n                    ans += counts[j]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        counts = [0]*121\\n        \\n        for a in ages:\\n            counts[a]+=1\\n        ans = 0\\n        \\n        for i in ages:\\n            for j in range(i, 0, -1):\\n                if i==j and counts[i]==1: continue\\n                if counts[j]==0: continue\\n                if j<=0.5*i+7: continue\\n                if i==j:\\n                    ans += counts[j]-1\\n                else:\\n                    ans += counts[j]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522862,
                "title": "friends-of-appropriate-ages-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        int numFriendRequests(vector<int>& ages) {\\n        unordered_map<int, int> count;\\n        for (int &age : ages)\\n            count[age]++;\\n        int res = 0;\\n        for (auto &a : count)\\n            for (auto &b : count)\\n                if (request(a.first, b.first))\\n                    res += a.second * (b.second - (a.first == b.first ? 1 : 0));\\n        return res;\\n    }\\n\\n    bool request(int a, int b) {\\n        return !(b <= 0.5 * a + 7 || b > a || (b > 100 && a < 100));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        int numFriendRequests(vector<int>& ages) {\\n        unordered_map<int, int> count;\\n        for (int &age : ages)\\n            count[age]++;\\n        int res = 0;\\n        for (auto &a : count)\\n            for (auto &b : count)\\n                if (request(a.first, b.first))\\n                    res += a.second * (b.second - (a.first == b.first ? 1 : 0));\\n        return res;\\n    }\\n\\n    bool request(int a, int b) {\\n        return !(b <= 0.5 * a + 7 || b > a || (b > 100 && a < 100));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497884,
                "title": "counting-the-number-of-people-in-different-age-using-list-no-binary-search",
                "content": "# Intuition\\nIf age i can send request to age j, the number of request is #i*#j if i!=j, else #i*(#i-1) because it wont send request to it self.\\nThus, we can group the number of people in different ages.\\nFor any age i, we need to find its bounrdary of age for sending request. There are two conditions: j<=0.5*i+7 or j>i. **Note** the first condition, event though j>0.5*i+7 but j>i, i won\\'t sent request! \\n\\n# Approach\\nGroup the people in differnt ages. Note that, if a dictionary or a Counters is used for this purpose, every time we find the lower bound of i (j>0.5*i+7, and j<i), we need to go through the age list again, which takes O(N) (binary search cost O(logN)).\\nBecause the age range is fixed, we can use a list for this purpose c = [0]*121 to indicate the age (0,120).\\nIf i>0.5*i+7, the number of request within the age group i is c\\\\[i\\\\]*(c\\\\[i\\\\]-1)\\nIf j=0.5*i+7, and j<i, j!=i, the request between age i and ages (j+1,i-1) is sum(cc\\\\[j+1:i\\\\])*c\\\\[i\\\\]\\n\\n# Complexity\\n- Time complexity:\\nGroup the ages takes O(N), loop to calculate the request O(#age), so total O(N+#age)=O(N)\\n\\n- Space complexity:\\nO(121) to store the number of people in different age\\n\\n# Code\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        count = [0]*121\\n        age = set()\\n        print(sorted(ages))\\n        for i in ages:\\n            count[i]+=1\\n            age.add(i)\\n\\n        res = 0\\n        for i in age:\\n            b = i//2+7\\n            \\n            if b<i:\\n                res += (count[i]-1)*count[i]\\n            \\n            if b<=i:\\n                s = sum(count[b+1:i])\\n            else:\\n                s=0\\n            \\n            res +=s*count[i]\\n            print(i,b,s,res)\\n        return res\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        count = [0]*121\\n        age = set()\\n        print(sorted(ages))\\n        for i in ages:\\n            count[i]+=1\\n            age.add(i)\\n\\n        res = 0\\n        for i in age:\\n            b = i//2+7\\n            \\n            if b<i:\\n                res += (count[i]-1)*count[i]\\n            \\n            if b<=i:\\n                s = sum(count[b+1:i])\\n            else:\\n                s=0\\n            \\n            res +=s*count[i]\\n            print(i,b,s,res)\\n        return res\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475843,
                "title": "ez-understand-python-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven that the total number of age cohorts is predetermined, a prudent approach would involve a preliminary enumeration of each cohort, followed by a systematic examination of each group.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. To effectively analyze the data, we can compile a comprehensive list of each age and its corresponding population count, denoted as (x, y).\\n2. Next, we can systematically examine each entry in the counter list and evaluate the specified conditions.\\n3. For each instance where the condition is met, we can compute the product of the relevant figures and accumulate the results in a variable named \\'res\\'.\\n4. In the event that we need to assess the number of individuals within the same age group, we can multiply the population count of that age by the count of individuals in the same group minus one, since it is possible for each person to have a friend who is not themselves.\\n# Complexity\\n- Time complexity: O(max(N, 120)) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        # counter list (x, y) where x is the age and y is the number of people at that age\\n        counter = []\\n        for age in ages:\\n            new = True\\n            for i in range(len(counter)):\\n                if counter[i][0] == age:\\n                    counter[i][1] += 1\\n                    new = False\\n            if new:\\n                counter.append([age, 1])\\n        # go through the counter list and check the condition\\n        res = 0\\n        for i in range(len(counter)):\\n            for j in range(len(counter)):\\n                # check condition\\n                if counter[j][0] <= 0.5 * counter[i][0] + 7 or counter[j][0] > counter[i][0]:\\n                    continue\\n                else:\\n                    if i != j:\\n                        res += counter[j][1] * counter[i][1]\\n                    else:\\n                        if counter[j][1] > 1:\\n                            res += counter[j][1] * (counter[i][1] - 1)\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        # counter list (x, y) where x is the age and y is the number of people at that age\\n        counter = []\\n        for age in ages:\\n            new = True\\n            for i in range(len(counter)):\\n                if counter[i][0] == age:\\n                    counter[i][1] += 1\\n                    new = False\\n            if new:\\n                counter.append([age, 1])\\n        # go through the counter list and check the condition\\n        res = 0\\n        for i in range(len(counter)):\\n            for j in range(len(counter)):\\n                # check condition\\n                if counter[j][0] <= 0.5 * counter[i][0] + 7 or counter[j][0] > counter[i][0]:\\n                    continue\\n                else:\\n                    if i != j:\\n                        res += counter[j][1] * counter[i][1]\\n                    else:\\n                        if counter[j][1] > 1:\\n                            res += counter[j][1] * (counter[i][1] - 1)\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457445,
                "title": "c-binary-search-63ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(),ages.end());\\n        int n=ages.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(ages[i]>13){\\n                int x=lower_bound(ages.begin(),ages.end(),ages[i]/2 + 8)-ages.begin();\\n                int y=upper_bound(ages.begin(),ages.end(),ages[i])-ages.begin();\\n                // while(y<n && ages[y]==ages[i]) y++;\\n                if(x<y) ans+=(y-i)*(y-x-1);\\n                i=y;\\n                if(y<n) i--;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(),ages.end());\\n        int n=ages.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(ages[i]>13){\\n                int x=lower_bound(ages.begin(),ages.end(),ages[i]/2 + 8)-ages.begin();\\n                int y=upper_bound(ages.begin(),ages.end(),ages[i])-ages.begin();\\n                // while(y<n && ages[y]==ages[i]) y++;\\n                if(x<y) ans+=(y-i)*(y-x-1);\\n                i=y;\\n                if(y<n) i--;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361480,
                "title": "simple-binary-search-python-implementation",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        ans = 0\\n        for i in range(len(ages)):\\n            idx1 = bisect_right(ages, ages[i])\\n            idx2 = bisect_right(ages, ages[i]*0.5+7)\\n            ans+=max(0,idx1-idx2-1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        ans = 0\\n        for i in range(len(ages)):\\n            idx1 = bisect_right(ages, ages[i])\\n            idx2 = bisect_right(ages, ages[i]*0.5+7)\\n            ans+=max(0,idx1-idx2-1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345251,
                "title": "javascript-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCount amount of people for each age. Go through hash array and check conditions for `x` and `y`. Get amount of requests by multiplying `arr[x]` and `arr[y]`. If `x` equals `y` we subtract `1` as a person will not send a friend request to themself.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} ages\\n * @return {number}\\n */\\nvar numFriendRequests = function(ages) {\\n    let arr = new Array(121).fill(0);\\n    let result = 0;\\n\\n    for (let i = 0; i < ages.length; i++) {\\n        arr[ages[i]]++;\\n    }\\n\\n    for (let x = 0; x < arr.length; x++) {\\n        for (let y = 0; y <= x; y++) {\\n            if (y <= (0.5 * x + 7)) {\\n                continue;\\n            } else {\\n                if (x === y) {\\n                    result += (arr[x] - 1) * arr[y];\\n                } else {\\n                    result += arr[x] * arr[y];\\n                }\\n            }\\n        }\\n    }\\n\\n    return result;\\n};\\n```\\n\\nUpdated version: one of conditions `y > (0.5 * x + 7)` so we can start `for` from this value + 1 to reduce iterations and make it really shorter.\\n\\n```\\n/* Hide the same code... */\\n\\nfor (let x = 0; x < arr.length; x++) {\\n    for (let y = Math.floor(0.5 * x + 7) + 1; y <= x; y++) {\\n        result += (arr[x] - (x === y)) * arr[y];\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} ages\\n * @return {number}\\n */\\nvar numFriendRequests = function(ages) {\\n    let arr = new Array(121).fill(0);\\n    let result = 0;\\n\\n    for (let i = 0; i < ages.length; i++) {\\n        arr[ages[i]]++;\\n    }\\n\\n    for (let x = 0; x < arr.length; x++) {\\n        for (let y = 0; y <= x; y++) {\\n            if (y <= (0.5 * x + 7)) {\\n                continue;\\n            } else {\\n                if (x === y) {\\n                    result += (arr[x] - 1) * arr[y];\\n                } else {\\n                    result += arr[x] * arr[y];\\n                }\\n            }\\n        }\\n    }\\n\\n    return result;\\n};\\n```\n```\\n/* Hide the same code... */\\n\\nfor (let x = 0; x < arr.length; x++) {\\n    for (let y = Math.floor(0.5 * x + 7) + 1; y <= x; y++) {\\n        result += (arr[x] - (x === y)) * arr[y];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3341362,
                "title": "no-need-to-sort-o-n-solution",
                "content": "# Intuition\\nAge constraint is very less(<=120). Bucket map can be created to hold count of people by age\\n\\n# Approach\\nWith given condition, friend request can be sent to only people with age greater than ages[i]/2+7 and lesser than ages[i]. \\nAnd map[ages[i]]-map[cond]-1 will give us total no of people that can be friend listed\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(121)\\n\\n# Code\\n```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int map[]=new int[121];\\n        for(int j=0;j<ages.length;j++){\\n            map[ages[j]]++;\\n        }\\n\\n        for(int i=1;i<=120;i++){\\n            map[i]+=map[i-1];\\n        }\\n        int totalFriend=0;\\n        for(int i=0;i<ages.length;i++){\\n            int cond=ages[i]/2+7;\\n            if(cond>=ages[i]){\\n                continue;\\n            }\\n            totalFriend+=map[ages[i]]-map[cond]-1;\\n        }\\n        return totalFriend;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int map[]=new int[121];\\n        for(int j=0;j<ages.length;j++){\\n            map[ages[j]]++;\\n        }\\n\\n        for(int i=1;i<=120;i++){\\n            map[i]+=map[i-1];\\n        }\\n        int totalFriend=0;\\n        for(int i=0;i<ages.length;i++){\\n            int cond=ages[i]/2+7;\\n            if(cond>=ages[i]){\\n                continue;\\n            }\\n            totalFriend+=map[ages[i]]-map[cond]-1;\\n        }\\n        return totalFriend;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299954,
                "title": "c",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool check(int A, int B){\\n        if(B <= 0.5 * A + 7 )\\n            return false ;\\n        if(B > A)\\n            return false ;\\n        if(B > 100 && A < 100)\\n            return false ;\\n        return true ;\\n    }\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int ret = 0 ;\\n        unordered_map<int, int>Map ; //{age, count}  \\n        for(auto& a : ages)\\n            Map[a]++ ;\\n        \\n        for(auto& [ageA, numA] : Map)\\n        {\\n            for(auto& [ageB, numB] : Map)\\n            {\\n                if(check(ageA, ageB)){\\n                    if(ageA == ageB)\\n                        ret += numA * (numA - 1) ; \\n                    else\\n                        ret += numA * numB ;\\n                }\\n            }\\n        }    \\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool check(int A, int B){\\n        if(B <= 0.5 * A + 7 )\\n            return false ;\\n        if(B > A)\\n            return false ;\\n        if(B > 100 && A < 100)\\n            return false ;\\n        return true ;\\n    }\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int ret = 0 ;\\n        unordered_map<int, int>Map ; //{age, count}  \\n        for(auto& a : ages)\\n            Map[a]++ ;\\n        \\n        for(auto& [ageA, numA] : Map)\\n        {\\n            for(auto& [ageB, numB] : Map)\\n            {\\n                if(check(ageA, ageB)){\\n                    if(ageA == ageB)\\n                        ret += numA * (numA - 1) ; \\n                    else\\n                        ret += numA * numB ;\\n                }\\n            }\\n        }    \\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232791,
                "title": "c-solution-time-o-n-space-o-1-hashmap-and-prefix-sum",
                "content": "# Intuition\\nMake a prefix array to store the count of people till the age (age == index).\\nTo make prefix array first we will make a hashmap to store count of people of particular age (without sorting);\\n\\n# Approach\\n- Make a **count** array to store the count of people of particular age.\\n- Make a **prefixSum** array to store the count of people less than or equal to the current age (index).\\n- Traverse the **prefixSum** array and add the number of people satisfy the condition given in question in contant time.\\n- Please **upvote** if you find approach helpful.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> count(121, 0);\\n\\n        for(auto it: ages) {\\n            count[it]++;\\n        }\\n\\n        vector<int> prefixSum(121, 0);\\n        for(int i=1; i<121; i++) {\\n            prefixSum[i] = prefixSum[i-1] + count[i];\\n        }\\n\\n        int res = 0;\\n        for(int i=1; i<121; i++) {\\n            int min = (i/2) + 7;\\n            if(min >= i) {\\n                continue;\\n            }\\n\\n            res += (count[i] * (count[i] - 1));\\n            res += (prefixSum[i-1] - prefixSum[min]) * count[i];\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> count(121, 0);\\n\\n        for(auto it: ages) {\\n            count[it]++;\\n        }\\n\\n        vector<int> prefixSum(121, 0);\\n        for(int i=1; i<121; i++) {\\n            prefixSum[i] = prefixSum[i-1] + count[i];\\n        }\\n\\n        int res = 0;\\n        for(int i=1; i<121; i++) {\\n            int min = (i/2) + 7;\\n            if(min >= i) {\\n                continue;\\n            }\\n\\n            res += (count[i] * (count[i] - 1));\\n            res += (prefixSum[i-1] - prefixSum[min]) * count[i];\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228546,
                "title": "c-solution-using-map-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        unordered_map<int,int> temp;\\n        int req=0;\\n        for(int i:ages)   //storing value and its frequency in map\\n            temp[i]++;\\n        for(auto &a:temp)\\n            for(auto &b:temp)\\n            {\\n                if(checkt(a.first,b.first))  //checking for the conditions for friends request\\n                {\\n                    if(a.first==b.first)  //if frequency of that age is more than one\\n                        req+=(a.second)*(b.second-1);\\n                    else                 //if it occured only once in map\\n                        req+=(a.second)*(b.second);\\n                }\\n            }\\n        return req;   //returning the request\\n    }\\n    bool checkt(int a,int b)\\n    {\\n        return !(b <= 0.5 * a + 7 || b > a );\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        unordered_map<int,int> temp;\\n        int req=0;\\n        for(int i:ages)   //storing value and its frequency in map\\n            temp[i]++;\\n        for(auto &a:temp)\\n            for(auto &b:temp)\\n            {\\n                if(checkt(a.first,b.first))  //checking for the conditions for friends request\\n                {\\n                    if(a.first==b.first)  //if frequency of that age is more than one\\n                        req+=(a.second)*(b.second-1);\\n                    else                 //if it occured only once in map\\n                        req+=(a.second)*(b.second);\\n                }\\n            }\\n        return req;   //returning the request\\n    }\\n    bool checkt(int a,int b)\\n    {\\n        return !(b <= 0.5 * a + 7 || b > a );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202645,
                "title": "java-group-by-age-and-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Looking at the input data, the ages are between 1 and 120. \\nIf person of age X can send a friend request to person of age Y, it means ALL people of age X can sent requests to ALL people of age Y.\\nThis means it makes more sense to COUNT each age in an int[121]\\n2. Looking at the criteria age[y] > age[x], we see a younger person cannot befriend an older person.\\nSo we have to traverse this array from right to left, checking if person of age 120 can befriend age 120, 119..1.\\n3. If can yes, if i == j (same group) add the permutation (n! / (n-2)!) which is n * (n-1).\\nif i !=j, then add their multiplication. (group[i] * group[j]).\\n\\n# Complexity\\n- Time complexity:$$O(n + 120 * 120)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(121)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] peopleAges = new int[121];\\n        int requests = 0;\\n        for (int age : ages) {\\n            peopleAges[age]++;\\n        }\\n        for (int i = peopleAges.length -1; i>= 1; i--) {\\n            if (peopleAges[i] > 0) {\\n                boolean canBefriend = true;\\n                for (int j = i; j >= 1 && canBefriend; j--) {\\n                    if (peopleAges[j] > 0 && (canBefriend = canBefriend(i, j))) {\\n                        requests += (i == j ? peopleAges[i] * (peopleAges[i]-1) : peopleAges[i] * peopleAges[j]);   \\n                    }\\n                }\\n            }\\n        }\\n        return requests;\\n    }\\n\\n    private boolean canBefriend(int i, int j) {\\n        return !(j <= 0.5 * i + 7 || j > 100 && i < 100);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] peopleAges = new int[121];\\n        int requests = 0;\\n        for (int age : ages) {\\n            peopleAges[age]++;\\n        }\\n        for (int i = peopleAges.length -1; i>= 1; i--) {\\n            if (peopleAges[i] > 0) {\\n                boolean canBefriend = true;\\n                for (int j = i; j >= 1 && canBefriend; j--) {\\n                    if (peopleAges[j] > 0 && (canBefriend = canBefriend(i, j))) {\\n                        requests += (i == j ? peopleAges[i] * (peopleAges[i]-1) : peopleAges[i] * peopleAges[j]);   \\n                    }\\n                }\\n            }\\n        }\\n        return requests;\\n    }\\n\\n    private boolean canBefriend(int i, int j) {\\n        return !(j <= 0.5 * i + 7 || j > 100 && i < 100);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159901,
                "title": "python-binary-search-solution-92-faster",
                "content": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        counter = dict()\\n\\n        for age in ages:\\n            if age in counter:\\n                counter[age] += 1\\n            else:\\n                counter[age] = 1\\n\\n        res = 0\\n        keys = sorted(list(counter.keys()))\\n        val = [counter[key] for key in keys]\\n        prefix = [val[0]]\\n        for i in range(1,len(keys)):prefix.append(prefix[-1] + val[i])\\n\\n        x = (0.5 * keys[0])+ 7\\n        if keys[0] > x:res += (counter[keys[0]] - 1) * counter[keys[0]]\\n\\n        for i in range(1,len(keys)):\\n            x = (0.5 * keys[i])+ 7\\n\\n            if keys[i] > x:res += (counter[keys[i]] - 1) * counter[keys[i]]\\n\\n            index = bisect.bisect_right(keys,x)\\n            \\n            cur = prefix[i-1]\\n            if index > 0:cur -= prefix[index-1]\\n            cur *= counter[keys[i]]\\n            res += max(0,cur)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        counter = dict()\\n\\n        for age in ages:\\n            if age in counter:\\n                counter[age] += 1\\n            else:\\n                counter[age] = 1\\n\\n        res = 0\\n        keys = sorted(list(counter.keys()))\\n        val = [counter[key] for key in keys]\\n        prefix = [val[0]]\\n        for i in range(1,len(keys)):prefix.append(prefix[-1] + val[i])\\n\\n        x = (0.5 * keys[0])+ 7\\n        if keys[0] > x:res += (counter[keys[0]] - 1) * counter[keys[0]]\\n\\n        for i in range(1,len(keys)):\\n            x = (0.5 * keys[i])+ 7\\n\\n            if keys[i] > x:res += (counter[keys[i]] - 1) * counter[keys[i]]\\n\\n            index = bisect.bisect_right(keys,x)\\n            \\n            cur = prefix[i-1]\\n            if index > 0:cur -= prefix[index-1]\\n            cur *= counter[keys[i]]\\n            res += max(0,cur)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141346,
                "title": "java-solution-with-seperate-int-array",
                "content": "# Intuition/Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly I looked at the lowest number that can send/recieve friend requests. This turns out to be 15 as 15*0.5+7=14.5, which is lower than 15. Additionally 15 is not larger than 15.\\n\\nWith every other n (1<=n<=14) this won\\'t work. \\nI.e. 14*0.5+7 =14 which is equal to 14 and therefore wont work according to the first rule (age[y] <= 0.5 * age[x] + 7 =>will not send a friend request );\\n\\nAfter this one can add up every number with equal value in a seperate int[] Array with the length of 121 as 1<=n<=120. \\n\\nNext one can add up every possible friend Request between certain ages. \\nWithin the same age>=15 every person of that age can send every other person of the same age a friend request. \\nfriendRequests+=(sameNumbers-1)*sameNumbers; \\nHere numbers are the individual ages.\\n\\nEvery person of a certain age can send friend requests to people of lower ages who are equal to age/2+7+1.\\nThe total amount of people of lower ages which a specific age can send friend requests to are summed up in a loop.\\nFinally the total amount of people of a certain age send friend requests to people of lower ages up to the lower bound (age/2+7+1).\\n\\nfriendRequests+=validLowerNumbers*sameNumbers;\\n\\nFinally this can be done for every age individually and summed up and returned.\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int friendRequests=0;\\n    int[] totalCount= new int[121];\\n\\n    public int numFriendRequests(int[] ages) {\\n        \\n        for(int a=0;a<ages.length;a++)\\n        {\\n            totalCount[ages[a]]+=1;\\n        }\\n\\n        int sameNumbers;\\n        int validLowerNumbers=0;\\n        \\n        for(int a=15; a<121;a++)\\n        {\\n            int lowestAccepted= a/2+7+1;\\n            sameNumbers=totalCount[a];\\n\\n            validLowerNumbers=0;\\n\\n            for(int b=lowestAccepted; b<a;b++)\\n            {\\n                validLowerNumbers+=totalCount[b];\\n            }\\n            friendRequests+=(sameNumbers-1)*sameNumbers;\\n            friendRequests+=validLowerNumbers*sameNumbers;\\n        }\\n        \\n        return friendRequests;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int friendRequests=0;\\n    int[] totalCount= new int[121];\\n\\n    public int numFriendRequests(int[] ages) {\\n        \\n        for(int a=0;a<ages.length;a++)\\n        {\\n            totalCount[ages[a]]+=1;\\n        }\\n\\n        int sameNumbers;\\n        int validLowerNumbers=0;\\n        \\n        for(int a=15; a<121;a++)\\n        {\\n            int lowestAccepted= a/2+7+1;\\n            sameNumbers=totalCount[a];\\n\\n            validLowerNumbers=0;\\n\\n            for(int b=lowestAccepted; b<a;b++)\\n            {\\n                validLowerNumbers+=totalCount[b];\\n            }\\n            friendRequests+=(sameNumbers-1)*sameNumbers;\\n            friendRequests+=validLowerNumbers*sameNumbers;\\n        }\\n        \\n        return friendRequests;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116814,
                "title": "functional-o-n-69ms-runtime-nice",
                "content": "# Intuition\\n\\n* People below age 15 are not able to request or be requested by anyone, because of the first condition.\\n* The third condition is a red herring.\\n* To solve for just the second condition, we can iterate through a mapping of the number of people by age, and add to a running total of requests as well as a running total of lower aged people.\\n  * The running total of lower aged people is used to compute how many people someone at the current age would request, which can then be multiplied by how many people have that current age and added into the running total of requests.\\n  * To extend this to account for the first condition as well, we change our running total of lower aged people into the number of people who should still be requested.\\n    * We update the running total of lower aged people to still request as people \\'age out\\', which happens at every other age we visit because of the `0.5`(aka `1 / 2`) in the first condition.\\n\\n# Approach\\nMake a mapping of the number of people by age, and then reduce it to the total requests, utilizing an appropriate running number of people who should still be requested, as we compute all the requests happening at or below each age. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nfunction numFriendRequests(ages: number[]): number {\\n    const numOfPeopleByAge = new Array(120 + 1).fill(0, 15, 120 + 1) ; ages.forEach(age => {\\n        if (age >= 15)\\n            numOfPeopleByAge[age]++\\n    })\\n    const [_, totalRequests] = numOfPeopleByAge.reduce(\\n        ([lowerAgedPeopleToRequest, totalRequests], numOfPeopleWithCurrentAge, currentAge, numOfPeopleByAge) => {\\n            if (currentAge % 2 == 0)\\n                lowerAgedPeopleToRequest -= numOfPeopleByAge[0.5 * currentAge + 7]\\n            const numOfPeopleToRequestAtCurrentAge = (numOfPeopleWithCurrentAge - 1 + lowerAgedPeopleToRequest)\\n            totalRequests += numOfPeopleToRequestAtCurrentAge * numOfPeopleWithCurrentAge\\n            lowerAgedPeopleToRequest += numOfPeopleWithCurrentAge\\n            return [lowerAgedPeopleToRequest, totalRequests]\\n        }, [0, 0])\\n    return totalRequests\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction numFriendRequests(ages: number[]): number {\\n    const numOfPeopleByAge = new Array(120 + 1).fill(0, 15, 120 + 1) ; ages.forEach(age => {\\n        if (age >= 15)\\n            numOfPeopleByAge[age]++\\n    })\\n    const [_, totalRequests] = numOfPeopleByAge.reduce(\\n        ([lowerAgedPeopleToRequest, totalRequests], numOfPeopleWithCurrentAge, currentAge, numOfPeopleByAge) => {\\n            if (currentAge % 2 == 0)\\n                lowerAgedPeopleToRequest -= numOfPeopleByAge[0.5 * currentAge + 7]\\n            const numOfPeopleToRequestAtCurrentAge = (numOfPeopleWithCurrentAge - 1 + lowerAgedPeopleToRequest)\\n            totalRequests += numOfPeopleToRequestAtCurrentAge * numOfPeopleWithCurrentAge\\n            lowerAgedPeopleToRequest += numOfPeopleWithCurrentAge\\n            return [lowerAgedPeopleToRequest, totalRequests]\\n        }, [0, 0])\\n    return totalRequests\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3060571,
                "title": "fast-c-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use a counting sort to store the number of people for each age. Then, for each person, we can check the number of people with age greater than the person\\'s age and less than the person\\'s age times 0.5 + 7. We need to exclude the case when age i equals age j.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a count array of length 121 to store the number of people for each age.\\n2. For each age in the given ages array, increment the corresponding count array index.\\n3. For each age i in the range 15 to 120:\\n   1. For each age j in the range 15 to 120:\\n      1. If age i is less than or equal to age j times 0.5 + 7, skip this iteration.\\n      2. If age i is less than age j, skip this iteration.\\n      3. If age i is greater than 100 and age j is less than 100, skip this iteration.\\n      4. Add the number of people with age i to the result multiplied by the number of people with age j, excluding the cases when i and j are the same age.\\n4. Return the result.\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this algorithm is O(n * m), where n and m are the maximum ages in the given array. This is because we need to loop through the entire array of ages, and for each age, we need to loop through every age from 15 to 120.\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nThe space complexity is O(1), as we only use a count array of fixed size 121.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int res = 0;\\n        vector<int> count(121);\\n        for (int age : ages) ++count[age];\\n        for (int i = 15; i <= 120; ++i)\\n            for (int j = 15; j <= 120; ++j) {\\n                if (i * 0.5 + 7 >= j) continue;\\n                if (i < j) continue;\\n                if (i < 100 && 100 < j) continue;\\n                res += count[i] * (count[j] - (i == j));\\n            }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int res = 0;\\n        vector<int> count(121);\\n        for (int age : ages) ++count[age];\\n        for (int i = 15; i <= 120; ++i)\\n            for (int j = 15; j <= 120; ++j) {\\n                if (i * 0.5 + 7 >= j) continue;\\n                if (i < j) continue;\\n                if (i < 100 && 100 < j) continue;\\n                res += count[i] * (count[j] - (i == j));\\n            }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054171,
                "title": "basic-solution-using-maps-cpp",
                "content": "# Explanation :\\n```\\npush all the ages into a hash map \\n\\nmaintaining the count of each age\\nwe will check for each age number(key) in map to which age group can\\nthey send an request \\n\\nmake a function to check all the constraints by sending two ages :\\none fixed by first for loop \\nsecond will be traversing the whole map one by one ;\\n\\nwhen ages will be same in the both loops \\neach person can send **(count-1)** requests to this same group \\n```\\n# Code\\n```\\nclass Solution {\\n\\n    bool canNotBeFriends(int x,int y){\\n            if(y<=0.5*x+7)\\n                return true;\\n            if(y>x)\\n                return true;\\n            if(y>100 && x<100)\\n                return true;\\n            return false;\\n    }\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        map<int,int> mp;\\n        int x,y,total=0;\\n        for(auto val: ages)\\n            mp[val]++;\\n        for(auto it1: mp){\\n            x=it1.first;\\n            for(auto it2: mp){\\n                y=it2.first;\\n                if(canNotBeFriends(x,y)){\\n                    continue;\\n                }\\n                if(x==y)\\n                    total+=(mp[x]-1)*mp[x];\\n                else\\n                    total+=mp[x]*mp[y];\\n\\n            }\\n        }\\n        return total ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\npush all the ages into a hash map \\n\\nmaintaining the count of each age\\nwe will check for each age number(key) in map to which age group can\\nthey send an request \\n\\nmake a function to check all the constraints by sending two ages :\\none fixed by first for loop \\nsecond will be traversing the whole map one by one ;\\n\\nwhen ages will be same in the both loops \\neach person can send **(count-1)** requests to this same group \\n```\n```\\nclass Solution {\\n\\n    bool canNotBeFriends(int x,int y){\\n            if(y<=0.5*x+7)\\n                return true;\\n            if(y>x)\\n                return true;\\n            if(y>100 && x<100)\\n                return true;\\n            return false;\\n    }\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        map<int,int> mp;\\n        int x,y,total=0;\\n        for(auto val: ages)\\n            mp[val]++;\\n        for(auto it1: mp){\\n            x=it1.first;\\n            for(auto it2: mp){\\n                y=it2.first;\\n                if(canNotBeFriends(x,y)){\\n                    continue;\\n                }\\n                if(x==y)\\n                    total+=(mp[x]-1)*mp[x];\\n                else\\n                    total+=mp[x]*mp[y];\\n\\n            }\\n        }\\n        return total ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047636,
                "title": "beats-100-time-and-space",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} ages\\n * @return {number}\\n */\\nvar numFriendRequests = function(ages) {\\n    // initiate 0 filled array for hash\\n    let hash = new Array(122).fill(0);\\n    \\n    // makes a normal hash of ages\\n    for(let i = 0; i < ages.length; i++) {\\n        const currAge = ages[i];\\n        hash[currAge]++;\\n    }\\n\\n    // turns hash into \"running hash\" that keeps total number so far\\n    let count = 0;\\n    for(let i = 0; i < hash.length - 1; i++) {\\n        hash[i] = count;\\n        count += hash[i + 1];\\n    }\\n\\n    // loops through ages and checks how many friends each person will have\\n    // add each persons friends to total\\n    let total = 0;\\n    for(let i = 0; i < ages.length; i++) {\\n        const age = ages[i];\\n\\n        // bottom cutoff for friends\\n        let index = Math.floor(age / 2 + 7);\\n        let bottom = hash[index];\\n        // top cutoff for friends\\n        let top = hash[age] - 1;\\n        // subtract top from bottom since hash uses running total;\\n        let addToTotal = (top - bottom);\\n\\n        // cannot subtract friends\\n        if(addToTotal > 0) total += addToTotal;\\n    }\\n\\n    return total;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} ages\\n * @return {number}\\n */\\nvar numFriendRequests = function(ages) {\\n    // initiate 0 filled array for hash\\n    let hash = new Array(122).fill(0);\\n    \\n    // makes a normal hash of ages\\n    for(let i = 0; i < ages.length; i++) {\\n        const currAge = ages[i];\\n        hash[currAge]++;\\n    }\\n\\n    // turns hash into \"running hash\" that keeps total number so far\\n    let count = 0;\\n    for(let i = 0; i < hash.length - 1; i++) {\\n        hash[i] = count;\\n        count += hash[i + 1];\\n    }\\n\\n    // loops through ages and checks how many friends each person will have\\n    // add each persons friends to total\\n    let total = 0;\\n    for(let i = 0; i < ages.length; i++) {\\n        const age = ages[i];\\n\\n        // bottom cutoff for friends\\n        let index = Math.floor(age / 2 + 7);\\n        let bottom = hash[index];\\n        // top cutoff for friends\\n        let top = hash[age] - 1;\\n        // subtract top from bottom since hash uses running total;\\n        let addToTotal = (top - bottom);\\n\\n        // cannot subtract friends\\n        if(addToTotal > 0) total += addToTotal;\\n    }\\n\\n    return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3044407,
                "title": "easy-c-solution-using-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint helper(vector<int>&ages,int target)\\n{\\n    int low=0;\\n    int high=ages.size()-1;\\n    while(low<=high)\\n    {\\n        int mid=low+(high-low)/2;\\n        if (ages[mid]<=target)\\n        low=mid+1;\\n        else high=mid-1;\\n    }\\n    return low;\\n}\\n    int numFriendRequests(vector<int>& ages) \\n    {\\n        sort(ages.begin(),ages.end());\\n        int ans=0;\\n        for (int i=0;i<ages.size();i++)\\n        {\\n            int lower=helper(ages,ages[i]*0.5+7);\\n            int higher=helper(ages,ages[i]);\\n            ans+=max(higher-lower-1,0);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint helper(vector<int>&ages,int target)\\n{\\n    int low=0;\\n    int high=ages.size()-1;\\n    while(low<=high)\\n    {\\n        int mid=low+(high-low)/2;\\n        if (ages[mid]<=target)\\n        low=mid+1;\\n        else high=mid-1;\\n    }\\n    return low;\\n}\\n    int numFriendRequests(vector<int>& ages) \\n    {\\n        sort(ages.begin(),ages.end());\\n        int ans=0;\\n        for (int i=0;i<ages.size();i++)\\n        {\\n            int lower=helper(ages,ages[i]*0.5+7);\\n            int higher=helper(ages,ages[i]);\\n            ans+=max(higher-lower-1,0);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028823,
                "title": "python-binary-search",
                "content": "# Complexity\\n- Time complexity: $O(n\\\\log n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n\\n        def get_candidates(i):\\n            if i == 0: return 0\\n            if ages[i]<=14: return 0\\n\\n            if ages[i-1]<=0.5*ages[i]+7: return 0\\n\\n            l, r = 0, i-1\\n            while l<=r:\\n                mid = (l+r)//2\\n                if ages[mid]<=0.5*ages[i]+7:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n\\n            if ages[mid]<=0.5*ages[i]+7:\\n                mid  += 1\\n\\n            return i-mid\\n        \\n\\n        ages.sort()\\n        n = len(ages)\\n        res = 0\\n\\n        prev = 0\\n        prev_cnt = 0\\n        for i in range(n):\\n            if ages[i]<=14: continue\\n\\n            if i>=1 and ages[i] == ages[i-1]:\\n                prev_cnt += 1\\n                prev = prev + 1\\n                res += prev + prev_cnt\\n                continue\\n\\n\\n            candidates = get_candidates(i)\\n            res += candidates\\n\\n            prev = candidates\\n            prev_cnt = 0\\n\\n\\n        return res\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n\\n        def get_candidates(i):\\n            if i == 0: return 0\\n            if ages[i]<=14: return 0\\n\\n            if ages[i-1]<=0.5*ages[i]+7: return 0\\n\\n            l, r = 0, i-1\\n            while l<=r:\\n                mid = (l+r)//2\\n                if ages[mid]<=0.5*ages[i]+7:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n\\n            if ages[mid]<=0.5*ages[i]+7:\\n                mid  += 1\\n\\n            return i-mid\\n        \\n\\n        ages.sort()\\n        n = len(ages)\\n        res = 0\\n\\n        prev = 0\\n        prev_cnt = 0\\n        for i in range(n):\\n            if ages[i]<=14: continue\\n\\n            if i>=1 and ages[i] == ages[i-1]:\\n                prev_cnt += 1\\n                prev = prev + 1\\n                res += prev + prev_cnt\\n                continue\\n\\n\\n            candidates = get_candidates(i)\\n            res += candidates\\n\\n            prev = candidates\\n            prev_cnt = 0\\n\\n\\n        return res\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993868,
                "title": "c-tricky-problem-detail-explanation-with-comment",
                "content": "**NOTE :** Start reading solution from ```numFriendRequests``` function. I have explained my approach and thought process in the code itself.\\n```\\nclass Solution {\\npublic:\\n    \\n    int binarySearch1(vector<int>& arr, int start, int end, double tgt){\\n        int potCand=-1;\\n        while(start<=end){\\n            int mid= start + (end-start)/2;\\n            \\n            if(1.0*arr[mid]<=tgt){\\n                end= mid-1;\\n            }\\n            else if(1.0*arr[mid]>tgt){\\n                potCand=mid;\\n                start=mid+1;\\n            }\\n        }\\n        \\n        return potCand;\\n    }\\n    \\n    int binarySearch3(vector<int>& arr, int start, int end, int tgt){\\n        int potCand=-1;\\n        while(start<=end){\\n            int mid= start + (end-start)/2;\\n            \\n            if(arr[mid]<=tgt){\\n                potCand=mid;\\n                end= mid-1;\\n            }\\n            else if(arr[mid]>tgt){\\n                start= mid+1;\\n            }\\n        }\\n        return potCand;\\n    }\\n    \\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end(), greater<int>()); // Non-increasingly sort\\n        \\n        int ans=0;\\n        for(int i=0; i<ages.size(); i++){\\n            double tgt= 1.0*ages[i];  // target\\n            \\n            /*\\n                1. (arr[y] > arr[x]/2 +7) &&\\n                2. (arr[y] <= arr[x]) &&\\n                3. (arr[x]>=100 || arr[y]<=100)\\n            */\\n            \\n            int idx1= binarySearch1(ages, i, ages.size()-1, 0.5*tgt+7); // cond 1 : arr[y] > arr[x]/2 +7\\n            // valid positions are [i-idx1]\\n            if(idx1==-1){ continue; }\\n            \\n            int idx2= ages.size()-1; // cond 2 : arr[y] <= arr[x]\\n            // valid positions are [i-idx2]\\n            \\n            int idx3;\\n            if(ages[i]>=100){ idx3= i; } // all index of y are valid\\n            else{\\n                idx3= binarySearch3(ages, i, ages.size()-1, 100); // cond 3: arr[y] <=100\\n                if(idx3==-1){ continue; }\\n            }\\n            // valid positions are [idx3-ages.size()-1]\\n            \\n            // cout<<idx1<<\" \"<<idx2<<\" \"<<idx3<<endl;\\n            \\n            // Now we need intersection of all 3 conditions.\\n            int finalIdxHigh= min(idx1, idx2);\\n            int finalIdxLow= max(i, idx3);\\n            \\n            ans+=(finalIdxHigh-finalIdxLow);\\n            if(finalIdxLow>i){ ans++; }   \\n        }\\n        \\n        /*\\n            \\uD83D\\uDC49 Now here is a catch : assume [16,16] (repeating case).\\n            \\uD83D\\uDC49 Now when we are at i(here x), we are taking care of all index in [i,size-1]. So, when we are at 0th idx, we are taking care of indexes from [0,1], \\n            and we get at pair ( 0-->1 ), but in this case ( 1-->0 ) is also a valid pair which we are missing.\\n            \\uD83D\\uDC49 For this reason we are storing freq of each element and handling repeating case separately below.\\n\\n            \\uD83D\\uDC49 For eg: assume [16,16,16]\\n            \\uD83D\\uDC49 Above process will handle cases like (0->1), (0->2), (1->2); so ans=3. But we are missing cases like (1->0), (2->1), (2->0). \\n            \\uD83D\\uDC49 From hashmap, we know m[16]=3 (freq). So we just add ans+=((3-1)*3)/2;\\n        */\\n        \\n        unordered_map<int, int> m; // {element, freq}\\n        for(auto it: ages){  m[it]++;  }\\n        \\n        for(auto it: m){\\n            int num= it.first; int n= it.second;\\n            bool flag= 1.0*num > 0.5*num +7;\\n            if(n>1 && flag==true){\\n                ans+=((n-1)*n)/2; \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nThanks !",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```numFriendRequests```\n```\\nclass Solution {\\npublic:\\n    \\n    int binarySearch1(vector<int>& arr, int start, int end, double tgt){\\n        int potCand=-1;\\n        while(start<=end){\\n            int mid= start + (end-start)/2;\\n            \\n            if(1.0*arr[mid]<=tgt){\\n                end= mid-1;\\n            }\\n            else if(1.0*arr[mid]>tgt){\\n                potCand=mid;\\n                start=mid+1;\\n            }\\n        }\\n        \\n        return potCand;\\n    }\\n    \\n    int binarySearch3(vector<int>& arr, int start, int end, int tgt){\\n        int potCand=-1;\\n        while(start<=end){\\n            int mid= start + (end-start)/2;\\n            \\n            if(arr[mid]<=tgt){\\n                potCand=mid;\\n                end= mid-1;\\n            }\\n            else if(arr[mid]>tgt){\\n                start= mid+1;\\n            }\\n        }\\n        return potCand;\\n    }\\n    \\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end(), greater<int>()); // Non-increasingly sort\\n        \\n        int ans=0;\\n        for(int i=0; i<ages.size(); i++){\\n            double tgt= 1.0*ages[i];  // target\\n            \\n            /*\\n                1. (arr[y] > arr[x]/2 +7) &&\\n                2. (arr[y] <= arr[x]) &&\\n                3. (arr[x]>=100 || arr[y]<=100)\\n            */\\n            \\n            int idx1= binarySearch1(ages, i, ages.size()-1, 0.5*tgt+7); // cond 1 : arr[y] > arr[x]/2 +7\\n            // valid positions are [i-idx1]\\n            if(idx1==-1){ continue; }\\n            \\n            int idx2= ages.size()-1; // cond 2 : arr[y] <= arr[x]\\n            // valid positions are [i-idx2]\\n            \\n            int idx3;\\n            if(ages[i]>=100){ idx3= i; } // all index of y are valid\\n            else{\\n                idx3= binarySearch3(ages, i, ages.size()-1, 100); // cond 3: arr[y] <=100\\n                if(idx3==-1){ continue; }\\n            }\\n            // valid positions are [idx3-ages.size()-1]\\n            \\n            // cout<<idx1<<\" \"<<idx2<<\" \"<<idx3<<endl;\\n            \\n            // Now we need intersection of all 3 conditions.\\n            int finalIdxHigh= min(idx1, idx2);\\n            int finalIdxLow= max(i, idx3);\\n            \\n            ans+=(finalIdxHigh-finalIdxLow);\\n            if(finalIdxLow>i){ ans++; }   \\n        }\\n        \\n        /*\\n            \\uD83D\\uDC49 Now here is a catch : assume [16,16] (repeating case).\\n            \\uD83D\\uDC49 Now when we are at i(here x), we are taking care of all index in [i,size-1]. So, when we are at 0th idx, we are taking care of indexes from [0,1], \\n            and we get at pair ( 0-->1 ), but in this case ( 1-->0 ) is also a valid pair which we are missing.\\n            \\uD83D\\uDC49 For this reason we are storing freq of each element and handling repeating case separately below.\\n\\n            \\uD83D\\uDC49 For eg: assume [16,16,16]\\n            \\uD83D\\uDC49 Above process will handle cases like (0->1), (0->2), (1->2); so ans=3. But we are missing cases like (1->0), (2->1), (2->0). \\n            \\uD83D\\uDC49 From hashmap, we know m[16]=3 (freq). So we just add ans+=((3-1)*3)/2;\\n        */\\n        \\n        unordered_map<int, int> m; // {element, freq}\\n        for(auto it: ages){  m[it]++;  }\\n        \\n        for(auto it: m){\\n            int num= it.first; int n= it.second;\\n            bool flag= 1.0*num > 0.5*num +7;\\n            if(n>1 && flag==true){\\n                ans+=((n-1)*n)/2; \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2945359,
                "title": "python3-concise-solution-beats-99",
                "content": "# Counter + Binary Search + Math\\n# Time complexity: \\nmax(O(121*log(121)), N), N = len(ages)\\n\\n# Code\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages):\\n        count = [0] * 121                               # counter: count frequency of each age\\n        for age in ages:\\n            count[age] += 1\\n        prefix = [0] * 121                              # prefix-sum: prefix sum of frequency, we will use this for range subtraction\\n        for i in range(1, 121):\\n            prefix[i] = prefix[i-1] + count[i]\\n        nums = [i for i in range(121)]                  # a dummy age list, which will be used in binary search\\n        ans = 0\\n        for age, cnt in enumerate(count):\\n            if not cnt: continue\\n            lb = age                                    # lower bound\\n            ub = (age - 7) * 2                          # upper bound\\n            i = bisect.bisect_left(nums, lb)            # binary search on lower bound, O(log(121))\\n            j = bisect.bisect_left(nums, ub)            # binary search on upper bound, O(log(121))\\n            if j - i <= 0: continue\\n            total = prefix[j-1] - prefix[i-1]           # range subtraction - how many ages in total can be considered as friend, including current age itself\\n            if lb <= age < ub:                          # considering itself, e.g. [17, 17, 17]\\n                # total -= cnt                          # minus itself\\n                # total = (cnt - 1) * cnt + total * cnt # make friends with other at same age `(cnt-1) * cnt`; with other at different age `total * cnt`\\n                total = cnt * (total - 1)               # a cleaner presentation of above two lines\\n            ans += total    \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages):\\n        count = [0] * 121                               # counter: count frequency of each age\\n        for age in ages:\\n            count[age] += 1\\n        prefix = [0] * 121                              # prefix-sum: prefix sum of frequency, we will use this for range subtraction\\n        for i in range(1, 121):\\n            prefix[i] = prefix[i-1] + count[i]\\n        nums = [i for i in range(121)]                  # a dummy age list, which will be used in binary search\\n        ans = 0\\n        for age, cnt in enumerate(count):\\n            if not cnt: continue\\n            lb = age                                    # lower bound\\n            ub = (age - 7) * 2                          # upper bound\\n            i = bisect.bisect_left(nums, lb)            # binary search on lower bound, O(log(121))\\n            j = bisect.bisect_left(nums, ub)            # binary search on upper bound, O(log(121))\\n            if j - i <= 0: continue\\n            total = prefix[j-1] - prefix[i-1]           # range subtraction - how many ages in total can be considered as friend, including current age itself\\n            if lb <= age < ub:                          # considering itself, e.g. [17, 17, 17]\\n                # total -= cnt                          # minus itself\\n                # total = (cnt - 1) * cnt + total * cnt # make friends with other at same age `(cnt-1) * cnt`; with other at different age `total * cnt`\\n                total = cnt * (total - 1)               # a cleaner presentation of above two lines\\n            ans += total    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931880,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn num_friend_requests(ages: Vec<i32>) -> i32 {\\n        let mut count = vec![0; 121];\\n        for age in ages {\\n            count[age as usize] += 1;\\n        }\\n        let mut result = 0;\\n        for age in 1..=120 {\\n            if count[age] == 0 {\\n                continue;\\n            }\\n            for other in (age / 2 + 8)..=age {\\n                if count[other] == 0 {\\n                    continue;\\n                }\\n                if age == other {\\n                    result += count[age] * (count[age] - 1);\\n                } else {\\n                    result += count[age] * count[other];\\n                }\\n            }\\n        }\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_friend_requests(ages: Vec<i32>) -> i32 {\\n        let mut count = vec![0; 121];\\n        for age in ages {\\n            count[age as usize] += 1;\\n        }\\n        let mut result = 0;\\n        for age in 1..=120 {\\n            if count[age] == 0 {\\n                continue;\\n            }\\n            for other in (age / 2 + 8)..=age {\\n                if count[other] == 0 {\\n                    continue;\\n                }\\n                if age == other {\\n                    result += count[age] * (count[age] - 1);\\n                } else {\\n                    result += count[age] * count[other];\\n                }\\n            }\\n        }\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2913512,
                "title": "java-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i:ages){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        }\\n        int count=0;\\n        for(int i1:map.keySet())\\n        {\\n            for(int i2:map.keySet()){\\n                if(help(i1,i2)){\\n                    count+=map.get(i1)*map.get(i2);\\n                    if(i1==i2)count-=map.get(i1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public static boolean help(int i1,int i2)\\n    {\\n        return i1<=(int)((i2/2)+7) || i1>i2?false:true;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i:ages){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        }\\n        int count=0;\\n        for(int i1:map.keySet())\\n        {\\n            for(int i2:map.keySet()){\\n                if(help(i1,i2)){\\n                    count+=map.get(i1)*map.get(i2);\\n                    if(i1==i2)count-=map.get(i1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public static boolean help(int i1,int i2)\\n    {\\n        return i1<=(int)((i2/2)+7) || i1>i2?false:true;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2895031,
                "title": "o-120-2-python-straightforward-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        def doSend(x, y):\\n            if 0.5 * x + 7 >= y:\\n                return False\\n\\n            if x < y:\\n                return False\\n\\n            if x < 100 and y > 100:\\n                return False\\n\\n            return True\\n\\n        counter = collections.Counter(ages)\\n        ans = 0\\n        ages = sorted(counter.keys())\\n        print(ages)\\n        for i in range(len(ages)):\\n            for j in range(len(ages)):\\n                isSent = doSend(ages[i], ages[j])\\n                if ages[i] == ages[j]:\\n                    if isSent:\\n                        ans += ((counter[ages[i]] - 1) * counter[ages[i]])\\n                        \\n                else:\\n                    if isSent:\\n                        ans += (counter[ages[i]] * counter[ages[j]])\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        def doSend(x, y):\\n            if 0.5 * x + 7 >= y:\\n                return False\\n\\n            if x < y:\\n                return False\\n\\n            if x < 100 and y > 100:\\n                return False\\n\\n            return True\\n\\n        counter = collections.Counter(ages)\\n        ans = 0\\n        ages = sorted(counter.keys())\\n        print(ages)\\n        for i in range(len(ages)):\\n            for j in range(len(ages)):\\n                isSent = doSend(ages[i], ages[j])\\n                if ages[i] == ages[j]:\\n                    if isSent:\\n                        ans += ((counter[ages[i]] - 1) * counter[ages[i]])\\n                        \\n                else:\\n                    if isSent:\\n                        ans += (counter[ages[i]] * counter[ages[j]])\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2861540,
                "title": "basic-rust-solution",
                "content": "\\n```\\nimpl Solution {\\n    pub fn num_friend_requests(ages: Vec<i32>) -> i32 {\\n        let mut sum = 0;\\n        for (i, &x) in ages.iter().enumerate() {\\n            for &y in &ages[i as usize + 1..] {\\n                if sends_request(x, y) {\\n                    sum += 1;\\n                }\\n                if sends_request(y, x) {\\n                    sum += 1;\\n                }\\n            }\\n        }\\n        sum\\n    }\\n}\\n\\nfn sends_request(x: i32, y: i32) -> bool {\\n    y > x / 2 + 7 && y <= x\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_friend_requests(ages: Vec<i32>) -> i32 {\\n        let mut sum = 0;\\n        for (i, &x) in ages.iter().enumerate() {\\n            for &y in &ages[i as usize + 1..] {\\n                if sends_request(x, y) {\\n                    sum += 1;\\n                }\\n                if sends_request(y, x) {\\n                    sum += 1;\\n                }\\n            }\\n        }\\n        sum\\n    }\\n}\\n\\nfn sends_request(x: i32, y: i32) -> bool {\\n    y > x / 2 + 7 && y <= x\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2829948,
                "title": "python-bisect-3rd-condition-is-redundant",
                "content": "3rd condition is redundant because according to condition 2 we already know `age[y] > age[x]`\\n\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        ans = 0\\n        for i in range(len(ages)):\\n            ans += max(0, bisect.bisect(ages, ages[i]) - bisect.bisect(ages, ages[i] * 0.5 + 7) - 1)\\n        return ans",
                "solutionTags": [],
                "code": "3rd condition is redundant because according to condition 2 we already know `age[y] > age[x]`\\n\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        ans = 0\\n        for i in range(len(ages)):\\n            ans += max(0, bisect.bisect(ages, ages[i]) - bisect.bisect(ages, ages[i] * 0.5 + 7) - 1)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2803994,
                "title": "java-solution",
                "content": "```\\n    public int numFriendRequests(int[] ages) {\\n        int n = ages.length, sum = 0;\\n        Arrays.sort(ages);\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = i-1; j >= 0; j--){\\n               if(ages[i] >= 2 * (ages[j] - 7))\\n                   break;\\n                else \\n                    sum++;\\n            }\\n            \\n            int k = i;\\n            while(k < n-1 && ages[++k] == ages[i])\\n                if(ages[i]< 2 * (ages[k]-7))\\n                sum++;\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\n    public int numFriendRequests(int[] ages) {\\n        int n = ages.length, sum = 0;\\n        Arrays.sort(ages);\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = i-1; j >= 0; j--){\\n               if(ages[i] >= 2 * (ages[j] - 7))\\n                   break;\\n                else \\n                    sum++;\\n            }\\n            \\n            int k = i;\\n            while(k < n-1 && ages[++k] == ages[i])\\n                if(ages[i]< 2 * (ages[k]-7))\\n                sum++;\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2720987,
                "title": "o-n-solution-easily-updated-to-o-120-solution-or-constant-time-for-any-input",
                "content": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n\\n        age_count = [0] * 121\\n        summ = 0\\n        dic = {}\\n        \\n        # count ages frpom 0 to 120\\n        for age in ages:\\n            age_count[age] += 1\\n            \\n        # range sum, helps in calculating number of friend requests to be sent \\n        # without binary search\\n        for i in range (121):\\n            summ += age_count[i]\\n            dic[i] = summ\\n\\n        \\n        total_count = 0\\n        # loop through all the ages\\n        # Alternately, You can even loop through 0 to 120 and still be able to calculate\\n        # that will reduce time complexity to O(120) basically almost constant time for inputs of any sizes\\n        \\n        for age in ages:\\n            lower_age = (age * 0.5) + 7\\n            rem = lower_age % 1.0\\n            lower_age = int(lower_age-0.5) if rem>0 else int(lower_age)\\n            higher_age = int(min(age, 100) if age < 100 else age)\\n                        \\n            if lower_age>higher_age:\\n                continue\\n            \\n            if lower_age<age<=higher_age:\\n                decrease_count=1\\n            else:\\n                decrease_count = 0\\n            if higher_age==lower_age:\\n                increase_count = 0\\n            else:\\n                increase_count = dic[higher_age] - dic[lower_age]\\n                \\n            total_count += increase_count - decrease_count\\n            \\n        return total_count\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n\\n        age_count = [0] * 121\\n        summ = 0\\n        dic = {}\\n        \\n        # count ages frpom 0 to 120\\n        for age in ages:\\n            age_count[age] += 1\\n            \\n        # range sum, helps in calculating number of friend requests to be sent \\n        # without binary search\\n        for i in range (121):\\n            summ += age_count[i]\\n            dic[i] = summ\\n\\n        \\n        total_count = 0\\n        # loop through all the ages\\n        # Alternately, You can even loop through 0 to 120 and still be able to calculate\\n        # that will reduce time complexity to O(120) basically almost constant time for inputs of any sizes\\n        \\n        for age in ages:\\n            lower_age = (age * 0.5) + 7\\n            rem = lower_age % 1.0\\n            lower_age = int(lower_age-0.5) if rem>0 else int(lower_age)\\n            higher_age = int(min(age, 100) if age < 100 else age)\\n                        \\n            if lower_age>higher_age:\\n                continue\\n            \\n            if lower_age<age<=higher_age:\\n                decrease_count=1\\n            else:\\n                decrease_count = 0\\n            if higher_age==lower_age:\\n                increase_count = 0\\n            else:\\n                increase_count = dic[higher_age] - dic[lower_age]\\n                \\n            total_count += increase_count - decrease_count\\n            \\n        return total_count\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675263,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\tvar numFriendRequests = function(ages) {\\n\\t\\tconst agesMap = new Map();\\n\\t\\tconst agesSum = Array(121).fill(0);\\n\\n\\t\\tages.forEach(age => {\\n\\t\\t\\tconst count = agesMap.get(age) ?? 0;\\n\\t\\t\\tagesMap.set(age, count + 1);\\n\\t\\t});\\n\\n\\t\\tfor (let age = 1; age < 121; age++) {\\n\\t\\t\\tagesSum[age] = (agesMap.get(age) ?? 0) + agesSum[age - 1];\\n\\t\\t}\\n\\n\\t\\treturn [...new Set(ages)].reduce((result, age) => {\\n\\t\\t\\tconst validAge = (age * 0.5 | 0) + 7;\\n\\t\\t\\tif (validAge >= age) return result;\\n\\t\\t\\tconst multiple = agesSum[age] - agesSum[validAge];\\n\\t\\t\\treturn result + (multiple - 1) * agesMap.get(age);\\n\\t\\t}, 0);\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar numFriendRequests = function(ages) {\\n\\t\\tconst agesMap = new Map();\\n\\t\\tconst agesSum = Array(121).fill(0);\\n\\n\\t\\tages.forEach(age => {\\n\\t\\t\\tconst count = agesMap.get(age) ?? 0;\\n\\t\\t\\tagesMap.set(age, count + 1);\\n\\t\\t});\\n\\n\\t\\tfor (let age = 1; age < 121; age++) {\\n\\t\\t\\tagesSum[age] = (agesMap.get(age) ?? 0) + agesSum[age - 1];\\n\\t\\t}\\n\\n\\t\\treturn [...new Set(ages)].reduce((result, age) => {\\n\\t\\t\\tconst validAge = (age * 0.5 | 0) + 7;\\n\\t\\t\\tif (validAge >= age) return result;\\n\\t\\t\\tconst multiple = agesSum[age] - agesSum[validAge];\\n\\t\\t\\treturn result + (multiple - 1) * agesMap.get(age);\\n\\t\\t}, 0);\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 2668841,
                "title": "pyton-binary-search",
                "content": "```\\nfrom bisect import bisect_left, bisect_right\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        res = 0\\n        for i, x in enumerate(ages):\\n            if x < 100:\\n                r = bisect_right(ages, min(x,100))\\n            else:\\n                r = bisect_right(ages, x)\\n            l = bisect_right(ages, 0.5*x + 7)\\n            if l < r:\\n                res += r - l - 1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom bisect import bisect_left, bisect_right\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        res = 0\\n        for i, x in enumerate(ages):\\n            if x < 100:\\n                r = bisect_right(ages, min(x,100))\\n            else:\\n                r = bisect_right(ages, x)\\n            l = bisect_right(ages, 0.5*x + 7)\\n            if l < r:\\n                res += r - l - 1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2661724,
                "title": "simple-java-solution-space-o-1-time-o-n",
                "content": "```\\n\\nclass Solution {\\n    public int numFriendRequests(int[] ages) { \\n        int[] numPerAge = new int[150];\\n        \\n        for(int i : ages)\\n            numPerAge[i] += 1;\\n        \\n        int sum = 0;\\n        for(int currentAge = 0; currentAge <150; currentAge++) {\\n            //if perf\\n            if(numPerAge[currentAge] == 0)\\n                continue;\\n            \\n            // To be elibigle to receive request\\n            // Y person should be greater than or equal to \\'startAge\\'. (+1 is for equal and greater than)\\n            int startAge = (int)(currentAge * 0.5) + 7 + 1;\\n            \\n            // If Eligible age is greater than current age, \\n            // Person of currentAge wont be able to send any request due to rule#2.\\n            if(startAge > currentAge)\\n                continue;\\n            \\n            // Get count of all person whoes age starts with startAge and currentAge-1;\\n            int eligiblePeopleCount = getCount(numPerAge, startAge, currentAge-1);\\n            \\n            // Persons of Same age (as currentAge) will send request to each of the eligible people.\\n            sum += (eligiblePeopleCount * numPerAge[currentAge]);\\n\\n            // X Person can send request to the other presons who is of same age of X.\\n            sum += (numPerAge[currentAge] * (numPerAge[currentAge] -1));\\n        }\\n        return sum;\\n    }\\n    private int getCount(int[] numPerAge, int startAge, int currentAge) {\\n        if(currentAge < startAge)\\n            return 0;\\n\\n        int sum = 0;\\n        for(int i = startAge; i <= currentAge; i++) {\\n            sum += numPerAge[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int numFriendRequests(int[] ages) { \\n        int[] numPerAge = new int[150];\\n        \\n        for(int i : ages)\\n            numPerAge[i] += 1;\\n        \\n        int sum = 0;\\n        for(int currentAge = 0; currentAge <150; currentAge++) {\\n            //if perf\\n            if(numPerAge[currentAge] == 0)\\n                continue;\\n            \\n            // To be elibigle to receive request\\n            // Y person should be greater than or equal to \\'startAge\\'. (+1 is for equal and greater than)\\n            int startAge = (int)(currentAge * 0.5) + 7 + 1;\\n            \\n            // If Eligible age is greater than current age, \\n            // Person of currentAge wont be able to send any request due to rule#2.\\n            if(startAge > currentAge)\\n                continue;\\n            \\n            // Get count of all person whoes age starts with startAge and currentAge-1;\\n            int eligiblePeopleCount = getCount(numPerAge, startAge, currentAge-1);\\n            \\n            // Persons of Same age (as currentAge) will send request to each of the eligible people.\\n            sum += (eligiblePeopleCount * numPerAge[currentAge]);\\n\\n            // X Person can send request to the other presons who is of same age of X.\\n            sum += (numPerAge[currentAge] * (numPerAge[currentAge] -1));\\n        }\\n        return sum;\\n    }\\n    private int getCount(int[] numPerAge, int startAge, int currentAge) {\\n        if(currentAge < startAge)\\n            return 0;\\n\\n        int sum = 0;\\n        for(int i = startAge; i <= currentAge; i++) {\\n            sum += numPerAge[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653687,
                "title": "golang-o-n-2",
                "content": "```\\nfunc numFriendRequests(ages []int) int {\\n    requestCount := 0\\n    \\n    ageToCount := make(map[int]int)\\n    for i := 0; i < len(ages); i++ {\\n        ageToCount[ages[i]]++\\n    }\\n    \\n    uniqueAges := make([]int, 0, len(ageToCount))\\n    for age, _ := range ageToCount {\\n        uniqueAges = append(uniqueAges, age)\\n    }\\n    \\n    sort.Ints(uniqueAges)\\n    \\n    n := len(uniqueAges)\\n    for i := 0; i < n; i ++ {\\n        for j := 0; j < n; j++ {\\n            if sendRequest(uniqueAges[i], uniqueAges[j]) {\\n                if i == j {\\n                    requestCount += ageToCount[uniqueAges[i]] * (ageToCount[uniqueAges[i]] - 1) \\n                } else {\\n                    requestCount += (ageToCount[uniqueAges[i]] * ageToCount[uniqueAges[j]])\\n                }\\n            }\\n        }\\n    }\\n    \\n    return requestCount\\n}\\n\\nfunc sendRequest(a int, b int) bool {\\n    return !((2 * b - 14 <= a) || b > a)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numFriendRequests(ages []int) int {\\n    requestCount := 0\\n    \\n    ageToCount := make(map[int]int)\\n    for i := 0; i < len(ages); i++ {\\n        ageToCount[ages[i]]++\\n    }\\n    \\n    uniqueAges := make([]int, 0, len(ageToCount))\\n    for age, _ := range ageToCount {\\n        uniqueAges = append(uniqueAges, age)\\n    }\\n    \\n    sort.Ints(uniqueAges)\\n    \\n    n := len(uniqueAges)\\n    for i := 0; i < n; i ++ {\\n        for j := 0; j < n; j++ {\\n            if sendRequest(uniqueAges[i], uniqueAges[j]) {\\n                if i == j {\\n                    requestCount += ageToCount[uniqueAges[i]] * (ageToCount[uniqueAges[i]] - 1) \\n                } else {\\n                    requestCount += (ageToCount[uniqueAges[i]] * ageToCount[uniqueAges[j]])\\n                }\\n            }\\n        }\\n    }\\n    \\n    return requestCount\\n}\\n\\nfunc sendRequest(a int, b int) bool {\\n    return !((2 * b - 14 <= a) || b > a)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2617352,
                "title": "my-solutions",
                "content": "**1. Use the binary search**\\n```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `ages`\\n */\\nclass Solution {\\n public:\\n  int numFriendRequests(vector<int> &ages) {\\n    const int n = static_cast<int>(ages.size());\\n    sort(ages.begin(), ages.end());\\n    int ret = 0;\\n    for (int x = 0; x < n; ++x) {\\n      int upper_y = ages[x];\\n      if (ages[x] < 100) {\\n        upper_y = min(upper_y, 100);\\n      }\\n\\n      const int lower_y = ages[x] / 2 + 7;\\n      ret += static_cast<int>(max(0L,\\n                                  upper_bound(ages.begin(), ages.end(), upper_y) -\\n                                  upper_bound(ages.begin(), ages.end(), lower_y) -\\n                                  (ages[x] <= upper_y && ages[x] >= lower_y ? 1 : 0)));\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**2. Use the unordered map**\\n```\\n/**\\n * Time Complexity: O(n_ages * a_ages)\\n * Space Complexity: O(n_ages)\\n * where `n_ages` is the number of distinct values (ages) of the vector `ages`\\n */\\nclass Solution {\\n public:\\n  int numFriendRequests(const vector<int> &ages) {\\n    unordered_map<int, int> age_to_persons;\\n    for (const int age : ages) {\\n      ++age_to_persons[age];\\n    }\\n   \\n    int ret = 0;\\n    for (const auto [x, x_persons] : age_to_persons) {\\n      for (const auto [y, y_persons] : age_to_persons) {\\n        if (can_make_friend_request(x, y)) {\\n          ret += x_persons * (y_persons + (x == y ? -1 : 0));\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  bool can_make_friend_request(const int x, const int y) {\\n    return !(y <= x / 2 + 7 || y > x || (y > 100 && x < 100));\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `ages`\\n */\\nclass Solution {\\n public:\\n  int numFriendRequests(vector<int> &ages) {\\n    const int n = static_cast<int>(ages.size());\\n    sort(ages.begin(), ages.end());\\n    int ret = 0;\\n    for (int x = 0; x < n; ++x) {\\n      int upper_y = ages[x];\\n      if (ages[x] < 100) {\\n        upper_y = min(upper_y, 100);\\n      }\\n\\n      const int lower_y = ages[x] / 2 + 7;\\n      ret += static_cast<int>(max(0L,\\n                                  upper_bound(ages.begin(), ages.end(), upper_y) -\\n                                  upper_bound(ages.begin(), ages.end(), lower_y) -\\n                                  (ages[x] <= upper_y && ages[x] >= lower_y ? 1 : 0)));\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(n_ages * a_ages)\\n * Space Complexity: O(n_ages)\\n * where `n_ages` is the number of distinct values (ages) of the vector `ages`\\n */\\nclass Solution {\\n public:\\n  int numFriendRequests(const vector<int> &ages) {\\n    unordered_map<int, int> age_to_persons;\\n    for (const int age : ages) {\\n      ++age_to_persons[age];\\n    }\\n   \\n    int ret = 0;\\n    for (const auto [x, x_persons] : age_to_persons) {\\n      for (const auto [y, y_persons] : age_to_persons) {\\n        if (can_make_friend_request(x, y)) {\\n          ret += x_persons * (y_persons + (x == y ? -1 : 0));\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  bool can_make_friend_request(const int x, const int y) {\\n    return !(y <= x / 2 + 7 || y > x || (y > 100 && x < 100));\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611773,
                "title": "python-o-nlgn-binary-search-easy-solution",
                "content": "import bisect\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        \\n        x, result = 0, 0\\n        \\n        ages.sort()\\n        \\n        while(x < len(ages)):\\n            x1 = bisect.bisect_right(ages, ages[x])\\n            y1 = bisect.bisect_right(ages, ages[x] * 0.5 + 7)\\n            result += max(0, x1 - y1 - 1)\\n            x += 1\\n \\n        return result\\n",
                "solutionTags": [],
                "code": "import bisect\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        \\n        x, result = 0, 0\\n        \\n        ages.sort()\\n        \\n        while(x < len(ages)):\\n            x1 = bisect.bisect_right(ages, ages[x])\\n            y1 = bisect.bisect_right(ages, ages[x] * 0.5 + 7)\\n            result += max(0, x1 - y1 - 1)\\n            x += 1\\n \\n        return result\\n",
                "codeTag": "Java"
            },
            {
                "id": 2568904,
                "title": "swift",
                "content": "```\\nclass Solution {\\n    func numFriendRequests(_ ages: [Int]) -> Int {\\n        var req: Int = 0, map: [Int:Int] = [:]\\n        for age in ages {\\n            map[age, default: 0] += 1\\n        }\\n        for y in 1 ... 120 {\\n            for x in 1 ... 120 {\\n                if (Double(y) <= (Double(x) * 0.5 + 7)) || (y > x) || (y > 100 && x < 100) {\\n                    continue\\n                }\\n                req += map[y, default: 0] * map[x, default: 0]\\n                if x == y { req -= map[y, default: 0] }\\n            }\\n        }\\n        return req\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func numFriendRequests(_ ages: [Int]) -> Int {\\n        var req: Int = 0, map: [Int:Int] = [:]\\n        for age in ages {\\n            map[age, default: 0] += 1\\n        }\\n        for y in 1 ... 120 {\\n            for x in 1 ... 120 {\\n                if (Double(y) <= (Double(x) * 0.5 + 7)) || (y > x) || (y > 100 && x < 100) {\\n                    continue\\n                }\\n                req += map[y, default: 0] * map[x, default: 0]\\n                if x == y { req -= map[y, default: 0] }\\n            }\\n        }\\n        return req\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568688,
                "title": "o-n-120-solution",
                "content": "inspired by the solution here  https://leetcode.com/problems/friends-of-appropriate-ages/discuss/2505228/Python-Time%3A-O(max(N-120))-Space-O(1)-Prefixsum-and-Numbersort-Solution\\nI have a different one\\n\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        num_person_by_age = [0 for i in range(121)]\\n        for age in ages:\\n            num_person_by_age[age] += 1\\n        \\n        count = 0\\n        num_person_by_age_presum = [0 for i in range(121)]\\n        for age in range(15, 121):\\n            num_person_by_age_presum[age] = num_person_by_age[age]+num_person_by_age_presum[age-1]\\n            \\n        for age in range(15, 121):\\n            if num_person_by_age[age] == 0:\\n                continue\\n            limit = age // 2 + 7\\n            num_request = (num_person_by_age_presum[age-1] - num_person_by_age_presum[limit] )*num_person_by_age[age]\\n            count += num_request + num_person_by_age[age] * (num_person_by_age[age]-1)\\n         \\n        return count\\n        ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        num_person_by_age = [0 for i in range(121)]\\n        for age in ages:\\n            num_person_by_age[age] += 1\\n        \\n        count = 0\\n        num_person_by_age_presum = [0 for i in range(121)]\\n        for age in range(15, 121):\\n            num_person_by_age_presum[age] = num_person_by_age[age]+num_person_by_age_presum[age-1]\\n            \\n        for age in range(15, 121):\\n            if num_person_by_age[age] == 0:\\n                continue\\n            limit = age // 2 + 7\\n            num_request = (num_person_by_age_presum[age-1] - num_person_by_age_presum[limit] )*num_person_by_age[age]\\n            count += num_request + num_person_by_age[age] * (num_person_by_age[age]-1)\\n         \\n        return count\\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 2567097,
                "title": "friends-of-appropiate-ages",
                "content": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        def  friendRequest(a, b):\\n            if b <=  .5 * a + 7:\\n                return False\\n            if b > a:\\n                return False\\n            return True\\n        \\n        age_groups = collections.Counter(ages)\\n        total_request =  0\\n        for a, num_a in age_groups.items():\\n            for b, num_b in age_groups.items():\\n                if friendRequest(a, b):\\n                    total_request += num_a * num_b\\n                    if a == b :\\n                        total_request -= num_a\\n        return total_request\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        def  friendRequest(a, b):\\n            if b <=  .5 * a + 7:\\n                return False\\n            if b > a:\\n                return False\\n            return True\\n        \\n        age_groups = collections.Counter(ages)\\n        total_request =  0\\n        for a, num_a in age_groups.items():\\n            for b, num_b in age_groups.items():\\n                if friendRequest(a, b):\\n                    total_request += num_a * num_b\\n                    if a == b :\\n                        total_request -= num_a\\n        return total_request\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562864,
                "title": "python-prefix-sum-deque-easy-understanding",
                "content": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        \"\"\"\\n        1. age[y] <= 0.5 * age[x] + 7: set the left bound\\n        2. age[y] > age[x]: check smaller prefix sum\\n        3. age[y] > 100 && age[x] < 100: no need if we check smaller prefix sum\\n        \"\"\"\\n        c = collections.Counter(ages)\\n        inPresum = deque() # the window that \"key\" will send request to\\n        preSum = 0 # count of people of inPresum\\n        ans = 0\\n        for key in sorted(c):\\n            # check left bound\\n            while inPresum and inPresum[0] <= 0.5 * key + 7:\\n                preSum -= c[inPresum.popleft()]\\n            \\n            currCount = c[key]\\n            # request between same ages\\n\\t\\t\\t# note: also need to check condition 1 here\\n            if currCount > 1 and key > (0.5 * key + 7):\\n                combination = math.factorial(currCount) // (2 * math.factorial(currCount-2) ) \\n                ans += combination * 2\\n            ans += currCount * preSum\\n            \\n            preSum += currCount\\n            inPresum.append(key)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        \"\"\"\\n        1. age[y] <= 0.5 * age[x] + 7: set the left bound\\n        2. age[y] > age[x]: check smaller prefix sum\\n        3. age[y] > 100 && age[x] < 100: no need if we check smaller prefix sum\\n        \"\"\"\\n        c = collections.Counter(ages)\\n        inPresum = deque() # the window that \"key\" will send request to\\n        preSum = 0 # count of people of inPresum\\n        ans = 0\\n        for key in sorted(c):\\n            # check left bound\\n            while inPresum and inPresum[0] <= 0.5 * key + 7:\\n                preSum -= c[inPresum.popleft()]\\n            \\n            currCount = c[key]\\n            # request between same ages\\n\\t\\t\\t# note: also need to check condition 1 here\\n            if currCount > 1 and key > (0.5 * key + 7):\\n                combination = math.factorial(currCount) // (2 * math.factorial(currCount-2) ) \\n                ans += combination * 2\\n            ans += currCount * preSum\\n            \\n            preSum += currCount\\n            inPresum.append(key)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531829,
                "title": "c-hashing-easy-to-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    bool request(int a,int b)\\n    {\\n        return !(a<=0.5*b+7||a>b||a>100&&b<100);\\n    }\\n    int numFriendRequests(vector<int>& ages) \\n    {\\n        unordered_map<int,int> m;\\n        int ans=0;\\n        for(auto &a:ages)\\n        {\\n            m[a]++;\\n        }\\n        for(auto &a:m)\\n        {\\n            for(auto &b:m)\\n            {\\n                if(request(a.first,b.first))\\n                {\\n                    ans+=a.second*(b.second-(a.first==b.first?1:0));\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool request(int a,int b)\\n    {\\n        return !(a<=0.5*b+7||a>b||a>100&&b<100);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2459938,
                "title": "clean-o-n-solution-beat-100",
                "content": "```\\n public int numFriendRequests(int[] ages) {\\n    int[] cnt = new int[121];\\n    for(int age: ages){\\n      cnt[age]++;\\n    }\\n    int[] presum = new int[cnt.length];\\n    for(int i=1; i< presum.length; i++){\\n      presum[i] = presum[i-1] + cnt[i];\\n    }\\n    int sum  =0;\\n    for(int age =1 ; age< cnt.length; age++){\\n      int c = cnt[age];\\n      if(c ==0 ) continue;\\n      int left = age/2 +7 , right = age; //(left, right]\\n      if(left >= right) continue;\\n      sum +=(presum[right]-1 - presum[left]) * c;\\n    }\\n    return sum;\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n public int numFriendRequests(int[] ages) {\\n    int[] cnt = new int[121];\\n    for(int age: ages){\\n      cnt[age]++;\\n    }\\n    int[] presum = new int[cnt.length];\\n    for(int i=1; i< presum.length; i++){\\n      presum[i] = presum[i-1] + cnt[i];\\n    }\\n    int sum  =0;\\n    for(int age =1 ; age< cnt.length; age++){\\n      int c = cnt[age];\\n      if(c ==0 ) continue;\\n      int left = age/2 +7 , right = age; //(left, right]\\n      if(left >= right) continue;\\n      sum +=(presum[right]-1 - presum[left]) * c;\\n    }\\n    return sum;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2367237,
                "title": "java-simple-solution",
                "content": "```java\\nclass Solution {\\n    static int upperBound(int arr[], int target) {\\n        int l = 0, h = arr.length - 1;\\n        for (; l <= h;) {\\n            int mid = (l + h) >> 1;\\n            if (arr[mid] <= target)\\n                l = mid + 1;\\n            else\\n                h = mid - 1;\\n        }\\n        return l;\\n    }\\n    public int numFriendRequests(int[] ages) {\\n        long ans = 0;\\n        Arrays.sort(ages);\\n\\t\\t// traversing order doesn\\'t matter as we are doing binary-search in whole array\\n\\t\\t// you can traverse from left side also\\n        for(int i = ages.length - 1;i >= 0;--i){\\n            int k = upperBound(ages,ages[i] / 2 + 7);\\n            int t = upperBound(ages,ages[i]);\\n            ans += Math.max(0,t - k - 1);\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```java\\nclass Solution {\\n    static int upperBound(int arr[], int target) {\\n        int l = 0, h = arr.length - 1;\\n        for (; l <= h;) {\\n            int mid = (l + h) >> 1;\\n            if (arr[mid] <= target)\\n                l = mid + 1;\\n            else\\n                h = mid - 1;\\n        }\\n        return l;\\n    }\\n    public int numFriendRequests(int[] ages) {\\n        long ans = 0;\\n        Arrays.sort(ages);\\n\\t\\t// traversing order doesn\\'t matter as we are doing binary-search in whole array\\n\\t\\t// you can traverse from left side also\\n        for(int i = ages.length - 1;i >= 0;--i){\\n            int k = upperBound(ages,ages[i] / 2 + 7);\\n            int t = upperBound(ages,ages[i]);\\n            ans += Math.max(0,t - k - 1);\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564622,
                "content": [
                    {
                        "username": "elvinyang",
                        "content": "age[B] > age[A] and age[B] > 100 && age[A] < 100, isn\\'t the latter redundant?"
                    },
                    {
                        "username": "zpcore",
                        "content": "How can all the people in the world only love the younger people? No couple will love each other in this way."
                    },
                    {
                        "username": "sima",
                        "content": "I can find 69->56, 69->48, 56->48\\n\\n101 cannot make friend requests to anyone\\n\\nNo one make friend request to 30, 69*0.5+7 > 30, 48*0.5+7 > 30, 56 * 0.5 + 7 > 30\\n\\nI can only find 3. where is the 4th one?"
                    },
                    {
                        "username": "ianpan870102",
                        "content": "As titled, the third condition is useless. The second condition completely overrides it."
                    },
                    {
                        "username": "BiggestChungus",
                        "content": "`age[y] <= 0.5 * age[x] + 7`\\n\\nlol this was a meme from about 15 years ago right??"
                    },
                    {
                        "username": "Engineerr",
                        "content": "Just to see if you fit in the company culture, never make friends with new hire, stay away from VP/director."
                    },
                    {
                        "username": "parag_meshram",
                        "content": "Imho, theoretically, time complexity should be O(No. of Ages) = O(No. of Person) as loops are always running for constant no. of times i.e.120 * 120 times and space complexity is always O(121) = O(1) for the counting array size. \\uD83E\\uDD14"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Using a sliding window this can be done in O(n). You need to iterate through the input at least once, there is no getting around that, therefore at a minimum its O(n). An O(1) solution requires you dont need to process input, and thats not possible for this problem. "
                    },
                    {
                        "username": "OrestKlymko",
                        "content": "[16,17,18] - Friend requests are made 17 -> 16, 18 -> 17, but why don\\'t 18 -> 16???"
                    }
                ]
            },
            {
                "id": 1564837,
                "content": [
                    {
                        "username": "elvinyang",
                        "content": "age[B] > age[A] and age[B] > 100 && age[A] < 100, isn\\'t the latter redundant?"
                    },
                    {
                        "username": "zpcore",
                        "content": "How can all the people in the world only love the younger people? No couple will love each other in this way."
                    },
                    {
                        "username": "sima",
                        "content": "I can find 69->56, 69->48, 56->48\\n\\n101 cannot make friend requests to anyone\\n\\nNo one make friend request to 30, 69*0.5+7 > 30, 48*0.5+7 > 30, 56 * 0.5 + 7 > 30\\n\\nI can only find 3. where is the 4th one?"
                    },
                    {
                        "username": "ianpan870102",
                        "content": "As titled, the third condition is useless. The second condition completely overrides it."
                    },
                    {
                        "username": "BiggestChungus",
                        "content": "`age[y] <= 0.5 * age[x] + 7`\\n\\nlol this was a meme from about 15 years ago right??"
                    },
                    {
                        "username": "Engineerr",
                        "content": "Just to see if you fit in the company culture, never make friends with new hire, stay away from VP/director."
                    },
                    {
                        "username": "parag_meshram",
                        "content": "Imho, theoretically, time complexity should be O(No. of Ages) = O(No. of Person) as loops are always running for constant no. of times i.e.120 * 120 times and space complexity is always O(121) = O(1) for the counting array size. \\uD83E\\uDD14"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Using a sliding window this can be done in O(n). You need to iterate through the input at least once, there is no getting around that, therefore at a minimum its O(n). An O(1) solution requires you dont need to process input, and thats not possible for this problem. "
                    },
                    {
                        "username": "OrestKlymko",
                        "content": "[16,17,18] - Friend requests are made 17 -> 16, 18 -> 17, but why don\\'t 18 -> 16???"
                    }
                ]
            },
            {
                "id": 1565764,
                "content": [
                    {
                        "username": "elvinyang",
                        "content": "age[B] > age[A] and age[B] > 100 && age[A] < 100, isn\\'t the latter redundant?"
                    },
                    {
                        "username": "zpcore",
                        "content": "How can all the people in the world only love the younger people? No couple will love each other in this way."
                    },
                    {
                        "username": "sima",
                        "content": "I can find 69->56, 69->48, 56->48\\n\\n101 cannot make friend requests to anyone\\n\\nNo one make friend request to 30, 69*0.5+7 > 30, 48*0.5+7 > 30, 56 * 0.5 + 7 > 30\\n\\nI can only find 3. where is the 4th one?"
                    },
                    {
                        "username": "ianpan870102",
                        "content": "As titled, the third condition is useless. The second condition completely overrides it."
                    },
                    {
                        "username": "BiggestChungus",
                        "content": "`age[y] <= 0.5 * age[x] + 7`\\n\\nlol this was a meme from about 15 years ago right??"
                    },
                    {
                        "username": "Engineerr",
                        "content": "Just to see if you fit in the company culture, never make friends with new hire, stay away from VP/director."
                    },
                    {
                        "username": "parag_meshram",
                        "content": "Imho, theoretically, time complexity should be O(No. of Ages) = O(No. of Person) as loops are always running for constant no. of times i.e.120 * 120 times and space complexity is always O(121) = O(1) for the counting array size. \\uD83E\\uDD14"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Using a sliding window this can be done in O(n). You need to iterate through the input at least once, there is no getting around that, therefore at a minimum its O(n). An O(1) solution requires you dont need to process input, and thats not possible for this problem. "
                    },
                    {
                        "username": "OrestKlymko",
                        "content": "[16,17,18] - Friend requests are made 17 -> 16, 18 -> 17, but why don\\'t 18 -> 16???"
                    }
                ]
            },
            {
                "id": 1570680,
                "content": [
                    {
                        "username": "elvinyang",
                        "content": "age[B] > age[A] and age[B] > 100 && age[A] < 100, isn\\'t the latter redundant?"
                    },
                    {
                        "username": "zpcore",
                        "content": "How can all the people in the world only love the younger people? No couple will love each other in this way."
                    },
                    {
                        "username": "sima",
                        "content": "I can find 69->56, 69->48, 56->48\\n\\n101 cannot make friend requests to anyone\\n\\nNo one make friend request to 30, 69*0.5+7 > 30, 48*0.5+7 > 30, 56 * 0.5 + 7 > 30\\n\\nI can only find 3. where is the 4th one?"
                    },
                    {
                        "username": "ianpan870102",
                        "content": "As titled, the third condition is useless. The second condition completely overrides it."
                    },
                    {
                        "username": "BiggestChungus",
                        "content": "`age[y] <= 0.5 * age[x] + 7`\\n\\nlol this was a meme from about 15 years ago right??"
                    },
                    {
                        "username": "Engineerr",
                        "content": "Just to see if you fit in the company culture, never make friends with new hire, stay away from VP/director."
                    },
                    {
                        "username": "parag_meshram",
                        "content": "Imho, theoretically, time complexity should be O(No. of Ages) = O(No. of Person) as loops are always running for constant no. of times i.e.120 * 120 times and space complexity is always O(121) = O(1) for the counting array size. \\uD83E\\uDD14"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Using a sliding window this can be done in O(n). You need to iterate through the input at least once, there is no getting around that, therefore at a minimum its O(n). An O(1) solution requires you dont need to process input, and thats not possible for this problem. "
                    },
                    {
                        "username": "OrestKlymko",
                        "content": "[16,17,18] - Friend requests are made 17 -> 16, 18 -> 17, but why don\\'t 18 -> 16???"
                    }
                ]
            },
            {
                "id": 2014524,
                "content": [
                    {
                        "username": "elvinyang",
                        "content": "age[B] > age[A] and age[B] > 100 && age[A] < 100, isn\\'t the latter redundant?"
                    },
                    {
                        "username": "zpcore",
                        "content": "How can all the people in the world only love the younger people? No couple will love each other in this way."
                    },
                    {
                        "username": "sima",
                        "content": "I can find 69->56, 69->48, 56->48\\n\\n101 cannot make friend requests to anyone\\n\\nNo one make friend request to 30, 69*0.5+7 > 30, 48*0.5+7 > 30, 56 * 0.5 + 7 > 30\\n\\nI can only find 3. where is the 4th one?"
                    },
                    {
                        "username": "ianpan870102",
                        "content": "As titled, the third condition is useless. The second condition completely overrides it."
                    },
                    {
                        "username": "BiggestChungus",
                        "content": "`age[y] <= 0.5 * age[x] + 7`\\n\\nlol this was a meme from about 15 years ago right??"
                    },
                    {
                        "username": "Engineerr",
                        "content": "Just to see if you fit in the company culture, never make friends with new hire, stay away from VP/director."
                    },
                    {
                        "username": "parag_meshram",
                        "content": "Imho, theoretically, time complexity should be O(No. of Ages) = O(No. of Person) as loops are always running for constant no. of times i.e.120 * 120 times and space complexity is always O(121) = O(1) for the counting array size. \\uD83E\\uDD14"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Using a sliding window this can be done in O(n). You need to iterate through the input at least once, there is no getting around that, therefore at a minimum its O(n). An O(1) solution requires you dont need to process input, and thats not possible for this problem. "
                    },
                    {
                        "username": "OrestKlymko",
                        "content": "[16,17,18] - Friend requests are made 17 -> 16, 18 -> 17, but why don\\'t 18 -> 16???"
                    }
                ]
            },
            {
                "id": 1574850,
                "content": [
                    {
                        "username": "elvinyang",
                        "content": "age[B] > age[A] and age[B] > 100 && age[A] < 100, isn\\'t the latter redundant?"
                    },
                    {
                        "username": "zpcore",
                        "content": "How can all the people in the world only love the younger people? No couple will love each other in this way."
                    },
                    {
                        "username": "sima",
                        "content": "I can find 69->56, 69->48, 56->48\\n\\n101 cannot make friend requests to anyone\\n\\nNo one make friend request to 30, 69*0.5+7 > 30, 48*0.5+7 > 30, 56 * 0.5 + 7 > 30\\n\\nI can only find 3. where is the 4th one?"
                    },
                    {
                        "username": "ianpan870102",
                        "content": "As titled, the third condition is useless. The second condition completely overrides it."
                    },
                    {
                        "username": "BiggestChungus",
                        "content": "`age[y] <= 0.5 * age[x] + 7`\\n\\nlol this was a meme from about 15 years ago right??"
                    },
                    {
                        "username": "Engineerr",
                        "content": "Just to see if you fit in the company culture, never make friends with new hire, stay away from VP/director."
                    },
                    {
                        "username": "parag_meshram",
                        "content": "Imho, theoretically, time complexity should be O(No. of Ages) = O(No. of Person) as loops are always running for constant no. of times i.e.120 * 120 times and space complexity is always O(121) = O(1) for the counting array size. \\uD83E\\uDD14"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Using a sliding window this can be done in O(n). You need to iterate through the input at least once, there is no getting around that, therefore at a minimum its O(n). An O(1) solution requires you dont need to process input, and thats not possible for this problem. "
                    },
                    {
                        "username": "OrestKlymko",
                        "content": "[16,17,18] - Friend requests are made 17 -> 16, 18 -> 17, but why don\\'t 18 -> 16???"
                    }
                ]
            },
            {
                "id": 1573685,
                "content": [
                    {
                        "username": "elvinyang",
                        "content": "age[B] > age[A] and age[B] > 100 && age[A] < 100, isn\\'t the latter redundant?"
                    },
                    {
                        "username": "zpcore",
                        "content": "How can all the people in the world only love the younger people? No couple will love each other in this way."
                    },
                    {
                        "username": "sima",
                        "content": "I can find 69->56, 69->48, 56->48\\n\\n101 cannot make friend requests to anyone\\n\\nNo one make friend request to 30, 69*0.5+7 > 30, 48*0.5+7 > 30, 56 * 0.5 + 7 > 30\\n\\nI can only find 3. where is the 4th one?"
                    },
                    {
                        "username": "ianpan870102",
                        "content": "As titled, the third condition is useless. The second condition completely overrides it."
                    },
                    {
                        "username": "BiggestChungus",
                        "content": "`age[y] <= 0.5 * age[x] + 7`\\n\\nlol this was a meme from about 15 years ago right??"
                    },
                    {
                        "username": "Engineerr",
                        "content": "Just to see if you fit in the company culture, never make friends with new hire, stay away from VP/director."
                    },
                    {
                        "username": "parag_meshram",
                        "content": "Imho, theoretically, time complexity should be O(No. of Ages) = O(No. of Person) as loops are always running for constant no. of times i.e.120 * 120 times and space complexity is always O(121) = O(1) for the counting array size. \\uD83E\\uDD14"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Using a sliding window this can be done in O(n). You need to iterate through the input at least once, there is no getting around that, therefore at a minimum its O(n). An O(1) solution requires you dont need to process input, and thats not possible for this problem. "
                    },
                    {
                        "username": "OrestKlymko",
                        "content": "[16,17,18] - Friend requests are made 17 -> 16, 18 -> 17, but why don\\'t 18 -> 16???"
                    }
                ]
            },
            {
                "id": 2070855,
                "content": [
                    {
                        "username": "elvinyang",
                        "content": "age[B] > age[A] and age[B] > 100 && age[A] < 100, isn\\'t the latter redundant?"
                    },
                    {
                        "username": "zpcore",
                        "content": "How can all the people in the world only love the younger people? No couple will love each other in this way."
                    },
                    {
                        "username": "sima",
                        "content": "I can find 69->56, 69->48, 56->48\\n\\n101 cannot make friend requests to anyone\\n\\nNo one make friend request to 30, 69*0.5+7 > 30, 48*0.5+7 > 30, 56 * 0.5 + 7 > 30\\n\\nI can only find 3. where is the 4th one?"
                    },
                    {
                        "username": "ianpan870102",
                        "content": "As titled, the third condition is useless. The second condition completely overrides it."
                    },
                    {
                        "username": "BiggestChungus",
                        "content": "`age[y] <= 0.5 * age[x] + 7`\\n\\nlol this was a meme from about 15 years ago right??"
                    },
                    {
                        "username": "Engineerr",
                        "content": "Just to see if you fit in the company culture, never make friends with new hire, stay away from VP/director."
                    },
                    {
                        "username": "parag_meshram",
                        "content": "Imho, theoretically, time complexity should be O(No. of Ages) = O(No. of Person) as loops are always running for constant no. of times i.e.120 * 120 times and space complexity is always O(121) = O(1) for the counting array size. \\uD83E\\uDD14"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Using a sliding window this can be done in O(n). You need to iterate through the input at least once, there is no getting around that, therefore at a minimum its O(n). An O(1) solution requires you dont need to process input, and thats not possible for this problem. "
                    },
                    {
                        "username": "OrestKlymko",
                        "content": "[16,17,18] - Friend requests are made 17 -> 16, 18 -> 17, but why don\\'t 18 -> 16???"
                    }
                ]
            }
        ]
    }
]